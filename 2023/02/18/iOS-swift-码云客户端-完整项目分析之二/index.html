<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="iOS swift 码云客户端 完整项目分析之二, Android iOS Flutter">
    <meta name="baidu-site-verification" content="fmlEuI34ir" />
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48" />
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7" />
    <meta name="description" content="1 项目地址
https://gitee.com/oschina/git-osc-iphone使用Swift语言重构的码云iOS客户端，采用MVVM设计模式与POP(面向协议编程)，核心框架为RxSwift。 

此篇文章讲解，如何构造一个">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>iOS swift 码云客户端 完整项目分析之二 | JasonToJan&#39;s Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?ce84511d3df71640a9378a69f6293044";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">JasonToJan's Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <i class="fa fa-comments"></i>
            
            <span>留言板</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">JasonToJan's Blog</div>
        <div class="logo-desc">
            
            专注移动端，热爱生活，热衷开发。
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-comments"></i>
                
                留言板
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/JasonToJan/hexo-matery-modified" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/JasonToJan/hexo-matery-modified" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/24.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        iOS swift 码云客户端 完整项目分析之二
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                        <a href="/tags/%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE-RxSwift/" target="_blank">
                            <span class="chip bg-color">完整项目 RxSwift</span>
                        </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                        <a href="/categories/iOS/" class="post-category" target="_blank">
                            iOS
                        </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-02-18
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    Jason
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    8k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    37 分
                </div>
                
                

                
                <div id="busuanzi_container_page_pv" class="info-break-policy">
                    <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                    <span id="busuanzi_value_page_pv"></span>
                </div>
                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="1-项目地址"><a href="#1-项目地址" class="headerlink" title="1 项目地址"></a>1 项目地址</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://gitee.com/oschina/git-osc-iphone">https://gitee.com/oschina/git-osc-iphone</a><br>使用Swift语言重构的码云iOS客户端，采用MVVM设计模式与POP(面向协议编程)，核心框架为RxSwift。 </p>
</blockquote>
<p>此篇文章讲解，如何构造一个3个Tab列表，列表请求网络，封装数据流对接RxSwift总体架构。<br>效果如下：<br><img src=mayun_201.png width=50%></p>
<h2 id="2-入口"><a href="#2-入口" class="headerlink" title="2 入口"></a>2 入口</h2><pre><code class="line-numbers language-Swift">
/// Coordinator负责Controller之间的调度和为Controller提供ViewModel对象
final class Coordinator &#123;

/// 我们需要在当前类中访问和修改这个属性的值，而在类外部只允许访问这个属性的值而不能修改它
private(set) var mRootController: MyTabBarController?

init() &#123;
    // 项目tab
    let projrctsController = MyPageViewController(
        controllers: [
            getItemsControllerWith(type: .featuredProjs),
            getItemsControllerWith(type: .popularProjs),
            getItemsControllerWith(type: .latestProjs)],
        titles: [String.Local.featured, String.Local.popular, String.Local.latest])
    projrctsController.navigationItem.title = String.Local.projects
    let projrctsNaviController = UINavigationController(rootViewController: projrctsController)
    
    // 发现tab
    let discoverNaviController: UINavigationController = UINavigationController(rootViewController: getLoginSecondController())
    
    // 我的tab
    let mineNaviControlelr: UINavigationController = UINavigationController(rootViewController: getLoginController())
    
    mRootController = MyTabBarController(childControllers: [projrctsNaviController, discoverNaviController, mineNaviControlelr], titles: [String.Local.projects, String.Local.discover, String.Local.mine], normalImags: [#imageLiteral(resourceName: &quot;projects&quot;), #imageLiteral(resourceName: &quot;discover&quot;), #imageLiteral(resourceName: &quot;mine&quot;)], selectedImgs: [#imageLiteral(resourceName: &quot;projects_selected&quot;), #imageLiteral(resourceName: &quot;discover_selected&quot;), #imageLiteral(resourceName: &quot;mine_selected&quot;)])
&#125;
</code></pre>
<p>首先是在AppDelegate里面new了一个这个对象，主要是统一管理控制器。<br>然后在它构造函数中，将项目的UINavigationController，和发现和我的添加到一个自定义的TabBarController。<br>App总体架构如上。<br>我们主要分析项目的UINavigationController怎么实现。</p>
<h2 id="3-项目页构造"><a href="#3-项目页构造" class="headerlink" title="3 项目页构造"></a>3 项目页构造</h2><pre><code class="line-numbers language-Swift">class MyPageViewController: UIViewController, ProtocolBindable, ProtocolPageViewPresentable &#123;
</code></pre>
<p>首先是自定义的UIViewController。</p>
<h3 id="3-1-ProtocolBindable协议相关联"><a href="#3-1-ProtocolBindable协议相关联" class="headerlink" title="3.1 ProtocolBindable协议相关联"></a>3.1 ProtocolBindable协议相关联</h3><p>实现协议ProtocolBindable，这个很简单：</p>
<pre><code class="line-numbers language-Swift">protocol ProtocolBindable &#123;
    var disposeBag: DisposeBag &#123;get&#125;
&#125;
</code></pre>
<p>主要处理RxSwift的内存泄漏问题。</p>
<p>注意到这个协议做了扩展：</p>
<pre><code class="line-numbers language-Swift">extension ProtocolBindable where Self: NetAccessableControllerType &#123;
    /// 网络请求相关的视图绑定
    func bindRequestViews() &#123;
        let viewModel = self.viewModel
        if let self = self as? TextHUDPresentable &amp; UIViewController &#123;
            viewModel.textHUDConfig.drive(self.textHUD.rx.textConfig).disposed(by: disposeBag)
        &#125;
        if let self = self as? ErrorViewPresentable &amp; UIViewController &amp; ProtocolBindable &#123;
            viewModel.errorViewConfig.drive(self.errorView.rx.config).disposed(by: disposeBag)
        &#125;
        if let self = self as? IndicatorPresentable &amp; UIViewController &#123;
            viewModel.request.mapAsVoid().bind(to: self.indicator.rx.hide).disposed(by: disposeBag)
        &#125;
    &#125;
&#125;
</code></pre>
<p>这里对协议进行了约束</p>
<blockquote>
<p>这个协议扩展有一个约束条件，即只有实现了NetAccessableControllerType协议的类（class）才可以使用它。</p>
</blockquote>
<p>需要继续看下NetAccessableControllerType协议：</p>
<pre><code class="line-numbers language-Swift">protocol NetAccessableControllerType: BaseControllerType, NetAccessable &#123;
    /// 协议中使用泛型的解决方案
    associatedtype V: BaseViewMoelType
    var viewModel: V &#123; get &#125;
&#125;
</code></pre>
<p>这里定义了ViewModel了。<br>这个协议又继承了子协议，需要继续看：</p>
<pre><code class="line-numbers language-Swift">protocol BaseControllerType: ProtocolBindable, HasDelegate where Delegate == PushableControllerDelegate, Self: UIViewController &#123; &#125;
</code></pre>
<blockquote>
<p>这段代码定义了一个名为BaseControllerType的协议，它包含了以下几个特性：<br>继承了ProtocolBindable协议：即实现了这个协议的类必须符合ProtocolBindable协议的要求。<br>继承了HasDelegate协议：即实现了这个协议的类必须符合HasDelegate协议的要求，其中Delegate必须是PushableControllerDelegate类型。<br>继承了UIViewController类：即实现了这个协议的类必须是UIViewController或其子类。<br>通过这个协议的定义，我们可以得出以下理解：<br>实现了BaseControllerType协议的类，必须是继承自UIViewController的类，并且同时实现了ProtocolBindable协议和HasDelegate协议，其中HasDelegate协议要求这个类的Delegate属性的类型必须是PushableControllerDelegate类型。<br>因此，这个协议可以用于约束那些需要同时具有ProtocolBindable和HasDelegate特性，并且必须是UIViewController或其子类的类。通常情况下，实现了BaseControllerType协议的类是视图控制器（ViewController），因为它们通常需要具有与导航和推送相关的特性。</p>
</blockquote>
<p>HasDelegate是RxCocoa三方库中的协议。<br>需要看下PushableControllerDelegate协议：</p>
<pre><code class="line-numbers language-Swift">protocol PushableControllerDelegate: class &#123;
    
    func pushUserControllerWith(userId: Int64, userName: String, navigation: UINavigationController?)
    
    func pushItemsControllerWith(type: ItemsType, item: Item?, navigation: UINavigationController?)
    
    func pushItemControllerWith(type: ItemType, item: Item?, navigation: UINavigationController?)
    
    func pushImageControllerWith(type: BlobFileType, navigation: UINavigationController?)
    
    func pushHtmlControllerWith(type: BlobFileType, navigation: UINavigationController?)
    
    func pushLoginControllerWith(navigation: UINavigationController?)
    
    func pushProjectsSearchControllerWith(navigation: UINavigationController?)
    
    func pushSettingControlelrWith(navigation: UINavigationController?)
    
    func pushMineControllerWith(navigation: UINavigationController?)
    
    func pushIssueCreateControllerWith(projectID: Int64?, navigation: UINavigationController?)
&#125;
</code></pre>
<p>这个应该是跳转逻辑。</p>
<p>另外那个网络协议为：</p>
<pre><code class="line-numbers language-Swift">protocol NetAccessable &#123;
    func request()
&#125;
</code></pre>
<p>应该是发起网络。</p>
<p>然后是关注下ProtocalBindable</p>
<p>需要看下这里：</p>
<pre><code class="line-numbers language-Swift">protocol NetAccessableControllerType: BaseControllerType, NetAccessable &#123;
    /// 协议中使用泛型的解决方案
    associatedtype V: BaseViewMoelType
    var viewModel: V &#123; get &#125;
&#125;
</code></pre>
<p>定义了ViewModel。<br>这个ViewModel需要继承BaseViewModelType。</p>
<pre><code class="line-numbers language-Swift">protocol BaseViewMoelType: class &#123;
    
    associatedtype E
    
    var errorViewConfig: Driver&lt;(Bool, (String?, UIImage?))&gt; &#123; get &#125;
    
    var textHUDConfig: Driver&lt;(Bool, String?)&gt; &#123; get &#125;
    
    var navigationTitle: Driver&lt;String?&gt; &#123; get &#125;
    
    /// request是指控制器在window显示后默认产生的网络请求数据流
    var request: Observable&lt;(E)&gt; &#123;get set&#125;
    
    ///actionRequest是指与UI交互产生的次要网络请求数据流
    func actionRequestWith&lt;T&gt;(api: ActionAPI) -&gt; Observable&lt;T&gt;?
&#125;
</code></pre>
<p>这里定义ViewModel基础行为。可以驱动显示异常View，标题名称，请求，交互行为，这里交互行为用到了一个ActionAPI，需要看下：</p>
<pre><code class="line-numbers language-Swift">enum ActionAPI &#123;
    case starProject(String)
    case unstarProject(String)
    case watchProject(String)
    case unwatchProject(String)
    case createIssue(proID: Int64, title: String, description: String)
    case login(email: String?, password: String?)
    case none
&#125;
</code></pre>
<p>基础行为，这里可以start或者watch一个project。<br>另外BaseViewMoelType扩展了下，其实就是默认实现了：</p>
<pre><code class="line-numbers language-Swift">
/// 协议默认实现
extension BaseViewMoelType &#123;
    
    func actionRequestWith&lt;T&gt;(api: ActionAPI) -&gt; Observable&lt;T&gt;? &#123; return nil &#125;
    
    var errorViewConfig: Driver&lt;(Bool, (String?, UIImage?))&gt; &#123;
        return request.asErrorViewConfig()
    &#125;
    var textHUDConfig: Driver&lt;(Bool, String?)&gt; &#123;
        return request.asTextHUDConfig()
    &#125;
    func setActionRequestAsMain(_ actionApi: ActionAPI) &#123;
        self.request = actionRequestWith(api: actionApi)!
    &#125;
    
    func createActionRequest&lt;T&gt;(with api: ActionAPI, creation: @escaping (AnyObserver&lt;T&gt;)-&gt;() ) -&gt; Observable&lt;T&gt;? &#123;
        switch api &#123;
        case .none: return Observable.error(RequestError.requestFailed(nil))
        default: return Observable&lt;T&gt;.create(&#123; (observer) -&gt; Disposable in
            creation(observer)
            return Disposables.create()
        &#125;).share(replay: 1)
    &#125;
        
    &#125;
&#125;
</code></pre>
<h3 id="3-2-ProtocolPageViewPresentable协议"><a href="#3-2-ProtocolPageViewPresentable协议" class="headerlink" title="3.2 ProtocolPageViewPresentable协议"></a>3.2 ProtocolPageViewPresentable协议</h3><p>另外一个协议：</p>
<pre><code class="line-numbers language-Swift">protocol ProtocolPageViewPresentable &#123;
    var titles: [String] &#123;get&#125;
    var pageViewManager: DNSPageViewManager &#123; get &#125;
&#125;
</code></pre>
<p>主要是配置入参，顶部标题列表，和一个控制器。</p>
<p>这个DNSPageViewManager，其实用到了一个三方库，这里只是把它copy到本地了。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/Danie1s/DNSPageView">https://github.com/Danie1s/DNSPageView</a> 现在还有人维护呢。</p>
</blockquote>
<p>另外它扩展了：</p>
<pre><code class="line-numbers language-Swift">
/// 它通过 where 子句指定了扩展的约束条件，即 PageViewPresentable 协议同时也是 Bindable 和 UIViewController 的子协议。
/// 意思就是在 UIViewController+Bindable 的类中才可使用这个扩展方法
extension ProtocolPageViewPresentable where Self: ProtocolBindable &amp; UIViewController &#123;
    
    func setupNavigationTitleStyle() &#123;
        let titleView = pageViewManager.titleView
        titleView.frame = CGRect.init(x: 0, y: 0, width: .screenWidth, height: 84)
        view.addSubview(titleView)
        view.addSubview(pageViewManager.contentView)
        
        navigationItem.titleView = titleView
        
        pageViewManager.contentView.snp.makeConstraints &#123;[weak self] (maker) in
            maker.edgesEqualTo(view: self?.view, with: self)
        &#125;
    &#125;
    
    func setupCustomStyle() &#123;
        let titleView = pageViewManager.titleView
        titleView.frame = CGRect.init(x: 0, y: 0, width: .screenWidth, height: 44)
        view.addSubview(titleView)
        view.addSubview(pageViewManager.contentView)
        
        NightModeViewModel.shared.pageViewStyle.bind(to: pageViewManager.rx.titleStyle).disposed(by: disposeBag)
        
        pageViewManager.contentView.snp.makeConstraints &#123; (maker) in
            maker.top.equalToSuperview().offset(40)
            if #available(iOS 11, *) &#123;
                maker.leading.equalTo(view.safeAreaLayoutGuide.snp.leading)
                maker.trailing.equalTo(view.safeAreaLayoutGuide.snp.trailing)
                maker.bottom.equalTo(view.safeAreaLayoutGuide.snp.bottom)
            &#125;
            else &#123;
                maker.leading.trailing.equalToSuperview()
                maker.bottom.equalTo(bottomLayoutGuide.snp.top)
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>这里setupNavigationTitleStyle 方法非常关键，将pageViewManger的contentView加进去了。<br>这里才可正常显示。<br>调用地方再MyPageViewController中的viewDidLoad()。</p>
<pre><code>override func viewDidLoad() &#123;
    super.viewDidLoad()
    setupNavigationTitleStyle()
&#125;
</code></pre>
<h3 id="3-3-构造函数"><a href="#3-3-构造函数" class="headerlink" title="3.3 构造函数"></a>3.3 构造函数</h3><p>变量声明：</p>
<pre><code class="line-numbers language-Swift">    var disposeBag: DisposeBag = .init()
    
    let titles: [String]
    
    let pageViewManager: DNSPageViewManager
    
</code></pre>
<p>构造函数：</p>
<pre><code class="line-numbers language-Swift">init(controllers: [UIViewController], titles: [String]) &#123;
    pageViewManager = .init(style: .navigationTitle, titles: titles, childViewControllers: controllers)
    self.titles = titles
    super.init(nibName: nil, bundle: nil)
    for vc in controllers &#123;
        self.addChild(vc)
    &#125;
&#125;
</code></pre>
<p>这里传3个Tab的UIViewController，和标题名称。</p>
<h3 id="3-4-第一次加载"><a href="#3-4-第一次加载" class="headerlink" title="3.4 第一次加载"></a>3.4 第一次加载</h3><pre><code class="line-numbers language-Swift">override func viewDidLoad() &#123;
    super.viewDidLoad()
    setupNavigationTitleStyle()
&#125;
</code></pre>
<p>这里是生命周期，将视图添加进去了，使用方法为 ProtocalPageViewPresetable中的协议扩展方法，就是上面3.2所示。</p>
<h2 id="4-单个列表控制器ProjectsController"><a href="#4-单个列表控制器ProjectsController" class="headerlink" title="4 单个列表控制器ProjectsController"></a>4 单个列表控制器ProjectsController</h2><h3 id="4-1-入口"><a href="#4-1-入口" class="headerlink" title="4.1 入口"></a>4.1 入口</h3><p>在Coordinator中：</p>
<pre><code class="line-numbers language-Swift">/// Coordinator负责Controller之间的调度和为Controller提供ViewModel对象
final class Coordinator &#123;
    
    /// 我们需要在当前类中访问和修改这个属性的值，而在类外部只允许访问这个属性的值而不能修改它
    private(set) var mRootController: MyTabBarController?
    
    init() &#123;
        // 项目tab
        let projrctsController = MyPageViewController(
            controllers: [
                getItemsControllerWith(type: .featuredProjs),
                getItemsControllerWith(type: .popularProjs),
                getItemsControllerWith(type: .latestProjs)],
</code></pre>
<p>这里其实推荐，热门，最近更新的这三个tab全是这个通用的ItemsController。</p>
<pre><code class="line-numbers language-Swift">private func getItemsControllerWith(type: ItemsType, item: Item? = nil) -&gt; UIViewController &#123;
    switch type &#123;
    case .featuredProjs, .popularProjs, .latestProjs, .userProjs(_), .languagedProjs(_), .staredProjs(_), .watchedProjs(_):
        return ProjectsController(viewModel: .init(store: .init(type: type)), delegate: self)
</code></pre>
<p>这里return 一个ProjectsController()。</p>
<h3 id="4-2-继承关系和全局变量"><a href="#4-2-继承关系和全局变量" class="headerlink" title="4.2 继承关系和全局变量"></a>4.2 继承关系和全局变量</h3><pre><code class="line-numbers language-Swift">class ProjectsController: UIViewController, ItemsController &#123;
</code></pre>
<p>这里继承了UIViewController。<br>同时也实现了ItemsController协议。</p>
<pre><code class="line-numbers language-Swift">protocol ItemsController: NetAccessableControllerType, TableViewPresentable, HintViewsPresentable where V: ItemsViewModelType &#123;
    
    var isRefreshable: Bool &#123; get &#125;
    
    var isPageable: Bool &#123; get &#125;
    
&#125;
</code></pre>
<p>这里定义了三个约束条件。</p>
<blockquote>
<p>这段代码是一个协议（protocol）的声明，其中定义了三个约束条件，分别是：<br>NetAccessableControllerType: 表示实现这个协议的类型必须能够访问网络，即实现了相关的网络请求方法和属性。<br>TableViewPresentable: 表示实现这个协议的类型必须能够在界面上呈现一个表格（UITableView），即实现了相关的UITableViewDataSource和UITableViewDelegate协议的方法。<br>HintViewsPresentable: 表示实现这个协议的类型必须能够在界面上呈现提示视图（hint views），即实现了相关的提示视图显示和隐藏的方法和属性。<br>在这个协议声明中还使用了一个泛型（generic）类型参数V，它是一个符合ItemsViewModelType协议的类型。这个协议的实现者需要提供一个实现了ItemsViewModelType协议的属性viewModel，以便在协议中使用。<br>因此，这个协议的意义是：实现它的类型需要满足上述三个约束条件，同时提供一个符合ItemsViewModelType协议的viewModel属性，以便协议中可以调用它所提供的方法和属性。</p>
</blockquote>
<p>Item的控制器的协议需要实现1：</p>
<pre><code class="line-numbers language-Swift">protocol NetAccessableControllerType: BaseControllerType, NetAccessable &#123;
    /// 协议中使用泛型的解决方案
    associatedtype V: BaseViewMoelType
    var viewModel: V &#123; get &#125;
&#125;
</code></pre>
<p>这个应该是用ViewModel的。</p>
<p>Item的控制器的协议需要实现2：</p>
<pre><code class="line-numbers language-Swift">protocol TableViewPresentable: NightModeChangable, UITableViewDelegate &#123;
    var tableView: UITableView &#123; get &#125;
    var cellInfo: [(String, RegisteredViewType)] &#123; get &#125;
    /// 需要在调用协议代理之前初始化
    var tableViewDelegate: RxTableViewSectionedReloadDelegate &#123; get &#125;
    func cellReuseIdentifier(for indexPath: IndexPath) -&gt; String
    func setupCell(_ cell: UITableViewCell, with indexPath: IndexPath)
&#125;
</code></pre>
<p>这里应该是用来展示TableView的。并且内部继承夜间模式和UiTableViewDelegate。</p>
<p>Item的控制器的协议需要实现3：</p>
<pre><code class="line-numbers language-Swift">typealias HintViewsPresentable = TextHUDPresentable &amp; IndicatorPresentable &amp; ErrorViewPresentable
</code></pre>
<p>这里是一个显示视图的协议。</p>
<p>看下TextHUDPresentable：</p>
<pre><code class="line-numbers language-Swift">protocol TextHUDPresentable: class &#123; &#125;
</code></pre>
<p>虽然是空协议，但是下面扩展了：</p>
<pre><code class="line-numbers language-Swift">private var associatedKey = &quot;TextHUD&quot;

//MARK:- TextHUDPresentable
protocol TextHUDPresentable: class &#123; &#125;


extension TextHUDPresentable where Self: UIViewController &#123;
    var textHUD: MBProgressHUD &#123;
        get &#123;
            guard let res = objc_getAssociatedObject(self, &amp;associatedKey) as? MBProgressHUD else &#123;
                fatalError(&quot;It should be set before used&quot;)
            &#125;
            return res
        &#125;
        
        set &#123;
            objc_setAssociatedObject(self, &amp;associatedKey, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
        &#125;
    &#125;
    
    func setupTextHUD() &#123;
        textHUD = MBProgressHUD()
        textHUD.label.adjustsFontSizeToFitWidth = true
        textHUD.mode = .text
        view.addSubview(textHUD)
    &#125;
&#125;
</code></pre>
<p>还有一个是协议：</p>
<pre><code class="line-numbers language-Swift">protocol IndicatorPresentable: DNSPageEventHandleable &#123; &#125;
</code></pre>
<p>这个应该是DNSPage事件相关的。</p>
<pre><code class="line-numbers language-Swift">/// DNSPageView的事件回调，如果有需要，请让对应的childViewController遵守这个协议
 public protocol DNSPageEventHandleable: class &#123;
    
    /// 重复点击pageTitleView后调用
    func titleViewDidSelectSameTitle()
    
    /// pageContentView的上一页消失的时候，上一页对应的controller调用
    func contentViewDidDisappear()
    
    /// pageContentView滚动停止的时候，当前页对应的controller调用
    func contentViewDidEndScroll()
    
    func contentViewDidFirstLoad()
    
    func contentViewWillAppear()
&#125;
</code></pre>
<p>这个定义在三方库里面了。</p>
<p>最后一个是：</p>
<pre><code class="line-numbers language-Swift">protocol ErrorViewPresentable: class &#123;&#125;
</code></pre>
<p>应该是用来展示异常视图的：</p>
<pre><code class="line-numbers language-Swift">extension ErrorViewPresentable where Self: UIViewController &amp; ProtocolBindable &#123;
    
    var errorView: ErrorView &#123;
        set &#123;
            
            objc_setAssociatedObject(self, &amp;associatedKey, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
        &#125;
        
        get &#123;
            return castOrFatalError(objc_getAssociatedObject(self, &amp;associatedKey))
        &#125;
        
    &#125;
    
    func setupErrorView() &#123;
        errorView = ErrorView()
        view.addSubview(errorView)
        errorView.rx.refreshing.startWith(()).bind(to: errorView.rx.hide).disposed(by: disposeBag)
        errorView.snp.makeConstraints &#123; (maker) in
            maker.edges.equalToSuperview()
        &#125;
        NightModeViewModel.shared.normalBackgroud.bind(to: errorView.rx.backgroundColor).disposed(by: disposeBag)
    &#125;
&#125;
</code></pre>
<p>回到ItemsController。<br>这个V应该是NetAccessableControllerType 这里的V。</p>
<h3 id="4-3-ViewModel中的泛型"><a href="#4-3-ViewModel中的泛型" class="headerlink" title="4.3 ViewModel中的泛型"></a>4.3 ViewModel中的泛型</h3><pre><code class="line-numbers language-Swift">protocol ItemsController: NetAccessableControllerType, TableViewPresentable, HintViewsPresentable where V: ItemsViewModelType &#123;
    
    var isRefreshable: Bool &#123; get &#125;
    
    var isPageable: Bool &#123; get &#125;
    
&#125;
</code></pre>
<p>这里用到了一个V。</p>
<pre><code class="line-numbers language-Swift">protocol NetAccessableControllerType: BaseControllerType, NetAccessable &#123;
    /// 协议中使用泛型的解决方案
    associatedtype V: BaseViewMoelType
    var viewModel: V &#123; get &#125;
&#125;
</code></pre>
<p>V指向了这里。</p>
<p>上面V必须是ItemsViewModelType这种类型哦：</p>
<pre><code class="line-numbers language-Swift">protocol ItemsViewModelType: NormalViewModelType where S: ItemsStoreType &#123;
    var initItems: BehaviorRelay&lt;[S.O]&gt; &#123; get &#125;
    var page: BehaviorRelay&lt;Int&gt; &#123; get &#125;
    var loadMore: Observable&lt;()&gt; &#123; get  set &#125;
    ///数据源
    var dataSource: Driver&lt;[S.O]&gt; &#123; get &#125;
    
    var contents: Driver&lt;[Section]&gt; &#123; get &#125;
    
    var cellHeight: Driver&lt;[[CGFloat]]&gt; &#123; get &#125;

&#125;
</code></pre>
<p>哎，这里又得去继承NormalViewModelType了：</p>
<pre><code class="line-numbers language-Swift">/// 遵循MVVM设计模式的ViewModel
protocol NormalViewModelType: BaseViewMoelType where E == () &#123;
    
    associatedtype S: StoreType
    
    var store: S &#123; get &#125;

    /// 用来保证ViewModel和其接受的Notification一一对应
    var uuid: UUID &#123; get &#125;
    
    /// 网络请求的参数
    var requestParam: [String: Any]? &#123; get set &#125;
    
    var isLocalDataExistd: Driver&lt;Bool&gt; &#123; get &#125;
    
    func reset(requestParam: [String: Any]?)
    
&#125;
</code></pre>
<p>这里是一个MVVM模式封装的一个协议。</p>
<p>这里又得去看BaseViewModelType了：</p>
<pre><code class="line-numbers language-Swift">protocol BaseViewMoelType: class &#123;
    
    associatedtype E
    
    var errorViewConfig: Driver&lt;(Bool, (String?, UIImage?))&gt; &#123; get &#125;
    
    var textHUDConfig: Driver&lt;(Bool, String?)&gt; &#123; get &#125;
    
    var navigationTitle: Driver&lt;String?&gt; &#123; get &#125;
    
    /// request是指控制器在window显示后默认产生的网络请求数据流
    var request: Observable&lt;(E)&gt; &#123;get set&#125;
    
    ///actionRequest是指与UI交互产生的次要网络请求数据流
    func actionRequestWith&lt;T&gt;(api: ActionAPI) -&gt; Observable&lt;T&gt;?
&#125;
</code></pre>
<p>可以看到，这里定义了Driver对象，封装请求方法。</p>
<p>回到上面的NormalViewModelType，<br>需要看下里面的一个S: StoreTYpe类型：</p>
<pre><code class="line-numbers language-Swift">protocol StoreType: class &#123;
    associatedtype O: Item
    associatedtype T: TargetType
    var targetType: T &#123; get &#125;
    func request(via param: [String: Any]?, uuid: UUID, observer: AnyObserver&lt;()&gt;)
    
&#125;
</code></pre>
<p>这里又定义了两种泛型，O和T， T应该是目标类，O指定item。</p>
<p>需要看下O到底是什么：</p>
<pre><code class="line-numbers language-Swift">typealias Item = Object &amp; Mappable &amp; RenderableObject
</code></pre>
<blockquote>
<p>Item 类型可以被视为是一个遵循了 Object、Mappable 和 RenderableObject 这三个协议的对象类型。</p>
</blockquote>
<p>T是啥？</p>
<pre><code class="line-numbers language-Swift">protocol TargetType &#123;
    //net
    var baseURL: URL &#123; get &#125;
    var path: String &#123; get &#125;
    var method: HTTPMethod &#123; get &#125;
    var parameters: [String: Any]? &#123; get &#125;
    
    //title for the controller
    var title: String? &#123; get &#125;
    var noDataDescription: String &#123; get &#125;
&#125;
</code></pre>
<p>这里应该是请求类型协议封装。<br>这个Store应该是拿数据的，要么从数据库拿，要么从网络拿。</p>
<p>再回到上面：</p>
<pre><code class="line-numbers language-Swift">protocol ItemsController: NetAccessableControllerType, TableViewPresentable, HintViewsPresentable where V: ItemsViewModelType &#123;
    
    var isRefreshable: Bool &#123; get &#125;
    
    var isPageable: Bool &#123; get &#125;
    
&#125;
</code></pre>
<p>这里V来自NetAccessableControllerType已经分析了。</p>
<p>注意到：</p>
<pre><code class="line-numbers language-Swift">protocol ItemsViewModelType: NormalViewModelType where S: ItemsStoreType &#123;
    var initItems: BehaviorRelay&lt;[S.O]&gt; &#123; get &#125;
    var page: BehaviorRelay&lt;Int&gt; &#123; get &#125;
    var loadMore: Observable&lt;()&gt; &#123; get  set &#125;
    ///数据源
    var dataSource: Driver&lt;[S.O]&gt; &#123; get &#125;
    
    var contents: Driver&lt;[Section]&gt; &#123; get &#125;
    
    var cellHeight: Driver&lt;[[CGFloat]]&gt; &#123; get &#125;

&#125;
</code></pre>
<p>最右边还有一个S: ItemsToreType，<br>S来自哪里呢？</p>
<pre><code class="line-numbers language-Swift">/// 遵循MVVM设计模式的ViewModel
protocol NormalViewModelType: BaseViewMoelType where E == () &#123;
    
    associatedtype S: StoreType
</code></pre>
<p>这里。</p>
<p>上面的</p>
<pre><code class="line-numbers language-Swift"> var initItems: BehaviorRelay&lt;[S.O]&gt; &#123; get &#125;
</code></pre>
<p>怎么理解？</p>
<pre><code class="line-numbers language-Swift">protocol StoreType: class &#123;
    associatedtype O: Item
    associatedtype T: TargetType
    var targetType: T &#123; get &#125;
    func request(via param: [String: Any]?, uuid: UUID, observer: AnyObserver&lt;()&gt;)
    
&#125;
</code></pre>
<p>应该是用的Item哦。</p>
<pre><code class="line-numbers language-Swift">typealias Item = Object &amp; Mappable &amp; RenderableObject
</code></pre>
<p>这样就串联起来了。</p>
<h3 id="4-4-关系图"><a href="#4-4-关系图" class="headerlink" title="4.4 关系图"></a>4.4 关系图</h3><p>太多协议了，需要一个图来理解下。<br><img src=mayun_202.png></p>
<h2 id="5-网络请求全过程"><a href="#5-网络请求全过程" class="headerlink" title="5 网络请求全过程"></a>5 网络请求全过程</h2><h3 id="5-1-在ProjectsController的viewDidLoad生命周期"><a href="#5-1-在ProjectsController的viewDidLoad生命周期" class="headerlink" title="5.1 在ProjectsController的viewDidLoad生命周期"></a>5.1 在ProjectsController的viewDidLoad生命周期</h3><pre><code class="line-numbers language-Swift">override func viewDidLoad() &#123;
        super.viewDidLoad()
        setupSubViews() &#123; [weak self] indexPath in
            guard let project = self?.viewModel.itemsValue[indexPath.row] else &#123; return &#125;
            self?.delegate?.pushItemControllerWith(type: ItemType.projsDetails(project.id), item: project, navigation: self?.navigationController)
        &#125;
    &#125;
</code></pre>
<p>这里调用了setupSubViews，初始化配置tableView了。<br>而且在回调中，声明了点击item事件。这里通过自定义代理，跳转到了某个Item控制器里面了。</p>
<p>这个setupSubViews方法是定义在ItemsController中的，这个就是上方第4点讲述的一个配置了很多协议的主要用来展示列表的一个通用控制器协议。</p>
<h3 id="5-2-通过ItemsController执行setupSubViews"><a href="#5-2-通过ItemsController执行setupSubViews" class="headerlink" title="5.2 通过ItemsController执行setupSubViews"></a>5.2 通过ItemsController执行setupSubViews</h3><pre><code class="line-numbers language-Swift">func setupSubViews(via requestParam: [String: Any]? = nil, itemSelected: @escaping (IndexPath)-&gt;() ) &#123;
        
    if requestParam != nil &#123;
        viewModel.requestParam = requestParam
    &#125;
    
    if isRefreshable &#123; setupRefreshHeader() &#125;
    
    //viewConfig
    setupTableView()
    setupIndicatorWith(backgroundStyle: .normal)
    setupErrorView()
    setupTextHUD()
    request()
    
    /*--------------------binding-----------------------*/
    //标题
    viewModel.navigationTitle.drive(navigationItem.rx.title).disposed(by: disposeBag)
    //载入菊花是否显示
    viewModel.isLocalDataExistd.drive(indicator.rx.isHidden).disposed(by: disposeBag)
    //数据源
    viewModel.contents.drive(tableView.rx.items(dataSource: dataSource)).disposed(by: disposeBag)
    //cell高度
    viewModel.cellHeight.drive(tableView.rx.cellHeights(delegate: tableViewDelegate)).disposed(by: disposeBag)
    //cell点击
    tableView.rx.itemSelected.bind &#123; [weak self] index in
        guard let self = self else &#123; return &#125;
        self.tableView.deselectRow(at: index, animated: true)
        itemSelected(index)
    &#125;.disposed(by: disposeBag)
    
    //是否添加footer
    viewModel.dataSource.filter &#123; $0.count == 20 &#125;.asObservable().bind &#123; [weak self] (_) in
        guard let self = self, self.isPageable else &#123; return &#125;
        self.setupRefreshFooter()
    &#125;.disposed(by: disposeBag)
&#125;
</code></pre>
<p>这里配置了很多关于Cell的属性，最关键的是一个 request方法，和 一个setupRefreshHeader方法。</p>
<p>首先看这里：</p>
<pre><code class="line-numbers language-Swift">if isRefreshable &#123; setupRefreshHeader() &#125;       
</code></pre>
<p>对应：</p>
<pre><code class="line-numbers language-Swift">private func setupRefreshHeader() &#123;
    tableView.mj_header = MJRefreshNormalHeader()
    /*通过直接订阅刷新事件来保证每次网络请求都能重新订阅Observable*/
    //header
    tableView.mj_header?.rx.refreshing.bind &#123; [weak self] in
        guard let s = self else &#123; return &#125;
        //print(RxSwift.Resources.total)
        s.bindRequestViews()
        s.viewModel.request.bind(to: s.tableView.mj_header!.rx.endRefreshing).disposed(by: s.disposeBag)
        &#125;.disposed(by: disposeBag)
&#125;
</code></pre>
<p>这里判断它能否支持刷新，支持的话，在header的refreshing状态下，会触发viewModel走request方法。<br>s就是自己，self的意思，通过自己的viewModel触发request。</p>
<p>什么时候触发这个header走refreshing，不出意外应该是上面的request()方法：</p>
<pre><code class="line-numbers language-Swift">extension ItemsController &#123;
    
    func request() &#123;
        if isRefreshable &#123;
            tableView.mj_header?.beginRefreshing()
            return
        &#125;
        bindRequestViews()
    &#125;
</code></pre>
<p>果然，这里直接利用header走beginRefreshing方法，触发上面的bind，再触发viewModel走request。</p>
<h3 id="5-3-viewModel走request"><a href="#5-3-viewModel走request" class="headerlink" title="5.3 viewModel走request"></a>5.3 viewModel走request</h3><p>首先我们要明白这个viewModel是哪个具体的viewModel。<br>这个itemsController中定义的viewModel来自于这个NetAccessableControllerType协议：</p>
<pre><code class="line-numbers language-Swift">protocol BaseControllerType: ProtocolBindable, HasDelegate where Delegate == PushableControllerDelegate, Self: UIViewController &#123; &#125;

protocol NetAccessableControllerType: BaseControllerType, NetAccessable &#123;
    /// 协议中使用泛型的解决方案
    associatedtype V: BaseViewMoelType
    var viewModel: V &#123; get &#125;
&#125;
</code></pre>
<p>这个ViewModel一定是BaseViewModelType类型的。</p>
<pre><code class="line-numbers language-Swift">protocol BaseViewMoelType: class &#123;
    
    associatedtype E
    
    var errorViewConfig: Driver&lt;(Bool, (String?, UIImage?))&gt; &#123; get &#125;
    
    var textHUDConfig: Driver&lt;(Bool, String?)&gt; &#123; get &#125;
    
    var navigationTitle: Driver&lt;String?&gt; &#123; get &#125;
    
    /// request是指控制器在window显示后默认产生的网络请求数据流
    var request: Observable&lt;(E)&gt; &#123;get set&#125;
    
    ///actionRequest是指与UI交互产生的次要网络请求数据流
    func actionRequestWith&lt;T&gt;(api: ActionAPI) -&gt; Observable&lt;T&gt;?
&#125;
</code></pre>
<p>这个协议定义的request返回的是Observable对象，这个是RxSwift中的类。</p>
<p>回到具体的ProjectsController中，看到了如何定义ViewModel的：</p>
<pre><code class="line-numbers language-Swift">class ProjectsController: UIViewController, ItemsController &#123;
    
    lazy var tableViewDelegate: RxTableViewSectionedReloadDelegate = .init(tableView: self.tableView)
    
    let isRefreshable: Bool = true
    
    let isPageable: Bool = true
    
    let tableView: UITableView = .init()
    
    let disposeBag: DisposeBag = DisposeBag()
    
    let cellInfo: [(String, RegisteredViewType)] = [(&quot;ProjectCell&quot;, .xib)]
    
    let viewModel: ItemsViewModel&lt;ProjectsStore&gt;
</code></pre>
<p>原来是ItemsViewModel，包了一个Store的实现类：ProjectsStore，这个ProjectsStore应该是用来本地网络缓存的，就是拿到网络数据后，磁盘缓存到本地。具体发起网络请求，应该是ItemsViewModel这个实现类。</p>
<p>首先看下这个ItemsViewModel的实现类中的request属性如何定义吧：</p>
<pre><code class="line-numbers language-Swift">
final class ItemsViewModel&lt;S: ItemsStoreType&gt;: ItemsViewModelType &#123;
    
    let initItems: BehaviorRelay&lt;[S.O]&gt;
    
    let uuid = UUID()
    
    lazy var requestParam: [String : Any]? = &#123; return self.defaultParam &#125;()
    
    let store: S
    
    lazy var page = BehaviorRelay(value: 2)
    
    let data = BehaviorSubject&lt;[[Item]]&gt;.init(value: [])
    
    /*---------observable---------------------*/

   //使用存储属性保证序列的唯一性
    lazy var request: Observable&lt;()&gt; = &#123;return self.requestObservable() &#125;()
</code></pre>
<p>这里搞了个闭包，调用了自身的requestObservable方法：</p>
<pre><code class="line-numbers language-Swift">///获取网络请求的序列
func requestObservable() -&gt; Observable&lt;()&gt; &#123;
    let paramaters = requestParam == nil ? defaultParam : requestParam
    return request(via: paramaters).share(replay: 1)
&#125;
</code></pre>
<p>这里是拿到了请求参数，继续走request方法：</p>
<pre><code class="line-numbers language-Swift">func request(via param: [String: Any]?) -&gt; Observable&lt;()&gt; &#123;
    return Observable&lt;()&gt;.create &#123; [weak self] (observer) in
        guard let self = self else &#123;
            observer.onCompleted()
            return Disposables.create()
        &#125;
        //model持有网络
        self.store.request(via: param, uuid: self.uuid, observer: observer)
        return Disposables.create()
    &#125;
&#125;
</code></pre>
<p>最终是走到了上面这个方法，参数为请求接口的参数。</p>
<p>最终将请求委托给自身的store来请求，看来这个store还是有用的，不仅仅用来缓存，网络请求也是它。</p>
<h3 id="5-4-ItemsStoreType走request"><a href="#5-4-ItemsStoreType走request" class="headerlink" title="5.4 ItemsStoreType走request"></a>5.4 ItemsStoreType走request</h3><p>上面因为ProjectController的viewModel是这样定义的：</p>
<pre><code class="line-numbers language-Swift">let viewModel: ItemsViewModel&lt;ProjectsStore&gt;
</code></pre>
<p>而这个ItemsViewModel中是这样要求Store的：</p>
<pre><code class="line-numbers language-Swift">final class ItemsViewModel&lt;S: ItemsStoreType&gt;: ItemsViewModelType &#123;
</code></pre>
<p>所以这个Store应该是需要继承ItemsStoreType的。</p>
<p>如果request方法没有被ProjectsStore重写，那么request方法一定会走ItemsStoreType的request里面。</p>
<p>现在看下ItemsStoreType的request方法吧：</p>
<pre><code class="line-numbers language-Swift">//MARK:- 网络请求
func request(via param: [String: Any]?, uuid: UUID, observer: AnyObserver&lt;()&gt;) &#123;
    HttpsManager.request(with: targetType, parameters: param).responseArray(completionHandler:
        ResponseHandler.handlerArrayResponse(via: observer, target: self.targetType, success: &#123; [weak self] (newItems: [O]) in
            self?.handle(newItems: newItems, via: param, uuid: uuid)
            //发送完成事件避免资源一直被占用
            observer.onCompleted()
    &#125;))
&#125;
</code></pre>
<p>看了下ProjectsStore确实没有重写，而且这个ItemsStoreType自己扩展了这个request方法。</p>
<p>这里通过调用HttpsManager去发起请求了，请求参数通过request参数传进来了。<br>请求结果通过ResponseHandler工具类解析了。</p>
<p>然后通过自身handle方法，调用store的saveItem保存到本地，这个应该是交给store的实现类具体实现。<br>将json格式的数据转成了ItemsStoreType定义的items类型。</p>
<p>items类型就是前面声明的泛型O：</p>
<pre><code class="line-numbers language-Swift">protocol ItemsStoreType: StoreType where T == ItemsType &#123;
    var items: [O] &#123; get set &#125;
    var targetType: ItemsType &#123; get &#125;
    func saveItems(via userInfo: [ResponseKey: Any])
    init(type: ItemsType)
&#125;
</code></pre>
<p>这个泛型O,同样也是在ProjectsStore中进行具体实现：</p>
<pre><code class="line-numbers language-Swift">final class ProjectsStore: ItemsStoreType &#123;
    
    typealias O = Project
</code></pre>
<p>这样，说明ProjectsStore中转换的json的目标实体就是Project实体。</p>
<p>必须要声明typealias哦：</p>
<pre><code class="line-numbers language-Swift">protocol StoreType: class &#123;
    associatedtype O: Item
    associatedtype T: TargetType
    var targetType: T &#123; get &#125;
    func request(via param: [String: Any]?, uuid: UUID, observer: AnyObserver&lt;()&gt;)   
&#125;
</code></pre>
<p>因为ProjectsStore继承ItemsStoreType集成StoreType，<br>这样ProjectsStore就必须实现associatedtype类型了。</p>
<blockquote>
<p>是的，如果一个协议中声明了关联类型（associatedtype），<br>那么在实现该协议的类型中必须要声明一个类型别名（typealias）来具体化该关联类型。<br>这是因为协议中的关联类型是一个占位符，它表示该协议的某些方法或属性的返回值类型或参数类型可以是任何类型，具体的类型要由实现该协议的类型来指定。</p>
</blockquote>
<p>这里json转换，主要利用了一个Objectmapper来帮忙转换：</p>
<pre><code class="line-numbers language-Swift">
struct ResponseHandler &#123;
    
    static func handlerArrayResponse&lt;T: Mappable&gt;(via observer: AnyObserver&lt;()&gt;, target: TargetType, success: @escaping ([T]) -&gt; ()) -&gt; (AFDataResponse&lt;[T]&gt;) -&gt; Void &#123;
        return &#123; dataResponse in
            if let error = dataResponse.error &#123;
                observer.onError(RequestError.requestFailed(error.localizedDescription))
                return
            &#125;
            if let objects = dataResponse.value &#123;
                objects.count == 0 ? observer.onError(RequestError.noData(target.noDataDescription)) : success(objects)
            &#125; else &#123;observer.onError(RequestError.noData(String.Local.noPermission))&#125;
        &#125;
    &#125;
</code></pre>
<p>上面就是将一个数组，转换成一个目标T的数组：<br>ObjectMapper：github地址: <a target="_blank" rel="noopener" href="https://github.com/tristanhimmelman/ObjectMapper">https://github.com/tristanhimmelman/ObjectMapper</a><br>Alamofire: github地址：<a target="_blank" rel="noopener" href="https://github.com/Alamofire/Alamofire">https://github.com/Alamofire/Alamofire</a></p>
<p>如何使用：<br>要使用ObjectMapper将Alamofire获取的JSON数据转换为目标实体，您可以按照以下步骤进行操作：</p>
<p>1).确保您的项目已经集成了ObjectMapper和Alamofire库，并且您已经在文件顶部添加了所需的import语句。</p>
<p>2).定义您的目标实体，并使其符合Mappable协议。例如，如果您有一个名为Person的目标实体，则可以按照以下方式定义它：</p>
<pre><code class="line-numbers language-Swift">import ObjectMapper

class Person: Mappable &#123;
    var name: String?
    var age: Int?
    
    required init?(map: Map) &#123;&#125;
    
    func mapping(map: Map) &#123;
        name &lt;- map[&quot;name&quot;]
        age &lt;- map[&quot;age&quot;]
    &#125;
&#125;
</code></pre>
<p>在上面的代码中，我们定义了一个名为Person的类，并使其符合Mappable协议。该类包含name和age两个属性，它们将从JSON中映射到Person实例的相应属性中。</p>
<p>3).在您的Alamofire请求中，将返回的JSON数据转换为目标实体。您可以按照以下方式进行操作：</p>
<pre><code class="line-numbers language-Swift">import Alamofire
import ObjectMapper

Alamofire.request(&quot;https://example.com/person&quot;).responseJSON &#123; response in
    guard let json = response.result.value as? [String: Any] else &#123;
        return
    &#125;
    if let person = Mapper&lt;Person&gt;().map(JSON: json) &#123;
        // 将person实例用于您的应用程序逻辑
    &#125;
&#125;
</code></pre>
<p>在上面的代码中，我们使用Alamofire发出请求，并在响应中检查是否存在JSON数据。如果有数据，我们使用ObjectMapper将其映射到Person实例中。如果映射成功，我们可以使用person实例进行应用程序逻辑。</p>
<p>这就是如何使用ObjectMapper将Alamofire获取的JSON数据转换为目标实体的步骤。请注意，这只是一个简单的示例，您可能需要根据您的应用程序逻辑进行适当的更改。</p>
<h3 id="5-5-自定义封装的HttpsManager"><a href="#5-5-自定义封装的HttpsManager" class="headerlink" title="5.5 自定义封装的HttpsManager"></a>5.5 自定义封装的HttpsManager</h3><pre><code class="line-numbers language-Swift">
fileprivate let key_urlUpdateDic = &quot;URLUpdateDictionary&quot;

struct HttpsManager &#123;
    /// 不自动产生缓存的SessionManager
    private static let defaultSession: Alamofire.Session = &#123;
        let configuration = URLSessionConfiguration.ephemeral
        //更该其protocolClasses 才能拦截URLSession的网络请求
        configuration.protocolClasses = [HttpsURLProtocol.self]
        return Alamofire.Session(configuration: configuration)
    &#125;()
    //https头
    private static var headers: Alamofire.HTTPHeaders &#123;
        return Alamofire.HTTPHeaders([&quot;User-Agent&quot;: userAgent])
    &#125;
    
    private static var userAgent: String &#123;
        let appVersion = Bundle.main.object(forInfoDictionaryKey: &quot;CFBundleShortVersionString&quot;) as? String ?? &quot;&quot;
        let IDFV = UIDevice.current.identifierForVendor?.uuidString ?? &quot;&quot;
        return String.init(format: &quot;git.OSChina.NET/git_%@/%@/%@/%@/%@&quot;, appVersion, UIDevice.current.systemName, UIDevice.current.systemVersion, UIDevice.current.model, IDFV)
    &#125;
    
    static var urlUpdateDic: [String?: Date]? = &#123;
        return UserDefaults.standard.dictionary(forKey: key_urlUpdateDic) as? [String : Date] ?? nil
    &#125;()
    
    static func saveUpdateDic() &#123;
        UserDefaults.standard.set(urlUpdateDic, forKey: key_urlUpdateDic)
    &#125;
    
    static func request(with type: TargetType, parameters: [String: Any]? = nil) -&gt; DataRequest &#123;
        let param = parameters == nil ? type.parameters : parameters
        return HttpsManager.defaultSession.request(type.url, method: type.method, parameters: param)
    &#125;
    
&#125;
</code></pre>
<p>这里我们倒推一下：<br>外部触发了request方法：</p>
<pre><code class="line-numbers language-Swift">static func request(with type: TargetType, parameters: [String: Any]? = nil) -&gt; DataRequest &#123;
    let param = parameters == nil ? type.parameters : parameters
    return HttpsManager.defaultSession.request(type.url, method: type.method, parameters: param)
&#125;
</code></pre>
<p>这里走了这个管理方法中的默认session发起请求。</p>
<p>这个session是这样定义的：</p>
<pre><code class="line-numbers language-Swift">/// 不自动产生缓存的SessionManager
private static let defaultSession: Alamofire.Session = &#123;
    let configuration = URLSessionConfiguration.ephemeral
    //更该其protocolClasses 才能拦截URLSession的网络请求
    configuration.protocolClasses = [HttpsURLProtocol.self]
    return Alamofire.Session(configuration: configuration)
&#125;()
</code></pre>
<p>是通过Alamofire类里面定义的一个Session。<br>通过自己配置URLSession，传给Alamofire中，就拿到一个不自动产生缓存的SessionManager对象了。</p>
<p>这个session走到了Alamofire中去请求了，下面就不涉及我们此篇文章的内容了。<br>这里通过Alamofire，我们得到一个DataRequest返回体。</p>
<pre><code class="line-numbers language-Swift">// MARK: - Subclasses

// MARK: - DataRequest

/// `Request` subclass which handles in-memory `Data` download using `URLSessionDataTask`.
public class DataRequest: Request &#123;
    /// `URLRequestConvertible` value used to create `URLRequest`s for this instance.
    public let convertible: URLRequestConvertible
    /// `Data` read from the server so far.
    public var data: Data? &#123; return protectedData.directValue &#125;
</code></pre>
<p>可以看到，数据放在了data中。</p>
<p>然后我们利用实体类去继承Mapper，他们就能成功转成自己要的实体了。</p>
<h2 id="6-磁盘缓存全过程"><a href="#6-磁盘缓存全过程" class="headerlink" title="6 磁盘缓存全过程"></a>6 磁盘缓存全过程</h2><h3 id="6-1-网络请求拿到数据了"><a href="#6-1-网络请求拿到数据了" class="headerlink" title="6.1 网络请求拿到数据了"></a>6.1 网络请求拿到数据了</h3><p>在ItemsStoreType的request方法中，拿到数据后调用了一个handle方法：</p>
<pre><code class="line-numbers language-Swift">//MARK:- 网络请求
func request(via param: [String: Any]?, uuid: UUID, observer: AnyObserver&lt;()&gt;) &#123;
    HttpsManager.request(with: targetType, parameters: param).responseArray(completionHandler:
        ResponseHandler.handlerArrayResponse(via: observer, target: self.targetType, success: &#123; [weak self] (newItems: [O]) in
            self?.handle(newItems: newItems, via: param, uuid: uuid)
            //发送完成事件避免资源一直被占用
            observer.onCompleted()
    &#125;))
&#125;
</code></pre>
<p>这里继续走：</p>
<pre><code class="line-numbers language-Swift">func handle(newItems: [O], via param: [String: Any]?, uuid: UUID, sendNoti: Bool = true) &#123;
    var userInfo: [ResponseKey: Any] = [.tragetType: self.targetType, .identity: uuid]
    //若参数存在page
    if let page = param?[&quot;page&quot;] as? Int &#123;
        var reason: ChangeReason
        if page == 1 &#123;
            self.items = newItems
            reason = .request
        &#125; else &#123;
            self.items.append(contentsOf: newItems)
            reason = .loadMore
        &#125;
        userInfo[.changeReason] = reason
    &#125;
    else &#123;
        userInfo[.changeReason] = ChangeReason.request
        self.items = newItems
    &#125;
    //交由具体的StoreClasses实现持久化存储
    self.saveItems(via: userInfo)
    if sendNoti &#123;
        NotificationCenter.default.post(name: Self.itemsChangedNoti, object: self
            .items, userInfo: userInfo)
    &#125;
&#125;
</code></pre>
<p>这里委托store的saveItems保存了。</p>
<h3 id="5-2-saveItems"><a href="#5-2-saveItems" class="headerlink" title="5.2 saveItems"></a>5.2 saveItems</h3><p>这里是交给了具体的Store去实现了：<br>这里是ProjectsStore的saveItems方法：</p>
<pre><code class="line-numbers language-Swift">func saveItems(via userInfo: [ResponseKey : Any]) &#123;
    //只存储第一页的数据
    if let changedReason = userInfo[ResponseKey.changeReason] as? ChangeReason, changedReason == .request, !(realm?.isInWriteTransaction ?? false) &#123;
        switch self.targetType &#123;
        case .userProjs(_): saveNormalItems()
        case .staredProjs(_), .watchedProjs(_): saveOwnerdItems()
        case .latestProjs, .popularProjs, .featuredProjs, .languagedProjs(_, _):
            saveOrderedItems()
        default: break
        &#125;
    &#125;
&#125;
</code></pre>
<p>这里根据类型，继续走到了saveOrderedItems：</p>
<pre><code class="line-numbers language-Swift">///定制的存储方法
private func saveOrderedItems() &#123;
    //本地没有数据存在
    if queryAllItems()?.count == 0 &#123;
        var index = 0
        for item in items &#123;
            custom(item: item, index: index)
            index += 1
        &#125;
        update(items: items)
    &#125;
    //本地存在数据
    else &#123;
        var index = items.count - 1
        var diff  = 0
        var turn  = true
        var newItems = [Project]()
        //所有请求到的数据都是新数据（本地不存在）
        //取本地第一条数据的index-新数据的count作为差值
        if object(of: items[items.count - 1].id) == nil, let firstIndex = queryAllItems()?.first?.index(of: targetType) &#123;
            diff = firstIndex - items.count
            turn = false
        &#125;
        for _ in items &#123;
            let item = items[index]
            //已经存在拥有序列的该类型数据(忽略，并计算新的index差)
            if turn, let obj = object(of: item.id), let storedIndex = obj.index(of: targetType) &#123;
                diff = storedIndex - index
            &#125; else &#123;
                //不存在就新定制
                custom(item: item, index: index + diff)
                newItems.append(item)
            &#125;
            index -= 1
        &#125;
        update(items: newItems)
    &#125;
&#125;
</code></pre>
<p>这里先看下queryAllItems吧。</p>
<h3 id="5-3-ItemsStoreType的queryAllItems"><a href="#5-3-ItemsStoreType的queryAllItems" class="headerlink" title="5.3 ItemsStoreType的queryAllItems"></a>5.3 ItemsStoreType的queryAllItems</h3><p>这里走到了ItemsStoreType方法中：</p>
<pre><code class="line-numbers language-Swift">func queryAllItems(limited: Int = 20) -&gt; [O]? &#123;
    switch targetType &#123;
    case .featuredProjs:
        return self.query(via: NSPredicate(format: &quot;featuredIndex != nil&quot;), sortedKey: &quot;featuredIndex&quot;).toArray(limited: limited)
    case .popularProjs:
        return self.query(via: NSPredicate(format: &quot;popularIndex != nil&quot;), sortedKey: &quot;popularIndex&quot;).toArray(limited: limited)
    case .latestProjs:
        return self.query(via: NSPredicate(format: &quot;latestIndex != nil&quot;), sortedKey: &quot;latestIndex&quot;).toArray(limited: limited)
    case .languagedProjs(_, let language):
        return self.query(via: NSPredicate(format: &quot;languageIndex != nil &amp;&amp; language = %@&quot;, language), sortedKey: &quot;languageIndex&quot;).toArray(limited: limited)
    case .userEvents(let id):
        return self.query(via: NSPredicate(format: &quot;authorId = %ld&quot;, id), sortedKey: &quot;createdDate&quot;, ascending: false).toArray(limited: limited)
    case .selfEvents:
        return self.query(via: NSPredicate(format: &quot;authorId = %ld&quot;, CurrentUserManager.id), sortedKey: &quot;createdDate&quot;, ascending: false).toArray(limited: limited)
    case .userProjs(let id):
        return self.query(via: NSPredicate(format: &quot;owner.id = %ld&quot;, id), sortedKey: &quot;createdAt&quot;, ascending: true).toArray(limited: limited)
    case .staredProjs(let id):
        return UserStore(type: .user(id)).item?.startedProjects.toArray(limited: 20) as? [Self.O]
    case .watchedProjs(let id):
        return UserStore(type: .user(id)).item?.watchedProjects.toArray(limited: 20) as? [Self.O]
    default: return nil
    &#125;
&#125;
</code></pre>
<p>这里通过NSPredicate数据库语法，走query方法：</p>
<h3 id="5-4-StoreType的query方法"><a href="#5-4-StoreType的query方法" class="headerlink" title="5.4 StoreType的query方法"></a>5.4 StoreType的query方法</h3><p>因为这个走到了底层，所以应该在底层封装：</p>
<pre><code class="line-numbers language-Swift">func query(via predicate: NSPredicate, sortedKey: String? = nil, ascending: Bool = true) -&gt; Results&lt;O&gt; &#123;
    if let key = sortedKey &#123;
        return realm.objects(O.self).filter(predicate).sorted(byKeyPath: key, ascending: ascending)
    &#125;
    
    return realm.objects(O.self).filter(predicate)
&#125;
</code></pre>
<p>这里终于找到罪魁祸首了，就是realm数据库。</p>
<p>再看下update:</p>
<pre><code class="line-numbers language-Swift">func update(items: [O]) &#123;
        if realm.isInWriteTransaction &#123; return &#125;
        do &#123;
            //save
            try realm.write &#123;
                realm.add(items, update: .modified)
                //realm.add(items, update: true)
            &#125;
            
        &#125; catch(_) &#123; return &#125;
        
    &#125;
</code></pre>
<p>realm来自于下方这里，当然可以在自己的实现Store中自定义，这里是默认实现。</p>
<pre><code class="line-numbers language-Swift">extension StoreType &#123;
var realm: Realm &#123;
    return Store.shared.realm
&#125;
</code></pre>
<p>应该是在Store的单例类中找到了realm。</p>
<h3 id="5-5-Store底层"><a href="#5-5-Store底层" class="headerlink" title="5.5 Store底层"></a>5.5 Store底层</h3><pre><code class="line-numbers language-Swift">final class Store &#123;
    static let shared = Store()
    let realm: Realm
    private init() &#123;
        Store.set(realmName: &quot;gitosc&quot;)
        realm = try! Realm()
    &#125;
    
    static func deleteRealm(with realm: Realm = Store.shared.realm) &#123;
        if realm.isInWriteTransaction &#123; return &#125;
        autoreleasepool &#123;
            do &#123;
                try realm.write &#123;
                    
                    realm.deleteAll()
                &#125;
            &#125; catch(_) &#123; return &#125;
        &#125;
        let realmURL = Realm.Configuration.defaultConfiguration.fileURL!
        let realmURLs: [URL] = [
            realmURL.appendingPathExtension(&quot;lock&quot;),
            realmURL.appendingPathExtension(&quot;note&quot;),
            realmURL.appendingPathExtension(&quot;management&quot;)
        ]
        for URL in realmURLs &#123;
            do &#123;
                try FileManager.default.removeItem(at: URL)
            &#125; catch &#123;
                // 错误处理
            &#125;
        &#125;
    &#125;
    
    private static func set(realmName: String) &#123;
        
        var config = Realm.Configuration()
        // 使用默认的目录，但是请将文件名替换为用户名
        config.fileURL = config.fileURL!.deletingLastPathComponent().appendingPathComponent(&quot;\(realmName).realm&quot;)
    
        // 将该配置设置为默认 Realm 配置
        Realm.Configuration.defaultConfiguration = config
    &#125;
&#125;
</code></pre>
<p>这里搞了一个单例类，存放了realm类，可以操作数据库。</p>
<p>其实在我们自己实现的ProjectsStore也声明了realm:</p>
<pre><code class="line-numbers language-Swift">final class ProjectsStore: ItemsStoreType &#123;
    
    typealias O = Project
    
    var items: [Project] = []
    
    var targetType: ItemsType
    
    var realm: Realm? = Store.shared.realm
</code></pre>
<p>其实不声明也可以，反正都是用的同一个单例类。</p>
<p>就这样，使用realm把数据转换成功数据库了，持久化在本地了。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><ul>
<li><p>本篇文章主要是窥探码云这个客户端网络请求和缓存的主流程，揭秘如何封装，一层一层环环相扣，将数据完美展现在UItableView里面。</p>
</li>
<li><p>首先我们如果是一个上方多tab，每个tab有一个列表，这种架构，可以用一个DNSPageView来构造，只需要在这里添加tab的几个控制器，titles，其它工作很少。</p>
</li>
<li><p>然后封装下子控制器，通过让这个子控制器继承UIViewController，和一个关键的ItemsController协议，这个协议我们自己定义的，主要用来请求网络，填充数据的。</p>
</li>
<li><p>这个子控制器里面，主要做一个tableView相关的绑定工作，这里我们会在子控制器里面添加一个tableView。主要在viewDidLoad里面配置。通过view.addSubView一个table来实现。</p>
</li>
<li><p>然后在第一次执行下下拉刷新事件，这个事件通过rxSwift绑定关系，来触发viewModel层走request。</p>
</li>
<li><p>因为要viewModel，所以我们需要继续封装一下ItemsController，将网络相关的全部给它处理，viewModel也放在它里面。</p>
</li>
<li><p>这里网络相关我们单独抽一个协议NetAccessableControllerType，这个叫网络可达，这里存放ViewModel，我们可以定义ViewModel基本协议方法，用一个BaseViewModelType来规范吧。</p>
</li>
<li><p>然后还有一个TableViewPresentable就主要用来填充数据吧，还有一个HintViewsPresentable也处理UI方面的东西。</p>
</li>
<li><p>然后的的ViewModel去继承ItemsViewModelType，上面定义的是BaseViewModelType是这个类型，这里需要声明继承关系。</p>
</li>
<li><p>这个ItemsViewModelType，其实就配置了很多Driver事件驱动，在setupView的初始化配置中，利用viewModel.contents来驱动tableView.rx.item数据填充。这个数据源我们在TableVIewPresentable中配置。</p>
</li>
<li><p>在网络请求成功后，给了ItemsStoreType中的items数据为网络数据，然后其实是给了ViewModel中的Store，就是说store有数据了，然后监听了dataSource其实是S.o，也就是items，这样就相当于监听了网络数据。</p>
</li>
<li><p>拿到数据后，驱动ItemsViewModel中的dataSource，走dataSource方法，在setupViewModel中监听了数据源，实现tableView赋值过程。</p>
</li>
</ul>

            </div>
            <hr />

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">写作不易，客官能否打赏一杯奶茶？</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《iOS swift 码云客户端 完整项目分析之二》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2023/02/18/iOS-swift-%E7%A0%81%E4%BA%91%E5%AE%A2%E6%88%B7%E7%AB%AF-%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90%E4%B9%8B%E4%BA%8C/" property="cc:attributionName"
               rel="cc:attributionURL">
                Jason
            </a> 采用
            <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    
    <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: 'fe0ccf043e8b41eb62ea',
        clientSecret: '9ca1dd3be79bdf6123d4aa8ca81753570fe870e1',
        repo: 'jasontojan.github.io',
        owner: 'jasontojan',
        admin: "jasontojan",
        id: '2023/02/18/iOS-swift-码云客户端-完整项目分析之二/',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    
    <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script> -->

<script>
    new Valine({
        el: '#vcomments',
        appId: '查教程获取',
        appKey: '查教程获取',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'false' === 'true',
        avatar: 'wavatar',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '如果你没有GitHub账号，还可以在这里评论啦！'
    });
</script>

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/02/24/Flutter-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/20.jpg" class="responsive-img" alt="Flutter 性能优化实践">
                        
                        <span class="card-title">Flutter 性能优化实践</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            1 简介Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2023-02-24
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Flutter/" class="post-category" target="_blank">
                                    Flutter
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Flutter%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" target="_blank">
                        <span class="chip bg-color">Flutter性能优化</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/02/13/iOS-swift-%E7%A0%81%E4%BA%91%E5%AE%A2%E6%88%B7%E7%AB%AF-%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%80/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/19.jpg" class="responsive-img" alt="iOS swift 码云客户端 完整项目分析之一">
                        
                        <span class="card-title">iOS swift 码云客户端 完整项目分析之一</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            1 项目地址
https://gitee.com/oschina/git-osc-iphone使用Swift语言重构的码云iOS客户端，采用MVVM设计模式与POP(面向协议编程)，核心框架为RxSwift。 

效果如下：








                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2023-02-13
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/iOS/" class="post-category" target="_blank">
                                    iOS
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE-RxSwift/" target="_blank">
                        <span class="chip bg-color">完整项目 RxSwift</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: JasonToJan's Blog<br />'
            + '作者: Jason<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
    });
</script>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; 2023-2023 JasonJan. 版权所有

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">274.7k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
            <br>
            
            <span id="busuanzi_container_site_pv" style='display:none'>
                <i class="fa fa-heart-o"></i>
                本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
            <span id="busuanzi_container_site_uv" style='display:none'>
                人次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
            </span>
            
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/JasonToJan" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:jason1211241203@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="https://zhihu.com/people/JasonJan" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-inverse">知</i>
    </a>



    <a href="http://wpa.qq.com/msgrd?v=3&uin=1211241203&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>



    <a href="https://weibo.com/JasonJan" class="tooltipped" target="_blank" data-tooltip="关注我的微博" data-position="top" data-delay="50">
        <i class="fa fa-weibo"></i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 80000;
        var uvcountOffset = 20000;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2017, 09, 11, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>

<link rel="stylesheet" href="/css/prism.css">
<script src="/js/prism.js" async></script>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=查教程获取"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '查教程获取');
</script>



    
    <script src="/libs/others/clicklove.js"></script>
    

    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    <!-- 雪花特效 -->
    

</body>

</html>