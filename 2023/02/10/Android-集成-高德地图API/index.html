<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Android 集成 高德地图API, Android iOS Flutter">
    <meta name="baidu-site-verification" content="fmlEuI34ir" />
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48" />
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7" />
    <meta name="description" content="1 参考文档
Github源码地址：https://github.com/lilongweidev/GaodeMapDemo博主博客地址:Android 高德地图API（详细步骤+源码）7Android 高德地图API（详细步骤+源码）6A">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Android 集成 高德地图API | JasonToJan&#39;s Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?ce84511d3df71640a9378a69f6293044";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">JasonToJan's Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <i class="fa fa-comments"></i>
            
            <span>留言板</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">JasonToJan's Blog</div>
        <div class="logo-desc">
            
            专注移动端，热爱生活，热衷开发。
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-comments"></i>
                
                留言板
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/JasonToJan/hexo-matery-modified" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/JasonToJan/hexo-matery-modified" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/24.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        Android 集成 高德地图API
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                        <a href="/tags/Android-%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE/" target="_blank">
                            <span class="chip bg-color">Android 高德地图</span>
                        </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                        <a href="/categories/Android/" class="post-category" target="_blank">
                            Android
                        </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-02-10
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    Jason
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    13.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    66 分
                </div>
                
                

                
                <div id="busuanzi_container_page_pv" class="info-break-policy">
                    <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                    <span id="busuanzi_value_page_pv"></span>
                </div>
                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="1-参考文档"><a href="#1-参考文档" class="headerlink" title="1 参考文档"></a>1 参考文档</h2><blockquote>
<p>Github源码地址：<a target="_blank" rel="noopener" href="https://github.com/lilongweidev/GaodeMapDemo">https://github.com/lilongweidev/GaodeMapDemo</a><br>博主博客地址:<br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1797654?areaSource=104001.113&traceId=nfv8q8EbnuT49lmQX8eK1">Android 高德地图API（详细步骤+源码）7</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1797651?areaSource=104001.114&traceId=nfv8q8EbnuT49lmQX8eK1">Android 高德地图API（详细步骤+源码）6</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1797622?areaSource=104001.115&traceId=nfv8q8EbnuT49lmQX8eK1">Android 高德地图API（详细步骤+源码）5</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1797621?areaSource=104001.116&traceId=nfv8q8EbnuT49lmQX8eK1">Android 高德地图API（详细步骤+源码）4</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1792227?areaSource=104001.121&traceId=nfv8q8EbnuT49lmQX8eK1">Android 高德地图API（详细步骤+源码）3</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1789741?areaSource=104001.122&traceId=nfv8q8EbnuT49lmQX8eK1">Android 高德地图API（详细步骤+源码）2</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1789740?areaSource=104001.123&traceId=nfv8q8EbnuT49lmQX8eK1">Android 高德地图API（详细步骤+源码）1</a></p>
</blockquote>
<h2 id="2-集成步骤"><a href="#2-集成步骤" class="headerlink" title="2 集成步骤"></a>2 集成步骤</h2><h3 id="2-1-创建开发者账号配置应用"><a href="#2-1-创建开发者账号配置应用" class="headerlink" title="2.1 创建开发者账号配置应用"></a>2.1 创建开发者账号配置应用</h3><p>直接在 <a target="_blank" rel="noopener" href="https://lbs.amap.com/">高德开放平台</a> 注册一个账号，新建一个应用。</p>
<p>这里添加应用的key的时候，需要两个SHA1，怎么获取呢？</p>
<ul>
<li><p>获取调试版安全码SHA1<br>AS的右侧边栏，点击Gradle → app → android → signingReport，最后双击signingReport。</p>
</li>
<li><p>获取发布版安全帽SHA1<br>这个需要根据发布签名来，比如我们拿到一个jks文件，通过以下命令来获取：</p>
</li>
</ul>
<pre><code>keytool -list -v -keystore 后面加个空格 再跟上你打正式包后的 jks 文件完整地址
</code></pre>
<h3 id="2-2-本地集成方式"><a href="#2-2-本地集成方式" class="headerlink" title="2.2 本地集成方式"></a>2.2 本地集成方式</h3><p>首先在这里下载sdk<br><a target="_blank" rel="noopener" href="https://a.amap.com/lbs/static/zip/AMap_Android_SDK_All.zip">Android地图SDK 一键下载</a><br>这个包括：开发包（2D地图包、3D地图包、搜索包）、示例代码、开发文档（2D地图、3D地图、搜索服务）等。</p>
<p>下载好后放在app模块的libs文件夹下，没有则新建。</p>
<p>然后打开你的app下的build.gradle文件，在android闭包下添加：</p>
<pre><code>sourceSets &#123;
    main&#123;
        jniLibs.srcDirs = [&#39;libs&#39;]
    &#125;
&#125;
</code></pre>
<p>这样程序就能访问到这个文件夹下的sdk了。</p>
<p>然后配置下AndroidManifest.xml文件：<br>打开AndroidManifest.xml，首先在application标签下添加定位服务：</p>
<pre><code>&lt;!--定位service--&gt;
&lt;service android:name=&quot;com.amap.api.location.APSService&quot;/&gt;
</code></pre>
<p>然后添加权限,有的则无需重复添加：</p>
<pre><code>&lt;!--用于访问网络，网络定位需要上网--&gt;
&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
&lt;!--用于读取手机当前的状态--&gt;
&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;
&lt;!--用于写入缓存数据到扩展存储卡--&gt;
&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;
&lt;!--用于申请调用A-GPS模块--&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_LOCATION_EXTRA_COMMANDS&quot; /&gt;
&lt;!--用于进行网络定位--&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;
&lt;!--用于访问GPS定位--&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;
&lt;!--用于获取运营商信息，用于支持提供运营商信息相关的接口--&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;
&lt;!--用于访问wifi网络信息，wifi信息会用于进行网络定位--&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;
&lt;!--用于获取wifi的获取权限，wifi信息会用来进行网络定位--&gt;
&lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt;
</code></pre>
<p>然后在application标签下添加高德的key：</p>
<pre><code> &lt;meta-data
            android:name=&quot;com.amap.api.v2.apikey&quot;
            android:value=&quot;d3347ee0f2928f9a0c199cae009ae7f7&quot; /&gt;
</code></pre>
<h3 id="2-3-远程集成方式"><a href="#2-3-远程集成方式" class="headerlink" title="2.3 远程集成方式"></a>2.3 远程集成方式</h3><p>这里通过远程依赖直接下载依赖包，可以在app模块的dependencies下方填写需要的依赖：</p>
<table>
<thead>
<tr>
<th>SDK</th>
<th>引入代码</th>
</tr>
</thead>
<tbody><tr>
<td>3D地图</td>
<td>‘com.amap.api:3dmap:latest.integration’</td>
</tr>
<tr>
<td>2D地图</td>
<td>‘com.amap.api:map2d:latest.integration’</td>
</tr>
<tr>
<td>导航</td>
<td>‘com.amap.api:navi-3dmap:latest.integration‘</td>
</tr>
<tr>
<td>搜索</td>
<td>‘com.amap.api:search:latest.integration’</td>
</tr>
<tr>
<td>定位</td>
<td>‘com.amap.api:location:latest.integration’</td>
</tr>
</tbody></table>
<p>然后最好设置下ndk:</p>
<pre><code>ndk &#123;
    //设置支持的SO库架构（开发者可以根据需要，选择一个或多个平台的so）
    abiFilters &quot;armeabi&quot;, &quot;armeabi-v7a&quot;, &quot;arm64-v8a&quot;, &quot;x86&quot;,&quot;x86_64&quot;
&#125;
</code></pre>
<p>一般情况，设置一个arm64-v8a就可以了，目前主流手机都支持。</p>
<p>注意：</p>
<blockquote>
<p>1、3D地图 SDK 和导航 SDK，5.0.0 版本以后全面支持多平台 so 库(armeabi、armeabi-v7a、arm64-v8a、x86、x86_64)，开发者可以根据需要选择。同时还需要注意的是：如果您涉及到新旧版本更替请移除旧版本的 so 库之后替换新版本 so 库到工程中。<br>2、navi导航SDK 5.0.0以后版本包含了3D地图SDK，所以请不要同时引入 map3d 和 navi SDK。<br>3、如果build失败提示com.amap.api:XXX:X.X.X 找不到，请确认拼写及版本号是否正确，如果访问不到maven仓库尝试一下配置下阿里云镜像。<br>4、依照上述方法引入 SDK 以后，不需要在libs文件夹下导入对应SDK的 so 和 jar 包，会有冲突。</p>
</blockquote>
<h2 id="3-获取当前定位信息"><a href="#3-获取当前定位信息" class="headerlink" title="3 获取当前定位信息"></a>3 获取当前定位信息</h2><h3 id="3-1-申请定位权限"><a href="#3-1-申请定位权限" class="headerlink" title="3.1 申请定位权限"></a>3.1 申请定位权限</h3><p>首先可以考虑引入官方的<br><a target="_blank" rel="noopener" href="https://github.com/googlesamples/easypermissions">easypermissions</a> 进行动态权限申请。<br>需要引入此依赖：</p>
<pre><code>implementation &#39;pub.devrel:easypermissions:3.0.0&#39;
</code></pre>
<p>申请权限：</p>
<pre><code class="line-numbers language-Java">/**
    * 动态请求权限
    */
@AfterPermissionGranted(REQUEST_PERMISSIONS)
private void requestPermission() &#123;
    String[] permissions = &#123;
            Manifest.permission.ACCESS_COARSE_LOCATION,
            Manifest.permission.ACCESS_FINE_LOCATION,
            Manifest.permission.READ_PHONE_STATE,
            Manifest.permission.WRITE_EXTERNAL_STORAGE
    &#125;;

    if (EasyPermissions.hasPermissions(this, permissions)) &#123;
        //true 有权限 开始定位
        //showMsg(&quot;已获得权限，可以定位啦！&quot;);
        Log.d(TAG, &quot;已获得权限，可以定位啦！&quot;);
        //启动定位
        mLocationClient.startLocation();
    &#125; else &#123;
        //false 无权限
        EasyPermissions.requestPermissions(this, &quot;需要权限&quot;, REQUEST_PERMISSIONS, permissions);
    &#125;
&#125;
</code></pre>
<p>然后需要在Activity的onRequestPermissionsResult获取请求权限回调：</p>
<pre><code class="line-numbers language-Java">/**
    * 请求权限结果
    * @param requestCode
    * @param permissions
    * @param grantResults
    */
@Override
public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123;
    super.onRequestPermissionsResult(requestCode, permissions, grantResults);
    //设置权限请求结果
    EasyPermissions.onRequestPermissionsResult(requestCode, permissions, grantResults, this);
&#125;
</code></pre>
<h3 id="3-2-初始化定位"><a href="#3-2-初始化定位" class="headerlink" title="3.2 初始化定位"></a>3.2 初始化定位</h3><p>变量声明：</p>
<pre><code class="line-numbers language-Java">//声明AMapLocationClient类对象
public AMapLocationClient mLocationClient = null;
//声明AMapLocationClientOption对象
public AMapLocationClientOption mLocationOption = null;
</code></pre>
<p>变量初始化</p>
<pre><code class="line-numbers language-Java">/**
    * 初始化定位
    */
private void initLocation() &#123;
    //初始化定位
    mLocationClient = new AMapLocationClient(getApplicationContext());
    //设置定位回调监听
    mLocationClient.setLocationListener(this);
    //初始化AMapLocationClientOption对象
    mLocationOption = new AMapLocationClientOption();
    //设置定位模式为AMapLocationMode.Hight_Accuracy，高精度模式。
    mLocationOption.setLocationMode(AMapLocationClientOption.AMapLocationMode.Hight_Accuracy);
    //获取最近3s内精度最高的一次定位结果：
    //设置setOnceLocationLatest(boolean b)接口为true，启动定位时SDK会返回最近3s内精度最高的一次定位结果。如果设置其为true，setOnceLocation(boolean b)接口也会被设置为true，反之不会，默认为false。
    mLocationOption.setOnceLocationLatest(true);
    //设置是否返回地址信息（默认返回地址信息）
    mLocationOption.setNeedAddress(true);
    //设置定位请求超时时间，单位是毫秒，默认30000毫秒，建议超时时间不要低于8000毫秒。
    mLocationOption.setHttpTimeOut(20000);
    //关闭缓存机制，高精度定位会产生缓存。
    mLocationOption.setLocationCacheEnable(false);
    //给定位客户端对象设置定位参数
    mLocationClient.setLocationOption(mLocationOption);
&#125;
</code></pre>
<p>开始定位：<br>这里通过 <code>mLocationClient.startLocation();</code> 去开始定位，结果会通过回调传给activity。</p>
<pre><code class="line-numbers language-Java">@Override
public void onLocationChanged(AMapLocation aMapLocation) &#123;
    if (aMapLocation != null) &#123;
        if (aMapLocation.getErrorCode() == 0) &#123;
            //地址
            String address = aMapLocation.getAddress();
            //城市赋值
            city = aMapLocation.getCity();
            //获取纬度
            double latitude = aMapLocation.getLatitude();
            //获取经度
            double longitude = aMapLocation.getLongitude();

            Log.d(&quot;MainActivity&quot;, aMapLocation.getCity());
            showMsg(address);

            //停止定位后，本地定位服务并不会被销毁
            mLocationClient.stopLocation();

            //显示地图定位结果
            if (mListener != null) &#123;
                // 显示系统图标
                mListener.onLocationChanged(aMapLocation);
            &#125;

            //显示浮动按钮
            fabPOI.show();
            //赋值
            cityCode = aMapLocation.getCityCode();
        &#125; else &#123;
            //定位失败时，可通过ErrCode（错误码）信息来确定失败的原因，errInfo是错误信息，详见错误码表。
            Log.e(&quot;AmapError&quot;, &quot;location Error, ErrCode:&quot;
                    + aMapLocation.getErrorCode() + &quot;, errInfo:&quot;
                    + aMapLocation.getErrorInfo());
        &#125;
    &#125;
&#125;
</code></pre>
<p>获取到定位结果后，需要我们解析一下。<br>同时需要停止定位。</p>
<p>同时需要再onDestory里面进行销毁引用：</p>
<pre><code class="line-numbers language-Java">@Override
protected void onDestroy() &#123;
    super.onDestroy();
    //销毁定位客户端，同时销毁本地定位服务。
    if (mLocationClient != null) &#123;
        mLocationClient.onDestroy();
    &#125;
    //在activity执行onDestroy时执行mMapView.onDestroy()，销毁地图
    mapView.onDestroy();
&#125;
</code></pre>
<h2 id="4-显示地图"><a href="#4-显示地图" class="headerlink" title="4 显示地图"></a>4 显示地图</h2><h3 id="4-1-添加MapView"><a href="#4-1-添加MapView" class="headerlink" title="4.1 添加MapView"></a>4.1 添加MapView</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:gravity=&quot;center&quot;
    tools:context=&quot;.MainActivity&quot;&gt;

    &lt;!--地图--&gt;
    &lt;com.amap.api.maps.MapView
        android:id=&quot;@+id/map_view&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;/&gt;

&lt;/RelativeLayout&gt;
</code></pre>
<p>简单看下源码：</p>
<pre><code class="line-numbers language-Java">public class MapView extends FrameLayout implements BaseMapView &#123;
    private IMapFragmentDelegate mapFragmentDelegate;
    private AMap aMap;
    private int visibility = 0;

    public MapView(Context var1) &#123;
        super(var1);
        this.getMapFragmentDelegate().setContext(var1);
    &#125;

    public MapView(Context var1, AttributeSet var2) &#123;
</code></pre>
<p>没想到地图是用FrameLayout，我以为是用GLSurfaceView绘制的呢。<br>主要逻辑它通过这个代理来完成的。</p>
<h3 id="4-2-同步生命周期"><a href="#4-2-同步生命周期" class="headerlink" title="4.2 同步生命周期"></a>4.2 同步生命周期</h3><p>然后需要在activity的生命周期里面同步下mapView的生命周期。</p>
<pre><code class="line-numbers language-Java">  @Override
    protected void onDestroy() &#123;
        super.onDestroy();
        //销毁定位客户端，同时销毁本地定位服务。
        if (mLocationClient != null) &#123;
            mLocationClient.onDestroy();
        &#125;
        //在activity执行onDestroy时执行mMapView.onDestroy()，销毁地图
        mapView.onDestroy();
    &#125;

    @Override
    protected void onResume() &#123;
        super.onResume();
        //在activity执行onResume时执行mMapView.onResume ()，重新绘制加载地图
        mapView.onResume();
    &#125;

    @Override
    protected void onPause() &#123;
        super.onPause();
        //在activity执行onPause时执行mMapView.onPause ()，暂停地图的绘制
        mapView.onPause();
    &#125;

    @Override
    protected void onSaveInstanceState(Bundle outState) &#123;
        super.onSaveInstanceState(outState);
        //在activity执行onSaveInstanceState时执行mMapView.onSaveInstanceState (outState)，保存地图当前的状态
        mapView.onSaveInstanceState(outState);
    &#125;
</code></pre>
<p>此时可以显示北京地图了。</p>
<h2 id="5-显示当前定位地图"><a href="#5-显示当前定位地图" class="headerlink" title="5 显示当前定位地图"></a>5 显示当前定位地图</h2><h3 id="5-1-相关成员变量"><a href="#5-1-相关成员变量" class="headerlink" title="5.1 相关成员变量"></a>5.1 相关成员变量</h3><pre><code class="line-numbers language-Java">//地图控制器
private AMap aMap = null;
//位置更改监听
private OnLocationChangedListener mListener;
</code></pre>
<h3 id="5-2-初始化地图控制器"><a href="#5-2-初始化地图控制器" class="headerlink" title="5.2 初始化地图控制器"></a>5.2 初始化地图控制器</h3><p>在onCreate中执行如下代码：</p>
<pre><code class="line-numbers language-Java">private void initMap(Bundle savedInstanceState) &#123;
    mapView = findViewById(R.id.map_view);
    //在activity执行onCreate时执行mMapView.onCreate(savedInstanceState)，创建地图
    mapView.onCreate(savedInstanceState);
    //初始化地图控制器对象
    aMap = mapView.getMap();

    // 设置定位监听
    aMap.setLocationSource(this);
    // 设置为true表示显示定位层并可触发定位，false表示隐藏定位层并不可触发定位，默认是false
    aMap.setMyLocationEnabled(true);
&#125;
</code></pre>
<h3 id="5-3-给地图注入监听"><a href="#5-3-给地图注入监听" class="headerlink" title="5.3 给地图注入监听"></a>5.3 给地图注入监听</h3><p>注意到上面的 <code>aMap = aMap.setLocationSource(this);</code><br>这个this说明这个Activity要实现回调方法：</p>
<pre><code class="line-numbers language-Java">public interface LocationSource &#123;
    void activate(LocationSource.OnLocationChangedListener var1);

    void deactivate();

    public interface OnLocationChangedListener &#123;
        void onLocationChanged(Location var1);
    &#125;
&#125;
</code></pre>
<p>这个是高德提供的定位接口。</p>
<p>我们需要在activity里面去实现这个接口：</p>
<pre><code class="line-numbers language-Java">/**
 * 激活定位
 */
@Override
public void activate(OnLocationChangedListener onLocationChangedListener) &#123;
    mListener = onLocationChangedListener;
    if (mLocationClient == null) &#123;
        mLocationClient.startLocation();//启动定位
    &#125;
&#125;

/**
 * 停止定位
 */
@Override 
public void deactivate() &#123;
    mListener = null;
    if (mLocationClient != null) &#123;
        mLocationClient.stopLocation();
        mLocationClient.onDestroy();
    &#125;
    mLocationClient = null;
&#125;
</code></pre>
<p>这里主要是在activate里面接收回调，拿到地址后，通过这个回调给map。这样map就指向定位地址了。</p>
<h2 id="6-地图设置"><a href="#6-地图设置" class="headerlink" title="6 地图设置"></a>6 地图设置</h2><h3 id="6-1-修改自定义定位图标"><a href="#6-1-修改自定义定位图标" class="headerlink" title="6.1 修改自定义定位图标"></a>6.1 修改自定义定位图标</h3><pre><code class="line-numbers language-Java">//定位样式
private MyLocationStyle myLocationStyle = new MyLocationStyle();
</code></pre>
<p>初始化地图：</p>
<pre><code class="line-numbers language-Java">// 自定义定位蓝点图标
myLocationStyle.myLocationIcon(BitmapDescriptorFactory.fromResource(R.drawable.gps_point));
// 自定义精度范围的圆形边框颜色  都为0则透明
myLocationStyle.strokeColor(Color.argb(0, 0, 0, 0));
// 自定义精度范围的圆形边框宽度  0 无宽度
myLocationStyle.strokeWidth(0);
// 设置圆形的填充颜色  都为0则透明
myLocationStyle.radiusFillColor(Color.argb(0, 0, 0, 0));

//设置定位蓝点的Style
aMap.setMyLocationStyle(myLocationStyle);
</code></pre>
<h3 id="6-2-设置缩放等级"><a href="#6-2-设置缩放等级" class="headerlink" title="6.2 设置缩放等级"></a>6.2 设置缩放等级</h3><pre><code class="line-numbers language-Java">//设置最小缩放等级为16 ，缩放级别范围为[3, 20]
aMap.setMinZoomLevel(12);
</code></pre>
<h3 id="6-3-开启室内地图"><a href="#6-3-开启室内地图" class="headerlink" title="6.3 开启室内地图"></a>6.3 开启室内地图</h3><pre><code class="line-numbers language-Java">//开启室内地图
aMap.showIndoorMap(true);
</code></pre>
<h3 id="6-4-地图控件设置"><a href="#6-4-地图控件设置" class="headerlink" title="6.4 地图控件设置"></a>6.4 地图控件设置</h3><pre><code class="line-numbers language-Java">//定义一个UiSettings对象
private UiSettings mUiSettings;
</code></pre>
<p>然后可以隐藏缩放按钮：</p>
<pre><code class="line-numbers language-Java">//实例化UiSettings类对象
mUiSettings = aMap.getUiSettings();
//隐藏缩放按钮
mUiSettings.setZoomControlsEnabled(false);
</code></pre>
<p>可以设置比例尺控件：</p>
<pre><code class="line-numbers language-Java">//显示比例尺 默认不显示
mUiSettings.setScaleControlsEnabled(true);
</code></pre>
<h2 id="7-获取POI数据"><a href="#7-获取POI数据" class="headerlink" title="7 获取POI数据"></a>7 获取POI数据</h2><p>POI是什么呢？</p>
<blockquote>
<p>POI (Point of Interest，兴趣点)。在地图表达中，一个 POI 可代表一栋大厦、一家商铺、一处景点等等。通过POI搜索，完成找餐馆、找景点、找厕所等等的功能。</p>
</blockquote>
<p>回到首页，声明几个POI相关变量：</p>
<pre><code class="line-numbers language-Java">//POI查询对象
private PoiSearch.Query query;
//POI搜索对象
private PoiSearch poiSearch;
//城市码
private String cityCode = null;
//浮动按钮
private FloatingActionButton fabPOI;
</code></pre>
<p>在定位回调中，成功后，可显示浮动按钮。</p>
<p>我们设定，点击浮动按钮，去查询附近POI数据，<br>这里点击事件走一下逻辑：</p>
<pre><code class="line-numbers language-Java">public void queryPOI(View view) &#123;
    //构造query对象
    query = new PoiSearch.Query(&quot;购物&quot;, &quot;&quot;, cityCode);
    // 设置每页最多返回多少条poiitem
    query.setPageSize(10);
    //设置查询页码
    query.setPageNum(1);
    //构造 PoiSearch 对象
    try &#123;
        poiSearch = new PoiSearch(this, query);
    &#125; catch (AMapException e) &#123;
        e.printStackTrace();
    &#125;
    //设置搜索回调监听
    poiSearch.setOnPoiSearchListener(this);
    //发起搜索附近POI异步请求
    poiSearch.searchPOIAsyn();
&#125;
</code></pre>
<p>这里设置了回调，所以在activity里面，应该要实现搜索回调接口。</p>
<p>该接口为：</p>
<pre><code class="line-numbers language-Java">public interface OnPoiSearchListener &#123;
    void onPoiSearched(PoiResult var1, int var2);

    void onPoiItemSearched(PoiItem var1, int var2);
&#125;
</code></pre>
<p>所以我们在首页里面去实现：</p>
<pre><code class="line-numbers language-Java">/**
    * POI搜索返回
    *
    * @param poiResult POI所有数据
    * @param i
    */
@Override
public void onPoiSearched(PoiResult poiResult, int i) &#123;
    //解析result获取POI信息

    //获取POI组数列表
    ArrayList&lt;PoiItem&gt; poiItems = poiResult.getPois();
    for (PoiItem poiItem : poiItems) &#123;
        Log.d(&quot;MainActivity&quot;, &quot; Title：&quot; + poiItem.getTitle() + &quot; Snippet：&quot; + poiItem.getSnippet());
    &#125;
&#125;

/**
    * POI中的项目搜索返回
    *
    * @param poiItem 获取POI item
    * @param i
    */
@Override
public void onPoiItemSearched(PoiItem poiItem, int i) &#123;

&#125;
</code></pre>
<p>这里我们只是打印了附近POI数据。</p>
<h2 id="8-地图点击事件"><a href="#8-地图点击事件" class="headerlink" title="8 地图点击事件"></a>8 地图点击事件</h2><h3 id="8-1-点击事件"><a href="#8-1-点击事件" class="headerlink" title="8.1 点击事件"></a>8.1 点击事件</h3><pre><code class="line-numbers language-Java">//设置地图点击事件
aMap.setOnMapClickListener(this);
</code></pre>
<p>这里需要Activity实现一下接口 AMap.OnMapClickListener</p>
<pre><code class="line-numbers language-Java">/**
    * 地图单击事件
    *
    * @param latLng
    */
@Override
public void onMapClick(LatLng latLng) &#123;
    //通过经纬度获取地址
    //latlonToAddress(latLng);
    //添加标点
    addMarker(latLng);
    //改变地图中心点
    updateMapCenter(latLng);
&#125;
</code></pre>
<pre><code class="line-numbers language-Java">/**
    * 添加地图标点
    *
    * @param latLng
    */
private void addMarker(LatLng latLng) &#123;
    //显示浮动按钮
    fabClearMarker.show();
    //添加标点
    Marker marker = aMap.addMarker(new MarkerOptions()
            .draggable(true)//可拖动
            .position(latLng)
            .title(&quot;标题&quot;)
            .snippet(&quot;详细信息&quot;));

    //绘制Marker时显示InfoWindow
    //marker.showInfoWindow();

    //设置标点的绘制动画效果
    Animation animation = new RotateAnimation(marker.getRotateAngle(), marker.getRotateAngle() + 180, 0, 0, 0);
    long duration = 1000L;
    animation.setDuration(duration);
    animation.setInterpolator(new LinearInterpolator());

    marker.setAnimation(animation);
    marker.startAnimation();

    markerList.add(marker);
&#125;
</code></pre>
<p>上面添加了一个Marker标点，然后设置了动画旋转效果。</p>
<p>然后地图好像以marker居中了：</p>
<pre><code class="line-numbers language-Java">/**
    * 改变地图中心位置
    * @param latLng 位置
    */
private void updateMapCenter(LatLng latLng) &#123;
    // CameraPosition 第一个参数： 目标位置的屏幕中心点经纬度坐标。
    // CameraPosition 第二个参数： 目标可视区域的缩放级别
    // CameraPosition 第三个参数： 目标可视区域的倾斜度，以角度为单位。
    // CameraPosition 第四个参数： 可视区域指向的方向，以角度为单位，从正北向顺时针方向计算，从0度到360度
    CameraPosition cameraPosition = new CameraPosition(latLng, 16, 30, 0);
    //位置变更
    CameraUpdate cameraUpdate = CameraUpdateFactory.newCameraPosition(cameraPosition);
    //改变位置
    //aMap.moveCamera(cameraUpdate);
    //带动画的移动
    aMap.animateCamera(cameraUpdate);

&#125;
</code></pre>
<h3 id="8-2-设置地图长按事件"><a href="#8-2-设置地图长按事件" class="headerlink" title="8.2 设置地图长按事件"></a>8.2 设置地图长按事件</h3><pre><code class="line-numbers language-Java">//设置地图长按事件
aMap.setOnMapLongClickListener(this);
</code></pre>
<p>所以需要Activity实现接口：</p>
<pre><code class="line-numbers language-Java">public interface OnMapLongClickListener &#123;
    void onMapLongClick(LatLng var1);
&#125;
</code></pre>
<p>具体实现如下：</p>
<pre><code class="line-numbers language-Java">/**
    * 地图长按事件
    *
    * @param latLng
    */
@Override
public void onMapLongClick(LatLng latLng) &#123;
    //通过经纬度获取地址
    latlonToAddress(latLng);
&#125;
</code></pre>
<p>这里通过点击的经纬度获取地址：</p>
<pre><code class="line-numbers language-Java">/**
    * 通过经纬度获取地址
    *
    * @param latLng
    */
private void latlonToAddress(LatLng latLng) &#123;
    //位置点  通过经纬度进行构建
    LatLonPoint latLonPoint = new LatLonPoint(latLng.latitude, latLng.longitude);
    //逆编码查询  第一个参数表示一个Latlng，第二参数表示范围多少米，第三个参数表示是火系坐标系还是GPS原生坐标系
    RegeocodeQuery query = new RegeocodeQuery(latLonPoint, 20, GeocodeSearch.AMAP);
    //异步获取地址信息
    geocodeSearch.getFromLocationAsyn(query);
&#125;
</code></pre>
<p>因为前面初始化的时候给gecodeSearch设置了监听</p>
<pre><code class="line-numbers language-Java">geocodeSearch.setOnGeocodeSearchListener(this);
</code></pre>
<p>所以当我们走异步获取地址信息的时候，结果会回调到这个接口上：</p>
<pre><code class="line-numbers language-Java">public interface OnGeocodeSearchListener &#123;
    void onRegeocodeSearched(RegeocodeResult var1, int var2);

    void onGeocodeSearched(GeocodeResult var1, int var2);
&#125;
</code></pre>
<p>所以我们Activity也需要实现这两个方法：</p>
<pre><code class="line-numbers language-Java">/**
    * 坐标转地址
    *
    * @param regeocodeResult
    * @param rCode
    */
@Override
public void onRegeocodeSearched(RegeocodeResult regeocodeResult, int rCode) &#123;
    //解析result获取地址描述信息
    if (rCode == PARSE_SUCCESS_CODE) &#123;
        RegeocodeAddress regeocodeAddress = regeocodeResult.getRegeocodeAddress();
        //显示解析后的地址
        Log.d(&quot;MainActivity&quot;, regeocodeAddress.getFormatAddress());
        //showMsg(&quot;地址：&quot; + regeocodeAddress.getFormatAddress());

        LatLonPoint latLonPoint = regeocodeResult.getRegeocodeQuery().getPoint();
        LatLng latLng = new LatLng(latLonPoint.getLatitude(), latLonPoint.getLongitude());
        addMarker(latLng);
    &#125; else &#123;
        showMsg(&quot;获取地址失败&quot;);
    &#125;

&#125;

/**
    * 地址转坐标
    *
    * @param geocodeResult
    * @param rCode
    */
@Override
public void onGeocodeSearched(GeocodeResult geocodeResult, int rCode) &#123;
    if (rCode == PARSE_SUCCESS_CODE) &#123;
        List&lt;GeocodeAddress&gt; geocodeAddressList = geocodeResult.getGeocodeAddressList();
        if (geocodeAddressList != null &amp;&amp; geocodeAddressList.size() &gt; 0) &#123;
            LatLonPoint latLonPoint = geocodeAddressList.get(0).getLatLonPoint();
            //显示解析后的坐标
            showMsg(&quot;坐标：&quot; + latLonPoint.getLongitude() + &quot;，&quot; + latLonPoint.getLatitude());
        &#125;

    &#125; else &#123;
        showMsg(&quot;获取坐标失败&quot;);
    &#125;
&#125;
</code></pre>
<p>这里获取到地址后，打印下来。</p>
<p>这个GeocodeSearch主要是用来逆地址编码的，因为搜索结果只返回经纬度，我们需要通过经纬度获取具体地址名称，这时候就需要使用这个GeocodeSearch类来帮忙处理了。</p>
<h3 id="8-3-地址编码"><a href="#8-3-地址编码" class="headerlink" title="8.3 地址编码"></a>8.3 地址编码</h3><p>地址编码，就是地址转坐标。</p>
<blockquote>
<p>比如说你到一个景点去游玩，不知道路线只知道景点名，那么这个时候通常你会在导航软件中输入这个景点名，然后搜索出前往的路线及搭乘的交通工具。此时，导航软件会将你输入的地址转成经纬度坐标，然后通过你当前的所在地坐标计算距离，获取两点之间的交通情况，然后规划路线。</p>
</blockquote>
<p>所以要搞一个搜索框，这里直接搞一个EditText进去。</p>
<p>设置点击事件，以及键盘监听 EditText.OnKeyListener。</p>
<pre><code class="line-numbers language-Java">/**
    * 键盘点击
    *
    * @param v
    * @param keyCode
    * @param event
    * @return
    */
@Override
public boolean onKey(View v, int keyCode, KeyEvent event) &#123;
    if (keyCode == KeyEvent.KEYCODE_ENTER &amp;&amp; event.getAction() == KeyEvent.ACTION_UP) &#123;
        //获取输入框的值
        String address = etAddress.getText().toString().trim();
        if (address == null || address.isEmpty()) &#123;
            showMsg(&quot;请输入地址&quot;);
        &#125; else &#123;
            InputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
            //隐藏软键盘
            imm.hideSoftInputFromWindow(getWindow().getDecorView().getWindowToken(), 0);

            // name表示地址，第二个参数表示查询城市，中文或者中文全拼，citycode、adcode
            GeocodeQuery query = new GeocodeQuery(address, city);
            geocodeSearch.getFromLocationNameAsyn(query);
        &#125;
        return true;
    &#125;
    return false;
&#125;
</code></pre>
<p>这里点击搜索时，判空，然后通过 GeocodeSearch实例的getFromLocationNameAsyn来通过名称搜索地址。</p>
<h3 id="8-4-清空marker"><a href="#8-4-清空marker" class="headerlink" title="8.4 清空marker"></a>8.4 清空marker</h3><pre><code class="line-numbers language-Java">/**
    * 清空地图Marker
    *
    * @param view
    */
public void clearAllMarker(View view) &#123;
    if (markerList != null &amp;&amp; markerList.size()&gt;0)&#123;
        for (Marker markerItem : markerList) &#123;
            markerItem.remove();
        &#125;
    &#125;
    fabClearMarker.hide();
&#125;
</code></pre>
<p>这里是存储了Marker到一个集合，清除的时候，调用marker的remove方法即可。</p>
<h3 id="8-5-Marker的点击和拖拽"><a href="#8-5-Marker的点击和拖拽" class="headerlink" title="8.5 Marker的点击和拖拽"></a>8.5 Marker的点击和拖拽</h3><p>需要实现下 Amap.OnMarkerClickListener 接口。</p>
<p>然后需要配置下map的marker点击事件：</p>
<pre><code class="line-numbers language-Java">//设置地图Marker点击事件
aMap.setOnMarkerClickListener(this);
</code></pre>
<p>具体实现如下：</p>
<pre><code class="line-numbers language-Java">/**
    * Marker点击事件
    *
    * @param marker
    * @return
    */
@Override
public boolean onMarkerClick(Marker marker) &#123;
    //showMsg(&quot;点击了标点&quot;);
    //显示InfoWindow
    if (!marker.isInfoWindowShown()) &#123;
        //显示
        marker.showInfoWindow();
    &#125; else &#123;
        //隐藏
        marker.hideInfoWindow();
    &#125;
    return true;
&#125;
</code></pre>
<p>拖拽比较类似，<br>先配置map的markerDragListener事件：</p>
<pre><code class="line-numbers language-Java">//设置地图Marker拖拽事件
aMap.setOnMarkerDragListener(this);
</code></pre>
<p>然后实现这个接口：</p>
<pre><code class="line-numbers language-Java">/**
    * 开始拖动
    *
    * @param marker
    */
@Override
public void onMarkerDragStart(Marker marker) &#123;
    Log.d(TAG, &quot;开始拖动&quot;);
&#125;

/**
    * 拖动中
    *
    * @param marker
    */
@Override
public void onMarkerDrag(Marker marker) &#123;
    Log.d(TAG, &quot;拖动中&quot;);
&#125;

/**
    * 拖动完成
    *
    * @param marker
    */
@Override
public void onMarkerDragEnd(Marker marker) &#123;
    Log.d(TAG, &quot;拖动完成&quot;);
&#125;
</code></pre>
<p>但是实现需要配置marker可点拖动状态：</p>
<pre><code class="line-numbers language-Java">Marker marker = aMap.addMarker(new MarkerOptions()
            .draggable(true)//可拖动
            .position(latLng)
            .title(&quot;标题&quot;)
            .snippet(&quot;详细信息&quot;));
</code></pre>
<h3 id="8-6-绘制InfoWindow"><a href="#8-6-绘制InfoWindow" class="headerlink" title="8.6 绘制InfoWindow"></a>8.6 绘制InfoWindow</h3><pre><code class="line-numbers language-Java">Marker marker = aMap.addMarker(new MarkerOptions()
            .draggable(true)//可拖动
            .position(latLng)
            .title(&quot;标题&quot;)
            .snippet(&quot;详细信息&quot;));
</code></pre>
<p>这里配置title和snippet，其实就是一个窗体。</p>
<p>然后通过marker.showInfoWindow或者hideInfoWindow方法实现显示或隐藏。</p>
<p>如何自定义InfoWindow呢？<br>首先需要在Activity中实现 AMAP.InfoWindowAdapter接口。</p>
<pre><code class="line-numbers language-Java">/**
    * 修改背景
    *
    * @param marker
    */
@Override
public View getInfoWindow(Marker marker) &#123;
    View infoWindow = getLayoutInflater().inflate(
            R.layout.custom_info_window, null);

    render(marker, infoWindow);
    return infoWindow;
&#125;

/**
    * 修改内容
    *
    * @param marker
    * @return
    */
@Override
public View getInfoContents(Marker marker) &#123;
    View infoContent = getLayoutInflater().inflate(
            R.layout.custom_info_contents, null);
    render(marker, infoContent);
    return infoContent;
&#125;
</code></pre>
<p>通过这两个方法可以自定义infoWindow。</p>
<p>其次infoWindow也是可以点击的，<br>我们需要再给Activity实现一个接口，AMap.OnInfoWindowClickListener,</p>
<pre><code class="line-numbers language-Java">//设置InfoWindow点击事件
aMap.setOnInfoWindowClickListener(this);
</code></pre>
<p>然后继续实现接口：</p>
<pre><code class="line-numbers language-Java">@Override
public void onInfoWindowClick(Marker marker) &#123;
    showMsg(&quot;弹窗内容：标题：&quot; + marker.getTitle() + &quot;\n片段：&quot; + marker.getSnippet());
&#125;
</code></pre>
<h3 id="8-7-如何改变地图中心点"><a href="#8-7-如何改变地图中心点" class="headerlink" title="8.7 如何改变地图中心点"></a>8.7 如何改变地图中心点</h3><p>希望点击一下就可以移动到所在地，这其实是比较容易做到的，回顾我们现在是一进入地图就会定位到当前所在地，而当我点击地图上其他位置时，会增加一个标点，而我们要做的就是把这个标点作为地图中心，然后移动地图位置即可。</p>
<pre><code class="line-numbers language-Java">/**
    * 改变地图中心位置
    * @param latLng 位置
    */
private void updateMapCenter(LatLng latLng) &#123;
    // CameraPosition 第一个参数： 目标位置的屏幕中心点经纬度坐标。
    // CameraPosition 第二个参数： 目标可视区域的缩放级别
    // CameraPosition 第三个参数： 目标可视区域的倾斜度，以角度为单位。
    // CameraPosition 第四个参数： 可视区域指向的方向，以角度为单位，从正北向顺时针方向计算，从0度到360度
    CameraPosition cameraPosition = new CameraPosition(latLng, 16, 30, 0);
    //位置变更
    CameraUpdate cameraUpdate = CameraUpdateFactory.newCameraPosition(cameraPosition);
    //改变位置
    aMap.moveCamera(cameraUpdate);
&#125;
</code></pre>
<p>用这个方法即可。</p>
<h2 id="9-出行路线规划"><a href="#9-出行路线规划" class="headerlink" title="9 出行路线规划"></a>9 出行路线规划</h2><h3 id="9-1-步行路线规划"><a href="#9-1-步行路线规划" class="headerlink" title="9.1 步行路线规划"></a>9.1 步行路线规划</h3><pre><code class="line-numbers language-Java">//起点
private LatLonPoint mStartPoint;
//终点
private LatLonPoint mEndPoint;
</code></pre>
<p>帮助类：</p>
<pre><code class="line-numbers language-Java">package com.llw.mapdemo.util;

public class ChString &#123;
    public static final String Kilometer = &quot;\u516c\u91cc&quot;;// &quot;公里&quot;;
    public static final String Meter = &quot;\u7c73&quot;;// &quot;米&quot;;
    public static final String ByFoot = &quot;\u6b65\u884c&quot;;// &quot;步行&quot;;
    public static final String To = &quot;\u53bb\u5f80&quot;;// &quot;去往&quot;;
    public static final String Station = &quot;\u8f66\u7ad9&quot;;// &quot;车站&quot;;
    public static final String TargetPlace = &quot;\u76ee\u7684\u5730&quot;;// &quot;目的地&quot;;
    public static final String StartPlace = &quot;\u51fa\u53d1\u5730&quot;;// &quot;出发地&quot;;
    public static final String About = &quot;\u5927\u7ea6&quot;;// &quot;大约&quot;;
    public static final String Direction = &quot;\u65b9\u5411&quot;;// &quot;方向&quot;;

    public static final String GetOn = &quot;\u4e0a\u8f66&quot;;// &quot;上车&quot;;
    public static final String GetOff = &quot;\u4e0b\u8f66&quot;;// &quot;下车&quot;;
    public static final String Zhan = &quot;\u7ad9&quot;;// &quot;站&quot;;

    public static final String cross = &quot;\u4ea4\u53c9\u8def\u53e3&quot;; // 交叉路口
    public static final String type = &quot;\u7c7b\u522b&quot;; // 类别
    public static final String address = &quot;\u5730\u5740&quot;; // 地址
    public static final String PrevStep = &quot;\u4e0a\u4e00\u6b65&quot;;
    public static final String NextStep = &quot;\u4e0b\u4e00\u6b65&quot;;
    public static final String Gong = &quot;\u516c\u4ea4&quot;;
    public static final String ByBus = &quot;\u4e58\u8f66&quot;;
    public static final String Arrive = &quot;\u5230\u8FBE&quot;;// 到达
&#125;
</code></pre>
<p>然后下面是地图帮助类：</p>
<pre><code class="line-numbers language-Java">package com.llw.mapdemo.util;

import com.amap.api.maps.model.LatLng;
import com.amap.api.services.core.LatLonPoint;

import java.text.DecimalFormat;

/**
 * 地图帮助类
 * @author llw
 */
public class MapUtil &#123;

    /**
     * 把LatLng对象转化为LatLonPoint对象
     */
    public static LatLonPoint convertToLatLonPoint(LatLng latLng) &#123;
        return new LatLonPoint(latLng.latitude, latLng.longitude);
    &#125;

    /**
     * 把LatLonPoint对象转化为LatLon对象
     */
    public static LatLng convertToLatLng(LatLonPoint latLonPoint) &#123;
        return new LatLng(latLonPoint.getLatitude(), latLonPoint.getLongitude());
    &#125;

    public static String getFriendlyTime(int second) &#123;
        if (second &gt; 3600) &#123;
            int hour = second / 3600;
            int miniate = (second % 3600) / 60;
            return hour + &quot;小时&quot; + miniate + &quot;分钟&quot;;
        &#125;
        if (second &gt;= 60) &#123;
            int miniate = second / 60;
            return miniate + &quot;分钟&quot;;
        &#125;
        return second + &quot;秒&quot;;
    &#125;

    public static String getFriendlyLength(int lenMeter) &#123;
        if (lenMeter &gt; 10000) // 10 km
        &#123;
            int dis = lenMeter / 1000;
            return dis + ChString.Kilometer;
        &#125;

        if (lenMeter &gt; 1000) &#123;
            float dis = (float) lenMeter / 1000;
            DecimalFormat fnum = new DecimalFormat(&quot;##0.0&quot;);
            String dstr = fnum.format(dis);
            return dstr + ChString.Kilometer;
        &#125;

        if (lenMeter &gt; 100) &#123;
            int dis = lenMeter / 50 * 50;
            return dis + ChString.Meter;
        &#125;

        int dis = lenMeter / 10 * 10;
        if (dis == 0) &#123;
            dis = 10;
        &#125;

        return dis + ChString.Meter;
    &#125;

&#125;
</code></pre>
<p>这里定位之后，设置一个起点。</p>
<pre><code class="line-numbers language-Java">//设置起点
mStartPoint = convertToLatLonPoint(new LatLng(latitude, longitude));
</code></pre>
<p>通过经纬度，构建LatLng对象，然后将LatLng转为LatLonPoint。最后赋值给起点mStartPoint。</p>
<p>点击地图，设置终点：</p>
<pre><code class="line-numbers language-Java">/**
    * 点击地图
    */
@Override
public void onMapClick(LatLng latLng) &#123;
    //终点
    mEndPoint = convertToLatLonPoint(latLng);
&#125;
</code></pre>
<p>搜索路线需要建立一个RouteSearch对象：</p>
<pre><code class="line-numbers language-Java">//路线搜索对象
private RouteSearch routeSearch;
</code></pre>
<p>然后初始化：</p>
<pre><code class="line-numbers language-Java">/**
    * 初始化路线
    */
private void initRoute() &#123;
    try &#123;
        routeSearch = new RouteSearch(this);
    &#125; catch (AMapException e) &#123;
        e.printStackTrace();
    &#125;
    routeSearch.setRouteSearchListener(this);
&#125;
</code></pre>
<p>这里设置了监听，所以需要重写几个路线规划的方法：</p>
<p>步行规划路径结果：</p>
<pre><code class="line-numbers language-Java">/**
    * 步行规划路径结果
    *
    * @param walkRouteResult 结果
    * @param code            结果码
    */
@Override
public void onWalkRouteSearched(WalkRouteResult walkRouteResult, int code) &#123;
    aMap.clear();// 清理地图上的所有覆盖物
    if (code == AMapException.CODE_AMAP_SUCCESS) &#123;
        if (walkRouteResult != null &amp;&amp; walkRouteResult.getPaths() != null) &#123;
            if (walkRouteResult.getPaths().size() &gt; 0) &#123;
                final WalkPath walkPath = walkRouteResult.getPaths().get(0);
                if (walkPath == null) &#123;
                    return;
                &#125;
                //绘制路线
                WalkRouteOverlay walkRouteOverlay = new WalkRouteOverlay(
                        this, aMap, walkPath,
                        walkRouteResult.getStartPos(),
                        walkRouteResult.getTargetPos());
                walkRouteOverlay.removeFromMap();
                walkRouteOverlay.addToMap();
                walkRouteOverlay.zoomToSpan();

                int dis = (int) walkPath.getDistance();
                int dur = (int) walkPath.getDuration();
                String des = MapUtil.getFriendlyTime(dur) + &quot;(&quot; + MapUtil.getFriendlyLength(dis) + &quot;)&quot;;
                //显示步行花费时间
                tvTime.setText(des);
                bottomLayout.setVisibility(View.VISIBLE);
                //跳转到路线详情页面
                bottomLayout.setOnClickListener(new View.OnClickListener() &#123;
                    @Override
                    public void onClick(View v) &#123;
                        Intent intent = new Intent(RouteActivity.this,
                                RouteDetailActivity.class);
                        intent.putExtra(&quot;type&quot;, 0);
                        intent.putExtra(&quot;path&quot;, walkPath);
                        startActivity(intent);
                    &#125;
                &#125;);
            &#125; else if (walkRouteResult.getPaths() == null) &#123;
                showMsg(&quot;对不起，没有搜索到相关数据！&quot;);
            &#125;
        &#125; else &#123;
            showMsg(&quot;对不起，没有搜索到相关数据！&quot;);
        &#125;
    &#125; else &#123;
        showMsg(&quot;错误码；&quot; + code);
    &#125;
&#125;
</code></pre>
<p>怎么触发路线搜索：<br>当起点和终点通过地址转坐标方式，拿到地址后，就可以开始路线搜索了</p>
<pre><code class="line-numbers language-Java">if (mStartPoint != null &amp;&amp; mEndPoint != null) &#123;
    //开始路线搜索
    startRouteSearch();
&#125;
</code></pre>
<p>然后开始路线搜索：</p>
<pre><code class="line-numbers language-Java">/**
    * 开始路线搜索
    */
private void startRouteSearch() &#123;
    //在地图上添加起点Marker
    aMap.addMarker(new MarkerOptions()
            .position(convertToLatLng(mStartPoint))
            .icon(BitmapDescriptorFactory.fromResource(R.drawable.start)));
    //在地图上添加终点Marker
    aMap.addMarker(new MarkerOptions()
            .position(convertToLatLng(mEndPoint))
            .icon(BitmapDescriptorFactory.fromResource(R.drawable.end)));

    //搜索路线 构建路径的起终点
    final RouteSearch.FromAndTo fromAndTo = new RouteSearch.FromAndTo(
            mStartPoint, mEndPoint);

    //出行方式判断
    switch (TRAVEL_MODE) &#123;
        case 0://步行
            //构建步行路线搜索对象
            RouteSearch.WalkRouteQuery query = new RouteSearch.WalkRouteQuery(fromAndTo, RouteSearch.WalkDefault);
            // 异步路径规划步行模式查询
            routeSearch.calculateWalkRouteAsyn(query);
            break;
        case 1://骑行
            //构建骑行路线搜索对象
            RouteSearch.RideRouteQuery rideQuery = new RouteSearch.RideRouteQuery(fromAndTo, RouteSearch.WalkDefault);
            //骑行规划路径计算
            routeSearch.calculateRideRouteAsyn(rideQuery);
            break;
        case 2://驾车
            //构建驾车路线搜索对象  剩余三个参数分别是：途经点、避让区域、避让道路
            RouteSearch.DriveRouteQuery driveQuery = new RouteSearch.DriveRouteQuery(fromAndTo, RouteSearch.WalkDefault, null, null, &quot;&quot;);
            //驾车规划路径计算
            routeSearch.calculateDriveRouteAsyn(driveQuery);
            break;
        case 3://公交
            //构建驾车路线搜索对象 第三个参数表示公交查询城市区号，第四个参数表示是否计算夜班车，0表示不计算,1表示计算
            RouteSearch.BusRouteQuery busQuery = new RouteSearch.BusRouteQuery(fromAndTo, RouteSearch.BusLeaseWalk, city, 0);
            //公交规划路径计算
            routeSearch.calculateBusRouteAsyn(busQuery);
            break;
        default:
            break;
    &#125;
&#125;
</code></pre>
<p>好的，现在通过接口，拿到路线返回的结果了。现在需要对路线进行绘制。</p>
<p>需要先安排一个工具类：</p>
<pre><code class="line-numbers language-Java">
import android.graphics.Bitmap;

import com.amap.api.maps.model.LatLng;
import com.amap.api.services.core.LatLonPoint;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;

/**
 * 地图服务工具类
 */
class AMapServicesUtil &#123;
    public static int BUFFER_SIZE = 2048;

    public static byte[] inputStreamToByte(InputStream in) throws IOException &#123;

        ByteArrayOutputStream outStream = new ByteArrayOutputStream();
        byte[] data = new byte[BUFFER_SIZE];
        int count = -1;
        while ((count = in.read(data, 0, BUFFER_SIZE)) != -1)&#123;
            outStream.write(data, 0, count);
        &#125;

        data = null;
        return outStream.toByteArray();
    &#125;
    public static LatLonPoint convertToLatLonPoint(LatLng latlon) &#123;
        return new LatLonPoint(latlon.latitude, latlon.longitude);
    &#125;
    public static LatLng convertToLatLng(LatLonPoint latLonPoint) &#123;
        return new LatLng(latLonPoint.getLatitude(), latLonPoint.getLongitude());
    &#125;
    public static ArrayList&lt;LatLng&gt; convertArrList(List&lt;LatLonPoint&gt; shapes) &#123;
        ArrayList&lt;LatLng&gt; lineShapes = new ArrayList&lt;LatLng&gt;();
        for (LatLonPoint point : shapes) &#123;
            LatLng latLngTemp = AMapServicesUtil.convertToLatLng(point);
            lineShapes.add(latLngTemp);
        &#125;
        return lineShapes;
    &#125;
    public static Bitmap zoomBitmap(Bitmap bitmap, float res) &#123;
        if (bitmap == null) &#123;
            return null;
        &#125;
        int width, height;
        width = (int) (bitmap.getWidth() * res);
        height = (int) (bitmap.getHeight() * res);
        Bitmap newbmp = Bitmap.createScaledBitmap(bitmap, width, height, true);
        return newbmp;
    &#125;

&#125;
</code></pre>
<p>图层叠加工具类：</p>
<pre><code class="line-numbers language-Java">import java.util.ArrayList;
import java.util.List;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Color;

import com.amap.api.maps.AMap;
import com.amap.api.maps.CameraUpdateFactory;
import com.amap.api.maps.model.BitmapDescriptor;
import com.amap.api.maps.model.BitmapDescriptorFactory;
import com.amap.api.maps.model.LatLng;
import com.amap.api.maps.model.LatLngBounds;
import com.amap.api.maps.model.Marker;
import com.amap.api.maps.model.MarkerOptions;
import com.amap.api.maps.model.Polyline;
import com.amap.api.maps.model.PolylineOptions;
import com.llw.mapdemo.R;

/**
 * 路线图层叠加
 */
public class RouteOverlay &#123;
    protected List&lt;Marker&gt; stationMarkers = new ArrayList&lt;Marker&gt;();
    protected List&lt;Polyline&gt; allPolyLines = new ArrayList&lt;Polyline&gt;();
    protected Marker startMarker;
    protected Marker endMarker;
    protected LatLng startPoint;
    protected LatLng endPoint;
    protected AMap mAMap;
    private Context mContext;
    private Bitmap startBit, endBit, busBit, walkBit, driveBit;
    protected boolean nodeIconVisible = true;

    public RouteOverlay(Context context) &#123;
        mContext = context;
    &#125;

    /**
     * 去掉BusRouteOverlay上所有的Marker。
     * @since V2.1.0
     */
    public void removeFromMap() &#123;
        if (startMarker != null) &#123;
            startMarker.remove();

        &#125;
        if (endMarker != null) &#123;
            endMarker.remove();
        &#125;
        for (Marker marker : stationMarkers) &#123;
            marker.remove();
        &#125;
        for (Polyline line : allPolyLines) &#123;
            line.remove();
        &#125;
        destroyBit();
    &#125;

    private void destroyBit() &#123;
        if (startBit != null) &#123;
            startBit.recycle();
            startBit = null;
        &#125;
        if (endBit != null) &#123;
            endBit.recycle();
            endBit = null;
        &#125;
        if (busBit != null) &#123;
            busBit.recycle();
            busBit = null;
        &#125;
        if (walkBit != null) &#123;
            walkBit.recycle();
            walkBit = null;
        &#125;
        if (driveBit != null) &#123;
            driveBit.recycle();
            driveBit = null;
        &#125;
    &#125;
    /**
     * 给起点Marker设置图标，并返回更换图标的图片。如不用默认图片，需要重写此方法。
     * @return 更换的Marker图片。
     * @since V2.1.0
     */
    protected BitmapDescriptor getStartBitmapDescriptor() &#123;
        return BitmapDescriptorFactory.fromResource(R.drawable.amap_start);
    &#125;
    /**
     * 给终点Marker设置图标，并返回更换图标的图片。如不用默认图片，需要重写此方法。
     * @return 更换的Marker图片。
     * @since V2.1.0
     */
    protected BitmapDescriptor getEndBitmapDescriptor() &#123;
        return BitmapDescriptorFactory.fromResource(R.drawable.amap_end);
    &#125;
    /**
     * 给公交Marker设置图标，并返回更换图标的图片。如不用默认图片，需要重写此方法。
     * @return 更换的Marker图片。
     * @since V2.1.0
     */
    protected BitmapDescriptor getBusBitmapDescriptor() &#123;
        return BitmapDescriptorFactory.fromResource(R.drawable.amap_bus);
    &#125;
    /**
     * 给步行Marker设置图标，并返回更换图标的图片。如不用默认图片，需要重写此方法。
     * @return 更换的Marker图片。
     * @since V2.1.0
     */
    protected BitmapDescriptor getWalkBitmapDescriptor() &#123;
        return BitmapDescriptorFactory.fromResource(R.drawable.amap_man);
    &#125;

    protected BitmapDescriptor getDriveBitmapDescriptor() &#123;
        return BitmapDescriptorFactory.fromResource(R.drawable.amap_car);
    &#125;

    protected void addStartAndEndMarker() &#123;
        startMarker = mAMap.addMarker((new MarkerOptions())
                .position(startPoint).icon(getStartBitmapDescriptor())
                .title(&quot;\u8D77\u70B9&quot;));
        // startMarker.showInfoWindow();

        endMarker = mAMap.addMarker((new MarkerOptions()).position(endPoint)
                .icon(getEndBitmapDescriptor()).title(&quot;\u7EC8\u70B9&quot;));
        // mAMap.moveCamera(CameraUpdateFactory.newLatLngZoom(startPoint,
        // getShowRouteZoom()));
    &#125;
    /**
     * 移动镜头到当前的视角。
     * @since V2.1.0
     */
    public void zoomToSpan() &#123;
        if (startPoint != null) &#123;
            if (mAMap == null) &#123;
                return;
            &#125;
            try &#123;
                LatLngBounds bounds = getLatLngBounds();
                mAMap.animateCamera(CameraUpdateFactory
                        .newLatLngBounds(bounds, 100));
            &#125; catch (Throwable e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;

    protected LatLngBounds getLatLngBounds() &#123;
        LatLngBounds.Builder b = LatLngBounds.builder();
        b.include(new LatLng(startPoint.latitude, startPoint.longitude));
        b.include(new LatLng(endPoint.latitude, endPoint.longitude));
        return b.build();
    &#125;
    /**
     * 路段节点图标控制显示接口。
     * @param visible true为显示节点图标，false为不显示。
     * @since V2.3.1
     */
    public void setNodeIconVisibility(boolean visible) &#123;
        try &#123;
            nodeIconVisible = visible;
            if (this.stationMarkers != null &amp;&amp; this.stationMarkers.size() &gt; 0) &#123;
                for (int i = 0; i &lt; this.stationMarkers.size(); i++) &#123;
                    this.stationMarkers.get(i).setVisible(visible);
                &#125;
            &#125;
        &#125; catch (Throwable e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    
    protected void addStationMarker(MarkerOptions options) &#123;
        if(options == null) &#123;
            return;
        &#125;
        Marker marker = mAMap.addMarker(options);
        if(marker != null) &#123;
            stationMarkers.add(marker);
        &#125;
        
    &#125;

    protected void addPolyLine(PolylineOptions options) &#123;
        if(options == null) &#123;
            return;
        &#125;
        Polyline polyline = mAMap.addPolyline(options);
        if(polyline != null) &#123;
            allPolyLines.add(polyline);
        &#125;
    &#125;
    
    protected float getRouteWidth() &#123;
        return 18f;
    &#125;

    protected int getWalkColor() &#123;
        return Color.parseColor(&quot;#6db74d&quot;);
    &#125;

    /**
     * 自定义路线颜色。
     * return 自定义路线颜色。
     * @since V2.2.1
     */
    protected int getBusColor() &#123;
        return Color.parseColor(&quot;#537edc&quot;);
    &#125;

    protected int getDriveColor() &#123;
        return Color.parseColor(&quot;#537edc&quot;);
    &#125;

    // protected int getShowRouteZoom() &#123;
    // return 15;
    // &#125;
&#125;
</code></pre>
<p>步行路线图层类：</p>
<pre><code class="line-numbers language-Java">package com.llw.mapdemo.overlay;

import java.util.List;

import com.amap.api.maps.AMap;
import com.amap.api.maps.model.BitmapDescriptor;
import com.amap.api.maps.model.LatLng;
import com.amap.api.maps.model.MarkerOptions;
import com.amap.api.maps.model.PolylineOptions;
import com.amap.api.services.core.LatLonPoint;
import com.amap.api.services.route.WalkPath;
import com.amap.api.services.route.WalkStep;

import android.content.Context;

/**
 * 步行路线图层类。在高德地图API里，如果要显示步行路线规划，可以用此类来创建步行路线图层。如不满足需求，也可以自己创建自定义的步行路线图层。
 * @since V2.1.0
 */
public class WalkRouteOverlay extends RouteOverlay &#123;

    private PolylineOptions mPolylineOptions;

    private BitmapDescriptor walkStationDescriptor= null;

    private WalkPath walkPath;
    /**
     * 通过此构造函数创建步行路线图层。
     * @param context 当前activity。
     * @param amap 地图对象。
     * @param path 步行路线规划的一个方案。详见搜索服务模块的路径查询包（com.amap.api.services.route）中的类 &lt;strong&gt;&lt;a href=&quot;../../../../../../Search/com/amap/api/services/route/WalkStep.html&quot; title=&quot;com.amap.api.services.route中的类&quot;&gt;WalkStep&lt;/a&gt;&lt;/strong&gt;。
     * @param start 起点。详见搜索服务模块的核心基础包（com.amap.api.services.core）中的类&lt;strong&gt;&lt;a href=&quot;../../../../../../Search/com/amap/api/services/core/LatLonPoint.html&quot; title=&quot;com.amap.api.services.core中的类&quot;&gt;LatLonPoint&lt;/a&gt;&lt;/strong&gt;。
     * @param end 终点。详见搜索服务模块的核心基础包（com.amap.api.services.core）中的类&lt;strong&gt;&lt;a href=&quot;../../../../../../Search/com/amap/api/services/core/LatLonPoint.html&quot; title=&quot;com.amap.api.services.core中的类&quot;&gt;LatLonPoint&lt;/a&gt;&lt;/strong&gt;。
     * @since V2.1.0
     */
    public WalkRouteOverlay(Context context, AMap amap, WalkPath path,
            LatLonPoint start, LatLonPoint end) &#123;
        super(context);
        this.mAMap = amap;
        this.walkPath = path;
        startPoint = AMapServicesUtil.convertToLatLng(start);
        endPoint = AMapServicesUtil.convertToLatLng(end);
    &#125;
    /**
     * 添加步行路线到地图中。
     * @since V2.1.0
     */
    public void addToMap() &#123;

        initPolylineOptions();
        try &#123;
            List&lt;WalkStep&gt; walkPaths = walkPath.getSteps();
            for (int i = 0; i &lt; walkPaths.size(); i++) &#123;
                WalkStep walkStep = walkPaths.get(i);
                LatLng latLng = AMapServicesUtil.convertToLatLng(walkStep
                        .getPolyline().get(0));
                
                addWalkStationMarkers(walkStep, latLng);
                addWalkPolyLines(walkStep);
               
            &#125;
            addStartAndEndMarker();

            showPolyline();
        &#125; catch (Throwable e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    
    /**
     * 检查这一步的最后一点和下一步的起始点之间是否存在空隙
     */
    private void checkDistanceToNextStep(WalkStep walkStep,
            WalkStep walkStep1) &#123;
        LatLonPoint lastPoint = getLastWalkPoint(walkStep);
        LatLonPoint nextFirstPoint = getFirstWalkPoint(walkStep1);
        if (!(lastPoint.equals(nextFirstPoint))) &#123;
            addWalkPolyLine(lastPoint, nextFirstPoint);
        &#125;
    &#125;

    /**
     * @param walkStep
     * @return
     */
    private LatLonPoint getLastWalkPoint(WalkStep walkStep) &#123;
        return walkStep.getPolyline().get(walkStep.getPolyline().size() - 1);
    &#125;

    /**
     * @param walkStep
     * @return
     */
    private LatLonPoint getFirstWalkPoint(WalkStep walkStep) &#123;
        return walkStep.getPolyline().get(0);
    &#125;


    private void addWalkPolyLine(LatLonPoint pointFrom, LatLonPoint pointTo) &#123;
        addWalkPolyLine(AMapServicesUtil.convertToLatLng(pointFrom), AMapServicesUtil.convertToLatLng(pointTo));
    &#125;

    private void addWalkPolyLine(LatLng latLngFrom, LatLng latLngTo) &#123;
        mPolylineOptions.add(latLngFrom, latLngTo);
    &#125;

    /**
     * @param walkStep
     */
    private void addWalkPolyLines(WalkStep walkStep) &#123;
        mPolylineOptions.addAll(AMapServicesUtil.convertArrList(walkStep.getPolyline()));
    &#125;

    /**
     * @param walkStep
     * @param position
     */
    private void addWalkStationMarkers(WalkStep walkStep, LatLng position) &#123;
        addStationMarker(new MarkerOptions()
                .position(position)
                .title(&quot;\u65B9\u5411:&quot; + walkStep.getAction()
                        + &quot;\n\u9053\u8DEF:&quot; + walkStep.getRoad())
                .snippet(walkStep.getInstruction()).visible(nodeIconVisible)
                .anchor(0.5f, 0.5f).icon(walkStationDescriptor));
    &#125;

    /**
     * 初始化线段属性
     */
    private void initPolylineOptions() &#123;

        if(walkStationDescriptor == null) &#123;
            walkStationDescriptor = getWalkBitmapDescriptor();
        &#125;

        mPolylineOptions = null;

        mPolylineOptions = new PolylineOptions();
        mPolylineOptions.color(getWalkColor()).width(getRouteWidth());
    &#125;


    private void showPolyline() &#123;
        addPolyLine(mPolylineOptions);
    &#125;
&#125;
</code></pre>
<p>通过这三个类，完成步行路线绘制。<br>主要是地图的View，通过参数，传递给WalkRouteOverLay中，实现路线绘制。</p>
<h3 id="9-2-骑行路线规划"><a href="#9-2-骑行路线规划" class="headerlink" title="9.2 骑行路线规划"></a>9.2 骑行路线规划</h3><p>骑行其实和步行差不多，只是路线限制时图层不同而已，其他的都类似，写起来也是比较简单的。</p>
<p>在startRouteSearch方法中：</p>
<pre><code class="line-numbers language-Java"> //出行方式判断
switch (TRAVEL_MODE) &#123;
    case 0://步行
        //构建步行路线搜索对象
        RouteSearch.WalkRouteQuery query = new RouteSearch.WalkRouteQuery(fromAndTo, RouteSearch.WalkDefault);
        // 异步路径规划步行模式查询
        routeSearch.calculateWalkRouteAsyn(query);
        break;
    case 1://骑行
        //构建骑行路线搜索对象
        RouteSearch.RideRouteQuery rideQuery = new RouteSearch.RideRouteQuery(fromAndTo, RouteSearch.WalkDefault);
        //骑行规划路径计算
        routeSearch.calculateRideRouteAsyn(rideQuery);
        break;
</code></pre>
<p>这里通过routeSearch来计算骑行路线。</p>
<p>然后再MapUtil工具中，新增一个方法：</p>
<pre><code class="line-numbers language-Java">/**
    * 把集合体的LatLonPoint转化为集合体的LatLng
    */
public static ArrayList&lt;LatLng&gt; convertArrList(List&lt;LatLonPoint&gt; shapes) &#123;
    ArrayList&lt;LatLng&gt; lineShapes = new ArrayList&lt;LatLng&gt;();
    for (LatLonPoint point : shapes) &#123;
        LatLng latLngTemp = convertToLatLng(point);
        lineShapes.add(latLngTemp);
    &#125;
    return lineShapes;
&#125;
</code></pre>
<p>然后新增一个RideRouteOverlay，用于在地图上绘制骑行的图层：</p>
<pre><code class="line-numbers language-Java">import android.content.Context;

import com.amap.api.maps.AMap;
import com.amap.api.maps.model.BitmapDescriptor;
import com.amap.api.maps.model.BitmapDescriptorFactory;
import com.amap.api.maps.model.LatLng;
import com.amap.api.maps.model.MarkerOptions;
import com.amap.api.maps.model.PolylineOptions;
import com.amap.api.services.core.LatLonPoint;
import com.amap.api.services.route.RidePath;
import com.amap.api.services.route.RideStep;
import com.llw.mapdemo.R;
import com.llw.mapdemo.util.MapUtil;

import java.util.List;

/**
 * 骑行路线图层类。在高德地图API里，如果要显示步行路线规划，可以用此类来创建骑行路线图层。如不满足需求，也可以自己创建自定义的骑行路线图层。
 * @since V3.5.0
 */
public class RideRouteOverlay extends RouteOverlay &#123;

    private PolylineOptions mPolylineOptions;
    
    private BitmapDescriptor walkStationDescriptor= null;

    private RidePath ridePath;
    /**
     * 通过此构造函数创建骑行路线图层。
     * @param context 当前activity。
     * @param amap 地图对象。
     * @param path 骑行路线规划的一个方案。详见搜索服务模块的路径查询包（com.amap.api.services.route）中的类 &lt;strong&gt;&lt;a href=&quot;../../../../../../Search/com/amap/api/services/route/WalkStep.html&quot; title=&quot;com.amap.api.services.route中的类&quot;&gt;WalkStep&lt;/a&gt;&lt;/strong&gt;。
     * @param start 起点。详见搜索服务模块的核心基础包（com.amap.api.services.core）中的类&lt;strong&gt;&lt;a href=&quot;../../../../../../Search/com/amap/api/services/core/LatLonPoint.html&quot; title=&quot;com.amap.api.services.core中的类&quot;&gt;LatLonPoint&lt;/a&gt;&lt;/strong&gt;。
     * @param end 终点。详见搜索服务模块的核心基础包（com.amap.api.services.core）中的类&lt;strong&gt;&lt;a href=&quot;../../../../../../Search/com/amap/api/services/core/LatLonPoint.html&quot; title=&quot;com.amap.api.services.core中的类&quot;&gt;LatLonPoint&lt;/a&gt;&lt;/strong&gt;。
     * @since V3.5.0
     */
    public RideRouteOverlay(Context context, AMap amap, RidePath path,
                            LatLonPoint start, LatLonPoint end) &#123;
        super(context);
        this.mAMap = amap;
        this.ridePath = path;
        startPoint = MapUtil.convertToLatLng(start);
        endPoint = MapUtil.convertToLatLng(end);
    &#125;
    /**
     * 添加骑行路线到地图中。
     * @since V3.5.0
     */
    public void addToMap() &#123;
        
        initPolylineOptions();
        try &#123;
            List&lt;RideStep&gt; ridePaths = ridePath.getSteps();
            for (int i = 0; i &lt; ridePaths.size(); i++) &#123;
                RideStep rideStep = ridePaths.get(i);
                LatLng latLng = MapUtil.convertToLatLng(rideStep
                        .getPolyline().get(0));
                
                addRideStationMarkers(rideStep, latLng);
                addRidePolyLines(rideStep);
            &#125;
            addStartAndEndMarker();
            
            showPolyline();
        &#125; catch (Throwable e) &#123;
            e.printStackTrace();
        &#125;
    &#125;


    /**
     * @param rideStep
     */
    private void addRidePolyLines(RideStep rideStep) &#123;
        mPolylineOptions.addAll(MapUtil.convertArrList(rideStep.getPolyline()));
    &#125;
    /**
     * @param rideStep
     * @param position
     */
    private void addRideStationMarkers(RideStep rideStep, LatLng position) &#123;
        addStationMarker(new MarkerOptions()
                .position(position)
                .title(&quot;\u65B9\u5411:&quot; + rideStep.getAction()
                        + &quot;\n\u9053\u8DEF:&quot; + rideStep.getRoad())
                .snippet(rideStep.getInstruction()).visible(nodeIconVisible)
                .anchor(0.5f, 0.5f).icon(walkStationDescriptor));
    &#125;
    
     /**
     * 初始化线段属性
     */
    private void initPolylineOptions() &#123;
        
        if(walkStationDescriptor == null) &#123;
            walkStationDescriptor = BitmapDescriptorFactory.fromResource(R.drawable.amap_ride);
        &#125;
        mPolylineOptions = null;
        mPolylineOptions = new PolylineOptions();
        mPolylineOptions.color(getDriveColor()).width(getRouteWidth());
    &#125;
     private void showPolyline() &#123;
            addPolyLine(mPolylineOptions);
        &#125;
&#125;
</code></pre>
<p>然后在骑行路径规划的接口回调中使用这个图层绘制：</p>
<pre><code class="line-numbers language-Java">/**
    * 骑行规划路径结果
    *
    * @param rideRouteResult 结果
    * @param code            结果码
    */
@Override
public void onRideRouteSearched(final RideRouteResult rideRouteResult, int code) &#123;
    aMap.clear();// 清理地图上的所有覆盖物
    if (code == AMapException.CODE_AMAP_SUCCESS) &#123;
        if (rideRouteResult != null &amp;&amp; rideRouteResult.getPaths() != null) &#123;
            if (rideRouteResult.getPaths().size() &gt; 0) &#123;
                final RidePath ridePath = rideRouteResult.getPaths()
                        .get(0);
                if(ridePath == null) &#123;
                    return;
                &#125;
                RideRouteOverlay rideRouteOverlay = new RideRouteOverlay(
                        this, aMap, ridePath,
                        rideRouteResult.getStartPos(),
                        rideRouteResult.getTargetPos());
                rideRouteOverlay.removeFromMap();
                rideRouteOverlay.addToMap();
                rideRouteOverlay.zoomToSpan();

                int dis = (int) ridePath.getDistance();
                int dur = (int) ridePath.getDuration();
                String des = MapUtil.getFriendlyTime(dur)+&quot;(&quot;+MapUtil.getFriendlyLength(dis)+&quot;)&quot;;
                Log.d(TAG, des);

            &#125; else if (rideRouteResult.getPaths() == null) &#123;
                showMsg(&quot;对不起，没有搜索到相关数据！&quot;);
            &#125;
        &#125; else &#123;
            showMsg(&quot;对不起，没有搜索到相关数据！&quot;);
        &#125;
    &#125; else &#123;
        showMsg(&quot;错误码；&quot; + code);
    &#125;
&#125;
</code></pre>
<h3 id="9-3-驾车路线规划"><a href="#9-3-驾车路线规划" class="headerlink" title="9.3 驾车路线规划"></a>9.3 驾车路线规划</h3><p>先增加计算驾车接口调用：</p>
<pre><code class="line-numbers language-Java">    case 2://驾车
        //构建驾车路线搜索对象  剩余三个参数分别是：途经点、避让区域、避让道路
        RouteSearch.DriveRouteQuery driveQuery = new RouteSearch.DriveRouteQuery(fromAndTo, RouteSearch.WalkDefault, null, null, &quot;&quot;);
        //驾车规划路径计算
        routeSearch.calculateDriveRouteAsyn(driveQuery);
        break;
</code></pre>
<p>然后增加图层工具：</p>
<pre><code class="line-numbers language-Java">import android.content.Context;
import android.graphics.Color;

import com.amap.api.maps.AMap;
import com.amap.api.maps.model.BitmapDescriptor;
import com.amap.api.maps.model.BitmapDescriptorFactory;
import com.amap.api.maps.model.LatLng;
import com.amap.api.maps.model.LatLngBounds;
import com.amap.api.maps.model.Marker;
import com.amap.api.maps.model.MarkerOptions;
import com.amap.api.maps.model.PolylineOptions;
import com.amap.api.services.core.LatLonPoint;
import com.amap.api.services.route.DrivePath;
import com.amap.api.services.route.DriveStep;
import com.amap.api.services.route.TMC;
import com.llw.mapdemo.R;
import com.llw.mapdemo.util.MapUtil;

import java.util.ArrayList;
import java.util.List;


/**
 * 驾车路线图层类
 */
public class DrivingRouteOverlay extends RouteOverlay&#123;

    private DrivePath drivePath;
    private List&lt;LatLonPoint&gt; throughPointList;
    private List&lt;Marker&gt; throughPointMarkerList = new ArrayList&lt;Marker&gt;();
    private boolean throughPointMarkerVisible = true;
    private List&lt;TMC&gt; tmcs;
    private PolylineOptions mPolylineOptions;
    private PolylineOptions mPolylineOptionscolor;
    private Context mContext;
    private boolean isColorfulline = true;
    private float mWidth = 25;
    private List&lt;LatLng&gt; mLatLngsOfPath;

    public void setIsColorfulline(boolean iscolorfulline) &#123;
        this.isColorfulline = iscolorfulline;
    &#125;

    /**
     * 根据给定的参数，构造一个导航路线图层类对象。
     *
     * @param amap      地图对象。
     * @param path 导航路线规划方案。
     * @param context   当前的activity对象。
     */
    public DrivingRouteOverlay(Context context, AMap amap, DrivePath path,
                               LatLonPoint start, LatLonPoint end, List&lt;LatLonPoint&gt; throughPointList) &#123;
        super(context);
        mContext = context; 
        mAMap = amap; 
        this.drivePath = path;
        startPoint = MapUtil.convertToLatLng(start);
        endPoint = MapUtil.convertToLatLng(end);
        this.throughPointList = throughPointList;
    &#125;

    @Override
    public float getRouteWidth() &#123;
        return mWidth;
    &#125;

    /**
     * 设置路线宽度
     *
     * @param mWidth 路线宽度，取值范围：大于0
     */
    public void setRouteWidth(float mWidth) &#123;
        this.mWidth = mWidth;
    &#125;

    /**
     * 添加驾车路线添加到地图上显示。
     */
    public void addToMap() &#123;
        initPolylineOptions();
        try &#123;
            if (mAMap == null) &#123;
                return;
            &#125;

            if (mWidth == 0 || drivePath == null) &#123;
                return;
            &#125;
            mLatLngsOfPath = new ArrayList&lt;LatLng&gt;();
            tmcs = new ArrayList&lt;TMC&gt;();
            List&lt;DriveStep&gt; drivePaths = drivePath.getSteps();
            for (DriveStep step : drivePaths) &#123;
                List&lt;LatLonPoint&gt; latlonPoints = step.getPolyline();
                List&lt;TMC&gt; tmclist = step.getTMCs();
                tmcs.addAll(tmclist);
                addDrivingStationMarkers(step, convertToLatLng(latlonPoints.get(0)));
                for (LatLonPoint latlonpoint : latlonPoints) &#123;
                    mPolylineOptions.add(convertToLatLng(latlonpoint));
                    mLatLngsOfPath.add(convertToLatLng(latlonpoint));
                &#125;
            &#125;
            if (startMarker != null) &#123;
                startMarker.remove();
                startMarker = null;
            &#125;
            if (endMarker != null) &#123;
                endMarker.remove();
                endMarker = null;
            &#125;
            addStartAndEndMarker();
            addThroughPointMarker();
            if (isColorfulline &amp;&amp; tmcs.size()&gt;0 ) &#123;
                colorWayUpdate(tmcs);
                showcolorPolyline();
            &#125;else &#123;
                showPolyline();
            &#125;            
            
        &#125; catch (Throwable e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    /**
     * 初始化线段属性
     */
    private void initPolylineOptions() &#123;

        mPolylineOptions = null;

        mPolylineOptions = new PolylineOptions();
        mPolylineOptions.color(getDriveColor()).width(getRouteWidth());
    &#125;

    private void showPolyline() &#123;
        addPolyLine(mPolylineOptions);
    &#125;
    
    private void showcolorPolyline() &#123;
        addPolyLine(mPolylineOptionscolor);
        
    &#125;

    /**
     * 根据不同的路段拥堵情况展示不同的颜色
     *
     * @param tmcSection
     */
    private void colorWayUpdate(List&lt;TMC&gt; tmcSection) &#123;
        if (mAMap == null) &#123;
            return;
        &#125;
        if (tmcSection == null || tmcSection.size() &lt;= 0) &#123;
            return;
        &#125;
        TMC segmentTrafficStatus;
        mPolylineOptionscolor = null;
        mPolylineOptionscolor = new PolylineOptions();
        mPolylineOptionscolor.width(getRouteWidth());
        List&lt;Integer&gt; colorList = new ArrayList&lt;Integer&gt;();
        mPolylineOptionscolor.add(MapUtil.convertToLatLng(tmcSection.get(0).getPolyline().get(0)));
        colorList.add(getDriveColor());
        for (int i = 0; i &lt; tmcSection.size(); i++) &#123;
            segmentTrafficStatus = tmcSection.get(i);
            int color = getcolor(segmentTrafficStatus.getStatus());
            List&lt;LatLonPoint&gt; mployline = segmentTrafficStatus.getPolyline();
            for (int j = 1; j &lt; mployline.size(); j++) &#123;
                mPolylineOptionscolor.add(MapUtil.convertToLatLng(mployline.get(j)));
                colorList.add(color);
            &#125;
        &#125;
        colorList.add(getDriveColor());
        mPolylineOptionscolor.colorValues(colorList);
    &#125;
    
    private int getcolor(String status) &#123;

        if (status.equals(&quot;畅通&quot;)) &#123;
            return Color.GREEN;
        &#125; else if (status.equals(&quot;缓行&quot;)) &#123;
             return Color.YELLOW;
        &#125; else if (status.equals(&quot;拥堵&quot;)) &#123;
            return Color.RED;
        &#125; else if (status.equals(&quot;严重拥堵&quot;)) &#123;
            return Color.parseColor(&quot;#990033&quot;);
        &#125; else &#123;
            return Color.parseColor(&quot;#537edc&quot;);
        &#125;	
    &#125;

    public LatLng convertToLatLng(LatLonPoint point) &#123;
        return new LatLng(point.getLatitude(),point.getLongitude());
  &#125;
    
    /**
     * @param driveStep
     * @param latLng
     */
    private void addDrivingStationMarkers(DriveStep driveStep, LatLng latLng) &#123;
        addStationMarker(new MarkerOptions()
                .position(latLng)
                .title(&quot;\u65B9\u5411:&quot; + driveStep.getAction()
                        + &quot;\n\u9053\u8DEF:&quot; + driveStep.getRoad())
                .snippet(driveStep.getInstruction()).visible(nodeIconVisible)
                .anchor(0.5f, 0.5f).icon(getDriveBitmapDescriptor()));
    &#125;

    @Override
    protected LatLngBounds getLatLngBounds() &#123;
        LatLngBounds.Builder b = LatLngBounds.builder();
        b.include(new LatLng(startPoint.latitude, startPoint.longitude));
        b.include(new LatLng(endPoint.latitude, endPoint.longitude));
        if (this.throughPointList != null &amp;&amp; this.throughPointList.size() &gt; 0) &#123;
            for (int i = 0; i &lt; this.throughPointList.size(); i++) &#123;
                b.include(new LatLng(
                        this.throughPointList.get(i).getLatitude(),
                        this.throughPointList.get(i).getLongitude()));
            &#125;
        &#125;
        return b.build();
    &#125;

    public void setThroughPointIconVisibility(boolean visible) &#123;
        try &#123;
            throughPointMarkerVisible = visible;
            if (this.throughPointMarkerList != null
                    &amp;&amp; this.throughPointMarkerList.size() &gt; 0) &#123;
                for (int i = 0; i &lt; this.throughPointMarkerList.size(); i++) &#123;
                    this.throughPointMarkerList.get(i).setVisible(visible);
                &#125;
            &#125;
        &#125; catch (Throwable e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    
    private void addThroughPointMarker() &#123;
        if (this.throughPointList != null &amp;&amp; this.throughPointList.size() &gt; 0) &#123;
            LatLonPoint latLonPoint = null;
            for (int i = 0; i &lt; this.throughPointList.size(); i++) &#123;
                latLonPoint = this.throughPointList.get(i);
                if (latLonPoint != null) &#123;
                    throughPointMarkerList.add(mAMap
                            .addMarker((new MarkerOptions())
                                    .position(
                                            new LatLng(latLonPoint
                                                    .getLatitude(), latLonPoint
                                                    .getLongitude()))
                                    .visible(throughPointMarkerVisible)
                                    .icon(getThroughPointBitDes())
                                    .title(&quot;\u9014\u7ECF\u70B9&quot;)));
                &#125;
            &#125;
        &#125;
    &#125;
    
    private BitmapDescriptor getThroughPointBitDes() &#123;
        return BitmapDescriptorFactory.fromResource(R.drawable.amap_through);
       
    &#125;

    /**
     * 获取两点间距离
     *
     * @param start
     * @param end
     * @return
     */
    public static int calculateDistance(LatLng start, LatLng end) &#123;
        double x1 = start.longitude;
        double y1 = start.latitude;
        double x2 = end.longitude;
        double y2 = end.latitude;
        return calculateDistance(x1, y1, x2, y2);
    &#125;

    public static int calculateDistance(double x1, double y1, double x2, double y2) &#123;
        final double NF_pi = 0.01745329251994329; // 弧度 PI/180
        x1 *= NF_pi;
        y1 *= NF_pi;
        x2 *= NF_pi;
        y2 *= NF_pi;
        double sinx1 = Math.sin(x1);
        double siny1 = Math.sin(y1);
        double cosx1 = Math.cos(x1);
        double cosy1 = Math.cos(y1);
        double sinx2 = Math.sin(x2);
        double siny2 = Math.sin(y2);
        double cosx2 = Math.cos(x2);
        double cosy2 = Math.cos(y2);
        double[] v1 = new double[3];
        v1[0] = cosy1 * cosx1 - cosy2 * cosx2;
        v1[1] = cosy1 * sinx1 - cosy2 * sinx2;
        v1[2] = siny1 - siny2;
        double dist = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1] + v1[2] * v1[2]);

        return (int) (Math.asin(dist / 2) * 12742001.5798544);
    &#125;


    //获取指定两点之间固定距离点
    public static LatLng getPointForDis(LatLng sPt, LatLng ePt, double dis) &#123;
        double lSegLength = calculateDistance(sPt, ePt);
        double preResult = dis / lSegLength;
        return new LatLng((ePt.latitude - sPt.latitude) * preResult + sPt.latitude, (ePt.longitude - sPt.longitude) * preResult + sPt.longitude);
    &#125;
    /**
     * 去掉DriveLineOverlay上的线段和标记。
     */
    @Override
    public void removeFromMap() &#123;
        try &#123;
            super.removeFromMap();
            if (this.throughPointMarkerList != null
                    &amp;&amp; this.throughPointMarkerList.size() &gt; 0) &#123;
                for (int i = 0; i &lt; this.throughPointMarkerList.size(); i++) &#123;
                    this.throughPointMarkerList.get(i).remove();
                &#125;
                this.throughPointMarkerList.clear();
            &#125;
        &#125; catch (Throwable e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>搜索结果中进行图层绘制：</p>
<pre><code class="line-numbers language-Java">/**
    * 驾车规划路径结果
    *
    * @param driveRouteResult 结果
    * @param code            结果码
    */
@Override
public void onDriveRouteSearched(DriveRouteResult driveRouteResult, int code) &#123;
    aMap.clear();// 清理地图上的所有覆盖物
    if (code == AMapException.CODE_AMAP_SUCCESS) &#123;
        if (driveRouteResult != null &amp;&amp; driveRouteResult.getPaths() != null) &#123;
            if (driveRouteResult.getPaths().size() &gt; 0) &#123;
                final DrivePath drivePath = driveRouteResult.getPaths()
                        .get(0);
                if(drivePath == null) &#123;
                    return;
                &#125;
                DrivingRouteOverlay drivingRouteOverlay = new DrivingRouteOverlay(
                        this, aMap, drivePath,
                        driveRouteResult.getStartPos(),
                        driveRouteResult.getTargetPos(), null);
                drivingRouteOverlay.removeFromMap();
                drivingRouteOverlay.addToMap();
                drivingRouteOverlay.zoomToSpan();

                int dis = (int) drivePath.getDistance();
                int dur = (int) drivePath.getDuration();
                String des = MapUtil.getFriendlyTime(dur)+&quot;(&quot;+MapUtil.getFriendlyLength(dis)+&quot;)&quot;;
                Log.d(TAG, des);
            &#125; else if (driveRouteResult.getPaths() == null) &#123;
                showMsg(&quot;对不起，没有搜索到相关数据！&quot;);
            &#125;
        &#125; else &#123;
            showMsg(&quot;对不起，没有搜索到相关数据！&quot;);
        &#125;
    &#125; else &#123;
        showMsg(&quot;错误码；&quot; + code);
    &#125;
&#125;
</code></pre>
<h3 id="9-4-公交路线规划"><a href="#9-4-公交路线规划" class="headerlink" title="9.4 公交路线规划"></a>9.4 公交路线规划</h3><p>接口请求：</p>
<pre><code class="line-numbers language-Java">    case 3://公交
        //构建驾车路线搜索对象 第三个参数表示公交查询城市区号，第四个参数表示是否计算夜班车，0表示不计算,1表示计算
        RouteSearch.BusRouteQuery busQuery = new RouteSearch.BusRouteQuery(fromAndTo, RouteSearch.BusLeaseWalk, &quot;0755&quot;,0);
        //公交规划路径计算
        routeSearch.calculateBusRouteAsyn(busQuery);
        break;
</code></pre>
<p>图层工具添加：</p>
<pre><code class="line-numbers language-Java">import android.content.Context;

import com.amap.api.maps.AMap;
import com.amap.api.maps.model.LatLng;
import com.amap.api.maps.model.MarkerOptions;
import com.amap.api.maps.model.PolylineOptions;
import com.amap.api.services.busline.BusStationItem;
import com.amap.api.services.core.LatLonPoint;
import com.amap.api.services.route.BusPath;
import com.amap.api.services.route.BusStep;
import com.amap.api.services.route.Doorway;
import com.amap.api.services.route.RailwayStationItem;
import com.amap.api.services.route.RouteBusLineItem;
import com.amap.api.services.route.RouteBusWalkItem;
import com.amap.api.services.route.RouteRailwayItem;
import com.amap.api.services.route.TaxiItem;
import com.amap.api.services.route.WalkStep;
import com.llw.mapdemo.util.MapUtil;

import java.util.ArrayList;
import java.util.List;

/**
 * 公交路线图层类。在高德地图API里，如果需要显示公交路线，可以用此类来创建公交路线图层。如不满足需求，也可以自己创建自定义的公交路线图层。
 * @since V2.1.0
 */
public class BusRouteOverlay extends RouteOverlay &#123;

    private BusPath busPath;
    private LatLng latLng;

    /**
     * 通过此构造函数创建公交路线图层。
     * @param context 当前activity。
     * @param amap 地图对象。
     * @param path 公交路径规划的一个路段。详见搜索服务模块的路径查询包（com.amap.api.services.route）中的类&lt;strong&gt; &lt;a href=&quot;../../../../../../Search/com/amap/api/services/route/BusPath.html&quot; title=&quot;com.amap.api.services.route中的类&quot;&gt;BusPath&lt;/a&gt;&lt;/strong&gt;。
     * @param start 起点坐标。详见搜索服务模块的核心基础包（com.amap.api.services.core）中的类 &lt;strong&gt;&lt;a href=&quot;../../../../../../Search/com/amap/api/services/core/LatLonPoint.html&quot; title=&quot;com.amap.api.services.core中的类&quot;&gt;LatLonPoint&lt;/a&gt;&lt;/strong&gt;。
     * @param end 终点坐标。详见搜索服务模块的核心基础包（com.amap.api.services.core）中的类 &lt;strong&gt;&lt;a href=&quot;../../../../../../Search/com/amap/api/services/core/LatLonPoint.html&quot; title=&quot;com.amap.api.services.core中的类&quot;&gt;LatLonPoint&lt;/a&gt;&lt;/strong&gt;。
     * @since V2.1.0
     */
    public BusRouteOverlay(Context context, AMap amap, BusPath path,
                           LatLonPoint start, LatLonPoint end) &#123;
        super(context);
        this.busPath = path;
        startPoint = MapUtil.convertToLatLng(start);
        endPoint = MapUtil.convertToLatLng(end);
        mAMap = amap;
    &#125;

    /**
     * 添加公交路线到地图上。
     * @since V2.1.0
     */

    public void addToMap() &#123;
        /**
         * 绘制节点和线&lt;br&gt;
         * 细节情况较多&lt;br&gt;
         * 两个step之间，用step和step1区分&lt;br&gt;
         * 1.一个step内可能有步行和公交，然后有可能他们之间连接有断开&lt;br&gt;
         * 2.step的公交和step1的步行，有可能连接有断开&lt;br&gt;
         * 3.step和step1之间是公交换乘，且没有步行，需要把step的终点和step1的起点连起来&lt;br&gt;
         * 4.公交最后一站和终点间有步行，加入步行线路，还会有一些步行marker&lt;br&gt;
         * 5.公交最后一站和终点间无步行，之间连起来&lt;br&gt;
         */
        try &#123;
            List&lt;BusStep&gt; busSteps = busPath.getSteps();
            for (int i = 0; i &lt; busSteps.size(); i++) &#123;
                BusStep busStep = busSteps.get(i);
                if (i &lt; busSteps.size() - 1) &#123;
                    BusStep busStep1 = busSteps.get(i + 1);// 取得当前下一个BusStep对象
                    // 假如步行和公交之间连接有断开，就把步行最后一个经纬度点和公交第一个经纬度点连接起来，避免断线问题
                    if (busStep.getWalk() != null
                            &amp;&amp; busStep.getBusLine() != null) &#123;
                        checkWalkToBusline(busStep);
                    &#125;

                    // 假如公交和步行之间连接有断开，就把上一公交经纬度点和下一步行第一个经纬度点连接起来，避免断线问题
                    if (busStep.getBusLine() != null
                            &amp;&amp; busStep1.getWalk() != null 
                            &amp;&amp; busStep1.getWalk().getSteps().size() &gt; 0) &#123;
                        checkBusLineToNextWalk(busStep, busStep1);
                    &#125;
                    // 假如两个公交换乘中间没有步行，就把上一公交经纬度点和下一步公交第一个经纬度点连接起来，避免断线问题
                    if (busStep.getBusLine() != null
                            &amp;&amp; busStep1.getWalk() == null
                            &amp;&amp; busStep1.getBusLine() != null) &#123;
                        checkBusEndToNextBusStart(busStep, busStep1);
                    &#125;
                    // 和上面的很类似
                    if (busStep.getBusLine() != null
                            &amp;&amp; busStep1.getWalk() == null
                            &amp;&amp; busStep1.getBusLine() != null) &#123;
                        checkBusToNextBusNoWalk(busStep, busStep1);
                    &#125;
                    if (busStep.getBusLine() != null
                            &amp;&amp; busStep1.getRailway() != null ) &#123;
                        checkBusLineToNextRailway(busStep, busStep1);
                    &#125;
                    if (busStep1.getWalk() != null &amp;&amp;
                            busStep1.getWalk().getSteps().size() &gt; 0 &amp;&amp;
                            busStep.getRailway() != null) &#123;
                        checkRailwayToNextWalk(busStep, busStep1);
                    &#125;
                    
                    if ( busStep1.getRailway() != null &amp;&amp;
                            busStep.getRailway() != null) &#123;
                        checkRailwayToNextRailway(busStep, busStep1);
                    &#125;
                    
                    if (busStep.getRailway() != null &amp;&amp; 
                        busStep1.getTaxi() != null )&#123;
                        checkRailwayToNextTaxi(busStep, busStep1);
                    &#125;
                    

                &#125;

                if (busStep.getWalk() != null
                        &amp;&amp; busStep.getWalk().getSteps().size() &gt; 0) &#123;
                    addWalkSteps(busStep);
                &#125; else &#123;
                    if (busStep.getBusLine() == null &amp;&amp; busStep.getRailway() == null &amp;&amp; busStep.getTaxi() == null) &#123;
                        addWalkPolyline(latLng, endPoint);
                    &#125;
                &#125;
                if (busStep.getBusLine() != null) &#123;
                    RouteBusLineItem routeBusLineItem = busStep.getBusLine();
                    addBusLineSteps(routeBusLineItem);
                    addBusStationMarkers(routeBusLineItem);
                    if (i == busSteps.size() - 1) &#123;
                        addWalkPolyline(MapUtil.convertToLatLng(getLastBuslinePoint(busStep)), endPoint);
                    &#125;
                &#125;
                if (busStep.getRailway() != null) &#123;
                    addRailwayStep(busStep.getRailway());
                    addRailwayMarkers(busStep.getRailway());
                    if (i == busSteps.size() - 1) &#123;
                        addWalkPolyline(MapUtil.convertToLatLng(busStep.getRailway().getArrivalstop().getLocation()), endPoint);
                    &#125;
                &#125;
                if (busStep.getTaxi() != null) &#123;
                    addTaxiStep(busStep.getTaxi());
                    addTaxiMarkers(busStep.getTaxi());
                &#125;
            &#125;
            addStartAndEndMarker();

        &#125; catch (Throwable e) &#123;
            e.printStackTrace();
        &#125;
    &#125;



    private void checkRailwayToNextTaxi(BusStep busStep, BusStep busStep1) &#123;
        LatLonPoint railwayLastPoint = busStep.getRailway().getArrivalstop().getLocation();
        LatLonPoint taxiFirstPoint = busStep1.getTaxi().getOrigin();
        if (!railwayLastPoint.equals(taxiFirstPoint)) &#123;
            addWalkPolyLineByLatLonPoints(railwayLastPoint, taxiFirstPoint);
        &#125;
    &#125;

    private void checkRailwayToNextRailway(BusStep busStep, BusStep busStep1) &#123;
        LatLonPoint railwayLastPoint = busStep.getRailway().getArrivalstop().getLocation();
        LatLonPoint railwayFirstPoint = busStep1.getRailway().getDeparturestop().getLocation();
        if (!railwayLastPoint.equals(railwayFirstPoint)) &#123;
            addWalkPolyLineByLatLonPoints(railwayLastPoint, railwayFirstPoint);
        &#125;
        
    &#125;

    private void checkBusLineToNextRailway(BusStep busStep, BusStep busStep1) &#123;
        LatLonPoint busLastPoint = getLastBuslinePoint(busStep);
        LatLonPoint railwayFirstPoint = busStep1.getRailway().getDeparturestop().getLocation();
        if (!busLastPoint.equals(railwayFirstPoint)) &#123;
            addWalkPolyLineByLatLonPoints(busLastPoint, railwayFirstPoint);
        &#125;
        
    &#125;

    private void checkRailwayToNextWalk(BusStep busStep, BusStep busStep1) &#123;
        LatLonPoint railwayLastPoint = busStep.getRailway().getArrivalstop().getLocation();
        LatLonPoint walkFirstPoint = getFirstWalkPoint(busStep1);
        if (!railwayLastPoint.equals(walkFirstPoint)) &#123;
            addWalkPolyLineByLatLonPoints(railwayLastPoint, walkFirstPoint);
        &#125;
        
    &#125;

    private void addRailwayStep(RouteRailwayItem railway) &#123;
        List&lt;LatLng&gt; railwaylistpoint = new ArrayList&lt;LatLng&gt;();
        List&lt;RailwayStationItem&gt; railwayStationItems = new ArrayList&lt;RailwayStationItem&gt;();
        railwayStationItems.add(railway.getDeparturestop());
        railwayStationItems.addAll(railway.getViastops());
        railwayStationItems.add(railway.getArrivalstop());
        for (int i = 0; i &lt; railwayStationItems.size(); i++) &#123;
            railwaylistpoint.add(MapUtil.convertToLatLng(railwayStationItems.get(i).getLocation()));
        &#125;
        addRailwayPolyline(railwaylistpoint);
    &#125;
    
    private void addTaxiStep(TaxiItem taxi)&#123;
        addPolyLine(new PolylineOptions().width(getRouteWidth())
                .color(getBusColor())
                .add(MapUtil.convertToLatLng(taxi.getOrigin()))
                .add(MapUtil.convertToLatLng(taxi.getDestination())));
    &#125;

    /**
     * @param busStep
     */
    private void addWalkSteps(BusStep busStep) &#123;
        RouteBusWalkItem routeBusWalkItem = busStep.getWalk();
        List&lt;WalkStep&gt; walkSteps = routeBusWalkItem.getSteps();
        for (int j = 0; j &lt; walkSteps.size(); j++) &#123;
            WalkStep walkStep = walkSteps.get(j);
            if (j == 0) &#123;
                LatLng latLng = MapUtil.convertToLatLng(walkStep
                        .getPolyline().get(0));
                String road = walkStep.getRoad();// 道路名字
                String instruction = getWalkSnippet(walkSteps);// 步行导航信息
                addWalkStationMarkers(latLng, road, instruction);
            &#125;

            List&lt;LatLng&gt; listWalkPolyline = MapUtil
                    .convertArrList(walkStep.getPolyline());
            this.latLng = listWalkPolyline.get(listWalkPolyline.size() - 1);

            addWalkPolyline(listWalkPolyline);

            // 假如步行前一段的终点和下的起点有断开，断画直线连接起来，避免断线问题
            if (j &lt; walkSteps.size() - 1) &#123;
                LatLng lastLatLng = listWalkPolyline.get(listWalkPolyline
                        .size() - 1);
                LatLng firstlatLatLng = MapUtil
                        .convertToLatLng(walkSteps.get(j + 1).getPolyline()
                                .get(0));
                if (!(lastLatLng.equals(firstlatLatLng))) &#123;
                    addWalkPolyline(lastLatLng, firstlatLatLng);
                &#125;
            &#125;

        &#125;
    &#125;

    /**
     * 添加一系列的bus PolyLine
     *
     * @param routeBusLineItem
     */
    private void addBusLineSteps(RouteBusLineItem routeBusLineItem) &#123;
        addBusLineSteps(routeBusLineItem.getPolyline());
    &#125;

    private void addBusLineSteps(List&lt;LatLonPoint&gt; listPoints) &#123;
        if (listPoints.size() &lt; 1) &#123;
            return;
        &#125;
        addPolyLine(new PolylineOptions().width(getRouteWidth())
                .color(getBusColor())
                .addAll(MapUtil.convertArrList(listPoints)));
    &#125;

    /**
     * @param latLng
     *            marker
     * @param title
     * @param snippet
     */
    private void addWalkStationMarkers(LatLng latLng, String title,
                                       String snippet) &#123;
        addStationMarker(new MarkerOptions().position(latLng).title(title)
                .snippet(snippet).anchor(0.5f, 0.5f).visible(nodeIconVisible)
                .icon(getWalkBitmapDescriptor()));
    &#125;

    /**
     * @param routeBusLineItem
     */
    private void addBusStationMarkers(RouteBusLineItem routeBusLineItem) &#123;
        BusStationItem startBusStation = routeBusLineItem
                .getDepartureBusStation();
        LatLng position = MapUtil.convertToLatLng(startBusStation
                .getLatLonPoint());
        String title = routeBusLineItem.getBusLineName();
        String snippet = getBusSnippet(routeBusLineItem);

        addStationMarker(new MarkerOptions().position(position).title(title)
                .snippet(snippet).anchor(0.5f, 0.5f).visible(nodeIconVisible)
                .icon(getBusBitmapDescriptor()));
    &#125;
    
    private void addTaxiMarkers(TaxiItem taxiItem) &#123;
        
        LatLng position = MapUtil.convertToLatLng(taxiItem
                .getOrigin());
        String title = taxiItem.getmSname()+&quot;打车&quot;;
        String snippet = &quot;到终点&quot;;

        addStationMarker(new MarkerOptions().position(position).title(title)
                .snippet(snippet).anchor(0.5f, 0.5f).visible(nodeIconVisible)
                .icon(getDriveBitmapDescriptor()));
    &#125;

    private void addRailwayMarkers(RouteRailwayItem railway) &#123;
        LatLng Departureposition = MapUtil.convertToLatLng(railway
                .getDeparturestop().getLocation());
        String Departuretitle = railway.getDeparturestop().getName()+&quot;上车&quot;;
        String Departuresnippet = railway.getName();

        addStationMarker(new MarkerOptions().position(Departureposition).title(Departuretitle)
                .snippet(Departuresnippet).anchor(0.5f, 0.5f).visible(nodeIconVisible)
                .icon(getBusBitmapDescriptor()));
        
        
        LatLng Arrivalposition = MapUtil.convertToLatLng(railway
                .getArrivalstop().getLocation());
        String Arrivaltitle = railway.getArrivalstop().getName()+&quot;下车&quot;;
        String Arrivalsnippet = railway.getName();

        addStationMarker(new MarkerOptions().position(Arrivalposition).title(Arrivaltitle)
                .snippet(Arrivalsnippet).anchor(0.5f, 0.5f).visible(nodeIconVisible)
                .icon(getBusBitmapDescriptor()));
    &#125;
    /**
     * 如果换乘没有步行 检查bus最后一点和下一个step的bus起点是否一致
     *
     * @param busStep
     * @param busStep1
     */
    private void checkBusToNextBusNoWalk(BusStep busStep, BusStep busStep1) &#123;
        LatLng endbusLatLng = MapUtil
                .convertToLatLng(getLastBuslinePoint(busStep));
        LatLng startbusLatLng = MapUtil
                .convertToLatLng(getFirstBuslinePoint(busStep1));
        if (startbusLatLng.latitude - endbusLatLng.latitude &gt; 0.0001
                || startbusLatLng.longitude - endbusLatLng.longitude &gt; 0.0001) &#123;
            drawLineArrow(endbusLatLng, startbusLatLng);// 断线用带箭头的直线连?
        &#125;
    &#125;

    /**
     *
     * checkBusToNextBusNoWalk 和这个类似
     *
     * @param busStep
     * @param busStep1
     */
    private void checkBusEndToNextBusStart(BusStep busStep, BusStep busStep1) &#123;
        LatLonPoint busLastPoint = getLastBuslinePoint(busStep);
        LatLng endbusLatLng = MapUtil.convertToLatLng(busLastPoint);
        LatLonPoint busFirstPoint = getFirstBuslinePoint(busStep1);
        LatLng startbusLatLng = MapUtil.convertToLatLng(busFirstPoint);
        if (!endbusLatLng.equals(startbusLatLng)) &#123;
            drawLineArrow(endbusLatLng, startbusLatLng);//
        &#125;
    &#125;

    /**
     * 检查bus最后一步和下一各step的步行起点是否一致
     *
     * @param busStep
     * @param busStep1
     */
    private void checkBusLineToNextWalk(BusStep busStep, BusStep busStep1) &#123;
        LatLonPoint busLastPoint = getLastBuslinePoint(busStep);
        LatLonPoint walkFirstPoint = getFirstWalkPoint(busStep1);
        if (!busLastPoint.equals(walkFirstPoint)) &#123;
            addWalkPolyLineByLatLonPoints(busLastPoint, walkFirstPoint);
        &#125;
    &#125;

    /**
     * 检查 步行最后一点 和 bus的起点 是否一致
     *
     * @param busStep
     */
    private void checkWalkToBusline(BusStep busStep) &#123;
        LatLonPoint walkLastPoint = getLastWalkPoint(busStep);
        LatLonPoint buslineFirstPoint = getFirstBuslinePoint(busStep);

        if (!walkLastPoint.equals(buslineFirstPoint)) &#123;
            addWalkPolyLineByLatLonPoints(walkLastPoint, buslineFirstPoint);
        &#125;
    &#125;

    /**
     * @param busStep1
     * @return
     */
    private LatLonPoint getFirstWalkPoint(BusStep busStep1) &#123;
        return busStep1.getWalk().getSteps().get(0).getPolyline().get(0);
    &#125;

    /**
     *
     */
    private void addWalkPolyLineByLatLonPoints(LatLonPoint pointFrom,
                                               LatLonPoint pointTo) &#123;
        LatLng latLngFrom = MapUtil.convertToLatLng(pointFrom);
        LatLng latLngTo = MapUtil.convertToLatLng(pointTo);

        addWalkPolyline(latLngFrom, latLngTo);
    &#125;

    /**
     * @param latLngFrom
     * @param latLngTo
     * @return
     */
    private void addWalkPolyline(LatLng latLngFrom, LatLng latLngTo) &#123;
        addPolyLine(new PolylineOptions().add(latLngFrom, latLngTo)
                .width(getRouteWidth()).color(getWalkColor()).setDottedLine(true));
    &#125;

    /**
     * @param listWalkPolyline
     */
    private void addWalkPolyline(List&lt;LatLng&gt; listWalkPolyline) &#123;

        addPolyLine(new PolylineOptions().addAll(listWalkPolyline)
                .color(getWalkColor()).width(getRouteWidth()).setDottedLine(true));
    &#125;

    private void addRailwayPolyline(List&lt;LatLng&gt; listPolyline) &#123;

        addPolyLine(new PolylineOptions().addAll(listPolyline)
                .color(getDriveColor()).width(getRouteWidth()));
    &#125;
    
    
    private String getWalkSnippet(List&lt;WalkStep&gt; walkSteps) &#123;
        float disNum = 0;
        for (WalkStep step : walkSteps) &#123;
            disNum += step.getDistance();
        &#125;
        return &quot;\u6B65\u884C&quot; + disNum + &quot;\u7C73&quot;;
    &#125;

    public void drawLineArrow(LatLng latLngFrom, LatLng latLngTo) &#123;

        addPolyLine(new PolylineOptions().add(latLngFrom, latLngTo).width(3)
                .color(getBusColor()).width(getRouteWidth()));// 绘制直线
    &#125;

    private String getBusSnippet(RouteBusLineItem routeBusLineItem) &#123;
        return &quot;(&quot;
                + routeBusLineItem.getDepartureBusStation().getBusStationName()
                + &quot;--&gt;&quot;
                + routeBusLineItem.getArrivalBusStation().getBusStationName()
                + &quot;) \u7ECF\u8FC7&quot; + (routeBusLineItem.getPassStationNum() + 1)
                + &quot;\u7AD9&quot;;
    &#125;

    /**
     * @param busStep
     * @return
     */
    private LatLonPoint getLastWalkPoint(BusStep busStep) &#123;

        List&lt;WalkStep&gt; walkSteps = busStep.getWalk().getSteps();
        WalkStep walkStep = walkSteps.get(walkSteps.size() - 1);
        List&lt;LatLonPoint&gt; lonPoints = walkStep.getPolyline();
        return lonPoints.get(lonPoints.size() - 1);
    &#125;

    private LatLonPoint getExitPoint(BusStep busStep) &#123;
        Doorway doorway = busStep.getExit();
        if (doorway == null) &#123;
            return null;
        &#125;
        return doorway.getLatLonPoint();
    &#125;

    private LatLonPoint getLastBuslinePoint(BusStep busStep) &#123;
        List&lt;LatLonPoint&gt; lonPoints = busStep.getBusLine().getPolyline();

        return lonPoints.get(lonPoints.size() - 1);
    &#125;

    private LatLonPoint getEntrancePoint(BusStep busStep) &#123;
        Doorway doorway = busStep.getEntrance();
        if (doorway == null) &#123;
            return null;
        &#125;
        return doorway.getLatLonPoint();
    &#125;

    private LatLonPoint getFirstBuslinePoint(BusStep busStep) &#123;
        return busStep.getBusLine().getPolyline().get(0);
    &#125;
&#125;
</code></pre>
<p>然后是结果使用图层绘制：</p>
<pre><code class="line-numbers language-Java">    /**
    * 公交规划路径结果
    *
    * @param busRouteResult 结果
    * @param code           结果码
    */
@Override
public void onBusRouteSearched(BusRouteResult busRouteResult, int code) &#123;
    aMap.clear();// 清理地图上的所有覆盖物
    if (code == AMapException.CODE_AMAP_SUCCESS) &#123;
        if (busRouteResult != null &amp;&amp; busRouteResult.getPaths() != null) &#123;
            if (busRouteResult.getPaths().size() &gt; 0) &#123;
                final BusPath busPath = busRouteResult.getPaths().get(0);
                if (busPath == null) &#123;
                    return;
                &#125;
                BusRouteOverlay busRouteOverlay = new BusRouteOverlay(
                        this, aMap, busPath,
                        busRouteResult.getStartPos(),
                        busRouteResult.getTargetPos());
                busRouteOverlay.removeFromMap();
                busRouteOverlay.addToMap();
                busRouteOverlay.zoomToSpan();

                int dis = (int) busPath.getDistance();
                int dur = (int) busPath.getDuration();
                String des = MapUtil.getFriendlyTime(dur) + &quot;(&quot; + MapUtil.getFriendlyLength(dis) + &quot;)&quot;;
                Log.d(TAG, des);
            &#125; else if (busRouteResult.getPaths() == null) &#123;
                showMsg(&quot;对不起，没有搜索到相关数据！&quot;);
            &#125;
        &#125; else &#123;
            showMsg(&quot;对不起，没有搜索到相关数据！&quot;);
        &#125;
    &#125; else &#123;
        showMsg(&quot;错误码；&quot; + code);
    &#125;
&#125;
</code></pre>
<h2 id="10-总结"><a href="#10-总结" class="headerlink" title="10 总结"></a>10 总结</h2><ul>
<li>首先是配置依赖，可以远程或者本地引用，前提是配置key，注意配置SHA1安全码。</li>
<li>然后是地图使用，主要是在布局中声明Map，这个Map本质上是一个ViewGroup。</li>
<li>然后是设置地图的一些配置，比如marker，点击事件，拖拽事件等。</li>
<li>然后是定位的使用，逆地址编码和地址编码，注意动态申请权限。</li>
<li>然后是搜索结果的使用，这个调接口，配合地址编码，也是很容易。</li>
<li>然后是路径规划了，这个主要是调接口， RouteSearch很关键，然后是各种图层绘制，总体上还是比较简单的。</li>
</ul>

            </div>
            <hr />

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">写作不易，客官能否打赏一杯奶茶？</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《Android 集成 高德地图API》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2023/02/10/Android-%E9%9B%86%E6%88%90-%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BEAPI/" property="cc:attributionName"
               rel="cc:attributionURL">
                Jason
            </a> 采用
            <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    
    <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: 'fe0ccf043e8b41eb62ea',
        clientSecret: '9ca1dd3be79bdf6123d4aa8ca81753570fe870e1',
        repo: 'jasontojan.github.io',
        owner: 'jasontojan',
        admin: "jasontojan",
        id: '2023/02/10/Android-集成-高德地图API/',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    
    <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script> -->

<script>
    new Valine({
        el: '#vcomments',
        appId: '查教程获取',
        appKey: '查教程获取',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'false' === 'true',
        avatar: 'wavatar',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '如果你没有GitHub账号，还可以在这里评论啦！'
    });
</script>

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/02/11/Android-wear-os-%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="Android wear os 使用入门">
                        
                        <span class="card-title">Android wear os 使用入门</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            1 Wear OS 开发原则1.1 针对关键任务进行设计重点关注目标用户的一项或两项需求，而不是完整应用体验。不要迁移整个移动代码库，也不要将 Wear OS 界面放在顶层。
相反，您应寻找适合腕部佩戴的关键任务，并简化 Wear OS 的
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2023-02-11
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Android/" class="post-category" target="_blank">
                                    Android
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Android-wear/" target="_blank">
                        <span class="chip bg-color">Android wear</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/02/10/Android-%E9%9B%86%E6%88%90-ChatGPT/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/16.jpg" class="responsive-img" alt="Android 集成 ChatGPT">
                        
                        <span class="card-title">Android 集成 ChatGPT</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            1 效果

2 技术栈Timber: 日志打印工具（Github地址）Room：Jetpack包含的数据库（最全面的Room数据库指南）Splash Screens: 启动屏幕Android12支持（Android 12 SplashScr
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2023-02-10
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Android/" class="post-category" target="_blank">
                                    Android
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Android-Kotlin-ChatGPT/" target="_blank">
                        <span class="chip bg-color">Android Kotlin ChatGPT</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: JasonToJan's Blog<br />'
            + '作者: Jason<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
    });
</script>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; 2023-2023 JasonJan. 版权所有

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">274.7k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
            <br>
            
            <span id="busuanzi_container_site_pv" style='display:none'>
                <i class="fa fa-heart-o"></i>
                本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
            <span id="busuanzi_container_site_uv" style='display:none'>
                人次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
            </span>
            
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/JasonToJan" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:jason1211241203@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="https://zhihu.com/people/JasonJan" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-inverse">知</i>
    </a>



    <a href="http://wpa.qq.com/msgrd?v=3&uin=1211241203&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>



    <a href="https://weibo.com/JasonJan" class="tooltipped" target="_blank" data-tooltip="关注我的微博" data-position="top" data-delay="50">
        <i class="fa fa-weibo"></i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 80000;
        var uvcountOffset = 20000;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2017, 09, 11, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>

<link rel="stylesheet" href="/css/prism.css">
<script src="/js/prism.js" async></script>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=查教程获取"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '查教程获取');
</script>



    
    <script src="/libs/others/clicklove.js"></script>
    

    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    <!-- 雪花特效 -->
    

</body>

</html>