{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/matery/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/matery/source/js/matery.js","path":"js/matery.js","modified":0,"renderable":1},{"_id":"themes/matery/source/js/prism.js","path":"js/prism.js","modified":0,"renderable":1},{"_id":"themes/matery/source/css/gitment.css","path":"css/gitment.css","modified":0,"renderable":1},{"_id":"themes/matery/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/matery/source/css/matery.css","path":"css/matery.css","modified":0,"renderable":1},{"_id":"themes/matery/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":0,"renderable":1},{"_id":"themes/matery/source/css/my.css","path":"css/my.css","modified":0,"renderable":1},{"_id":"themes/matery/source/css/prism.css","path":"css/prism.css","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/contact.jpg","path":"medias/contact.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/logo.png","path":"medias/logo.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/gzh.jpg","path":"medias/gzh.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/clipboard.min.js","path":"libs/codeBlock/clipboard.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeLang.js","path":"libs/codeBlock/codeLang.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeBlockFuction.js","path":"libs/codeBlock/codeBlockFuction.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeCopy.js","path":"libs/codeBlock/codeCopy.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeShrink.js","path":"libs/codeBlock/codeShrink.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","path":"libs/jquery/jquery-2.2.0.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/explosion.min.js","path":"libs/others/explosion.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/fireworks.js","path":"libs/others/fireworks.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/snow.js","path":"libs/others/snow.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/text.js","path":"libs/others/text.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/0xbird.png","path":"medias/avatars/0xbird.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/ajin.jpg","path":"medias/avatars/ajin.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/antnlp.ico","path":"medias/avatars/antnlp.ico","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/avatar.jpg","path":"medias/avatars/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/babyq.png","path":"medias/avatars/babyq.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/bytedtrans.png","path":"medias/avatars/bytedtrans.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/cww97.jpg","path":"medias/avatars/cww97.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/duyupei.jpg","path":"medias/avatars/duyupei.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/feibar.jpg","path":"medias/avatars/feibar.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/feibar.png","path":"medias/avatars/feibar.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/fun4go.png","path":"medias/avatars/fun4go.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/gsy.jpg","path":"medias/avatars/gsy.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/hael.jpg","path":"medias/avatars/hael.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/huaji.jpg","path":"medias/avatars/huaji.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/hzwer.jpg","path":"medias/avatars/hzwer.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/ids2.jpg","path":"medias/avatars/ids2.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/jiejie.jpg","path":"medias/avatars/jiejie.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/jingjing.jpg","path":"medias/avatars/jingjing.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/kewlgrl.jpg","path":"medias/avatars/kewlgrl.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/ldy.jpg","path":"medias/avatars/ldy.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/lijiaqian.png","path":"medias/avatars/lijiaqian.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/liyangzone.jpg","path":"medias/avatars/liyangzone.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/liyucheng.jpg","path":"medias/avatars/liyucheng.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/jitao.jpg","path":"medias/avatars/jitao.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/lyn-draw.jpg","path":"medias/avatars/lyn-draw.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mashiro.jpg","path":"medias/avatars/mashiro.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/masterx.jpg","path":"medias/avatars/masterx.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/michael.jpg","path":"medias/avatars/michael.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/lzh.png","path":"medias/avatars/lzh.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/milyyy.jpg","path":"medias/avatars/milyyy.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mouse.jpg","path":"medias/avatars/mouse.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mpy634.png","path":"medias/avatars/mpy634.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/myzhihu.png","path":"medias/avatars/myzhihu.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/qiandongwei.jpg","path":"medias/avatars/qiandongwei.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mizunashi.png","path":"medias/avatars/mizunashi.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/qianqian.png","path":"medias/avatars/qianqian.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/qiqiang.jpg","path":"medias/avatars/qiqiang.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/spacesac.png","path":"medias/avatars/spacesac.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/sunchangzhi.jpg","path":"medias/avatars/sunchangzhi.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/taotao.jpg","path":"medias/avatars/taotao.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/taowei.jpg","path":"medias/avatars/taowei.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/tawn.jpg","path":"medias/avatars/tawn.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/xiejiadong.jpg","path":"medias/avatars/xiejiadong.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/xuzhongyou.jpg","path":"medias/avatars/xuzhongyou.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/yezijie.png","path":"medias/avatars/yezijie.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/zhangting.jpg","path":"medias/avatars/zhangting.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/zhangyi.jpg","path":"medias/avatars/zhangyi.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/zhaokangzhe.jpg","path":"medias/avatars/zhaokangzhe.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/zzw.jpg","path":"medias/avatars/zzw.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/24.jpg","path":"medias/featureimages/24.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/25.jpg","path":"medias/featureimages/25.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/26.jpg","path":"medias/featureimages/26.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/19.jpg","path":"medias/featureimages/19.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/27.jpg","path":"medias/featureimages/27.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/28.jpg","path":"medias/featureimages/28.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/files/cv-zh.pdf","path":"medias/files/cv-zh.pdf","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/reward/alipay.png","path":"medias/reward/alipay.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/files/cv-en.pdf","path":"medias/files/cv-en.pdf","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/reward/wechat.png","path":"medias/reward/wechat.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","path":"libs/awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","path":"libs/awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","path":"libs/awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","path":"libs/awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","path":"libs/awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","path":"libs/awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","path":"libs/awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/yiluxiangbei.jpg","path":"medias/music/avatars/yiluxiangbei.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/yequ.jpg","path":"medias/music/avatars/yequ.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/daoshu.jpg","path":"medias/music/avatars/daoshu.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/tiantangdemogui.jpg","path":"medias/music/avatars/tiantangdemogui.jpg","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0}],"Cache":[{"_id":"source/404.md","hash":"d97f69ff63501de89cfd341c68e4d6ed5c8a5b3a","modified":1675231576183},{"_id":"source/CNAME","hash":"5e8a7aad69a8e5e79479ea54733cb096611eec47","modified":1675231576183},{"_id":"source/.DS_Store","hash":"c87533c3cd2e390057cef0343bdbede7010ac113","modified":1675232121431},{"_id":"source/_data/musics.json","hash":"32bc061f34721b4ff55f880de1d0ec5787acd2f9","modified":1675231576183},{"_id":"source/about/index.md","hash":"244c65942bf4533fefd227f28d7044e82ccb7091","modified":1675232014882},{"_id":"source/_posts/Android-google-samples-nowinandroid-app模块流程分析.md","hash":"32c010b182b4d4d8367e2d2be569d99a40302496","modified":1675235540421},{"_id":"source/archives/index.md","hash":"4ac0f3011941b36c1edb8fc2fdb4738ea5da3fa0","modified":1675231576249},{"_id":"source/_posts/Android-gradle相关-KTS脚本-项目配置改造.md","hash":"aefaf7855c49ebea6bedd9e2f553debc937a2b01","modified":1675235541384},{"_id":"source/_data/friends.json","hash":"e4c6253b684af89a656c9ce5440ed5c405d6421d","modified":1675231576183},{"_id":"source/_posts/iOS-swift-数据库realm实践.md","hash":"90d6f365c0f0546a22e61c6dc3998a025839bf2e","modified":1675235545200},{"_id":"source/_posts/iOS-swift-实现简易地图功能.md","hash":"a889276cd33e25df2c876a6269be5b1a210aac45","modified":1675235544284},{"_id":"source/_posts/Flutter-学习导航.md","hash":"affc9ef62d42fc21a16aebedff79004a428e410b","modified":1675232014855},{"_id":"source/_posts/.DS_Store","hash":"ed03ec0096826fbf4b7960d018e8a42c4dedb566","modified":1675232084263},{"_id":"source/_posts/5w2h-godweiyang.md","hash":"39f3fdf4266cacc879de004c99fb06a0b3ed6966","modified":1675231576183},{"_id":"source/_posts/iOS-swift-混编Flutter.md","hash":"0ab1b7b00aad9a3a3416549c68b698047463f58a","modified":1675235542330},{"_id":"source/_posts/iOS-swift-如何实现扫码功能.md","hash":"86e86c10c40a6d6d94df84991d53b0af280f332c","modified":1675235543365},{"_id":"source/_posts/iOS-swift-自定义View之四级地址.md","hash":"b84cad50954f62a4e2db17212605b0a2fc703978","modified":1675235546935},{"_id":"source/_posts/玩Android-Compose版本-项目分析.md","hash":"b5dd8006cadb89d2e67f6d8fbb3b61221ef9b85d","modified":1675235539274},{"_id":"source/_posts/iOS-swift-自定义View之时间选择器.md","hash":"eeb0134cdbe13a321ef3fdf65b5166f0d45893f9","modified":1675235546066},{"_id":"source/_posts/iOS-swift-自定义View之步进器.md","hash":"a192b25f128aeb263fa41ceeb81b5958922560a0","modified":1675235550038},{"_id":"source/_posts/Android-学习导航.md","hash":"63c2df7ff7115942e91b77a29181c06725447ed7","modified":1675232014852},{"_id":"source/contact/index.md","hash":"6ebabb170c2cc0447ca6b153aea573ea436c595a","modified":1675231576249},{"_id":"source/_posts/iOS-swift-网络请求二次封装moya.md","hash":"46af2af92e67d79a53596d54063c3fa3b6b766b6","modified":1675233298913},{"_id":"source/categories/index.md","hash":"3e265a72178e02c03be39ec4d5751ad9d098dea2","modified":1675231576249},{"_id":"source/_posts/iOS-学习导航.md","hash":"cbec323c2b0c23dfab51b84fc1337366e0211735","modified":1675232849750},{"_id":"source/friends/index.md","hash":"405a0f5a74a01af8c4447f5bf325492bd7606cb8","modified":1675231576250},{"_id":"source/_posts/Android-学习导航/bianchengjingxuan.jpeg","hash":"f6fb1d9014d3745473e188380216cef5bae7da92","modified":1675232014852},{"_id":"source/_posts/Android-学习导航/guolin.jpeg","hash":"637e479009efdec579986fbe8eb5eacc9e46932e","modified":1675232014853},{"_id":"source/_posts/Android-学习导航/carson.jpeg","hash":"40635ad0a930abcc74b1e2eec760cb44cfc477f8","modified":1675232014853},{"_id":"source/tags/index.md","hash":"bd116296d4685772c75cec439845019e95a4f836","modified":1675231576250},{"_id":"source/_posts/Android-学习导航/jishuquan.jpeg","hash":"7597cde9db6040f80064ab5c397ad40394c2c068","modified":1675232014854},{"_id":"source/_posts/Android-学习导航/jishuzhuanjia.jpeg","hash":"a9036689bffb0d31e44ca4c691a79b30893b97ac","modified":1675232014854},{"_id":"source/_posts/Android-学习导航/qunyingzhuan.jpeg","hash":"203453e7a2f5ec4b3ab6b9d643a1a8882ec528be","modified":1675232014855},{"_id":"source/_posts/Android-学习导航/hongyang.jpeg","hash":"6d414b2f8a29459ed52f4a7d1714441074d85f42","modified":1675232014853},{"_id":"source/_posts/Android-学习导航/jsonchao.jpeg","hash":"e476402b268490d72534f55cfa9d23b9be43f566","modified":1675232014854},{"_id":"source/_posts/Flutter-学习导航/FlutterDevs.jpeg","hash":"f99339d77b2943ce258ccc86d1347d666b72920c","modified":1675232014855},{"_id":"source/_posts/Flutter-学习导航/blog_520lee_com.jpeg","hash":"55ca5b424bbe29efce36afdd29b702250d988875","modified":1675232014856},{"_id":"source/_posts/Flutter-学习导航/Study_Knowledge.jpeg","hash":"ed1d63d25a4136faca1b8a6d6c3da1ef3413720b","modified":1675232014856},{"_id":"source/_posts/iOS-学习导航/iOSkaifa.jpeg","hash":"a5478eb61474efe19ac6abc28a427d7096c749e8","modified":1675232014882},{"_id":"source/_posts/iOS-学习导航/mobile_tech_share.jpeg","hash":"90b55e26b096ae716f8074096ac48b2b1290c852","modified":1675232014882},{"_id":"source/_posts/iOS-swift-自定义View之步进器/stepper0.png","hash":"ebc88bb13e0f6168189228b613a0dd41f73882d2","modified":1675232014881},{"_id":"source/_posts/玩Android-Compose版本-项目分析/home_item.jpeg","hash":"ee18c76cc19ffc9653309fb22c5db4be8abe6694","modified":1675231576225},{"_id":"source/_posts/iOS-swift-自定义View之步进器/stepper5.png","hash":"4f77bd25aaec9a33753d84c2205feb7642e40284","modified":1675232014881},{"_id":"source/_posts/iOS-swift-自定义View之时间选择器/预约日期.png","hash":"dedd941735c71b5f1bd3a1471e180c409b47ffe7","modified":1675232014880},{"_id":"source/_posts/iOS-swift-自定义View之时间选择器/预约时间.png","hash":"062fd52e9f09f9a482ac57796c4bf8b347d7da86","modified":1675232014881},{"_id":"source/_posts/iOS-swift-混编Flutter/fluttererror1.png","hash":"144e586ff60c31f455e3edd250f8e3fc4950b5d0","modified":1675232849748},{"_id":"themes/matery/.gitignore","hash":"eaa3d84cb77d92a21b111fd1e37f53edc1ff9de0","modified":1675231576250},{"_id":"themes/matery/LICENSE","hash":"b314c7ebb7d599944981908b7f3ed33a30e78f3a","modified":1675231576250},{"_id":"themes/matery/README.md","hash":"7ef16198a2c5ff580f006582286354caf160c7fe","modified":1675231576250},{"_id":"themes/matery/README_CN.md","hash":"a94324950e0299bcfcbc106cf2ca65c93e1fe843","modified":1675231576250},{"_id":"themes/matery/languages/zh-CN.yml","hash":"d92db4b986bb6f0d228e9a8249383103bf56342d","modified":1675231576250},{"_id":"themes/matery/layout/404.ejs","hash":"f08a0f507b36f3652520a41381f71167488405c7","modified":1675231576250},{"_id":"themes/matery/_config.yml","hash":"fbf93c989eba69ae89dd67a155cb589611345f71","modified":1675232014883},{"_id":"themes/matery/layout/about.ejs","hash":"e87752e59f021b5139b1155a264da11ab469a9aa","modified":1675231576253},{"_id":"themes/matery/layout/archive.ejs","hash":"1b5023571894404d75caffa28128fc9c49f9095d","modified":1675231576253},{"_id":"themes/matery/languages/default.yml","hash":"527c795b8c41fe62bf35603ffebfa6d4a7929a2c","modified":1675231576250},{"_id":"themes/matery/layout/contact.ejs","hash":"1513c5a40b7cc0b6e5854cf8c3253958bcb486cb","modified":1675231576253},{"_id":"themes/matery/layout/categories.ejs","hash":"c431e772d0f7700592228bbd9502793bdc28a893","modified":1675231576253},{"_id":"themes/matery/layout/category.ejs","hash":"2d421e10c3b8fd2c4f725e5eaa967c4a1429c707","modified":1675231576253},{"_id":"themes/matery/layout/post.ejs","hash":"f1a35f32e5901e167ae9a750e7cb3635549cea2e","modified":1675231576253},{"_id":"themes/matery/layout/index.ejs","hash":"7fc5a6c4f0229c0be43b7d1315524c468346fbb8","modified":1675231576253},{"_id":"themes/matery/layout/tags.ejs","hash":"851c0ee599e91e7b1d657673859e8b6ff79cf50b","modified":1675231576253},{"_id":"themes/matery/layout/friends.ejs","hash":"895e40a864796680fbef581e4b09f252fbdd963a","modified":1675231576253},{"_id":"themes/matery/layout/tag.ejs","hash":"5cdf3a1d72f54285ee9cb826fd0e4a0449093215","modified":1675231576253},{"_id":"themes/matery/layout/layout.ejs","hash":"2ba4110dc596424b1220a259c8e594da774e7f59","modified":1675231576253},{"_id":"themes/matery/layout/_widget/category-cloud.ejs","hash":"b2b22d4fc4e46b051f67216c391f629f4ff552b5","modified":1675231576252},{"_id":"themes/matery/layout/_widget/my-gallery.ejs","hash":"9ea672db65f1e5b8fad1ffafb1614f25adc97e63","modified":1675231576252},{"_id":"themes/matery/layout/_widget/music.ejs","hash":"fc50cb4bbc1f4d0e4c9f5941f1c3c74bea742db7","modified":1675231576252},{"_id":"themes/matery/source/favicon.png","hash":"0f4145b9a712f9662e4fae1b0086ce74cf1f9fc4","modified":1675231576254},{"_id":"themes/matery/layout/_widget/category-radar.ejs","hash":"5284712d84bbaa4f0d88026ac3ec5a8c13e00056","modified":1675231576252},{"_id":"themes/matery/layout/_widget/my-skills.ejs","hash":"c6f713316ce75ad08ac5d1587bd8ce42e894e9ae","modified":1675231576252},{"_id":"themes/matery/layout/_widget/my-projects.ejs","hash":"785cb588a31215876f6737213054ba0e8552fff0","modified":1675231576252},{"_id":"themes/matery/layout/_widget/dream.ejs","hash":"6ae58a57b83a5999d0b6a737ec868f084d208f89","modified":1675231576252},{"_id":"themes/matery/layout/_widget/recommend.ejs","hash":"d439d86818de179d64965d4f7f5fa56147fd9221","modified":1675231576253},{"_id":"themes/matery/layout/_widget/post-calendar.ejs","hash":"4608af6151f0e32f668c89f09343748340021478","modified":1675231576253},{"_id":"themes/matery/layout/_widget/tag-wordcloud.ejs","hash":"bf604fe9c435f0fb9a559cac9c35772579b590e8","modified":1675231576253},{"_id":"themes/matery/layout/_widget/post-charts.ejs","hash":"0aaf0a111b9aa07ff37f6286eeac5506283f47f8","modified":1675231576253},{"_id":"themes/matery/layout/_widget/video.ejs","hash":"05f5e2acace5730cdf7bed650375ad88f6b5d1b7","modified":1675231576253},{"_id":"themes/matery/layout/_widget/tag-cloud.ejs","hash":"6310903eb0e434d6f9a59ca669aab7fae38d4797","modified":1675231576253},{"_id":"themes/matery/layout/_partial/back-top.ejs","hash":"cb99dc352397ec5d0765794d7b8884972e61973b","modified":1675231576251},{"_id":"themes/matery/layout/_partial/github-link.ejs","hash":"fd4034bca2eb3987dcf113e6477260bee97eb1e7","modified":1675231576251},{"_id":"themes/matery/layout/_partial/bg-cover-content.ejs","hash":"ab610754bf6aea844b5ae0802ed37c73b5f1dc9f","modified":1675231576251},{"_id":"themes/matery/layout/_partial/gitment.ejs","hash":"d8c40dbc8106b5bc53ceb727ad968c1d8f234261","modified":1675231576251},{"_id":"themes/matery/layout/_partial/bg-cover.ejs","hash":"d5a7b9bb96e04c0a3485dd873748f19c50a6a04f","modified":1675231576251},{"_id":"themes/matery/layout/_partial/gitalk.ejs","hash":"a3a140e6aeeb6f289e4b821a577ef548267f3de1","modified":1675231576251},{"_id":"themes/matery/layout/_partial/header.ejs","hash":"821e1af65990521c9e0288178d8e5b18c73a9cab","modified":1675231576251},{"_id":"themes/matery/layout/_partial/disqus.ejs","hash":"42dda8e67f7f09d148347887e52f18aea546df26","modified":1675231576251},{"_id":"themes/matery/layout/_partial/index-cover.ejs","hash":"d4042e5521ceb5f3255cd4455ac7ccd227fee6df","modified":1675231576251},{"_id":"themes/matery/layout/_partial/mobile-nav.ejs","hash":"e761f0104fbf431671bbe6bebc91ca82f737f4d2","modified":1675231576251},{"_id":"themes/matery/layout/_partial/google-analytics.ejs","hash":"890c8f04c1f4905dfceb3ea9fd6efdd040d79c01","modified":1675231576251},{"_id":"themes/matery/layout/_partial/footer.ejs","hash":"bf685ae08a225b3dbf7acdfd0291a7c271ced985","modified":1675234399481},{"_id":"themes/matery/layout/_partial/head.ejs","hash":"fb572df037b5a6eb563912caa1f1967ca835a70a","modified":1675231576251},{"_id":"themes/matery/layout/_partial/navigation.ejs","hash":"3a82fcb6f31d69971cb564985842c14ac02cdca0","modified":1675231576251},{"_id":"themes/matery/layout/_partial/livere.ejs","hash":"42728561c09589f79b698eb059ab4def53ed3642","modified":1675231576251},{"_id":"themes/matery/layout/_partial/post-detail.ejs","hash":"3f208f33e4e12becdb8323e6e64e20ad60c3fb2a","modified":1675231576252},{"_id":"themes/matery/layout/_partial/paging.ejs","hash":"dfdeea9c59d157acb851d4bf44bf95f81787523c","modified":1675231576251},{"_id":"themes/matery/layout/_partial/prev-next.ejs","hash":"4e73f10eacb5d00a0681cb44fe5c039cd8ab03cd","modified":1675231576252},{"_id":"themes/matery/layout/_partial/post-cover.ejs","hash":"166c0b9753f3f913bd801e82ad5b268004be198d","modified":1675231576251},{"_id":"themes/matery/layout/_partial/post-statis.ejs","hash":"3b42900247d5ea4ea5b68e2be44420a0d54785ad","modified":1675231576252},{"_id":"themes/matery/layout/_partial/search.ejs","hash":"e859fe6e0259e0c123cb7ceda6e4cac836318ffc","modified":1675231576252},{"_id":"themes/matery/layout/_partial/reprint-statement.ejs","hash":"f85a222ec3f9bc27eb7978015e63a16514b38791","modified":1675231576252},{"_id":"themes/matery/layout/_partial/social-link.ejs","hash":"e2865b3003ec07892e9112692e7ec786ee926ae8","modified":1675231576252},{"_id":"themes/matery/layout/_partial/valine.ejs","hash":"c3039180ddb2eb17e724b8441e5f93e79859aef7","modified":1675231576252},{"_id":"themes/matery/layout/_partial/post-detail-toc.ejs","hash":"82cb8090cde663fa7ad67418a802997b3057e957","modified":1675231576252},{"_id":"themes/matery/layout/_partial/share.ejs","hash":"0f2e1e27d21492cf228e786daead985b1e1dcea4","modified":1675231576252},{"_id":"themes/matery/layout/_partial/reward.ejs","hash":"73624d9db81e87ff0c12310bb873fbd0b5221021","modified":1675231576252},{"_id":"themes/matery/source/css/gitment.css","hash":"d5ef623065d1fbc897119f7b70ccf7563e329917","modified":1675231576254},{"_id":"themes/matery/source/js/matery.js","hash":"208b7806caa943c115aa0825c9c72a0781404775","modified":1675231576255},{"_id":"themes/matery/source/css/my.css","hash":"37683a9f11c68903a53e2b8593ca8c095a721896","modified":1675231576254},{"_id":"themes/matery/source/css/matery.css","hash":"0d345a72318fd7aadcb6fcaa6f3abac94b91001c","modified":1675231576254},{"_id":"themes/matery/source/css/my-gitalk.css","hash":"4e3e855767ac5a48b13af1d6a42df13d8975e03f","modified":1675231576254},{"_id":"themes/matery/source/js/search.js","hash":"77ecae23dd3edd8ad962c5b12954652bb2f7a1b6","modified":1675231576255},{"_id":"themes/matery/source/css/prism.css","hash":"163e7764ec6f65f1be8fac7b4a75088b79407ed2","modified":1675234285782},{"_id":"themes/matery/source/medias/logo.png","hash":"ee16e748bc0961b84ed544a3c041aa9c19b95948","modified":1675231576353},{"_id":"themes/matery/source/libs/aos/aos.css","hash":"ded9739f803d114c9168d3351fded72b3b478b4c","modified":1675231576255},{"_id":"themes/matery/source/js/prism.js","hash":"dd2c2a445f8fda202c69a1a8906e7563583a7a25","modified":1675234290996},{"_id":"themes/matery/source/libs/aos/aos.js","hash":"5a8e6d07ffa55642418ab3fd4b263aa08284b77a","modified":1675231576255},{"_id":"themes/matery/source/libs/codeBlock/clipboard.min.js","hash":"9cd57c67fbd3e3067f80793ef8445f5ff7783563","modified":1675231576261},{"_id":"themes/matery/source/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1675231576261},{"_id":"themes/matery/source/libs/animate/animate.min.css","hash":"5dfcbcee866e9dc564916416281885f3e320871e","modified":1675231576255},{"_id":"themes/matery/source/libs/codeBlock/codeCopy.js","hash":"b74a381adf6ef8404d6a0452c2b9f44b47219c80","modified":1675231576261},{"_id":"themes/matery/source/libs/codeBlock/codeShrink.js","hash":"215910dc8f63fd50b97957e5fcdc8480aa2728cb","modified":1675231576262},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","hash":"7f4f8913f2d46ade2def5134e2cc8684a4b87939","modified":1675231576255},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","hash":"70c0c4a9bf698747b7c058c21287ad617355e5dd","modified":1675231576256},{"_id":"themes/matery/source/libs/codeBlock/codeLang.js","hash":"ea8b51e4d75e7b2cd63e4d5bcb8db2cf7f23f5db","modified":1675231576261},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","hash":"021898a16279ac2ffe75af4f902fab2a0a39f11a","modified":1675231576266},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","hash":"5d52d3b34fceb9d7e11f1beaf7ed380b4249dec4","modified":1675231576262},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","hash":"4e6538c8312aeeab845d361c37a8c1a0931241f0","modified":1675231576267},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","hash":"a0625d8b432af8bdc820f8768d36cde439e7257c","modified":1675231576266},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"26849509f196a2d21bbfd15696e5d5153163b8f1","modified":1675231576267},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","hash":"f81cd7bfcf7aa2d043bd3e6077df42656fc44b82","modified":1675231576269},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1675231576270},{"_id":"themes/matery/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1675231576270},{"_id":"themes/matery/source/libs/others/fireworks.js","hash":"53981959bc6def4a85bbbb41b07e4b1474a2124d","modified":1675231576270},{"_id":"themes/matery/source/libs/others/explosion.min.js","hash":"417b68e2cf2c6de2119c57626f4412105a8457f5","modified":1675231576270},{"_id":"themes/matery/source/libs/others/snow.js","hash":"b393f069781eef788a0ae66b2681cece8fea2851","modified":1675231576270},{"_id":"themes/matery/source/libs/others/text.js","hash":"1791782cde0d1e4197f2ed58ecb7dd6aefddd169","modified":1675231576270},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1675231576270},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1675231576271},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","hash":"33810b2b757fc4327bc1d3b83bb5e0d3dc1fec5b","modified":1675231576262},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","hash":"f646f2bb75bcd1eb65b2788ac7bf15d4fd243ce9","modified":1675231576271},{"_id":"themes/matery/source/medias/avatars/ajin.jpg","hash":"76cb8e872472ff47a1b061c3bcff1c03f30c02b8","modified":1675231576273},{"_id":"themes/matery/source/medias/avatars/avatar.jpg","hash":"f92b165327d79aacc2fde2880745f80e4ca3d9e1","modified":1675231576274},{"_id":"themes/matery/source/medias/avatars/babyq.png","hash":"be5432588003e5a52c02e690622eec72b5f7346c","modified":1675231576274},{"_id":"themes/matery/source/medias/avatars/cww97.jpg","hash":"6af987cafc55d8d031534dd5e0f722fff19f70ec","modified":1675231576274},{"_id":"themes/matery/source/medias/avatars/feibar.jpg","hash":"343f47cb5c83cd866a1c824cbe2a112d02516d06","modified":1675231576275},{"_id":"themes/matery/source/medias/avatars/huaji.jpg","hash":"86be7eed2a491455ccfe3e7da46366ff477765ca","modified":1675231576277},{"_id":"themes/matery/source/medias/avatars/hael.jpg","hash":"e66ccedab38bb2e8fc45fac024e234ab8e7b9d54","modified":1675231576277},{"_id":"themes/matery/source/medias/avatars/ids2.jpg","hash":"2c8d3ac6ab5ac6196bac83766fde975daca91c32","modified":1675231576278},{"_id":"themes/matery/source/medias/avatars/hzwer.jpg","hash":"53a66bb5e65d2abd5b7412edf094c1e0b1094492","modified":1675231576277},{"_id":"themes/matery/source/medias/avatars/kewlgrl.jpg","hash":"3af0fd1029a1511bb3c0e90871e41b35e714b01f","modified":1675231576279},{"_id":"themes/matery/source/medias/avatars/fun4go.png","hash":"0f4333973a972a629cfbabf601bc7c192b65376c","modified":1675231576277},{"_id":"themes/matery/source/medias/avatars/ldy.jpg","hash":"906ef214d1f2fe52a663738340ad5623f826bd82","modified":1675231576280},{"_id":"themes/matery/source/medias/avatars/lijiaqian.png","hash":"9d96b3838acfae9a23b6e290fcfafceff0419c63","modified":1675231576281},{"_id":"themes/matery/source/medias/avatars/liyucheng.jpg","hash":"12055a27fa667c87d2319475968056e1a8ad0f08","modified":1675231576281},{"_id":"themes/matery/source/medias/avatars/liyangzone.jpg","hash":"febab557e4c0d859ab4cc14b57d8106f5e3fccfb","modified":1675231576281},{"_id":"themes/matery/source/medias/avatars/masterx.jpg","hash":"c9f7e83d895fa241cefd6e742f356106b35f1b89","modified":1675231576283},{"_id":"themes/matery/source/medias/avatars/michael.jpg","hash":"331a2ab20c299196f5a3089b8445fc8f55346cb6","modified":1675231576284},{"_id":"themes/matery/source/medias/avatars/mpy634.png","hash":"30f88e09c02b37c2dc684d4ee3237e327bb23f8b","modified":1675231576285},{"_id":"themes/matery/source/medias/avatars/qiqiang.jpg","hash":"081459866f922d9558a88cd4d7155d91fa730322","modified":1675231576286},{"_id":"themes/matery/source/medias/avatars/mouse.jpg","hash":"2eae273885b9859150a1f98f74b3df12ca9a207c","modified":1675231576285},{"_id":"themes/matery/source/medias/avatars/sunchangzhi.jpg","hash":"bbe2a15fd474ab62dbd14fea72deb1113a4fb005","modified":1675231576287},{"_id":"themes/matery/source/medias/avatars/taotao.jpg","hash":"e668254375ddd40a684ff4669c3421851bebd36e","modified":1675231576287},{"_id":"themes/matery/source/medias/avatars/spacesac.png","hash":"ff1bdb058f1f0499312da1a082ba97d78590db1a","modified":1675231576287},{"_id":"themes/matery/source/medias/avatars/tawn.jpg","hash":"68a1cbacbb2370912b000c9d8d2b16196c918a50","modified":1675231576287},{"_id":"themes/matery/source/medias/avatars/zhaokangzhe.jpg","hash":"c8242bd13f08a9ddb97e26f216bc729b12ed9058","modified":1675231576290},{"_id":"themes/matery/source/medias/avatars/yezijie.png","hash":"8a53537eb69f749115e512b6da061e7f23cd04e5","modified":1675231576288},{"_id":"themes/matery/source/medias/featureimages/0.jpg","hash":"1f8bbfbd625448b4b2a748b75636e456b826dcd3","modified":1675231576298},{"_id":"themes/matery/source/medias/avatars/taowei.jpg","hash":"e58b03b70656aa7a27238be38dac3896d9d16f10","modified":1675231576287},{"_id":"themes/matery/source/medias/featureimages/5.jpg","hash":"c4cc724f4572a9bcede7443a4f4c0393d3073868","modified":1675231576337},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1675231576267},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","hash":"3480f00d284c812d623ed16a9e0ead3fb964c72e","modified":1675231576268},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1675231576268},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1675231576268},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1675231576268},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1675231576267},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1675231576268},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1675231576268},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1675231576268},{"_id":"themes/matery/source/medias/files/cv-en.pdf","hash":"2a62ab3797f8bc8e2e5e04c4950198525c635139","modified":1675231576351},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"f8cd48e1fff82ecd54a7ce3e69de8dba7c92d113","modified":1675231576268},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1675231576256},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1675231576270},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","hash":"337b4f156f6d8f4beb32c32a3db46fef361cff74","modified":1675231576270},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1675231576270},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1675231576270},{"_id":"themes/matery/source/libs/share/css/share.min.css","hash":"7126de5cec8371e580b7b1f22512da0985cc39e5","modified":1675231576270},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","hash":"4df722bafde2c5d8faaace0d1f894798385a8793","modified":1675231576271},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","hash":"16ce82901ca0e302cf47a35fb10f59009a5e7eb9","modified":1675231576271},{"_id":"themes/matery/source/medias/music/avatars/tiantangdemogui.jpg","hash":"f005578ddb4d3d731838db89a708f39f18d50e60","modified":1675231576354},{"_id":"themes/matery/source/medias/music/avatars/yiluxiangbei.jpg","hash":"01b12e3aca7385a88412c12539e1a608a78896fa","modified":1675231576355},{"_id":"source/_posts/iOS-swift-网络请求二次封装moya/moya1.png","hash":"b9eecb78564853a842883c98ca0b654dd7cd2661","modified":1675233130505},{"_id":"themes/matery/source/medias/music/avatars/yequ.jpg","hash":"103beb9ab33434b434fa37a30aecdb29db633024","modified":1675231576355},{"_id":"source/_posts/iOS-swift-混编Flutter/fluttererror03.png","hash":"c2092c7ac8a47f5145a4891d0e64cda207ffa626","modified":1675232849748},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","hash":"82276be41d2001e820020a219b90ad5b026302d1","modified":1675231576262},{"_id":"themes/matery/source/libs/gitment/gitment.js","hash":"5a13983930b019450e4fe01a407c64b3dd316be4","modified":1675231576267},{"_id":"themes/matery/source/medias/gzh.jpg","hash":"c6f507fbe3c3719b81dcba46125568bf22e8d9b6","modified":1675231576353},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","hash":"7a551393b8360731104fdef1af36a6f3638f5855","modified":1675231576267},{"_id":"themes/matery/source/libs/valine/Valine.min.js","hash":"f1558f12d96a352e490166d543a8e821dd3bb2bc","modified":1675231576271},{"_id":"themes/matery/source/medias/avatars/bytedtrans.png","hash":"ce59d69e5106f20548f4ec9b6429c8fcc787ea08","modified":1675231576274},{"_id":"themes/matery/source/medias/avatars/antnlp.ico","hash":"29475f350b989331cebd702a315f020917d06ed8","modified":1675231576273},{"_id":"themes/matery/source/medias/avatars/gsy.jpg","hash":"6a175e2ba56a2280d40a2e654b559be41c3a0a48","modified":1675231576277},{"_id":"themes/matery/source/medias/avatars/duyupei.jpg","hash":"3c02ed4cf57dc37e4f4b8314bf5094833a854cb0","modified":1675231576275},{"_id":"themes/matery/source/medias/avatars/jiejie.jpg","hash":"a52476e25bec2391674e77a889a89341fbb29791","modified":1675231576278},{"_id":"themes/matery/source/medias/avatars/myzhihu.png","hash":"992e0d803160d2ae867be5eb0032d324d1cedffb","modified":1675231576286},{"_id":"themes/matery/source/medias/avatars/qiandongwei.jpg","hash":"6873551596a4513d01898ad866c4073c68270c57","modified":1675231576286},{"_id":"themes/matery/source/medias/avatars/milyyy.jpg","hash":"ac2826d9c28346efeb967df01465a2c74d9041fe","modified":1675231576284},{"_id":"themes/matery/source/medias/avatars/mizunashi.png","hash":"5fc300701d3b4250a307ed70e3a3aa0d5395c808","modified":1675231576285},{"_id":"themes/matery/source/medias/avatars/xuzhongyou.jpg","hash":"1db4dfaf23cf250f222a398326562d4170d3aaa1","modified":1675231576288},{"_id":"themes/matery/source/medias/avatars/zhangting.jpg","hash":"10ee25ae3531f046a8bd3696c1cc8a16f0f25e1b","modified":1675231576289},{"_id":"themes/matery/source/medias/avatars/xiejiadong.jpg","hash":"f1a31f89426bd4dccdaba2170f4fc701336702e1","modified":1675231576288},{"_id":"themes/matery/source/medias/avatars/zzw.jpg","hash":"5d385b5732644b07b937a4919abc83cb95e14513","modified":1675231576290},{"_id":"themes/matery/source/medias/banner/1.jpg","hash":"309f484b6e69e877de6a7fb847d66497d22bbd65","modified":1675231576291},{"_id":"themes/matery/source/medias/files/cv-zh.pdf","hash":"4f58778031b0a0e669e036b16639741e44fc2375","modified":1675231576352},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1675231576261},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1675231576261},{"_id":"themes/matery/source/medias/contact.jpg","hash":"e7bb4c4cc6807f32018c9ce7eadf4946e1976b64","modified":1675231576298},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","hash":"f63c7c489524ccb5d95e74fcd6618116c58fb305","modified":1675231576266},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","hash":"c843f0dc497314574c608ca28cc742bb041786d5","modified":1675231576269},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","hash":"2c27939768606603bee3b5e6c8a722596a667e60","modified":1675231576269},{"_id":"themes/matery/source/libs/valine/av-min.js","hash":"04c6b2782ce4610c429563110f6a20a47432fc4c","modified":1675231576272},{"_id":"themes/matery/source/medias/avatars/0xbird.png","hash":"f9d597dfcb49e1e2be06138b24028291f5638610","modified":1675231576273},{"_id":"themes/matery/source/medias/avatars/lyn-draw.jpg","hash":"837d5d5df4dcb086d2da114d0d85084b4ec18768","modified":1675231576282},{"_id":"themes/matery/source/medias/avatars/mashiro.jpg","hash":"250e911c16eeb6acb1e6214ad3e6a3d762850a8e","modified":1675231576283},{"_id":"themes/matery/source/medias/avatars/lzh.png","hash":"8ffcbf19d6b38b891dbe408d9a4e9513b56f247e","modified":1675231576282},{"_id":"themes/matery/source/medias/avatars/qianqian.png","hash":"fed254c4e7eb58ee22d647acb83f1d08f4508f8f","modified":1675231576286},{"_id":"themes/matery/source/medias/banner/0.jpg","hash":"d4db93afdff4ce889dd8271bcf9e80eb3c0bf866","modified":1675231576291},{"_id":"themes/matery/source/medias/banner/2.jpg","hash":"280fa1c6493d7fdccfc18bd486446bacd9afe623","modified":1675231576292},{"_id":"themes/matery/source/medias/banner/6.jpg","hash":"4fcbc9dd8ec0316e9dd5bfd0caf86f1520b10b3f","modified":1675231576297},{"_id":"themes/matery/source/medias/featureimages/14.jpg","hash":"1c1063c29f827cf52eeef7ca8dc2d7e4efa31a76","modified":1675231576306},{"_id":"themes/matery/source/medias/featureimages/13.jpg","hash":"d8cc7a730668943dcb0776cfa240a0cf76826363","modified":1675231576305},{"_id":"themes/matery/source/medias/featureimages/22.jpg","hash":"02ec4566225102778c3837f08b24de02faf460a6","modified":1675231576322},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1675231576260},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1675231576258},{"_id":"source/_posts/iOS-swift-混编Flutter/fluttererror2.png","hash":"19dc9ab0586378a2929bb69c318d6ec6db6d8de0","modified":1675232849750},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1675231576257},{"_id":"themes/matery/source/medias/avatars/feibar.png","hash":"eceaefcbbca1bf49b582eaa649d311cf4fe69dd6","modified":1675231576276},{"_id":"themes/matery/source/medias/avatars/jitao.jpg","hash":"5934b9baccebccbc2be2ead5d84ad32dd41f9559","modified":1675231576279},{"_id":"themes/matery/source/medias/avatars/zhangyi.jpg","hash":"c9130036aac9a7ac8d62e33550a9d64896cdc364","modified":1675231576290},{"_id":"themes/matery/source/medias/banner/4.jpg","hash":"a3cfdee2120195ab36b2fdd074d5558852e69297","modified":1675231576295},{"_id":"themes/matery/source/medias/featureimages/12.jpg","hash":"c2892770fd5617418fd33d6f834879e05b2cdafd","modified":1675231576305},{"_id":"themes/matery/source/medias/music/avatars/daoshu.jpg","hash":"eee120fdf5ccbe86aa7d51826c4c773e76e6357f","modified":1675231576354},{"_id":"themes/matery/source/medias/avatars/jingjing.jpg","hash":"bfcab0139edb2509de984cb0a9b156879c355158","modified":1675231576279},{"_id":"themes/matery/source/medias/banner/3.jpg","hash":"255aaa4375da855bd80b38cfcc253de892a9d4cf","modified":1675231576293},{"_id":"themes/matery/source/medias/banner/5.jpg","hash":"6ddd1bcbb62a2d28c5be3b9acb7418849d60b2e7","modified":1675231576296},{"_id":"themes/matery/source/medias/featureimages/23.jpg","hash":"ee598933707f8bb98ecbf36925f24e8a1c4bd2d6","modified":1675231576323},{"_id":"themes/matery/source/medias/featureimages/25.jpg","hash":"d0668539783fc615f14178644e486a6befb90c0c","modified":1675231576328},{"_id":"themes/matery/source/medias/featureimages/2.jpg","hash":"1d8863277d744e1a18a2778ac26041bda5b03a98","modified":1675231576316},{"_id":"themes/matery/source/medias/featureimages/17.jpg","hash":"11a6de283124964370dbfaf0e74f2f1e9ac8394d","modified":1675231576311},{"_id":"themes/matery/source/medias/featureimages/3.jpg","hash":"ceb8e0c195a7fe7420334efa114e98cd0e1c6523","modified":1675231576333},{"_id":"themes/matery/source/medias/featureimages/28.jpg","hash":"c73036359640a67a8b17db7ba0e968c088957ab8","modified":1675231576332},{"_id":"source/_posts/iOS-swift-数据库realm实践/realm2.png","hash":"9a893b602da7960abac88cbd75a913107d9ad58d","modified":1675232014866},{"_id":"source/_posts/iOS-swift-数据库realm实践/realm1.png","hash":"8dea478526f67950e1d04d4f8ade74ab7cd64b2b","modified":1675232014864},{"_id":"source/_posts/玩Android-Compose版本-项目分析/mine.jpeg","hash":"1f86a74843aaae7e80f61155a58a17da1320a614","modified":1675231576227},{"_id":"themes/matery/source/medias/featureimages/10.jpg","hash":"66de48d963e7f221931e550b2442da0cd40cbaa8","modified":1675231576301},{"_id":"themes/matery/source/medias/featureimages/20.jpg","hash":"84ba9cf61045de789426eeb6333910266ce29b8c","modified":1675231576318},{"_id":"themes/matery/source/medias/featureimages/27.jpg","hash":"7ea6f890cc59def8b1c9f393e4ae77cd16c79aad","modified":1675231576330},{"_id":"themes/matery/source/medias/featureimages/26.jpg","hash":"c66a4e7a2e670b63759a091f9428ee7f971d7b56","modified":1675231576329},{"_id":"themes/matery/source/medias/featureimages/6.jpg","hash":"698fc46e97428d73c9d4e3d254e88b9b66fb38cd","modified":1675231576341},{"_id":"themes/matery/source/medias/featureimages/7.jpg","hash":"bd400da9123424afe7ba6c839be9ad7697c1245b","modified":1675231576343},{"_id":"source/_posts/iOS-swift-实现简易地图功能/map.png","hash":"93e267d80b97c93e48677b068f43c171ea851053","modified":1675232014861},{"_id":"themes/matery/source/medias/featureimages/11.jpg","hash":"2b30186c6d78ed76fa5f278be57290c1bd22c96a","modified":1675231576303},{"_id":"themes/matery/source/medias/featureimages/1.jpg","hash":"f1d720039d654d693c32150c06c78cfc3663b0b4","modified":1675231576299},{"_id":"themes/matery/source/medias/featureimages/16.jpg","hash":"0801e96a2f4cbd14b2ad44547e5ffbb23822e751","modified":1675231576310},{"_id":"themes/matery/source/medias/featureimages/18.jpg","hash":"c74ce6fa4eee122e147ec55532744f34a87ae2bf","modified":1675231576312},{"_id":"themes/matery/source/medias/featureimages/21.jpg","hash":"a77810cc2224446f5d4e1a857a8d480f21e81f83","modified":1675231576321},{"_id":"themes/matery/source/medias/featureimages/19.jpg","hash":"2a47d1123d9c4c6255b7b4817a582d2fa9aea808","modified":1675231576314},{"_id":"themes/matery/source/medias/featureimages/24.jpg","hash":"72bc68fb0673b84ab9f863d2979396cdc268a76c","modified":1675231576326},{"_id":"themes/matery/source/medias/reward/alipay.png","hash":"98faed5b838aa003f660213be764152ee348f451","modified":1675231576356},{"_id":"themes/matery/source/medias/reward/wechat.png","hash":"98faed5b838aa003f660213be764152ee348f451","modified":1675231576356},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1675231576259},{"_id":"source/_posts/玩Android-Compose版本-项目分析/首页.jpeg","hash":"c0541a828adb8491a51c67a7a11fe2d7ff057bad","modified":1675231576249},{"_id":"themes/matery/source/medias/featureimages/8.jpg","hash":"f81e97edf705ab45b989b2b15d6a13c005ccaa32","modified":1675231576346},{"_id":"source/_posts/iOS-swift-如何实现扫码功能/scan1.png","hash":"b06f374c408dd565191b743f0dcebfd4f6311100","modified":1675232014857},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","hash":"8789b5e4daf0029a6c88f238f10e54d01c4fce82","modified":1675231576265},{"_id":"source/_posts/iOS-swift-如何实现扫码功能/scan2.png","hash":"f77a75032260c4927cb3b674d190257fd558e208","modified":1675232014859},{"_id":"source/_posts/iOS-swift-自定义View之四级地址/四级地址.gif","hash":"586e0fcfc20a5c0d870a0e5cacb85a2ec52a304e","modified":1675232014876},{"_id":"themes/matery/source/medias/featureimages/15.jpg","hash":"aff885598033614639944c7559b4849f883e2b34","modified":1675231576309},{"_id":"themes/matery/source/medias/featureimages/9.jpg","hash":"cd54b116609f5741cc7db0f7f49bf56ac356ddfb","modified":1675231576350},{"_id":"themes/matery/source/medias/featureimages/4.jpg","hash":"e06afe32a867f7a6e861618e0b5ac9d93cd71d05","modified":1675231576337},{"_id":"source/_posts/玩Android-Compose版本-项目分析/闪屏页.gif","hash":"a76a77cf58af915878c1141c48d7825ef9334fe9","modified":1675231576244},{"_id":"public/about/index.html","hash":"d781cdd4aa5550267cf83df2d90a3a5f944a7d96","modified":1675243882420},{"_id":"public/404.html","hash":"f3448e68bba68c14d4da91ade24f345c84b3109b","modified":1675243882420},{"_id":"public/categories/index.html","hash":"cc44685cdb5d18c2b02c375e3ef664e4007193bb","modified":1675243882420},{"_id":"public/archives/index.html","hash":"64fa1993c219c4e1e264fc9134c8330f84d2248b","modified":1675243882420},{"_id":"public/friends/index.html","hash":"46e31a4ed33f8f009a9edb226a8e022d743fa0c5","modified":1675243882420},{"_id":"public/tags/index.html","hash":"54ecee5a51ec1ee8c5a7aea69125db9a898c420c","modified":1675243882420},{"_id":"public/2023/02/01/iOS-swift-混编Flutter/index.html","hash":"a49be95a8d2385d4506868f78f319411ecf31fad","modified":1675243882420},{"_id":"public/contact/index.html","hash":"ca807969c25bff840a44ab9957b10ca7f24339d2","modified":1675243882420},{"_id":"public/2023/02/01/iOS-swift-网络请求二次封装moya/index.html","hash":"3610c6f29cbb85a411fdc8601764d9e5efe0ffc5","modified":1675243882420},{"_id":"public/2023/01/31/iOS-swift-实现简易地图功能/index.html","hash":"ba845c3c795d961027e94a4a43deb4da40fba9f8","modified":1675243882420},{"_id":"public/2023/01/30/iOS-swift-数据库realm实践/index.html","hash":"9dd291e48986453a68b270670265e6ea6884171d","modified":1675243882420},{"_id":"public/2023/01/29/iOS-swift-如何实现扫码功能/index.html","hash":"a3d0782ba4ad3aadda85c23740c660dc32de0a51","modified":1675243882420},{"_id":"public/2023/01/28/iOS-swift-自定义View之时间选择器/index.html","hash":"fc63dc63cab6479be80b419a10cdb0eadd826939","modified":1675243882420},{"_id":"public/2023/01/27/iOS-swift-自定义View之四级地址/index.html","hash":"4f1b0316c2b5dcf4b4f46bc3fafcab0794f1a891","modified":1675243882420},{"_id":"public/2023/01/26/iOS-swift-自定义View之步进器/index.html","hash":"45928c2c71a559f3929fe1324f787a9201062021","modified":1675243882420},{"_id":"public/2023/01/23/iOS-学习导航/index.html","hash":"8c640410ee43f37ed09faa5c1c7458b584026c18","modified":1675243882420},{"_id":"public/2023/01/22/Flutter-学习导航/index.html","hash":"5a70c8ef8a00c0975dc83464e8c276f4593d054c","modified":1675243882420},{"_id":"public/2023/01/21/Android-学习导航/index.html","hash":"3dd4aed3898b202106d9b931c294767a466f9612","modified":1675243882420},{"_id":"public/2023/01/15/Android-google-samples-nowinandroid-app模块流程分析/index.html","hash":"4e07a726297ee4716a07fb8beac82325134eaa4d","modified":1675243882420},{"_id":"public/2023/01/17/玩Android-Compose版本-项目分析/index.html","hash":"9f85c75afccf32fd541477c24cc8ba7ec69adf1b","modified":1675243882420},{"_id":"public/2023/01/11/5w2h-godweiyang/index.html","hash":"a052e94723786c7ddddbdb2ece8e321f277be85e","modified":1675243882420},{"_id":"public/2023/01/13/Android-gradle相关-KTS脚本-项目配置改造/index.html","hash":"dbdb21c7517f484faae719db9cb6510a0fd5e3a9","modified":1675243882420},{"_id":"public/categories/随笔/index.html","hash":"c114ce6a76f3331295ced7d7a85cfb092b0287fb","modified":1675243882420},{"_id":"public/categories/Android/index.html","hash":"1c5c052e05c0d8b8a6daa73d04979d4f26130de5","modified":1675243882420},{"_id":"public/categories/iOS/index.html","hash":"c247b05bc2b9323ccfec7c25f9233e80ef0a238d","modified":1675243882420},{"_id":"public/categories/Flutter/index.html","hash":"89ed05a07cfbbd1ef25441a1961f58b9ff138313","modified":1675243882420},{"_id":"public/page/2/index.html","hash":"be2da1c2330246216987748768cd957c565434f4","modified":1675243882420},{"_id":"public/archives/page/2/index.html","hash":"526a61430975df680c0c0bce118e31c7bb4d9cfd","modified":1675243882420},{"_id":"public/index.html","hash":"59111fb768b2a896c2785a9b419e02db069db2ac","modified":1675243882420},{"_id":"public/archives/2023/index.html","hash":"047596d3ecf8017ab387c3732672adef9d25160f","modified":1675243882420},{"_id":"public/archives/2023/page/2/index.html","hash":"07c8550f494fbebbb71101339d8749b2b119f00d","modified":1675243882420},{"_id":"public/archives/2023/01/page/2/index.html","hash":"34eeaacac90d0c56cf8e7880c341c53221e8ab60","modified":1675243882420},{"_id":"public/archives/2023/01/index.html","hash":"f1bbac0db367753ce6714b8752b64efc56933cf1","modified":1675243882420},{"_id":"public/archives/2023/02/index.html","hash":"1fa4ddfd4f2d111a51d93e56ca596b48cbf122c5","modified":1675243882420},{"_id":"public/tags/Android/index.html","hash":"948f9256027994f3a762519086cfd914a569381a","modified":1675243882420},{"_id":"public/tags/博客/index.html","hash":"5589421a676706a4833e919160f8d47fd1218cbe","modified":1675243882420},{"_id":"public/tags/Flutter/index.html","hash":"5005437ab5a6d81537b4c7358ab252c0b7dea6b0","modified":1675243882420},{"_id":"public/tags/数据库-iOS/index.html","hash":"377bfe33af791b63bae9aa6f02112227c924469d","modified":1675243882420},{"_id":"public/tags/网络请求/index.html","hash":"9e602ebf136ab6dce029d62dc7581731cb9aaf17","modified":1675243882420},{"_id":"public/tags/混编Flutter/index.html","hash":"da4a69dc3d9c267ab350e72ce9498504a40f6e81","modified":1675243882420},{"_id":"public/tags/iOS-自定义View/index.html","hash":"189876d93d4edda0562d942866536975cbec83d5","modified":1675243882420},{"_id":"public/tags/条形码识别-相机/index.html","hash":"38c67580713033a61cf0198b92b83bffc3857b96","modified":1675243882420},{"_id":"public/tags/地图/index.html","hash":"1d1bdda026fbd7b9f10a9364a838d6d638173f5f","modified":1675243882420},{"_id":"public/tags/iOS/index.html","hash":"c4566f7f02252cb142ba75605b087a3880e0d693","modified":1675243882420},{"_id":"public/favicon.png","hash":"0f4145b9a712f9662e4fae1b0086ce74cf1f9fc4","modified":1675235563295},{"_id":"public/medias/avatars/ajin.jpg","hash":"76cb8e872472ff47a1b061c3bcff1c03f30c02b8","modified":1675235563295},{"_id":"public/medias/avatars/avatar.jpg","hash":"f92b165327d79aacc2fde2880745f80e4ca3d9e1","modified":1675235563295},{"_id":"public/medias/avatars/babyq.png","hash":"be5432588003e5a52c02e690622eec72b5f7346c","modified":1675235563295},{"_id":"public/medias/logo.png","hash":"ee16e748bc0961b84ed544a3c041aa9c19b95948","modified":1675235563295},{"_id":"public/medias/avatars/feibar.jpg","hash":"343f47cb5c83cd866a1c824cbe2a112d02516d06","modified":1675235563295},{"_id":"public/medias/avatars/hael.jpg","hash":"e66ccedab38bb2e8fc45fac024e234ab8e7b9d54","modified":1675235563295},{"_id":"public/medias/avatars/huaji.jpg","hash":"86be7eed2a491455ccfe3e7da46366ff477765ca","modified":1675235563295},{"_id":"public/medias/avatars/cww97.jpg","hash":"6af987cafc55d8d031534dd5e0f722fff19f70ec","modified":1675235563295},{"_id":"public/medias/avatars/fun4go.png","hash":"0f4333973a972a629cfbabf601bc7c192b65376c","modified":1675235563295},{"_id":"public/medias/avatars/kewlgrl.jpg","hash":"3af0fd1029a1511bb3c0e90871e41b35e714b01f","modified":1675235563295},{"_id":"public/medias/avatars/ids2.jpg","hash":"2c8d3ac6ab5ac6196bac83766fde975daca91c32","modified":1675235563295},{"_id":"public/medias/avatars/ldy.jpg","hash":"906ef214d1f2fe52a663738340ad5623f826bd82","modified":1675235563295},{"_id":"public/medias/avatars/lijiaqian.png","hash":"9d96b3838acfae9a23b6e290fcfafceff0419c63","modified":1675235563295},{"_id":"public/medias/avatars/hzwer.jpg","hash":"53a66bb5e65d2abd5b7412edf094c1e0b1094492","modified":1675235563295},{"_id":"public/medias/avatars/liyucheng.jpg","hash":"12055a27fa667c87d2319475968056e1a8ad0f08","modified":1675235563295},{"_id":"public/medias/avatars/liyangzone.jpg","hash":"febab557e4c0d859ab4cc14b57d8106f5e3fccfb","modified":1675235563295},{"_id":"public/medias/avatars/masterx.jpg","hash":"c9f7e83d895fa241cefd6e742f356106b35f1b89","modified":1675235563295},{"_id":"public/medias/avatars/michael.jpg","hash":"331a2ab20c299196f5a3089b8445fc8f55346cb6","modified":1675235563295},{"_id":"public/medias/avatars/mpy634.png","hash":"30f88e09c02b37c2dc684d4ee3237e327bb23f8b","modified":1675235563295},{"_id":"public/medias/avatars/mouse.jpg","hash":"2eae273885b9859150a1f98f74b3df12ca9a207c","modified":1675235563295},{"_id":"public/medias/avatars/qiqiang.jpg","hash":"081459866f922d9558a88cd4d7155d91fa730322","modified":1675235563295},{"_id":"public/medias/avatars/spacesac.png","hash":"ff1bdb058f1f0499312da1a082ba97d78590db1a","modified":1675235563295},{"_id":"public/medias/avatars/taowei.jpg","hash":"e58b03b70656aa7a27238be38dac3896d9d16f10","modified":1675235563295},{"_id":"public/medias/avatars/tawn.jpg","hash":"68a1cbacbb2370912b000c9d8d2b16196c918a50","modified":1675235563295},{"_id":"public/medias/avatars/taotao.jpg","hash":"e668254375ddd40a684ff4669c3421851bebd36e","modified":1675235563295},{"_id":"public/medias/avatars/sunchangzhi.jpg","hash":"bbe2a15fd474ab62dbd14fea72deb1113a4fb005","modified":1675235563295},{"_id":"public/medias/avatars/yezijie.png","hash":"8a53537eb69f749115e512b6da061e7f23cd04e5","modified":1675235563295},{"_id":"public/medias/avatars/zhaokangzhe.jpg","hash":"c8242bd13f08a9ddb97e26f216bc729b12ed9058","modified":1675235563295},{"_id":"public/medias/featureimages/0.jpg","hash":"1f8bbfbd625448b4b2a748b75636e456b826dcd3","modified":1675235563295},{"_id":"public/medias/featureimages/5.jpg","hash":"c4cc724f4572a9bcede7443a4f4c0393d3073868","modified":1675235563295},{"_id":"public/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1675235563295},{"_id":"public/medias/files/cv-en.pdf","hash":"2a62ab3797f8bc8e2e5e04c4950198525c635139","modified":1675235563295},{"_id":"public/libs/lightGallery/fonts/lg.svg","hash":"3480f00d284c812d623ed16a9e0ead3fb964c72e","modified":1675235563295},{"_id":"public/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1675235563295},{"_id":"public/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1675235563295},{"_id":"public/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1675235563295},{"_id":"public/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1675235563295},{"_id":"public/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1675235563295},{"_id":"public/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1675235563295},{"_id":"public/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1675235563295},{"_id":"public/libs/share/fonts/iconfont.svg","hash":"337b4f156f6d8f4beb32c32a3db46fef361cff74","modified":1675235563295},{"_id":"public/medias/music/avatars/yequ.jpg","hash":"103beb9ab33434b434fa37a30aecdb29db633024","modified":1675235563295},{"_id":"public/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1675235563295},{"_id":"public/CNAME","hash":"5e8a7aad69a8e5e79479ea54733cb096611eec47","modified":1675235563295},{"_id":"public/medias/music/avatars/tiantangdemogui.jpg","hash":"f005578ddb4d3d731838db89a708f39f18d50e60","modified":1675235563295},{"_id":"public/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1675235563295},{"_id":"public/medias/music/avatars/yiluxiangbei.jpg","hash":"01b12e3aca7385a88412c12539e1a608a78896fa","modified":1675235563295},{"_id":"public/2023/01/22/Flutter-学习导航/Study_Knowledge.jpeg","hash":"ed1d63d25a4136faca1b8a6d6c3da1ef3413720b","modified":1675235563295},{"_id":"public/2023/01/22/Flutter-学习导航/FlutterDevs.jpeg","hash":"f99339d77b2943ce258ccc86d1347d666b72920c","modified":1675235563295},{"_id":"public/2023/01/22/Flutter-学习导航/blog_520lee_com.jpeg","hash":"55ca5b424bbe29efce36afdd29b702250d988875","modified":1675235563295},{"_id":"public/2023/01/21/Android-学习导航/hongyang.jpeg","hash":"6d414b2f8a29459ed52f4a7d1714441074d85f42","modified":1675235563295},{"_id":"public/2023/01/21/Android-学习导航/jishuquan.jpeg","hash":"7597cde9db6040f80064ab5c397ad40394c2c068","modified":1675235563295},{"_id":"public/2023/01/21/Android-学习导航/carson.jpeg","hash":"40635ad0a930abcc74b1e2eec760cb44cfc477f8","modified":1675235563295},{"_id":"public/2023/01/21/Android-学习导航/guolin.jpeg","hash":"637e479009efdec579986fbe8eb5eacc9e46932e","modified":1675235563295},{"_id":"public/2023/01/21/Android-学习导航/bianchengjingxuan.jpeg","hash":"f6fb1d9014d3745473e188380216cef5bae7da92","modified":1675235563295},{"_id":"public/2023/01/21/Android-学习导航/qunyingzhuan.jpeg","hash":"203453e7a2f5ec4b3ab6b9d643a1a8882ec528be","modified":1675235563295},{"_id":"public/2023/01/21/Android-学习导航/jsonchao.jpeg","hash":"e476402b268490d72534f55cfa9d23b9be43f566","modified":1675235563295},{"_id":"public/2023/01/21/Android-学习导航/jishuzhuanjia.jpeg","hash":"a9036689bffb0d31e44ca4c691a79b30893b97ac","modified":1675235563295},{"_id":"public/2023/01/26/iOS-swift-自定义View之步进器/stepper5.png","hash":"4f77bd25aaec9a33753d84c2205feb7642e40284","modified":1675235563295},{"_id":"public/2023/01/26/iOS-swift-自定义View之步进器/stepper0.png","hash":"ebc88bb13e0f6168189228b613a0dd41f73882d2","modified":1675235563295},{"_id":"public/2023/01/23/iOS-学习导航/mobile_tech_share.jpeg","hash":"90b55e26b096ae716f8074096ac48b2b1290c852","modified":1675235563295},{"_id":"public/2023/01/23/iOS-学习导航/iOSkaifa.jpeg","hash":"a5478eb61474efe19ac6abc28a427d7096c749e8","modified":1675235563295},{"_id":"public/2023/01/17/玩Android-Compose版本-项目分析/home_item.jpeg","hash":"ee18c76cc19ffc9653309fb22c5db4be8abe6694","modified":1675235563295},{"_id":"public/medias/avatars/antnlp.ico","hash":"29475f350b989331cebd702a315f020917d06ed8","modified":1675235563295},{"_id":"public/medias/gzh.jpg","hash":"c6f507fbe3c3719b81dcba46125568bf22e8d9b6","modified":1675235563295},{"_id":"public/medias/avatars/bytedtrans.png","hash":"ce59d69e5106f20548f4ec9b6429c8fcc787ea08","modified":1675235563295},{"_id":"public/medias/avatars/gsy.jpg","hash":"6a175e2ba56a2280d40a2e654b559be41c3a0a48","modified":1675235563295},{"_id":"public/medias/avatars/duyupei.jpg","hash":"3c02ed4cf57dc37e4f4b8314bf5094833a854cb0","modified":1675235563295},{"_id":"public/medias/avatars/jiejie.jpg","hash":"a52476e25bec2391674e77a889a89341fbb29791","modified":1675235563295},{"_id":"public/medias/avatars/qiandongwei.jpg","hash":"6873551596a4513d01898ad866c4073c68270c57","modified":1675235563295},{"_id":"public/medias/avatars/milyyy.jpg","hash":"ac2826d9c28346efeb967df01465a2c74d9041fe","modified":1675235563295},{"_id":"public/medias/avatars/myzhihu.png","hash":"992e0d803160d2ae867be5eb0032d324d1cedffb","modified":1675235563295},{"_id":"public/medias/avatars/mizunashi.png","hash":"5fc300701d3b4250a307ed70e3a3aa0d5395c808","modified":1675235563295},{"_id":"public/js/search.js","hash":"499e11786efbb04815b54a1de317cc8606a37555","modified":1675235563295},{"_id":"public/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1675235563295},{"_id":"public/css/prism.css","hash":"163e7764ec6f65f1be8fac7b4a75088b79407ed2","modified":1675235563295},{"_id":"public/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1675235563295},{"_id":"public/css/my.css","hash":"497e50351f7838f8546cac76850a42e7e380a110","modified":1675235563295},{"_id":"public/js/matery.js","hash":"92f07106944f5ef7cd72e84bb3534513d00eebe1","modified":1675235563295},{"_id":"public/libs/codeBlock/codeLang.js","hash":"ea8b51e4d75e7b2cd63e4d5bcb8db2cf7f23f5db","modified":1675235563295},{"_id":"public/libs/codeBlock/codeCopy.js","hash":"b74a381adf6ef8404d6a0452c2b9f44b47219c80","modified":1675235563295},{"_id":"public/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1675235563295},{"_id":"public/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1675235563295},{"_id":"public/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1675235563295},{"_id":"public/libs/codeBlock/codeShrink.js","hash":"215910dc8f63fd50b97957e5fcdc8480aa2728cb","modified":1675235563295},{"_id":"public/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1675235563295},{"_id":"public/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1675235563295},{"_id":"public/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1675235563295},{"_id":"public/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1675235563295},{"_id":"public/libs/others/fireworks.js","hash":"53981959bc6def4a85bbbb41b07e4b1474a2124d","modified":1675235563295},{"_id":"public/libs/others/text.js","hash":"1791782cde0d1e4197f2ed58ecb7dd6aefddd169","modified":1675235563295},{"_id":"public/libs/others/explosion.min.js","hash":"417b68e2cf2c6de2119c57626f4412105a8457f5","modified":1675235563295},{"_id":"public/libs/others/snow.js","hash":"7f3b1ad2f64d4473210a2c3218893649c73c980e","modified":1675235563295},{"_id":"public/libs/tocbot/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1675235563295},{"_id":"public/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1675235563295},{"_id":"public/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1675235563295},{"_id":"public/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1675235563295},{"_id":"public/js/prism.js","hash":"dd2c2a445f8fda202c69a1a8906e7563583a7a25","modified":1675235563295},{"_id":"public/css/matery.css","hash":"caa63c2c7908e45ebbbea0fbdc72d09b7b6d5b76","modified":1675235563295},{"_id":"public/libs/codeBlock/clipboard.min.js","hash":"9cd57c67fbd3e3067f80793ef8445f5ff7783563","modified":1675235563295},{"_id":"public/libs/gitalk/gitalk.css","hash":"3aac1db83b0135c521187254ff302d125cc30706","modified":1675235563295},{"_id":"public/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1675235563295},{"_id":"public/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1675235563295},{"_id":"public/libs/gitalk/gitalk.min.js","hash":"28bdb33c9eb609c2f30d431df1a4cf8ca70bf841","modified":1675235563295},{"_id":"public/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1675235563295},{"_id":"public/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1675235563295},{"_id":"public/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1675235563295},{"_id":"public/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1675235563295},{"_id":"public/libs/jquery/jquery-2.2.0.min.js","hash":"5d7e5bbfa540f0e53bd599e4305e1a4e815b5dd1","modified":1675235563295},{"_id":"public/libs/materialize/materialize.min.css","hash":"4d46df5f22cbc24eefa76228c7ee308dc3585594","modified":1675235563295},{"_id":"public/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1675235563295},{"_id":"public/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1675235563295},{"_id":"public/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1675235563295},{"_id":"public/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1675235563295},{"_id":"public/libs/valine/Valine.min.js","hash":"4e34802ccbb59f1daa58a62241ff57f923e50600","modified":1675235563295},{"_id":"public/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1675235563295},{"_id":"public/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1675235563295},{"_id":"public/libs/awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1675235563295},{"_id":"public/libs/share/js/social-share.min.js","hash":"4df722bafde2c5d8faaace0d1f894798385a8793","modified":1675235563295},{"_id":"public/libs/share/js/jquery.share.min.js","hash":"16ce82901ca0e302cf47a35fb10f59009a5e7eb9","modified":1675235563295},{"_id":"public/libs/valine/av-min.js","hash":"2577e72b52b736d99649f9e95be8976d58563333","modified":1675235563295},{"_id":"public/medias/avatars/xuzhongyou.jpg","hash":"1db4dfaf23cf250f222a398326562d4170d3aaa1","modified":1675235563295},{"_id":"public/medias/banner/1.jpg","hash":"309f484b6e69e877de6a7fb847d66497d22bbd65","modified":1675235563295},{"_id":"public/medias/avatars/xiejiadong.jpg","hash":"f1a31f89426bd4dccdaba2170f4fc701336702e1","modified":1675235563295},{"_id":"public/medias/avatars/zhangting.jpg","hash":"10ee25ae3531f046a8bd3696c1cc8a16f0f25e1b","modified":1675235563295},{"_id":"public/medias/avatars/zzw.jpg","hash":"5d385b5732644b07b937a4919abc83cb95e14513","modified":1675235563295},{"_id":"public/medias/files/cv-zh.pdf","hash":"4f58778031b0a0e669e036b16639741e44fc2375","modified":1675235563295},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1675235563295},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1675235563295},{"_id":"public/2023/01/28/iOS-swift-自定义View之时间选择器/预约时间.png","hash":"062fd52e9f09f9a482ac57796c4bf8b347d7da86","modified":1675235563295},{"_id":"public/2023/01/28/iOS-swift-自定义View之时间选择器/预约日期.png","hash":"dedd941735c71b5f1bd3a1471e180c409b47ffe7","modified":1675235563295},{"_id":"public/2023/02/01/iOS-swift-混编Flutter/fluttererror1.png","hash":"144e586ff60c31f455e3edd250f8e3fc4950b5d0","modified":1675235563295},{"_id":"public/medias/contact.jpg","hash":"e7bb4c4cc6807f32018c9ce7eadf4946e1976b64","modified":1675235563295},{"_id":"public/medias/avatars/0xbird.png","hash":"f9d597dfcb49e1e2be06138b24028291f5638610","modified":1675235563295},{"_id":"public/medias/avatars/lyn-draw.jpg","hash":"837d5d5df4dcb086d2da114d0d85084b4ec18768","modified":1675235563295},{"_id":"public/medias/avatars/mashiro.jpg","hash":"250e911c16eeb6acb1e6214ad3e6a3d762850a8e","modified":1675235563295},{"_id":"public/medias/avatars/lzh.png","hash":"8ffcbf19d6b38b891dbe408d9a4e9513b56f247e","modified":1675235563295},{"_id":"public/medias/avatars/qianqian.png","hash":"fed254c4e7eb58ee22d647acb83f1d08f4508f8f","modified":1675235563295},{"_id":"public/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1675235563295},{"_id":"public/medias/banner/0.jpg","hash":"d4db93afdff4ce889dd8271bcf9e80eb3c0bf866","modified":1675235563295},{"_id":"public/medias/banner/2.jpg","hash":"280fa1c6493d7fdccfc18bd486446bacd9afe623","modified":1675235563295},{"_id":"public/medias/banner/6.jpg","hash":"4fcbc9dd8ec0316e9dd5bfd0caf86f1520b10b3f","modified":1675235563295},{"_id":"public/medias/featureimages/14.jpg","hash":"1c1063c29f827cf52eeef7ca8dc2d7e4efa31a76","modified":1675235563295},{"_id":"public/medias/featureimages/13.jpg","hash":"d8cc7a730668943dcb0776cfa240a0cf76826363","modified":1675235563295},{"_id":"public/medias/featureimages/22.jpg","hash":"02ec4566225102778c3837f08b24de02faf460a6","modified":1675235563295},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1675235563295},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1675235563295},{"_id":"public/libs/awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1675235563295},{"_id":"public/2023/02/01/iOS-swift-网络请求二次封装moya/moya1.png","hash":"b9eecb78564853a842883c98ca0b654dd7cd2661","modified":1675235563295},{"_id":"public/2023/02/01/iOS-swift-混编Flutter/fluttererror03.png","hash":"c2092c7ac8a47f5145a4891d0e64cda207ffa626","modified":1675235563295},{"_id":"public/medias/avatars/feibar.png","hash":"eceaefcbbca1bf49b582eaa649d311cf4fe69dd6","modified":1675235563295},{"_id":"public/medias/avatars/jitao.jpg","hash":"5934b9baccebccbc2be2ead5d84ad32dd41f9559","modified":1675235563295},{"_id":"public/medias/banner/4.jpg","hash":"a3cfdee2120195ab36b2fdd074d5558852e69297","modified":1675235563295},{"_id":"public/medias/avatars/zhangyi.jpg","hash":"c9130036aac9a7ac8d62e33550a9d64896cdc364","modified":1675235563295},{"_id":"public/medias/featureimages/12.jpg","hash":"c2892770fd5617418fd33d6f834879e05b2cdafd","modified":1675235563295},{"_id":"public/medias/music/avatars/daoshu.jpg","hash":"eee120fdf5ccbe86aa7d51826c4c773e76e6357f","modified":1675235563295},{"_id":"public/medias/avatars/jingjing.jpg","hash":"bfcab0139edb2509de984cb0a9b156879c355158","modified":1675235563295},{"_id":"public/medias/banner/5.jpg","hash":"6ddd1bcbb62a2d28c5be3b9acb7418849d60b2e7","modified":1675235563295},{"_id":"public/medias/banner/3.jpg","hash":"255aaa4375da855bd80b38cfcc253de892a9d4cf","modified":1675235563295},{"_id":"public/medias/featureimages/17.jpg","hash":"11a6de283124964370dbfaf0e74f2f1e9ac8394d","modified":1675235563295},{"_id":"public/medias/featureimages/2.jpg","hash":"1d8863277d744e1a18a2778ac26041bda5b03a98","modified":1675235563295},{"_id":"public/medias/featureimages/25.jpg","hash":"d0668539783fc615f14178644e486a6befb90c0c","modified":1675235563295},{"_id":"public/medias/featureimages/23.jpg","hash":"ee598933707f8bb98ecbf36925f24e8a1c4bd2d6","modified":1675235563295},{"_id":"public/medias/featureimages/3.jpg","hash":"ceb8e0c195a7fe7420334efa114e98cd0e1c6523","modified":1675235563295},{"_id":"public/medias/featureimages/28.jpg","hash":"c73036359640a67a8b17db7ba0e968c088957ab8","modified":1675235563295},{"_id":"public/2023/02/01/iOS-swift-混编Flutter/fluttererror2.png","hash":"19dc9ab0586378a2929bb69c318d6ec6db6d8de0","modified":1675235563295},{"_id":"public/medias/featureimages/10.jpg","hash":"66de48d963e7f221931e550b2442da0cd40cbaa8","modified":1675235563295},{"_id":"public/medias/featureimages/20.jpg","hash":"84ba9cf61045de789426eeb6333910266ce29b8c","modified":1675235563295},{"_id":"public/medias/featureimages/26.jpg","hash":"c66a4e7a2e670b63759a091f9428ee7f971d7b56","modified":1675235563295},{"_id":"public/medias/featureimages/27.jpg","hash":"7ea6f890cc59def8b1c9f393e4ae77cd16c79aad","modified":1675235563295},{"_id":"public/medias/featureimages/6.jpg","hash":"698fc46e97428d73c9d4e3d254e88b9b66fb38cd","modified":1675235563295},{"_id":"public/medias/featureimages/7.jpg","hash":"bd400da9123424afe7ba6c839be9ad7697c1245b","modified":1675235563295},{"_id":"public/medias/featureimages/11.jpg","hash":"2b30186c6d78ed76fa5f278be57290c1bd22c96a","modified":1675235563295},{"_id":"public/medias/featureimages/1.jpg","hash":"f1d720039d654d693c32150c06c78cfc3663b0b4","modified":1675235563295},{"_id":"public/medias/featureimages/16.jpg","hash":"0801e96a2f4cbd14b2ad44547e5ffbb23822e751","modified":1675235563295},{"_id":"public/medias/featureimages/18.jpg","hash":"c74ce6fa4eee122e147ec55532744f34a87ae2bf","modified":1675235563295},{"_id":"public/medias/featureimages/21.jpg","hash":"a77810cc2224446f5d4e1a857a8d480f21e81f83","modified":1675235563295},{"_id":"public/medias/featureimages/24.jpg","hash":"72bc68fb0673b84ab9f863d2979396cdc268a76c","modified":1675235563295},{"_id":"public/medias/featureimages/19.jpg","hash":"2a47d1123d9c4c6255b7b4817a582d2fa9aea808","modified":1675235563295},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1675235563295},{"_id":"public/medias/reward/wechat.png","hash":"98faed5b838aa003f660213be764152ee348f451","modified":1675235563295},{"_id":"public/medias/reward/alipay.png","hash":"98faed5b838aa003f660213be764152ee348f451","modified":1675235563295},{"_id":"public/2023/01/30/iOS-swift-数据库realm实践/realm2.png","hash":"9a893b602da7960abac88cbd75a913107d9ad58d","modified":1675235563295},{"_id":"public/2023/01/30/iOS-swift-数据库realm实践/realm1.png","hash":"8dea478526f67950e1d04d4f8ade74ab7cd64b2b","modified":1675235563295},{"_id":"public/2023/01/17/玩Android-Compose版本-项目分析/mine.jpeg","hash":"1f86a74843aaae7e80f61155a58a17da1320a614","modified":1675235563295},{"_id":"public/2023/01/31/iOS-swift-实现简易地图功能/map.png","hash":"93e267d80b97c93e48677b068f43c171ea851053","modified":1675235563295},{"_id":"public/medias/featureimages/8.jpg","hash":"f81e97edf705ab45b989b2b15d6a13c005ccaa32","modified":1675235563295},{"_id":"public/2023/01/17/玩Android-Compose版本-项目分析/首页.jpeg","hash":"c0541a828adb8491a51c67a7a11fe2d7ff057bad","modified":1675235563295},{"_id":"public/2023/01/29/iOS-swift-如何实现扫码功能/scan1.png","hash":"b06f374c408dd565191b743f0dcebfd4f6311100","modified":1675235563295},{"_id":"public/medias/featureimages/15.jpg","hash":"aff885598033614639944c7559b4849f883e2b34","modified":1675235563295},{"_id":"public/2023/01/27/iOS-swift-自定义View之四级地址/四级地址.gif","hash":"586e0fcfc20a5c0d870a0e5cacb85a2ec52a304e","modified":1675235563295},{"_id":"public/2023/01/29/iOS-swift-如何实现扫码功能/scan2.png","hash":"f77a75032260c4927cb3b674d190257fd558e208","modified":1675235563295},{"_id":"public/medias/featureimages/9.jpg","hash":"cd54b116609f5741cc7db0f7f49bf56ac356ddfb","modified":1675235563295},{"_id":"public/medias/featureimages/4.jpg","hash":"e06afe32a867f7a6e861618e0b5ac9d93cd71d05","modified":1675235563295},{"_id":"public/2023/01/17/玩Android-Compose版本-项目分析/闪屏页.gif","hash":"a76a77cf58af915878c1141c48d7825ef9334fe9","modified":1675235563295},{"_id":"public/baidu_urls.txt","hash":"6d8576101d88fcf7477deaaf0a9d97613057dfc5","modified":1675243882420},{"_id":"source/_posts/iOS-swift-打造TabLayout效果.md","hash":"4652860b0742d0d374c1413e85e65d5c4406723f","modified":1675243860499},{"_id":"source/_posts/iOS-swift-打造TabLayout效果/segment1.png","hash":"f671c195de1774e1531ba0311e55c03592fef431","modified":1675240800145},{"_id":"source/_posts/iOS-swift-打造TabLayout效果/page1.gif","hash":"77268a4d9068e1cec74c463d8f48b766455fbbd4","modified":1675240198332},{"_id":"public/2023/02/02/iOS-swift-打造TabLayout效果/index.html","hash":"22efdb3edde645ca35765065aacf191707f0a93c","modified":1675243882420},{"_id":"public/tags/TabLayout/index.html","hash":"3cbb15b60d524e2bffb05e7d908d86749e871e72","modified":1675243882420},{"_id":"public/2023/02/02/iOS-swift-打造TabLayout效果/segment1.png","hash":"f671c195de1774e1531ba0311e55c03592fef431","modified":1675243882420},{"_id":"public/2023/02/02/iOS-swift-打造TabLayout效果/page1.gif","hash":"77268a4d9068e1cec74c463d8f48b766455fbbd4","modified":1675243882420}],"Category":[{"name":"Android","_id":"cldlc01j90003jhv7c4753cp7"},{"name":"随笔","_id":"cldlc01je000jjhv76y883mdh"},{"name":"Flutter","_id":"cldlc01jf000pjhv74mmxg8b3"},{"name":"iOS","_id":"cldlc01jf000vjhv703m36l4r"}],"Data":[{"_id":"friends","data":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}]},{"_id":"musics","data":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}],"Page":[{"title":"404","date":"2019-07-19T08:41:10.000Z","type":"404","layout":"404","description":"你来到了没有知识的荒原 :(","_content":"","source":"404.md","raw":"---\ntitle: 404\ndate: 2019-07-19 16:41:10\ntype: \"404\"\nlayout: \"404\"\ndescription: \"你来到了没有知识的荒原 :(\"\n---\n","updated":"2023-02-01T06:06:16.183Z","path":"404.html","comments":1,"_id":"cldlc01j60000jhv7gglmf9nj","content":"","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":""},{"title":"about","date":"2023-01-11T08:41:10.000Z","type":"about","layout":"about","mathjax":true,"_content":"\n\n## CV\n<!-- [中文版](/medias/files/cv-zh.pdf)\n[English Version](/medias/files/cv-en.pdf) -->\n\n## 教育背景\n* <b>本科 广州大学 软件工程</b>\n2014/09 - 2018/06\n\n\n## 工作经历\n* <b>格力电子商务</b>\n2022/01 - 至今\n主要负责终端管理内部工具的开发，技术栈：Android,iOS,Flutter。\n\n* <b>魅族科技有限公司</b>\n2020/05 - 2022.1\n主要负责快应用相关开发，负责快应用引擎维护，封装快卡片sdk等。\n\n\n## 联系方式\n* <b>电子邮箱</b>\nJason211241203@gmail.com\n1211241203@qq.com\n\n\n<!-- ![](/medias/contact.jpg) -->","source":"about/index.md","raw":"---\ntitle: about\ndate: 2023-01-11 16:41:10\ntype: \"about\"\nlayout: \"about\"\nmathjax: true\n---\n\n\n## CV\n<!-- [中文版](/medias/files/cv-zh.pdf)\n[English Version](/medias/files/cv-en.pdf) -->\n\n## 教育背景\n* <b>本科 广州大学 软件工程</b>\n2014/09 - 2018/06\n\n\n## 工作经历\n* <b>格力电子商务</b>\n2022/01 - 至今\n主要负责终端管理内部工具的开发，技术栈：Android,iOS,Flutter。\n\n* <b>魅族科技有限公司</b>\n2020/05 - 2022.1\n主要负责快应用相关开发，负责快应用引擎维护，封装快卡片sdk等。\n\n\n## 联系方式\n* <b>电子邮箱</b>\nJason211241203@gmail.com\n1211241203@qq.com\n\n\n<!-- ![](/medias/contact.jpg) -->","updated":"2023-02-01T06:13:34.882Z","path":"about/index.html","comments":1,"_id":"cldlc01j90002jhv7b99xc1mb","content":"<h2 id=\"CV\"><a href=\"#CV\" class=\"headerlink\" title=\"CV\"></a>CV</h2><!-- [中文版](/medias/files/cv-zh.pdf)\n[English Version](/medias/files/cv-en.pdf) -->\n\n<h2 id=\"教育背景\"><a href=\"#教育背景\" class=\"headerlink\" title=\"教育背景\"></a>教育背景</h2><ul>\n<li><b>本科 广州大学 软件工程</b><br>2014&#x2F;09 - 2018&#x2F;06</li>\n</ul>\n<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2><ul>\n<li><p><b>格力电子商务</b><br>2022&#x2F;01 - 至今<br>主要负责终端管理内部工具的开发，技术栈：Android,iOS,Flutter。</p>\n</li>\n<li><p><b>魅族科技有限公司</b><br>2020&#x2F;05 - 2022.1<br>主要负责快应用相关开发，负责快应用引擎维护，封装快卡片sdk等。</p>\n</li>\n</ul>\n<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><ul>\n<li><b>电子邮箱</b><br><a href=\"mailto:&#x4a;&#x61;&#x73;&#x6f;&#x6e;&#x32;&#49;&#49;&#50;&#52;&#x31;&#50;&#x30;&#x33;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;\">&#x4a;&#x61;&#x73;&#x6f;&#x6e;&#x32;&#49;&#49;&#50;&#52;&#x31;&#50;&#x30;&#x33;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;</a><br><a href=\"mailto:&#49;&#50;&#x31;&#x31;&#50;&#x34;&#49;&#x32;&#x30;&#x33;&#64;&#113;&#113;&#x2e;&#x63;&#x6f;&#109;\">&#49;&#50;&#x31;&#x31;&#50;&#x34;&#49;&#x32;&#x30;&#x33;&#64;&#113;&#113;&#x2e;&#x63;&#x6f;&#109;</a></li>\n</ul>\n<!-- ![](/medias/contact.jpg) -->","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"CV\"><a href=\"#CV\" class=\"headerlink\" title=\"CV\"></a>CV</h2><!-- [中文版](/medias/files/cv-zh.pdf)\n[English Version](/medias/files/cv-en.pdf) -->\n\n<h2 id=\"教育背景\"><a href=\"#教育背景\" class=\"headerlink\" title=\"教育背景\"></a>教育背景</h2><ul>\n<li><b>本科 广州大学 软件工程</b><br>2014&#x2F;09 - 2018&#x2F;06</li>\n</ul>\n<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2><ul>\n<li><p><b>格力电子商务</b><br>2022&#x2F;01 - 至今<br>主要负责终端管理内部工具的开发，技术栈：Android,iOS,Flutter。</p>\n</li>\n<li><p><b>魅族科技有限公司</b><br>2020&#x2F;05 - 2022.1<br>主要负责快应用相关开发，负责快应用引擎维护，封装快卡片sdk等。</p>\n</li>\n</ul>\n<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><ul>\n<li><b>电子邮箱</b><br><a href=\"mailto:&#x4a;&#x61;&#x73;&#x6f;&#x6e;&#x32;&#49;&#49;&#50;&#52;&#x31;&#50;&#x30;&#x33;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;\">&#x4a;&#x61;&#x73;&#x6f;&#x6e;&#x32;&#49;&#49;&#50;&#52;&#x31;&#50;&#x30;&#x33;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;</a><br><a href=\"mailto:&#49;&#50;&#x31;&#x31;&#50;&#x34;&#49;&#x32;&#x30;&#x33;&#64;&#113;&#113;&#x2e;&#x63;&#x6f;&#109;\">&#49;&#50;&#x31;&#x31;&#50;&#x34;&#49;&#x32;&#x30;&#x33;&#64;&#113;&#113;&#x2e;&#x63;&#x6f;&#109;</a></li>\n</ul>\n<!-- ![](/medias/contact.jpg) -->"},{"title":"contact","date":"2023-01-11T09:17:02.000Z","type":"contact","layout":"contact","_content":"\n# 欢迎留言\n大家有任何问题，都可以在评论区给我留言。\n\n我很忙啦，如果不是很麻烦的问题就直接在评论区留言啦。\n\n# 友链交换\n想要交换友链的小伙伴，欢迎在评论区留言，留言格式：\n* **名称：**你的博客名称\n* **地址：**你的博客地址\n* **简介：**一句话简介\n* **头像：**你的头像地址\n","source":"contact/index.md","raw":"---\ntitle: contact\ndate: 2023-01-11 17:17:02\ntype: \"contact\"\nlayout: \"contact\"\n---\n\n# 欢迎留言\n大家有任何问题，都可以在评论区给我留言。\n\n我很忙啦，如果不是很麻烦的问题就直接在评论区留言啦。\n\n# 友链交换\n想要交换友链的小伙伴，欢迎在评论区留言，留言格式：\n* **名称：**你的博客名称\n* **地址：**你的博客地址\n* **简介：**一句话简介\n* **头像：**你的头像地址\n","updated":"2023-02-01T06:06:16.249Z","path":"contact/index.html","comments":1,"_id":"cldlc01ja0005jhv7bf8wcd2h","content":"<h1 id=\"欢迎留言\"><a href=\"#欢迎留言\" class=\"headerlink\" title=\"欢迎留言\"></a>欢迎留言</h1><p>大家有任何问题，都可以在评论区给我留言。</p>\n<p>我很忙啦，如果不是很麻烦的问题就直接在评论区留言啦。</p>\n<h1 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h1><p>想要交换友链的小伙伴，欢迎在评论区留言，留言格式：</p>\n<ul>\n<li><strong>名称：</strong>你的博客名称</li>\n<li><strong>地址：</strong>你的博客地址</li>\n<li><strong>简介：</strong>一句话简介</li>\n<li><strong>头像：</strong>你的头像地址</li>\n</ul>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h1 id=\"欢迎留言\"><a href=\"#欢迎留言\" class=\"headerlink\" title=\"欢迎留言\"></a>欢迎留言</h1><p>大家有任何问题，都可以在评论区给我留言。</p>\n<p>我很忙啦，如果不是很麻烦的问题就直接在评论区留言啦。</p>\n<h1 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h1><p>想要交换友链的小伙伴，欢迎在评论区留言，留言格式：</p>\n<ul>\n<li><strong>名称：</strong>你的博客名称</li>\n<li><strong>地址：</strong>你的博客地址</li>\n<li><strong>简介：</strong>一句话简介</li>\n<li><strong>头像：</strong>你的头像地址</li>\n</ul>\n"},{"title":"categories","date":"2023-01-11T08:39:20.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2023-01-11 16:39:20\ntype: \"categories\"\nlayout: \"categories\"\n---","updated":"2023-02-01T06:06:16.249Z","path":"categories/index.html","comments":1,"_id":"cldlc01ja0006jhv77jg51lyz","content":"","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":""},{"title":"archives","date":"2023-01-11T08:39:20.000Z","type":"archives","layout":"archives","_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2023-01-11 16:39:20\ntype: \"archives\"\nlayout: \"archives\"\n---","updated":"2023-02-01T06:06:16.249Z","path":"archives/index.html","comments":1,"_id":"cldlc01ja0007jhv7cbzwasek","content":"","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":""},{"title":"friends","date":"2023-01-11T08:42:10.000Z","type":"friends","layout":"friends","_content":"\n# 友链交换\n想要交换友链的小伙伴，欢迎在留言板留言，留言格式：\n* **名称：**你的博客名称\n* **地址：**你的博客地址\n* **简介：**一句话简介\n* **头像：**你的头像地址\n\n\n","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2023-01-11 16:42:10\ntype: \"friends\"\nlayout: \"friends\"\n---\n\n# 友链交换\n想要交换友链的小伙伴，欢迎在留言板留言，留言格式：\n* **名称：**你的博客名称\n* **地址：**你的博客地址\n* **简介：**一句话简介\n* **头像：**你的头像地址\n\n\n","updated":"2023-02-01T06:06:16.250Z","path":"friends/index.html","comments":1,"_id":"cldlc01ja0009jhv7e4fu27be","content":"<h1 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h1><p>想要交换友链的小伙伴，欢迎在留言板留言，留言格式：</p>\n<ul>\n<li><strong>名称：</strong>你的博客名称</li>\n<li><strong>地址：</strong>你的博客地址</li>\n<li><strong>简介：</strong>一句话简介</li>\n<li><strong>头像：</strong>你的头像地址</li>\n</ul>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h1 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h1><p>想要交换友链的小伙伴，欢迎在留言板留言，留言格式：</p>\n<ul>\n<li><strong>名称：</strong>你的博客名称</li>\n<li><strong>地址：</strong>你的博客地址</li>\n<li><strong>简介：</strong>一句话简介</li>\n<li><strong>头像：</strong>你的头像地址</li>\n</ul>\n"},{"title":"tags","date":"2023-01-11T08:40:27.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2023-01-11 16:40:27\ntype: \"tags\"\nlayout: \"tags\"\n---","updated":"2023-02-01T06:06:16.250Z","path":"tags/index.html","comments":1,"_id":"cldlc01jc000cjhv7abg81304","content":"","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":""}],"Post":[{"title":"Android google samples nowinandroid app模块流程分析","date":"2023-01-15T03:53:19.000Z","top":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n> googe samples之 nowinandroid项目地址：[https://github.com/android/nowinandroid](https://github.com/android/nowinandroid)\n\n### 1.app模块build.gradle文件配置\n```Groovy\nplugins {\n    id(\"nowinandroid.android.application\")\n    id(\"nowinandroid.android.application.compose\")\n    id(\"nowinandroid.android.application.jacoco\")\n    id(\"nowinandroid.android.hilt\")\n    id(\"jacoco\")\n    id(\"nowinandroid.firebase-perf\")\n}\n```\n引入了application插件，compose插件，jacoco插件，hilt插件，firebase插件\n\n依赖项：\n```Groovy\n    implementation(project(\":feature:interests\"))\n    implementation(project(\":feature:foryou\"))\n    implementation(project(\":feature:bookmarks\"))\n    implementation(project(\":feature:topic\"))\n    implementation(project(\":feature:settings\"))\n\n    implementation(project(\":core:common\"))\n    implementation(project(\":core:ui\"))\n    implementation(project(\":core:designsystem\"))\n    implementation(project(\":core:data\"))\n    implementation(project(\":core:model\"))\n\n    implementation(project(\":sync:work\"))\n```\nfeature文件夹下是app模块的界面上拆分组件。\n如feature_interests 就是兴趣tab\nfeature_foryou 就是第一个tab\nfeature_bookmarks 是书签模块\n等等\n\n下面的core就是核心模块了，有通用组件，ui组件，设计系统，数据区\n\n然后sync_work是一些工具module了。\n\n### 2.清单文件\n```xml\n    <application\n        android:name=\".NiaApplication\"\n        android:allowBackup=\"true\"\n        android:enableOnBackInvokedCallback=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Nia.Splash\">\n<!--        Profileable 是 Android 10 中引入的清单配置，可用于 CPU 和内存分析任务。使用 profileable 标志而不是 debuggable 标志具有降低性能开销的关键优势；-->\n        <profileable android:shell=\"true\" tools:targetApi=\"q\" />\n\n        <activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n\n```\n这里很简单，就一个Application自定义的，一个首页，说明这个App就一个Activity。\n这里引入了一个profileable标签，是Android10后引入的，可以用于CPU和内存分析任务。\n\n### 3.自定义Application\n这里App开始启动了。\n首先是用了一个HiltAndroidApp的注解。\n这个是类似Dragger的依赖注解框架，这里要求在Application用这个注解。\n关于Hilt用法可参考：[https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn](https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn)\n\n这里在Application里面初始化了一个东西：\n`Sync.initialize(context = this)`\n作用就是初始化Sync三方库。\n\n里面是这样走的：\n```Kotlin\n  AppInitializer.getInstance(context)\n            .initializeComponent(SyncInitializer::class.java)\n```\nAppInitializer是google的Jetpack下的startup中的类成员，关于这个用法可以参考下郭霖的博客：[https://blog.csdn.net/guolin_blog/article/details/108026357](https://blog.csdn.net/guolin_blog/article/details/108026357)\n\n为什么要引入这个同步的库呢？\n/**\n * Registers work to sync the data layer periodically on app startup.\n * 初始化三方库 这里是WorkManager，主要用于\n * Android出于设备电量的考虑，为开发者提供了WorkManager，旨在将一些不需要及时完成的任务交给它来完成。\n * 虽然WorkManager宣称，能够保证任务得到执行，但我在真实设备中，发现应用程序彻底退出与重启设备，任务都没有再次执行。\n * 查阅了相关资料，发现这应该与系统有关系。我们前面也提到了，WorkManager会根据系统的版本，\n * 决定采用JobScheduler或是AlarmManager+Broadcast Receivers来完成任务。\n * 但是这些API很可能会受到OEM系统的影响。比如，假设某个系统不允许AlarmManager自动唤起，那么WorkManager很可能就无法正常使用。\n */\n \n ### 4.MainActivity 参数定义\n Application走完，就到了Activity了。\n 首先是两个注解：\n\n1.  @OptIn(ExperimentalMaterial3WindowSizeClassApi::class)\n Opt-in 是 Kotlin 标准库中的一个方法，用于声明使用某些 API 需要明确的同意。\n  该功能可以让开发者告知 API 使用者使用某些 API 需要一些特定的条件，如果使用者已经知晓则需要明确声明依旧使用（Opt-in）才能继续使用该 API。\n  例如，某些 API 尚处于测试阶段，未来可能会发生变化；亦或是我前言中提到的场景，都非常适合使用该方法。\n  如果我们声明了某个方法（functiuon）或类(class)需要 Opt-in ，则IDE或编译器会发出警告，要求使用者明确标注需要使用（Opt-in）。\n  参考文档：[https://juejin.cn/post/7157950373250990093](https://juejin.cn/post/7157950373250990093)\n\n2. @AndroidEntryPoint\n在要使用依赖注入的类上方添加@AndroidEntryPoint注解\n参考文档：[https://www.jianshu.com/p/22a36660a656](https://www.jianshu.com/p/22a36660a656)\n\n然后声明了两个注入的变量：\n```Kotlin\n/**\n     * Lazily inject [JankStats], which is used to track jank throughout the app.\n     * JankStats 是首个专为在用户设备上检测及报告应用的性能问题而构建的 AndroidX 库。\n     * JankStats 是占用空间相对较小的 API，主要有三大目标: 捕获每帧的性能信息、在用户设备 (不仅是开发设备) 上运行、以及在应用出现性能问题时启用检测，并报告所发生的情况\n     *\n     * 在Dagger中Lazy可以将要注入的依赖项转变为懒加载模式，这样注入的依赖项，只有在需要使用时，\n     * 才会调用对应的依赖生成方法。懒加载的实现很简单，只需要在注入位置将依赖项的类型设置为Lazy接口的类型参数即可。\n     *\n     * 构造函数在di 文件夹下的 JankStatsModule 下\n     */\n    @Inject\n    lateinit var lazyStats: dagger.Lazy<JankStats>\n\n    /**\n     * 自定义网络监视器 这个是一个接口 应该也是测试用的\n     */\n    @Inject\n    lateinit var networkMonitor: NetworkMonitor\n\n```\n \n 关于lazyStats怎么初始化的？在项目di文件夹下有个JankStatsModule\n \n```Kotlin\n/**\n * 这里的目标是生产一个JankStats对象\n *\n * 怎么生产呢，需要2个构造参数\n * 1.JankStats.OnFrameListener\n * 2.Window\n *\n * window需要依赖activity，这里就需要 ActivityComponent了\n * 这个JankStats对象的生命周期设定为Activity级别\n */\n@Module\n@InstallIn(ActivityComponent::class)\nobject JankStatsModule {\n    @Provides\n    fun providesOnFrameListener(): JankStats.OnFrameListener {\n        return JankStats.OnFrameListener { frameData ->\n            // Make sure to only log janky frames.\n            if (frameData.isJank) {\n                // We're currently logging this but would better report it to a backend.\n                Log.v(\"NiA Jank\", frameData.toString())\n            }\n        }\n    }\n\n    @Provides\n    fun providesWindow(activity: Activity): Window {\n        return activity.window\n    }\n\n    @Provides\n    fun providesJankStats(\n        window: Window,\n        frameListener: JankStats.OnFrameListener\n    ): JankStats {\n        return JankStats.createAndTrack(window, frameListener)\n    }\n}\n```\n这里生产了  一个JankStats对象。\n\n关于网络监视器如何初始化的呢？\n这个网络监视器是一个接口来的：\n```Kotlin\n/**\n * Utility for reporting app connectivity status\n */\ninterface NetworkMonitor {\n    val isOnline: Flow<Boolean>\n}\n\n```\n一直没找到如何实例化的地方。\n不过再其它模块，core下的data.di文件夹下发现了另外一个DataModule下有如下代码：\n```Kotlin\n\n    @Binds\n    fun bindsNetworkMonitor(\n        networkMonitor: ConnectivityManagerNetworkMonitor\n    ): NetworkMonitor\n```\n这里貌似可以生产一个NetworkMonitor对象。\n但怎么关联起来的呢？\n\n这个我确实不清楚hilt的用法，而且这个DataModule理应需要在Application配置，但也没找到相关依赖，可能hilt对加上这种注解能全局自动生成依赖代码也说不定。反正这里的网络监视器应该就是这个ConnectivityManagerNetworkMonitor 主要逻辑也在这里。\n\n第三个变量是viewModel\n` val viewModel: MainActivityViewModel by viewModels()`\n这个用法类似：\n`ViewModelProvider(this).get(MainActivityViewModel::class.java)`\n\n\n### 5.首页生命周期-onCreate\n继续走，第一行是 适配闪屏页 installSplashScreen()\n关于闪屏页可参考文档：[https://blog.csdn.net/guolin_blog/article/details/120275319](https://blog.csdn.net/guolin_blog/article/details/120275319)（郭霖）\n\n然后这里监听了一个密封接口中的 Loading 状态，\n密封接口定义如下：\n```Kotlin\n/**\n * 首页ui 状态的密封类，有加载中和成功的状态\n * 密封接口 类似枚举类型，说明有Loading状态和成功状态\n * 表示受限制的类层次结构\n */\nsealed interface MainActivityUiState {\n    object Loading : MainActivityUiState\n    data class Success(val userData: UserData) : MainActivityUiState\n}\n```\n很明显这里Loading实现了这个接口，Success也实现了这个接口。\n\n在onCreate监听了这个Loading类：\n```Kotlin\n\n        /**\n         * mutableStateOf 表明某个变量是有状态的，对变量进行监听，当状态改变时，触发重绘。\n         * remember --- 记录变量的值，使得下次使用改变量时不进行初始化。\n         * 使用 remember 存储对象的可组合项会创建内部状态，使该可组合项有状态。\n         * remember 会为函数提供存储空间，将 remember 计算的值储存，当 remember 的键改变的时候会进行重新计算值并储存。\n         * rememberSaveable --- 在这里顺带提一下,rememberSaveable 可以在重组后保持状态,也可以在重新创建 activity 和进程后保持状态。\n         */\n        var uiState: MainActivityUiState by mutableStateOf(Loading)\n```\n\n然后开启一个携程，拿用户数据：\n```Kotlin\n // Activity生命周期内使用携程\n        lifecycleScope.launch {\n            // Lifecycle.State.STARTED: 表示只有在Activity处于Started状态的情况下，协程中的代码才会执行。\n            lifecycle.repeatOnLifecycle(Lifecycle.State.STARTED) {\n                viewModel.uiState\n                    .onEach {\n                        uiState = it\n                    }\n                    .collect() // 走collect方法才代表执行携程\n            }\n        }\n```\n拿到数据后，才回去更新uiState对象。\n\n就是说uiState会有上面密封接口定义的两种类型。\n\n当监听到uiState变化后会走：\n```Kotlin\n /**\n         * 如果网络请求正在请求loading状态，就还是显示闪屏，如果拿到数据了就不需要闪屏了\n         */\n        splashScreen.setKeepOnScreenCondition {\n            when (uiState) {\n                Loading -> true\n                is Success -> false\n            }\n        }\n```\n闪屏会去除掉。\n\n下面开启沉浸式状态栏：\n```Kotlin\n  /**\n         * 第二参数decorFitsSystemWindows表示是否沉浸，false 表示沉浸，true表示不沉浸\n         */\n        WindowCompat.setDecorFitsSystemWindows(window, false)\n```\n\n然后就是内容区，compose设置内容区了\n一个setContent的函数，太长了，就不全部贴图，挨个分析。\n\n1.首先获取一个systemUIController\n```Kotlin\n /**\n             * 开发者若想在 Compose 布局中控制 System UI，就必须获取 SystemUiController 对象。\n             * 通过该库提供 rememberSystemUiController 函数，开发者可以获取当前操作系统（目前仅支持 Android 系统）的  SystemUiController 对象。\n             */\n            val systemUiController = rememberSystemUiController()\n```\n\n2.是否使用深色主题，用户可以自己选\n```Kotlin\n /**\n             * 是否使用深色主题，入参当前ui状态\n             */\n            val darkTheme = shouldUseDarkTheme(uiState)\n            \n```\n\n内部实现：\n```Kotlin\n/**\n * Returns `true` if dark theme should be used, as a function of the [uiState] and the\n * current system context.\n * 调用@Composable 函数的函数必须用@Composable 注解标记\n */\n@Composable\nprivate fun shouldUseDarkTheme(\n    uiState: MainActivityUiState,\n): Boolean = when (uiState) {\n    /**\n     * isSystemInDarkTheme 根据系统来，加载中状态\n     */\n    Loading -> isSystemInDarkTheme()\n    is Success -> when (uiState.userData.darkThemeConfig) {\n        /**\n         * 成功状态下，根据用户配置的数据来展示，如果跟随系统那就跟随，如果用户主动设置了某一种，那就成功时选择\n         */\n        DarkThemeConfig.FOLLOW_SYSTEM -> isSystemInDarkTheme()\n        DarkThemeConfig.LIGHT -> false\n        DarkThemeConfig.DARK -> true\n    }\n}\n```\n\n然后开启一个DisposableEffect来关联上面这两个对象：\n```Kotlin\n  /**\n             * disposable，顾名思义，这就是一个自带清理作用的Effect\n             */\n            DisposableEffect(systemUiController, darkTheme) {\n                // 否与导航栏图标+内容是否“黑暗\"\n                systemUiController.systemBarsDarkContentEnabled = !darkTheme\n                onDispose {}\n            }\n```\n\n最后，开始设置App主题了：\n```Kotlin\n  /**\n             * 主题配置，是否暗色，判断用户是否有自己选择\n             * 是否用Android主题\n             * 下面这些代码才是内容区的布局，上面MainActivityUiState 这个只是拿用户的持久化数据，槽了\n             */\n            NiaTheme(\n                darkTheme = darkTheme,\n                androidTheme = shouldUseAndroidTheme(uiState)\n            ) {\n                // NiaApp是一个闭包，作为第三个参数\n                NiaApp(\n                    /**\n                     * 窗口大小类，获取一个WindowSizeClass 这个实例\n                     */\n                    windowSizeClass = calculateWindowSizeClass(this),\n                    /**\n                     * 网络监视器，前面注入的\n                     */\n                    networkMonitor = networkMonitor,\n                )\n            }\n```\n\n里面的闭包 NiaApp也就是开启了我们的App。\n\n### 6.首页其它生命周期\n```Kotlin\n  override fun onResume() {\n        super.onResume()\n        /**\n         * 跟踪性能\n         */\n        lazyStats.get().isTrackingEnabled = true\n    }\n\n    override fun onPause() {\n        super.onPause()\n        /**\n         * 去除跟踪\n         */\n        lazyStats.get().isTrackingEnabled = false\n    }\n```\n\nMainActivity内容就这么多了，非常指简洁。\n布局交给NiaApp类处理了。\n\n其它对象初始化交给hilt处理了。\n\n主要就只开了个协程获取用户数据，而且优化闪屏页和loading的显示。\n\n### 7.NiaTheme主题设置\n先是主题颜色：\n```Kotlin\n // 主题颜色\n    val colorScheme = when {\n        // 判断当前 android主题是暗色还是浅色\n        androidTheme -> if (darkTheme) DarkAndroidColorScheme else LightAndroidColorScheme\n        // 没有禁用动态主题并且支持动态主题\n        !disableDynamicTheming && supportsDynamicTheming() -> {\n            val context = LocalContext.current\n            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)\n        }\n        // 其它情况\n        else -> if (darkTheme) DarkDefaultColorScheme else LightDefaultColorScheme\n    }\n```\n\n渐变色:\n```Kotlin\n    // Gradient colors 渐变色\n    // 空渐变色\n    val emptyGradientColors = GradientColors(container = colorScheme.surfaceColorAtElevation(2.dp))\n    // 默认渐变色\n    val defaultGradientColors = GradientColors(\n        top = colorScheme.inverseOnSurface,\n        bottom = colorScheme.primaryContainer,\n        container = colorScheme.surface\n    )\n    // 渐变色\n    val gradientColors = when {\n        androidTheme -> if (darkTheme) DarkAndroidGradientColors else LightAndroidGradientColors\n        !disableDynamicTheming && supportsDynamicTheming() -> emptyGradientColors\n        else -> defaultGradientColors\n    }\n```\n\n最终设置到MaterialTheme里面：\n```Kotlin\n   // Composition locals\n    CompositionLocalProvider(\n        LocalGradientColors provides gradientColors,\n        LocalBackgroundTheme provides backgroundTheme\n    ) {\n        MaterialTheme(\n            colorScheme = colorScheme,\n            typography = NiaTypography,\n            content = content\n        )\n    }\n```\n\n### 8.NiaApp状态定义\n\n首先创建一个NiaApp实例。\n入参：窗口大小类，网络监视器\n```Kotlin\n NiaApp(\n                    /**\n                     * 窗口大小类，获取一个WindowSizeClass 这个实例\n                     */\n                    windowSizeClass = calculateWindowSizeClass(this),\n                    /**\n                     * 网络监视器，前面注入的\n                     */\n                    networkMonitor = networkMonitor,\n                )\n```\n\n这里是App首页ui样式。\n\n这里用到的状态作为第三个参数，作为app状态记录。\n\n函数定义如下：\n```Kotlin\n@OptIn(\n    ExperimentalMaterial3Api::class,\n    ExperimentalLayoutApi::class,\n    ExperimentalComposeUiApi::class,\n    ExperimentalLifecycleComposeApi::class\n)\n@Composable\nfun NiaApp(\n    windowSizeClass: WindowSizeClass,\n    networkMonitor: NetworkMonitor,\n    /**\n     * app状态记录\n     */\n    appState: NiaAppState = rememberNiaAppState(\n        networkMonitor = networkMonitor,\n        windowSizeClass = windowSizeClass\n    ),\n) \n```\n这里第三个参数已经默认实现了。\n\n就是用于app状态记录，调用了一个自定义的rememberNiaAppState方法。\n```Kotlin\n@Composable\nfun rememberNiaAppState(\n    windowSizeClass: WindowSizeClass,\n    networkMonitor: NetworkMonitor,\n    coroutineScope: CoroutineScope = rememberCoroutineScope(),\n    /**\n     * 导航控制器\n     */\n    navController: NavHostController = rememberNavController()\n): NiaAppState {\n    NavigationTrackingSideEffect(navController)\n    /**\n     * remember 里面参数可以任意，闭包里面的东西，就是remember返回的东西\n     */\n    return remember(navController, coroutineScope, windowSizeClass, networkMonitor) {\n        NiaAppState(navController, coroutineScope, windowSizeClass, networkMonitor)\n    }\n}\n```\n这里默认实现了协程作用域，导航控制器，需要返回一个NiaAppState变量。\n\n这里通过remember闭包来返回这个变量。\n\n这个NiaAppState定义如下：\n```Kotlin\n/**\n * 主要用于类似LiveData保存的数据\n * App状态记录，需要传入导航控制器，携程作用范围，window窗口大小\n */\n@Stable\nclass NiaAppState(\n    val navController: NavHostController,\n    val coroutineScope: CoroutineScope,\n    val windowSizeClass: WindowSizeClass,\n    networkMonitor: NetworkMonitor,\n) {\n```\n类似LiveData，保存了首页必要的一些数据。\n\n```Kotlin\n /**\n     * 当前在那个tab\n     */\n    val currentDestination: NavDestination?\n        @Composable get() = navController\n            .currentBackStackEntryAsState().value?.destination\n```\n\n```Kotlin\n /**\n     * 通过在哪个tab，决定用哪个枚举类， TopLevelDestination是自己定义的枚举类\n     */\n    val currentTopLevelDestination: TopLevelDestination?\n        @Composable get() = when (currentDestination?.route) {\n            forYouNavigationRoute -> FOR_YOU\n            bookmarksRoute -> BOOKMARKS\n            interestsRoute -> INTERESTS\n            else -> null\n        }\n```\n\n```Kotlin\n /**\n     * 是否展示设置弹框\n     */\n    var shouldShowSettingsDialog by mutableStateOf(false)\n        private set\n```\n\n```Kotlin\n /**\n     * 是否展示底部bar\n     */\n    val shouldShowBottomBar: Boolean\n        get() = windowSizeClass.widthSizeClass == WindowWidthSizeClass.Compact ||\n            windowSizeClass.heightSizeClass == WindowHeightSizeClass.Compact\n```\n\n```Kotlin\n  /**\n     * 是否展示水平左侧导航\n     */\n    val shouldShowNavRail: Boolean\n        get() = !shouldShowBottomBar\n```\n\n```Kotlin\n /**\n     * 监控网络，是否断网\n     */\n    val isOffline = networkMonitor.isOnline\n        .map(Boolean::not)\n        .stateIn(\n            scope = coroutineScope,\n            started = SharingStarted.WhileSubscribed(5_000),\n            initialValue = false\n        )\n\n```\n\n```Kotlin\n   /**\n     * 这里是一个枚举类，表示底部tab集合\n     * Map of top level destinations to be used in the TopBar, BottomBar and NavRail. The key is the\n     * route.\n     */\n    val topLevelDestinations: List<TopLevelDestination> = TopLevelDestination.values().asList()\n```\n\n```Kotlin\n /**\n     * 点击tab事件传递\n     *\n     * @param topLevelDestination: The destination the app needs to navigate to.\n     */\n    fun navigateToTopLevelDestination(topLevelDestination: TopLevelDestination) {\n        trace(\"Navigation: ${topLevelDestination.name}\") {\n            val topLevelNavOptions = navOptions {\n                // Pop up to the start destination of the graph to\n                // avoid building up a large stack of destinations\n                // on the back stack as users select items\n                popUpTo(navController.graph.findStartDestination().id) {\n                    saveState = true\n                }\n                // Avoid multiple copies of the same destination when\n                // reselecting the same item\n                launchSingleTop = true\n                // Restore state when reselecting a previously selected item\n                restoreState = true\n            }\n\n            when (topLevelDestination) {\n                FOR_YOU -> navController.navigateToForYou(topLevelNavOptions)\n                BOOKMARKS -> navController.navigateToBookmarks(topLevelNavOptions)\n                INTERESTS -> navController.navigateToInterestsGraph(topLevelNavOptions)\n            }\n        }\n    }\n\n```\n\n然后定义了一些方法：\n```Kotlin\n /**\n     * 返回点击\n     */\n    fun onBackClick() {\n        navController.popBackStack()\n    }\n\n    /**\n     * 改变设置弹框状态\n     */\n    fun setShowSettingsDialog(shouldShow: Boolean) {\n        shouldShowSettingsDialog = shouldShow\n    }\n```\n\n### 9.NiaApp内容区\n\nApp背景色\n```Kotlin\n@Composable\nfun NiaBackground(\n    modifier: Modifier = Modifier,\n    content: @Composable () -> Unit\n) {\n    val color = LocalBackgroundTheme.current.color\n    val tonalElevation = LocalBackgroundTheme.current.tonalElevation\n    Surface(\n        color = if (color == Color.Unspecified) Color.Transparent else color,\n        tonalElevation = if (tonalElevation == Dp.Unspecified) 0.dp else tonalElevation,\n        modifier = modifier.fillMaxSize(),\n    ) {\n        CompositionLocalProvider(LocalAbsoluteTonalElevation provides 0.dp) {\n            content()\n        }\n    }\n}\n```\n\n数据源使用 LocalBackgroundTheme.current.color\n\n内容区继续渐变背景：\n```Kotlin\n@Composable\nfun NiaGradientBackground(\n    modifier: Modifier = Modifier,\n    gradientColors: GradientColors = LocalGradientColors.current,\n    content: @Composable () -> Unit\n) {\n    val currentTopColor by rememberUpdatedState(gradientColors.top)\n    val currentBottomColor by rememberUpdatedState(gradientColors.bottom)\n    Surface(\n        color = if (gradientColors.container == Color.Unspecified) {\n            Color.Transparent\n        } else {\n            gradientColors.container\n        },\n        modifier = modifier.fillMaxSize()\n    ) {\n        Box(\n            Modifier\n                .fillMaxSize()\n                .drawWithCache {\n                    // Compute the start and end coordinates such that the gradients are angled 11.06\n                    // degrees off the vertical axis\n                    val offset = size.height * tan(\n                        Math\n                            .toRadians(11.06)\n                            .toFloat()\n                    )\n\n                    val start = Offset(size.width / 2 + offset / 2, 0f)\n                    val end = Offset(size.width / 2 - offset / 2, size.height)\n\n                    // Create the top gradient that fades out after the halfway point vertically\n                    val topGradient = Brush.linearGradient(\n                        0f to if (currentTopColor == Color.Unspecified) {\n                            Color.Transparent\n                        } else {\n                            currentTopColor\n                        },\n                        0.724f to Color.Transparent,\n                        start = start,\n                        end = end,\n                    )\n                    // Create the bottom gradient that fades in before the halfway point vertically\n                    val bottomGradient = Brush.linearGradient(\n                        0.2552f to Color.Transparent,\n                        1f to if (currentBottomColor == Color.Unspecified) {\n                            Color.Transparent\n                        } else {\n                            currentBottomColor\n                        },\n                        start = start,\n                        end = end,\n                    )\n\n                    onDrawBehind {\n                        // There is overlap here, so order is important\n                        drawRect(topGradient)\n                        drawRect(bottomGradient)\n                    }\n                }\n        ) {\n            content()\n        }\n    }\n}\n```\n这里在上面0到0.724区间设置了topGradient\n在0.2552f到1设置了 bottomGradient\n\n### 10.业务内容区\n\n```Kotlin\n   // 记录下snackbar状态，后续可能会刷新\n            val snackbarHostState = remember { SnackbarHostState() }\n```\n这个用于网络监听，如果没有网络，底部会常驻一个snackbar\n\n```Kotlin\n            // 是否离线\n            val isOffline by appState.isOffline.collectAsStateWithLifecycle()\n\n            // If user is not connected to the internet show a snack bar to inform them.\n            // 如果没有网络，底部展示Snackbar\n            val notConnectedMessage = stringResource(R.string.not_connected)\n            // 这个是Compose里面的launch，compose开启携程的方法\n            LaunchedEffect(isOffline) {\n                if (isOffline) snackbarHostState.showSnackbar(\n                    message = notConnectedMessage,\n                    duration = Indefinite\n                )\n            }\n```\n\nKotlin\n            // 是否应该展示设置弹框，当点击右上角设置后，会弹出设置弹框\n            if (appState.shouldShowSettingsDialog) {\n                SettingsDialog(\n                    onDismiss = { appState.setShowSettingsDialog(false) }\n                )\n            }\n```\n\n然后就是脚手架了：\nScaffold，这里可以配置底部bar\n```Kotlin\n  Scaffold(\n                modifier = Modifier.semantics {\n                    testTagsAsResourceId = true\n                },\n                containerColor = Color.Transparent,\n                contentColor = MaterialTheme.colorScheme.onBackground,\n                contentWindowInsets = WindowInsets(0, 0, 0, 0),\n                snackbarHost = { SnackbarHost(snackbarHostState) },\n                // 底部bar 设置destinations，就是底部tab数据\n                bottomBar = {\n                    if (appState.shouldShowBottomBar) {\n                        NiaBottomBar(\n                            destinations = appState.topLevelDestinations,\n                            onNavigateToDestination = appState::navigateToTopLevelDestination,\n                            currentDestination = appState.currentDestination,\n                            modifier = Modifier.testTag(\"NiaBottomBar\")\n                        )\n                    }\n                }\n            )\n```\n\n这里snackbarHost也是脚手架里面的内容。\n\n然后里面是一个Row，为什么是一个水平布局，因为考虑到兼容电视，平板，这里将导航页设置了一个水平的左侧导航。\n```Kotlin\n  // 平板 水平布局 左侧导航\n                    if (appState.shouldShowNavRail) {\n                        NiaNavRail(\n                            destinations = appState.topLevelDestinations,\n                            onNavigateToDestination = appState::navigateToTopLevelDestination,\n                            currentDestination = appState.currentDestination,\n                            modifier = Modifier\n                                .testTag(\"NiaNavRail\")\n                                .safeDrawingPadding()\n                        )\n                    }\n```\n\n然后就是实际内容区域了：\n设置+主页构成。\n```Kotlin\n// 垂直布局，状态栏+内容区\n                    /**\n                     * 以前，我们在布局中去设置一个控件的大小，间距，点击事件，宽高，背景等属性值。\n                     * 而在Compose中我们是通过Modifie去设置，Modifie相当于一个控件的属性配置的工具类。\n                     */\n                    Column(Modifier.fillMaxSize()) {\n                        // Show the top app bar on top level destinations.\n                        val destination = appState.currentTopLevelDestination\n                        if (destination != null) {\n                            NiaTopAppBar(\n                                titleRes = destination.titleTextId,\n                                actionIcon = NiaIcons.Settings,\n                                actionIconContentDescription = stringResource(\n                                    id = settingsR.string.top_app_bar_action_icon_description\n                                ),\n                                colors = TopAppBarDefaults.centerAlignedTopAppBarColors(\n                                    containerColor = Color.Transparent\n                                ),\n                                /**\n                                 * 设置点击事件触发appState中的 mutableStateOf变量发生更改\n                                 */\n                                onActionClick = { appState.setShowSettingsDialog(true) }\n                            )\n                        }\n\n                        // 主页面\n                        NiaNavHost(\n                            navController = appState.navController,\n                            onBackClick = appState::onBackClick\n                        )\n                    }\n```\n\nNiaTopAppBar是自定义顶部标题栏\nNiaNavHost是主页面\n\n主页面也是在App模块下的navigation文件夹中定义。\n\n```Kotlin\n@Composable\nfun NiaNavHost(\n    /**\n     * 导航控制器\n     */\n    navController: NavHostController,\n    /**\n     * 返回点击\n     */\n    onBackClick: () -> Unit,\n    /**\n     * 属性配置工具\n     */\n    modifier: Modifier = Modifier,\n    /**\n     * 开始路由设置\n     */\n    startDestination: String = forYouNavigationRoute\n) {\n    NavHost(\n        navController = navController,\n        startDestination = startDestination,\n        modifier = modifier,\n    ) {\n        forYouScreen()\n        bookmarksScreen()\n        interestsGraph(\n            navigateToTopic = { topicId ->\n                navController.navigateToTopic(topicId)\n            },\n            nestedGraphs = {\n                topicScreen(onBackClick)\n            }\n        )\n    }\n}\n```\n这里使用了一个NavHost 的compose官方组件。\n\ntab实现为：\nforYouScreen 你的模块\nbookmarksScreen 书签模块\ninterestsGraph 兴趣模块\n\n这几个tab都是依赖于其它module了。\napp自身module大致内容就这么多了。\n\n\n","source":"_posts/Android-google-samples-nowinandroid-app模块流程分析.md","raw":"---\ntitle: Android google samples nowinandroid app模块流程分析\ndate: 2023-01-15 11:53:19\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- Android\ncategories:\n- Android\n---\n\n> googe samples之 nowinandroid项目地址：[https://github.com/android/nowinandroid](https://github.com/android/nowinandroid)\n\n### 1.app模块build.gradle文件配置\n```Groovy\nplugins {\n    id(\"nowinandroid.android.application\")\n    id(\"nowinandroid.android.application.compose\")\n    id(\"nowinandroid.android.application.jacoco\")\n    id(\"nowinandroid.android.hilt\")\n    id(\"jacoco\")\n    id(\"nowinandroid.firebase-perf\")\n}\n```\n引入了application插件，compose插件，jacoco插件，hilt插件，firebase插件\n\n依赖项：\n```Groovy\n    implementation(project(\":feature:interests\"))\n    implementation(project(\":feature:foryou\"))\n    implementation(project(\":feature:bookmarks\"))\n    implementation(project(\":feature:topic\"))\n    implementation(project(\":feature:settings\"))\n\n    implementation(project(\":core:common\"))\n    implementation(project(\":core:ui\"))\n    implementation(project(\":core:designsystem\"))\n    implementation(project(\":core:data\"))\n    implementation(project(\":core:model\"))\n\n    implementation(project(\":sync:work\"))\n```\nfeature文件夹下是app模块的界面上拆分组件。\n如feature_interests 就是兴趣tab\nfeature_foryou 就是第一个tab\nfeature_bookmarks 是书签模块\n等等\n\n下面的core就是核心模块了，有通用组件，ui组件，设计系统，数据区\n\n然后sync_work是一些工具module了。\n\n### 2.清单文件\n```xml\n    <application\n        android:name=\".NiaApplication\"\n        android:allowBackup=\"true\"\n        android:enableOnBackInvokedCallback=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Nia.Splash\">\n<!--        Profileable 是 Android 10 中引入的清单配置，可用于 CPU 和内存分析任务。使用 profileable 标志而不是 debuggable 标志具有降低性能开销的关键优势；-->\n        <profileable android:shell=\"true\" tools:targetApi=\"q\" />\n\n        <activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n\n```\n这里很简单，就一个Application自定义的，一个首页，说明这个App就一个Activity。\n这里引入了一个profileable标签，是Android10后引入的，可以用于CPU和内存分析任务。\n\n### 3.自定义Application\n这里App开始启动了。\n首先是用了一个HiltAndroidApp的注解。\n这个是类似Dragger的依赖注解框架，这里要求在Application用这个注解。\n关于Hilt用法可参考：[https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn](https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn)\n\n这里在Application里面初始化了一个东西：\n`Sync.initialize(context = this)`\n作用就是初始化Sync三方库。\n\n里面是这样走的：\n```Kotlin\n  AppInitializer.getInstance(context)\n            .initializeComponent(SyncInitializer::class.java)\n```\nAppInitializer是google的Jetpack下的startup中的类成员，关于这个用法可以参考下郭霖的博客：[https://blog.csdn.net/guolin_blog/article/details/108026357](https://blog.csdn.net/guolin_blog/article/details/108026357)\n\n为什么要引入这个同步的库呢？\n/**\n * Registers work to sync the data layer periodically on app startup.\n * 初始化三方库 这里是WorkManager，主要用于\n * Android出于设备电量的考虑，为开发者提供了WorkManager，旨在将一些不需要及时完成的任务交给它来完成。\n * 虽然WorkManager宣称，能够保证任务得到执行，但我在真实设备中，发现应用程序彻底退出与重启设备，任务都没有再次执行。\n * 查阅了相关资料，发现这应该与系统有关系。我们前面也提到了，WorkManager会根据系统的版本，\n * 决定采用JobScheduler或是AlarmManager+Broadcast Receivers来完成任务。\n * 但是这些API很可能会受到OEM系统的影响。比如，假设某个系统不允许AlarmManager自动唤起，那么WorkManager很可能就无法正常使用。\n */\n \n ### 4.MainActivity 参数定义\n Application走完，就到了Activity了。\n 首先是两个注解：\n\n1.  @OptIn(ExperimentalMaterial3WindowSizeClassApi::class)\n Opt-in 是 Kotlin 标准库中的一个方法，用于声明使用某些 API 需要明确的同意。\n  该功能可以让开发者告知 API 使用者使用某些 API 需要一些特定的条件，如果使用者已经知晓则需要明确声明依旧使用（Opt-in）才能继续使用该 API。\n  例如，某些 API 尚处于测试阶段，未来可能会发生变化；亦或是我前言中提到的场景，都非常适合使用该方法。\n  如果我们声明了某个方法（functiuon）或类(class)需要 Opt-in ，则IDE或编译器会发出警告，要求使用者明确标注需要使用（Opt-in）。\n  参考文档：[https://juejin.cn/post/7157950373250990093](https://juejin.cn/post/7157950373250990093)\n\n2. @AndroidEntryPoint\n在要使用依赖注入的类上方添加@AndroidEntryPoint注解\n参考文档：[https://www.jianshu.com/p/22a36660a656](https://www.jianshu.com/p/22a36660a656)\n\n然后声明了两个注入的变量：\n```Kotlin\n/**\n     * Lazily inject [JankStats], which is used to track jank throughout the app.\n     * JankStats 是首个专为在用户设备上检测及报告应用的性能问题而构建的 AndroidX 库。\n     * JankStats 是占用空间相对较小的 API，主要有三大目标: 捕获每帧的性能信息、在用户设备 (不仅是开发设备) 上运行、以及在应用出现性能问题时启用检测，并报告所发生的情况\n     *\n     * 在Dagger中Lazy可以将要注入的依赖项转变为懒加载模式，这样注入的依赖项，只有在需要使用时，\n     * 才会调用对应的依赖生成方法。懒加载的实现很简单，只需要在注入位置将依赖项的类型设置为Lazy接口的类型参数即可。\n     *\n     * 构造函数在di 文件夹下的 JankStatsModule 下\n     */\n    @Inject\n    lateinit var lazyStats: dagger.Lazy<JankStats>\n\n    /**\n     * 自定义网络监视器 这个是一个接口 应该也是测试用的\n     */\n    @Inject\n    lateinit var networkMonitor: NetworkMonitor\n\n```\n \n 关于lazyStats怎么初始化的？在项目di文件夹下有个JankStatsModule\n \n```Kotlin\n/**\n * 这里的目标是生产一个JankStats对象\n *\n * 怎么生产呢，需要2个构造参数\n * 1.JankStats.OnFrameListener\n * 2.Window\n *\n * window需要依赖activity，这里就需要 ActivityComponent了\n * 这个JankStats对象的生命周期设定为Activity级别\n */\n@Module\n@InstallIn(ActivityComponent::class)\nobject JankStatsModule {\n    @Provides\n    fun providesOnFrameListener(): JankStats.OnFrameListener {\n        return JankStats.OnFrameListener { frameData ->\n            // Make sure to only log janky frames.\n            if (frameData.isJank) {\n                // We're currently logging this but would better report it to a backend.\n                Log.v(\"NiA Jank\", frameData.toString())\n            }\n        }\n    }\n\n    @Provides\n    fun providesWindow(activity: Activity): Window {\n        return activity.window\n    }\n\n    @Provides\n    fun providesJankStats(\n        window: Window,\n        frameListener: JankStats.OnFrameListener\n    ): JankStats {\n        return JankStats.createAndTrack(window, frameListener)\n    }\n}\n```\n这里生产了  一个JankStats对象。\n\n关于网络监视器如何初始化的呢？\n这个网络监视器是一个接口来的：\n```Kotlin\n/**\n * Utility for reporting app connectivity status\n */\ninterface NetworkMonitor {\n    val isOnline: Flow<Boolean>\n}\n\n```\n一直没找到如何实例化的地方。\n不过再其它模块，core下的data.di文件夹下发现了另外一个DataModule下有如下代码：\n```Kotlin\n\n    @Binds\n    fun bindsNetworkMonitor(\n        networkMonitor: ConnectivityManagerNetworkMonitor\n    ): NetworkMonitor\n```\n这里貌似可以生产一个NetworkMonitor对象。\n但怎么关联起来的呢？\n\n这个我确实不清楚hilt的用法，而且这个DataModule理应需要在Application配置，但也没找到相关依赖，可能hilt对加上这种注解能全局自动生成依赖代码也说不定。反正这里的网络监视器应该就是这个ConnectivityManagerNetworkMonitor 主要逻辑也在这里。\n\n第三个变量是viewModel\n` val viewModel: MainActivityViewModel by viewModels()`\n这个用法类似：\n`ViewModelProvider(this).get(MainActivityViewModel::class.java)`\n\n\n### 5.首页生命周期-onCreate\n继续走，第一行是 适配闪屏页 installSplashScreen()\n关于闪屏页可参考文档：[https://blog.csdn.net/guolin_blog/article/details/120275319](https://blog.csdn.net/guolin_blog/article/details/120275319)（郭霖）\n\n然后这里监听了一个密封接口中的 Loading 状态，\n密封接口定义如下：\n```Kotlin\n/**\n * 首页ui 状态的密封类，有加载中和成功的状态\n * 密封接口 类似枚举类型，说明有Loading状态和成功状态\n * 表示受限制的类层次结构\n */\nsealed interface MainActivityUiState {\n    object Loading : MainActivityUiState\n    data class Success(val userData: UserData) : MainActivityUiState\n}\n```\n很明显这里Loading实现了这个接口，Success也实现了这个接口。\n\n在onCreate监听了这个Loading类：\n```Kotlin\n\n        /**\n         * mutableStateOf 表明某个变量是有状态的，对变量进行监听，当状态改变时，触发重绘。\n         * remember --- 记录变量的值，使得下次使用改变量时不进行初始化。\n         * 使用 remember 存储对象的可组合项会创建内部状态，使该可组合项有状态。\n         * remember 会为函数提供存储空间，将 remember 计算的值储存，当 remember 的键改变的时候会进行重新计算值并储存。\n         * rememberSaveable --- 在这里顺带提一下,rememberSaveable 可以在重组后保持状态,也可以在重新创建 activity 和进程后保持状态。\n         */\n        var uiState: MainActivityUiState by mutableStateOf(Loading)\n```\n\n然后开启一个携程，拿用户数据：\n```Kotlin\n // Activity生命周期内使用携程\n        lifecycleScope.launch {\n            // Lifecycle.State.STARTED: 表示只有在Activity处于Started状态的情况下，协程中的代码才会执行。\n            lifecycle.repeatOnLifecycle(Lifecycle.State.STARTED) {\n                viewModel.uiState\n                    .onEach {\n                        uiState = it\n                    }\n                    .collect() // 走collect方法才代表执行携程\n            }\n        }\n```\n拿到数据后，才回去更新uiState对象。\n\n就是说uiState会有上面密封接口定义的两种类型。\n\n当监听到uiState变化后会走：\n```Kotlin\n /**\n         * 如果网络请求正在请求loading状态，就还是显示闪屏，如果拿到数据了就不需要闪屏了\n         */\n        splashScreen.setKeepOnScreenCondition {\n            when (uiState) {\n                Loading -> true\n                is Success -> false\n            }\n        }\n```\n闪屏会去除掉。\n\n下面开启沉浸式状态栏：\n```Kotlin\n  /**\n         * 第二参数decorFitsSystemWindows表示是否沉浸，false 表示沉浸，true表示不沉浸\n         */\n        WindowCompat.setDecorFitsSystemWindows(window, false)\n```\n\n然后就是内容区，compose设置内容区了\n一个setContent的函数，太长了，就不全部贴图，挨个分析。\n\n1.首先获取一个systemUIController\n```Kotlin\n /**\n             * 开发者若想在 Compose 布局中控制 System UI，就必须获取 SystemUiController 对象。\n             * 通过该库提供 rememberSystemUiController 函数，开发者可以获取当前操作系统（目前仅支持 Android 系统）的  SystemUiController 对象。\n             */\n            val systemUiController = rememberSystemUiController()\n```\n\n2.是否使用深色主题，用户可以自己选\n```Kotlin\n /**\n             * 是否使用深色主题，入参当前ui状态\n             */\n            val darkTheme = shouldUseDarkTheme(uiState)\n            \n```\n\n内部实现：\n```Kotlin\n/**\n * Returns `true` if dark theme should be used, as a function of the [uiState] and the\n * current system context.\n * 调用@Composable 函数的函数必须用@Composable 注解标记\n */\n@Composable\nprivate fun shouldUseDarkTheme(\n    uiState: MainActivityUiState,\n): Boolean = when (uiState) {\n    /**\n     * isSystemInDarkTheme 根据系统来，加载中状态\n     */\n    Loading -> isSystemInDarkTheme()\n    is Success -> when (uiState.userData.darkThemeConfig) {\n        /**\n         * 成功状态下，根据用户配置的数据来展示，如果跟随系统那就跟随，如果用户主动设置了某一种，那就成功时选择\n         */\n        DarkThemeConfig.FOLLOW_SYSTEM -> isSystemInDarkTheme()\n        DarkThemeConfig.LIGHT -> false\n        DarkThemeConfig.DARK -> true\n    }\n}\n```\n\n然后开启一个DisposableEffect来关联上面这两个对象：\n```Kotlin\n  /**\n             * disposable，顾名思义，这就是一个自带清理作用的Effect\n             */\n            DisposableEffect(systemUiController, darkTheme) {\n                // 否与导航栏图标+内容是否“黑暗\"\n                systemUiController.systemBarsDarkContentEnabled = !darkTheme\n                onDispose {}\n            }\n```\n\n最后，开始设置App主题了：\n```Kotlin\n  /**\n             * 主题配置，是否暗色，判断用户是否有自己选择\n             * 是否用Android主题\n             * 下面这些代码才是内容区的布局，上面MainActivityUiState 这个只是拿用户的持久化数据，槽了\n             */\n            NiaTheme(\n                darkTheme = darkTheme,\n                androidTheme = shouldUseAndroidTheme(uiState)\n            ) {\n                // NiaApp是一个闭包，作为第三个参数\n                NiaApp(\n                    /**\n                     * 窗口大小类，获取一个WindowSizeClass 这个实例\n                     */\n                    windowSizeClass = calculateWindowSizeClass(this),\n                    /**\n                     * 网络监视器，前面注入的\n                     */\n                    networkMonitor = networkMonitor,\n                )\n            }\n```\n\n里面的闭包 NiaApp也就是开启了我们的App。\n\n### 6.首页其它生命周期\n```Kotlin\n  override fun onResume() {\n        super.onResume()\n        /**\n         * 跟踪性能\n         */\n        lazyStats.get().isTrackingEnabled = true\n    }\n\n    override fun onPause() {\n        super.onPause()\n        /**\n         * 去除跟踪\n         */\n        lazyStats.get().isTrackingEnabled = false\n    }\n```\n\nMainActivity内容就这么多了，非常指简洁。\n布局交给NiaApp类处理了。\n\n其它对象初始化交给hilt处理了。\n\n主要就只开了个协程获取用户数据，而且优化闪屏页和loading的显示。\n\n### 7.NiaTheme主题设置\n先是主题颜色：\n```Kotlin\n // 主题颜色\n    val colorScheme = when {\n        // 判断当前 android主题是暗色还是浅色\n        androidTheme -> if (darkTheme) DarkAndroidColorScheme else LightAndroidColorScheme\n        // 没有禁用动态主题并且支持动态主题\n        !disableDynamicTheming && supportsDynamicTheming() -> {\n            val context = LocalContext.current\n            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)\n        }\n        // 其它情况\n        else -> if (darkTheme) DarkDefaultColorScheme else LightDefaultColorScheme\n    }\n```\n\n渐变色:\n```Kotlin\n    // Gradient colors 渐变色\n    // 空渐变色\n    val emptyGradientColors = GradientColors(container = colorScheme.surfaceColorAtElevation(2.dp))\n    // 默认渐变色\n    val defaultGradientColors = GradientColors(\n        top = colorScheme.inverseOnSurface,\n        bottom = colorScheme.primaryContainer,\n        container = colorScheme.surface\n    )\n    // 渐变色\n    val gradientColors = when {\n        androidTheme -> if (darkTheme) DarkAndroidGradientColors else LightAndroidGradientColors\n        !disableDynamicTheming && supportsDynamicTheming() -> emptyGradientColors\n        else -> defaultGradientColors\n    }\n```\n\n最终设置到MaterialTheme里面：\n```Kotlin\n   // Composition locals\n    CompositionLocalProvider(\n        LocalGradientColors provides gradientColors,\n        LocalBackgroundTheme provides backgroundTheme\n    ) {\n        MaterialTheme(\n            colorScheme = colorScheme,\n            typography = NiaTypography,\n            content = content\n        )\n    }\n```\n\n### 8.NiaApp状态定义\n\n首先创建一个NiaApp实例。\n入参：窗口大小类，网络监视器\n```Kotlin\n NiaApp(\n                    /**\n                     * 窗口大小类，获取一个WindowSizeClass 这个实例\n                     */\n                    windowSizeClass = calculateWindowSizeClass(this),\n                    /**\n                     * 网络监视器，前面注入的\n                     */\n                    networkMonitor = networkMonitor,\n                )\n```\n\n这里是App首页ui样式。\n\n这里用到的状态作为第三个参数，作为app状态记录。\n\n函数定义如下：\n```Kotlin\n@OptIn(\n    ExperimentalMaterial3Api::class,\n    ExperimentalLayoutApi::class,\n    ExperimentalComposeUiApi::class,\n    ExperimentalLifecycleComposeApi::class\n)\n@Composable\nfun NiaApp(\n    windowSizeClass: WindowSizeClass,\n    networkMonitor: NetworkMonitor,\n    /**\n     * app状态记录\n     */\n    appState: NiaAppState = rememberNiaAppState(\n        networkMonitor = networkMonitor,\n        windowSizeClass = windowSizeClass\n    ),\n) \n```\n这里第三个参数已经默认实现了。\n\n就是用于app状态记录，调用了一个自定义的rememberNiaAppState方法。\n```Kotlin\n@Composable\nfun rememberNiaAppState(\n    windowSizeClass: WindowSizeClass,\n    networkMonitor: NetworkMonitor,\n    coroutineScope: CoroutineScope = rememberCoroutineScope(),\n    /**\n     * 导航控制器\n     */\n    navController: NavHostController = rememberNavController()\n): NiaAppState {\n    NavigationTrackingSideEffect(navController)\n    /**\n     * remember 里面参数可以任意，闭包里面的东西，就是remember返回的东西\n     */\n    return remember(navController, coroutineScope, windowSizeClass, networkMonitor) {\n        NiaAppState(navController, coroutineScope, windowSizeClass, networkMonitor)\n    }\n}\n```\n这里默认实现了协程作用域，导航控制器，需要返回一个NiaAppState变量。\n\n这里通过remember闭包来返回这个变量。\n\n这个NiaAppState定义如下：\n```Kotlin\n/**\n * 主要用于类似LiveData保存的数据\n * App状态记录，需要传入导航控制器，携程作用范围，window窗口大小\n */\n@Stable\nclass NiaAppState(\n    val navController: NavHostController,\n    val coroutineScope: CoroutineScope,\n    val windowSizeClass: WindowSizeClass,\n    networkMonitor: NetworkMonitor,\n) {\n```\n类似LiveData，保存了首页必要的一些数据。\n\n```Kotlin\n /**\n     * 当前在那个tab\n     */\n    val currentDestination: NavDestination?\n        @Composable get() = navController\n            .currentBackStackEntryAsState().value?.destination\n```\n\n```Kotlin\n /**\n     * 通过在哪个tab，决定用哪个枚举类， TopLevelDestination是自己定义的枚举类\n     */\n    val currentTopLevelDestination: TopLevelDestination?\n        @Composable get() = when (currentDestination?.route) {\n            forYouNavigationRoute -> FOR_YOU\n            bookmarksRoute -> BOOKMARKS\n            interestsRoute -> INTERESTS\n            else -> null\n        }\n```\n\n```Kotlin\n /**\n     * 是否展示设置弹框\n     */\n    var shouldShowSettingsDialog by mutableStateOf(false)\n        private set\n```\n\n```Kotlin\n /**\n     * 是否展示底部bar\n     */\n    val shouldShowBottomBar: Boolean\n        get() = windowSizeClass.widthSizeClass == WindowWidthSizeClass.Compact ||\n            windowSizeClass.heightSizeClass == WindowHeightSizeClass.Compact\n```\n\n```Kotlin\n  /**\n     * 是否展示水平左侧导航\n     */\n    val shouldShowNavRail: Boolean\n        get() = !shouldShowBottomBar\n```\n\n```Kotlin\n /**\n     * 监控网络，是否断网\n     */\n    val isOffline = networkMonitor.isOnline\n        .map(Boolean::not)\n        .stateIn(\n            scope = coroutineScope,\n            started = SharingStarted.WhileSubscribed(5_000),\n            initialValue = false\n        )\n\n```\n\n```Kotlin\n   /**\n     * 这里是一个枚举类，表示底部tab集合\n     * Map of top level destinations to be used in the TopBar, BottomBar and NavRail. The key is the\n     * route.\n     */\n    val topLevelDestinations: List<TopLevelDestination> = TopLevelDestination.values().asList()\n```\n\n```Kotlin\n /**\n     * 点击tab事件传递\n     *\n     * @param topLevelDestination: The destination the app needs to navigate to.\n     */\n    fun navigateToTopLevelDestination(topLevelDestination: TopLevelDestination) {\n        trace(\"Navigation: ${topLevelDestination.name}\") {\n            val topLevelNavOptions = navOptions {\n                // Pop up to the start destination of the graph to\n                // avoid building up a large stack of destinations\n                // on the back stack as users select items\n                popUpTo(navController.graph.findStartDestination().id) {\n                    saveState = true\n                }\n                // Avoid multiple copies of the same destination when\n                // reselecting the same item\n                launchSingleTop = true\n                // Restore state when reselecting a previously selected item\n                restoreState = true\n            }\n\n            when (topLevelDestination) {\n                FOR_YOU -> navController.navigateToForYou(topLevelNavOptions)\n                BOOKMARKS -> navController.navigateToBookmarks(topLevelNavOptions)\n                INTERESTS -> navController.navigateToInterestsGraph(topLevelNavOptions)\n            }\n        }\n    }\n\n```\n\n然后定义了一些方法：\n```Kotlin\n /**\n     * 返回点击\n     */\n    fun onBackClick() {\n        navController.popBackStack()\n    }\n\n    /**\n     * 改变设置弹框状态\n     */\n    fun setShowSettingsDialog(shouldShow: Boolean) {\n        shouldShowSettingsDialog = shouldShow\n    }\n```\n\n### 9.NiaApp内容区\n\nApp背景色\n```Kotlin\n@Composable\nfun NiaBackground(\n    modifier: Modifier = Modifier,\n    content: @Composable () -> Unit\n) {\n    val color = LocalBackgroundTheme.current.color\n    val tonalElevation = LocalBackgroundTheme.current.tonalElevation\n    Surface(\n        color = if (color == Color.Unspecified) Color.Transparent else color,\n        tonalElevation = if (tonalElevation == Dp.Unspecified) 0.dp else tonalElevation,\n        modifier = modifier.fillMaxSize(),\n    ) {\n        CompositionLocalProvider(LocalAbsoluteTonalElevation provides 0.dp) {\n            content()\n        }\n    }\n}\n```\n\n数据源使用 LocalBackgroundTheme.current.color\n\n内容区继续渐变背景：\n```Kotlin\n@Composable\nfun NiaGradientBackground(\n    modifier: Modifier = Modifier,\n    gradientColors: GradientColors = LocalGradientColors.current,\n    content: @Composable () -> Unit\n) {\n    val currentTopColor by rememberUpdatedState(gradientColors.top)\n    val currentBottomColor by rememberUpdatedState(gradientColors.bottom)\n    Surface(\n        color = if (gradientColors.container == Color.Unspecified) {\n            Color.Transparent\n        } else {\n            gradientColors.container\n        },\n        modifier = modifier.fillMaxSize()\n    ) {\n        Box(\n            Modifier\n                .fillMaxSize()\n                .drawWithCache {\n                    // Compute the start and end coordinates such that the gradients are angled 11.06\n                    // degrees off the vertical axis\n                    val offset = size.height * tan(\n                        Math\n                            .toRadians(11.06)\n                            .toFloat()\n                    )\n\n                    val start = Offset(size.width / 2 + offset / 2, 0f)\n                    val end = Offset(size.width / 2 - offset / 2, size.height)\n\n                    // Create the top gradient that fades out after the halfway point vertically\n                    val topGradient = Brush.linearGradient(\n                        0f to if (currentTopColor == Color.Unspecified) {\n                            Color.Transparent\n                        } else {\n                            currentTopColor\n                        },\n                        0.724f to Color.Transparent,\n                        start = start,\n                        end = end,\n                    )\n                    // Create the bottom gradient that fades in before the halfway point vertically\n                    val bottomGradient = Brush.linearGradient(\n                        0.2552f to Color.Transparent,\n                        1f to if (currentBottomColor == Color.Unspecified) {\n                            Color.Transparent\n                        } else {\n                            currentBottomColor\n                        },\n                        start = start,\n                        end = end,\n                    )\n\n                    onDrawBehind {\n                        // There is overlap here, so order is important\n                        drawRect(topGradient)\n                        drawRect(bottomGradient)\n                    }\n                }\n        ) {\n            content()\n        }\n    }\n}\n```\n这里在上面0到0.724区间设置了topGradient\n在0.2552f到1设置了 bottomGradient\n\n### 10.业务内容区\n\n```Kotlin\n   // 记录下snackbar状态，后续可能会刷新\n            val snackbarHostState = remember { SnackbarHostState() }\n```\n这个用于网络监听，如果没有网络，底部会常驻一个snackbar\n\n```Kotlin\n            // 是否离线\n            val isOffline by appState.isOffline.collectAsStateWithLifecycle()\n\n            // If user is not connected to the internet show a snack bar to inform them.\n            // 如果没有网络，底部展示Snackbar\n            val notConnectedMessage = stringResource(R.string.not_connected)\n            // 这个是Compose里面的launch，compose开启携程的方法\n            LaunchedEffect(isOffline) {\n                if (isOffline) snackbarHostState.showSnackbar(\n                    message = notConnectedMessage,\n                    duration = Indefinite\n                )\n            }\n```\n\nKotlin\n            // 是否应该展示设置弹框，当点击右上角设置后，会弹出设置弹框\n            if (appState.shouldShowSettingsDialog) {\n                SettingsDialog(\n                    onDismiss = { appState.setShowSettingsDialog(false) }\n                )\n            }\n```\n\n然后就是脚手架了：\nScaffold，这里可以配置底部bar\n```Kotlin\n  Scaffold(\n                modifier = Modifier.semantics {\n                    testTagsAsResourceId = true\n                },\n                containerColor = Color.Transparent,\n                contentColor = MaterialTheme.colorScheme.onBackground,\n                contentWindowInsets = WindowInsets(0, 0, 0, 0),\n                snackbarHost = { SnackbarHost(snackbarHostState) },\n                // 底部bar 设置destinations，就是底部tab数据\n                bottomBar = {\n                    if (appState.shouldShowBottomBar) {\n                        NiaBottomBar(\n                            destinations = appState.topLevelDestinations,\n                            onNavigateToDestination = appState::navigateToTopLevelDestination,\n                            currentDestination = appState.currentDestination,\n                            modifier = Modifier.testTag(\"NiaBottomBar\")\n                        )\n                    }\n                }\n            )\n```\n\n这里snackbarHost也是脚手架里面的内容。\n\n然后里面是一个Row，为什么是一个水平布局，因为考虑到兼容电视，平板，这里将导航页设置了一个水平的左侧导航。\n```Kotlin\n  // 平板 水平布局 左侧导航\n                    if (appState.shouldShowNavRail) {\n                        NiaNavRail(\n                            destinations = appState.topLevelDestinations,\n                            onNavigateToDestination = appState::navigateToTopLevelDestination,\n                            currentDestination = appState.currentDestination,\n                            modifier = Modifier\n                                .testTag(\"NiaNavRail\")\n                                .safeDrawingPadding()\n                        )\n                    }\n```\n\n然后就是实际内容区域了：\n设置+主页构成。\n```Kotlin\n// 垂直布局，状态栏+内容区\n                    /**\n                     * 以前，我们在布局中去设置一个控件的大小，间距，点击事件，宽高，背景等属性值。\n                     * 而在Compose中我们是通过Modifie去设置，Modifie相当于一个控件的属性配置的工具类。\n                     */\n                    Column(Modifier.fillMaxSize()) {\n                        // Show the top app bar on top level destinations.\n                        val destination = appState.currentTopLevelDestination\n                        if (destination != null) {\n                            NiaTopAppBar(\n                                titleRes = destination.titleTextId,\n                                actionIcon = NiaIcons.Settings,\n                                actionIconContentDescription = stringResource(\n                                    id = settingsR.string.top_app_bar_action_icon_description\n                                ),\n                                colors = TopAppBarDefaults.centerAlignedTopAppBarColors(\n                                    containerColor = Color.Transparent\n                                ),\n                                /**\n                                 * 设置点击事件触发appState中的 mutableStateOf变量发生更改\n                                 */\n                                onActionClick = { appState.setShowSettingsDialog(true) }\n                            )\n                        }\n\n                        // 主页面\n                        NiaNavHost(\n                            navController = appState.navController,\n                            onBackClick = appState::onBackClick\n                        )\n                    }\n```\n\nNiaTopAppBar是自定义顶部标题栏\nNiaNavHost是主页面\n\n主页面也是在App模块下的navigation文件夹中定义。\n\n```Kotlin\n@Composable\nfun NiaNavHost(\n    /**\n     * 导航控制器\n     */\n    navController: NavHostController,\n    /**\n     * 返回点击\n     */\n    onBackClick: () -> Unit,\n    /**\n     * 属性配置工具\n     */\n    modifier: Modifier = Modifier,\n    /**\n     * 开始路由设置\n     */\n    startDestination: String = forYouNavigationRoute\n) {\n    NavHost(\n        navController = navController,\n        startDestination = startDestination,\n        modifier = modifier,\n    ) {\n        forYouScreen()\n        bookmarksScreen()\n        interestsGraph(\n            navigateToTopic = { topicId ->\n                navController.navigateToTopic(topicId)\n            },\n            nestedGraphs = {\n                topicScreen(onBackClick)\n            }\n        )\n    }\n}\n```\n这里使用了一个NavHost 的compose官方组件。\n\ntab实现为：\nforYouScreen 你的模块\nbookmarksScreen 书签模块\ninterestsGraph 兴趣模块\n\n这几个tab都是依赖于其它module了。\napp自身module大致内容就这么多了。\n\n\n","slug":"Android-google-samples-nowinandroid-app模块流程分析","published":1,"updated":"2023-02-01T07:12:20.421Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlc01j70001jhv7761c3czv","content":"<blockquote>\n<p>googe samples之 nowinandroid项目地址：<a href=\"https://github.com/android/nowinandroid\">https://github.com/android/nowinandroid</a></p>\n</blockquote>\n<h3 id=\"1-app模块build-gradle文件配置\"><a href=\"#1-app模块build-gradle文件配置\" class=\"headerlink\" title=\"1.app模块build.gradle文件配置\"></a>1.app模块build.gradle文件配置</h3><pre><code class=\"line-numbers language-Groovy\">plugins &#123;\n    id(&quot;nowinandroid.android.application&quot;)\n    id(&quot;nowinandroid.android.application.compose&quot;)\n    id(&quot;nowinandroid.android.application.jacoco&quot;)\n    id(&quot;nowinandroid.android.hilt&quot;)\n    id(&quot;jacoco&quot;)\n    id(&quot;nowinandroid.firebase-perf&quot;)\n&#125;\n</code></pre>\n<p>引入了application插件，compose插件，jacoco插件，hilt插件，firebase插件</p>\n<p>依赖项：</p>\n<pre><code class=\"line-numbers language-Groovy\">    implementation(project(&quot;:feature:interests&quot;))\n    implementation(project(&quot;:feature:foryou&quot;))\n    implementation(project(&quot;:feature:bookmarks&quot;))\n    implementation(project(&quot;:feature:topic&quot;))\n    implementation(project(&quot;:feature:settings&quot;))\n\n    implementation(project(&quot;:core:common&quot;))\n    implementation(project(&quot;:core:ui&quot;))\n    implementation(project(&quot;:core:designsystem&quot;))\n    implementation(project(&quot;:core:data&quot;))\n    implementation(project(&quot;:core:model&quot;))\n\n    implementation(project(&quot;:sync:work&quot;))\n</code></pre>\n<p>feature文件夹下是app模块的界面上拆分组件。<br>如feature_interests 就是兴趣tab<br>feature_foryou 就是第一个tab<br>feature_bookmarks 是书签模块<br>等等</p>\n<p>下面的core就是核心模块了，有通用组件，ui组件，设计系统，数据区</p>\n<p>然后sync_work是一些工具module了。</p>\n<h3 id=\"2-清单文件\"><a href=\"#2-清单文件\" class=\"headerlink\" title=\"2.清单文件\"></a>2.清单文件</h3><pre><code class=\"line-numbers language-xml\">    &lt;application\n        android:name=&quot;.NiaApplication&quot;\n        android:allowBackup=&quot;true&quot;\n        android:enableOnBackInvokedCallback=&quot;true&quot;\n        android:icon=&quot;@mipmap/ic_launcher&quot;\n        android:label=&quot;@string/app_name&quot;\n        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;\n        android:supportsRtl=&quot;true&quot;\n        android:theme=&quot;@style/Theme.Nia.Splash&quot;&gt;\n&lt;!--        Profileable 是 Android 10 中引入的清单配置，可用于 CPU 和内存分析任务。使用 profileable 标志而不是 debuggable 标志具有降低性能开销的关键优势；--&gt;\n        &lt;profileable android:shell=&quot;true&quot; tools:targetApi=&quot;q&quot; /&gt;\n\n        &lt;activity\n            android:name=&quot;.MainActivity&quot;\n            android:exported=&quot;true&quot;&gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;\n\n                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n    &lt;/application&gt;\n</code></pre>\n<p>这里很简单，就一个Application自定义的，一个首页，说明这个App就一个Activity。<br>这里引入了一个profileable标签，是Android10后引入的，可以用于CPU和内存分析任务。</p>\n<h3 id=\"3-自定义Application\"><a href=\"#3-自定义Application\" class=\"headerlink\" title=\"3.自定义Application\"></a>3.自定义Application</h3><p>这里App开始启动了。<br>首先是用了一个HiltAndroidApp的注解。<br>这个是类似Dragger的依赖注解框架，这里要求在Application用这个注解。<br>关于Hilt用法可参考：<a href=\"https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn\">https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn</a></p>\n<p>这里在Application里面初始化了一个东西：<br><code>Sync.initialize(context = this)</code><br>作用就是初始化Sync三方库。</p>\n<p>里面是这样走的：</p>\n<pre><code class=\"line-numbers language-Kotlin\">  AppInitializer.getInstance(context)\n            .initializeComponent(SyncInitializer::class.java)\n</code></pre>\n<p>AppInitializer是google的Jetpack下的startup中的类成员，关于这个用法可以参考下郭霖的博客：<a href=\"https://blog.csdn.net/guolin_blog/article/details/108026357\">https://blog.csdn.net/guolin_blog&#x2F;article&#x2F;details&#x2F;108026357</a></p>\n<p>为什么要引入这个同步的库呢？<br>&#x2F;**</p>\n<ul>\n<li>Registers work to sync the data layer periodically on app startup.</li>\n<li>初始化三方库 这里是WorkManager，主要用于</li>\n<li>Android出于设备电量的考虑，为开发者提供了WorkManager，旨在将一些不需要及时完成的任务交给它来完成。</li>\n<li>虽然WorkManager宣称，能够保证任务得到执行，但我在真实设备中，发现应用程序彻底退出与重启设备，任务都没有再次执行。</li>\n<li>查阅了相关资料，发现这应该与系统有关系。我们前面也提到了，WorkManager会根据系统的版本，</li>\n<li>决定采用JobScheduler或是AlarmManager+Broadcast Receivers来完成任务。</li>\n<li>但是这些API很可能会受到OEM系统的影响。比如，假设某个系统不允许AlarmManager自动唤起，那么WorkManager很可能就无法正常使用。<br> *&#x2F;</li>\n</ul>\n<h3 id=\"4-MainActivity-参数定义\"><a href=\"#4-MainActivity-参数定义\" class=\"headerlink\" title=\"4.MainActivity 参数定义\"></a>4.MainActivity 参数定义</h3><p> Application走完，就到了Activity了。<br> 首先是两个注解：</p>\n<ol>\n<li><p>@OptIn(ExperimentalMaterial3WindowSizeClassApi::class)<br> Opt-in 是 Kotlin 标准库中的一个方法，用于声明使用某些 API 需要明确的同意。<br>  该功能可以让开发者告知 API 使用者使用某些 API 需要一些特定的条件，如果使用者已经知晓则需要明确声明依旧使用（Opt-in）才能继续使用该 API。<br>  例如，某些 API 尚处于测试阶段，未来可能会发生变化；亦或是我前言中提到的场景，都非常适合使用该方法。<br>  如果我们声明了某个方法（functiuon）或类(class)需要 Opt-in ，则IDE或编译器会发出警告，要求使用者明确标注需要使用（Opt-in）。<br>  参考文档：<a href=\"https://juejin.cn/post/7157950373250990093\">https://juejin.cn/post/7157950373250990093</a></p>\n</li>\n<li><p>@AndroidEntryPoint<br>在要使用依赖注入的类上方添加@AndroidEntryPoint注解<br>参考文档：<a href=\"https://www.jianshu.com/p/22a36660a656\">https://www.jianshu.com/p/22a36660a656</a></p>\n</li>\n</ol>\n<p>然后声明了两个注入的变量：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n     * Lazily inject [JankStats], which is used to track jank throughout the app.\n     * JankStats 是首个专为在用户设备上检测及报告应用的性能问题而构建的 AndroidX 库。\n     * JankStats 是占用空间相对较小的 API，主要有三大目标: 捕获每帧的性能信息、在用户设备 (不仅是开发设备) 上运行、以及在应用出现性能问题时启用检测，并报告所发生的情况\n     *\n     * 在Dagger中Lazy可以将要注入的依赖项转变为懒加载模式，这样注入的依赖项，只有在需要使用时，\n     * 才会调用对应的依赖生成方法。懒加载的实现很简单，只需要在注入位置将依赖项的类型设置为Lazy接口的类型参数即可。\n     *\n     * 构造函数在di 文件夹下的 JankStatsModule 下\n     */\n    @Inject\n    lateinit var lazyStats: dagger.Lazy&lt;JankStats&gt;\n\n    /**\n     * 自定义网络监视器 这个是一个接口 应该也是测试用的\n     */\n    @Inject\n    lateinit var networkMonitor: NetworkMonitor\n</code></pre>\n<p> 关于lazyStats怎么初始化的？在项目di文件夹下有个JankStatsModule</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * 这里的目标是生产一个JankStats对象\n *\n * 怎么生产呢，需要2个构造参数\n * 1.JankStats.OnFrameListener\n * 2.Window\n *\n * window需要依赖activity，这里就需要 ActivityComponent了\n * 这个JankStats对象的生命周期设定为Activity级别\n */\n@Module\n@InstallIn(ActivityComponent::class)\nobject JankStatsModule &#123;\n    @Provides\n    fun providesOnFrameListener(): JankStats.OnFrameListener &#123;\n        return JankStats.OnFrameListener &#123; frameData -&gt;\n            // Make sure to only log janky frames.\n            if (frameData.isJank) &#123;\n                // We&#39;re currently logging this but would better report it to a backend.\n                Log.v(&quot;NiA Jank&quot;, frameData.toString())\n            &#125;\n        &#125;\n    &#125;\n\n    @Provides\n    fun providesWindow(activity: Activity): Window &#123;\n        return activity.window\n    &#125;\n\n    @Provides\n    fun providesJankStats(\n        window: Window,\n        frameListener: JankStats.OnFrameListener\n    ): JankStats &#123;\n        return JankStats.createAndTrack(window, frameListener)\n    &#125;\n&#125;\n</code></pre>\n<p>这里生产了  一个JankStats对象。</p>\n<p>关于网络监视器如何初始化的呢？<br>这个网络监视器是一个接口来的：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * Utility for reporting app connectivity status\n */\ninterface NetworkMonitor &#123;\n    val isOnline: Flow&lt;Boolean&gt;\n&#125;\n</code></pre>\n<p>一直没找到如何实例化的地方。<br>不过再其它模块，core下的data.di文件夹下发现了另外一个DataModule下有如下代码：</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n    @Binds\n    fun bindsNetworkMonitor(\n        networkMonitor: ConnectivityManagerNetworkMonitor\n    ): NetworkMonitor\n</code></pre>\n<p>这里貌似可以生产一个NetworkMonitor对象。<br>但怎么关联起来的呢？</p>\n<p>这个我确实不清楚hilt的用法，而且这个DataModule理应需要在Application配置，但也没找到相关依赖，可能hilt对加上这种注解能全局自动生成依赖代码也说不定。反正这里的网络监视器应该就是这个ConnectivityManagerNetworkMonitor 主要逻辑也在这里。</p>\n<p>第三个变量是viewModel<br><code> val viewModel: MainActivityViewModel by viewModels()</code><br>这个用法类似：<br><code>ViewModelProvider(this).get(MainActivityViewModel::class.java)</code></p>\n<h3 id=\"5-首页生命周期-onCreate\"><a href=\"#5-首页生命周期-onCreate\" class=\"headerlink\" title=\"5.首页生命周期-onCreate\"></a>5.首页生命周期-onCreate</h3><p>继续走，第一行是 适配闪屏页 installSplashScreen()<br>关于闪屏页可参考文档：<a href=\"https://blog.csdn.net/guolin_blog/article/details/120275319\">https://blog.csdn.net/guolin_blog&#x2F;article&#x2F;details&#x2F;120275319</a>（郭霖）</p>\n<p>然后这里监听了一个密封接口中的 Loading 状态，<br>密封接口定义如下：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * 首页ui 状态的密封类，有加载中和成功的状态\n * 密封接口 类似枚举类型，说明有Loading状态和成功状态\n * 表示受限制的类层次结构\n */\nsealed interface MainActivityUiState &#123;\n    object Loading : MainActivityUiState\n    data class Success(val userData: UserData) : MainActivityUiState\n&#125;\n</code></pre>\n<p>很明显这里Loading实现了这个接口，Success也实现了这个接口。</p>\n<p>在onCreate监听了这个Loading类：</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n        /**\n         * mutableStateOf 表明某个变量是有状态的，对变量进行监听，当状态改变时，触发重绘。\n         * remember --- 记录变量的值，使得下次使用改变量时不进行初始化。\n         * 使用 remember 存储对象的可组合项会创建内部状态，使该可组合项有状态。\n         * remember 会为函数提供存储空间，将 remember 计算的值储存，当 remember 的键改变的时候会进行重新计算值并储存。\n         * rememberSaveable --- 在这里顺带提一下,rememberSaveable 可以在重组后保持状态,也可以在重新创建 activity 和进程后保持状态。\n         */\n        var uiState: MainActivityUiState by mutableStateOf(Loading)\n</code></pre>\n<p>然后开启一个携程，拿用户数据：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> // Activity生命周期内使用携程\n        lifecycleScope.launch &#123;\n            // Lifecycle.State.STARTED: 表示只有在Activity处于Started状态的情况下，协程中的代码才会执行。\n            lifecycle.repeatOnLifecycle(Lifecycle.State.STARTED) &#123;\n                viewModel.uiState\n                    .onEach &#123;\n                        uiState = it\n                    &#125;\n                    .collect() // 走collect方法才代表执行携程\n            &#125;\n        &#125;\n</code></pre>\n<p>拿到数据后，才回去更新uiState对象。</p>\n<p>就是说uiState会有上面密封接口定义的两种类型。</p>\n<p>当监听到uiState变化后会走：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n         * 如果网络请求正在请求loading状态，就还是显示闪屏，如果拿到数据了就不需要闪屏了\n         */\n        splashScreen.setKeepOnScreenCondition &#123;\n            when (uiState) &#123;\n                Loading -&gt; true\n                is Success -&gt; false\n            &#125;\n        &#125;\n</code></pre>\n<p>闪屏会去除掉。</p>\n<p>下面开启沉浸式状态栏：</p>\n<pre><code class=\"line-numbers language-Kotlin\">  /**\n         * 第二参数decorFitsSystemWindows表示是否沉浸，false 表示沉浸，true表示不沉浸\n         */\n        WindowCompat.setDecorFitsSystemWindows(window, false)\n</code></pre>\n<p>然后就是内容区，compose设置内容区了<br>一个setContent的函数，太长了，就不全部贴图，挨个分析。</p>\n<p>1.首先获取一个systemUIController</p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n             * 开发者若想在 Compose 布局中控制 System UI，就必须获取 SystemUiController 对象。\n             * 通过该库提供 rememberSystemUiController 函数，开发者可以获取当前操作系统（目前仅支持 Android 系统）的  SystemUiController 对象。\n             */\n            val systemUiController = rememberSystemUiController()\n</code></pre>\n<p>2.是否使用深色主题，用户可以自己选</p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n             * 是否使用深色主题，入参当前ui状态\n             */\n            val darkTheme = shouldUseDarkTheme(uiState)\n            \n</code></pre>\n<p>内部实现：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * Returns `true` if dark theme should be used, as a function of the [uiState] and the\n * current system context.\n * 调用@Composable 函数的函数必须用@Composable 注解标记\n */\n@Composable\nprivate fun shouldUseDarkTheme(\n    uiState: MainActivityUiState,\n): Boolean = when (uiState) &#123;\n    /**\n     * isSystemInDarkTheme 根据系统来，加载中状态\n     */\n    Loading -&gt; isSystemInDarkTheme()\n    is Success -&gt; when (uiState.userData.darkThemeConfig) &#123;\n        /**\n         * 成功状态下，根据用户配置的数据来展示，如果跟随系统那就跟随，如果用户主动设置了某一种，那就成功时选择\n         */\n        DarkThemeConfig.FOLLOW_SYSTEM -&gt; isSystemInDarkTheme()\n        DarkThemeConfig.LIGHT -&gt; false\n        DarkThemeConfig.DARK -&gt; true\n    &#125;\n&#125;\n</code></pre>\n<p>然后开启一个DisposableEffect来关联上面这两个对象：</p>\n<pre><code class=\"line-numbers language-Kotlin\">  /**\n             * disposable，顾名思义，这就是一个自带清理作用的Effect\n             */\n            DisposableEffect(systemUiController, darkTheme) &#123;\n                // 否与导航栏图标+内容是否“黑暗&quot;\n                systemUiController.systemBarsDarkContentEnabled = !darkTheme\n                onDispose &#123;&#125;\n            &#125;\n</code></pre>\n<p>最后，开始设置App主题了：</p>\n<pre><code class=\"line-numbers language-Kotlin\">  /**\n             * 主题配置，是否暗色，判断用户是否有自己选择\n             * 是否用Android主题\n             * 下面这些代码才是内容区的布局，上面MainActivityUiState 这个只是拿用户的持久化数据，槽了\n             */\n            NiaTheme(\n                darkTheme = darkTheme,\n                androidTheme = shouldUseAndroidTheme(uiState)\n            ) &#123;\n                // NiaApp是一个闭包，作为第三个参数\n                NiaApp(\n                    /**\n                     * 窗口大小类，获取一个WindowSizeClass 这个实例\n                     */\n                    windowSizeClass = calculateWindowSizeClass(this),\n                    /**\n                     * 网络监视器，前面注入的\n                     */\n                    networkMonitor = networkMonitor,\n                )\n            &#125;\n</code></pre>\n<p>里面的闭包 NiaApp也就是开启了我们的App。</p>\n<h3 id=\"6-首页其它生命周期\"><a href=\"#6-首页其它生命周期\" class=\"headerlink\" title=\"6.首页其它生命周期\"></a>6.首页其它生命周期</h3><pre><code class=\"line-numbers language-Kotlin\">  override fun onResume() &#123;\n        super.onResume()\n        /**\n         * 跟踪性能\n         */\n        lazyStats.get().isTrackingEnabled = true\n    &#125;\n\n    override fun onPause() &#123;\n        super.onPause()\n        /**\n         * 去除跟踪\n         */\n        lazyStats.get().isTrackingEnabled = false\n    &#125;\n</code></pre>\n<p>MainActivity内容就这么多了，非常指简洁。<br>布局交给NiaApp类处理了。</p>\n<p>其它对象初始化交给hilt处理了。</p>\n<p>主要就只开了个协程获取用户数据，而且优化闪屏页和loading的显示。</p>\n<h3 id=\"7-NiaTheme主题设置\"><a href=\"#7-NiaTheme主题设置\" class=\"headerlink\" title=\"7.NiaTheme主题设置\"></a>7.NiaTheme主题设置</h3><p>先是主题颜色：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> // 主题颜色\n    val colorScheme = when &#123;\n        // 判断当前 android主题是暗色还是浅色\n        androidTheme -&gt; if (darkTheme) DarkAndroidColorScheme else LightAndroidColorScheme\n        // 没有禁用动态主题并且支持动态主题\n        !disableDynamicTheming &amp;&amp; supportsDynamicTheming() -&gt; &#123;\n            val context = LocalContext.current\n            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)\n        &#125;\n        // 其它情况\n        else -&gt; if (darkTheme) DarkDefaultColorScheme else LightDefaultColorScheme\n    &#125;\n</code></pre>\n<p>渐变色:</p>\n<pre><code class=\"line-numbers language-Kotlin\">    // Gradient colors 渐变色\n    // 空渐变色\n    val emptyGradientColors = GradientColors(container = colorScheme.surfaceColorAtElevation(2.dp))\n    // 默认渐变色\n    val defaultGradientColors = GradientColors(\n        top = colorScheme.inverseOnSurface,\n        bottom = colorScheme.primaryContainer,\n        container = colorScheme.surface\n    )\n    // 渐变色\n    val gradientColors = when &#123;\n        androidTheme -&gt; if (darkTheme) DarkAndroidGradientColors else LightAndroidGradientColors\n        !disableDynamicTheming &amp;&amp; supportsDynamicTheming() -&gt; emptyGradientColors\n        else -&gt; defaultGradientColors\n    &#125;\n</code></pre>\n<p>最终设置到MaterialTheme里面：</p>\n<pre><code class=\"line-numbers language-Kotlin\">   // Composition locals\n    CompositionLocalProvider(\n        LocalGradientColors provides gradientColors,\n        LocalBackgroundTheme provides backgroundTheme\n    ) &#123;\n        MaterialTheme(\n            colorScheme = colorScheme,\n            typography = NiaTypography,\n            content = content\n        )\n    &#125;\n</code></pre>\n<h3 id=\"8-NiaApp状态定义\"><a href=\"#8-NiaApp状态定义\" class=\"headerlink\" title=\"8.NiaApp状态定义\"></a>8.NiaApp状态定义</h3><p>首先创建一个NiaApp实例。<br>入参：窗口大小类，网络监视器</p>\n<pre><code class=\"line-numbers language-Kotlin\"> NiaApp(\n                    /**\n                     * 窗口大小类，获取一个WindowSizeClass 这个实例\n                     */\n                    windowSizeClass = calculateWindowSizeClass(this),\n                    /**\n                     * 网络监视器，前面注入的\n                     */\n                    networkMonitor = networkMonitor,\n                )\n</code></pre>\n<p>这里是App首页ui样式。</p>\n<p>这里用到的状态作为第三个参数，作为app状态记录。</p>\n<p>函数定义如下：</p>\n<pre><code class=\"line-numbers language-Kotlin\">@OptIn(\n    ExperimentalMaterial3Api::class,\n    ExperimentalLayoutApi::class,\n    ExperimentalComposeUiApi::class,\n    ExperimentalLifecycleComposeApi::class\n)\n@Composable\nfun NiaApp(\n    windowSizeClass: WindowSizeClass,\n    networkMonitor: NetworkMonitor,\n    /**\n     * app状态记录\n     */\n    appState: NiaAppState = rememberNiaAppState(\n        networkMonitor = networkMonitor,\n        windowSizeClass = windowSizeClass\n    ),\n) \n</code></pre>\n<p>这里第三个参数已经默认实现了。</p>\n<p>就是用于app状态记录，调用了一个自定义的rememberNiaAppState方法。</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun rememberNiaAppState(\n    windowSizeClass: WindowSizeClass,\n    networkMonitor: NetworkMonitor,\n    coroutineScope: CoroutineScope = rememberCoroutineScope(),\n    /**\n     * 导航控制器\n     */\n    navController: NavHostController = rememberNavController()\n): NiaAppState &#123;\n    NavigationTrackingSideEffect(navController)\n    /**\n     * remember 里面参数可以任意，闭包里面的东西，就是remember返回的东西\n     */\n    return remember(navController, coroutineScope, windowSizeClass, networkMonitor) &#123;\n        NiaAppState(navController, coroutineScope, windowSizeClass, networkMonitor)\n    &#125;\n&#125;\n</code></pre>\n<p>这里默认实现了协程作用域，导航控制器，需要返回一个NiaAppState变量。</p>\n<p>这里通过remember闭包来返回这个变量。</p>\n<p>这个NiaAppState定义如下：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * 主要用于类似LiveData保存的数据\n * App状态记录，需要传入导航控制器，携程作用范围，window窗口大小\n */\n@Stable\nclass NiaAppState(\n    val navController: NavHostController,\n    val coroutineScope: CoroutineScope,\n    val windowSizeClass: WindowSizeClass,\n    networkMonitor: NetworkMonitor,\n) &#123;\n</code></pre>\n<p>类似LiveData，保存了首页必要的一些数据。</p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 当前在那个tab\n     */\n    val currentDestination: NavDestination?\n        @Composable get() = navController\n            .currentBackStackEntryAsState().value?.destination\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 通过在哪个tab，决定用哪个枚举类， TopLevelDestination是自己定义的枚举类\n     */\n    val currentTopLevelDestination: TopLevelDestination?\n        @Composable get() = when (currentDestination?.route) &#123;\n            forYouNavigationRoute -&gt; FOR_YOU\n            bookmarksRoute -&gt; BOOKMARKS\n            interestsRoute -&gt; INTERESTS\n            else -&gt; null\n        &#125;\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 是否展示设置弹框\n     */\n    var shouldShowSettingsDialog by mutableStateOf(false)\n        private set\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 是否展示底部bar\n     */\n    val shouldShowBottomBar: Boolean\n        get() = windowSizeClass.widthSizeClass == WindowWidthSizeClass.Compact ||\n            windowSizeClass.heightSizeClass == WindowHeightSizeClass.Compact\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\">  /**\n     * 是否展示水平左侧导航\n     */\n    val shouldShowNavRail: Boolean\n        get() = !shouldShowBottomBar\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 监控网络，是否断网\n     */\n    val isOffline = networkMonitor.isOnline\n        .map(Boolean::not)\n        .stateIn(\n            scope = coroutineScope,\n            started = SharingStarted.WhileSubscribed(5_000),\n            initialValue = false\n        )\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\">   /**\n     * 这里是一个枚举类，表示底部tab集合\n     * Map of top level destinations to be used in the TopBar, BottomBar and NavRail. The key is the\n     * route.\n     */\n    val topLevelDestinations: List&lt;TopLevelDestination&gt; = TopLevelDestination.values().asList()\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 点击tab事件传递\n     *\n     * @param topLevelDestination: The destination the app needs to navigate to.\n     */\n    fun navigateToTopLevelDestination(topLevelDestination: TopLevelDestination) &#123;\n        trace(&quot;Navigation: $&#123;topLevelDestination.name&#125;&quot;) &#123;\n            val topLevelNavOptions = navOptions &#123;\n                // Pop up to the start destination of the graph to\n                // avoid building up a large stack of destinations\n                // on the back stack as users select items\n                popUpTo(navController.graph.findStartDestination().id) &#123;\n                    saveState = true\n                &#125;\n                // Avoid multiple copies of the same destination when\n                // reselecting the same item\n                launchSingleTop = true\n                // Restore state when reselecting a previously selected item\n                restoreState = true\n            &#125;\n\n            when (topLevelDestination) &#123;\n                FOR_YOU -&gt; navController.navigateToForYou(topLevelNavOptions)\n                BOOKMARKS -&gt; navController.navigateToBookmarks(topLevelNavOptions)\n                INTERESTS -&gt; navController.navigateToInterestsGraph(topLevelNavOptions)\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>然后定义了一些方法：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 返回点击\n     */\n    fun onBackClick() &#123;\n        navController.popBackStack()\n    &#125;\n\n    /**\n     * 改变设置弹框状态\n     */\n    fun setShowSettingsDialog(shouldShow: Boolean) &#123;\n        shouldShowSettingsDialog = shouldShow\n    &#125;\n</code></pre>\n<h3 id=\"9-NiaApp内容区\"><a href=\"#9-NiaApp内容区\" class=\"headerlink\" title=\"9.NiaApp内容区\"></a>9.NiaApp内容区</h3><p>App背景色</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun NiaBackground(\n    modifier: Modifier = Modifier,\n    content: @Composable () -&gt; Unit\n) &#123;\n    val color = LocalBackgroundTheme.current.color\n    val tonalElevation = LocalBackgroundTheme.current.tonalElevation\n    Surface(\n        color = if (color == Color.Unspecified) Color.Transparent else color,\n        tonalElevation = if (tonalElevation == Dp.Unspecified) 0.dp else tonalElevation,\n        modifier = modifier.fillMaxSize(),\n    ) &#123;\n        CompositionLocalProvider(LocalAbsoluteTonalElevation provides 0.dp) &#123;\n            content()\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>数据源使用 LocalBackgroundTheme.current.color</p>\n<p>内容区继续渐变背景：</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun NiaGradientBackground(\n    modifier: Modifier = Modifier,\n    gradientColors: GradientColors = LocalGradientColors.current,\n    content: @Composable () -&gt; Unit\n) &#123;\n    val currentTopColor by rememberUpdatedState(gradientColors.top)\n    val currentBottomColor by rememberUpdatedState(gradientColors.bottom)\n    Surface(\n        color = if (gradientColors.container == Color.Unspecified) &#123;\n            Color.Transparent\n        &#125; else &#123;\n            gradientColors.container\n        &#125;,\n        modifier = modifier.fillMaxSize()\n    ) &#123;\n        Box(\n            Modifier\n                .fillMaxSize()\n                .drawWithCache &#123;\n                    // Compute the start and end coordinates such that the gradients are angled 11.06\n                    // degrees off the vertical axis\n                    val offset = size.height * tan(\n                        Math\n                            .toRadians(11.06)\n                            .toFloat()\n                    )\n\n                    val start = Offset(size.width / 2 + offset / 2, 0f)\n                    val end = Offset(size.width / 2 - offset / 2, size.height)\n\n                    // Create the top gradient that fades out after the halfway point vertically\n                    val topGradient = Brush.linearGradient(\n                        0f to if (currentTopColor == Color.Unspecified) &#123;\n                            Color.Transparent\n                        &#125; else &#123;\n                            currentTopColor\n                        &#125;,\n                        0.724f to Color.Transparent,\n                        start = start,\n                        end = end,\n                    )\n                    // Create the bottom gradient that fades in before the halfway point vertically\n                    val bottomGradient = Brush.linearGradient(\n                        0.2552f to Color.Transparent,\n                        1f to if (currentBottomColor == Color.Unspecified) &#123;\n                            Color.Transparent\n                        &#125; else &#123;\n                            currentBottomColor\n                        &#125;,\n                        start = start,\n                        end = end,\n                    )\n\n                    onDrawBehind &#123;\n                        // There is overlap here, so order is important\n                        drawRect(topGradient)\n                        drawRect(bottomGradient)\n                    &#125;\n                &#125;\n        ) &#123;\n            content()\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里在上面0到0.724区间设置了topGradient<br>在0.2552f到1设置了 bottomGradient</p>\n<h3 id=\"10-业务内容区\"><a href=\"#10-业务内容区\" class=\"headerlink\" title=\"10.业务内容区\"></a>10.业务内容区</h3><pre><code class=\"line-numbers language-Kotlin\">   // 记录下snackbar状态，后续可能会刷新\n            val snackbarHostState = remember &#123; SnackbarHostState() &#125;\n</code></pre>\n<p>这个用于网络监听，如果没有网络，底部会常驻一个snackbar</p>\n<pre><code class=\"line-numbers language-Kotlin\">            // 是否离线\n            val isOffline by appState.isOffline.collectAsStateWithLifecycle()\n\n            // If user is not connected to the internet show a snack bar to inform them.\n            // 如果没有网络，底部展示Snackbar\n            val notConnectedMessage = stringResource(R.string.not_connected)\n            // 这个是Compose里面的launch，compose开启携程的方法\n            LaunchedEffect(isOffline) &#123;\n                if (isOffline) snackbarHostState.showSnackbar(\n                    message = notConnectedMessage,\n                    duration = Indefinite\n                )\n            &#125;\n</code></pre>\n<p>Kotlin<br>            &#x2F;&#x2F; 是否应该展示设置弹框，当点击右上角设置后，会弹出设置弹框<br>            if (appState.shouldShowSettingsDialog) {<br>                SettingsDialog(<br>                    onDismiss &#x3D; { appState.setShowSettingsDialog(false) }<br>                )<br>            }</p>\n<pre><code>\n然后就是脚手架了：\nScaffold，这里可以配置底部bar\n```Kotlin\n  Scaffold(\n                modifier = Modifier.semantics &#123;\n                    testTagsAsResourceId = true\n                &#125;,\n                containerColor = Color.Transparent,\n                contentColor = MaterialTheme.colorScheme.onBackground,\n                contentWindowInsets = WindowInsets(0, 0, 0, 0),\n                snackbarHost = &#123; SnackbarHost(snackbarHostState) &#125;,\n                // 底部bar 设置destinations，就是底部tab数据\n                bottomBar = &#123;\n                    if (appState.shouldShowBottomBar) &#123;\n                        NiaBottomBar(\n                            destinations = appState.topLevelDestinations,\n                            onNavigateToDestination = appState::navigateToTopLevelDestination,\n                            currentDestination = appState.currentDestination,\n                            modifier = Modifier.testTag(&quot;NiaBottomBar&quot;)\n                        )\n                    &#125;\n                &#125;\n            )\n</code></pre>\n<p>这里snackbarHost也是脚手架里面的内容。</p>\n<p>然后里面是一个Row，为什么是一个水平布局，因为考虑到兼容电视，平板，这里将导航页设置了一个水平的左侧导航。</p>\n<pre><code class=\"line-numbers language-Kotlin\">  // 平板 水平布局 左侧导航\n                    if (appState.shouldShowNavRail) &#123;\n                        NiaNavRail(\n                            destinations = appState.topLevelDestinations,\n                            onNavigateToDestination = appState::navigateToTopLevelDestination,\n                            currentDestination = appState.currentDestination,\n                            modifier = Modifier\n                                .testTag(&quot;NiaNavRail&quot;)\n                                .safeDrawingPadding()\n                        )\n                    &#125;\n</code></pre>\n<p>然后就是实际内容区域了：<br>设置+主页构成。</p>\n<pre><code class=\"line-numbers language-Kotlin\">// 垂直布局，状态栏+内容区\n                    /**\n                     * 以前，我们在布局中去设置一个控件的大小，间距，点击事件，宽高，背景等属性值。\n                     * 而在Compose中我们是通过Modifie去设置，Modifie相当于一个控件的属性配置的工具类。\n                     */\n                    Column(Modifier.fillMaxSize()) &#123;\n                        // Show the top app bar on top level destinations.\n                        val destination = appState.currentTopLevelDestination\n                        if (destination != null) &#123;\n                            NiaTopAppBar(\n                                titleRes = destination.titleTextId,\n                                actionIcon = NiaIcons.Settings,\n                                actionIconContentDescription = stringResource(\n                                    id = settingsR.string.top_app_bar_action_icon_description\n                                ),\n                                colors = TopAppBarDefaults.centerAlignedTopAppBarColors(\n                                    containerColor = Color.Transparent\n                                ),\n                                /**\n                                 * 设置点击事件触发appState中的 mutableStateOf变量发生更改\n                                 */\n                                onActionClick = &#123; appState.setShowSettingsDialog(true) &#125;\n                            )\n                        &#125;\n\n                        // 主页面\n                        NiaNavHost(\n                            navController = appState.navController,\n                            onBackClick = appState::onBackClick\n                        )\n                    &#125;\n</code></pre>\n<p>NiaTopAppBar是自定义顶部标题栏<br>NiaNavHost是主页面</p>\n<p>主页面也是在App模块下的navigation文件夹中定义。</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun NiaNavHost(\n    /**\n     * 导航控制器\n     */\n    navController: NavHostController,\n    /**\n     * 返回点击\n     */\n    onBackClick: () -&gt; Unit,\n    /**\n     * 属性配置工具\n     */\n    modifier: Modifier = Modifier,\n    /**\n     * 开始路由设置\n     */\n    startDestination: String = forYouNavigationRoute\n) &#123;\n    NavHost(\n        navController = navController,\n        startDestination = startDestination,\n        modifier = modifier,\n    ) &#123;\n        forYouScreen()\n        bookmarksScreen()\n        interestsGraph(\n            navigateToTopic = &#123; topicId -&gt;\n                navController.navigateToTopic(topicId)\n            &#125;,\n            nestedGraphs = &#123;\n                topicScreen(onBackClick)\n            &#125;\n        )\n    &#125;\n&#125;\n</code></pre>\n<p>这里使用了一个NavHost 的compose官方组件。</p>\n<p>tab实现为：<br>forYouScreen 你的模块<br>bookmarksScreen 书签模块<br>interestsGraph 兴趣模块</p>\n<p>这几个tab都是依赖于其它module了。<br>app自身module大致内容就这么多了。</p>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<blockquote>\n<p>googe samples之 nowinandroid项目地址：<a href=\"https://github.com/android/nowinandroid\">https://github.com/android/nowinandroid</a></p>\n</blockquote>\n<h3 id=\"1-app模块build-gradle文件配置\"><a href=\"#1-app模块build-gradle文件配置\" class=\"headerlink\" title=\"1.app模块build.gradle文件配置\"></a>1.app模块build.gradle文件配置</h3><pre><code class=\"line-numbers language-Groovy\">plugins &#123;\n    id(&quot;nowinandroid.android.application&quot;)\n    id(&quot;nowinandroid.android.application.compose&quot;)\n    id(&quot;nowinandroid.android.application.jacoco&quot;)\n    id(&quot;nowinandroid.android.hilt&quot;)\n    id(&quot;jacoco&quot;)\n    id(&quot;nowinandroid.firebase-perf&quot;)\n&#125;\n</code></pre>\n<p>引入了application插件，compose插件，jacoco插件，hilt插件，firebase插件</p>\n<p>依赖项：</p>\n<pre><code class=\"line-numbers language-Groovy\">    implementation(project(&quot;:feature:interests&quot;))\n    implementation(project(&quot;:feature:foryou&quot;))\n    implementation(project(&quot;:feature:bookmarks&quot;))\n    implementation(project(&quot;:feature:topic&quot;))\n    implementation(project(&quot;:feature:settings&quot;))\n\n    implementation(project(&quot;:core:common&quot;))\n    implementation(project(&quot;:core:ui&quot;))\n    implementation(project(&quot;:core:designsystem&quot;))\n    implementation(project(&quot;:core:data&quot;))\n    implementation(project(&quot;:core:model&quot;))\n\n    implementation(project(&quot;:sync:work&quot;))\n</code></pre>\n<p>feature文件夹下是app模块的界面上拆分组件。<br>如feature_interests 就是兴趣tab<br>feature_foryou 就是第一个tab<br>feature_bookmarks 是书签模块<br>等等</p>\n<p>下面的core就是核心模块了，有通用组件，ui组件，设计系统，数据区</p>\n<p>然后sync_work是一些工具module了。</p>\n<h3 id=\"2-清单文件\"><a href=\"#2-清单文件\" class=\"headerlink\" title=\"2.清单文件\"></a>2.清单文件</h3><pre><code class=\"line-numbers language-xml\">    &lt;application\n        android:name=&quot;.NiaApplication&quot;\n        android:allowBackup=&quot;true&quot;\n        android:enableOnBackInvokedCallback=&quot;true&quot;\n        android:icon=&quot;@mipmap/ic_launcher&quot;\n        android:label=&quot;@string/app_name&quot;\n        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;\n        android:supportsRtl=&quot;true&quot;\n        android:theme=&quot;@style/Theme.Nia.Splash&quot;&gt;\n&lt;!--        Profileable 是 Android 10 中引入的清单配置，可用于 CPU 和内存分析任务。使用 profileable 标志而不是 debuggable 标志具有降低性能开销的关键优势；--&gt;\n        &lt;profileable android:shell=&quot;true&quot; tools:targetApi=&quot;q&quot; /&gt;\n\n        &lt;activity\n            android:name=&quot;.MainActivity&quot;\n            android:exported=&quot;true&quot;&gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;\n\n                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n    &lt;/application&gt;\n</code></pre>\n<p>这里很简单，就一个Application自定义的，一个首页，说明这个App就一个Activity。<br>这里引入了一个profileable标签，是Android10后引入的，可以用于CPU和内存分析任务。</p>\n<h3 id=\"3-自定义Application\"><a href=\"#3-自定义Application\" class=\"headerlink\" title=\"3.自定义Application\"></a>3.自定义Application</h3><p>这里App开始启动了。<br>首先是用了一个HiltAndroidApp的注解。<br>这个是类似Dragger的依赖注解框架，这里要求在Application用这个注解。<br>关于Hilt用法可参考：<a href=\"https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn\">https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn</a></p>\n<p>这里在Application里面初始化了一个东西：<br><code>Sync.initialize(context = this)</code><br>作用就是初始化Sync三方库。</p>\n<p>里面是这样走的：</p>\n<pre><code class=\"line-numbers language-Kotlin\">  AppInitializer.getInstance(context)\n            .initializeComponent(SyncInitializer::class.java)\n</code></pre>\n<p>AppInitializer是google的Jetpack下的startup中的类成员，关于这个用法可以参考下郭霖的博客：<a href=\"https://blog.csdn.net/guolin_blog/article/details/108026357\">https://blog.csdn.net/guolin_blog&#x2F;article&#x2F;details&#x2F;108026357</a></p>\n<p>为什么要引入这个同步的库呢？<br>&#x2F;**</p>\n<ul>\n<li>Registers work to sync the data layer periodically on app startup.</li>\n<li>初始化三方库 这里是WorkManager，主要用于</li>\n<li>Android出于设备电量的考虑，为开发者提供了WorkManager，旨在将一些不需要及时完成的任务交给它来完成。</li>\n<li>虽然WorkManager宣称，能够保证任务得到执行，但我在真实设备中，发现应用程序彻底退出与重启设备，任务都没有再次执行。</li>\n<li>查阅了相关资料，发现这应该与系统有关系。我们前面也提到了，WorkManager会根据系统的版本，</li>\n<li>决定采用JobScheduler或是AlarmManager+Broadcast Receivers来完成任务。</li>\n<li>但是这些API很可能会受到OEM系统的影响。比如，假设某个系统不允许AlarmManager自动唤起，那么WorkManager很可能就无法正常使用。<br> *&#x2F;</li>\n</ul>\n<h3 id=\"4-MainActivity-参数定义\"><a href=\"#4-MainActivity-参数定义\" class=\"headerlink\" title=\"4.MainActivity 参数定义\"></a>4.MainActivity 参数定义</h3><p> Application走完，就到了Activity了。<br> 首先是两个注解：</p>\n<ol>\n<li><p>@OptIn(ExperimentalMaterial3WindowSizeClassApi::class)<br> Opt-in 是 Kotlin 标准库中的一个方法，用于声明使用某些 API 需要明确的同意。<br>  该功能可以让开发者告知 API 使用者使用某些 API 需要一些特定的条件，如果使用者已经知晓则需要明确声明依旧使用（Opt-in）才能继续使用该 API。<br>  例如，某些 API 尚处于测试阶段，未来可能会发生变化；亦或是我前言中提到的场景，都非常适合使用该方法。<br>  如果我们声明了某个方法（functiuon）或类(class)需要 Opt-in ，则IDE或编译器会发出警告，要求使用者明确标注需要使用（Opt-in）。<br>  参考文档：<a href=\"https://juejin.cn/post/7157950373250990093\">https://juejin.cn/post/7157950373250990093</a></p>\n</li>\n<li><p>@AndroidEntryPoint<br>在要使用依赖注入的类上方添加@AndroidEntryPoint注解<br>参考文档：<a href=\"https://www.jianshu.com/p/22a36660a656\">https://www.jianshu.com/p/22a36660a656</a></p>\n</li>\n</ol>\n<p>然后声明了两个注入的变量：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n     * Lazily inject [JankStats], which is used to track jank throughout the app.\n     * JankStats 是首个专为在用户设备上检测及报告应用的性能问题而构建的 AndroidX 库。\n     * JankStats 是占用空间相对较小的 API，主要有三大目标: 捕获每帧的性能信息、在用户设备 (不仅是开发设备) 上运行、以及在应用出现性能问题时启用检测，并报告所发生的情况\n     *\n     * 在Dagger中Lazy可以将要注入的依赖项转变为懒加载模式，这样注入的依赖项，只有在需要使用时，\n     * 才会调用对应的依赖生成方法。懒加载的实现很简单，只需要在注入位置将依赖项的类型设置为Lazy接口的类型参数即可。\n     *\n     * 构造函数在di 文件夹下的 JankStatsModule 下\n     */\n    @Inject\n    lateinit var lazyStats: dagger.Lazy&lt;JankStats&gt;\n\n    /**\n     * 自定义网络监视器 这个是一个接口 应该也是测试用的\n     */\n    @Inject\n    lateinit var networkMonitor: NetworkMonitor\n</code></pre>\n<p> 关于lazyStats怎么初始化的？在项目di文件夹下有个JankStatsModule</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * 这里的目标是生产一个JankStats对象\n *\n * 怎么生产呢，需要2个构造参数\n * 1.JankStats.OnFrameListener\n * 2.Window\n *\n * window需要依赖activity，这里就需要 ActivityComponent了\n * 这个JankStats对象的生命周期设定为Activity级别\n */\n@Module\n@InstallIn(ActivityComponent::class)\nobject JankStatsModule &#123;\n    @Provides\n    fun providesOnFrameListener(): JankStats.OnFrameListener &#123;\n        return JankStats.OnFrameListener &#123; frameData -&gt;\n            // Make sure to only log janky frames.\n            if (frameData.isJank) &#123;\n                // We&#39;re currently logging this but would better report it to a backend.\n                Log.v(&quot;NiA Jank&quot;, frameData.toString())\n            &#125;\n        &#125;\n    &#125;\n\n    @Provides\n    fun providesWindow(activity: Activity): Window &#123;\n        return activity.window\n    &#125;\n\n    @Provides\n    fun providesJankStats(\n        window: Window,\n        frameListener: JankStats.OnFrameListener\n    ): JankStats &#123;\n        return JankStats.createAndTrack(window, frameListener)\n    &#125;\n&#125;\n</code></pre>\n<p>这里生产了  一个JankStats对象。</p>\n<p>关于网络监视器如何初始化的呢？<br>这个网络监视器是一个接口来的：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * Utility for reporting app connectivity status\n */\ninterface NetworkMonitor &#123;\n    val isOnline: Flow&lt;Boolean&gt;\n&#125;\n</code></pre>\n<p>一直没找到如何实例化的地方。<br>不过再其它模块，core下的data.di文件夹下发现了另外一个DataModule下有如下代码：</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n    @Binds\n    fun bindsNetworkMonitor(\n        networkMonitor: ConnectivityManagerNetworkMonitor\n    ): NetworkMonitor\n</code></pre>\n<p>这里貌似可以生产一个NetworkMonitor对象。<br>但怎么关联起来的呢？</p>\n<p>这个我确实不清楚hilt的用法，而且这个DataModule理应需要在Application配置，但也没找到相关依赖，可能hilt对加上这种注解能全局自动生成依赖代码也说不定。反正这里的网络监视器应该就是这个ConnectivityManagerNetworkMonitor 主要逻辑也在这里。</p>\n<p>第三个变量是viewModel<br><code> val viewModel: MainActivityViewModel by viewModels()</code><br>这个用法类似：<br><code>ViewModelProvider(this).get(MainActivityViewModel::class.java)</code></p>\n<h3 id=\"5-首页生命周期-onCreate\"><a href=\"#5-首页生命周期-onCreate\" class=\"headerlink\" title=\"5.首页生命周期-onCreate\"></a>5.首页生命周期-onCreate</h3><p>继续走，第一行是 适配闪屏页 installSplashScreen()<br>关于闪屏页可参考文档：<a href=\"https://blog.csdn.net/guolin_blog/article/details/120275319\">https://blog.csdn.net/guolin_blog&#x2F;article&#x2F;details&#x2F;120275319</a>（郭霖）</p>\n<p>然后这里监听了一个密封接口中的 Loading 状态，<br>密封接口定义如下：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * 首页ui 状态的密封类，有加载中和成功的状态\n * 密封接口 类似枚举类型，说明有Loading状态和成功状态\n * 表示受限制的类层次结构\n */\nsealed interface MainActivityUiState &#123;\n    object Loading : MainActivityUiState\n    data class Success(val userData: UserData) : MainActivityUiState\n&#125;\n</code></pre>\n<p>很明显这里Loading实现了这个接口，Success也实现了这个接口。</p>\n<p>在onCreate监听了这个Loading类：</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n        /**\n         * mutableStateOf 表明某个变量是有状态的，对变量进行监听，当状态改变时，触发重绘。\n         * remember --- 记录变量的值，使得下次使用改变量时不进行初始化。\n         * 使用 remember 存储对象的可组合项会创建内部状态，使该可组合项有状态。\n         * remember 会为函数提供存储空间，将 remember 计算的值储存，当 remember 的键改变的时候会进行重新计算值并储存。\n         * rememberSaveable --- 在这里顺带提一下,rememberSaveable 可以在重组后保持状态,也可以在重新创建 activity 和进程后保持状态。\n         */\n        var uiState: MainActivityUiState by mutableStateOf(Loading)\n</code></pre>\n<p>然后开启一个携程，拿用户数据：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> // Activity生命周期内使用携程\n        lifecycleScope.launch &#123;\n            // Lifecycle.State.STARTED: 表示只有在Activity处于Started状态的情况下，协程中的代码才会执行。\n            lifecycle.repeatOnLifecycle(Lifecycle.State.STARTED) &#123;\n                viewModel.uiState\n                    .onEach &#123;\n                        uiState = it\n                    &#125;\n                    .collect() // 走collect方法才代表执行携程\n            &#125;\n        &#125;\n</code></pre>\n<p>拿到数据后，才回去更新uiState对象。</p>\n<p>就是说uiState会有上面密封接口定义的两种类型。</p>\n<p>当监听到uiState变化后会走：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n         * 如果网络请求正在请求loading状态，就还是显示闪屏，如果拿到数据了就不需要闪屏了\n         */\n        splashScreen.setKeepOnScreenCondition &#123;\n            when (uiState) &#123;\n                Loading -&gt; true\n                is Success -&gt; false\n            &#125;\n        &#125;\n</code></pre>\n<p>闪屏会去除掉。</p>\n<p>下面开启沉浸式状态栏：</p>\n<pre><code class=\"line-numbers language-Kotlin\">  /**\n         * 第二参数decorFitsSystemWindows表示是否沉浸，false 表示沉浸，true表示不沉浸\n         */\n        WindowCompat.setDecorFitsSystemWindows(window, false)\n</code></pre>\n<p>然后就是内容区，compose设置内容区了<br>一个setContent的函数，太长了，就不全部贴图，挨个分析。</p>\n<p>1.首先获取一个systemUIController</p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n             * 开发者若想在 Compose 布局中控制 System UI，就必须获取 SystemUiController 对象。\n             * 通过该库提供 rememberSystemUiController 函数，开发者可以获取当前操作系统（目前仅支持 Android 系统）的  SystemUiController 对象。\n             */\n            val systemUiController = rememberSystemUiController()\n</code></pre>\n<p>2.是否使用深色主题，用户可以自己选</p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n             * 是否使用深色主题，入参当前ui状态\n             */\n            val darkTheme = shouldUseDarkTheme(uiState)\n            \n</code></pre>\n<p>内部实现：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * Returns `true` if dark theme should be used, as a function of the [uiState] and the\n * current system context.\n * 调用@Composable 函数的函数必须用@Composable 注解标记\n */\n@Composable\nprivate fun shouldUseDarkTheme(\n    uiState: MainActivityUiState,\n): Boolean = when (uiState) &#123;\n    /**\n     * isSystemInDarkTheme 根据系统来，加载中状态\n     */\n    Loading -&gt; isSystemInDarkTheme()\n    is Success -&gt; when (uiState.userData.darkThemeConfig) &#123;\n        /**\n         * 成功状态下，根据用户配置的数据来展示，如果跟随系统那就跟随，如果用户主动设置了某一种，那就成功时选择\n         */\n        DarkThemeConfig.FOLLOW_SYSTEM -&gt; isSystemInDarkTheme()\n        DarkThemeConfig.LIGHT -&gt; false\n        DarkThemeConfig.DARK -&gt; true\n    &#125;\n&#125;\n</code></pre>\n<p>然后开启一个DisposableEffect来关联上面这两个对象：</p>\n<pre><code class=\"line-numbers language-Kotlin\">  /**\n             * disposable，顾名思义，这就是一个自带清理作用的Effect\n             */\n            DisposableEffect(systemUiController, darkTheme) &#123;\n                // 否与导航栏图标+内容是否“黑暗&quot;\n                systemUiController.systemBarsDarkContentEnabled = !darkTheme\n                onDispose &#123;&#125;\n            &#125;\n</code></pre>\n<p>最后，开始设置App主题了：</p>\n<pre><code class=\"line-numbers language-Kotlin\">  /**\n             * 主题配置，是否暗色，判断用户是否有自己选择\n             * 是否用Android主题\n             * 下面这些代码才是内容区的布局，上面MainActivityUiState 这个只是拿用户的持久化数据，槽了\n             */\n            NiaTheme(\n                darkTheme = darkTheme,\n                androidTheme = shouldUseAndroidTheme(uiState)\n            ) &#123;\n                // NiaApp是一个闭包，作为第三个参数\n                NiaApp(\n                    /**\n                     * 窗口大小类，获取一个WindowSizeClass 这个实例\n                     */\n                    windowSizeClass = calculateWindowSizeClass(this),\n                    /**\n                     * 网络监视器，前面注入的\n                     */\n                    networkMonitor = networkMonitor,\n                )\n            &#125;\n</code></pre>\n<p>里面的闭包 NiaApp也就是开启了我们的App。</p>\n<h3 id=\"6-首页其它生命周期\"><a href=\"#6-首页其它生命周期\" class=\"headerlink\" title=\"6.首页其它生命周期\"></a>6.首页其它生命周期</h3><pre><code class=\"line-numbers language-Kotlin\">  override fun onResume() &#123;\n        super.onResume()\n        /**\n         * 跟踪性能\n         */\n        lazyStats.get().isTrackingEnabled = true\n    &#125;\n\n    override fun onPause() &#123;\n        super.onPause()\n        /**\n         * 去除跟踪\n         */\n        lazyStats.get().isTrackingEnabled = false\n    &#125;\n</code></pre>\n<p>MainActivity内容就这么多了，非常指简洁。<br>布局交给NiaApp类处理了。</p>\n<p>其它对象初始化交给hilt处理了。</p>\n<p>主要就只开了个协程获取用户数据，而且优化闪屏页和loading的显示。</p>\n<h3 id=\"7-NiaTheme主题设置\"><a href=\"#7-NiaTheme主题设置\" class=\"headerlink\" title=\"7.NiaTheme主题设置\"></a>7.NiaTheme主题设置</h3><p>先是主题颜色：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> // 主题颜色\n    val colorScheme = when &#123;\n        // 判断当前 android主题是暗色还是浅色\n        androidTheme -&gt; if (darkTheme) DarkAndroidColorScheme else LightAndroidColorScheme\n        // 没有禁用动态主题并且支持动态主题\n        !disableDynamicTheming &amp;&amp; supportsDynamicTheming() -&gt; &#123;\n            val context = LocalContext.current\n            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)\n        &#125;\n        // 其它情况\n        else -&gt; if (darkTheme) DarkDefaultColorScheme else LightDefaultColorScheme\n    &#125;\n</code></pre>\n<p>渐变色:</p>\n<pre><code class=\"line-numbers language-Kotlin\">    // Gradient colors 渐变色\n    // 空渐变色\n    val emptyGradientColors = GradientColors(container = colorScheme.surfaceColorAtElevation(2.dp))\n    // 默认渐变色\n    val defaultGradientColors = GradientColors(\n        top = colorScheme.inverseOnSurface,\n        bottom = colorScheme.primaryContainer,\n        container = colorScheme.surface\n    )\n    // 渐变色\n    val gradientColors = when &#123;\n        androidTheme -&gt; if (darkTheme) DarkAndroidGradientColors else LightAndroidGradientColors\n        !disableDynamicTheming &amp;&amp; supportsDynamicTheming() -&gt; emptyGradientColors\n        else -&gt; defaultGradientColors\n    &#125;\n</code></pre>\n<p>最终设置到MaterialTheme里面：</p>\n<pre><code class=\"line-numbers language-Kotlin\">   // Composition locals\n    CompositionLocalProvider(\n        LocalGradientColors provides gradientColors,\n        LocalBackgroundTheme provides backgroundTheme\n    ) &#123;\n        MaterialTheme(\n            colorScheme = colorScheme,\n            typography = NiaTypography,\n            content = content\n        )\n    &#125;\n</code></pre>\n<h3 id=\"8-NiaApp状态定义\"><a href=\"#8-NiaApp状态定义\" class=\"headerlink\" title=\"8.NiaApp状态定义\"></a>8.NiaApp状态定义</h3><p>首先创建一个NiaApp实例。<br>入参：窗口大小类，网络监视器</p>\n<pre><code class=\"line-numbers language-Kotlin\"> NiaApp(\n                    /**\n                     * 窗口大小类，获取一个WindowSizeClass 这个实例\n                     */\n                    windowSizeClass = calculateWindowSizeClass(this),\n                    /**\n                     * 网络监视器，前面注入的\n                     */\n                    networkMonitor = networkMonitor,\n                )\n</code></pre>\n<p>这里是App首页ui样式。</p>\n<p>这里用到的状态作为第三个参数，作为app状态记录。</p>\n<p>函数定义如下：</p>\n<pre><code class=\"line-numbers language-Kotlin\">@OptIn(\n    ExperimentalMaterial3Api::class,\n    ExperimentalLayoutApi::class,\n    ExperimentalComposeUiApi::class,\n    ExperimentalLifecycleComposeApi::class\n)\n@Composable\nfun NiaApp(\n    windowSizeClass: WindowSizeClass,\n    networkMonitor: NetworkMonitor,\n    /**\n     * app状态记录\n     */\n    appState: NiaAppState = rememberNiaAppState(\n        networkMonitor = networkMonitor,\n        windowSizeClass = windowSizeClass\n    ),\n) \n</code></pre>\n<p>这里第三个参数已经默认实现了。</p>\n<p>就是用于app状态记录，调用了一个自定义的rememberNiaAppState方法。</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun rememberNiaAppState(\n    windowSizeClass: WindowSizeClass,\n    networkMonitor: NetworkMonitor,\n    coroutineScope: CoroutineScope = rememberCoroutineScope(),\n    /**\n     * 导航控制器\n     */\n    navController: NavHostController = rememberNavController()\n): NiaAppState &#123;\n    NavigationTrackingSideEffect(navController)\n    /**\n     * remember 里面参数可以任意，闭包里面的东西，就是remember返回的东西\n     */\n    return remember(navController, coroutineScope, windowSizeClass, networkMonitor) &#123;\n        NiaAppState(navController, coroutineScope, windowSizeClass, networkMonitor)\n    &#125;\n&#125;\n</code></pre>\n<p>这里默认实现了协程作用域，导航控制器，需要返回一个NiaAppState变量。</p>\n<p>这里通过remember闭包来返回这个变量。</p>\n<p>这个NiaAppState定义如下：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * 主要用于类似LiveData保存的数据\n * App状态记录，需要传入导航控制器，携程作用范围，window窗口大小\n */\n@Stable\nclass NiaAppState(\n    val navController: NavHostController,\n    val coroutineScope: CoroutineScope,\n    val windowSizeClass: WindowSizeClass,\n    networkMonitor: NetworkMonitor,\n) &#123;\n</code></pre>\n<p>类似LiveData，保存了首页必要的一些数据。</p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 当前在那个tab\n     */\n    val currentDestination: NavDestination?\n        @Composable get() = navController\n            .currentBackStackEntryAsState().value?.destination\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 通过在哪个tab，决定用哪个枚举类， TopLevelDestination是自己定义的枚举类\n     */\n    val currentTopLevelDestination: TopLevelDestination?\n        @Composable get() = when (currentDestination?.route) &#123;\n            forYouNavigationRoute -&gt; FOR_YOU\n            bookmarksRoute -&gt; BOOKMARKS\n            interestsRoute -&gt; INTERESTS\n            else -&gt; null\n        &#125;\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 是否展示设置弹框\n     */\n    var shouldShowSettingsDialog by mutableStateOf(false)\n        private set\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 是否展示底部bar\n     */\n    val shouldShowBottomBar: Boolean\n        get() = windowSizeClass.widthSizeClass == WindowWidthSizeClass.Compact ||\n            windowSizeClass.heightSizeClass == WindowHeightSizeClass.Compact\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\">  /**\n     * 是否展示水平左侧导航\n     */\n    val shouldShowNavRail: Boolean\n        get() = !shouldShowBottomBar\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 监控网络，是否断网\n     */\n    val isOffline = networkMonitor.isOnline\n        .map(Boolean::not)\n        .stateIn(\n            scope = coroutineScope,\n            started = SharingStarted.WhileSubscribed(5_000),\n            initialValue = false\n        )\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\">   /**\n     * 这里是一个枚举类，表示底部tab集合\n     * Map of top level destinations to be used in the TopBar, BottomBar and NavRail. The key is the\n     * route.\n     */\n    val topLevelDestinations: List&lt;TopLevelDestination&gt; = TopLevelDestination.values().asList()\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 点击tab事件传递\n     *\n     * @param topLevelDestination: The destination the app needs to navigate to.\n     */\n    fun navigateToTopLevelDestination(topLevelDestination: TopLevelDestination) &#123;\n        trace(&quot;Navigation: $&#123;topLevelDestination.name&#125;&quot;) &#123;\n            val topLevelNavOptions = navOptions &#123;\n                // Pop up to the start destination of the graph to\n                // avoid building up a large stack of destinations\n                // on the back stack as users select items\n                popUpTo(navController.graph.findStartDestination().id) &#123;\n                    saveState = true\n                &#125;\n                // Avoid multiple copies of the same destination when\n                // reselecting the same item\n                launchSingleTop = true\n                // Restore state when reselecting a previously selected item\n                restoreState = true\n            &#125;\n\n            when (topLevelDestination) &#123;\n                FOR_YOU -&gt; navController.navigateToForYou(topLevelNavOptions)\n                BOOKMARKS -&gt; navController.navigateToBookmarks(topLevelNavOptions)\n                INTERESTS -&gt; navController.navigateToInterestsGraph(topLevelNavOptions)\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>然后定义了一些方法：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 返回点击\n     */\n    fun onBackClick() &#123;\n        navController.popBackStack()\n    &#125;\n\n    /**\n     * 改变设置弹框状态\n     */\n    fun setShowSettingsDialog(shouldShow: Boolean) &#123;\n        shouldShowSettingsDialog = shouldShow\n    &#125;\n</code></pre>\n<h3 id=\"9-NiaApp内容区\"><a href=\"#9-NiaApp内容区\" class=\"headerlink\" title=\"9.NiaApp内容区\"></a>9.NiaApp内容区</h3><p>App背景色</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun NiaBackground(\n    modifier: Modifier = Modifier,\n    content: @Composable () -&gt; Unit\n) &#123;\n    val color = LocalBackgroundTheme.current.color\n    val tonalElevation = LocalBackgroundTheme.current.tonalElevation\n    Surface(\n        color = if (color == Color.Unspecified) Color.Transparent else color,\n        tonalElevation = if (tonalElevation == Dp.Unspecified) 0.dp else tonalElevation,\n        modifier = modifier.fillMaxSize(),\n    ) &#123;\n        CompositionLocalProvider(LocalAbsoluteTonalElevation provides 0.dp) &#123;\n            content()\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>数据源使用 LocalBackgroundTheme.current.color</p>\n<p>内容区继续渐变背景：</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun NiaGradientBackground(\n    modifier: Modifier = Modifier,\n    gradientColors: GradientColors = LocalGradientColors.current,\n    content: @Composable () -&gt; Unit\n) &#123;\n    val currentTopColor by rememberUpdatedState(gradientColors.top)\n    val currentBottomColor by rememberUpdatedState(gradientColors.bottom)\n    Surface(\n        color = if (gradientColors.container == Color.Unspecified) &#123;\n            Color.Transparent\n        &#125; else &#123;\n            gradientColors.container\n        &#125;,\n        modifier = modifier.fillMaxSize()\n    ) &#123;\n        Box(\n            Modifier\n                .fillMaxSize()\n                .drawWithCache &#123;\n                    // Compute the start and end coordinates such that the gradients are angled 11.06\n                    // degrees off the vertical axis\n                    val offset = size.height * tan(\n                        Math\n                            .toRadians(11.06)\n                            .toFloat()\n                    )\n\n                    val start = Offset(size.width / 2 + offset / 2, 0f)\n                    val end = Offset(size.width / 2 - offset / 2, size.height)\n\n                    // Create the top gradient that fades out after the halfway point vertically\n                    val topGradient = Brush.linearGradient(\n                        0f to if (currentTopColor == Color.Unspecified) &#123;\n                            Color.Transparent\n                        &#125; else &#123;\n                            currentTopColor\n                        &#125;,\n                        0.724f to Color.Transparent,\n                        start = start,\n                        end = end,\n                    )\n                    // Create the bottom gradient that fades in before the halfway point vertically\n                    val bottomGradient = Brush.linearGradient(\n                        0.2552f to Color.Transparent,\n                        1f to if (currentBottomColor == Color.Unspecified) &#123;\n                            Color.Transparent\n                        &#125; else &#123;\n                            currentBottomColor\n                        &#125;,\n                        start = start,\n                        end = end,\n                    )\n\n                    onDrawBehind &#123;\n                        // There is overlap here, so order is important\n                        drawRect(topGradient)\n                        drawRect(bottomGradient)\n                    &#125;\n                &#125;\n        ) &#123;\n            content()\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里在上面0到0.724区间设置了topGradient<br>在0.2552f到1设置了 bottomGradient</p>\n<h3 id=\"10-业务内容区\"><a href=\"#10-业务内容区\" class=\"headerlink\" title=\"10.业务内容区\"></a>10.业务内容区</h3><pre><code class=\"line-numbers language-Kotlin\">   // 记录下snackbar状态，后续可能会刷新\n            val snackbarHostState = remember &#123; SnackbarHostState() &#125;\n</code></pre>\n<p>这个用于网络监听，如果没有网络，底部会常驻一个snackbar</p>\n<pre><code class=\"line-numbers language-Kotlin\">            // 是否离线\n            val isOffline by appState.isOffline.collectAsStateWithLifecycle()\n\n            // If user is not connected to the internet show a snack bar to inform them.\n            // 如果没有网络，底部展示Snackbar\n            val notConnectedMessage = stringResource(R.string.not_connected)\n            // 这个是Compose里面的launch，compose开启携程的方法\n            LaunchedEffect(isOffline) &#123;\n                if (isOffline) snackbarHostState.showSnackbar(\n                    message = notConnectedMessage,\n                    duration = Indefinite\n                )\n            &#125;\n</code></pre>\n<p>Kotlin<br>            &#x2F;&#x2F; 是否应该展示设置弹框，当点击右上角设置后，会弹出设置弹框<br>            if (appState.shouldShowSettingsDialog) {<br>                SettingsDialog(<br>                    onDismiss &#x3D; { appState.setShowSettingsDialog(false) }<br>                )<br>            }</p>\n<pre><code>\n然后就是脚手架了：\nScaffold，这里可以配置底部bar\n```Kotlin\n  Scaffold(\n                modifier = Modifier.semantics &#123;\n                    testTagsAsResourceId = true\n                &#125;,\n                containerColor = Color.Transparent,\n                contentColor = MaterialTheme.colorScheme.onBackground,\n                contentWindowInsets = WindowInsets(0, 0, 0, 0),\n                snackbarHost = &#123; SnackbarHost(snackbarHostState) &#125;,\n                // 底部bar 设置destinations，就是底部tab数据\n                bottomBar = &#123;\n                    if (appState.shouldShowBottomBar) &#123;\n                        NiaBottomBar(\n                            destinations = appState.topLevelDestinations,\n                            onNavigateToDestination = appState::navigateToTopLevelDestination,\n                            currentDestination = appState.currentDestination,\n                            modifier = Modifier.testTag(&quot;NiaBottomBar&quot;)\n                        )\n                    &#125;\n                &#125;\n            )\n</code></pre>\n<p>这里snackbarHost也是脚手架里面的内容。</p>\n<p>然后里面是一个Row，为什么是一个水平布局，因为考虑到兼容电视，平板，这里将导航页设置了一个水平的左侧导航。</p>\n<pre><code class=\"line-numbers language-Kotlin\">  // 平板 水平布局 左侧导航\n                    if (appState.shouldShowNavRail) &#123;\n                        NiaNavRail(\n                            destinations = appState.topLevelDestinations,\n                            onNavigateToDestination = appState::navigateToTopLevelDestination,\n                            currentDestination = appState.currentDestination,\n                            modifier = Modifier\n                                .testTag(&quot;NiaNavRail&quot;)\n                                .safeDrawingPadding()\n                        )\n                    &#125;\n</code></pre>\n<p>然后就是实际内容区域了：<br>设置+主页构成。</p>\n<pre><code class=\"line-numbers language-Kotlin\">// 垂直布局，状态栏+内容区\n                    /**\n                     * 以前，我们在布局中去设置一个控件的大小，间距，点击事件，宽高，背景等属性值。\n                     * 而在Compose中我们是通过Modifie去设置，Modifie相当于一个控件的属性配置的工具类。\n                     */\n                    Column(Modifier.fillMaxSize()) &#123;\n                        // Show the top app bar on top level destinations.\n                        val destination = appState.currentTopLevelDestination\n                        if (destination != null) &#123;\n                            NiaTopAppBar(\n                                titleRes = destination.titleTextId,\n                                actionIcon = NiaIcons.Settings,\n                                actionIconContentDescription = stringResource(\n                                    id = settingsR.string.top_app_bar_action_icon_description\n                                ),\n                                colors = TopAppBarDefaults.centerAlignedTopAppBarColors(\n                                    containerColor = Color.Transparent\n                                ),\n                                /**\n                                 * 设置点击事件触发appState中的 mutableStateOf变量发生更改\n                                 */\n                                onActionClick = &#123; appState.setShowSettingsDialog(true) &#125;\n                            )\n                        &#125;\n\n                        // 主页面\n                        NiaNavHost(\n                            navController = appState.navController,\n                            onBackClick = appState::onBackClick\n                        )\n                    &#125;\n</code></pre>\n<p>NiaTopAppBar是自定义顶部标题栏<br>NiaNavHost是主页面</p>\n<p>主页面也是在App模块下的navigation文件夹中定义。</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun NiaNavHost(\n    /**\n     * 导航控制器\n     */\n    navController: NavHostController,\n    /**\n     * 返回点击\n     */\n    onBackClick: () -&gt; Unit,\n    /**\n     * 属性配置工具\n     */\n    modifier: Modifier = Modifier,\n    /**\n     * 开始路由设置\n     */\n    startDestination: String = forYouNavigationRoute\n) &#123;\n    NavHost(\n        navController = navController,\n        startDestination = startDestination,\n        modifier = modifier,\n    ) &#123;\n        forYouScreen()\n        bookmarksScreen()\n        interestsGraph(\n            navigateToTopic = &#123; topicId -&gt;\n                navController.navigateToTopic(topicId)\n            &#125;,\n            nestedGraphs = &#123;\n                topicScreen(onBackClick)\n            &#125;\n        )\n    &#125;\n&#125;\n</code></pre>\n<p>这里使用了一个NavHost 的compose官方组件。</p>\n<p>tab实现为：<br>forYouScreen 你的模块<br>bookmarksScreen 书签模块<br>interestsGraph 兴趣模块</p>\n<p>这几个tab都是依赖于其它module了。<br>app自身module大致内容就这么多了。</p>\n"},{"title":"Android gradle相关 KTS脚本 项目配置改造","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-01-13T05:39:50.000Z","_content":"\n> googe samples之 nowinandroid项目地址：[https://github.com/android/nowinandroid](https://github.com/android/nowinandroid)\n\n### 1.gradle.properties\n这里面配置了 android.useAndroidX等常用的配置，这里应该耳熟能详了，这里就不过多介绍。下面这里有一块不是特别熟悉：\n```groovy\n# Disable build features that are enabled by default,\n# https://developer.android.com/studio/releases/gradle-plugin#buildFeatures\nandroid.defaults.buildfeatures.buildconfig=false\nandroid.defaults.buildfeatures.aidl=false\nandroid.defaults.buildfeatures.renderscript=false\nandroid.defaults.buildfeatures.resvalues=false\nandroid.defaults.buildfeatures.shaders=false\n```\n\n通过关闭buildfeatures.buildconfig，来提升构建性能。有时候模块不需要生成buildconfig文件，那直接关闭即可。还有其它的aidl，renderscript，resvalues同理。\n\n\n### 2.项目settings.gradle.kts\n这里首先是一个pluginManagement闭包：\n```groovy\npluginManagement {\n    includeBuild(\"build-logic\") // 多模块共享模块\n    repositories {\n        google()\n        mavenCentral()\n        gradlePluginPortal()\n    }\n}\n```\n第一个问题是：pluginManagement是什么东西啊？没见过。\n简单来说：dependencyManagement用于在父项目中统一对子项目依赖管理。这样就可以对所有模块的版本进行管理。\n\n第二个问题是：includeBuild是什么？\n相信大部分人都有用过buildSrc吧。如果没有，那config.gradle总用过吧，总之就是把不同模块之前相同依赖抽出来，同时引用。 buildSrc的弊端就是每次依赖更新都将重新构建整个项目，导致编译时间很长，这里google官方推荐使用includeBuild来解决这个问题。\n\n然后gradlePluginProtal() 远程插件仓库，是google推荐的。\n\n第二块代码是这样的：\n```groovy\ndependencyResolutionManagement {\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories {\n        google()\n        mavenCentral()\n    }\n}\n```\n\n当您的依赖项不是本地库或文件树时，Gradle 会在 settings.gradle 文件的 dependencyResolutionManagement { repositories {...} } 代码块中指定的所有在线仓库中查找相关文件。 各个仓库的列出顺序决定了 Gradle 在这些仓库中搜索各个项目依赖项的顺序。例如，如果从仓库 A 和 B 均可获得某个依赖项，而您先列出了仓库 A，则 Gradle 会从仓库 A 下载该依赖项。说白了，就是有一个优先权，从上往下。\n\n然后这个文件其它内容没啥参考价值了，都是include多个模块。\n这个文件最重要也是最关键的地方就是 includeBuild(\"build-logic\")\n\n\n### 3.项目级build.gradle.kts\n首先是一个buildscript闭包：\n```groovy\nbuildscript {\n    repositories {\n        maven { url = uri(\"https://maven.aliyun.com/repository/public\") }\n        maven { url = uri(\"https://maven.aliyun.com/repository/gradle-plugin\") }\n        maven { url = uri(\"https://maven.aliyun.com/repository/central\") }\n        maven { url = uri(\"https://maven.aliyun.com/repository/google\") }\n\n        mavenCentral()\n        google()\n\n\n        // Android Build Server\n        maven { url = uri(\"../nowinandroid-prebuilts/m2repository\") }\n    }\n}\n```\n其实这里引发了另外一个问题：\n在项目根目录（root Project）下的build.gradle中：buildscript、allprojects、subprojects的repositories有什么区别？\n\n1. buildScript块的repositories主要是为了Gradle脚本自身的执行，获取脚本依赖插件。也就是说，buildScript是用来加载Gradle脚本自身需要使用的资源，可以声明的资源包括依赖项、第三方插件、maven仓库地址等。\n2. 根级别的repositories主要是为了当前项目提供所需依赖包，比如log4j、spring-core等依赖包可从mavenCentral仓库获得。\n3. allprojects块的repositories用于多项目构建，为所有项目提供共同的所需依赖包。而子项目可以配置自己的repositories以获取自己独需的依赖包。\n4. subprojects块的repositories用于配置这个项目的子项目。使用多模块项目时，不同模块之间有相同的配置，导致重复配置，可以将相同的部分抽取出来，使用配置注入的技术完成子项目的配置。根项目就像一个容器, subprojects 方法遍历这个容器的所有元素并且注入指定的配置。allprojects是对所有project的配置，包括Root Project。而subprojects是对所有Child Project的配置。\n\n这里说明buildScript里面的仓库主要用于Gradle脚本自身执行，因为这里一直超时，我把阿里云镜像加进去就没问题了，估计是下载Gradle脚本自身相关依赖导致超时了。\n\n然后下面还有一部分是plugins闭包：\n```groovy\nplugins {\n    alias(libs.plugins.android.application) apply false\n    alias(libs.plugins.kotlin.jvm) apply false\n    alias(libs.plugins.kotlin.serialization) apply false\n    alias(libs.plugins.hilt) apply false\n    alias(libs.plugins.secrets) apply false\n}\n```\n这里的libs就是在 前面的build-logic模块下的 versionCatalogs创建的一个名称。\n定义了后，这里就可以引用了。这里应该是引用插件，不过都是apply false，这里的作用个人还不是很清楚。\n\n### 4.app模块下的build.gradle.kts\n这里第一行是：\n`import com.google.samples.apps.nowinandroid.NiaBuildType`\n这里可以引用自己编写的类，\n这个类定义再build-logic模块中，是一个枚举类，看一下吧：\n```groovy\npackage com.google.samples.apps.nowinandroid\n\n/**\n * This is shared between :app and :benchmarks module to provide configurations type safety.\n */\n@Suppress(\"unused\")\nenum class NiaBuildType(val applicationIdSuffix: String? = null) {\n    DEBUG(\".debug\"),\n    RELEASE,\n    BENCHMARK(\".benchmark\")\n}\n\n```\n估计是代表编译模式，debug还是release，或者其它模式。\n\n然后继续回到build.gradle.kts文件下，\n这里引入插件了：\n```groovy\nplugins {\n    id(\"nowinandroid.android.application\")\n    id(\"nowinandroid.android.application.compose\")\n    id(\"nowinandroid.android.application.jacoco\")\n    id(\"nowinandroid.android.hilt\")\n    id(\"jacoco\")\n    id(\"nowinandroid.firebase-perf\")\n}\n```\n\n注意这几个有nowinandroid前缀的应该都是我们自己编写的插件。\n首先看下第一个：noewinandroid.android.application\n\n当然还是先全局搜索下，发现在build-logic模块下注册了：\n```groovy\ngradlePlugin {\n    plugins {\n        register(\"androidApplicationCompose\") {\n            id = \"nowinandroid.android.application.compose\"\n            implementationClass = \"AndroidApplicationComposeConventionPlugin\"\n        }\n        register(\"androidApplication\") {\n            id = \"nowinandroid.android.application\"\n            implementationClass = \"AndroidApplicationConventionPlugin\"\n        }\n```\n实现类为：AndroidApplicationConventionPlugin\n```groovy\nclass AndroidApplicationConventionPlugin : Plugin<Project> {\n    override fun apply(target: Project) {\n        with(target) {\n            with(pluginManager) {\n                apply(\"com.android.application\")\n                apply(\"org.jetbrains.kotlin.android\")\n            }\n\n            extensions.configure<ApplicationExtension> {\n                configureKotlinAndroid(this)\n                defaultConfig.targetSdk = 33\n                configureFlavors(this)\n            }\n            extensions.configure<ApplicationAndroidComponentsExtension> {\n                configurePrintApksTask(this)\n            }\n        }\n    }\n}\n```\n这里继承了Plugin<Project>，实现apply方法。\n利用插件管理器pluginManager来引入\"com.android.application\"插件和“org.jetbrains.kotlin.android”插件。\n\n可以看到这里面帮忙apply了com.android.application，这样就不用重复再build.gradle中引入了。\n\n重点来看下引入的compose，说实话我还没用过google的jetpack compose工具包。\n依然在build-logic下注册了这个插件：\n```groovy\ngradlePlugin {\n    plugins {\n        register(\"androidApplicationCompose\") {\n            id = \"nowinandroid.android.application.compose\"\n            implementationClass = \"AndroidApplicationComposeConventionPlugin\"\n        }\n```\n实现类：AndroidApplicationComposeConventionPlugin\n```groovy\nclass AndroidApplicationComposeConventionPlugin : Plugin<Project> {\n    override fun apply(target: Project) {\n        with(target) {\n            pluginManager.apply(\"com.android.application\")\n            val extension = extensions.getByType<ApplicationExtension>()\n            configureAndroidCompose(extension)\n        }\n    }\n\n}\n```\n非常简单，先apply了com.android.application\n然后调用了一个 configureAndroidCompose 方法，这是一个扩展方法，也是在build-logic下的一个kt文件中对Project进行了扩展。\n```groovy\n/**\n * Configure Compose-specific options\n */\ninternal fun Project.configureAndroidCompose(\n    commonExtension: CommonExtension<*, *, *, *>,\n) {\n    val libs = extensions.getByType<VersionCatalogsExtension>().named(\"libs\")\n\n    commonExtension.apply {\n        buildFeatures {\n            compose = true\n        }\n\n        composeOptions {\n            kotlinCompilerExtensionVersion = libs.findVersion(\"androidxComposeCompiler\").get().toString()\n        }\n\n        kotlinOptions {\n            freeCompilerArgs = freeCompilerArgs + buildComposeMetricsParameters()\n        }\n\n        dependencies {\n            val bom = libs.findLibrary(\"androidx-compose-bom\").get()\n            add(\"implementation\", platform(bom))\n            add(\"androidTestImplementation\", platform(bom))\n        }\n    }\n}\n```\n这里编写了compose相关的必要的配置。buildFeaturs，composeOptions,kotlinOptions,dependencies这些都加上了。\n\n再回到app模块下的build.gradle.kts文件，\n还有一个插件是：nowinandroid.android.application.jacoco\n这个是自定义的一个代码覆盖率的一个插件，基于jacoco的。\n```groovy\n register(\"androidApplicationJacoco\") {\n            id = \"nowinandroid.android.application.jacoco\"\n            implementationClass = \"AndroidApplicationJacocoConventionPlugin\"\n        }\n```\n先注册，再看下实现类：\n```groovy\n\nclass AndroidApplicationJacocoConventionPlugin : Plugin<Project> {\n    override fun apply(target: Project) {\n        with(target) {\n            with(pluginManager) {\n                apply(\"org.gradle.jacoco\")\n                apply(\"com.android.application\")\n            }\n            val extension = extensions.getByType<ApplicationAndroidComponentsExtension>()\n            configureJacoco(extension)\n        }\n    }\n\n}\n```\n这里引入了gradle的jacoco插件，然后调用了configureJacoco方法。\n具体插件使用方法可以这里看下：[https://www.w3cschool.cn/gradle/9pg71huj.html](https://www.w3cschool.cn/gradle/9pg71huj.html)\n\n这个配置起来确实很麻烦，如果全部代码加到app模块下，很难进行维护，这样以插件形式确实方便很多。\n\n这里继续看app模块引入的自定义插件：hilt\n这个想必大家都不陌生了，是一个依赖注入的插件，基于Dragger，但比Dragger简洁很多了。\n实现类为：\n```groovy\nclass AndroidHiltConventionPlugin : Plugin<Project> {\n    override fun apply(target: Project) {\n        with(target) {\n            with(pluginManager) {\n                apply(\"dagger.hilt.android.plugin\")\n                // KAPT must go last to avoid build warnings.\n                // See: https://stackoverflow.com/questions/70550883/warning-the-following-options-were-not-recognized-by-any-processor-dagger-f\n                apply(\"org.jetbrains.kotlin.kapt\")\n            }\n\n            val libs = extensions.getByType<VersionCatalogsExtension>().named(\"libs\")\n            dependencies {\n                \"implementation\"(libs.findLibrary(\"hilt.android\").get())\n                \"kapt\"(libs.findLibrary(\"hilt.compiler\").get())\n                \"kaptAndroidTest\"(libs.findLibrary(\"hilt.compiler\").get())\n            }\n\n        }\n    }\n}\n```\n这样就配置好了hilt。\n\n最后一个app模块引入的插件是firebase-perf\n这个是google出品的性能监控插件。\n具体用法参考：[https://blog.csdn.net/u010207898/article/details/125070024](https://blog.csdn.net/u010207898/article/details/125070024)\n\n\n* * *\n好的下面继续看app模块下的build.gradle.kts\nandroid层级下基本没啥大问题，配置applicationId版本号之类的。\n这里有个testInstrumentationRunner选择自定义了：\n`testInstrumentationRunner = \"com.google.samples.apps.nowinandroid.core.testing.NiaTestRunner\"`\n\n看下这里做了啥：\n可以看到这个路径下是在testing模块下的，那应该就是测试相关的了。这里主要是用于单元测试的。这个NiaTestRunner继承了AndroidJunitRunner，这里代码如下：\n```groovy\nclass NiaTestRunner : AndroidJUnitRunner() {\n    override fun newApplication(cl: ClassLoader?, name: String?, context: Context?): Application {\n        return super.newApplication(cl, HiltTestApplication::class.java.name, context)\n    }\n}\n```\n\n这个hilt居然还有做单元测试的注入，还是不错，收藏了。\n\n看下buildTypes里面的配置：\n```groovy\n   buildTypes {\n        val debug by getting {\n            applicationIdSuffix = NiaBuildType.DEBUG.applicationIdSuffix\n        }\n```\n这里val debug by gettting为啥这样写？\n这里其实分了2步：\n```groovy\nval release = getByName(\"release\")\n    release.apply {\n```\n\n等价于：\n` val release by getting`\n\n继续下面：\n```groovy\n   packagingOptions {\n        resources {\n            excludes.add(\"/META-INF/{AL2.0,LGPL2.1}\")\n        }\n    }\n```\n这个配置是什么呢：\n打包配置，需要移除这个文件。\n\n继续下面：\n```groovy\n  testOptions {\n        unitTests {\n            isIncludeAndroidResources = true\n        }\n        // TODO: Convert it as a convention plugin once Flamingo goes out (https://github.com/android/nowinandroid/issues/523)\n        managedDevices {\n            devices {\n                maybeCreate<com.android.build.api.dsl.ManagedVirtualDevice>(\"pixel4api30\").apply {\n                    device = \"Pixel 4\"\n                    apiLevel = 30\n                    // ATDs currently support only API level 30.\n                    systemImageSource = \"aosp-atd\"\n                }\n            }\n        }\n    }\n```\n这里是一个testOptions，主要用于配置测试设备的一些属性。\n\n这里关于其它配置可以参考这篇文档[https://blog.csdn.net/shulianghan/article/details/124919287](https://blog.csdn.net/shulianghan/article/details/124919287)\n\n继续看android闭包最后一个配置:\n`namespace = \"com.google.samples.apps.nowinandroid\"`\n\n每个 Android 模块都有一个命名空间，此命名空间用作其生成的 R 和 BuildConfig 类的 Java 或 Kotlin 软件包名称。命名空间由模块的 build.gradle 文件中的 namespace 属性定义，如以下代码段所示。namespace 最初会设为您在创建项目时选择的软件包名称。\n\n最下面就是我们熟悉的dependencies了，可以看到这里非常简练，没有任何版本号，全是通过lis引入的，看着很舒服。\n```groovy\n\ndependencies {\n    implementation(project(\":feature:interests\"))\n    implementation(project(\":feature:foryou\"))\n    implementation(project(\":feature:bookmarks\"))\n    implementation(project(\":feature:topic\"))\n    implementation(project(\":feature:settings\"))\n\n    implementation(project(\":core:common\"))\n    implementation(project(\":core:ui\"))\n    implementation(project(\":core:designsystem\"))\n    implementation(project(\":core:data\"))\n    implementation(project(\":core:model\"))\n\n    implementation(project(\":sync:work\"))\n\n    androidTestImplementation(project(\":core:testing\"))\n    androidTestImplementation(project(\":core:datastore-test\"))\n    androidTestImplementation(project(\":core:data-test\"))\n    androidTestImplementation(project(\":core:network\"))\n    androidTestImplementation(libs.androidx.navigation.testing)\n    androidTestImplementation(libs.accompanist.testharness)\n    androidTestImplementation(kotlin(\"test\"))\n    debugImplementation(libs.androidx.compose.ui.testManifest)\n    debugImplementation(project(\":ui-test-hilt-manifest\"))\n\n    implementation(libs.accompanist.systemuicontroller)\n    implementation(libs.androidx.activity.compose)\n    implementation(libs.androidx.appcompat)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.core.splashscreen)\n    implementation(libs.androidx.compose.runtime)\n    implementation(libs.androidx.lifecycle.runtimeCompose)\n    implementation(libs.androidx.compose.runtime.tracing)\n    implementation(libs.androidx.compose.material3.windowSizeClass)\n    implementation(libs.androidx.hilt.navigation.compose)\n    implementation(libs.androidx.navigation.compose)\n    implementation(libs.androidx.window.manager)\n    implementation(libs.androidx.profileinstaller)\n\n    implementation(libs.coil.kt)\n    implementation(libs.coil.kt.svg)\n}\n\n```\n\n最下面是强制使用某个依赖：\n```groovy\n// androidx.test is forcing JUnit, 4.12. This forces it to use 4.13\nconfigurations.configureEach {\n    resolutionStrategy {\n        force(libs.junit4)\n        // Temporary workaround for https://issuetracker.google.com/174733673\n        force(\"org.objenesis:objenesis:2.6\")\n    }\n}\n```\n\n### 5.build-logic 模块配置构建逻辑\n这里完全封装了自定义插件，定义依赖，配置相关的逻辑主要在这个模块，其实这个模块感觉可以复用，就是说换一个项目，这个模块基本上可以通用，改改具体版本号或者属性即可。哪些要用，哪些不用，在app模块下按需注册插件即可。\n\n首先看下这个模块的setttings.gradle.kts文件\n很简单：\n```groovy\ndependencyResolutionManagement {\n    repositories {\n        google()\n        mavenCentral()\n    }\n    versionCatalogs {\n        create(\"libs\") {\n            from(files(\"../gradle/libs.versions.toml\"))\n        }\n    }\n}\n\nrootProject.name = \"build-logic\"\ninclude(\":convention\")\n```\n\n这里最为关键的是用了一个 versionCatelogs，这里定义了我们所有三方依赖的地方。然后引入了这个模块下的convention的具体模块，这个模块就是编写自定义插件的地方。\n\n简单看下这个libs.version.toml文件吧，它放在项目级下的gradle文件夹中了：\n```groovy\n[versions]\naccompanist = \"0.28.0\"\nandroidDesugarJdkLibs = \"1.2.2\"\nandroidGradlePlugin = \"7.3.1\"\nandroidxActivity = \"1.6.1\"\nandroidxAppCompat = \"1.5.1\"\nandroidxBrowser = \"1.4.0\"\nandroidxComposeBom = \"2022.12.00\"\nandroidxComposeCompiler = \"1.4.0-alpha02\"\nandroidxComposeRuntimeTracing = \"1.0.0-alpha01\"\nandroidxCore = \"1.9.0\"\nandroidxCoreSplashscreen = \"1.0.0\"\nandroidxDataStore = \"1.0.0\"\nandroidxEspresso = \"3.5.0\"\nandroidxHiltNavigationCompose = \"1.0.0\"\nandroidxLifecycle = \"2.6.0-alpha03\"\nandroidxMacroBenchmark = \"1.1.1\"\nandroidxMetrics = \"1.0.0-alpha03\"\nandroidxNavigation = \"2.5.3\"\nandroidxProfileinstaller = \"1.2.1\"\n等等...\n```\n\n看下build-logic 模块下的build.gradle.kts文件：\n首先引入了 kotlin-dsl 插件：\n```groovy\nplugins {\n    `kotlin-dsl`\n}\n```\n这样就能写 java 闭包了，还有一些 compileOnly方法等。具体关于dsl使用方法可以参考这篇文章：[https://www.jianshu.com/p/461d4a249b71](https://www.jianshu.com/p/461d4a249b71)\n\n下面配置了执行build-logic需要依赖的一些东西：\n```groovy\njava {\n    sourceCompatibility = JavaVersion.VERSION_1_8\n    targetCompatibility = JavaVersion.VERSION_1_8\n}\n\ndependencies {\n    compileOnly(libs.android.gradlePlugin)\n    compileOnly(libs.kotlin.gradlePlugin)\n}\n\n```\n\n这里需要编译依赖一些三方库。\n\n然后下面是重点，gradlePlugin闭包下就是注册各种自定义插件了，并且实现类对应convention模块下的某个类，这个类继承了Plugin<Project>。\n\n\n\n### 6.总结\n1.单独抽出一个module作为封装自定义插件的module。在这个module里面添加自定义插件的逻辑，在这个module的settings.gradle.kts中创建一个versionCatelogs，指向所有依赖文件中。\n2.项目级别的settings.gradle.kts用includeBuild来引入上述module。\n3.gradle.properties文件可以配置编译时buildconfig，aidl等文件是否生成。\n4.app级别的build.gradle.kts按需配置自定义插件，testInstrumentationRunnner可以配置测试类。","source":"_posts/Android-gradle相关-KTS脚本-项目配置改造.md","raw":"---\ntitle: Android gradle相关 KTS脚本 项目配置改造\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-01-13 13:39:50\ntags:\n- Android\ncategories:\n- Android\n---\n\n> googe samples之 nowinandroid项目地址：[https://github.com/android/nowinandroid](https://github.com/android/nowinandroid)\n\n### 1.gradle.properties\n这里面配置了 android.useAndroidX等常用的配置，这里应该耳熟能详了，这里就不过多介绍。下面这里有一块不是特别熟悉：\n```groovy\n# Disable build features that are enabled by default,\n# https://developer.android.com/studio/releases/gradle-plugin#buildFeatures\nandroid.defaults.buildfeatures.buildconfig=false\nandroid.defaults.buildfeatures.aidl=false\nandroid.defaults.buildfeatures.renderscript=false\nandroid.defaults.buildfeatures.resvalues=false\nandroid.defaults.buildfeatures.shaders=false\n```\n\n通过关闭buildfeatures.buildconfig，来提升构建性能。有时候模块不需要生成buildconfig文件，那直接关闭即可。还有其它的aidl，renderscript，resvalues同理。\n\n\n### 2.项目settings.gradle.kts\n这里首先是一个pluginManagement闭包：\n```groovy\npluginManagement {\n    includeBuild(\"build-logic\") // 多模块共享模块\n    repositories {\n        google()\n        mavenCentral()\n        gradlePluginPortal()\n    }\n}\n```\n第一个问题是：pluginManagement是什么东西啊？没见过。\n简单来说：dependencyManagement用于在父项目中统一对子项目依赖管理。这样就可以对所有模块的版本进行管理。\n\n第二个问题是：includeBuild是什么？\n相信大部分人都有用过buildSrc吧。如果没有，那config.gradle总用过吧，总之就是把不同模块之前相同依赖抽出来，同时引用。 buildSrc的弊端就是每次依赖更新都将重新构建整个项目，导致编译时间很长，这里google官方推荐使用includeBuild来解决这个问题。\n\n然后gradlePluginProtal() 远程插件仓库，是google推荐的。\n\n第二块代码是这样的：\n```groovy\ndependencyResolutionManagement {\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories {\n        google()\n        mavenCentral()\n    }\n}\n```\n\n当您的依赖项不是本地库或文件树时，Gradle 会在 settings.gradle 文件的 dependencyResolutionManagement { repositories {...} } 代码块中指定的所有在线仓库中查找相关文件。 各个仓库的列出顺序决定了 Gradle 在这些仓库中搜索各个项目依赖项的顺序。例如，如果从仓库 A 和 B 均可获得某个依赖项，而您先列出了仓库 A，则 Gradle 会从仓库 A 下载该依赖项。说白了，就是有一个优先权，从上往下。\n\n然后这个文件其它内容没啥参考价值了，都是include多个模块。\n这个文件最重要也是最关键的地方就是 includeBuild(\"build-logic\")\n\n\n### 3.项目级build.gradle.kts\n首先是一个buildscript闭包：\n```groovy\nbuildscript {\n    repositories {\n        maven { url = uri(\"https://maven.aliyun.com/repository/public\") }\n        maven { url = uri(\"https://maven.aliyun.com/repository/gradle-plugin\") }\n        maven { url = uri(\"https://maven.aliyun.com/repository/central\") }\n        maven { url = uri(\"https://maven.aliyun.com/repository/google\") }\n\n        mavenCentral()\n        google()\n\n\n        // Android Build Server\n        maven { url = uri(\"../nowinandroid-prebuilts/m2repository\") }\n    }\n}\n```\n其实这里引发了另外一个问题：\n在项目根目录（root Project）下的build.gradle中：buildscript、allprojects、subprojects的repositories有什么区别？\n\n1. buildScript块的repositories主要是为了Gradle脚本自身的执行，获取脚本依赖插件。也就是说，buildScript是用来加载Gradle脚本自身需要使用的资源，可以声明的资源包括依赖项、第三方插件、maven仓库地址等。\n2. 根级别的repositories主要是为了当前项目提供所需依赖包，比如log4j、spring-core等依赖包可从mavenCentral仓库获得。\n3. allprojects块的repositories用于多项目构建，为所有项目提供共同的所需依赖包。而子项目可以配置自己的repositories以获取自己独需的依赖包。\n4. subprojects块的repositories用于配置这个项目的子项目。使用多模块项目时，不同模块之间有相同的配置，导致重复配置，可以将相同的部分抽取出来，使用配置注入的技术完成子项目的配置。根项目就像一个容器, subprojects 方法遍历这个容器的所有元素并且注入指定的配置。allprojects是对所有project的配置，包括Root Project。而subprojects是对所有Child Project的配置。\n\n这里说明buildScript里面的仓库主要用于Gradle脚本自身执行，因为这里一直超时，我把阿里云镜像加进去就没问题了，估计是下载Gradle脚本自身相关依赖导致超时了。\n\n然后下面还有一部分是plugins闭包：\n```groovy\nplugins {\n    alias(libs.plugins.android.application) apply false\n    alias(libs.plugins.kotlin.jvm) apply false\n    alias(libs.plugins.kotlin.serialization) apply false\n    alias(libs.plugins.hilt) apply false\n    alias(libs.plugins.secrets) apply false\n}\n```\n这里的libs就是在 前面的build-logic模块下的 versionCatalogs创建的一个名称。\n定义了后，这里就可以引用了。这里应该是引用插件，不过都是apply false，这里的作用个人还不是很清楚。\n\n### 4.app模块下的build.gradle.kts\n这里第一行是：\n`import com.google.samples.apps.nowinandroid.NiaBuildType`\n这里可以引用自己编写的类，\n这个类定义再build-logic模块中，是一个枚举类，看一下吧：\n```groovy\npackage com.google.samples.apps.nowinandroid\n\n/**\n * This is shared between :app and :benchmarks module to provide configurations type safety.\n */\n@Suppress(\"unused\")\nenum class NiaBuildType(val applicationIdSuffix: String? = null) {\n    DEBUG(\".debug\"),\n    RELEASE,\n    BENCHMARK(\".benchmark\")\n}\n\n```\n估计是代表编译模式，debug还是release，或者其它模式。\n\n然后继续回到build.gradle.kts文件下，\n这里引入插件了：\n```groovy\nplugins {\n    id(\"nowinandroid.android.application\")\n    id(\"nowinandroid.android.application.compose\")\n    id(\"nowinandroid.android.application.jacoco\")\n    id(\"nowinandroid.android.hilt\")\n    id(\"jacoco\")\n    id(\"nowinandroid.firebase-perf\")\n}\n```\n\n注意这几个有nowinandroid前缀的应该都是我们自己编写的插件。\n首先看下第一个：noewinandroid.android.application\n\n当然还是先全局搜索下，发现在build-logic模块下注册了：\n```groovy\ngradlePlugin {\n    plugins {\n        register(\"androidApplicationCompose\") {\n            id = \"nowinandroid.android.application.compose\"\n            implementationClass = \"AndroidApplicationComposeConventionPlugin\"\n        }\n        register(\"androidApplication\") {\n            id = \"nowinandroid.android.application\"\n            implementationClass = \"AndroidApplicationConventionPlugin\"\n        }\n```\n实现类为：AndroidApplicationConventionPlugin\n```groovy\nclass AndroidApplicationConventionPlugin : Plugin<Project> {\n    override fun apply(target: Project) {\n        with(target) {\n            with(pluginManager) {\n                apply(\"com.android.application\")\n                apply(\"org.jetbrains.kotlin.android\")\n            }\n\n            extensions.configure<ApplicationExtension> {\n                configureKotlinAndroid(this)\n                defaultConfig.targetSdk = 33\n                configureFlavors(this)\n            }\n            extensions.configure<ApplicationAndroidComponentsExtension> {\n                configurePrintApksTask(this)\n            }\n        }\n    }\n}\n```\n这里继承了Plugin<Project>，实现apply方法。\n利用插件管理器pluginManager来引入\"com.android.application\"插件和“org.jetbrains.kotlin.android”插件。\n\n可以看到这里面帮忙apply了com.android.application，这样就不用重复再build.gradle中引入了。\n\n重点来看下引入的compose，说实话我还没用过google的jetpack compose工具包。\n依然在build-logic下注册了这个插件：\n```groovy\ngradlePlugin {\n    plugins {\n        register(\"androidApplicationCompose\") {\n            id = \"nowinandroid.android.application.compose\"\n            implementationClass = \"AndroidApplicationComposeConventionPlugin\"\n        }\n```\n实现类：AndroidApplicationComposeConventionPlugin\n```groovy\nclass AndroidApplicationComposeConventionPlugin : Plugin<Project> {\n    override fun apply(target: Project) {\n        with(target) {\n            pluginManager.apply(\"com.android.application\")\n            val extension = extensions.getByType<ApplicationExtension>()\n            configureAndroidCompose(extension)\n        }\n    }\n\n}\n```\n非常简单，先apply了com.android.application\n然后调用了一个 configureAndroidCompose 方法，这是一个扩展方法，也是在build-logic下的一个kt文件中对Project进行了扩展。\n```groovy\n/**\n * Configure Compose-specific options\n */\ninternal fun Project.configureAndroidCompose(\n    commonExtension: CommonExtension<*, *, *, *>,\n) {\n    val libs = extensions.getByType<VersionCatalogsExtension>().named(\"libs\")\n\n    commonExtension.apply {\n        buildFeatures {\n            compose = true\n        }\n\n        composeOptions {\n            kotlinCompilerExtensionVersion = libs.findVersion(\"androidxComposeCompiler\").get().toString()\n        }\n\n        kotlinOptions {\n            freeCompilerArgs = freeCompilerArgs + buildComposeMetricsParameters()\n        }\n\n        dependencies {\n            val bom = libs.findLibrary(\"androidx-compose-bom\").get()\n            add(\"implementation\", platform(bom))\n            add(\"androidTestImplementation\", platform(bom))\n        }\n    }\n}\n```\n这里编写了compose相关的必要的配置。buildFeaturs，composeOptions,kotlinOptions,dependencies这些都加上了。\n\n再回到app模块下的build.gradle.kts文件，\n还有一个插件是：nowinandroid.android.application.jacoco\n这个是自定义的一个代码覆盖率的一个插件，基于jacoco的。\n```groovy\n register(\"androidApplicationJacoco\") {\n            id = \"nowinandroid.android.application.jacoco\"\n            implementationClass = \"AndroidApplicationJacocoConventionPlugin\"\n        }\n```\n先注册，再看下实现类：\n```groovy\n\nclass AndroidApplicationJacocoConventionPlugin : Plugin<Project> {\n    override fun apply(target: Project) {\n        with(target) {\n            with(pluginManager) {\n                apply(\"org.gradle.jacoco\")\n                apply(\"com.android.application\")\n            }\n            val extension = extensions.getByType<ApplicationAndroidComponentsExtension>()\n            configureJacoco(extension)\n        }\n    }\n\n}\n```\n这里引入了gradle的jacoco插件，然后调用了configureJacoco方法。\n具体插件使用方法可以这里看下：[https://www.w3cschool.cn/gradle/9pg71huj.html](https://www.w3cschool.cn/gradle/9pg71huj.html)\n\n这个配置起来确实很麻烦，如果全部代码加到app模块下，很难进行维护，这样以插件形式确实方便很多。\n\n这里继续看app模块引入的自定义插件：hilt\n这个想必大家都不陌生了，是一个依赖注入的插件，基于Dragger，但比Dragger简洁很多了。\n实现类为：\n```groovy\nclass AndroidHiltConventionPlugin : Plugin<Project> {\n    override fun apply(target: Project) {\n        with(target) {\n            with(pluginManager) {\n                apply(\"dagger.hilt.android.plugin\")\n                // KAPT must go last to avoid build warnings.\n                // See: https://stackoverflow.com/questions/70550883/warning-the-following-options-were-not-recognized-by-any-processor-dagger-f\n                apply(\"org.jetbrains.kotlin.kapt\")\n            }\n\n            val libs = extensions.getByType<VersionCatalogsExtension>().named(\"libs\")\n            dependencies {\n                \"implementation\"(libs.findLibrary(\"hilt.android\").get())\n                \"kapt\"(libs.findLibrary(\"hilt.compiler\").get())\n                \"kaptAndroidTest\"(libs.findLibrary(\"hilt.compiler\").get())\n            }\n\n        }\n    }\n}\n```\n这样就配置好了hilt。\n\n最后一个app模块引入的插件是firebase-perf\n这个是google出品的性能监控插件。\n具体用法参考：[https://blog.csdn.net/u010207898/article/details/125070024](https://blog.csdn.net/u010207898/article/details/125070024)\n\n\n* * *\n好的下面继续看app模块下的build.gradle.kts\nandroid层级下基本没啥大问题，配置applicationId版本号之类的。\n这里有个testInstrumentationRunner选择自定义了：\n`testInstrumentationRunner = \"com.google.samples.apps.nowinandroid.core.testing.NiaTestRunner\"`\n\n看下这里做了啥：\n可以看到这个路径下是在testing模块下的，那应该就是测试相关的了。这里主要是用于单元测试的。这个NiaTestRunner继承了AndroidJunitRunner，这里代码如下：\n```groovy\nclass NiaTestRunner : AndroidJUnitRunner() {\n    override fun newApplication(cl: ClassLoader?, name: String?, context: Context?): Application {\n        return super.newApplication(cl, HiltTestApplication::class.java.name, context)\n    }\n}\n```\n\n这个hilt居然还有做单元测试的注入，还是不错，收藏了。\n\n看下buildTypes里面的配置：\n```groovy\n   buildTypes {\n        val debug by getting {\n            applicationIdSuffix = NiaBuildType.DEBUG.applicationIdSuffix\n        }\n```\n这里val debug by gettting为啥这样写？\n这里其实分了2步：\n```groovy\nval release = getByName(\"release\")\n    release.apply {\n```\n\n等价于：\n` val release by getting`\n\n继续下面：\n```groovy\n   packagingOptions {\n        resources {\n            excludes.add(\"/META-INF/{AL2.0,LGPL2.1}\")\n        }\n    }\n```\n这个配置是什么呢：\n打包配置，需要移除这个文件。\n\n继续下面：\n```groovy\n  testOptions {\n        unitTests {\n            isIncludeAndroidResources = true\n        }\n        // TODO: Convert it as a convention plugin once Flamingo goes out (https://github.com/android/nowinandroid/issues/523)\n        managedDevices {\n            devices {\n                maybeCreate<com.android.build.api.dsl.ManagedVirtualDevice>(\"pixel4api30\").apply {\n                    device = \"Pixel 4\"\n                    apiLevel = 30\n                    // ATDs currently support only API level 30.\n                    systemImageSource = \"aosp-atd\"\n                }\n            }\n        }\n    }\n```\n这里是一个testOptions，主要用于配置测试设备的一些属性。\n\n这里关于其它配置可以参考这篇文档[https://blog.csdn.net/shulianghan/article/details/124919287](https://blog.csdn.net/shulianghan/article/details/124919287)\n\n继续看android闭包最后一个配置:\n`namespace = \"com.google.samples.apps.nowinandroid\"`\n\n每个 Android 模块都有一个命名空间，此命名空间用作其生成的 R 和 BuildConfig 类的 Java 或 Kotlin 软件包名称。命名空间由模块的 build.gradle 文件中的 namespace 属性定义，如以下代码段所示。namespace 最初会设为您在创建项目时选择的软件包名称。\n\n最下面就是我们熟悉的dependencies了，可以看到这里非常简练，没有任何版本号，全是通过lis引入的，看着很舒服。\n```groovy\n\ndependencies {\n    implementation(project(\":feature:interests\"))\n    implementation(project(\":feature:foryou\"))\n    implementation(project(\":feature:bookmarks\"))\n    implementation(project(\":feature:topic\"))\n    implementation(project(\":feature:settings\"))\n\n    implementation(project(\":core:common\"))\n    implementation(project(\":core:ui\"))\n    implementation(project(\":core:designsystem\"))\n    implementation(project(\":core:data\"))\n    implementation(project(\":core:model\"))\n\n    implementation(project(\":sync:work\"))\n\n    androidTestImplementation(project(\":core:testing\"))\n    androidTestImplementation(project(\":core:datastore-test\"))\n    androidTestImplementation(project(\":core:data-test\"))\n    androidTestImplementation(project(\":core:network\"))\n    androidTestImplementation(libs.androidx.navigation.testing)\n    androidTestImplementation(libs.accompanist.testharness)\n    androidTestImplementation(kotlin(\"test\"))\n    debugImplementation(libs.androidx.compose.ui.testManifest)\n    debugImplementation(project(\":ui-test-hilt-manifest\"))\n\n    implementation(libs.accompanist.systemuicontroller)\n    implementation(libs.androidx.activity.compose)\n    implementation(libs.androidx.appcompat)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.core.splashscreen)\n    implementation(libs.androidx.compose.runtime)\n    implementation(libs.androidx.lifecycle.runtimeCompose)\n    implementation(libs.androidx.compose.runtime.tracing)\n    implementation(libs.androidx.compose.material3.windowSizeClass)\n    implementation(libs.androidx.hilt.navigation.compose)\n    implementation(libs.androidx.navigation.compose)\n    implementation(libs.androidx.window.manager)\n    implementation(libs.androidx.profileinstaller)\n\n    implementation(libs.coil.kt)\n    implementation(libs.coil.kt.svg)\n}\n\n```\n\n最下面是强制使用某个依赖：\n```groovy\n// androidx.test is forcing JUnit, 4.12. This forces it to use 4.13\nconfigurations.configureEach {\n    resolutionStrategy {\n        force(libs.junit4)\n        // Temporary workaround for https://issuetracker.google.com/174733673\n        force(\"org.objenesis:objenesis:2.6\")\n    }\n}\n```\n\n### 5.build-logic 模块配置构建逻辑\n这里完全封装了自定义插件，定义依赖，配置相关的逻辑主要在这个模块，其实这个模块感觉可以复用，就是说换一个项目，这个模块基本上可以通用，改改具体版本号或者属性即可。哪些要用，哪些不用，在app模块下按需注册插件即可。\n\n首先看下这个模块的setttings.gradle.kts文件\n很简单：\n```groovy\ndependencyResolutionManagement {\n    repositories {\n        google()\n        mavenCentral()\n    }\n    versionCatalogs {\n        create(\"libs\") {\n            from(files(\"../gradle/libs.versions.toml\"))\n        }\n    }\n}\n\nrootProject.name = \"build-logic\"\ninclude(\":convention\")\n```\n\n这里最为关键的是用了一个 versionCatelogs，这里定义了我们所有三方依赖的地方。然后引入了这个模块下的convention的具体模块，这个模块就是编写自定义插件的地方。\n\n简单看下这个libs.version.toml文件吧，它放在项目级下的gradle文件夹中了：\n```groovy\n[versions]\naccompanist = \"0.28.0\"\nandroidDesugarJdkLibs = \"1.2.2\"\nandroidGradlePlugin = \"7.3.1\"\nandroidxActivity = \"1.6.1\"\nandroidxAppCompat = \"1.5.1\"\nandroidxBrowser = \"1.4.0\"\nandroidxComposeBom = \"2022.12.00\"\nandroidxComposeCompiler = \"1.4.0-alpha02\"\nandroidxComposeRuntimeTracing = \"1.0.0-alpha01\"\nandroidxCore = \"1.9.0\"\nandroidxCoreSplashscreen = \"1.0.0\"\nandroidxDataStore = \"1.0.0\"\nandroidxEspresso = \"3.5.0\"\nandroidxHiltNavigationCompose = \"1.0.0\"\nandroidxLifecycle = \"2.6.0-alpha03\"\nandroidxMacroBenchmark = \"1.1.1\"\nandroidxMetrics = \"1.0.0-alpha03\"\nandroidxNavigation = \"2.5.3\"\nandroidxProfileinstaller = \"1.2.1\"\n等等...\n```\n\n看下build-logic 模块下的build.gradle.kts文件：\n首先引入了 kotlin-dsl 插件：\n```groovy\nplugins {\n    `kotlin-dsl`\n}\n```\n这样就能写 java 闭包了，还有一些 compileOnly方法等。具体关于dsl使用方法可以参考这篇文章：[https://www.jianshu.com/p/461d4a249b71](https://www.jianshu.com/p/461d4a249b71)\n\n下面配置了执行build-logic需要依赖的一些东西：\n```groovy\njava {\n    sourceCompatibility = JavaVersion.VERSION_1_8\n    targetCompatibility = JavaVersion.VERSION_1_8\n}\n\ndependencies {\n    compileOnly(libs.android.gradlePlugin)\n    compileOnly(libs.kotlin.gradlePlugin)\n}\n\n```\n\n这里需要编译依赖一些三方库。\n\n然后下面是重点，gradlePlugin闭包下就是注册各种自定义插件了，并且实现类对应convention模块下的某个类，这个类继承了Plugin<Project>。\n\n\n\n### 6.总结\n1.单独抽出一个module作为封装自定义插件的module。在这个module里面添加自定义插件的逻辑，在这个module的settings.gradle.kts中创建一个versionCatelogs，指向所有依赖文件中。\n2.项目级别的settings.gradle.kts用includeBuild来引入上述module。\n3.gradle.properties文件可以配置编译时buildconfig，aidl等文件是否生成。\n4.app级别的build.gradle.kts按需配置自定义插件，testInstrumentationRunnner可以配置测试类。","slug":"Android-gradle相关-KTS脚本-项目配置改造","published":1,"updated":"2023-02-01T07:12:21.384Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlc01jc000bjhv74oll3b8j","content":"<blockquote>\n<p>googe samples之 nowinandroid项目地址：<a href=\"https://github.com/android/nowinandroid\">https://github.com/android/nowinandroid</a></p>\n</blockquote>\n<h3 id=\"1-gradle-properties\"><a href=\"#1-gradle-properties\" class=\"headerlink\" title=\"1.gradle.properties\"></a>1.gradle.properties</h3><p>这里面配置了 android.useAndroidX等常用的配置，这里应该耳熟能详了，这里就不过多介绍。下面这里有一块不是特别熟悉：</p>\n<pre><code class=\"line-numbers language-groovy\"># Disable build features that are enabled by default,\n# https://developer.android.com/studio/releases/gradle-plugin#buildFeatures\nandroid.defaults.buildfeatures.buildconfig=false\nandroid.defaults.buildfeatures.aidl=false\nandroid.defaults.buildfeatures.renderscript=false\nandroid.defaults.buildfeatures.resvalues=false\nandroid.defaults.buildfeatures.shaders=false\n</code></pre>\n<p>通过关闭buildfeatures.buildconfig，来提升构建性能。有时候模块不需要生成buildconfig文件，那直接关闭即可。还有其它的aidl，renderscript，resvalues同理。</p>\n<h3 id=\"2-项目settings-gradle-kts\"><a href=\"#2-项目settings-gradle-kts\" class=\"headerlink\" title=\"2.项目settings.gradle.kts\"></a>2.项目settings.gradle.kts</h3><p>这里首先是一个pluginManagement闭包：</p>\n<pre><code class=\"line-numbers language-groovy\">pluginManagement &#123;\n    includeBuild(&quot;build-logic&quot;) // 多模块共享模块\n    repositories &#123;\n        google()\n        mavenCentral()\n        gradlePluginPortal()\n    &#125;\n&#125;\n</code></pre>\n<p>第一个问题是：pluginManagement是什么东西啊？没见过。<br>简单来说：dependencyManagement用于在父项目中统一对子项目依赖管理。这样就可以对所有模块的版本进行管理。</p>\n<p>第二个问题是：includeBuild是什么？<br>相信大部分人都有用过buildSrc吧。如果没有，那config.gradle总用过吧，总之就是把不同模块之前相同依赖抽出来，同时引用。 buildSrc的弊端就是每次依赖更新都将重新构建整个项目，导致编译时间很长，这里google官方推荐使用includeBuild来解决这个问题。</p>\n<p>然后gradlePluginProtal() 远程插件仓库，是google推荐的。</p>\n<p>第二块代码是这样的：</p>\n<pre><code class=\"line-numbers language-groovy\">dependencyResolutionManagement &#123;\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories &#123;\n        google()\n        mavenCentral()\n    &#125;\n&#125;\n</code></pre>\n<p>当您的依赖项不是本地库或文件树时，Gradle 会在 settings.gradle 文件的 dependencyResolutionManagement { repositories {…} } 代码块中指定的所有在线仓库中查找相关文件。 各个仓库的列出顺序决定了 Gradle 在这些仓库中搜索各个项目依赖项的顺序。例如，如果从仓库 A 和 B 均可获得某个依赖项，而您先列出了仓库 A，则 Gradle 会从仓库 A 下载该依赖项。说白了，就是有一个优先权，从上往下。</p>\n<p>然后这个文件其它内容没啥参考价值了，都是include多个模块。<br>这个文件最重要也是最关键的地方就是 includeBuild(“build-logic”)</p>\n<h3 id=\"3-项目级build-gradle-kts\"><a href=\"#3-项目级build-gradle-kts\" class=\"headerlink\" title=\"3.项目级build.gradle.kts\"></a>3.项目级build.gradle.kts</h3><p>首先是一个buildscript闭包：</p>\n<pre><code class=\"line-numbers language-groovy\">buildscript &#123;\n    repositories &#123;\n        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/public&quot;) &#125;\n        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/gradle-plugin&quot;) &#125;\n        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/central&quot;) &#125;\n        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/google&quot;) &#125;\n\n        mavenCentral()\n        google()\n\n\n        // Android Build Server\n        maven &#123; url = uri(&quot;../nowinandroid-prebuilts/m2repository&quot;) &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>其实这里引发了另外一个问题：<br>在项目根目录（root Project）下的build.gradle中：buildscript、allprojects、subprojects的repositories有什么区别？</p>\n<ol>\n<li>buildScript块的repositories主要是为了Gradle脚本自身的执行，获取脚本依赖插件。也就是说，buildScript是用来加载Gradle脚本自身需要使用的资源，可以声明的资源包括依赖项、第三方插件、maven仓库地址等。</li>\n<li>根级别的repositories主要是为了当前项目提供所需依赖包，比如log4j、spring-core等依赖包可从mavenCentral仓库获得。</li>\n<li>allprojects块的repositories用于多项目构建，为所有项目提供共同的所需依赖包。而子项目可以配置自己的repositories以获取自己独需的依赖包。</li>\n<li>subprojects块的repositories用于配置这个项目的子项目。使用多模块项目时，不同模块之间有相同的配置，导致重复配置，可以将相同的部分抽取出来，使用配置注入的技术完成子项目的配置。根项目就像一个容器, subprojects 方法遍历这个容器的所有元素并且注入指定的配置。allprojects是对所有project的配置，包括Root Project。而subprojects是对所有Child Project的配置。</li>\n</ol>\n<p>这里说明buildScript里面的仓库主要用于Gradle脚本自身执行，因为这里一直超时，我把阿里云镜像加进去就没问题了，估计是下载Gradle脚本自身相关依赖导致超时了。</p>\n<p>然后下面还有一部分是plugins闭包：</p>\n<pre><code class=\"line-numbers language-groovy\">plugins &#123;\n    alias(libs.plugins.android.application) apply false\n    alias(libs.plugins.kotlin.jvm) apply false\n    alias(libs.plugins.kotlin.serialization) apply false\n    alias(libs.plugins.hilt) apply false\n    alias(libs.plugins.secrets) apply false\n&#125;\n</code></pre>\n<p>这里的libs就是在 前面的build-logic模块下的 versionCatalogs创建的一个名称。<br>定义了后，这里就可以引用了。这里应该是引用插件，不过都是apply false，这里的作用个人还不是很清楚。</p>\n<h3 id=\"4-app模块下的build-gradle-kts\"><a href=\"#4-app模块下的build-gradle-kts\" class=\"headerlink\" title=\"4.app模块下的build.gradle.kts\"></a>4.app模块下的build.gradle.kts</h3><p>这里第一行是：<br><code>import com.google.samples.apps.nowinandroid.NiaBuildType</code><br>这里可以引用自己编写的类，<br>这个类定义再build-logic模块中，是一个枚举类，看一下吧：</p>\n<pre><code class=\"line-numbers language-groovy\">package com.google.samples.apps.nowinandroid\n\n/**\n * This is shared between :app and :benchmarks module to provide configurations type safety.\n */\n@Suppress(&quot;unused&quot;)\nenum class NiaBuildType(val applicationIdSuffix: String? = null) &#123;\n    DEBUG(&quot;.debug&quot;),\n    RELEASE,\n    BENCHMARK(&quot;.benchmark&quot;)\n&#125;\n</code></pre>\n<p>估计是代表编译模式，debug还是release，或者其它模式。</p>\n<p>然后继续回到build.gradle.kts文件下，<br>这里引入插件了：</p>\n<pre><code class=\"line-numbers language-groovy\">plugins &#123;\n    id(&quot;nowinandroid.android.application&quot;)\n    id(&quot;nowinandroid.android.application.compose&quot;)\n    id(&quot;nowinandroid.android.application.jacoco&quot;)\n    id(&quot;nowinandroid.android.hilt&quot;)\n    id(&quot;jacoco&quot;)\n    id(&quot;nowinandroid.firebase-perf&quot;)\n&#125;\n</code></pre>\n<p>注意这几个有nowinandroid前缀的应该都是我们自己编写的插件。<br>首先看下第一个：noewinandroid.android.application</p>\n<p>当然还是先全局搜索下，发现在build-logic模块下注册了：</p>\n<pre><code class=\"line-numbers language-groovy\">gradlePlugin &#123;\n    plugins &#123;\n        register(&quot;androidApplicationCompose&quot;) &#123;\n            id = &quot;nowinandroid.android.application.compose&quot;\n            implementationClass = &quot;AndroidApplicationComposeConventionPlugin&quot;\n        &#125;\n        register(&quot;androidApplication&quot;) &#123;\n            id = &quot;nowinandroid.android.application&quot;\n            implementationClass = &quot;AndroidApplicationConventionPlugin&quot;\n        &#125;\n</code></pre>\n<p>实现类为：AndroidApplicationConventionPlugin</p>\n<pre><code class=\"line-numbers language-groovy\">class AndroidApplicationConventionPlugin : Plugin&lt;Project&gt; &#123;\n    override fun apply(target: Project) &#123;\n        with(target) &#123;\n            with(pluginManager) &#123;\n                apply(&quot;com.android.application&quot;)\n                apply(&quot;org.jetbrains.kotlin.android&quot;)\n            &#125;\n\n            extensions.configure&lt;ApplicationExtension&gt; &#123;\n                configureKotlinAndroid(this)\n                defaultConfig.targetSdk = 33\n                configureFlavors(this)\n            &#125;\n            extensions.configure&lt;ApplicationAndroidComponentsExtension&gt; &#123;\n                configurePrintApksTask(this)\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里继承了Plugin<Project>，实现apply方法。<br>利用插件管理器pluginManager来引入”com.android.application”插件和“org.jetbrains.kotlin.android”插件。</p>\n<p>可以看到这里面帮忙apply了com.android.application，这样就不用重复再build.gradle中引入了。</p>\n<p>重点来看下引入的compose，说实话我还没用过google的jetpack compose工具包。<br>依然在build-logic下注册了这个插件：</p>\n<pre><code class=\"line-numbers language-groovy\">gradlePlugin &#123;\n    plugins &#123;\n        register(&quot;androidApplicationCompose&quot;) &#123;\n            id = &quot;nowinandroid.android.application.compose&quot;\n            implementationClass = &quot;AndroidApplicationComposeConventionPlugin&quot;\n        &#125;\n</code></pre>\n<p>实现类：AndroidApplicationComposeConventionPlugin</p>\n<pre><code class=\"line-numbers language-groovy\">class AndroidApplicationComposeConventionPlugin : Plugin&lt;Project&gt; &#123;\n    override fun apply(target: Project) &#123;\n        with(target) &#123;\n            pluginManager.apply(&quot;com.android.application&quot;)\n            val extension = extensions.getByType&lt;ApplicationExtension&gt;()\n            configureAndroidCompose(extension)\n        &#125;\n    &#125;\n\n&#125;\n</code></pre>\n<p>非常简单，先apply了com.android.application<br>然后调用了一个 configureAndroidCompose 方法，这是一个扩展方法，也是在build-logic下的一个kt文件中对Project进行了扩展。</p>\n<pre><code class=\"line-numbers language-groovy\">/**\n * Configure Compose-specific options\n */\ninternal fun Project.configureAndroidCompose(\n    commonExtension: CommonExtension&lt;*, *, *, *&gt;,\n) &#123;\n    val libs = extensions.getByType&lt;VersionCatalogsExtension&gt;().named(&quot;libs&quot;)\n\n    commonExtension.apply &#123;\n        buildFeatures &#123;\n            compose = true\n        &#125;\n\n        composeOptions &#123;\n            kotlinCompilerExtensionVersion = libs.findVersion(&quot;androidxComposeCompiler&quot;).get().toString()\n        &#125;\n\n        kotlinOptions &#123;\n            freeCompilerArgs = freeCompilerArgs + buildComposeMetricsParameters()\n        &#125;\n\n        dependencies &#123;\n            val bom = libs.findLibrary(&quot;androidx-compose-bom&quot;).get()\n            add(&quot;implementation&quot;, platform(bom))\n            add(&quot;androidTestImplementation&quot;, platform(bom))\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里编写了compose相关的必要的配置。buildFeaturs，composeOptions,kotlinOptions,dependencies这些都加上了。</p>\n<p>再回到app模块下的build.gradle.kts文件，<br>还有一个插件是：nowinandroid.android.application.jacoco<br>这个是自定义的一个代码覆盖率的一个插件，基于jacoco的。</p>\n<pre><code class=\"line-numbers language-groovy\"> register(&quot;androidApplicationJacoco&quot;) &#123;\n            id = &quot;nowinandroid.android.application.jacoco&quot;\n            implementationClass = &quot;AndroidApplicationJacocoConventionPlugin&quot;\n        &#125;\n</code></pre>\n<p>先注册，再看下实现类：</p>\n<pre><code class=\"line-numbers language-groovy\">\nclass AndroidApplicationJacocoConventionPlugin : Plugin&lt;Project&gt; &#123;\n    override fun apply(target: Project) &#123;\n        with(target) &#123;\n            with(pluginManager) &#123;\n                apply(&quot;org.gradle.jacoco&quot;)\n                apply(&quot;com.android.application&quot;)\n            &#125;\n            val extension = extensions.getByType&lt;ApplicationAndroidComponentsExtension&gt;()\n            configureJacoco(extension)\n        &#125;\n    &#125;\n\n&#125;\n</code></pre>\n<p>这里引入了gradle的jacoco插件，然后调用了configureJacoco方法。<br>具体插件使用方法可以这里看下：<a href=\"https://www.w3cschool.cn/gradle/9pg71huj.html\">https://www.w3cschool.cn/gradle/9pg71huj.html</a></p>\n<p>这个配置起来确实很麻烦，如果全部代码加到app模块下，很难进行维护，这样以插件形式确实方便很多。</p>\n<p>这里继续看app模块引入的自定义插件：hilt<br>这个想必大家都不陌生了，是一个依赖注入的插件，基于Dragger，但比Dragger简洁很多了。<br>实现类为：</p>\n<pre><code class=\"line-numbers language-groovy\">class AndroidHiltConventionPlugin : Plugin&lt;Project&gt; &#123;\n    override fun apply(target: Project) &#123;\n        with(target) &#123;\n            with(pluginManager) &#123;\n                apply(&quot;dagger.hilt.android.plugin&quot;)\n                // KAPT must go last to avoid build warnings.\n                // See: https://stackoverflow.com/questions/70550883/warning-the-following-options-were-not-recognized-by-any-processor-dagger-f\n                apply(&quot;org.jetbrains.kotlin.kapt&quot;)\n            &#125;\n\n            val libs = extensions.getByType&lt;VersionCatalogsExtension&gt;().named(&quot;libs&quot;)\n            dependencies &#123;\n                &quot;implementation&quot;(libs.findLibrary(&quot;hilt.android&quot;).get())\n                &quot;kapt&quot;(libs.findLibrary(&quot;hilt.compiler&quot;).get())\n                &quot;kaptAndroidTest&quot;(libs.findLibrary(&quot;hilt.compiler&quot;).get())\n            &#125;\n\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这样就配置好了hilt。</p>\n<p>最后一个app模块引入的插件是firebase-perf<br>这个是google出品的性能监控插件。<br>具体用法参考：<a href=\"https://blog.csdn.net/u010207898/article/details/125070024\">https://blog.csdn.net/u010207898/article/details/125070024</a></p>\n<hr>\n<p>好的下面继续看app模块下的build.gradle.kts<br>android层级下基本没啥大问题，配置applicationId版本号之类的。<br>这里有个testInstrumentationRunner选择自定义了：<br><code>testInstrumentationRunner = &quot;com.google.samples.apps.nowinandroid.core.testing.NiaTestRunner&quot;</code></p>\n<p>看下这里做了啥：<br>可以看到这个路径下是在testing模块下的，那应该就是测试相关的了。这里主要是用于单元测试的。这个NiaTestRunner继承了AndroidJunitRunner，这里代码如下：</p>\n<pre><code class=\"line-numbers language-groovy\">class NiaTestRunner : AndroidJUnitRunner() &#123;\n    override fun newApplication(cl: ClassLoader?, name: String?, context: Context?): Application &#123;\n        return super.newApplication(cl, HiltTestApplication::class.java.name, context)\n    &#125;\n&#125;\n</code></pre>\n<p>这个hilt居然还有做单元测试的注入，还是不错，收藏了。</p>\n<p>看下buildTypes里面的配置：</p>\n<pre><code class=\"line-numbers language-groovy\">   buildTypes &#123;\n        val debug by getting &#123;\n            applicationIdSuffix = NiaBuildType.DEBUG.applicationIdSuffix\n        &#125;\n</code></pre>\n<p>这里val debug by gettting为啥这样写？<br>这里其实分了2步：</p>\n<pre><code class=\"line-numbers language-groovy\">val release = getByName(&quot;release&quot;)\n    release.apply &#123;\n</code></pre>\n<p>等价于：<br><code> val release by getting</code></p>\n<p>继续下面：</p>\n<pre><code class=\"line-numbers language-groovy\">   packagingOptions &#123;\n        resources &#123;\n            excludes.add(&quot;/META-INF/&#123;AL2.0,LGPL2.1&#125;&quot;)\n        &#125;\n    &#125;\n</code></pre>\n<p>这个配置是什么呢：<br>打包配置，需要移除这个文件。</p>\n<p>继续下面：</p>\n<pre><code class=\"line-numbers language-groovy\">  testOptions &#123;\n        unitTests &#123;\n            isIncludeAndroidResources = true\n        &#125;\n        // TODO: Convert it as a convention plugin once Flamingo goes out (https://github.com/android/nowinandroid/issues/523)\n        managedDevices &#123;\n            devices &#123;\n                maybeCreate&lt;com.android.build.api.dsl.ManagedVirtualDevice&gt;(&quot;pixel4api30&quot;).apply &#123;\n                    device = &quot;Pixel 4&quot;\n                    apiLevel = 30\n                    // ATDs currently support only API level 30.\n                    systemImageSource = &quot;aosp-atd&quot;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>这里是一个testOptions，主要用于配置测试设备的一些属性。</p>\n<p>这里关于其它配置可以参考这篇文档<a href=\"https://blog.csdn.net/shulianghan/article/details/124919287\">https://blog.csdn.net/shulianghan/article/details/124919287</a></p>\n<p>继续看android闭包最后一个配置:<br><code>namespace = &quot;com.google.samples.apps.nowinandroid&quot;</code></p>\n<p>每个 Android 模块都有一个命名空间，此命名空间用作其生成的 R 和 BuildConfig 类的 Java 或 Kotlin 软件包名称。命名空间由模块的 build.gradle 文件中的 namespace 属性定义，如以下代码段所示。namespace 最初会设为您在创建项目时选择的软件包名称。</p>\n<p>最下面就是我们熟悉的dependencies了，可以看到这里非常简练，没有任何版本号，全是通过lis引入的，看着很舒服。</p>\n<pre><code class=\"line-numbers language-groovy\">\ndependencies &#123;\n    implementation(project(&quot;:feature:interests&quot;))\n    implementation(project(&quot;:feature:foryou&quot;))\n    implementation(project(&quot;:feature:bookmarks&quot;))\n    implementation(project(&quot;:feature:topic&quot;))\n    implementation(project(&quot;:feature:settings&quot;))\n\n    implementation(project(&quot;:core:common&quot;))\n    implementation(project(&quot;:core:ui&quot;))\n    implementation(project(&quot;:core:designsystem&quot;))\n    implementation(project(&quot;:core:data&quot;))\n    implementation(project(&quot;:core:model&quot;))\n\n    implementation(project(&quot;:sync:work&quot;))\n\n    androidTestImplementation(project(&quot;:core:testing&quot;))\n    androidTestImplementation(project(&quot;:core:datastore-test&quot;))\n    androidTestImplementation(project(&quot;:core:data-test&quot;))\n    androidTestImplementation(project(&quot;:core:network&quot;))\n    androidTestImplementation(libs.androidx.navigation.testing)\n    androidTestImplementation(libs.accompanist.testharness)\n    androidTestImplementation(kotlin(&quot;test&quot;))\n    debugImplementation(libs.androidx.compose.ui.testManifest)\n    debugImplementation(project(&quot;:ui-test-hilt-manifest&quot;))\n\n    implementation(libs.accompanist.systemuicontroller)\n    implementation(libs.androidx.activity.compose)\n    implementation(libs.androidx.appcompat)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.core.splashscreen)\n    implementation(libs.androidx.compose.runtime)\n    implementation(libs.androidx.lifecycle.runtimeCompose)\n    implementation(libs.androidx.compose.runtime.tracing)\n    implementation(libs.androidx.compose.material3.windowSizeClass)\n    implementation(libs.androidx.hilt.navigation.compose)\n    implementation(libs.androidx.navigation.compose)\n    implementation(libs.androidx.window.manager)\n    implementation(libs.androidx.profileinstaller)\n\n    implementation(libs.coil.kt)\n    implementation(libs.coil.kt.svg)\n&#125;\n</code></pre>\n<p>最下面是强制使用某个依赖：</p>\n<pre><code class=\"line-numbers language-groovy\">// androidx.test is forcing JUnit, 4.12. This forces it to use 4.13\nconfigurations.configureEach &#123;\n    resolutionStrategy &#123;\n        force(libs.junit4)\n        // Temporary workaround for https://issuetracker.google.com/174733673\n        force(&quot;org.objenesis:objenesis:2.6&quot;)\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"5-build-logic-模块配置构建逻辑\"><a href=\"#5-build-logic-模块配置构建逻辑\" class=\"headerlink\" title=\"5.build-logic 模块配置构建逻辑\"></a>5.build-logic 模块配置构建逻辑</h3><p>这里完全封装了自定义插件，定义依赖，配置相关的逻辑主要在这个模块，其实这个模块感觉可以复用，就是说换一个项目，这个模块基本上可以通用，改改具体版本号或者属性即可。哪些要用，哪些不用，在app模块下按需注册插件即可。</p>\n<p>首先看下这个模块的setttings.gradle.kts文件<br>很简单：</p>\n<pre><code class=\"line-numbers language-groovy\">dependencyResolutionManagement &#123;\n    repositories &#123;\n        google()\n        mavenCentral()\n    &#125;\n    versionCatalogs &#123;\n        create(&quot;libs&quot;) &#123;\n            from(files(&quot;../gradle/libs.versions.toml&quot;))\n        &#125;\n    &#125;\n&#125;\n\nrootProject.name = &quot;build-logic&quot;\ninclude(&quot;:convention&quot;)\n</code></pre>\n<p>这里最为关键的是用了一个 versionCatelogs，这里定义了我们所有三方依赖的地方。然后引入了这个模块下的convention的具体模块，这个模块就是编写自定义插件的地方。</p>\n<p>简单看下这个libs.version.toml文件吧，它放在项目级下的gradle文件夹中了：</p>\n<pre><code class=\"line-numbers language-groovy\">[versions]\naccompanist = &quot;0.28.0&quot;\nandroidDesugarJdkLibs = &quot;1.2.2&quot;\nandroidGradlePlugin = &quot;7.3.1&quot;\nandroidxActivity = &quot;1.6.1&quot;\nandroidxAppCompat = &quot;1.5.1&quot;\nandroidxBrowser = &quot;1.4.0&quot;\nandroidxComposeBom = &quot;2022.12.00&quot;\nandroidxComposeCompiler = &quot;1.4.0-alpha02&quot;\nandroidxComposeRuntimeTracing = &quot;1.0.0-alpha01&quot;\nandroidxCore = &quot;1.9.0&quot;\nandroidxCoreSplashscreen = &quot;1.0.0&quot;\nandroidxDataStore = &quot;1.0.0&quot;\nandroidxEspresso = &quot;3.5.0&quot;\nandroidxHiltNavigationCompose = &quot;1.0.0&quot;\nandroidxLifecycle = &quot;2.6.0-alpha03&quot;\nandroidxMacroBenchmark = &quot;1.1.1&quot;\nandroidxMetrics = &quot;1.0.0-alpha03&quot;\nandroidxNavigation = &quot;2.5.3&quot;\nandroidxProfileinstaller = &quot;1.2.1&quot;\n等等...\n</code></pre>\n<p>看下build-logic 模块下的build.gradle.kts文件：<br>首先引入了 kotlin-dsl 插件：</p>\n<pre><code class=\"line-numbers language-groovy\">plugins &#123;\n    `kotlin-dsl`\n&#125;\n</code></pre>\n<p>这样就能写 java 闭包了，还有一些 compileOnly方法等。具体关于dsl使用方法可以参考这篇文章：<a href=\"https://www.jianshu.com/p/461d4a249b71\">https://www.jianshu.com/p/461d4a249b71</a></p>\n<p>下面配置了执行build-logic需要依赖的一些东西：</p>\n<pre><code class=\"line-numbers language-groovy\">java &#123;\n    sourceCompatibility = JavaVersion.VERSION_1_8\n    targetCompatibility = JavaVersion.VERSION_1_8\n&#125;\n\ndependencies &#123;\n    compileOnly(libs.android.gradlePlugin)\n    compileOnly(libs.kotlin.gradlePlugin)\n&#125;\n</code></pre>\n<p>这里需要编译依赖一些三方库。</p>\n<p>然后下面是重点，gradlePlugin闭包下就是注册各种自定义插件了，并且实现类对应convention模块下的某个类，这个类继承了Plugin<Project>。</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6.总结\"></a>6.总结</h3><p>1.单独抽出一个module作为封装自定义插件的module。在这个module里面添加自定义插件的逻辑，在这个module的settings.gradle.kts中创建一个versionCatelogs，指向所有依赖文件中。<br>2.项目级别的settings.gradle.kts用includeBuild来引入上述module。<br>3.gradle.properties文件可以配置编译时buildconfig，aidl等文件是否生成。<br>4.app级别的build.gradle.kts按需配置自定义插件，testInstrumentationRunnner可以配置测试类。</p>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<blockquote>\n<p>googe samples之 nowinandroid项目地址：<a href=\"https://github.com/android/nowinandroid\">https://github.com/android/nowinandroid</a></p>\n</blockquote>\n<h3 id=\"1-gradle-properties\"><a href=\"#1-gradle-properties\" class=\"headerlink\" title=\"1.gradle.properties\"></a>1.gradle.properties</h3><p>这里面配置了 android.useAndroidX等常用的配置，这里应该耳熟能详了，这里就不过多介绍。下面这里有一块不是特别熟悉：</p>\n<pre><code class=\"line-numbers language-groovy\"># Disable build features that are enabled by default,\n# https://developer.android.com/studio/releases/gradle-plugin#buildFeatures\nandroid.defaults.buildfeatures.buildconfig=false\nandroid.defaults.buildfeatures.aidl=false\nandroid.defaults.buildfeatures.renderscript=false\nandroid.defaults.buildfeatures.resvalues=false\nandroid.defaults.buildfeatures.shaders=false\n</code></pre>\n<p>通过关闭buildfeatures.buildconfig，来提升构建性能。有时候模块不需要生成buildconfig文件，那直接关闭即可。还有其它的aidl，renderscript，resvalues同理。</p>\n<h3 id=\"2-项目settings-gradle-kts\"><a href=\"#2-项目settings-gradle-kts\" class=\"headerlink\" title=\"2.项目settings.gradle.kts\"></a>2.项目settings.gradle.kts</h3><p>这里首先是一个pluginManagement闭包：</p>\n<pre><code class=\"line-numbers language-groovy\">pluginManagement &#123;\n    includeBuild(&quot;build-logic&quot;) // 多模块共享模块\n    repositories &#123;\n        google()\n        mavenCentral()\n        gradlePluginPortal()\n    &#125;\n&#125;\n</code></pre>\n<p>第一个问题是：pluginManagement是什么东西啊？没见过。<br>简单来说：dependencyManagement用于在父项目中统一对子项目依赖管理。这样就可以对所有模块的版本进行管理。</p>\n<p>第二个问题是：includeBuild是什么？<br>相信大部分人都有用过buildSrc吧。如果没有，那config.gradle总用过吧，总之就是把不同模块之前相同依赖抽出来，同时引用。 buildSrc的弊端就是每次依赖更新都将重新构建整个项目，导致编译时间很长，这里google官方推荐使用includeBuild来解决这个问题。</p>\n<p>然后gradlePluginProtal() 远程插件仓库，是google推荐的。</p>\n<p>第二块代码是这样的：</p>\n<pre><code class=\"line-numbers language-groovy\">dependencyResolutionManagement &#123;\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories &#123;\n        google()\n        mavenCentral()\n    &#125;\n&#125;\n</code></pre>\n<p>当您的依赖项不是本地库或文件树时，Gradle 会在 settings.gradle 文件的 dependencyResolutionManagement { repositories {…} } 代码块中指定的所有在线仓库中查找相关文件。 各个仓库的列出顺序决定了 Gradle 在这些仓库中搜索各个项目依赖项的顺序。例如，如果从仓库 A 和 B 均可获得某个依赖项，而您先列出了仓库 A，则 Gradle 会从仓库 A 下载该依赖项。说白了，就是有一个优先权，从上往下。</p>\n<p>然后这个文件其它内容没啥参考价值了，都是include多个模块。<br>这个文件最重要也是最关键的地方就是 includeBuild(“build-logic”)</p>\n<h3 id=\"3-项目级build-gradle-kts\"><a href=\"#3-项目级build-gradle-kts\" class=\"headerlink\" title=\"3.项目级build.gradle.kts\"></a>3.项目级build.gradle.kts</h3><p>首先是一个buildscript闭包：</p>\n<pre><code class=\"line-numbers language-groovy\">buildscript &#123;\n    repositories &#123;\n        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/public&quot;) &#125;\n        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/gradle-plugin&quot;) &#125;\n        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/central&quot;) &#125;\n        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/google&quot;) &#125;\n\n        mavenCentral()\n        google()\n\n\n        // Android Build Server\n        maven &#123; url = uri(&quot;../nowinandroid-prebuilts/m2repository&quot;) &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>其实这里引发了另外一个问题：<br>在项目根目录（root Project）下的build.gradle中：buildscript、allprojects、subprojects的repositories有什么区别？</p>\n<ol>\n<li>buildScript块的repositories主要是为了Gradle脚本自身的执行，获取脚本依赖插件。也就是说，buildScript是用来加载Gradle脚本自身需要使用的资源，可以声明的资源包括依赖项、第三方插件、maven仓库地址等。</li>\n<li>根级别的repositories主要是为了当前项目提供所需依赖包，比如log4j、spring-core等依赖包可从mavenCentral仓库获得。</li>\n<li>allprojects块的repositories用于多项目构建，为所有项目提供共同的所需依赖包。而子项目可以配置自己的repositories以获取自己独需的依赖包。</li>\n<li>subprojects块的repositories用于配置这个项目的子项目。使用多模块项目时，不同模块之间有相同的配置，导致重复配置，可以将相同的部分抽取出来，使用配置注入的技术完成子项目的配置。根项目就像一个容器, subprojects 方法遍历这个容器的所有元素并且注入指定的配置。allprojects是对所有project的配置，包括Root Project。而subprojects是对所有Child Project的配置。</li>\n</ol>\n<p>这里说明buildScript里面的仓库主要用于Gradle脚本自身执行，因为这里一直超时，我把阿里云镜像加进去就没问题了，估计是下载Gradle脚本自身相关依赖导致超时了。</p>\n<p>然后下面还有一部分是plugins闭包：</p>\n<pre><code class=\"line-numbers language-groovy\">plugins &#123;\n    alias(libs.plugins.android.application) apply false\n    alias(libs.plugins.kotlin.jvm) apply false\n    alias(libs.plugins.kotlin.serialization) apply false\n    alias(libs.plugins.hilt) apply false\n    alias(libs.plugins.secrets) apply false\n&#125;\n</code></pre>\n<p>这里的libs就是在 前面的build-logic模块下的 versionCatalogs创建的一个名称。<br>定义了后，这里就可以引用了。这里应该是引用插件，不过都是apply false，这里的作用个人还不是很清楚。</p>\n<h3 id=\"4-app模块下的build-gradle-kts\"><a href=\"#4-app模块下的build-gradle-kts\" class=\"headerlink\" title=\"4.app模块下的build.gradle.kts\"></a>4.app模块下的build.gradle.kts</h3><p>这里第一行是：<br><code>import com.google.samples.apps.nowinandroid.NiaBuildType</code><br>这里可以引用自己编写的类，<br>这个类定义再build-logic模块中，是一个枚举类，看一下吧：</p>\n<pre><code class=\"line-numbers language-groovy\">package com.google.samples.apps.nowinandroid\n\n/**\n * This is shared between :app and :benchmarks module to provide configurations type safety.\n */\n@Suppress(&quot;unused&quot;)\nenum class NiaBuildType(val applicationIdSuffix: String? = null) &#123;\n    DEBUG(&quot;.debug&quot;),\n    RELEASE,\n    BENCHMARK(&quot;.benchmark&quot;)\n&#125;\n</code></pre>\n<p>估计是代表编译模式，debug还是release，或者其它模式。</p>\n<p>然后继续回到build.gradle.kts文件下，<br>这里引入插件了：</p>\n<pre><code class=\"line-numbers language-groovy\">plugins &#123;\n    id(&quot;nowinandroid.android.application&quot;)\n    id(&quot;nowinandroid.android.application.compose&quot;)\n    id(&quot;nowinandroid.android.application.jacoco&quot;)\n    id(&quot;nowinandroid.android.hilt&quot;)\n    id(&quot;jacoco&quot;)\n    id(&quot;nowinandroid.firebase-perf&quot;)\n&#125;\n</code></pre>\n<p>注意这几个有nowinandroid前缀的应该都是我们自己编写的插件。<br>首先看下第一个：noewinandroid.android.application</p>\n<p>当然还是先全局搜索下，发现在build-logic模块下注册了：</p>\n<pre><code class=\"line-numbers language-groovy\">gradlePlugin &#123;\n    plugins &#123;\n        register(&quot;androidApplicationCompose&quot;) &#123;\n            id = &quot;nowinandroid.android.application.compose&quot;\n            implementationClass = &quot;AndroidApplicationComposeConventionPlugin&quot;\n        &#125;\n        register(&quot;androidApplication&quot;) &#123;\n            id = &quot;nowinandroid.android.application&quot;\n            implementationClass = &quot;AndroidApplicationConventionPlugin&quot;\n        &#125;\n</code></pre>\n<p>实现类为：AndroidApplicationConventionPlugin</p>\n<pre><code class=\"line-numbers language-groovy\">class AndroidApplicationConventionPlugin : Plugin&lt;Project&gt; &#123;\n    override fun apply(target: Project) &#123;\n        with(target) &#123;\n            with(pluginManager) &#123;\n                apply(&quot;com.android.application&quot;)\n                apply(&quot;org.jetbrains.kotlin.android&quot;)\n            &#125;\n\n            extensions.configure&lt;ApplicationExtension&gt; &#123;\n                configureKotlinAndroid(this)\n                defaultConfig.targetSdk = 33\n                configureFlavors(this)\n            &#125;\n            extensions.configure&lt;ApplicationAndroidComponentsExtension&gt; &#123;\n                configurePrintApksTask(this)\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里继承了Plugin<Project>，实现apply方法。<br>利用插件管理器pluginManager来引入”com.android.application”插件和“org.jetbrains.kotlin.android”插件。</p>\n<p>可以看到这里面帮忙apply了com.android.application，这样就不用重复再build.gradle中引入了。</p>\n<p>重点来看下引入的compose，说实话我还没用过google的jetpack compose工具包。<br>依然在build-logic下注册了这个插件：</p>\n<pre><code class=\"line-numbers language-groovy\">gradlePlugin &#123;\n    plugins &#123;\n        register(&quot;androidApplicationCompose&quot;) &#123;\n            id = &quot;nowinandroid.android.application.compose&quot;\n            implementationClass = &quot;AndroidApplicationComposeConventionPlugin&quot;\n        &#125;\n</code></pre>\n<p>实现类：AndroidApplicationComposeConventionPlugin</p>\n<pre><code class=\"line-numbers language-groovy\">class AndroidApplicationComposeConventionPlugin : Plugin&lt;Project&gt; &#123;\n    override fun apply(target: Project) &#123;\n        with(target) &#123;\n            pluginManager.apply(&quot;com.android.application&quot;)\n            val extension = extensions.getByType&lt;ApplicationExtension&gt;()\n            configureAndroidCompose(extension)\n        &#125;\n    &#125;\n\n&#125;\n</code></pre>\n<p>非常简单，先apply了com.android.application<br>然后调用了一个 configureAndroidCompose 方法，这是一个扩展方法，也是在build-logic下的一个kt文件中对Project进行了扩展。</p>\n<pre><code class=\"line-numbers language-groovy\">/**\n * Configure Compose-specific options\n */\ninternal fun Project.configureAndroidCompose(\n    commonExtension: CommonExtension&lt;*, *, *, *&gt;,\n) &#123;\n    val libs = extensions.getByType&lt;VersionCatalogsExtension&gt;().named(&quot;libs&quot;)\n\n    commonExtension.apply &#123;\n        buildFeatures &#123;\n            compose = true\n        &#125;\n\n        composeOptions &#123;\n            kotlinCompilerExtensionVersion = libs.findVersion(&quot;androidxComposeCompiler&quot;).get().toString()\n        &#125;\n\n        kotlinOptions &#123;\n            freeCompilerArgs = freeCompilerArgs + buildComposeMetricsParameters()\n        &#125;\n\n        dependencies &#123;\n            val bom = libs.findLibrary(&quot;androidx-compose-bom&quot;).get()\n            add(&quot;implementation&quot;, platform(bom))\n            add(&quot;androidTestImplementation&quot;, platform(bom))\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里编写了compose相关的必要的配置。buildFeaturs，composeOptions,kotlinOptions,dependencies这些都加上了。</p>\n<p>再回到app模块下的build.gradle.kts文件，<br>还有一个插件是：nowinandroid.android.application.jacoco<br>这个是自定义的一个代码覆盖率的一个插件，基于jacoco的。</p>\n<pre><code class=\"line-numbers language-groovy\"> register(&quot;androidApplicationJacoco&quot;) &#123;\n            id = &quot;nowinandroid.android.application.jacoco&quot;\n            implementationClass = &quot;AndroidApplicationJacocoConventionPlugin&quot;\n        &#125;\n</code></pre>\n<p>先注册，再看下实现类：</p>\n<pre><code class=\"line-numbers language-groovy\">\nclass AndroidApplicationJacocoConventionPlugin : Plugin&lt;Project&gt; &#123;\n    override fun apply(target: Project) &#123;\n        with(target) &#123;\n            with(pluginManager) &#123;\n                apply(&quot;org.gradle.jacoco&quot;)\n                apply(&quot;com.android.application&quot;)\n            &#125;\n            val extension = extensions.getByType&lt;ApplicationAndroidComponentsExtension&gt;()\n            configureJacoco(extension)\n        &#125;\n    &#125;\n\n&#125;\n</code></pre>\n<p>这里引入了gradle的jacoco插件，然后调用了configureJacoco方法。<br>具体插件使用方法可以这里看下：<a href=\"https://www.w3cschool.cn/gradle/9pg71huj.html\">https://www.w3cschool.cn/gradle/9pg71huj.html</a></p>\n<p>这个配置起来确实很麻烦，如果全部代码加到app模块下，很难进行维护，这样以插件形式确实方便很多。</p>\n<p>这里继续看app模块引入的自定义插件：hilt<br>这个想必大家都不陌生了，是一个依赖注入的插件，基于Dragger，但比Dragger简洁很多了。<br>实现类为：</p>\n<pre><code class=\"line-numbers language-groovy\">class AndroidHiltConventionPlugin : Plugin&lt;Project&gt; &#123;\n    override fun apply(target: Project) &#123;\n        with(target) &#123;\n            with(pluginManager) &#123;\n                apply(&quot;dagger.hilt.android.plugin&quot;)\n                // KAPT must go last to avoid build warnings.\n                // See: https://stackoverflow.com/questions/70550883/warning-the-following-options-were-not-recognized-by-any-processor-dagger-f\n                apply(&quot;org.jetbrains.kotlin.kapt&quot;)\n            &#125;\n\n            val libs = extensions.getByType&lt;VersionCatalogsExtension&gt;().named(&quot;libs&quot;)\n            dependencies &#123;\n                &quot;implementation&quot;(libs.findLibrary(&quot;hilt.android&quot;).get())\n                &quot;kapt&quot;(libs.findLibrary(&quot;hilt.compiler&quot;).get())\n                &quot;kaptAndroidTest&quot;(libs.findLibrary(&quot;hilt.compiler&quot;).get())\n            &#125;\n\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这样就配置好了hilt。</p>\n<p>最后一个app模块引入的插件是firebase-perf<br>这个是google出品的性能监控插件。<br>具体用法参考：<a href=\"https://blog.csdn.net/u010207898/article/details/125070024\">https://blog.csdn.net/u010207898/article/details/125070024</a></p>\n<hr>\n<p>好的下面继续看app模块下的build.gradle.kts<br>android层级下基本没啥大问题，配置applicationId版本号之类的。<br>这里有个testInstrumentationRunner选择自定义了：<br><code>testInstrumentationRunner = &quot;com.google.samples.apps.nowinandroid.core.testing.NiaTestRunner&quot;</code></p>\n<p>看下这里做了啥：<br>可以看到这个路径下是在testing模块下的，那应该就是测试相关的了。这里主要是用于单元测试的。这个NiaTestRunner继承了AndroidJunitRunner，这里代码如下：</p>\n<pre><code class=\"line-numbers language-groovy\">class NiaTestRunner : AndroidJUnitRunner() &#123;\n    override fun newApplication(cl: ClassLoader?, name: String?, context: Context?): Application &#123;\n        return super.newApplication(cl, HiltTestApplication::class.java.name, context)\n    &#125;\n&#125;\n</code></pre>\n<p>这个hilt居然还有做单元测试的注入，还是不错，收藏了。</p>\n<p>看下buildTypes里面的配置：</p>\n<pre><code class=\"line-numbers language-groovy\">   buildTypes &#123;\n        val debug by getting &#123;\n            applicationIdSuffix = NiaBuildType.DEBUG.applicationIdSuffix\n        &#125;\n</code></pre>\n<p>这里val debug by gettting为啥这样写？<br>这里其实分了2步：</p>\n<pre><code class=\"line-numbers language-groovy\">val release = getByName(&quot;release&quot;)\n    release.apply &#123;\n</code></pre>\n<p>等价于：<br><code> val release by getting</code></p>\n<p>继续下面：</p>\n<pre><code class=\"line-numbers language-groovy\">   packagingOptions &#123;\n        resources &#123;\n            excludes.add(&quot;/META-INF/&#123;AL2.0,LGPL2.1&#125;&quot;)\n        &#125;\n    &#125;\n</code></pre>\n<p>这个配置是什么呢：<br>打包配置，需要移除这个文件。</p>\n<p>继续下面：</p>\n<pre><code class=\"line-numbers language-groovy\">  testOptions &#123;\n        unitTests &#123;\n            isIncludeAndroidResources = true\n        &#125;\n        // TODO: Convert it as a convention plugin once Flamingo goes out (https://github.com/android/nowinandroid/issues/523)\n        managedDevices &#123;\n            devices &#123;\n                maybeCreate&lt;com.android.build.api.dsl.ManagedVirtualDevice&gt;(&quot;pixel4api30&quot;).apply &#123;\n                    device = &quot;Pixel 4&quot;\n                    apiLevel = 30\n                    // ATDs currently support only API level 30.\n                    systemImageSource = &quot;aosp-atd&quot;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>这里是一个testOptions，主要用于配置测试设备的一些属性。</p>\n<p>这里关于其它配置可以参考这篇文档<a href=\"https://blog.csdn.net/shulianghan/article/details/124919287\">https://blog.csdn.net/shulianghan/article/details/124919287</a></p>\n<p>继续看android闭包最后一个配置:<br><code>namespace = &quot;com.google.samples.apps.nowinandroid&quot;</code></p>\n<p>每个 Android 模块都有一个命名空间，此命名空间用作其生成的 R 和 BuildConfig 类的 Java 或 Kotlin 软件包名称。命名空间由模块的 build.gradle 文件中的 namespace 属性定义，如以下代码段所示。namespace 最初会设为您在创建项目时选择的软件包名称。</p>\n<p>最下面就是我们熟悉的dependencies了，可以看到这里非常简练，没有任何版本号，全是通过lis引入的，看着很舒服。</p>\n<pre><code class=\"line-numbers language-groovy\">\ndependencies &#123;\n    implementation(project(&quot;:feature:interests&quot;))\n    implementation(project(&quot;:feature:foryou&quot;))\n    implementation(project(&quot;:feature:bookmarks&quot;))\n    implementation(project(&quot;:feature:topic&quot;))\n    implementation(project(&quot;:feature:settings&quot;))\n\n    implementation(project(&quot;:core:common&quot;))\n    implementation(project(&quot;:core:ui&quot;))\n    implementation(project(&quot;:core:designsystem&quot;))\n    implementation(project(&quot;:core:data&quot;))\n    implementation(project(&quot;:core:model&quot;))\n\n    implementation(project(&quot;:sync:work&quot;))\n\n    androidTestImplementation(project(&quot;:core:testing&quot;))\n    androidTestImplementation(project(&quot;:core:datastore-test&quot;))\n    androidTestImplementation(project(&quot;:core:data-test&quot;))\n    androidTestImplementation(project(&quot;:core:network&quot;))\n    androidTestImplementation(libs.androidx.navigation.testing)\n    androidTestImplementation(libs.accompanist.testharness)\n    androidTestImplementation(kotlin(&quot;test&quot;))\n    debugImplementation(libs.androidx.compose.ui.testManifest)\n    debugImplementation(project(&quot;:ui-test-hilt-manifest&quot;))\n\n    implementation(libs.accompanist.systemuicontroller)\n    implementation(libs.androidx.activity.compose)\n    implementation(libs.androidx.appcompat)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.core.splashscreen)\n    implementation(libs.androidx.compose.runtime)\n    implementation(libs.androidx.lifecycle.runtimeCompose)\n    implementation(libs.androidx.compose.runtime.tracing)\n    implementation(libs.androidx.compose.material3.windowSizeClass)\n    implementation(libs.androidx.hilt.navigation.compose)\n    implementation(libs.androidx.navigation.compose)\n    implementation(libs.androidx.window.manager)\n    implementation(libs.androidx.profileinstaller)\n\n    implementation(libs.coil.kt)\n    implementation(libs.coil.kt.svg)\n&#125;\n</code></pre>\n<p>最下面是强制使用某个依赖：</p>\n<pre><code class=\"line-numbers language-groovy\">// androidx.test is forcing JUnit, 4.12. This forces it to use 4.13\nconfigurations.configureEach &#123;\n    resolutionStrategy &#123;\n        force(libs.junit4)\n        // Temporary workaround for https://issuetracker.google.com/174733673\n        force(&quot;org.objenesis:objenesis:2.6&quot;)\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"5-build-logic-模块配置构建逻辑\"><a href=\"#5-build-logic-模块配置构建逻辑\" class=\"headerlink\" title=\"5.build-logic 模块配置构建逻辑\"></a>5.build-logic 模块配置构建逻辑</h3><p>这里完全封装了自定义插件，定义依赖，配置相关的逻辑主要在这个模块，其实这个模块感觉可以复用，就是说换一个项目，这个模块基本上可以通用，改改具体版本号或者属性即可。哪些要用，哪些不用，在app模块下按需注册插件即可。</p>\n<p>首先看下这个模块的setttings.gradle.kts文件<br>很简单：</p>\n<pre><code class=\"line-numbers language-groovy\">dependencyResolutionManagement &#123;\n    repositories &#123;\n        google()\n        mavenCentral()\n    &#125;\n    versionCatalogs &#123;\n        create(&quot;libs&quot;) &#123;\n            from(files(&quot;../gradle/libs.versions.toml&quot;))\n        &#125;\n    &#125;\n&#125;\n\nrootProject.name = &quot;build-logic&quot;\ninclude(&quot;:convention&quot;)\n</code></pre>\n<p>这里最为关键的是用了一个 versionCatelogs，这里定义了我们所有三方依赖的地方。然后引入了这个模块下的convention的具体模块，这个模块就是编写自定义插件的地方。</p>\n<p>简单看下这个libs.version.toml文件吧，它放在项目级下的gradle文件夹中了：</p>\n<pre><code class=\"line-numbers language-groovy\">[versions]\naccompanist = &quot;0.28.0&quot;\nandroidDesugarJdkLibs = &quot;1.2.2&quot;\nandroidGradlePlugin = &quot;7.3.1&quot;\nandroidxActivity = &quot;1.6.1&quot;\nandroidxAppCompat = &quot;1.5.1&quot;\nandroidxBrowser = &quot;1.4.0&quot;\nandroidxComposeBom = &quot;2022.12.00&quot;\nandroidxComposeCompiler = &quot;1.4.0-alpha02&quot;\nandroidxComposeRuntimeTracing = &quot;1.0.0-alpha01&quot;\nandroidxCore = &quot;1.9.0&quot;\nandroidxCoreSplashscreen = &quot;1.0.0&quot;\nandroidxDataStore = &quot;1.0.0&quot;\nandroidxEspresso = &quot;3.5.0&quot;\nandroidxHiltNavigationCompose = &quot;1.0.0&quot;\nandroidxLifecycle = &quot;2.6.0-alpha03&quot;\nandroidxMacroBenchmark = &quot;1.1.1&quot;\nandroidxMetrics = &quot;1.0.0-alpha03&quot;\nandroidxNavigation = &quot;2.5.3&quot;\nandroidxProfileinstaller = &quot;1.2.1&quot;\n等等...\n</code></pre>\n<p>看下build-logic 模块下的build.gradle.kts文件：<br>首先引入了 kotlin-dsl 插件：</p>\n<pre><code class=\"line-numbers language-groovy\">plugins &#123;\n    `kotlin-dsl`\n&#125;\n</code></pre>\n<p>这样就能写 java 闭包了，还有一些 compileOnly方法等。具体关于dsl使用方法可以参考这篇文章：<a href=\"https://www.jianshu.com/p/461d4a249b71\">https://www.jianshu.com/p/461d4a249b71</a></p>\n<p>下面配置了执行build-logic需要依赖的一些东西：</p>\n<pre><code class=\"line-numbers language-groovy\">java &#123;\n    sourceCompatibility = JavaVersion.VERSION_1_8\n    targetCompatibility = JavaVersion.VERSION_1_8\n&#125;\n\ndependencies &#123;\n    compileOnly(libs.android.gradlePlugin)\n    compileOnly(libs.kotlin.gradlePlugin)\n&#125;\n</code></pre>\n<p>这里需要编译依赖一些三方库。</p>\n<p>然后下面是重点，gradlePlugin闭包下就是注册各种自定义插件了，并且实现类对应convention模块下的某个类，这个类继承了Plugin<Project>。</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6.总结\"></a>6.总结</h3><p>1.单独抽出一个module作为封装自定义插件的module。在这个module里面添加自定义插件的逻辑，在这个module的settings.gradle.kts中创建一个versionCatelogs，指向所有依赖文件中。<br>2.项目级别的settings.gradle.kts用includeBuild来引入上述module。<br>3.gradle.properties文件可以配置编译时buildconfig，aidl等文件是否生成。<br>4.app级别的build.gradle.kts按需配置自定义插件，testInstrumentationRunnner可以配置测试类。</p>\n"},{"title":"Android 学习导航","date":"2023-01-21T06:14:49.000Z","top":true,"cover":false,"toc":true,"mathjax":true,"_content":"\n# 1 知识体系\n\t\n## 1.1 Android性能优化\n\n### 1.1.1 包体积优化\n> [https://juejin.cn/post/7186580175222472759](https://juejin.cn/post/7186580175222472759)\n\n\n\n# 2 优秀站点\n\n## 2.1 玩Android\n\n### 2.1.1 热门博文\n> [https://www.wanandroid.com/index?cid=0](https://www.wanandroid.com/index?cid=0)\n\t\t\n### 2.1.2 每日更新\n> [https://www.wanandroid.com/user_article](https://www.wanandroid.com/user_article)\n\n\n## 2.2 掘金\n\n### 2.2.1 热门博文\n> [https://juejin.cn/android?sort=monthly_hottest](https://juejin.cn/android?sort=monthly_hottest)\n\n### 2.2.2 每日更新\n> [https://juejin.cn/android?sort=newest](https://juejin.cn/android?sort=newest)\n\n\n## 2.3 简书\n\n### 2.3.1 热门博文\n> [https://www.jianshu.com/techareas/andriod](https://www.jianshu.com/techareas/andriod)\n\n## 2.4 CSDN\n\n### 2.4.1 热门博文\n> [https://blog.csdn.net/nav/mobile/android](https://blog.csdn.net/nav/mobile/android)\n\n## 2.5 开源中国\n\n### 2.5.1 Android开发专区\n> [https://www.oschina.net/android](https://www.oschina.net/android)\n\n## 2.6 Medium(国外)\n\n### 2.6.1 热门问答\n> [https://medium.com/tag/android](https://medium.com/tag/android)\n\n## 2.7 stackoverflow(国外)\n\n### 2.7.1 热门问答\n> [https://stackoverflow.com/questions/tagged/android](https://stackoverflow.com/questions/tagged/android)\n\n## 2.8 Android周报（国外）\n> [https://androidweekly.net/](https://androidweekly.net/)\n\n## 2.9 codeKK\n\n### 2.9.1 Github每日开源\n> [https://p.codekk.com/](https://p.codekk.com/)\n\n## 2.10 github相关\n\n### 2.10.1 关于kotlin每日趋势增长\n> [https://github.com/trending/kotlin?since=daily](https://github.com/trending/kotlin?since=weekly)\n\n## 2.10.2 关于Android的话题\n> [https://github.com/topics/android](https://github.com/topics/android)\n\n\n# 3.公众号\n\n## 3.1 鸿洋\n<img src=hongyang.jpeg>\n\t\t\n## 3.2 郭霖\n<img src=guolin.jpeg>\n\t\t\n## 3.3 Carson\n<img src=carson.jpeg>\n\t\t\n## 3.4 JsonChao\n<img src=jsonchao.jpeg>\n\t\t\n## 3.5 Android群英传\n<img src=qunyingzhuan.jpeg>\n\t\t\n## 3.6 Android编程精选\n<img src=bianchengjingxuan.jpeg>\n\t\t\n## 3.7 Android技术专家\n<img src=jishuzhuanjia.jpeg>\n\t\t\n## 3.8 Android技术圈\n<img src=jishuquan.jpeg>\n\t\t\n\n# 4.大神博客\n\n## 4.1 jsonChao（平安）\n> [https://juejin.cn/user/4318537403878167/posts](https://juejin.cn/user/4318537403878167/posts)\n\n## 4.2 鸿洋（百度）\n> [https://blog.csdn.net/lmj623565791/](https://blog.csdn.net/lmj623565791/)\n\n## 4.3 郭霖\n> [https://blog.csdn.net/guolin_blog/](https://blog.csdn.net/guolin_blog/)\n\n## 4.4 Carson（微信）\n> [https://www.jianshu.com/u/383970bef0a0](https://www.jianshu.com/u/383970bef0a0)\n\n## 4.5 何强（魅族）\n> [https://www.heqiangfly.com/archives/](https://www.heqiangfly.com/archives/)\n\n## 4.6 爱雨浮龙（阿里）\n> [https://juejin.cn/user/2805609405877415/posts](https://juejin.cn/user/2805609405877415/posts)\n\n## 4.7 Android学习资源大全（19年后未更新了）\n> [https://juejin.cn/user/2805609405877415/posts](https://juejin.cn/user/2805609405877415/posts)\n\n## 4.8 徐医生\n> [https://blog.csdn.net/eclipsexys](https://blog.csdn.net/eclipsexys)\n\n## 4.9 技术小黑屋\n> [https://droidyue.com/](https://droidyue.com/)\n\t\n## 4.10 刘望舒\n> [https://liuwangshu.blog.csdn.net/](https://liuwangshu.blog.csdn.net/)\n\n## 4.11 任玉刚\n> [https://blog.csdn.net/singwhatiwanna](https://blog.csdn.net/singwhatiwanna)\n\n## 4.12 Gityuan\n> [http://gityuan.com/](http://gityuan.com/)\n\n## 4.13 扔物线\n> [https://rengwuxian.com/](https://rengwuxian.com/)\n\n## 4.14 yrom\n> [https://yrom.net/archives/](https://yrom.net/archives/)\n\n## 4.15 美团\n> [https://tech.meituan.com/](https://tech.meituan.com/)\n\n## 4.16 切切歆语\n> [https://blog.csdn.net/dickyqie/category_6238189.html](https://blog.csdn.net/dickyqie/category_6238189.html)\n\n# 5.优秀三方库\n\t\n## 5.1 网络相关\n\n### 5.1.1 Retrofit\n> [https://github.com/square/retrofit](https://github.com/square/retrofit)\n\n### 5.1.2 OKHttp\n> [https://github.com/square/okhttp](https://github.com/square/okhttp)\n\n## 5.2 图片相关\n\n### 5.2.1 Glide\n> [https://github.com/bumptech/glide](https://github.com/bumptech/glide)\n\n## 5.3 响应式相关\n\n### 5.3.1 RxJava\n> [https://github.com/ReactiveX/RxJava](https://github.com/ReactiveX/RxJava)\n\n## 5.4 事件相关\n\n### 5.4.1 EventBus\n> [https://github.com/greenrobot/EventBus](https://github.com/greenrobot/EventBus)\n\n## 5.5 数据库相关\n\n### 5.5.1 greenDAO\n> [https://github.com/greenrobot/greenDAO](https://github.com/greenrobot/greenDAO)\n\n# 6.项目推荐\n\n## 6.1 wanAndroid项目推荐\n> [https://www.wanandroid.com/projectindex](https://www.wanandroid.com/projectindex)\n\n## 6.2 官方demo==nowinandroid\n> [https://github.com/android/nowinandroidhttps://github.com/android/nowinandroid](https://github.com/android/nowinandroid)\n\n## 6.3 emo==腾讯大神封装的compse基础UI\n> [https://github.com/cgspine/emo](https://github.com/cgspine/emo)\n\n# 7.其它\n\n## 7.1 面试相关\n\n## 7.2 开发工具相关\n\n## 7.3 官方资源\n\n### 7.3.1 Android官网\n> [https://developer.android.google.cn/](https://developer.android.google.cn/)\n\n### 7.3.2 Google Samples\n> [https://github.com/googlesamples](https://github.com/googlesamples)\n","source":"_posts/Android-学习导航.md","raw":"---\ntitle: Android 学习导航\ndate: 2023-01-21 14:14:49\ntop: true\ncover: false\ntoc: true\nmathjax: true\ntags:\n- Android\ncategories:\n- Android\n---\n\n# 1 知识体系\n\t\n## 1.1 Android性能优化\n\n### 1.1.1 包体积优化\n> [https://juejin.cn/post/7186580175222472759](https://juejin.cn/post/7186580175222472759)\n\n\n\n# 2 优秀站点\n\n## 2.1 玩Android\n\n### 2.1.1 热门博文\n> [https://www.wanandroid.com/index?cid=0](https://www.wanandroid.com/index?cid=0)\n\t\t\n### 2.1.2 每日更新\n> [https://www.wanandroid.com/user_article](https://www.wanandroid.com/user_article)\n\n\n## 2.2 掘金\n\n### 2.2.1 热门博文\n> [https://juejin.cn/android?sort=monthly_hottest](https://juejin.cn/android?sort=monthly_hottest)\n\n### 2.2.2 每日更新\n> [https://juejin.cn/android?sort=newest](https://juejin.cn/android?sort=newest)\n\n\n## 2.3 简书\n\n### 2.3.1 热门博文\n> [https://www.jianshu.com/techareas/andriod](https://www.jianshu.com/techareas/andriod)\n\n## 2.4 CSDN\n\n### 2.4.1 热门博文\n> [https://blog.csdn.net/nav/mobile/android](https://blog.csdn.net/nav/mobile/android)\n\n## 2.5 开源中国\n\n### 2.5.1 Android开发专区\n> [https://www.oschina.net/android](https://www.oschina.net/android)\n\n## 2.6 Medium(国外)\n\n### 2.6.1 热门问答\n> [https://medium.com/tag/android](https://medium.com/tag/android)\n\n## 2.7 stackoverflow(国外)\n\n### 2.7.1 热门问答\n> [https://stackoverflow.com/questions/tagged/android](https://stackoverflow.com/questions/tagged/android)\n\n## 2.8 Android周报（国外）\n> [https://androidweekly.net/](https://androidweekly.net/)\n\n## 2.9 codeKK\n\n### 2.9.1 Github每日开源\n> [https://p.codekk.com/](https://p.codekk.com/)\n\n## 2.10 github相关\n\n### 2.10.1 关于kotlin每日趋势增长\n> [https://github.com/trending/kotlin?since=daily](https://github.com/trending/kotlin?since=weekly)\n\n## 2.10.2 关于Android的话题\n> [https://github.com/topics/android](https://github.com/topics/android)\n\n\n# 3.公众号\n\n## 3.1 鸿洋\n<img src=hongyang.jpeg>\n\t\t\n## 3.2 郭霖\n<img src=guolin.jpeg>\n\t\t\n## 3.3 Carson\n<img src=carson.jpeg>\n\t\t\n## 3.4 JsonChao\n<img src=jsonchao.jpeg>\n\t\t\n## 3.5 Android群英传\n<img src=qunyingzhuan.jpeg>\n\t\t\n## 3.6 Android编程精选\n<img src=bianchengjingxuan.jpeg>\n\t\t\n## 3.7 Android技术专家\n<img src=jishuzhuanjia.jpeg>\n\t\t\n## 3.8 Android技术圈\n<img src=jishuquan.jpeg>\n\t\t\n\n# 4.大神博客\n\n## 4.1 jsonChao（平安）\n> [https://juejin.cn/user/4318537403878167/posts](https://juejin.cn/user/4318537403878167/posts)\n\n## 4.2 鸿洋（百度）\n> [https://blog.csdn.net/lmj623565791/](https://blog.csdn.net/lmj623565791/)\n\n## 4.3 郭霖\n> [https://blog.csdn.net/guolin_blog/](https://blog.csdn.net/guolin_blog/)\n\n## 4.4 Carson（微信）\n> [https://www.jianshu.com/u/383970bef0a0](https://www.jianshu.com/u/383970bef0a0)\n\n## 4.5 何强（魅族）\n> [https://www.heqiangfly.com/archives/](https://www.heqiangfly.com/archives/)\n\n## 4.6 爱雨浮龙（阿里）\n> [https://juejin.cn/user/2805609405877415/posts](https://juejin.cn/user/2805609405877415/posts)\n\n## 4.7 Android学习资源大全（19年后未更新了）\n> [https://juejin.cn/user/2805609405877415/posts](https://juejin.cn/user/2805609405877415/posts)\n\n## 4.8 徐医生\n> [https://blog.csdn.net/eclipsexys](https://blog.csdn.net/eclipsexys)\n\n## 4.9 技术小黑屋\n> [https://droidyue.com/](https://droidyue.com/)\n\t\n## 4.10 刘望舒\n> [https://liuwangshu.blog.csdn.net/](https://liuwangshu.blog.csdn.net/)\n\n## 4.11 任玉刚\n> [https://blog.csdn.net/singwhatiwanna](https://blog.csdn.net/singwhatiwanna)\n\n## 4.12 Gityuan\n> [http://gityuan.com/](http://gityuan.com/)\n\n## 4.13 扔物线\n> [https://rengwuxian.com/](https://rengwuxian.com/)\n\n## 4.14 yrom\n> [https://yrom.net/archives/](https://yrom.net/archives/)\n\n## 4.15 美团\n> [https://tech.meituan.com/](https://tech.meituan.com/)\n\n## 4.16 切切歆语\n> [https://blog.csdn.net/dickyqie/category_6238189.html](https://blog.csdn.net/dickyqie/category_6238189.html)\n\n# 5.优秀三方库\n\t\n## 5.1 网络相关\n\n### 5.1.1 Retrofit\n> [https://github.com/square/retrofit](https://github.com/square/retrofit)\n\n### 5.1.2 OKHttp\n> [https://github.com/square/okhttp](https://github.com/square/okhttp)\n\n## 5.2 图片相关\n\n### 5.2.1 Glide\n> [https://github.com/bumptech/glide](https://github.com/bumptech/glide)\n\n## 5.3 响应式相关\n\n### 5.3.1 RxJava\n> [https://github.com/ReactiveX/RxJava](https://github.com/ReactiveX/RxJava)\n\n## 5.4 事件相关\n\n### 5.4.1 EventBus\n> [https://github.com/greenrobot/EventBus](https://github.com/greenrobot/EventBus)\n\n## 5.5 数据库相关\n\n### 5.5.1 greenDAO\n> [https://github.com/greenrobot/greenDAO](https://github.com/greenrobot/greenDAO)\n\n# 6.项目推荐\n\n## 6.1 wanAndroid项目推荐\n> [https://www.wanandroid.com/projectindex](https://www.wanandroid.com/projectindex)\n\n## 6.2 官方demo==nowinandroid\n> [https://github.com/android/nowinandroidhttps://github.com/android/nowinandroid](https://github.com/android/nowinandroid)\n\n## 6.3 emo==腾讯大神封装的compse基础UI\n> [https://github.com/cgspine/emo](https://github.com/cgspine/emo)\n\n# 7.其它\n\n## 7.1 面试相关\n\n## 7.2 开发工具相关\n\n## 7.3 官方资源\n\n### 7.3.1 Android官网\n> [https://developer.android.google.cn/](https://developer.android.google.cn/)\n\n### 7.3.2 Google Samples\n> [https://github.com/googlesamples](https://github.com/googlesamples)\n","slug":"Android-学习导航","published":1,"updated":"2023-02-01T06:13:34.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlc01jc000djhv7cg5d54j1","content":"<h1 id=\"1-知识体系\"><a href=\"#1-知识体系\" class=\"headerlink\" title=\"1 知识体系\"></a>1 知识体系</h1><h2 id=\"1-1-Android性能优化\"><a href=\"#1-1-Android性能优化\" class=\"headerlink\" title=\"1.1 Android性能优化\"></a>1.1 Android性能优化</h2><h3 id=\"1-1-1-包体积优化\"><a href=\"#1-1-1-包体积优化\" class=\"headerlink\" title=\"1.1.1 包体积优化\"></a>1.1.1 包体积优化</h3><blockquote>\n<p><a href=\"https://juejin.cn/post/7186580175222472759\">https://juejin.cn/post/7186580175222472759</a></p>\n</blockquote>\n<h1 id=\"2-优秀站点\"><a href=\"#2-优秀站点\" class=\"headerlink\" title=\"2 优秀站点\"></a>2 优秀站点</h1><h2 id=\"2-1-玩Android\"><a href=\"#2-1-玩Android\" class=\"headerlink\" title=\"2.1 玩Android\"></a>2.1 玩Android</h2><h3 id=\"2-1-1-热门博文\"><a href=\"#2-1-1-热门博文\" class=\"headerlink\" title=\"2.1.1 热门博文\"></a>2.1.1 热门博文</h3><blockquote>\n<p><a href=\"https://www.wanandroid.com/index?cid=0\">https://www.wanandroid.com/index?cid=0</a></p>\n</blockquote>\n<h3 id=\"2-1-2-每日更新\"><a href=\"#2-1-2-每日更新\" class=\"headerlink\" title=\"2.1.2 每日更新\"></a>2.1.2 每日更新</h3><blockquote>\n<p><a href=\"https://www.wanandroid.com/user_article\">https://www.wanandroid.com/user_article</a></p>\n</blockquote>\n<h2 id=\"2-2-掘金\"><a href=\"#2-2-掘金\" class=\"headerlink\" title=\"2.2 掘金\"></a>2.2 掘金</h2><h3 id=\"2-2-1-热门博文\"><a href=\"#2-2-1-热门博文\" class=\"headerlink\" title=\"2.2.1 热门博文\"></a>2.2.1 热门博文</h3><blockquote>\n<p><a href=\"https://juejin.cn/android?sort=monthly_hottest\">https://juejin.cn/android?sort=monthly_hottest</a></p>\n</blockquote>\n<h3 id=\"2-2-2-每日更新\"><a href=\"#2-2-2-每日更新\" class=\"headerlink\" title=\"2.2.2 每日更新\"></a>2.2.2 每日更新</h3><blockquote>\n<p><a href=\"https://juejin.cn/android?sort=newest\">https://juejin.cn/android?sort=newest</a></p>\n</blockquote>\n<h2 id=\"2-3-简书\"><a href=\"#2-3-简书\" class=\"headerlink\" title=\"2.3 简书\"></a>2.3 简书</h2><h3 id=\"2-3-1-热门博文\"><a href=\"#2-3-1-热门博文\" class=\"headerlink\" title=\"2.3.1 热门博文\"></a>2.3.1 热门博文</h3><blockquote>\n<p><a href=\"https://www.jianshu.com/techareas/andriod\">https://www.jianshu.com/techareas/andriod</a></p>\n</blockquote>\n<h2 id=\"2-4-CSDN\"><a href=\"#2-4-CSDN\" class=\"headerlink\" title=\"2.4 CSDN\"></a>2.4 CSDN</h2><h3 id=\"2-4-1-热门博文\"><a href=\"#2-4-1-热门博文\" class=\"headerlink\" title=\"2.4.1 热门博文\"></a>2.4.1 热门博文</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/nav/mobile/android\">https://blog.csdn.net/nav/mobile/android</a></p>\n</blockquote>\n<h2 id=\"2-5-开源中国\"><a href=\"#2-5-开源中国\" class=\"headerlink\" title=\"2.5 开源中国\"></a>2.5 开源中国</h2><h3 id=\"2-5-1-Android开发专区\"><a href=\"#2-5-1-Android开发专区\" class=\"headerlink\" title=\"2.5.1 Android开发专区\"></a>2.5.1 Android开发专区</h3><blockquote>\n<p><a href=\"https://www.oschina.net/android\">https://www.oschina.net/android</a></p>\n</blockquote>\n<h2 id=\"2-6-Medium-国外\"><a href=\"#2-6-Medium-国外\" class=\"headerlink\" title=\"2.6 Medium(国外)\"></a>2.6 Medium(国外)</h2><h3 id=\"2-6-1-热门问答\"><a href=\"#2-6-1-热门问答\" class=\"headerlink\" title=\"2.6.1 热门问答\"></a>2.6.1 热门问答</h3><blockquote>\n<p><a href=\"https://medium.com/tag/android\">https://medium.com/tag/android</a></p>\n</blockquote>\n<h2 id=\"2-7-stackoverflow-国外\"><a href=\"#2-7-stackoverflow-国外\" class=\"headerlink\" title=\"2.7 stackoverflow(国外)\"></a>2.7 stackoverflow(国外)</h2><h3 id=\"2-7-1-热门问答\"><a href=\"#2-7-1-热门问答\" class=\"headerlink\" title=\"2.7.1 热门问答\"></a>2.7.1 热门问答</h3><blockquote>\n<p><a href=\"https://stackoverflow.com/questions/tagged/android\">https://stackoverflow.com/questions/tagged/android</a></p>\n</blockquote>\n<h2 id=\"2-8-Android周报（国外）\"><a href=\"#2-8-Android周报（国外）\" class=\"headerlink\" title=\"2.8 Android周报（国外）\"></a>2.8 Android周报（国外）</h2><blockquote>\n<p><a href=\"https://androidweekly.net/\">https://androidweekly.net/</a></p>\n</blockquote>\n<h2 id=\"2-9-codeKK\"><a href=\"#2-9-codeKK\" class=\"headerlink\" title=\"2.9 codeKK\"></a>2.9 codeKK</h2><h3 id=\"2-9-1-Github每日开源\"><a href=\"#2-9-1-Github每日开源\" class=\"headerlink\" title=\"2.9.1 Github每日开源\"></a>2.9.1 Github每日开源</h3><blockquote>\n<p><a href=\"https://p.codekk.com/\">https://p.codekk.com/</a></p>\n</blockquote>\n<h2 id=\"2-10-github相关\"><a href=\"#2-10-github相关\" class=\"headerlink\" title=\"2.10 github相关\"></a>2.10 github相关</h2><h3 id=\"2-10-1-关于kotlin每日趋势增长\"><a href=\"#2-10-1-关于kotlin每日趋势增长\" class=\"headerlink\" title=\"2.10.1 关于kotlin每日趋势增长\"></a>2.10.1 关于kotlin每日趋势增长</h3><blockquote>\n<p><a href=\"https://github.com/trending/kotlin?since=weekly\">https://github.com/trending/kotlin?since=daily</a></p>\n</blockquote>\n<h2 id=\"2-10-2-关于Android的话题\"><a href=\"#2-10-2-关于Android的话题\" class=\"headerlink\" title=\"2.10.2 关于Android的话题\"></a>2.10.2 关于Android的话题</h2><blockquote>\n<p><a href=\"https://github.com/topics/android\">https://github.com/topics/android</a></p>\n</blockquote>\n<h1 id=\"3-公众号\"><a href=\"#3-公众号\" class=\"headerlink\" title=\"3.公众号\"></a>3.公众号</h1><h2 id=\"3-1-鸿洋\"><a href=\"#3-1-鸿洋\" class=\"headerlink\" title=\"3.1 鸿洋\"></a>3.1 鸿洋</h2><img src=hongyang.jpeg>\n        \n<h2 id=\"3-2-郭霖\"><a href=\"#3-2-郭霖\" class=\"headerlink\" title=\"3.2 郭霖\"></a>3.2 郭霖</h2><img src=guolin.jpeg>\n        \n<h2 id=\"3-3-Carson\"><a href=\"#3-3-Carson\" class=\"headerlink\" title=\"3.3 Carson\"></a>3.3 Carson</h2><img src=carson.jpeg>\n        \n<h2 id=\"3-4-JsonChao\"><a href=\"#3-4-JsonChao\" class=\"headerlink\" title=\"3.4 JsonChao\"></a>3.4 JsonChao</h2><img src=jsonchao.jpeg>\n        \n<h2 id=\"3-5-Android群英传\"><a href=\"#3-5-Android群英传\" class=\"headerlink\" title=\"3.5 Android群英传\"></a>3.5 Android群英传</h2><img src=qunyingzhuan.jpeg>\n        \n<h2 id=\"3-6-Android编程精选\"><a href=\"#3-6-Android编程精选\" class=\"headerlink\" title=\"3.6 Android编程精选\"></a>3.6 Android编程精选</h2><img src=bianchengjingxuan.jpeg>\n        \n<h2 id=\"3-7-Android技术专家\"><a href=\"#3-7-Android技术专家\" class=\"headerlink\" title=\"3.7 Android技术专家\"></a>3.7 Android技术专家</h2><img src=jishuzhuanjia.jpeg>\n        \n<h2 id=\"3-8-Android技术圈\"><a href=\"#3-8-Android技术圈\" class=\"headerlink\" title=\"3.8 Android技术圈\"></a>3.8 Android技术圈</h2><img src=jishuquan.jpeg>\n        \n\n<h1 id=\"4-大神博客\"><a href=\"#4-大神博客\" class=\"headerlink\" title=\"4.大神博客\"></a>4.大神博客</h1><h2 id=\"4-1-jsonChao（平安）\"><a href=\"#4-1-jsonChao（平安）\" class=\"headerlink\" title=\"4.1 jsonChao（平安）\"></a>4.1 jsonChao（平安）</h2><blockquote>\n<p><a href=\"https://juejin.cn/user/4318537403878167/posts\">https://juejin.cn/user/4318537403878167/posts</a></p>\n</blockquote>\n<h2 id=\"4-2-鸿洋（百度）\"><a href=\"#4-2-鸿洋（百度）\" class=\"headerlink\" title=\"4.2 鸿洋（百度）\"></a>4.2 鸿洋（百度）</h2><blockquote>\n<p><a href=\"https://blog.csdn.net/lmj623565791/\">https://blog.csdn.net/lmj623565791/</a></p>\n</blockquote>\n<h2 id=\"4-3-郭霖\"><a href=\"#4-3-郭霖\" class=\"headerlink\" title=\"4.3 郭霖\"></a>4.3 郭霖</h2><blockquote>\n<p><a href=\"https://blog.csdn.net/guolin_blog/\">https://blog.csdn.net/guolin_blog&#x2F;</a></p>\n</blockquote>\n<h2 id=\"4-4-Carson（微信）\"><a href=\"#4-4-Carson（微信）\" class=\"headerlink\" title=\"4.4 Carson（微信）\"></a>4.4 Carson（微信）</h2><blockquote>\n<p><a href=\"https://www.jianshu.com/u/383970bef0a0\">https://www.jianshu.com/u/383970bef0a0</a></p>\n</blockquote>\n<h2 id=\"4-5-何强（魅族）\"><a href=\"#4-5-何强（魅族）\" class=\"headerlink\" title=\"4.5 何强（魅族）\"></a>4.5 何强（魅族）</h2><blockquote>\n<p><a href=\"https://www.heqiangfly.com/archives/\">https://www.heqiangfly.com/archives/</a></p>\n</blockquote>\n<h2 id=\"4-6-爱雨浮龙（阿里）\"><a href=\"#4-6-爱雨浮龙（阿里）\" class=\"headerlink\" title=\"4.6 爱雨浮龙（阿里）\"></a>4.6 爱雨浮龙（阿里）</h2><blockquote>\n<p><a href=\"https://juejin.cn/user/2805609405877415/posts\">https://juejin.cn/user/2805609405877415/posts</a></p>\n</blockquote>\n<h2 id=\"4-7-Android学习资源大全（19年后未更新了）\"><a href=\"#4-7-Android学习资源大全（19年后未更新了）\" class=\"headerlink\" title=\"4.7 Android学习资源大全（19年后未更新了）\"></a>4.7 Android学习资源大全（19年后未更新了）</h2><blockquote>\n<p><a href=\"https://juejin.cn/user/2805609405877415/posts\">https://juejin.cn/user/2805609405877415/posts</a></p>\n</blockquote>\n<h2 id=\"4-8-徐医生\"><a href=\"#4-8-徐医生\" class=\"headerlink\" title=\"4.8 徐医生\"></a>4.8 徐医生</h2><blockquote>\n<p><a href=\"https://blog.csdn.net/eclipsexys\">https://blog.csdn.net/eclipsexys</a></p>\n</blockquote>\n<h2 id=\"4-9-技术小黑屋\"><a href=\"#4-9-技术小黑屋\" class=\"headerlink\" title=\"4.9 技术小黑屋\"></a>4.9 技术小黑屋</h2><blockquote>\n<p><a href=\"https://droidyue.com/\">https://droidyue.com/</a></p>\n</blockquote>\n<h2 id=\"4-10-刘望舒\"><a href=\"#4-10-刘望舒\" class=\"headerlink\" title=\"4.10 刘望舒\"></a>4.10 刘望舒</h2><blockquote>\n<p><a href=\"https://liuwangshu.blog.csdn.net/\">https://liuwangshu.blog.csdn.net/</a></p>\n</blockquote>\n<h2 id=\"4-11-任玉刚\"><a href=\"#4-11-任玉刚\" class=\"headerlink\" title=\"4.11 任玉刚\"></a>4.11 任玉刚</h2><blockquote>\n<p><a href=\"https://blog.csdn.net/singwhatiwanna\">https://blog.csdn.net/singwhatiwanna</a></p>\n</blockquote>\n<h2 id=\"4-12-Gityuan\"><a href=\"#4-12-Gityuan\" class=\"headerlink\" title=\"4.12 Gityuan\"></a>4.12 Gityuan</h2><blockquote>\n<p><a href=\"http://gityuan.com/\">http://gityuan.com/</a></p>\n</blockquote>\n<h2 id=\"4-13-扔物线\"><a href=\"#4-13-扔物线\" class=\"headerlink\" title=\"4.13 扔物线\"></a>4.13 扔物线</h2><blockquote>\n<p><a href=\"https://rengwuxian.com/\">https://rengwuxian.com/</a></p>\n</blockquote>\n<h2 id=\"4-14-yrom\"><a href=\"#4-14-yrom\" class=\"headerlink\" title=\"4.14 yrom\"></a>4.14 yrom</h2><blockquote>\n<p><a href=\"https://yrom.net/archives/\">https://yrom.net/archives/</a></p>\n</blockquote>\n<h2 id=\"4-15-美团\"><a href=\"#4-15-美团\" class=\"headerlink\" title=\"4.15 美团\"></a>4.15 美团</h2><blockquote>\n<p><a href=\"https://tech.meituan.com/\">https://tech.meituan.com/</a></p>\n</blockquote>\n<h2 id=\"4-16-切切歆语\"><a href=\"#4-16-切切歆语\" class=\"headerlink\" title=\"4.16 切切歆语\"></a>4.16 切切歆语</h2><blockquote>\n<p><a href=\"https://blog.csdn.net/dickyqie/category_6238189.html\">https://blog.csdn.net/dickyqie/category_6238189.html</a></p>\n</blockquote>\n<h1 id=\"5-优秀三方库\"><a href=\"#5-优秀三方库\" class=\"headerlink\" title=\"5.优秀三方库\"></a>5.优秀三方库</h1><h2 id=\"5-1-网络相关\"><a href=\"#5-1-网络相关\" class=\"headerlink\" title=\"5.1 网络相关\"></a>5.1 网络相关</h2><h3 id=\"5-1-1-Retrofit\"><a href=\"#5-1-1-Retrofit\" class=\"headerlink\" title=\"5.1.1 Retrofit\"></a>5.1.1 Retrofit</h3><blockquote>\n<p><a href=\"https://github.com/square/retrofit\">https://github.com/square/retrofit</a></p>\n</blockquote>\n<h3 id=\"5-1-2-OKHttp\"><a href=\"#5-1-2-OKHttp\" class=\"headerlink\" title=\"5.1.2 OKHttp\"></a>5.1.2 OKHttp</h3><blockquote>\n<p><a href=\"https://github.com/square/okhttp\">https://github.com/square/okhttp</a></p>\n</blockquote>\n<h2 id=\"5-2-图片相关\"><a href=\"#5-2-图片相关\" class=\"headerlink\" title=\"5.2 图片相关\"></a>5.2 图片相关</h2><h3 id=\"5-2-1-Glide\"><a href=\"#5-2-1-Glide\" class=\"headerlink\" title=\"5.2.1 Glide\"></a>5.2.1 Glide</h3><blockquote>\n<p><a href=\"https://github.com/bumptech/glide\">https://github.com/bumptech/glide</a></p>\n</blockquote>\n<h2 id=\"5-3-响应式相关\"><a href=\"#5-3-响应式相关\" class=\"headerlink\" title=\"5.3 响应式相关\"></a>5.3 响应式相关</h2><h3 id=\"5-3-1-RxJava\"><a href=\"#5-3-1-RxJava\" class=\"headerlink\" title=\"5.3.1 RxJava\"></a>5.3.1 RxJava</h3><blockquote>\n<p><a href=\"https://github.com/ReactiveX/RxJava\">https://github.com/ReactiveX/RxJava</a></p>\n</blockquote>\n<h2 id=\"5-4-事件相关\"><a href=\"#5-4-事件相关\" class=\"headerlink\" title=\"5.4 事件相关\"></a>5.4 事件相关</h2><h3 id=\"5-4-1-EventBus\"><a href=\"#5-4-1-EventBus\" class=\"headerlink\" title=\"5.4.1 EventBus\"></a>5.4.1 EventBus</h3><blockquote>\n<p><a href=\"https://github.com/greenrobot/EventBus\">https://github.com/greenrobot/EventBus</a></p>\n</blockquote>\n<h2 id=\"5-5-数据库相关\"><a href=\"#5-5-数据库相关\" class=\"headerlink\" title=\"5.5 数据库相关\"></a>5.5 数据库相关</h2><h3 id=\"5-5-1-greenDAO\"><a href=\"#5-5-1-greenDAO\" class=\"headerlink\" title=\"5.5.1 greenDAO\"></a>5.5.1 greenDAO</h3><blockquote>\n<p><a href=\"https://github.com/greenrobot/greenDAO\">https://github.com/greenrobot/greenDAO</a></p>\n</blockquote>\n<h1 id=\"6-项目推荐\"><a href=\"#6-项目推荐\" class=\"headerlink\" title=\"6.项目推荐\"></a>6.项目推荐</h1><h2 id=\"6-1-wanAndroid项目推荐\"><a href=\"#6-1-wanAndroid项目推荐\" class=\"headerlink\" title=\"6.1 wanAndroid项目推荐\"></a>6.1 wanAndroid项目推荐</h2><blockquote>\n<p><a href=\"https://www.wanandroid.com/projectindex\">https://www.wanandroid.com/projectindex</a></p>\n</blockquote>\n<h2 id=\"6-2-官方demo-x3D-x3D-nowinandroid\"><a href=\"#6-2-官方demo-x3D-x3D-nowinandroid\" class=\"headerlink\" title=\"6.2 官方demo&#x3D;&#x3D;nowinandroid\"></a>6.2 官方demo&#x3D;&#x3D;nowinandroid</h2><blockquote>\n<p><a href=\"https://github.com/android/nowinandroid\">https://github.com/android/nowinandroidhttps://github.com/android/nowinandroid</a></p>\n</blockquote>\n<h2 id=\"6-3-emo-x3D-x3D-腾讯大神封装的compse基础UI\"><a href=\"#6-3-emo-x3D-x3D-腾讯大神封装的compse基础UI\" class=\"headerlink\" title=\"6.3 emo&#x3D;&#x3D;腾讯大神封装的compse基础UI\"></a>6.3 emo&#x3D;&#x3D;腾讯大神封装的compse基础UI</h2><blockquote>\n<p><a href=\"https://github.com/cgspine/emo\">https://github.com/cgspine/emo</a></p>\n</blockquote>\n<h1 id=\"7-其它\"><a href=\"#7-其它\" class=\"headerlink\" title=\"7.其它\"></a>7.其它</h1><h2 id=\"7-1-面试相关\"><a href=\"#7-1-面试相关\" class=\"headerlink\" title=\"7.1 面试相关\"></a>7.1 面试相关</h2><h2 id=\"7-2-开发工具相关\"><a href=\"#7-2-开发工具相关\" class=\"headerlink\" title=\"7.2 开发工具相关\"></a>7.2 开发工具相关</h2><h2 id=\"7-3-官方资源\"><a href=\"#7-3-官方资源\" class=\"headerlink\" title=\"7.3 官方资源\"></a>7.3 官方资源</h2><h3 id=\"7-3-1-Android官网\"><a href=\"#7-3-1-Android官网\" class=\"headerlink\" title=\"7.3.1 Android官网\"></a>7.3.1 Android官网</h3><blockquote>\n<p><a href=\"https://developer.android.google.cn/\">https://developer.android.google.cn/</a></p>\n</blockquote>\n<h3 id=\"7-3-2-Google-Samples\"><a href=\"#7-3-2-Google-Samples\" class=\"headerlink\" title=\"7.3.2 Google Samples\"></a>7.3.2 Google Samples</h3><blockquote>\n<p><a href=\"https://github.com/googlesamples\">https://github.com/googlesamples</a></p>\n</blockquote>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h1 id=\"1-知识体系\"><a href=\"#1-知识体系\" class=\"headerlink\" title=\"1 知识体系\"></a>1 知识体系</h1><h2 id=\"1-1-Android性能优化\"><a href=\"#1-1-Android性能优化\" class=\"headerlink\" title=\"1.1 Android性能优化\"></a>1.1 Android性能优化</h2><h3 id=\"1-1-1-包体积优化\"><a href=\"#1-1-1-包体积优化\" class=\"headerlink\" title=\"1.1.1 包体积优化\"></a>1.1.1 包体积优化</h3><blockquote>\n<p><a href=\"https://juejin.cn/post/7186580175222472759\">https://juejin.cn/post/7186580175222472759</a></p>\n</blockquote>\n<h1 id=\"2-优秀站点\"><a href=\"#2-优秀站点\" class=\"headerlink\" title=\"2 优秀站点\"></a>2 优秀站点</h1><h2 id=\"2-1-玩Android\"><a href=\"#2-1-玩Android\" class=\"headerlink\" title=\"2.1 玩Android\"></a>2.1 玩Android</h2><h3 id=\"2-1-1-热门博文\"><a href=\"#2-1-1-热门博文\" class=\"headerlink\" title=\"2.1.1 热门博文\"></a>2.1.1 热门博文</h3><blockquote>\n<p><a href=\"https://www.wanandroid.com/index?cid=0\">https://www.wanandroid.com/index?cid=0</a></p>\n</blockquote>\n<h3 id=\"2-1-2-每日更新\"><a href=\"#2-1-2-每日更新\" class=\"headerlink\" title=\"2.1.2 每日更新\"></a>2.1.2 每日更新</h3><blockquote>\n<p><a href=\"https://www.wanandroid.com/user_article\">https://www.wanandroid.com/user_article</a></p>\n</blockquote>\n<h2 id=\"2-2-掘金\"><a href=\"#2-2-掘金\" class=\"headerlink\" title=\"2.2 掘金\"></a>2.2 掘金</h2><h3 id=\"2-2-1-热门博文\"><a href=\"#2-2-1-热门博文\" class=\"headerlink\" title=\"2.2.1 热门博文\"></a>2.2.1 热门博文</h3><blockquote>\n<p><a href=\"https://juejin.cn/android?sort=monthly_hottest\">https://juejin.cn/android?sort=monthly_hottest</a></p>\n</blockquote>\n<h3 id=\"2-2-2-每日更新\"><a href=\"#2-2-2-每日更新\" class=\"headerlink\" title=\"2.2.2 每日更新\"></a>2.2.2 每日更新</h3><blockquote>\n<p><a href=\"https://juejin.cn/android?sort=newest\">https://juejin.cn/android?sort=newest</a></p>\n</blockquote>\n<h2 id=\"2-3-简书\"><a href=\"#2-3-简书\" class=\"headerlink\" title=\"2.3 简书\"></a>2.3 简书</h2><h3 id=\"2-3-1-热门博文\"><a href=\"#2-3-1-热门博文\" class=\"headerlink\" title=\"2.3.1 热门博文\"></a>2.3.1 热门博文</h3><blockquote>\n<p><a href=\"https://www.jianshu.com/techareas/andriod\">https://www.jianshu.com/techareas/andriod</a></p>\n</blockquote>\n<h2 id=\"2-4-CSDN\"><a href=\"#2-4-CSDN\" class=\"headerlink\" title=\"2.4 CSDN\"></a>2.4 CSDN</h2><h3 id=\"2-4-1-热门博文\"><a href=\"#2-4-1-热门博文\" class=\"headerlink\" title=\"2.4.1 热门博文\"></a>2.4.1 热门博文</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/nav/mobile/android\">https://blog.csdn.net/nav/mobile/android</a></p>\n</blockquote>\n<h2 id=\"2-5-开源中国\"><a href=\"#2-5-开源中国\" class=\"headerlink\" title=\"2.5 开源中国\"></a>2.5 开源中国</h2><h3 id=\"2-5-1-Android开发专区\"><a href=\"#2-5-1-Android开发专区\" class=\"headerlink\" title=\"2.5.1 Android开发专区\"></a>2.5.1 Android开发专区</h3><blockquote>\n<p><a href=\"https://www.oschina.net/android\">https://www.oschina.net/android</a></p>\n</blockquote>\n<h2 id=\"2-6-Medium-国外\"><a href=\"#2-6-Medium-国外\" class=\"headerlink\" title=\"2.6 Medium(国外)\"></a>2.6 Medium(国外)</h2><h3 id=\"2-6-1-热门问答\"><a href=\"#2-6-1-热门问答\" class=\"headerlink\" title=\"2.6.1 热门问答\"></a>2.6.1 热门问答</h3><blockquote>\n<p><a href=\"https://medium.com/tag/android\">https://medium.com/tag/android</a></p>\n</blockquote>\n<h2 id=\"2-7-stackoverflow-国外\"><a href=\"#2-7-stackoverflow-国外\" class=\"headerlink\" title=\"2.7 stackoverflow(国外)\"></a>2.7 stackoverflow(国外)</h2><h3 id=\"2-7-1-热门问答\"><a href=\"#2-7-1-热门问答\" class=\"headerlink\" title=\"2.7.1 热门问答\"></a>2.7.1 热门问答</h3><blockquote>\n<p><a href=\"https://stackoverflow.com/questions/tagged/android\">https://stackoverflow.com/questions/tagged/android</a></p>\n</blockquote>\n<h2 id=\"2-8-Android周报（国外）\"><a href=\"#2-8-Android周报（国外）\" class=\"headerlink\" title=\"2.8 Android周报（国外）\"></a>2.8 Android周报（国外）</h2><blockquote>\n<p><a href=\"https://androidweekly.net/\">https://androidweekly.net/</a></p>\n</blockquote>\n<h2 id=\"2-9-codeKK\"><a href=\"#2-9-codeKK\" class=\"headerlink\" title=\"2.9 codeKK\"></a>2.9 codeKK</h2><h3 id=\"2-9-1-Github每日开源\"><a href=\"#2-9-1-Github每日开源\" class=\"headerlink\" title=\"2.9.1 Github每日开源\"></a>2.9.1 Github每日开源</h3><blockquote>\n<p><a href=\"https://p.codekk.com/\">https://p.codekk.com/</a></p>\n</blockquote>\n<h2 id=\"2-10-github相关\"><a href=\"#2-10-github相关\" class=\"headerlink\" title=\"2.10 github相关\"></a>2.10 github相关</h2><h3 id=\"2-10-1-关于kotlin每日趋势增长\"><a href=\"#2-10-1-关于kotlin每日趋势增长\" class=\"headerlink\" title=\"2.10.1 关于kotlin每日趋势增长\"></a>2.10.1 关于kotlin每日趋势增长</h3><blockquote>\n<p><a href=\"https://github.com/trending/kotlin?since=weekly\">https://github.com/trending/kotlin?since=daily</a></p>\n</blockquote>\n<h2 id=\"2-10-2-关于Android的话题\"><a href=\"#2-10-2-关于Android的话题\" class=\"headerlink\" title=\"2.10.2 关于Android的话题\"></a>2.10.2 关于Android的话题</h2><blockquote>\n<p><a href=\"https://github.com/topics/android\">https://github.com/topics/android</a></p>\n</blockquote>\n<h1 id=\"3-公众号\"><a href=\"#3-公众号\" class=\"headerlink\" title=\"3.公众号\"></a>3.公众号</h1><h2 id=\"3-1-鸿洋\"><a href=\"#3-1-鸿洋\" class=\"headerlink\" title=\"3.1 鸿洋\"></a>3.1 鸿洋</h2><img src=hongyang.jpeg>\n        \n<h2 id=\"3-2-郭霖\"><a href=\"#3-2-郭霖\" class=\"headerlink\" title=\"3.2 郭霖\"></a>3.2 郭霖</h2><img src=guolin.jpeg>\n        \n<h2 id=\"3-3-Carson\"><a href=\"#3-3-Carson\" class=\"headerlink\" title=\"3.3 Carson\"></a>3.3 Carson</h2><img src=carson.jpeg>\n        \n<h2 id=\"3-4-JsonChao\"><a href=\"#3-4-JsonChao\" class=\"headerlink\" title=\"3.4 JsonChao\"></a>3.4 JsonChao</h2><img src=jsonchao.jpeg>\n        \n<h2 id=\"3-5-Android群英传\"><a href=\"#3-5-Android群英传\" class=\"headerlink\" title=\"3.5 Android群英传\"></a>3.5 Android群英传</h2><img src=qunyingzhuan.jpeg>\n        \n<h2 id=\"3-6-Android编程精选\"><a href=\"#3-6-Android编程精选\" class=\"headerlink\" title=\"3.6 Android编程精选\"></a>3.6 Android编程精选</h2><img src=bianchengjingxuan.jpeg>\n        \n<h2 id=\"3-7-Android技术专家\"><a href=\"#3-7-Android技术专家\" class=\"headerlink\" title=\"3.7 Android技术专家\"></a>3.7 Android技术专家</h2><img src=jishuzhuanjia.jpeg>\n        \n<h2 id=\"3-8-Android技术圈\"><a href=\"#3-8-Android技术圈\" class=\"headerlink\" title=\"3.8 Android技术圈\"></a>3.8 Android技术圈</h2><img src=jishuquan.jpeg>\n        \n\n<h1 id=\"4-大神博客\"><a href=\"#4-大神博客\" class=\"headerlink\" title=\"4.大神博客\"></a>4.大神博客</h1><h2 id=\"4-1-jsonChao（平安）\"><a href=\"#4-1-jsonChao（平安）\" class=\"headerlink\" title=\"4.1 jsonChao（平安）\"></a>4.1 jsonChao（平安）</h2><blockquote>\n<p><a href=\"https://juejin.cn/user/4318537403878167/posts\">https://juejin.cn/user/4318537403878167/posts</a></p>\n</blockquote>\n<h2 id=\"4-2-鸿洋（百度）\"><a href=\"#4-2-鸿洋（百度）\" class=\"headerlink\" title=\"4.2 鸿洋（百度）\"></a>4.2 鸿洋（百度）</h2><blockquote>\n<p><a href=\"https://blog.csdn.net/lmj623565791/\">https://blog.csdn.net/lmj623565791/</a></p>\n</blockquote>\n<h2 id=\"4-3-郭霖\"><a href=\"#4-3-郭霖\" class=\"headerlink\" title=\"4.3 郭霖\"></a>4.3 郭霖</h2><blockquote>\n<p><a href=\"https://blog.csdn.net/guolin_blog/\">https://blog.csdn.net/guolin_blog&#x2F;</a></p>\n</blockquote>\n<h2 id=\"4-4-Carson（微信）\"><a href=\"#4-4-Carson（微信）\" class=\"headerlink\" title=\"4.4 Carson（微信）\"></a>4.4 Carson（微信）</h2><blockquote>\n<p><a href=\"https://www.jianshu.com/u/383970bef0a0\">https://www.jianshu.com/u/383970bef0a0</a></p>\n</blockquote>\n<h2 id=\"4-5-何强（魅族）\"><a href=\"#4-5-何强（魅族）\" class=\"headerlink\" title=\"4.5 何强（魅族）\"></a>4.5 何强（魅族）</h2><blockquote>\n<p><a href=\"https://www.heqiangfly.com/archives/\">https://www.heqiangfly.com/archives/</a></p>\n</blockquote>\n<h2 id=\"4-6-爱雨浮龙（阿里）\"><a href=\"#4-6-爱雨浮龙（阿里）\" class=\"headerlink\" title=\"4.6 爱雨浮龙（阿里）\"></a>4.6 爱雨浮龙（阿里）</h2><blockquote>\n<p><a href=\"https://juejin.cn/user/2805609405877415/posts\">https://juejin.cn/user/2805609405877415/posts</a></p>\n</blockquote>\n<h2 id=\"4-7-Android学习资源大全（19年后未更新了）\"><a href=\"#4-7-Android学习资源大全（19年后未更新了）\" class=\"headerlink\" title=\"4.7 Android学习资源大全（19年后未更新了）\"></a>4.7 Android学习资源大全（19年后未更新了）</h2><blockquote>\n<p><a href=\"https://juejin.cn/user/2805609405877415/posts\">https://juejin.cn/user/2805609405877415/posts</a></p>\n</blockquote>\n<h2 id=\"4-8-徐医生\"><a href=\"#4-8-徐医生\" class=\"headerlink\" title=\"4.8 徐医生\"></a>4.8 徐医生</h2><blockquote>\n<p><a href=\"https://blog.csdn.net/eclipsexys\">https://blog.csdn.net/eclipsexys</a></p>\n</blockquote>\n<h2 id=\"4-9-技术小黑屋\"><a href=\"#4-9-技术小黑屋\" class=\"headerlink\" title=\"4.9 技术小黑屋\"></a>4.9 技术小黑屋</h2><blockquote>\n<p><a href=\"https://droidyue.com/\">https://droidyue.com/</a></p>\n</blockquote>\n<h2 id=\"4-10-刘望舒\"><a href=\"#4-10-刘望舒\" class=\"headerlink\" title=\"4.10 刘望舒\"></a>4.10 刘望舒</h2><blockquote>\n<p><a href=\"https://liuwangshu.blog.csdn.net/\">https://liuwangshu.blog.csdn.net/</a></p>\n</blockquote>\n<h2 id=\"4-11-任玉刚\"><a href=\"#4-11-任玉刚\" class=\"headerlink\" title=\"4.11 任玉刚\"></a>4.11 任玉刚</h2><blockquote>\n<p><a href=\"https://blog.csdn.net/singwhatiwanna\">https://blog.csdn.net/singwhatiwanna</a></p>\n</blockquote>\n<h2 id=\"4-12-Gityuan\"><a href=\"#4-12-Gityuan\" class=\"headerlink\" title=\"4.12 Gityuan\"></a>4.12 Gityuan</h2><blockquote>\n<p><a href=\"http://gityuan.com/\">http://gityuan.com/</a></p>\n</blockquote>\n<h2 id=\"4-13-扔物线\"><a href=\"#4-13-扔物线\" class=\"headerlink\" title=\"4.13 扔物线\"></a>4.13 扔物线</h2><blockquote>\n<p><a href=\"https://rengwuxian.com/\">https://rengwuxian.com/</a></p>\n</blockquote>\n<h2 id=\"4-14-yrom\"><a href=\"#4-14-yrom\" class=\"headerlink\" title=\"4.14 yrom\"></a>4.14 yrom</h2><blockquote>\n<p><a href=\"https://yrom.net/archives/\">https://yrom.net/archives/</a></p>\n</blockquote>\n<h2 id=\"4-15-美团\"><a href=\"#4-15-美团\" class=\"headerlink\" title=\"4.15 美团\"></a>4.15 美团</h2><blockquote>\n<p><a href=\"https://tech.meituan.com/\">https://tech.meituan.com/</a></p>\n</blockquote>\n<h2 id=\"4-16-切切歆语\"><a href=\"#4-16-切切歆语\" class=\"headerlink\" title=\"4.16 切切歆语\"></a>4.16 切切歆语</h2><blockquote>\n<p><a href=\"https://blog.csdn.net/dickyqie/category_6238189.html\">https://blog.csdn.net/dickyqie/category_6238189.html</a></p>\n</blockquote>\n<h1 id=\"5-优秀三方库\"><a href=\"#5-优秀三方库\" class=\"headerlink\" title=\"5.优秀三方库\"></a>5.优秀三方库</h1><h2 id=\"5-1-网络相关\"><a href=\"#5-1-网络相关\" class=\"headerlink\" title=\"5.1 网络相关\"></a>5.1 网络相关</h2><h3 id=\"5-1-1-Retrofit\"><a href=\"#5-1-1-Retrofit\" class=\"headerlink\" title=\"5.1.1 Retrofit\"></a>5.1.1 Retrofit</h3><blockquote>\n<p><a href=\"https://github.com/square/retrofit\">https://github.com/square/retrofit</a></p>\n</blockquote>\n<h3 id=\"5-1-2-OKHttp\"><a href=\"#5-1-2-OKHttp\" class=\"headerlink\" title=\"5.1.2 OKHttp\"></a>5.1.2 OKHttp</h3><blockquote>\n<p><a href=\"https://github.com/square/okhttp\">https://github.com/square/okhttp</a></p>\n</blockquote>\n<h2 id=\"5-2-图片相关\"><a href=\"#5-2-图片相关\" class=\"headerlink\" title=\"5.2 图片相关\"></a>5.2 图片相关</h2><h3 id=\"5-2-1-Glide\"><a href=\"#5-2-1-Glide\" class=\"headerlink\" title=\"5.2.1 Glide\"></a>5.2.1 Glide</h3><blockquote>\n<p><a href=\"https://github.com/bumptech/glide\">https://github.com/bumptech/glide</a></p>\n</blockquote>\n<h2 id=\"5-3-响应式相关\"><a href=\"#5-3-响应式相关\" class=\"headerlink\" title=\"5.3 响应式相关\"></a>5.3 响应式相关</h2><h3 id=\"5-3-1-RxJava\"><a href=\"#5-3-1-RxJava\" class=\"headerlink\" title=\"5.3.1 RxJava\"></a>5.3.1 RxJava</h3><blockquote>\n<p><a href=\"https://github.com/ReactiveX/RxJava\">https://github.com/ReactiveX/RxJava</a></p>\n</blockquote>\n<h2 id=\"5-4-事件相关\"><a href=\"#5-4-事件相关\" class=\"headerlink\" title=\"5.4 事件相关\"></a>5.4 事件相关</h2><h3 id=\"5-4-1-EventBus\"><a href=\"#5-4-1-EventBus\" class=\"headerlink\" title=\"5.4.1 EventBus\"></a>5.4.1 EventBus</h3><blockquote>\n<p><a href=\"https://github.com/greenrobot/EventBus\">https://github.com/greenrobot/EventBus</a></p>\n</blockquote>\n<h2 id=\"5-5-数据库相关\"><a href=\"#5-5-数据库相关\" class=\"headerlink\" title=\"5.5 数据库相关\"></a>5.5 数据库相关</h2><h3 id=\"5-5-1-greenDAO\"><a href=\"#5-5-1-greenDAO\" class=\"headerlink\" title=\"5.5.1 greenDAO\"></a>5.5.1 greenDAO</h3><blockquote>\n<p><a href=\"https://github.com/greenrobot/greenDAO\">https://github.com/greenrobot/greenDAO</a></p>\n</blockquote>\n<h1 id=\"6-项目推荐\"><a href=\"#6-项目推荐\" class=\"headerlink\" title=\"6.项目推荐\"></a>6.项目推荐</h1><h2 id=\"6-1-wanAndroid项目推荐\"><a href=\"#6-1-wanAndroid项目推荐\" class=\"headerlink\" title=\"6.1 wanAndroid项目推荐\"></a>6.1 wanAndroid项目推荐</h2><blockquote>\n<p><a href=\"https://www.wanandroid.com/projectindex\">https://www.wanandroid.com/projectindex</a></p>\n</blockquote>\n<h2 id=\"6-2-官方demo-x3D-x3D-nowinandroid\"><a href=\"#6-2-官方demo-x3D-x3D-nowinandroid\" class=\"headerlink\" title=\"6.2 官方demo&#x3D;&#x3D;nowinandroid\"></a>6.2 官方demo&#x3D;&#x3D;nowinandroid</h2><blockquote>\n<p><a href=\"https://github.com/android/nowinandroid\">https://github.com/android/nowinandroidhttps://github.com/android/nowinandroid</a></p>\n</blockquote>\n<h2 id=\"6-3-emo-x3D-x3D-腾讯大神封装的compse基础UI\"><a href=\"#6-3-emo-x3D-x3D-腾讯大神封装的compse基础UI\" class=\"headerlink\" title=\"6.3 emo&#x3D;&#x3D;腾讯大神封装的compse基础UI\"></a>6.3 emo&#x3D;&#x3D;腾讯大神封装的compse基础UI</h2><blockquote>\n<p><a href=\"https://github.com/cgspine/emo\">https://github.com/cgspine/emo</a></p>\n</blockquote>\n<h1 id=\"7-其它\"><a href=\"#7-其它\" class=\"headerlink\" title=\"7.其它\"></a>7.其它</h1><h2 id=\"7-1-面试相关\"><a href=\"#7-1-面试相关\" class=\"headerlink\" title=\"7.1 面试相关\"></a>7.1 面试相关</h2><h2 id=\"7-2-开发工具相关\"><a href=\"#7-2-开发工具相关\" class=\"headerlink\" title=\"7.2 开发工具相关\"></a>7.2 开发工具相关</h2><h2 id=\"7-3-官方资源\"><a href=\"#7-3-官方资源\" class=\"headerlink\" title=\"7.3 官方资源\"></a>7.3 官方资源</h2><h3 id=\"7-3-1-Android官网\"><a href=\"#7-3-1-Android官网\" class=\"headerlink\" title=\"7.3.1 Android官网\"></a>7.3.1 Android官网</h3><blockquote>\n<p><a href=\"https://developer.android.google.cn/\">https://developer.android.google.cn/</a></p>\n</blockquote>\n<h3 id=\"7-3-2-Google-Samples\"><a href=\"#7-3-2-Google-Samples\" class=\"headerlink\" title=\"7.3.2 Google Samples\"></a>7.3.2 Google Samples</h3><blockquote>\n<p><a href=\"https://github.com/googlesamples\">https://github.com/googlesamples</a></p>\n</blockquote>\n"},{"title":"第一篇博客","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-01-11T07:27:31.000Z","password":null,"summary":null,"_content":"\n> 既然选择了，便不顾风雨兼程！\n\n![](/medias/contact.jpg)\n\n## When？什么时候开始写的？\n记得第一次写博客是 2017 年了，在 博客园上面，当时因为在跟同学自主创业，自己从0开始撸一个App，团队规模很小，一个iOS，一个Android，我就负责Android，然后一个后端，一个跑业务，主体上就这个4个人。当时为了方便自己学习，经常写一些博客记录，也是一个老大哥推荐我去写写博客做记录。一直到工作前都经常写，但总觉得博客园编写起来很麻烦，风格也不是自己喜欢的样式，后来逐渐放弃。\n其实毕业设计前帮一个同学搞了一个个人博客，本来我想做毕业设计的，结果用自主创业做的App也可以当毕业设计，两全其美，可惜自主创业的想法不错，但没有坚持下去，资金问题，后面大家也找工作去了。\n\n工作后，又有一个老大哥，推荐使用印象笔记，我试了下还挺好用，这一用就是几年，但是自己写的东西没有跟别人分享始终觉得还是不够，知识本来就是互相分享的，知识需要一起讨论才能起火花。\n\n\n## Why？为什么会想起来写博客？\n一直都想写博客，特别是看到别人的文章如此有条理，思维如此清晰，膜拜大佬们。所以现在刚好github有这种部署的能力，完全可以实现个人博客。那就开始吧。\n\n\n\n","source":"_posts/5w2h-godweiyang.md","raw":"---\ntitle: 第一篇博客\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-01-11 15:27:31\npassword:\nsummary:\ntags:\n- 博客\ncategories:\n- 随笔\n---\n\n> 既然选择了，便不顾风雨兼程！\n\n![](/medias/contact.jpg)\n\n## When？什么时候开始写的？\n记得第一次写博客是 2017 年了，在 博客园上面，当时因为在跟同学自主创业，自己从0开始撸一个App，团队规模很小，一个iOS，一个Android，我就负责Android，然后一个后端，一个跑业务，主体上就这个4个人。当时为了方便自己学习，经常写一些博客记录，也是一个老大哥推荐我去写写博客做记录。一直到工作前都经常写，但总觉得博客园编写起来很麻烦，风格也不是自己喜欢的样式，后来逐渐放弃。\n其实毕业设计前帮一个同学搞了一个个人博客，本来我想做毕业设计的，结果用自主创业做的App也可以当毕业设计，两全其美，可惜自主创业的想法不错，但没有坚持下去，资金问题，后面大家也找工作去了。\n\n工作后，又有一个老大哥，推荐使用印象笔记，我试了下还挺好用，这一用就是几年，但是自己写的东西没有跟别人分享始终觉得还是不够，知识本来就是互相分享的，知识需要一起讨论才能起火花。\n\n\n## Why？为什么会想起来写博客？\n一直都想写博客，特别是看到别人的文章如此有条理，思维如此清晰，膜拜大佬们。所以现在刚好github有这种部署的能力，完全可以实现个人博客。那就开始吧。\n\n\n\n","slug":"5w2h-godweiyang","published":1,"updated":"2023-02-01T06:06:16.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlc01jd000fjhv74oxuewn5","content":"<blockquote>\n<p>既然选择了，便不顾风雨兼程！</p>\n</blockquote>\n<p><img src=\"/medias/contact.jpg\"></p>\n<h2 id=\"When？什么时候开始写的？\"><a href=\"#When？什么时候开始写的？\" class=\"headerlink\" title=\"When？什么时候开始写的？\"></a>When？什么时候开始写的？</h2><p>记得第一次写博客是 2017 年了，在 博客园上面，当时因为在跟同学自主创业，自己从0开始撸一个App，团队规模很小，一个iOS，一个Android，我就负责Android，然后一个后端，一个跑业务，主体上就这个4个人。当时为了方便自己学习，经常写一些博客记录，也是一个老大哥推荐我去写写博客做记录。一直到工作前都经常写，但总觉得博客园编写起来很麻烦，风格也不是自己喜欢的样式，后来逐渐放弃。<br>其实毕业设计前帮一个同学搞了一个个人博客，本来我想做毕业设计的，结果用自主创业做的App也可以当毕业设计，两全其美，可惜自主创业的想法不错，但没有坚持下去，资金问题，后面大家也找工作去了。</p>\n<p>工作后，又有一个老大哥，推荐使用印象笔记，我试了下还挺好用，这一用就是几年，但是自己写的东西没有跟别人分享始终觉得还是不够，知识本来就是互相分享的，知识需要一起讨论才能起火花。</p>\n<h2 id=\"Why？为什么会想起来写博客？\"><a href=\"#Why？为什么会想起来写博客？\" class=\"headerlink\" title=\"Why？为什么会想起来写博客？\"></a>Why？为什么会想起来写博客？</h2><p>一直都想写博客，特别是看到别人的文章如此有条理，思维如此清晰，膜拜大佬们。所以现在刚好github有这种部署的能力，完全可以实现个人博客。那就开始吧。</p>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<blockquote>\n<p>既然选择了，便不顾风雨兼程！</p>\n</blockquote>\n<p><img src=\"/medias/contact.jpg\"></p>\n<h2 id=\"When？什么时候开始写的？\"><a href=\"#When？什么时候开始写的？\" class=\"headerlink\" title=\"When？什么时候开始写的？\"></a>When？什么时候开始写的？</h2><p>记得第一次写博客是 2017 年了，在 博客园上面，当时因为在跟同学自主创业，自己从0开始撸一个App，团队规模很小，一个iOS，一个Android，我就负责Android，然后一个后端，一个跑业务，主体上就这个4个人。当时为了方便自己学习，经常写一些博客记录，也是一个老大哥推荐我去写写博客做记录。一直到工作前都经常写，但总觉得博客园编写起来很麻烦，风格也不是自己喜欢的样式，后来逐渐放弃。<br>其实毕业设计前帮一个同学搞了一个个人博客，本来我想做毕业设计的，结果用自主创业做的App也可以当毕业设计，两全其美，可惜自主创业的想法不错，但没有坚持下去，资金问题，后面大家也找工作去了。</p>\n<p>工作后，又有一个老大哥，推荐使用印象笔记，我试了下还挺好用，这一用就是几年，但是自己写的东西没有跟别人分享始终觉得还是不够，知识本来就是互相分享的，知识需要一起讨论才能起火花。</p>\n<h2 id=\"Why？为什么会想起来写博客？\"><a href=\"#Why？为什么会想起来写博客？\" class=\"headerlink\" title=\"Why？为什么会想起来写博客？\"></a>Why？为什么会想起来写博客？</h2><p>一直都想写博客，特别是看到别人的文章如此有条理，思维如此清晰，膜拜大佬们。所以现在刚好github有这种部署的能力，完全可以实现个人博客。那就开始吧。</p>\n"},{"title":"Flutter-学习导航","date":"2023-01-21T23:38:21.000Z","top":true,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 知识体系\n\n## 2 优秀站点\n\n### 2.1 Flutter实战\n> [https://book.flutterchina.club/](https://book.flutterchina.club/)\n\n### 2.2 Flutter开发文档\n> [https://flutter.cn/docs](https://flutter.cn/docs)\n\n### 2.3 老孟Flutter\n> [http://laomengit.com/flutter/widgets/widgets_structure.html](http://laomengit.com/flutter/widgets/widgets_structure.html)\n\n\n## 3 公众号\n\n### 3.1 西江悦\n<img src=blog_520lee_com.jpeg>\n\n### 3.2 Flutter社区\n<img src=FlutterDevs.jpeg>\n\n### 3.3 Flutter开发精选\n<img src=Study_Knowledge.jpeg>\n\n## 4 大神博客\n\n### 4.1 crazyCodeBoy\n> [https://www.devio.org/](https://www.devio.org/)\n\n### 4.2 Welcome to Flutter\n> [https://www.didierboelens.com/](https://www.didierboelens.com/)\n\n## 5 优秀三方库\n\n### 5.1 官方仓库\n> [https://pub.flutter-io.cn/](https://pub.flutter-io.cn/)\n\n## 6 项目推荐\n\n### 6.1 Flutter中国开源\n> [https://github.com/flutterchina](https://github.com/flutterchina)\n\n### 6.2 郭树煜\n> [https://github.com/CarGuo/gsy_github_app_flutter](https://github.com/CarGuo/gsy_github_app_flutter)\n\n### 6.3 AwesomeFlutter\n> [https://github.com/Solido/awesome-flutter](https://github.com/Solido/awesome-flutter)\n\n### 6.4 高仿豆瓣\n> [https://github.com/kaina404/FlutterDouBan](https://github.com/kaina404/FlutterDouBan)\n\n### 6.5 书旗小说\n> [https://github.com/jayden320/flutter_shuqi](https://github.com/jayden320/flutter_shuqi)\n\n\n\n## 7 其它\n\n### 7.1 面试相关\n\n### 7.2 开发工具相关\n","source":"_posts/Flutter-学习导航.md","raw":"---\ntitle: Flutter-学习导航\ndate: 2023-01-22 07:38:21\ntop: true\ncover: false\ntoc: true\nmathjax: true\ntags:\n- Flutter\ncategories:\n- Flutter\n---\n\n## 1 知识体系\n\n## 2 优秀站点\n\n### 2.1 Flutter实战\n> [https://book.flutterchina.club/](https://book.flutterchina.club/)\n\n### 2.2 Flutter开发文档\n> [https://flutter.cn/docs](https://flutter.cn/docs)\n\n### 2.3 老孟Flutter\n> [http://laomengit.com/flutter/widgets/widgets_structure.html](http://laomengit.com/flutter/widgets/widgets_structure.html)\n\n\n## 3 公众号\n\n### 3.1 西江悦\n<img src=blog_520lee_com.jpeg>\n\n### 3.2 Flutter社区\n<img src=FlutterDevs.jpeg>\n\n### 3.3 Flutter开发精选\n<img src=Study_Knowledge.jpeg>\n\n## 4 大神博客\n\n### 4.1 crazyCodeBoy\n> [https://www.devio.org/](https://www.devio.org/)\n\n### 4.2 Welcome to Flutter\n> [https://www.didierboelens.com/](https://www.didierboelens.com/)\n\n## 5 优秀三方库\n\n### 5.1 官方仓库\n> [https://pub.flutter-io.cn/](https://pub.flutter-io.cn/)\n\n## 6 项目推荐\n\n### 6.1 Flutter中国开源\n> [https://github.com/flutterchina](https://github.com/flutterchina)\n\n### 6.2 郭树煜\n> [https://github.com/CarGuo/gsy_github_app_flutter](https://github.com/CarGuo/gsy_github_app_flutter)\n\n### 6.3 AwesomeFlutter\n> [https://github.com/Solido/awesome-flutter](https://github.com/Solido/awesome-flutter)\n\n### 6.4 高仿豆瓣\n> [https://github.com/kaina404/FlutterDouBan](https://github.com/kaina404/FlutterDouBan)\n\n### 6.5 书旗小说\n> [https://github.com/jayden320/flutter_shuqi](https://github.com/jayden320/flutter_shuqi)\n\n\n\n## 7 其它\n\n### 7.1 面试相关\n\n### 7.2 开发工具相关\n","slug":"Flutter-学习导航","published":1,"updated":"2023-02-01T06:13:34.855Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlc01jd000hjhv701s006dg","content":"<h2 id=\"1-知识体系\"><a href=\"#1-知识体系\" class=\"headerlink\" title=\"1 知识体系\"></a>1 知识体系</h2><h2 id=\"2-优秀站点\"><a href=\"#2-优秀站点\" class=\"headerlink\" title=\"2 优秀站点\"></a>2 优秀站点</h2><h3 id=\"2-1-Flutter实战\"><a href=\"#2-1-Flutter实战\" class=\"headerlink\" title=\"2.1 Flutter实战\"></a>2.1 Flutter实战</h3><blockquote>\n<p><a href=\"https://book.flutterchina.club/\">https://book.flutterchina.club/</a></p>\n</blockquote>\n<h3 id=\"2-2-Flutter开发文档\"><a href=\"#2-2-Flutter开发文档\" class=\"headerlink\" title=\"2.2 Flutter开发文档\"></a>2.2 Flutter开发文档</h3><blockquote>\n<p><a href=\"https://flutter.cn/docs\">https://flutter.cn/docs</a></p>\n</blockquote>\n<h3 id=\"2-3-老孟Flutter\"><a href=\"#2-3-老孟Flutter\" class=\"headerlink\" title=\"2.3 老孟Flutter\"></a>2.3 老孟Flutter</h3><blockquote>\n<p><a href=\"http://laomengit.com/flutter/widgets/widgets_structure.html\">http://laomengit.com/flutter/widgets/widgets_structure.html</a></p>\n</blockquote>\n<h2 id=\"3-公众号\"><a href=\"#3-公众号\" class=\"headerlink\" title=\"3 公众号\"></a>3 公众号</h2><h3 id=\"3-1-西江悦\"><a href=\"#3-1-西江悦\" class=\"headerlink\" title=\"3.1 西江悦\"></a>3.1 西江悦</h3><img src=blog_520lee_com.jpeg>\n\n<h3 id=\"3-2-Flutter社区\"><a href=\"#3-2-Flutter社区\" class=\"headerlink\" title=\"3.2 Flutter社区\"></a>3.2 Flutter社区</h3><img src=FlutterDevs.jpeg>\n\n<h3 id=\"3-3-Flutter开发精选\"><a href=\"#3-3-Flutter开发精选\" class=\"headerlink\" title=\"3.3 Flutter开发精选\"></a>3.3 Flutter开发精选</h3><img src=Study_Knowledge.jpeg>\n\n<h2 id=\"4-大神博客\"><a href=\"#4-大神博客\" class=\"headerlink\" title=\"4 大神博客\"></a>4 大神博客</h2><h3 id=\"4-1-crazyCodeBoy\"><a href=\"#4-1-crazyCodeBoy\" class=\"headerlink\" title=\"4.1 crazyCodeBoy\"></a>4.1 crazyCodeBoy</h3><blockquote>\n<p><a href=\"https://www.devio.org/\">https://www.devio.org/</a></p>\n</blockquote>\n<h3 id=\"4-2-Welcome-to-Flutter\"><a href=\"#4-2-Welcome-to-Flutter\" class=\"headerlink\" title=\"4.2 Welcome to Flutter\"></a>4.2 Welcome to Flutter</h3><blockquote>\n<p><a href=\"https://www.didierboelens.com/\">https://www.didierboelens.com/</a></p>\n</blockquote>\n<h2 id=\"5-优秀三方库\"><a href=\"#5-优秀三方库\" class=\"headerlink\" title=\"5 优秀三方库\"></a>5 优秀三方库</h2><h3 id=\"5-1-官方仓库\"><a href=\"#5-1-官方仓库\" class=\"headerlink\" title=\"5.1 官方仓库\"></a>5.1 官方仓库</h3><blockquote>\n<p><a href=\"https://pub.flutter-io.cn/\">https://pub.flutter-io.cn/</a></p>\n</blockquote>\n<h2 id=\"6-项目推荐\"><a href=\"#6-项目推荐\" class=\"headerlink\" title=\"6 项目推荐\"></a>6 项目推荐</h2><h3 id=\"6-1-Flutter中国开源\"><a href=\"#6-1-Flutter中国开源\" class=\"headerlink\" title=\"6.1 Flutter中国开源\"></a>6.1 Flutter中国开源</h3><blockquote>\n<p><a href=\"https://github.com/flutterchina\">https://github.com/flutterchina</a></p>\n</blockquote>\n<h3 id=\"6-2-郭树煜\"><a href=\"#6-2-郭树煜\" class=\"headerlink\" title=\"6.2 郭树煜\"></a>6.2 郭树煜</h3><blockquote>\n<p><a href=\"https://github.com/CarGuo/gsy_github_app_flutter\">https://github.com/CarGuo/gsy_github_app_flutter</a></p>\n</blockquote>\n<h3 id=\"6-3-AwesomeFlutter\"><a href=\"#6-3-AwesomeFlutter\" class=\"headerlink\" title=\"6.3 AwesomeFlutter\"></a>6.3 AwesomeFlutter</h3><blockquote>\n<p><a href=\"https://github.com/Solido/awesome-flutter\">https://github.com/Solido/awesome-flutter</a></p>\n</blockquote>\n<h3 id=\"6-4-高仿豆瓣\"><a href=\"#6-4-高仿豆瓣\" class=\"headerlink\" title=\"6.4 高仿豆瓣\"></a>6.4 高仿豆瓣</h3><blockquote>\n<p><a href=\"https://github.com/kaina404/FlutterDouBan\">https://github.com/kaina404/FlutterDouBan</a></p>\n</blockquote>\n<h3 id=\"6-5-书旗小说\"><a href=\"#6-5-书旗小说\" class=\"headerlink\" title=\"6.5 书旗小说\"></a>6.5 书旗小说</h3><blockquote>\n<p><a href=\"https://github.com/jayden320/flutter_shuqi\">https://github.com/jayden320/flutter_shuqi</a></p>\n</blockquote>\n<h2 id=\"7-其它\"><a href=\"#7-其它\" class=\"headerlink\" title=\"7 其它\"></a>7 其它</h2><h3 id=\"7-1-面试相关\"><a href=\"#7-1-面试相关\" class=\"headerlink\" title=\"7.1 面试相关\"></a>7.1 面试相关</h3><h3 id=\"7-2-开发工具相关\"><a href=\"#7-2-开发工具相关\" class=\"headerlink\" title=\"7.2 开发工具相关\"></a>7.2 开发工具相关</h3>","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-知识体系\"><a href=\"#1-知识体系\" class=\"headerlink\" title=\"1 知识体系\"></a>1 知识体系</h2><h2 id=\"2-优秀站点\"><a href=\"#2-优秀站点\" class=\"headerlink\" title=\"2 优秀站点\"></a>2 优秀站点</h2><h3 id=\"2-1-Flutter实战\"><a href=\"#2-1-Flutter实战\" class=\"headerlink\" title=\"2.1 Flutter实战\"></a>2.1 Flutter实战</h3><blockquote>\n<p><a href=\"https://book.flutterchina.club/\">https://book.flutterchina.club/</a></p>\n</blockquote>\n<h3 id=\"2-2-Flutter开发文档\"><a href=\"#2-2-Flutter开发文档\" class=\"headerlink\" title=\"2.2 Flutter开发文档\"></a>2.2 Flutter开发文档</h3><blockquote>\n<p><a href=\"https://flutter.cn/docs\">https://flutter.cn/docs</a></p>\n</blockquote>\n<h3 id=\"2-3-老孟Flutter\"><a href=\"#2-3-老孟Flutter\" class=\"headerlink\" title=\"2.3 老孟Flutter\"></a>2.3 老孟Flutter</h3><blockquote>\n<p><a href=\"http://laomengit.com/flutter/widgets/widgets_structure.html\">http://laomengit.com/flutter/widgets/widgets_structure.html</a></p>\n</blockquote>\n<h2 id=\"3-公众号\"><a href=\"#3-公众号\" class=\"headerlink\" title=\"3 公众号\"></a>3 公众号</h2><h3 id=\"3-1-西江悦\"><a href=\"#3-1-西江悦\" class=\"headerlink\" title=\"3.1 西江悦\"></a>3.1 西江悦</h3><img src=blog_520lee_com.jpeg>\n\n<h3 id=\"3-2-Flutter社区\"><a href=\"#3-2-Flutter社区\" class=\"headerlink\" title=\"3.2 Flutter社区\"></a>3.2 Flutter社区</h3><img src=FlutterDevs.jpeg>\n\n<h3 id=\"3-3-Flutter开发精选\"><a href=\"#3-3-Flutter开发精选\" class=\"headerlink\" title=\"3.3 Flutter开发精选\"></a>3.3 Flutter开发精选</h3><img src=Study_Knowledge.jpeg>\n\n<h2 id=\"4-大神博客\"><a href=\"#4-大神博客\" class=\"headerlink\" title=\"4 大神博客\"></a>4 大神博客</h2><h3 id=\"4-1-crazyCodeBoy\"><a href=\"#4-1-crazyCodeBoy\" class=\"headerlink\" title=\"4.1 crazyCodeBoy\"></a>4.1 crazyCodeBoy</h3><blockquote>\n<p><a href=\"https://www.devio.org/\">https://www.devio.org/</a></p>\n</blockquote>\n<h3 id=\"4-2-Welcome-to-Flutter\"><a href=\"#4-2-Welcome-to-Flutter\" class=\"headerlink\" title=\"4.2 Welcome to Flutter\"></a>4.2 Welcome to Flutter</h3><blockquote>\n<p><a href=\"https://www.didierboelens.com/\">https://www.didierboelens.com/</a></p>\n</blockquote>\n<h2 id=\"5-优秀三方库\"><a href=\"#5-优秀三方库\" class=\"headerlink\" title=\"5 优秀三方库\"></a>5 优秀三方库</h2><h3 id=\"5-1-官方仓库\"><a href=\"#5-1-官方仓库\" class=\"headerlink\" title=\"5.1 官方仓库\"></a>5.1 官方仓库</h3><blockquote>\n<p><a href=\"https://pub.flutter-io.cn/\">https://pub.flutter-io.cn/</a></p>\n</blockquote>\n<h2 id=\"6-项目推荐\"><a href=\"#6-项目推荐\" class=\"headerlink\" title=\"6 项目推荐\"></a>6 项目推荐</h2><h3 id=\"6-1-Flutter中国开源\"><a href=\"#6-1-Flutter中国开源\" class=\"headerlink\" title=\"6.1 Flutter中国开源\"></a>6.1 Flutter中国开源</h3><blockquote>\n<p><a href=\"https://github.com/flutterchina\">https://github.com/flutterchina</a></p>\n</blockquote>\n<h3 id=\"6-2-郭树煜\"><a href=\"#6-2-郭树煜\" class=\"headerlink\" title=\"6.2 郭树煜\"></a>6.2 郭树煜</h3><blockquote>\n<p><a href=\"https://github.com/CarGuo/gsy_github_app_flutter\">https://github.com/CarGuo/gsy_github_app_flutter</a></p>\n</blockquote>\n<h3 id=\"6-3-AwesomeFlutter\"><a href=\"#6-3-AwesomeFlutter\" class=\"headerlink\" title=\"6.3 AwesomeFlutter\"></a>6.3 AwesomeFlutter</h3><blockquote>\n<p><a href=\"https://github.com/Solido/awesome-flutter\">https://github.com/Solido/awesome-flutter</a></p>\n</blockquote>\n<h3 id=\"6-4-高仿豆瓣\"><a href=\"#6-4-高仿豆瓣\" class=\"headerlink\" title=\"6.4 高仿豆瓣\"></a>6.4 高仿豆瓣</h3><blockquote>\n<p><a href=\"https://github.com/kaina404/FlutterDouBan\">https://github.com/kaina404/FlutterDouBan</a></p>\n</blockquote>\n<h3 id=\"6-5-书旗小说\"><a href=\"#6-5-书旗小说\" class=\"headerlink\" title=\"6.5 书旗小说\"></a>6.5 书旗小说</h3><blockquote>\n<p><a href=\"https://github.com/jayden320/flutter_shuqi\">https://github.com/jayden320/flutter_shuqi</a></p>\n</blockquote>\n<h2 id=\"7-其它\"><a href=\"#7-其它\" class=\"headerlink\" title=\"7 其它\"></a>7 其它</h2><h3 id=\"7-1-面试相关\"><a href=\"#7-1-面试相关\" class=\"headerlink\" title=\"7.1 面试相关\"></a>7.1 面试相关</h3><h3 id=\"7-2-开发工具相关\"><a href=\"#7-2-开发工具相关\" class=\"headerlink\" title=\"7.2 开发工具相关\"></a>7.2 开发工具相关</h3>"},{"title":"iOS swift 如何实现扫码功能","date":"2023-01-29T00:13:37.000Z","top":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 需求定义\n\n这里有个需求，就是继承扫码能力，可以识别到条形码里面的内容。\n首先我们需要下载一个离线库，这个库里面会包含很多条码Code，相机通过识别到条码跟离线库中的匹配，如果匹配上了，会提示用户。所以首先我们肯定要有一个识别能力，数据库先不管，后面会有专门的文章来写数据库相关的东西。\n\n本篇文章主要是从0搭建一个可以识别条形码能力的Controller。\n其它额外需求先忽略。\n\n目标就是完成这样的效果：\n<img src=scan1.png>\n<img src=scan2.png>\n\n## 2 分析需求\n\n要具备扫码功能，肯定离不开相机，调用相机会设计到权限。\n所以我们得考虑是否有相机权限。\n其次，得考虑如何来识别条形码。\n重复识别到的问题。\n页面退出，相机资源怎么处理。\n光线太暗了，是否需要打开手电筒。\n条码太小，是否需要放大。\n等等，这些事先都得考虑到。\n\n\n## 3 打造页面\n\n### 3.1 构建UI\n\n首先把材料上齐。\n```Swift\nlazy var squareImgView: UIImageView = {\n        let imgv = UIImageView()\n        imgv.isUserInteractionEnabled = false\n        imgv.image = UIImage(named: \"扫码框\")\n        return imgv\n    }()\n    \n    lazy var torchButton: UIButton = {\n        let temp = UIButton(type: .custom)\n        temp.setImage(UIImage(named: \"scan_torch\"), for: .normal)\n        temp.setTitle(\"轻触照亮\", for: .normal)\n        temp.isHidden = true\n        temp.titleLabel?.font = UIFont.regular(15)\n        temp.ddy_SetStyle(.imgDown, padding: 10)\n        temp.addTarget(self, action: #selector(torchButtonClick), for: .touchUpInside)\n        return temp\n    }()\n    \n    lazy var photoBtn: UIButton = {\n        let btn = UIButton(type: .custom)\n        btn.setImage(UIImage(named: \"PhotoAlbum\"), for: .normal)\n        btn.addTarget(self, action: #selector(actionForPhoto), for: .touchUpInside)\n        return btn\n    }()\n    \n    lazy var tipsLabel: UILabel = {\n        let temp = UILabel()\n        temp.text = \"扫一扫条形码\"\n        temp.textColor = .white\n        temp.font = UIFont.regular(13)\n        temp.sizeToFit()\n        return temp\n    }()\n    \n    lazy var commitButton: UIButton = {\n        let btn: UIButton = UIButton(type: .custom)\n        btn.backgroundColor = UIColor(hex: \"#242424\")\n        btn.clipsToBounds = true\n        btn.layer.cornerRadius = 22\n        btn.layer.borderWidth = 1\n        btn.layer.borderColor = UIColor.white.cgColor\n        btn.setTitle(\"扫描完成\", for: .normal)\n        btn.addTarget(self, action: #selector(commitButtonClick), for: .touchUpInside)\n        return btn\n    }()\n    \n    lazy var inputButton: UIButton = {\n        let btn: UIButton = UIButton(type: .custom)\n        btn.backgroundColor = UIColor(hex: \"#242424\")\n        btn.layer.borderColor = UIColor.white.cgColor\n        btn.setTitle(\"手动输入条形码\", for: .normal)\n        btn.addTarget(self, action: #selector(actionForPushManuallyInput), for: .touchUpInside)\n        return btn\n    }()\n\n    lazy var layerView: UIView = {\n        let view = UIView(frame: CGRect(x: 0,\n                                        y: STATUS_BAR_HEIGHT + 44,\n                                        width: ScreenWidth,\n                                        height: ScreenHeight - STATUS_BAR_HEIGHT - 44 - 162))\n        return view\n    }()\n```\n打开需要这几个View。\n\n### 3.2 全局变量声明\n\n想要具备扫码能力，有几个类是必须的。\n```Swift\n// AVC 相关  相机硬件接口相关\n    private var videoDataOutput: AVCaptureVideoDataOutput?\n    private var output: AVCaptureMetadataOutput?\n    private var session: AVCaptureSession?\n    private var videoPreviewLayer: AVCaptureVideoPreviewLayer?\n```\n\n其它成员不着急，后续需要再加上去。\n\n### 3.3 生命周期之loadView\n\nloadView执行时机为：访问视图控制器的view时候，如何view为nil，或者还没有加载完成就会调用loadView方法来创建view。可以理解成先于viewDidLoad，一般走一次，一般用于视图初始化。\n\n这里就负责 添加子View 的工作。\n```Swift\nprivate func setupUI() {\n        view.addSubview(layerView)\n        view.addSubview(squareImgView)\n        view.addSubview(torchButton)\n        view.addSubview(tipsLabel)\n        view.addSubview(commitButton)\n        view.addSubview(inputButton)\n        view.addSubview(photoBtn)\n\n        squareImgView.snp.makeConstraints { make in\n            make.size.equalTo(320)\n            make.centerX.equalToSuperview()\n            make.top.equalTo(STATUS_BAR_HEIGHT + 44 + 76)\n        }\n        \n        torchButton.snp.makeConstraints { make in\n            make.centerX.equalToSuperview()\n            make.bottom.equalTo(squareImgView.snp.bottom).offset(20)\n            make.width.equalTo(320)\n            make.height.equalTo(200)\n        }\n        \n        tipsLabel.snp.makeConstraints { make in\n            make.centerX.equalToSuperview()\n            make.top.equalTo(squareImgView.snp.bottom).offset(12)\n        }\n        \n        commitButton.snp.makeConstraints { make in\n            make.top.equalTo(layerView.snp.bottom).offset(42)\n            make.leading.equalTo(102)\n            make.trailing.equalTo(-102)\n            make.height.equalTo(44)\n        }\n        \n        inputButton.snp.makeConstraints{ make in\n            make.top.equalTo(commitButton.snp.bottom).offset(12)\n            make.left.equalTo(commitButton)\n            make.right.equalTo(commitButton)\n            make.height.equalTo(36)\n        }\n        \n        photoBtn.snp.makeConstraints{ make in\n            make.centerY.equalTo(commitButton)\n            make.leading.equalTo(16)\n            make.width.height.equalTo(44)\n        }\n    }\n```\n可以看到，这里把架子搭上去了。\n\n### 3.4 生命周期之 viewDidLoad\n\n看下这里做了什么：\n```Swift\n override func viewDidLoad() {\n        super.viewDidLoad()\n        // 标题文字大小\n        navigationController?.navigationBar.navBarBackGroundColor(.black, image: UIImage(), isOpaque: false)\n        navigationController?.navigationBar.titleTextAttributes = [NSAttributedString.Key.foregroundColor:UIColor.white, NSAttributedString.Key.font : UIFont.pingFangMedium(size: 18)]\n        \n        // 背景黑色\n        view.backgroundColor = UIColor(hex: \"#242424\")\n\n        // 添加手势，用来实现二指缩放效果\n        addGesture()\n        \n        // 监听全局通知\n        addNotification()\n        \n        // 自己定义的协议，去加载历史数据\n        delegate?.loadHistoryData()\n        \n        // 手动输入条码闭包回调\n        manuallyInputViewController.inputBlock = { [unowned self] (_, code) in\n            self.delegate?.manuallyInput(code.replaceFlag)\n        }\n    }\n```\n\n如何添加手势呢？\n```Swift\nprivate func addGesture() {\n        let prinGesture = UIPinchGestureRecognizer(target: self, action: #selector(pinch(gesture:)))\n        layerView.addGestureRecognizer(prinGesture)\n    }\n```\n\n操作后会触发：\n```Swift\n@objc func pinch(gesture: UIPinchGestureRecognizer) {\n        guard let device = AVCaptureDevice.default(for: AVMediaType.video) else {\n            print(\"get front video AVCaptureDeviceInput  failed!\")\n            return\n        }\n        var minZoomFactor = 1.0\n        var maxZoomFactor = device.activeFormat.videoMaxZoomFactor\n        \n        if #available(iOS 11.0,*) {\n            minZoomFactor = device.minAvailableVideoZoomFactor\n            maxZoomFactor = device.maxAvailableVideoZoomFactor\n        }\n        \n        if gesture.state == .began {\n            lastZoomFactor = device.videoZoomFactor\n            print(\"缩放比例  \\(device.videoZoomFactor)\")\n            \n        } else if gesture.state == .changed{\n            var zoomFactor: Float = Float(lastZoomFactor * gesture.scale);\n            zoomFactor = fmaxf(fminf(zoomFactor, Float(maxZoomFactor)), Float(minZoomFactor))\n            print(\"缩放比例  \\(zoomFactor)\")\n            try? device.lockForConfiguration()\n            device.videoZoomFactor = CGFloat(zoomFactor)\n            device.unlockForConfiguration()\n        } else if gesture.state == .ended {\n            print(\"最终缩放比例  \\(device.videoZoomFactor)\")\n        }\n    }\n```\n\n其它的没啥了。\n\n### 3.5 生命周期之viewWillAppear\n\n这个是将要显示，一般做轻量级操作。\n```Swift\noverride func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n        setupRealWhiteClickCallBack()\n        setupBlackNavWhiteTitleBarColor()\n        isHiddenNavBar(isHidden: false)\n    }\n```\n主要实现了状态栏和标题栏相关的。\n\n### 3.6 生命周期之viewDidAppear\n\n这里是已经显示了，这里可以做稍微重量级代码。\n```Swift\noverride func viewDidAppear(_ animated: Bool) {\n        super.viewDidAppear(animated)\n        if self.session == nil {\n            self.scanQRCodePermission()\n        } else {\n            self.startScan()\n        }\n        UIApplication.shared.isIdleTimerDisabled = true\n        setNeedsStatusBarAppearanceUpdate()\n    }\n```\n很明显这里判断了下session是否为null。\n\n如果session为nil，则先判断是否有相机权限：\n```Swift\nfunc scanQRCodePermission() {\n        // 判断摄像头是否可用\n        let available = UIImagePickerController.isSourceTypeAvailable(.camera)\n        if available {\n            \n            // 判断是否有相机权限\n            let authStatus: AVAuthorizationStatus = AVCaptureDevice.authorizationStatus(for: AVMediaType.video)\n            if authStatus == .restricted {\n                let alerVC: UIAlertController = .init(title: \"提示\", message: \"由于系统原因, 无法访问相机\", preferredStyle: UIAlertController.Style.alert)\n                alerVC.addAction(UIAlertAction.init(title: \"确定\", style: .destructive) { (action) in\n                    UIApplication.shared.open(NSURL(string: UIApplication.openSettingsURLString)! as URL, options: [:] ) { (success) in\n                    }\n                })\n                present(alerVC, animated: true, completion: nil)\n            } else if authStatus == .denied {\n                let dic = Bundle.main.infoDictionary\n                var appName = dic?[\"CFBundleDisplayName\"]\n                if appName == nil{\n                    appName = dic?[\"CFBundleName\"]\n                }\n                let str = String.localizedStringWithFormat(\"[前往：设置 - 隐私 - 相机 - %@] 允许应用访问\", appName as! String)\n                let alerVC = UIAlertController(title: \"提示\", message: str, preferredStyle: .alert)\n                alerVC.addAction(UIAlertAction(title: \"确定\", style: UIAlertAction.Style.destructive) { (action) in\n                    UIApplication.shared.open(NSURL(string: UIApplication.openSettingsURLString)! as URL, options: [:] ) { (success) in\n                    }\n                })\n                present(alerVC, animated: true, completion: nil)\n            } else if authStatus == .notDetermined {\n                //用户未作出选择，申请权限 AVC直接requestAccess\n                AVCaptureDevice.requestAccess(for: AVMediaType.video){\n                    granted in\n                    DispatchQueue.main.async {\n                        if granted {\n                            //初次授权成功\n                            self.initCaptureSession()\n                        } else {\n                            //拒绝授权\n                        }\n                    }\n                }\n            } else {\n                //已授权\n                self.initCaptureSession()\n            }\n        } else {\n            //摄像头可能已损坏\n        }\n    }\n```\n上面的代码讲述了如何申请权限，权限被拒绝如何跳转设置。\n\n如果有权限了会走 initCaptureSession 来初始化session:\n```Swift\nfunc initCaptureSession() {\n        //创建会话对象\n        let `session` = AVCaptureSession()\n        self.session = session\n        session.sessionPreset = .high\n        \n        //获取设想设备\n        guard let device = AVCaptureDevice.default(for: AVMediaType.video) else {\n            print(\"get front video AVCaptureDeviceInput  failed!\")\n            return\n        }\n        \n        //创建设想设备输入流\n        guard let input = try? AVCaptureDeviceInput(device: device) else {\n            print(\"get front video AVCaptureDeviceInput  failed!\")\n            return\n        }\n        \n        //添加设想设备输入流到会话对象 输入流让session来分析\n        if session.canAddInput(input) {\n            session.addInput(input)\n        }\n        \n        //创建元数据输出流\n        let `output` = AVCaptureMetadataOutput()\n        self.output = output\n        output.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)\n                \n        //添加元数据输出流到会话对象 给新建的一个Output对象添加到session,session等下会给output赋值\n        session.addOutput(output)\n        \n        //创建摄像数据输出流并将其添加到会话对象上----->用户识别光线强弱\n        let `videoDataOutput` = AVCaptureVideoDataOutput()\n        self.videoDataOutput = videoDataOutput\n        videoDataOutput.setSampleBufferDelegate(self, queue: DispatchQueue.main)\n        session.addOutput(videoDataOutput)\n        \n        //设置数据输出类型(如下设置为条形码和二维码兼容)，需要将数据输出添加到会话后，才能指定元数据类型，否则会报错\n        \n        /*\n         \n         android\n         \n         Barcode.FORMAT_CODE_128,   *\n         Barcode.FORMAT_CODE_39,    *\n         Barcode.FORMAT_CODE_93,    *\n         Barcode.FORMAT_CODABAR,    ios 15.4 +\n         Barcode.FORMAT_EAN_13,     *\n         Barcode.FORMAT_EAN_8,      *\n         Barcode.FORMAT_UPC_A,      x\n         Barcode.FORMAT_UPC_E,      *\n         Barcode.TYPE_ISBN          x\n         */\n        output.metadataObjectTypes = [.code39,\n                                      .code39Mod43,\n                                      .code93,\n                                      .code128,\n                                      .ean8,\n                                      .ean13,\n                                      .upce,\n                                      .pdf417] //itf14\n        //实例化预览图层, 用于显示会话对象 session放到这里面，然后通过layer插入sublayer可以实现预览效果\n        let `videoPreviewLayer` = AVCaptureVideoPreviewLayer(session: session)\n        self.videoPreviewLayer = videoPreviewLayer\n        videoPreviewLayer.videoGravity = .resizeAspectFill\n        videoPreviewLayer.frame = layerView.bounds\n        layerView.layer.insertSublayer(videoPreviewLayer, at: 0)\n        \n        // session开始run\n        startScan()\n    }\n```\n\n回到 生命周期 中，如果 session 不为空，会走上面的startScan 函数，这里就是让session继续工作的意思：\n```Swift\nfunc startScan() {\n        session?.startRunning()\n    }\n```\n\n在viewDidAppear中还做了什么呢？\n```Swift\nUIApplication.shared.isIdleTimerDisabled = true\nsetNeedsStatusBarAppearanceUpdate()\n```\n\n第一行：禁止该页面进入睡眠；\n第二行：如果在viewController已经显示在当前页面，你可能还要在当前页面不时的更改statusBar的前景色，那么，你首先需要调用下面的setNeedsStatusBarAppearanceUpdate方法(这个方法会通知系统去调用当前UIViewController的preferredStatusBarStyle方法)，从而改变statusBar的statusBarStyle。\n\n### 3.7 生命周期之viewDidDisappear\n\n```Swift\n override func viewDidDisappear(_ animated: Bool) {\n        super.viewDidDisappear(animated)\n        stopScan()\n        UIApplication.shared.isIdleTimerDisabled = false\n        setNeedsStatusBarAppearanceUpdate()\n    }\n```\n这里停止扫描，应该是停止session:\n```Swift\nfunc stopScan() {\n        session?.stopRunning()\n    }\n```\n\n其它上面讲过，不必多言了。\n\n### 3.8 设置output代理\n\n回到初始化session的部分代码中：\n```Swift\n//创建元数据输出流\nlet `output` = AVCaptureMetadataOutput()\nself.output = output\noutput.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)\n```\n这里设置了一个metadata的代理，所以这个controller必然扩展了这个代理。\n\n具体如下：\n```Swift\nextension GMBaseScanViewController: AVCaptureMetadataOutputObjectsDelegate {\n    func metadataOutput(_ output: AVCaptureMetadataOutput, didOutput metadataObjects: [AVMetadataObject], from connection: AVCaptureConnection) {\n        if isCanScan {\n            let isAchieve: Bool = metadataObjects.count == 1\n            if isAchieve {\n                // 扫到条码\n                guard let device = AVCaptureDevice.default(for: AVMediaType.video) else { return }\n                guard let codeObj = metadataObjects.last as? AVMetadataMachineReadableCodeObject else { return }\n                print(\"扫到了条码 codeObj  ：  \\(codeObj)\")\n                guard let str = codeObj.stringValue else { return }\n                self.isCanScan = false\n                print(\"扫到了条码 str：  \\(str)\")\n                DispatchQueue.main.asyncAfter(deadline: .now() + scanInterval) {\n                    try? device.lockForConfiguration()\n                    device.videoZoomFactor = 1\n                    device.unlockForConfiguration()\n                    self.isCanScan = true\n                }\n                let barCode = barcodeProcessing(str)\n                delegate?.scanBarcode(barCode)\n            } else {\n                MBProgressHUD.showTipsMessage(\"无法识别\")\n            }\n        }\n    }\n    \n    func barcodeProcessing(_ code: String) -> String {\n        var codeStr: String = code.mutableCopy() as! String\n        var newStr = code.uppercased()\n        var index = 0\n        newStr = newStr.replacingOccurrences(of: \" \", with: \"\", options: .literal, range: nil)\n        codeStr = codeStr.replacingOccurrences(of: \" \", with: \"\", options: .literal, range: nil)\n        if newStr.hasPrefix(\"GREE\") {\n            index = 3\n        } else if newStr.hasPrefix(\"KINGHOME\") {\n            index = 7\n        } else if newStr.hasPrefix(\"TOSOT\") {\n            index = 4\n        }\n        if index != 0 {\n            let start = codeStr.index(codeStr.startIndex, offsetBy: 0)\n            let end = codeStr.index(codeStr.startIndex, offsetBy: index)\n            codeStr.removeSubrange(start...end)\n        }\n        return codeStr\n    }\n}\n```\n这里覆写了这协议方法，表示识别到内容了。然后会回调metadateOutput，原因是前面session里面设置了Output的代理为self,也就是这里，这里就关联起来了。\n前面是这样的：\n```Swift\n let `output` = AVCaptureMetadataOutput()\n        self.output = output\n        output.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)\n                \n        //添加元数据输出流到会话对象 给新建的一个Output对象添加到session,session等下会给output赋值\n        session.addOutput(output)\n```\n就是因为这个self，当session开始running后，就会走协议的回调方法，在那里面我们间隔3.5才让它进行下次扫描，也是在这里面分析这个条码是否正常之类的。\n\n### 3.9 设置videoDataOuput代理\n\n这个代理，目的是为了识别光线强弱。\n```Swift\nextension GMBaseScanViewController: AVCaptureVideoDataOutputSampleBufferDelegate {\n    \n    func captureOutput(_ output: AVCaptureOutput, didOutput sampleBuffer: CMSampleBuffer, from connection: AVCaptureConnection) {\n        // 获取光照亮度\n        guard let metadataCFDict: CFDictionary = CMCopyDictionaryOfAttachments(allocator: nil, target: sampleBuffer, attachmentMode: 1) else { return }\n        guard let metadataDic: [String: AnyObject] = metadataCFDict as? [String: AnyObject] else { return }\n        guard let exifMetadata: [String: AnyObject] = metadataDic[kCGImagePropertyExifDictionary as String] as? [String : AnyObject] else { return }\n        guard let brightnessValue: CGFloat = exifMetadata[kCGImagePropertyExifBrightnessValue as String] as? CGFloat else { return }\n        // 根据光照亮度展示按钮\n        if brightnessValue < -1 {\n            torchButton.isHidden = false\n        } else {\n            guard let device = AVCaptureDevice.default(for: AVMediaType.video) else { return }\n            if device.hasTorch && device.isTorchAvailable {\n                try? device.lockForConfiguration()\n                torchButton.isHidden = !(device.torchMode == .on)\n                device.unlockForConfiguration()\n                \n            }\n        }\n        \n    }\n    \n    private func convert(cmage: CIImage) -> UIImage {\n         let context = CIContext(options: nil)\n         let cgImage = context.createCGImage(cmage, from: cmage.extent)!\n         let image = UIImage(cgImage: cgImage)\n         return image\n    }\n    \n}\n```\n在代理 captureOutput的回调方法中可以获取光线强弱信息。\n\n也是在初始化session的时候设置了这个代理。\n\n### 3.10 识别到后播放声音\n\n这里我们额外增加一个方法，主要给外面调用，因为我们会提供一个代理，如果识别到后，通过代理内部方法将识别的条码给外面。这时候外面要震动或声音效果，只需要调用我们内部的一个方法即可。\n\n```Swift\nfunc playAudio(success code: Int) {\n        if isPlay == false {\n            return\n        }\n        if code == 1 {\n            var soundID: SystemSoundID = 0\n            guard let path = Bundle.main.path(forResource: \"scanSuccess\", ofType: \"mp3\") else { return }\n            let url = URL(fileURLWithPath: path)\n            AudioServicesCreateSystemSoundID(url as CFURL, &soundID)\n            AudioServicesPlaySystemSound(soundID) //声音\n        } else {\n            var soundID: SystemSoundID = 0\n            guard let path = Bundle.main.path(forResource: \"scanFail\", ofType: \"mp3\") else { return }\n            let url = URL(fileURLWithPath: path)\n            AudioServicesCreateSystemSoundID(url as CFURL, &soundID)\n            AudioServicesPlayAlertSound(soundID) //震动+播放声音\n        }\n    }\n```\n也是非常简单，只需要先拿到声音路径，转换url，再通过AudioServicesCreateSystemSoundID包装一下，再通过AudioServicesPlaySystemSound来播放这个soundID即可。\n\n就这样，一个具有扫码能力的Controller就出来了哦。\n\n## 4 总结\n\n* 如果用到扫码，一定需要申请权限的，必须考虑到是否有权限，如果拒绝了权限，或其它原因导致没有权限，都需要考虑。\n\n* 扫码关键的几个类，AVCaptureSession控制数据流关键类；AVCaptureMetadataOutput接收流，代理方法来处理识别到条码后的逻辑；AVCaptureVideoDataOutput接收流，可以处理光线强弱；AVCaptureVideoPreviewLayer用来预览相机的视图层，可显示在UIView的layer上。\n\n* 一般扫码需要具备的二指缩放，光线太暗打开闪光灯，这些可以算作基本能能力，务必要实现，否则体验很不佳。\n\n* 合理控制识别到条码间隔时间，该停止session的时候务必停止，为了防止频繁识别到相同条码，可以设置间隔时间。\n\n* 可以先定义一个播放声音效果的方法，方便外部直接调用方法播放成功或者失败的声音。声音主要用到AudioServices相关方法。\n\n* 系统类大多都是提供了代理，暴露了一些方法主要都是定义好的方法，我们业务开发也只需要接收和处理这些定义好的类就可以了。\n","source":"_posts/iOS-swift-如何实现扫码功能.md","raw":"---\ntitle: iOS swift 如何实现扫码功能\ndate: 2023-01-29 08:13:37\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- 条形码识别 相机\ncategories:\n- iOS\n---\n\n## 1 需求定义\n\n这里有个需求，就是继承扫码能力，可以识别到条形码里面的内容。\n首先我们需要下载一个离线库，这个库里面会包含很多条码Code，相机通过识别到条码跟离线库中的匹配，如果匹配上了，会提示用户。所以首先我们肯定要有一个识别能力，数据库先不管，后面会有专门的文章来写数据库相关的东西。\n\n本篇文章主要是从0搭建一个可以识别条形码能力的Controller。\n其它额外需求先忽略。\n\n目标就是完成这样的效果：\n<img src=scan1.png>\n<img src=scan2.png>\n\n## 2 分析需求\n\n要具备扫码功能，肯定离不开相机，调用相机会设计到权限。\n所以我们得考虑是否有相机权限。\n其次，得考虑如何来识别条形码。\n重复识别到的问题。\n页面退出，相机资源怎么处理。\n光线太暗了，是否需要打开手电筒。\n条码太小，是否需要放大。\n等等，这些事先都得考虑到。\n\n\n## 3 打造页面\n\n### 3.1 构建UI\n\n首先把材料上齐。\n```Swift\nlazy var squareImgView: UIImageView = {\n        let imgv = UIImageView()\n        imgv.isUserInteractionEnabled = false\n        imgv.image = UIImage(named: \"扫码框\")\n        return imgv\n    }()\n    \n    lazy var torchButton: UIButton = {\n        let temp = UIButton(type: .custom)\n        temp.setImage(UIImage(named: \"scan_torch\"), for: .normal)\n        temp.setTitle(\"轻触照亮\", for: .normal)\n        temp.isHidden = true\n        temp.titleLabel?.font = UIFont.regular(15)\n        temp.ddy_SetStyle(.imgDown, padding: 10)\n        temp.addTarget(self, action: #selector(torchButtonClick), for: .touchUpInside)\n        return temp\n    }()\n    \n    lazy var photoBtn: UIButton = {\n        let btn = UIButton(type: .custom)\n        btn.setImage(UIImage(named: \"PhotoAlbum\"), for: .normal)\n        btn.addTarget(self, action: #selector(actionForPhoto), for: .touchUpInside)\n        return btn\n    }()\n    \n    lazy var tipsLabel: UILabel = {\n        let temp = UILabel()\n        temp.text = \"扫一扫条形码\"\n        temp.textColor = .white\n        temp.font = UIFont.regular(13)\n        temp.sizeToFit()\n        return temp\n    }()\n    \n    lazy var commitButton: UIButton = {\n        let btn: UIButton = UIButton(type: .custom)\n        btn.backgroundColor = UIColor(hex: \"#242424\")\n        btn.clipsToBounds = true\n        btn.layer.cornerRadius = 22\n        btn.layer.borderWidth = 1\n        btn.layer.borderColor = UIColor.white.cgColor\n        btn.setTitle(\"扫描完成\", for: .normal)\n        btn.addTarget(self, action: #selector(commitButtonClick), for: .touchUpInside)\n        return btn\n    }()\n    \n    lazy var inputButton: UIButton = {\n        let btn: UIButton = UIButton(type: .custom)\n        btn.backgroundColor = UIColor(hex: \"#242424\")\n        btn.layer.borderColor = UIColor.white.cgColor\n        btn.setTitle(\"手动输入条形码\", for: .normal)\n        btn.addTarget(self, action: #selector(actionForPushManuallyInput), for: .touchUpInside)\n        return btn\n    }()\n\n    lazy var layerView: UIView = {\n        let view = UIView(frame: CGRect(x: 0,\n                                        y: STATUS_BAR_HEIGHT + 44,\n                                        width: ScreenWidth,\n                                        height: ScreenHeight - STATUS_BAR_HEIGHT - 44 - 162))\n        return view\n    }()\n```\n打开需要这几个View。\n\n### 3.2 全局变量声明\n\n想要具备扫码能力，有几个类是必须的。\n```Swift\n// AVC 相关  相机硬件接口相关\n    private var videoDataOutput: AVCaptureVideoDataOutput?\n    private var output: AVCaptureMetadataOutput?\n    private var session: AVCaptureSession?\n    private var videoPreviewLayer: AVCaptureVideoPreviewLayer?\n```\n\n其它成员不着急，后续需要再加上去。\n\n### 3.3 生命周期之loadView\n\nloadView执行时机为：访问视图控制器的view时候，如何view为nil，或者还没有加载完成就会调用loadView方法来创建view。可以理解成先于viewDidLoad，一般走一次，一般用于视图初始化。\n\n这里就负责 添加子View 的工作。\n```Swift\nprivate func setupUI() {\n        view.addSubview(layerView)\n        view.addSubview(squareImgView)\n        view.addSubview(torchButton)\n        view.addSubview(tipsLabel)\n        view.addSubview(commitButton)\n        view.addSubview(inputButton)\n        view.addSubview(photoBtn)\n\n        squareImgView.snp.makeConstraints { make in\n            make.size.equalTo(320)\n            make.centerX.equalToSuperview()\n            make.top.equalTo(STATUS_BAR_HEIGHT + 44 + 76)\n        }\n        \n        torchButton.snp.makeConstraints { make in\n            make.centerX.equalToSuperview()\n            make.bottom.equalTo(squareImgView.snp.bottom).offset(20)\n            make.width.equalTo(320)\n            make.height.equalTo(200)\n        }\n        \n        tipsLabel.snp.makeConstraints { make in\n            make.centerX.equalToSuperview()\n            make.top.equalTo(squareImgView.snp.bottom).offset(12)\n        }\n        \n        commitButton.snp.makeConstraints { make in\n            make.top.equalTo(layerView.snp.bottom).offset(42)\n            make.leading.equalTo(102)\n            make.trailing.equalTo(-102)\n            make.height.equalTo(44)\n        }\n        \n        inputButton.snp.makeConstraints{ make in\n            make.top.equalTo(commitButton.snp.bottom).offset(12)\n            make.left.equalTo(commitButton)\n            make.right.equalTo(commitButton)\n            make.height.equalTo(36)\n        }\n        \n        photoBtn.snp.makeConstraints{ make in\n            make.centerY.equalTo(commitButton)\n            make.leading.equalTo(16)\n            make.width.height.equalTo(44)\n        }\n    }\n```\n可以看到，这里把架子搭上去了。\n\n### 3.4 生命周期之 viewDidLoad\n\n看下这里做了什么：\n```Swift\n override func viewDidLoad() {\n        super.viewDidLoad()\n        // 标题文字大小\n        navigationController?.navigationBar.navBarBackGroundColor(.black, image: UIImage(), isOpaque: false)\n        navigationController?.navigationBar.titleTextAttributes = [NSAttributedString.Key.foregroundColor:UIColor.white, NSAttributedString.Key.font : UIFont.pingFangMedium(size: 18)]\n        \n        // 背景黑色\n        view.backgroundColor = UIColor(hex: \"#242424\")\n\n        // 添加手势，用来实现二指缩放效果\n        addGesture()\n        \n        // 监听全局通知\n        addNotification()\n        \n        // 自己定义的协议，去加载历史数据\n        delegate?.loadHistoryData()\n        \n        // 手动输入条码闭包回调\n        manuallyInputViewController.inputBlock = { [unowned self] (_, code) in\n            self.delegate?.manuallyInput(code.replaceFlag)\n        }\n    }\n```\n\n如何添加手势呢？\n```Swift\nprivate func addGesture() {\n        let prinGesture = UIPinchGestureRecognizer(target: self, action: #selector(pinch(gesture:)))\n        layerView.addGestureRecognizer(prinGesture)\n    }\n```\n\n操作后会触发：\n```Swift\n@objc func pinch(gesture: UIPinchGestureRecognizer) {\n        guard let device = AVCaptureDevice.default(for: AVMediaType.video) else {\n            print(\"get front video AVCaptureDeviceInput  failed!\")\n            return\n        }\n        var minZoomFactor = 1.0\n        var maxZoomFactor = device.activeFormat.videoMaxZoomFactor\n        \n        if #available(iOS 11.0,*) {\n            minZoomFactor = device.minAvailableVideoZoomFactor\n            maxZoomFactor = device.maxAvailableVideoZoomFactor\n        }\n        \n        if gesture.state == .began {\n            lastZoomFactor = device.videoZoomFactor\n            print(\"缩放比例  \\(device.videoZoomFactor)\")\n            \n        } else if gesture.state == .changed{\n            var zoomFactor: Float = Float(lastZoomFactor * gesture.scale);\n            zoomFactor = fmaxf(fminf(zoomFactor, Float(maxZoomFactor)), Float(minZoomFactor))\n            print(\"缩放比例  \\(zoomFactor)\")\n            try? device.lockForConfiguration()\n            device.videoZoomFactor = CGFloat(zoomFactor)\n            device.unlockForConfiguration()\n        } else if gesture.state == .ended {\n            print(\"最终缩放比例  \\(device.videoZoomFactor)\")\n        }\n    }\n```\n\n其它的没啥了。\n\n### 3.5 生命周期之viewWillAppear\n\n这个是将要显示，一般做轻量级操作。\n```Swift\noverride func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n        setupRealWhiteClickCallBack()\n        setupBlackNavWhiteTitleBarColor()\n        isHiddenNavBar(isHidden: false)\n    }\n```\n主要实现了状态栏和标题栏相关的。\n\n### 3.6 生命周期之viewDidAppear\n\n这里是已经显示了，这里可以做稍微重量级代码。\n```Swift\noverride func viewDidAppear(_ animated: Bool) {\n        super.viewDidAppear(animated)\n        if self.session == nil {\n            self.scanQRCodePermission()\n        } else {\n            self.startScan()\n        }\n        UIApplication.shared.isIdleTimerDisabled = true\n        setNeedsStatusBarAppearanceUpdate()\n    }\n```\n很明显这里判断了下session是否为null。\n\n如果session为nil，则先判断是否有相机权限：\n```Swift\nfunc scanQRCodePermission() {\n        // 判断摄像头是否可用\n        let available = UIImagePickerController.isSourceTypeAvailable(.camera)\n        if available {\n            \n            // 判断是否有相机权限\n            let authStatus: AVAuthorizationStatus = AVCaptureDevice.authorizationStatus(for: AVMediaType.video)\n            if authStatus == .restricted {\n                let alerVC: UIAlertController = .init(title: \"提示\", message: \"由于系统原因, 无法访问相机\", preferredStyle: UIAlertController.Style.alert)\n                alerVC.addAction(UIAlertAction.init(title: \"确定\", style: .destructive) { (action) in\n                    UIApplication.shared.open(NSURL(string: UIApplication.openSettingsURLString)! as URL, options: [:] ) { (success) in\n                    }\n                })\n                present(alerVC, animated: true, completion: nil)\n            } else if authStatus == .denied {\n                let dic = Bundle.main.infoDictionary\n                var appName = dic?[\"CFBundleDisplayName\"]\n                if appName == nil{\n                    appName = dic?[\"CFBundleName\"]\n                }\n                let str = String.localizedStringWithFormat(\"[前往：设置 - 隐私 - 相机 - %@] 允许应用访问\", appName as! String)\n                let alerVC = UIAlertController(title: \"提示\", message: str, preferredStyle: .alert)\n                alerVC.addAction(UIAlertAction(title: \"确定\", style: UIAlertAction.Style.destructive) { (action) in\n                    UIApplication.shared.open(NSURL(string: UIApplication.openSettingsURLString)! as URL, options: [:] ) { (success) in\n                    }\n                })\n                present(alerVC, animated: true, completion: nil)\n            } else if authStatus == .notDetermined {\n                //用户未作出选择，申请权限 AVC直接requestAccess\n                AVCaptureDevice.requestAccess(for: AVMediaType.video){\n                    granted in\n                    DispatchQueue.main.async {\n                        if granted {\n                            //初次授权成功\n                            self.initCaptureSession()\n                        } else {\n                            //拒绝授权\n                        }\n                    }\n                }\n            } else {\n                //已授权\n                self.initCaptureSession()\n            }\n        } else {\n            //摄像头可能已损坏\n        }\n    }\n```\n上面的代码讲述了如何申请权限，权限被拒绝如何跳转设置。\n\n如果有权限了会走 initCaptureSession 来初始化session:\n```Swift\nfunc initCaptureSession() {\n        //创建会话对象\n        let `session` = AVCaptureSession()\n        self.session = session\n        session.sessionPreset = .high\n        \n        //获取设想设备\n        guard let device = AVCaptureDevice.default(for: AVMediaType.video) else {\n            print(\"get front video AVCaptureDeviceInput  failed!\")\n            return\n        }\n        \n        //创建设想设备输入流\n        guard let input = try? AVCaptureDeviceInput(device: device) else {\n            print(\"get front video AVCaptureDeviceInput  failed!\")\n            return\n        }\n        \n        //添加设想设备输入流到会话对象 输入流让session来分析\n        if session.canAddInput(input) {\n            session.addInput(input)\n        }\n        \n        //创建元数据输出流\n        let `output` = AVCaptureMetadataOutput()\n        self.output = output\n        output.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)\n                \n        //添加元数据输出流到会话对象 给新建的一个Output对象添加到session,session等下会给output赋值\n        session.addOutput(output)\n        \n        //创建摄像数据输出流并将其添加到会话对象上----->用户识别光线强弱\n        let `videoDataOutput` = AVCaptureVideoDataOutput()\n        self.videoDataOutput = videoDataOutput\n        videoDataOutput.setSampleBufferDelegate(self, queue: DispatchQueue.main)\n        session.addOutput(videoDataOutput)\n        \n        //设置数据输出类型(如下设置为条形码和二维码兼容)，需要将数据输出添加到会话后，才能指定元数据类型，否则会报错\n        \n        /*\n         \n         android\n         \n         Barcode.FORMAT_CODE_128,   *\n         Barcode.FORMAT_CODE_39,    *\n         Barcode.FORMAT_CODE_93,    *\n         Barcode.FORMAT_CODABAR,    ios 15.4 +\n         Barcode.FORMAT_EAN_13,     *\n         Barcode.FORMAT_EAN_8,      *\n         Barcode.FORMAT_UPC_A,      x\n         Barcode.FORMAT_UPC_E,      *\n         Barcode.TYPE_ISBN          x\n         */\n        output.metadataObjectTypes = [.code39,\n                                      .code39Mod43,\n                                      .code93,\n                                      .code128,\n                                      .ean8,\n                                      .ean13,\n                                      .upce,\n                                      .pdf417] //itf14\n        //实例化预览图层, 用于显示会话对象 session放到这里面，然后通过layer插入sublayer可以实现预览效果\n        let `videoPreviewLayer` = AVCaptureVideoPreviewLayer(session: session)\n        self.videoPreviewLayer = videoPreviewLayer\n        videoPreviewLayer.videoGravity = .resizeAspectFill\n        videoPreviewLayer.frame = layerView.bounds\n        layerView.layer.insertSublayer(videoPreviewLayer, at: 0)\n        \n        // session开始run\n        startScan()\n    }\n```\n\n回到 生命周期 中，如果 session 不为空，会走上面的startScan 函数，这里就是让session继续工作的意思：\n```Swift\nfunc startScan() {\n        session?.startRunning()\n    }\n```\n\n在viewDidAppear中还做了什么呢？\n```Swift\nUIApplication.shared.isIdleTimerDisabled = true\nsetNeedsStatusBarAppearanceUpdate()\n```\n\n第一行：禁止该页面进入睡眠；\n第二行：如果在viewController已经显示在当前页面，你可能还要在当前页面不时的更改statusBar的前景色，那么，你首先需要调用下面的setNeedsStatusBarAppearanceUpdate方法(这个方法会通知系统去调用当前UIViewController的preferredStatusBarStyle方法)，从而改变statusBar的statusBarStyle。\n\n### 3.7 生命周期之viewDidDisappear\n\n```Swift\n override func viewDidDisappear(_ animated: Bool) {\n        super.viewDidDisappear(animated)\n        stopScan()\n        UIApplication.shared.isIdleTimerDisabled = false\n        setNeedsStatusBarAppearanceUpdate()\n    }\n```\n这里停止扫描，应该是停止session:\n```Swift\nfunc stopScan() {\n        session?.stopRunning()\n    }\n```\n\n其它上面讲过，不必多言了。\n\n### 3.8 设置output代理\n\n回到初始化session的部分代码中：\n```Swift\n//创建元数据输出流\nlet `output` = AVCaptureMetadataOutput()\nself.output = output\noutput.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)\n```\n这里设置了一个metadata的代理，所以这个controller必然扩展了这个代理。\n\n具体如下：\n```Swift\nextension GMBaseScanViewController: AVCaptureMetadataOutputObjectsDelegate {\n    func metadataOutput(_ output: AVCaptureMetadataOutput, didOutput metadataObjects: [AVMetadataObject], from connection: AVCaptureConnection) {\n        if isCanScan {\n            let isAchieve: Bool = metadataObjects.count == 1\n            if isAchieve {\n                // 扫到条码\n                guard let device = AVCaptureDevice.default(for: AVMediaType.video) else { return }\n                guard let codeObj = metadataObjects.last as? AVMetadataMachineReadableCodeObject else { return }\n                print(\"扫到了条码 codeObj  ：  \\(codeObj)\")\n                guard let str = codeObj.stringValue else { return }\n                self.isCanScan = false\n                print(\"扫到了条码 str：  \\(str)\")\n                DispatchQueue.main.asyncAfter(deadline: .now() + scanInterval) {\n                    try? device.lockForConfiguration()\n                    device.videoZoomFactor = 1\n                    device.unlockForConfiguration()\n                    self.isCanScan = true\n                }\n                let barCode = barcodeProcessing(str)\n                delegate?.scanBarcode(barCode)\n            } else {\n                MBProgressHUD.showTipsMessage(\"无法识别\")\n            }\n        }\n    }\n    \n    func barcodeProcessing(_ code: String) -> String {\n        var codeStr: String = code.mutableCopy() as! String\n        var newStr = code.uppercased()\n        var index = 0\n        newStr = newStr.replacingOccurrences(of: \" \", with: \"\", options: .literal, range: nil)\n        codeStr = codeStr.replacingOccurrences(of: \" \", with: \"\", options: .literal, range: nil)\n        if newStr.hasPrefix(\"GREE\") {\n            index = 3\n        } else if newStr.hasPrefix(\"KINGHOME\") {\n            index = 7\n        } else if newStr.hasPrefix(\"TOSOT\") {\n            index = 4\n        }\n        if index != 0 {\n            let start = codeStr.index(codeStr.startIndex, offsetBy: 0)\n            let end = codeStr.index(codeStr.startIndex, offsetBy: index)\n            codeStr.removeSubrange(start...end)\n        }\n        return codeStr\n    }\n}\n```\n这里覆写了这协议方法，表示识别到内容了。然后会回调metadateOutput，原因是前面session里面设置了Output的代理为self,也就是这里，这里就关联起来了。\n前面是这样的：\n```Swift\n let `output` = AVCaptureMetadataOutput()\n        self.output = output\n        output.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)\n                \n        //添加元数据输出流到会话对象 给新建的一个Output对象添加到session,session等下会给output赋值\n        session.addOutput(output)\n```\n就是因为这个self，当session开始running后，就会走协议的回调方法，在那里面我们间隔3.5才让它进行下次扫描，也是在这里面分析这个条码是否正常之类的。\n\n### 3.9 设置videoDataOuput代理\n\n这个代理，目的是为了识别光线强弱。\n```Swift\nextension GMBaseScanViewController: AVCaptureVideoDataOutputSampleBufferDelegate {\n    \n    func captureOutput(_ output: AVCaptureOutput, didOutput sampleBuffer: CMSampleBuffer, from connection: AVCaptureConnection) {\n        // 获取光照亮度\n        guard let metadataCFDict: CFDictionary = CMCopyDictionaryOfAttachments(allocator: nil, target: sampleBuffer, attachmentMode: 1) else { return }\n        guard let metadataDic: [String: AnyObject] = metadataCFDict as? [String: AnyObject] else { return }\n        guard let exifMetadata: [String: AnyObject] = metadataDic[kCGImagePropertyExifDictionary as String] as? [String : AnyObject] else { return }\n        guard let brightnessValue: CGFloat = exifMetadata[kCGImagePropertyExifBrightnessValue as String] as? CGFloat else { return }\n        // 根据光照亮度展示按钮\n        if brightnessValue < -1 {\n            torchButton.isHidden = false\n        } else {\n            guard let device = AVCaptureDevice.default(for: AVMediaType.video) else { return }\n            if device.hasTorch && device.isTorchAvailable {\n                try? device.lockForConfiguration()\n                torchButton.isHidden = !(device.torchMode == .on)\n                device.unlockForConfiguration()\n                \n            }\n        }\n        \n    }\n    \n    private func convert(cmage: CIImage) -> UIImage {\n         let context = CIContext(options: nil)\n         let cgImage = context.createCGImage(cmage, from: cmage.extent)!\n         let image = UIImage(cgImage: cgImage)\n         return image\n    }\n    \n}\n```\n在代理 captureOutput的回调方法中可以获取光线强弱信息。\n\n也是在初始化session的时候设置了这个代理。\n\n### 3.10 识别到后播放声音\n\n这里我们额外增加一个方法，主要给外面调用，因为我们会提供一个代理，如果识别到后，通过代理内部方法将识别的条码给外面。这时候外面要震动或声音效果，只需要调用我们内部的一个方法即可。\n\n```Swift\nfunc playAudio(success code: Int) {\n        if isPlay == false {\n            return\n        }\n        if code == 1 {\n            var soundID: SystemSoundID = 0\n            guard let path = Bundle.main.path(forResource: \"scanSuccess\", ofType: \"mp3\") else { return }\n            let url = URL(fileURLWithPath: path)\n            AudioServicesCreateSystemSoundID(url as CFURL, &soundID)\n            AudioServicesPlaySystemSound(soundID) //声音\n        } else {\n            var soundID: SystemSoundID = 0\n            guard let path = Bundle.main.path(forResource: \"scanFail\", ofType: \"mp3\") else { return }\n            let url = URL(fileURLWithPath: path)\n            AudioServicesCreateSystemSoundID(url as CFURL, &soundID)\n            AudioServicesPlayAlertSound(soundID) //震动+播放声音\n        }\n    }\n```\n也是非常简单，只需要先拿到声音路径，转换url，再通过AudioServicesCreateSystemSoundID包装一下，再通过AudioServicesPlaySystemSound来播放这个soundID即可。\n\n就这样，一个具有扫码能力的Controller就出来了哦。\n\n## 4 总结\n\n* 如果用到扫码，一定需要申请权限的，必须考虑到是否有权限，如果拒绝了权限，或其它原因导致没有权限，都需要考虑。\n\n* 扫码关键的几个类，AVCaptureSession控制数据流关键类；AVCaptureMetadataOutput接收流，代理方法来处理识别到条码后的逻辑；AVCaptureVideoDataOutput接收流，可以处理光线强弱；AVCaptureVideoPreviewLayer用来预览相机的视图层，可显示在UIView的layer上。\n\n* 一般扫码需要具备的二指缩放，光线太暗打开闪光灯，这些可以算作基本能能力，务必要实现，否则体验很不佳。\n\n* 合理控制识别到条码间隔时间，该停止session的时候务必停止，为了防止频繁识别到相同条码，可以设置间隔时间。\n\n* 可以先定义一个播放声音效果的方法，方便外部直接调用方法播放成功或者失败的声音。声音主要用到AudioServices相关方法。\n\n* 系统类大多都是提供了代理，暴露了一些方法主要都是定义好的方法，我们业务开发也只需要接收和处理这些定义好的类就可以了。\n","slug":"iOS-swift-如何实现扫码功能","published":1,"updated":"2023-02-01T07:12:23.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlc01je000ljhv72peba6gg","content":"<h2 id=\"1-需求定义\"><a href=\"#1-需求定义\" class=\"headerlink\" title=\"1 需求定义\"></a>1 需求定义</h2><p>这里有个需求，就是继承扫码能力，可以识别到条形码里面的内容。<br>首先我们需要下载一个离线库，这个库里面会包含很多条码Code，相机通过识别到条码跟离线库中的匹配，如果匹配上了，会提示用户。所以首先我们肯定要有一个识别能力，数据库先不管，后面会有专门的文章来写数据库相关的东西。</p>\n<p>本篇文章主要是从0搭建一个可以识别条形码能力的Controller。<br>其它额外需求先忽略。</p>\n<p>目标就是完成这样的效果：<br><img src=scan1.png><br><img src=scan2.png></p>\n<h2 id=\"2-分析需求\"><a href=\"#2-分析需求\" class=\"headerlink\" title=\"2 分析需求\"></a>2 分析需求</h2><p>要具备扫码功能，肯定离不开相机，调用相机会设计到权限。<br>所以我们得考虑是否有相机权限。<br>其次，得考虑如何来识别条形码。<br>重复识别到的问题。<br>页面退出，相机资源怎么处理。<br>光线太暗了，是否需要打开手电筒。<br>条码太小，是否需要放大。<br>等等，这些事先都得考虑到。</p>\n<h2 id=\"3-打造页面\"><a href=\"#3-打造页面\" class=\"headerlink\" title=\"3 打造页面\"></a>3 打造页面</h2><h3 id=\"3-1-构建UI\"><a href=\"#3-1-构建UI\" class=\"headerlink\" title=\"3.1 构建UI\"></a>3.1 构建UI</h3><p>首先把材料上齐。</p>\n<pre><code class=\"line-numbers language-Swift\">lazy var squareImgView: UIImageView = &#123;\n        let imgv = UIImageView()\n        imgv.isUserInteractionEnabled = false\n        imgv.image = UIImage(named: &quot;扫码框&quot;)\n        return imgv\n    &#125;()\n    \n    lazy var torchButton: UIButton = &#123;\n        let temp = UIButton(type: .custom)\n        temp.setImage(UIImage(named: &quot;scan_torch&quot;), for: .normal)\n        temp.setTitle(&quot;轻触照亮&quot;, for: .normal)\n        temp.isHidden = true\n        temp.titleLabel?.font = UIFont.regular(15)\n        temp.ddy_SetStyle(.imgDown, padding: 10)\n        temp.addTarget(self, action: #selector(torchButtonClick), for: .touchUpInside)\n        return temp\n    &#125;()\n    \n    lazy var photoBtn: UIButton = &#123;\n        let btn = UIButton(type: .custom)\n        btn.setImage(UIImage(named: &quot;PhotoAlbum&quot;), for: .normal)\n        btn.addTarget(self, action: #selector(actionForPhoto), for: .touchUpInside)\n        return btn\n    &#125;()\n    \n    lazy var tipsLabel: UILabel = &#123;\n        let temp = UILabel()\n        temp.text = &quot;扫一扫条形码&quot;\n        temp.textColor = .white\n        temp.font = UIFont.regular(13)\n        temp.sizeToFit()\n        return temp\n    &#125;()\n    \n    lazy var commitButton: UIButton = &#123;\n        let btn: UIButton = UIButton(type: .custom)\n        btn.backgroundColor = UIColor(hex: &quot;#242424&quot;)\n        btn.clipsToBounds = true\n        btn.layer.cornerRadius = 22\n        btn.layer.borderWidth = 1\n        btn.layer.borderColor = UIColor.white.cgColor\n        btn.setTitle(&quot;扫描完成&quot;, for: .normal)\n        btn.addTarget(self, action: #selector(commitButtonClick), for: .touchUpInside)\n        return btn\n    &#125;()\n    \n    lazy var inputButton: UIButton = &#123;\n        let btn: UIButton = UIButton(type: .custom)\n        btn.backgroundColor = UIColor(hex: &quot;#242424&quot;)\n        btn.layer.borderColor = UIColor.white.cgColor\n        btn.setTitle(&quot;手动输入条形码&quot;, for: .normal)\n        btn.addTarget(self, action: #selector(actionForPushManuallyInput), for: .touchUpInside)\n        return btn\n    &#125;()\n\n    lazy var layerView: UIView = &#123;\n        let view = UIView(frame: CGRect(x: 0,\n                                        y: STATUS_BAR_HEIGHT + 44,\n                                        width: ScreenWidth,\n                                        height: ScreenHeight - STATUS_BAR_HEIGHT - 44 - 162))\n        return view\n    &#125;()\n</code></pre>\n<p>打开需要这几个View。</p>\n<h3 id=\"3-2-全局变量声明\"><a href=\"#3-2-全局变量声明\" class=\"headerlink\" title=\"3.2 全局变量声明\"></a>3.2 全局变量声明</h3><p>想要具备扫码能力，有几个类是必须的。</p>\n<pre><code class=\"line-numbers language-Swift\">// AVC 相关  相机硬件接口相关\n    private var videoDataOutput: AVCaptureVideoDataOutput?\n    private var output: AVCaptureMetadataOutput?\n    private var session: AVCaptureSession?\n    private var videoPreviewLayer: AVCaptureVideoPreviewLayer?\n</code></pre>\n<p>其它成员不着急，后续需要再加上去。</p>\n<h3 id=\"3-3-生命周期之loadView\"><a href=\"#3-3-生命周期之loadView\" class=\"headerlink\" title=\"3.3 生命周期之loadView\"></a>3.3 生命周期之loadView</h3><p>loadView执行时机为：访问视图控制器的view时候，如何view为nil，或者还没有加载完成就会调用loadView方法来创建view。可以理解成先于viewDidLoad，一般走一次，一般用于视图初始化。</p>\n<p>这里就负责 添加子View 的工作。</p>\n<pre><code class=\"line-numbers language-Swift\">private func setupUI() &#123;\n        view.addSubview(layerView)\n        view.addSubview(squareImgView)\n        view.addSubview(torchButton)\n        view.addSubview(tipsLabel)\n        view.addSubview(commitButton)\n        view.addSubview(inputButton)\n        view.addSubview(photoBtn)\n\n        squareImgView.snp.makeConstraints &#123; make in\n            make.size.equalTo(320)\n            make.centerX.equalToSuperview()\n            make.top.equalTo(STATUS_BAR_HEIGHT + 44 + 76)\n        &#125;\n        \n        torchButton.snp.makeConstraints &#123; make in\n            make.centerX.equalToSuperview()\n            make.bottom.equalTo(squareImgView.snp.bottom).offset(20)\n            make.width.equalTo(320)\n            make.height.equalTo(200)\n        &#125;\n        \n        tipsLabel.snp.makeConstraints &#123; make in\n            make.centerX.equalToSuperview()\n            make.top.equalTo(squareImgView.snp.bottom).offset(12)\n        &#125;\n        \n        commitButton.snp.makeConstraints &#123; make in\n            make.top.equalTo(layerView.snp.bottom).offset(42)\n            make.leading.equalTo(102)\n            make.trailing.equalTo(-102)\n            make.height.equalTo(44)\n        &#125;\n        \n        inputButton.snp.makeConstraints&#123; make in\n            make.top.equalTo(commitButton.snp.bottom).offset(12)\n            make.left.equalTo(commitButton)\n            make.right.equalTo(commitButton)\n            make.height.equalTo(36)\n        &#125;\n        \n        photoBtn.snp.makeConstraints&#123; make in\n            make.centerY.equalTo(commitButton)\n            make.leading.equalTo(16)\n            make.width.height.equalTo(44)\n        &#125;\n    &#125;\n</code></pre>\n<p>可以看到，这里把架子搭上去了。</p>\n<h3 id=\"3-4-生命周期之-viewDidLoad\"><a href=\"#3-4-生命周期之-viewDidLoad\" class=\"headerlink\" title=\"3.4 生命周期之 viewDidLoad\"></a>3.4 生命周期之 viewDidLoad</h3><p>看下这里做了什么：</p>\n<pre><code class=\"line-numbers language-Swift\"> override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        // 标题文字大小\n        navigationController?.navigationBar.navBarBackGroundColor(.black, image: UIImage(), isOpaque: false)\n        navigationController?.navigationBar.titleTextAttributes = [NSAttributedString.Key.foregroundColor:UIColor.white, NSAttributedString.Key.font : UIFont.pingFangMedium(size: 18)]\n        \n        // 背景黑色\n        view.backgroundColor = UIColor(hex: &quot;#242424&quot;)\n\n        // 添加手势，用来实现二指缩放效果\n        addGesture()\n        \n        // 监听全局通知\n        addNotification()\n        \n        // 自己定义的协议，去加载历史数据\n        delegate?.loadHistoryData()\n        \n        // 手动输入条码闭包回调\n        manuallyInputViewController.inputBlock = &#123; [unowned self] (_, code) in\n            self.delegate?.manuallyInput(code.replaceFlag)\n        &#125;\n    &#125;\n</code></pre>\n<p>如何添加手势呢？</p>\n<pre><code class=\"line-numbers language-Swift\">private func addGesture() &#123;\n        let prinGesture = UIPinchGestureRecognizer(target: self, action: #selector(pinch(gesture:)))\n        layerView.addGestureRecognizer(prinGesture)\n    &#125;\n</code></pre>\n<p>操作后会触发：</p>\n<pre><code class=\"line-numbers language-Swift\">@objc func pinch(gesture: UIPinchGestureRecognizer) &#123;\n        guard let device = AVCaptureDevice.default(for: AVMediaType.video) else &#123;\n            print(&quot;get front video AVCaptureDeviceInput  failed!&quot;)\n            return\n        &#125;\n        var minZoomFactor = 1.0\n        var maxZoomFactor = device.activeFormat.videoMaxZoomFactor\n        \n        if #available(iOS 11.0,*) &#123;\n            minZoomFactor = device.minAvailableVideoZoomFactor\n            maxZoomFactor = device.maxAvailableVideoZoomFactor\n        &#125;\n        \n        if gesture.state == .began &#123;\n            lastZoomFactor = device.videoZoomFactor\n            print(&quot;缩放比例  \\(device.videoZoomFactor)&quot;)\n            \n        &#125; else if gesture.state == .changed&#123;\n            var zoomFactor: Float = Float(lastZoomFactor * gesture.scale);\n            zoomFactor = fmaxf(fminf(zoomFactor, Float(maxZoomFactor)), Float(minZoomFactor))\n            print(&quot;缩放比例  \\(zoomFactor)&quot;)\n            try? device.lockForConfiguration()\n            device.videoZoomFactor = CGFloat(zoomFactor)\n            device.unlockForConfiguration()\n        &#125; else if gesture.state == .ended &#123;\n            print(&quot;最终缩放比例  \\(device.videoZoomFactor)&quot;)\n        &#125;\n    &#125;\n</code></pre>\n<p>其它的没啥了。</p>\n<h3 id=\"3-5-生命周期之viewWillAppear\"><a href=\"#3-5-生命周期之viewWillAppear\" class=\"headerlink\" title=\"3.5 生命周期之viewWillAppear\"></a>3.5 生命周期之viewWillAppear</h3><p>这个是将要显示，一般做轻量级操作。</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewWillAppear(_ animated: Bool) &#123;\n        super.viewWillAppear(animated)\n        setupRealWhiteClickCallBack()\n        setupBlackNavWhiteTitleBarColor()\n        isHiddenNavBar(isHidden: false)\n    &#125;\n</code></pre>\n<p>主要实现了状态栏和标题栏相关的。</p>\n<h3 id=\"3-6-生命周期之viewDidAppear\"><a href=\"#3-6-生命周期之viewDidAppear\" class=\"headerlink\" title=\"3.6 生命周期之viewDidAppear\"></a>3.6 生命周期之viewDidAppear</h3><p>这里是已经显示了，这里可以做稍微重量级代码。</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidAppear(_ animated: Bool) &#123;\n        super.viewDidAppear(animated)\n        if self.session == nil &#123;\n            self.scanQRCodePermission()\n        &#125; else &#123;\n            self.startScan()\n        &#125;\n        UIApplication.shared.isIdleTimerDisabled = true\n        setNeedsStatusBarAppearanceUpdate()\n    &#125;\n</code></pre>\n<p>很明显这里判断了下session是否为null。</p>\n<p>如果session为nil，则先判断是否有相机权限：</p>\n<pre><code class=\"line-numbers language-Swift\">func scanQRCodePermission() &#123;\n        // 判断摄像头是否可用\n        let available = UIImagePickerController.isSourceTypeAvailable(.camera)\n        if available &#123;\n            \n            // 判断是否有相机权限\n            let authStatus: AVAuthorizationStatus = AVCaptureDevice.authorizationStatus(for: AVMediaType.video)\n            if authStatus == .restricted &#123;\n                let alerVC: UIAlertController = .init(title: &quot;提示&quot;, message: &quot;由于系统原因, 无法访问相机&quot;, preferredStyle: UIAlertController.Style.alert)\n                alerVC.addAction(UIAlertAction.init(title: &quot;确定&quot;, style: .destructive) &#123; (action) in\n                    UIApplication.shared.open(NSURL(string: UIApplication.openSettingsURLString)! as URL, options: [:] ) &#123; (success) in\n                    &#125;\n                &#125;)\n                present(alerVC, animated: true, completion: nil)\n            &#125; else if authStatus == .denied &#123;\n                let dic = Bundle.main.infoDictionary\n                var appName = dic?[&quot;CFBundleDisplayName&quot;]\n                if appName == nil&#123;\n                    appName = dic?[&quot;CFBundleName&quot;]\n                &#125;\n                let str = String.localizedStringWithFormat(&quot;[前往：设置 - 隐私 - 相机 - %@] 允许应用访问&quot;, appName as! String)\n                let alerVC = UIAlertController(title: &quot;提示&quot;, message: str, preferredStyle: .alert)\n                alerVC.addAction(UIAlertAction(title: &quot;确定&quot;, style: UIAlertAction.Style.destructive) &#123; (action) in\n                    UIApplication.shared.open(NSURL(string: UIApplication.openSettingsURLString)! as URL, options: [:] ) &#123; (success) in\n                    &#125;\n                &#125;)\n                present(alerVC, animated: true, completion: nil)\n            &#125; else if authStatus == .notDetermined &#123;\n                //用户未作出选择，申请权限 AVC直接requestAccess\n                AVCaptureDevice.requestAccess(for: AVMediaType.video)&#123;\n                    granted in\n                    DispatchQueue.main.async &#123;\n                        if granted &#123;\n                            //初次授权成功\n                            self.initCaptureSession()\n                        &#125; else &#123;\n                            //拒绝授权\n                        &#125;\n                    &#125;\n                &#125;\n            &#125; else &#123;\n                //已授权\n                self.initCaptureSession()\n            &#125;\n        &#125; else &#123;\n            //摄像头可能已损坏\n        &#125;\n    &#125;\n</code></pre>\n<p>上面的代码讲述了如何申请权限，权限被拒绝如何跳转设置。</p>\n<p>如果有权限了会走 initCaptureSession 来初始化session:</p>\n<pre><code class=\"line-numbers language-Swift\">func initCaptureSession() &#123;\n        //创建会话对象\n        let `session` = AVCaptureSession()\n        self.session = session\n        session.sessionPreset = .high\n        \n        //获取设想设备\n        guard let device = AVCaptureDevice.default(for: AVMediaType.video) else &#123;\n            print(&quot;get front video AVCaptureDeviceInput  failed!&quot;)\n            return\n        &#125;\n        \n        //创建设想设备输入流\n        guard let input = try? AVCaptureDeviceInput(device: device) else &#123;\n            print(&quot;get front video AVCaptureDeviceInput  failed!&quot;)\n            return\n        &#125;\n        \n        //添加设想设备输入流到会话对象 输入流让session来分析\n        if session.canAddInput(input) &#123;\n            session.addInput(input)\n        &#125;\n        \n        //创建元数据输出流\n        let `output` = AVCaptureMetadataOutput()\n        self.output = output\n        output.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)\n                \n        //添加元数据输出流到会话对象 给新建的一个Output对象添加到session,session等下会给output赋值\n        session.addOutput(output)\n        \n        //创建摄像数据输出流并将其添加到会话对象上-----&gt;用户识别光线强弱\n        let `videoDataOutput` = AVCaptureVideoDataOutput()\n        self.videoDataOutput = videoDataOutput\n        videoDataOutput.setSampleBufferDelegate(self, queue: DispatchQueue.main)\n        session.addOutput(videoDataOutput)\n        \n        //设置数据输出类型(如下设置为条形码和二维码兼容)，需要将数据输出添加到会话后，才能指定元数据类型，否则会报错\n        \n        /*\n         \n         android\n         \n         Barcode.FORMAT_CODE_128,   *\n         Barcode.FORMAT_CODE_39,    *\n         Barcode.FORMAT_CODE_93,    *\n         Barcode.FORMAT_CODABAR,    ios 15.4 +\n         Barcode.FORMAT_EAN_13,     *\n         Barcode.FORMAT_EAN_8,      *\n         Barcode.FORMAT_UPC_A,      x\n         Barcode.FORMAT_UPC_E,      *\n         Barcode.TYPE_ISBN          x\n         */\n        output.metadataObjectTypes = [.code39,\n                                      .code39Mod43,\n                                      .code93,\n                                      .code128,\n                                      .ean8,\n                                      .ean13,\n                                      .upce,\n                                      .pdf417] //itf14\n        //实例化预览图层, 用于显示会话对象 session放到这里面，然后通过layer插入sublayer可以实现预览效果\n        let `videoPreviewLayer` = AVCaptureVideoPreviewLayer(session: session)\n        self.videoPreviewLayer = videoPreviewLayer\n        videoPreviewLayer.videoGravity = .resizeAspectFill\n        videoPreviewLayer.frame = layerView.bounds\n        layerView.layer.insertSublayer(videoPreviewLayer, at: 0)\n        \n        // session开始run\n        startScan()\n    &#125;\n</code></pre>\n<p>回到 生命周期 中，如果 session 不为空，会走上面的startScan 函数，这里就是让session继续工作的意思：</p>\n<pre><code class=\"line-numbers language-Swift\">func startScan() &#123;\n        session?.startRunning()\n    &#125;\n</code></pre>\n<p>在viewDidAppear中还做了什么呢？</p>\n<pre><code class=\"line-numbers language-Swift\">UIApplication.shared.isIdleTimerDisabled = true\nsetNeedsStatusBarAppearanceUpdate()\n</code></pre>\n<p>第一行：禁止该页面进入睡眠；<br>第二行：如果在viewController已经显示在当前页面，你可能还要在当前页面不时的更改statusBar的前景色，那么，你首先需要调用下面的setNeedsStatusBarAppearanceUpdate方法(这个方法会通知系统去调用当前UIViewController的preferredStatusBarStyle方法)，从而改变statusBar的statusBarStyle。</p>\n<h3 id=\"3-7-生命周期之viewDidDisappear\"><a href=\"#3-7-生命周期之viewDidDisappear\" class=\"headerlink\" title=\"3.7 生命周期之viewDidDisappear\"></a>3.7 生命周期之viewDidDisappear</h3><pre><code class=\"line-numbers language-Swift\"> override func viewDidDisappear(_ animated: Bool) &#123;\n        super.viewDidDisappear(animated)\n        stopScan()\n        UIApplication.shared.isIdleTimerDisabled = false\n        setNeedsStatusBarAppearanceUpdate()\n    &#125;\n</code></pre>\n<p>这里停止扫描，应该是停止session:</p>\n<pre><code class=\"line-numbers language-Swift\">func stopScan() &#123;\n        session?.stopRunning()\n    &#125;\n</code></pre>\n<p>其它上面讲过，不必多言了。</p>\n<h3 id=\"3-8-设置output代理\"><a href=\"#3-8-设置output代理\" class=\"headerlink\" title=\"3.8 设置output代理\"></a>3.8 设置output代理</h3><p>回到初始化session的部分代码中：</p>\n<pre><code class=\"line-numbers language-Swift\">//创建元数据输出流\nlet `output` = AVCaptureMetadataOutput()\nself.output = output\noutput.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)\n</code></pre>\n<p>这里设置了一个metadata的代理，所以这个controller必然扩展了这个代理。</p>\n<p>具体如下：</p>\n<pre><code class=\"line-numbers language-Swift\">extension GMBaseScanViewController: AVCaptureMetadataOutputObjectsDelegate &#123;\n    func metadataOutput(_ output: AVCaptureMetadataOutput, didOutput metadataObjects: [AVMetadataObject], from connection: AVCaptureConnection) &#123;\n        if isCanScan &#123;\n            let isAchieve: Bool = metadataObjects.count == 1\n            if isAchieve &#123;\n                // 扫到条码\n                guard let device = AVCaptureDevice.default(for: AVMediaType.video) else &#123; return &#125;\n                guard let codeObj = metadataObjects.last as? AVMetadataMachineReadableCodeObject else &#123; return &#125;\n                print(&quot;扫到了条码 codeObj  ：  \\(codeObj)&quot;)\n                guard let str = codeObj.stringValue else &#123; return &#125;\n                self.isCanScan = false\n                print(&quot;扫到了条码 str：  \\(str)&quot;)\n                DispatchQueue.main.asyncAfter(deadline: .now() + scanInterval) &#123;\n                    try? device.lockForConfiguration()\n                    device.videoZoomFactor = 1\n                    device.unlockForConfiguration()\n                    self.isCanScan = true\n                &#125;\n                let barCode = barcodeProcessing(str)\n                delegate?.scanBarcode(barCode)\n            &#125; else &#123;\n                MBProgressHUD.showTipsMessage(&quot;无法识别&quot;)\n            &#125;\n        &#125;\n    &#125;\n    \n    func barcodeProcessing(_ code: String) -&gt; String &#123;\n        var codeStr: String = code.mutableCopy() as! String\n        var newStr = code.uppercased()\n        var index = 0\n        newStr = newStr.replacingOccurrences(of: &quot; &quot;, with: &quot;&quot;, options: .literal, range: nil)\n        codeStr = codeStr.replacingOccurrences(of: &quot; &quot;, with: &quot;&quot;, options: .literal, range: nil)\n        if newStr.hasPrefix(&quot;GREE&quot;) &#123;\n            index = 3\n        &#125; else if newStr.hasPrefix(&quot;KINGHOME&quot;) &#123;\n            index = 7\n        &#125; else if newStr.hasPrefix(&quot;TOSOT&quot;) &#123;\n            index = 4\n        &#125;\n        if index != 0 &#123;\n            let start = codeStr.index(codeStr.startIndex, offsetBy: 0)\n            let end = codeStr.index(codeStr.startIndex, offsetBy: index)\n            codeStr.removeSubrange(start...end)\n        &#125;\n        return codeStr\n    &#125;\n&#125;\n</code></pre>\n<p>这里覆写了这协议方法，表示识别到内容了。然后会回调metadateOutput，原因是前面session里面设置了Output的代理为self,也就是这里，这里就关联起来了。<br>前面是这样的：</p>\n<pre><code class=\"line-numbers language-Swift\"> let `output` = AVCaptureMetadataOutput()\n        self.output = output\n        output.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)\n                \n        //添加元数据输出流到会话对象 给新建的一个Output对象添加到session,session等下会给output赋值\n        session.addOutput(output)\n</code></pre>\n<p>就是因为这个self，当session开始running后，就会走协议的回调方法，在那里面我们间隔3.5才让它进行下次扫描，也是在这里面分析这个条码是否正常之类的。</p>\n<h3 id=\"3-9-设置videoDataOuput代理\"><a href=\"#3-9-设置videoDataOuput代理\" class=\"headerlink\" title=\"3.9 设置videoDataOuput代理\"></a>3.9 设置videoDataOuput代理</h3><p>这个代理，目的是为了识别光线强弱。</p>\n<pre><code class=\"line-numbers language-Swift\">extension GMBaseScanViewController: AVCaptureVideoDataOutputSampleBufferDelegate &#123;\n    \n    func captureOutput(_ output: AVCaptureOutput, didOutput sampleBuffer: CMSampleBuffer, from connection: AVCaptureConnection) &#123;\n        // 获取光照亮度\n        guard let metadataCFDict: CFDictionary = CMCopyDictionaryOfAttachments(allocator: nil, target: sampleBuffer, attachmentMode: 1) else &#123; return &#125;\n        guard let metadataDic: [String: AnyObject] = metadataCFDict as? [String: AnyObject] else &#123; return &#125;\n        guard let exifMetadata: [String: AnyObject] = metadataDic[kCGImagePropertyExifDictionary as String] as? [String : AnyObject] else &#123; return &#125;\n        guard let brightnessValue: CGFloat = exifMetadata[kCGImagePropertyExifBrightnessValue as String] as? CGFloat else &#123; return &#125;\n        // 根据光照亮度展示按钮\n        if brightnessValue &lt; -1 &#123;\n            torchButton.isHidden = false\n        &#125; else &#123;\n            guard let device = AVCaptureDevice.default(for: AVMediaType.video) else &#123; return &#125;\n            if device.hasTorch &amp;&amp; device.isTorchAvailable &#123;\n                try? device.lockForConfiguration()\n                torchButton.isHidden = !(device.torchMode == .on)\n                device.unlockForConfiguration()\n                \n            &#125;\n        &#125;\n        \n    &#125;\n    \n    private func convert(cmage: CIImage) -&gt; UIImage &#123;\n         let context = CIContext(options: nil)\n         let cgImage = context.createCGImage(cmage, from: cmage.extent)!\n         let image = UIImage(cgImage: cgImage)\n         return image\n    &#125;\n    \n&#125;\n</code></pre>\n<p>在代理 captureOutput的回调方法中可以获取光线强弱信息。</p>\n<p>也是在初始化session的时候设置了这个代理。</p>\n<h3 id=\"3-10-识别到后播放声音\"><a href=\"#3-10-识别到后播放声音\" class=\"headerlink\" title=\"3.10 识别到后播放声音\"></a>3.10 识别到后播放声音</h3><p>这里我们额外增加一个方法，主要给外面调用，因为我们会提供一个代理，如果识别到后，通过代理内部方法将识别的条码给外面。这时候外面要震动或声音效果，只需要调用我们内部的一个方法即可。</p>\n<pre><code class=\"line-numbers language-Swift\">func playAudio(success code: Int) &#123;\n        if isPlay == false &#123;\n            return\n        &#125;\n        if code == 1 &#123;\n            var soundID: SystemSoundID = 0\n            guard let path = Bundle.main.path(forResource: &quot;scanSuccess&quot;, ofType: &quot;mp3&quot;) else &#123; return &#125;\n            let url = URL(fileURLWithPath: path)\n            AudioServicesCreateSystemSoundID(url as CFURL, &amp;soundID)\n            AudioServicesPlaySystemSound(soundID) //声音\n        &#125; else &#123;\n            var soundID: SystemSoundID = 0\n            guard let path = Bundle.main.path(forResource: &quot;scanFail&quot;, ofType: &quot;mp3&quot;) else &#123; return &#125;\n            let url = URL(fileURLWithPath: path)\n            AudioServicesCreateSystemSoundID(url as CFURL, &amp;soundID)\n            AudioServicesPlayAlertSound(soundID) //震动+播放声音\n        &#125;\n    &#125;\n</code></pre>\n<p>也是非常简单，只需要先拿到声音路径，转换url，再通过AudioServicesCreateSystemSoundID包装一下，再通过AudioServicesPlaySystemSound来播放这个soundID即可。</p>\n<p>就这样，一个具有扫码能力的Controller就出来了哦。</p>\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4 总结\"></a>4 总结</h2><ul>\n<li><p>如果用到扫码，一定需要申请权限的，必须考虑到是否有权限，如果拒绝了权限，或其它原因导致没有权限，都需要考虑。</p>\n</li>\n<li><p>扫码关键的几个类，AVCaptureSession控制数据流关键类；AVCaptureMetadataOutput接收流，代理方法来处理识别到条码后的逻辑；AVCaptureVideoDataOutput接收流，可以处理光线强弱；AVCaptureVideoPreviewLayer用来预览相机的视图层，可显示在UIView的layer上。</p>\n</li>\n<li><p>一般扫码需要具备的二指缩放，光线太暗打开闪光灯，这些可以算作基本能能力，务必要实现，否则体验很不佳。</p>\n</li>\n<li><p>合理控制识别到条码间隔时间，该停止session的时候务必停止，为了防止频繁识别到相同条码，可以设置间隔时间。</p>\n</li>\n<li><p>可以先定义一个播放声音效果的方法，方便外部直接调用方法播放成功或者失败的声音。声音主要用到AudioServices相关方法。</p>\n</li>\n<li><p>系统类大多都是提供了代理，暴露了一些方法主要都是定义好的方法，我们业务开发也只需要接收和处理这些定义好的类就可以了。</p>\n</li>\n</ul>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-需求定义\"><a href=\"#1-需求定义\" class=\"headerlink\" title=\"1 需求定义\"></a>1 需求定义</h2><p>这里有个需求，就是继承扫码能力，可以识别到条形码里面的内容。<br>首先我们需要下载一个离线库，这个库里面会包含很多条码Code，相机通过识别到条码跟离线库中的匹配，如果匹配上了，会提示用户。所以首先我们肯定要有一个识别能力，数据库先不管，后面会有专门的文章来写数据库相关的东西。</p>\n<p>本篇文章主要是从0搭建一个可以识别条形码能力的Controller。<br>其它额外需求先忽略。</p>\n<p>目标就是完成这样的效果：<br><img src=scan1.png><br><img src=scan2.png></p>\n<h2 id=\"2-分析需求\"><a href=\"#2-分析需求\" class=\"headerlink\" title=\"2 分析需求\"></a>2 分析需求</h2><p>要具备扫码功能，肯定离不开相机，调用相机会设计到权限。<br>所以我们得考虑是否有相机权限。<br>其次，得考虑如何来识别条形码。<br>重复识别到的问题。<br>页面退出，相机资源怎么处理。<br>光线太暗了，是否需要打开手电筒。<br>条码太小，是否需要放大。<br>等等，这些事先都得考虑到。</p>\n<h2 id=\"3-打造页面\"><a href=\"#3-打造页面\" class=\"headerlink\" title=\"3 打造页面\"></a>3 打造页面</h2><h3 id=\"3-1-构建UI\"><a href=\"#3-1-构建UI\" class=\"headerlink\" title=\"3.1 构建UI\"></a>3.1 构建UI</h3><p>首先把材料上齐。</p>\n<pre><code class=\"line-numbers language-Swift\">lazy var squareImgView: UIImageView = &#123;\n        let imgv = UIImageView()\n        imgv.isUserInteractionEnabled = false\n        imgv.image = UIImage(named: &quot;扫码框&quot;)\n        return imgv\n    &#125;()\n    \n    lazy var torchButton: UIButton = &#123;\n        let temp = UIButton(type: .custom)\n        temp.setImage(UIImage(named: &quot;scan_torch&quot;), for: .normal)\n        temp.setTitle(&quot;轻触照亮&quot;, for: .normal)\n        temp.isHidden = true\n        temp.titleLabel?.font = UIFont.regular(15)\n        temp.ddy_SetStyle(.imgDown, padding: 10)\n        temp.addTarget(self, action: #selector(torchButtonClick), for: .touchUpInside)\n        return temp\n    &#125;()\n    \n    lazy var photoBtn: UIButton = &#123;\n        let btn = UIButton(type: .custom)\n        btn.setImage(UIImage(named: &quot;PhotoAlbum&quot;), for: .normal)\n        btn.addTarget(self, action: #selector(actionForPhoto), for: .touchUpInside)\n        return btn\n    &#125;()\n    \n    lazy var tipsLabel: UILabel = &#123;\n        let temp = UILabel()\n        temp.text = &quot;扫一扫条形码&quot;\n        temp.textColor = .white\n        temp.font = UIFont.regular(13)\n        temp.sizeToFit()\n        return temp\n    &#125;()\n    \n    lazy var commitButton: UIButton = &#123;\n        let btn: UIButton = UIButton(type: .custom)\n        btn.backgroundColor = UIColor(hex: &quot;#242424&quot;)\n        btn.clipsToBounds = true\n        btn.layer.cornerRadius = 22\n        btn.layer.borderWidth = 1\n        btn.layer.borderColor = UIColor.white.cgColor\n        btn.setTitle(&quot;扫描完成&quot;, for: .normal)\n        btn.addTarget(self, action: #selector(commitButtonClick), for: .touchUpInside)\n        return btn\n    &#125;()\n    \n    lazy var inputButton: UIButton = &#123;\n        let btn: UIButton = UIButton(type: .custom)\n        btn.backgroundColor = UIColor(hex: &quot;#242424&quot;)\n        btn.layer.borderColor = UIColor.white.cgColor\n        btn.setTitle(&quot;手动输入条形码&quot;, for: .normal)\n        btn.addTarget(self, action: #selector(actionForPushManuallyInput), for: .touchUpInside)\n        return btn\n    &#125;()\n\n    lazy var layerView: UIView = &#123;\n        let view = UIView(frame: CGRect(x: 0,\n                                        y: STATUS_BAR_HEIGHT + 44,\n                                        width: ScreenWidth,\n                                        height: ScreenHeight - STATUS_BAR_HEIGHT - 44 - 162))\n        return view\n    &#125;()\n</code></pre>\n<p>打开需要这几个View。</p>\n<h3 id=\"3-2-全局变量声明\"><a href=\"#3-2-全局变量声明\" class=\"headerlink\" title=\"3.2 全局变量声明\"></a>3.2 全局变量声明</h3><p>想要具备扫码能力，有几个类是必须的。</p>\n<pre><code class=\"line-numbers language-Swift\">// AVC 相关  相机硬件接口相关\n    private var videoDataOutput: AVCaptureVideoDataOutput?\n    private var output: AVCaptureMetadataOutput?\n    private var session: AVCaptureSession?\n    private var videoPreviewLayer: AVCaptureVideoPreviewLayer?\n</code></pre>\n<p>其它成员不着急，后续需要再加上去。</p>\n<h3 id=\"3-3-生命周期之loadView\"><a href=\"#3-3-生命周期之loadView\" class=\"headerlink\" title=\"3.3 生命周期之loadView\"></a>3.3 生命周期之loadView</h3><p>loadView执行时机为：访问视图控制器的view时候，如何view为nil，或者还没有加载完成就会调用loadView方法来创建view。可以理解成先于viewDidLoad，一般走一次，一般用于视图初始化。</p>\n<p>这里就负责 添加子View 的工作。</p>\n<pre><code class=\"line-numbers language-Swift\">private func setupUI() &#123;\n        view.addSubview(layerView)\n        view.addSubview(squareImgView)\n        view.addSubview(torchButton)\n        view.addSubview(tipsLabel)\n        view.addSubview(commitButton)\n        view.addSubview(inputButton)\n        view.addSubview(photoBtn)\n\n        squareImgView.snp.makeConstraints &#123; make in\n            make.size.equalTo(320)\n            make.centerX.equalToSuperview()\n            make.top.equalTo(STATUS_BAR_HEIGHT + 44 + 76)\n        &#125;\n        \n        torchButton.snp.makeConstraints &#123; make in\n            make.centerX.equalToSuperview()\n            make.bottom.equalTo(squareImgView.snp.bottom).offset(20)\n            make.width.equalTo(320)\n            make.height.equalTo(200)\n        &#125;\n        \n        tipsLabel.snp.makeConstraints &#123; make in\n            make.centerX.equalToSuperview()\n            make.top.equalTo(squareImgView.snp.bottom).offset(12)\n        &#125;\n        \n        commitButton.snp.makeConstraints &#123; make in\n            make.top.equalTo(layerView.snp.bottom).offset(42)\n            make.leading.equalTo(102)\n            make.trailing.equalTo(-102)\n            make.height.equalTo(44)\n        &#125;\n        \n        inputButton.snp.makeConstraints&#123; make in\n            make.top.equalTo(commitButton.snp.bottom).offset(12)\n            make.left.equalTo(commitButton)\n            make.right.equalTo(commitButton)\n            make.height.equalTo(36)\n        &#125;\n        \n        photoBtn.snp.makeConstraints&#123; make in\n            make.centerY.equalTo(commitButton)\n            make.leading.equalTo(16)\n            make.width.height.equalTo(44)\n        &#125;\n    &#125;\n</code></pre>\n<p>可以看到，这里把架子搭上去了。</p>\n<h3 id=\"3-4-生命周期之-viewDidLoad\"><a href=\"#3-4-生命周期之-viewDidLoad\" class=\"headerlink\" title=\"3.4 生命周期之 viewDidLoad\"></a>3.4 生命周期之 viewDidLoad</h3><p>看下这里做了什么：</p>\n<pre><code class=\"line-numbers language-Swift\"> override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        // 标题文字大小\n        navigationController?.navigationBar.navBarBackGroundColor(.black, image: UIImage(), isOpaque: false)\n        navigationController?.navigationBar.titleTextAttributes = [NSAttributedString.Key.foregroundColor:UIColor.white, NSAttributedString.Key.font : UIFont.pingFangMedium(size: 18)]\n        \n        // 背景黑色\n        view.backgroundColor = UIColor(hex: &quot;#242424&quot;)\n\n        // 添加手势，用来实现二指缩放效果\n        addGesture()\n        \n        // 监听全局通知\n        addNotification()\n        \n        // 自己定义的协议，去加载历史数据\n        delegate?.loadHistoryData()\n        \n        // 手动输入条码闭包回调\n        manuallyInputViewController.inputBlock = &#123; [unowned self] (_, code) in\n            self.delegate?.manuallyInput(code.replaceFlag)\n        &#125;\n    &#125;\n</code></pre>\n<p>如何添加手势呢？</p>\n<pre><code class=\"line-numbers language-Swift\">private func addGesture() &#123;\n        let prinGesture = UIPinchGestureRecognizer(target: self, action: #selector(pinch(gesture:)))\n        layerView.addGestureRecognizer(prinGesture)\n    &#125;\n</code></pre>\n<p>操作后会触发：</p>\n<pre><code class=\"line-numbers language-Swift\">@objc func pinch(gesture: UIPinchGestureRecognizer) &#123;\n        guard let device = AVCaptureDevice.default(for: AVMediaType.video) else &#123;\n            print(&quot;get front video AVCaptureDeviceInput  failed!&quot;)\n            return\n        &#125;\n        var minZoomFactor = 1.0\n        var maxZoomFactor = device.activeFormat.videoMaxZoomFactor\n        \n        if #available(iOS 11.0,*) &#123;\n            minZoomFactor = device.minAvailableVideoZoomFactor\n            maxZoomFactor = device.maxAvailableVideoZoomFactor\n        &#125;\n        \n        if gesture.state == .began &#123;\n            lastZoomFactor = device.videoZoomFactor\n            print(&quot;缩放比例  \\(device.videoZoomFactor)&quot;)\n            \n        &#125; else if gesture.state == .changed&#123;\n            var zoomFactor: Float = Float(lastZoomFactor * gesture.scale);\n            zoomFactor = fmaxf(fminf(zoomFactor, Float(maxZoomFactor)), Float(minZoomFactor))\n            print(&quot;缩放比例  \\(zoomFactor)&quot;)\n            try? device.lockForConfiguration()\n            device.videoZoomFactor = CGFloat(zoomFactor)\n            device.unlockForConfiguration()\n        &#125; else if gesture.state == .ended &#123;\n            print(&quot;最终缩放比例  \\(device.videoZoomFactor)&quot;)\n        &#125;\n    &#125;\n</code></pre>\n<p>其它的没啥了。</p>\n<h3 id=\"3-5-生命周期之viewWillAppear\"><a href=\"#3-5-生命周期之viewWillAppear\" class=\"headerlink\" title=\"3.5 生命周期之viewWillAppear\"></a>3.5 生命周期之viewWillAppear</h3><p>这个是将要显示，一般做轻量级操作。</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewWillAppear(_ animated: Bool) &#123;\n        super.viewWillAppear(animated)\n        setupRealWhiteClickCallBack()\n        setupBlackNavWhiteTitleBarColor()\n        isHiddenNavBar(isHidden: false)\n    &#125;\n</code></pre>\n<p>主要实现了状态栏和标题栏相关的。</p>\n<h3 id=\"3-6-生命周期之viewDidAppear\"><a href=\"#3-6-生命周期之viewDidAppear\" class=\"headerlink\" title=\"3.6 生命周期之viewDidAppear\"></a>3.6 生命周期之viewDidAppear</h3><p>这里是已经显示了，这里可以做稍微重量级代码。</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidAppear(_ animated: Bool) &#123;\n        super.viewDidAppear(animated)\n        if self.session == nil &#123;\n            self.scanQRCodePermission()\n        &#125; else &#123;\n            self.startScan()\n        &#125;\n        UIApplication.shared.isIdleTimerDisabled = true\n        setNeedsStatusBarAppearanceUpdate()\n    &#125;\n</code></pre>\n<p>很明显这里判断了下session是否为null。</p>\n<p>如果session为nil，则先判断是否有相机权限：</p>\n<pre><code class=\"line-numbers language-Swift\">func scanQRCodePermission() &#123;\n        // 判断摄像头是否可用\n        let available = UIImagePickerController.isSourceTypeAvailable(.camera)\n        if available &#123;\n            \n            // 判断是否有相机权限\n            let authStatus: AVAuthorizationStatus = AVCaptureDevice.authorizationStatus(for: AVMediaType.video)\n            if authStatus == .restricted &#123;\n                let alerVC: UIAlertController = .init(title: &quot;提示&quot;, message: &quot;由于系统原因, 无法访问相机&quot;, preferredStyle: UIAlertController.Style.alert)\n                alerVC.addAction(UIAlertAction.init(title: &quot;确定&quot;, style: .destructive) &#123; (action) in\n                    UIApplication.shared.open(NSURL(string: UIApplication.openSettingsURLString)! as URL, options: [:] ) &#123; (success) in\n                    &#125;\n                &#125;)\n                present(alerVC, animated: true, completion: nil)\n            &#125; else if authStatus == .denied &#123;\n                let dic = Bundle.main.infoDictionary\n                var appName = dic?[&quot;CFBundleDisplayName&quot;]\n                if appName == nil&#123;\n                    appName = dic?[&quot;CFBundleName&quot;]\n                &#125;\n                let str = String.localizedStringWithFormat(&quot;[前往：设置 - 隐私 - 相机 - %@] 允许应用访问&quot;, appName as! String)\n                let alerVC = UIAlertController(title: &quot;提示&quot;, message: str, preferredStyle: .alert)\n                alerVC.addAction(UIAlertAction(title: &quot;确定&quot;, style: UIAlertAction.Style.destructive) &#123; (action) in\n                    UIApplication.shared.open(NSURL(string: UIApplication.openSettingsURLString)! as URL, options: [:] ) &#123; (success) in\n                    &#125;\n                &#125;)\n                present(alerVC, animated: true, completion: nil)\n            &#125; else if authStatus == .notDetermined &#123;\n                //用户未作出选择，申请权限 AVC直接requestAccess\n                AVCaptureDevice.requestAccess(for: AVMediaType.video)&#123;\n                    granted in\n                    DispatchQueue.main.async &#123;\n                        if granted &#123;\n                            //初次授权成功\n                            self.initCaptureSession()\n                        &#125; else &#123;\n                            //拒绝授权\n                        &#125;\n                    &#125;\n                &#125;\n            &#125; else &#123;\n                //已授权\n                self.initCaptureSession()\n            &#125;\n        &#125; else &#123;\n            //摄像头可能已损坏\n        &#125;\n    &#125;\n</code></pre>\n<p>上面的代码讲述了如何申请权限，权限被拒绝如何跳转设置。</p>\n<p>如果有权限了会走 initCaptureSession 来初始化session:</p>\n<pre><code class=\"line-numbers language-Swift\">func initCaptureSession() &#123;\n        //创建会话对象\n        let `session` = AVCaptureSession()\n        self.session = session\n        session.sessionPreset = .high\n        \n        //获取设想设备\n        guard let device = AVCaptureDevice.default(for: AVMediaType.video) else &#123;\n            print(&quot;get front video AVCaptureDeviceInput  failed!&quot;)\n            return\n        &#125;\n        \n        //创建设想设备输入流\n        guard let input = try? AVCaptureDeviceInput(device: device) else &#123;\n            print(&quot;get front video AVCaptureDeviceInput  failed!&quot;)\n            return\n        &#125;\n        \n        //添加设想设备输入流到会话对象 输入流让session来分析\n        if session.canAddInput(input) &#123;\n            session.addInput(input)\n        &#125;\n        \n        //创建元数据输出流\n        let `output` = AVCaptureMetadataOutput()\n        self.output = output\n        output.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)\n                \n        //添加元数据输出流到会话对象 给新建的一个Output对象添加到session,session等下会给output赋值\n        session.addOutput(output)\n        \n        //创建摄像数据输出流并将其添加到会话对象上-----&gt;用户识别光线强弱\n        let `videoDataOutput` = AVCaptureVideoDataOutput()\n        self.videoDataOutput = videoDataOutput\n        videoDataOutput.setSampleBufferDelegate(self, queue: DispatchQueue.main)\n        session.addOutput(videoDataOutput)\n        \n        //设置数据输出类型(如下设置为条形码和二维码兼容)，需要将数据输出添加到会话后，才能指定元数据类型，否则会报错\n        \n        /*\n         \n         android\n         \n         Barcode.FORMAT_CODE_128,   *\n         Barcode.FORMAT_CODE_39,    *\n         Barcode.FORMAT_CODE_93,    *\n         Barcode.FORMAT_CODABAR,    ios 15.4 +\n         Barcode.FORMAT_EAN_13,     *\n         Barcode.FORMAT_EAN_8,      *\n         Barcode.FORMAT_UPC_A,      x\n         Barcode.FORMAT_UPC_E,      *\n         Barcode.TYPE_ISBN          x\n         */\n        output.metadataObjectTypes = [.code39,\n                                      .code39Mod43,\n                                      .code93,\n                                      .code128,\n                                      .ean8,\n                                      .ean13,\n                                      .upce,\n                                      .pdf417] //itf14\n        //实例化预览图层, 用于显示会话对象 session放到这里面，然后通过layer插入sublayer可以实现预览效果\n        let `videoPreviewLayer` = AVCaptureVideoPreviewLayer(session: session)\n        self.videoPreviewLayer = videoPreviewLayer\n        videoPreviewLayer.videoGravity = .resizeAspectFill\n        videoPreviewLayer.frame = layerView.bounds\n        layerView.layer.insertSublayer(videoPreviewLayer, at: 0)\n        \n        // session开始run\n        startScan()\n    &#125;\n</code></pre>\n<p>回到 生命周期 中，如果 session 不为空，会走上面的startScan 函数，这里就是让session继续工作的意思：</p>\n<pre><code class=\"line-numbers language-Swift\">func startScan() &#123;\n        session?.startRunning()\n    &#125;\n</code></pre>\n<p>在viewDidAppear中还做了什么呢？</p>\n<pre><code class=\"line-numbers language-Swift\">UIApplication.shared.isIdleTimerDisabled = true\nsetNeedsStatusBarAppearanceUpdate()\n</code></pre>\n<p>第一行：禁止该页面进入睡眠；<br>第二行：如果在viewController已经显示在当前页面，你可能还要在当前页面不时的更改statusBar的前景色，那么，你首先需要调用下面的setNeedsStatusBarAppearanceUpdate方法(这个方法会通知系统去调用当前UIViewController的preferredStatusBarStyle方法)，从而改变statusBar的statusBarStyle。</p>\n<h3 id=\"3-7-生命周期之viewDidDisappear\"><a href=\"#3-7-生命周期之viewDidDisappear\" class=\"headerlink\" title=\"3.7 生命周期之viewDidDisappear\"></a>3.7 生命周期之viewDidDisappear</h3><pre><code class=\"line-numbers language-Swift\"> override func viewDidDisappear(_ animated: Bool) &#123;\n        super.viewDidDisappear(animated)\n        stopScan()\n        UIApplication.shared.isIdleTimerDisabled = false\n        setNeedsStatusBarAppearanceUpdate()\n    &#125;\n</code></pre>\n<p>这里停止扫描，应该是停止session:</p>\n<pre><code class=\"line-numbers language-Swift\">func stopScan() &#123;\n        session?.stopRunning()\n    &#125;\n</code></pre>\n<p>其它上面讲过，不必多言了。</p>\n<h3 id=\"3-8-设置output代理\"><a href=\"#3-8-设置output代理\" class=\"headerlink\" title=\"3.8 设置output代理\"></a>3.8 设置output代理</h3><p>回到初始化session的部分代码中：</p>\n<pre><code class=\"line-numbers language-Swift\">//创建元数据输出流\nlet `output` = AVCaptureMetadataOutput()\nself.output = output\noutput.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)\n</code></pre>\n<p>这里设置了一个metadata的代理，所以这个controller必然扩展了这个代理。</p>\n<p>具体如下：</p>\n<pre><code class=\"line-numbers language-Swift\">extension GMBaseScanViewController: AVCaptureMetadataOutputObjectsDelegate &#123;\n    func metadataOutput(_ output: AVCaptureMetadataOutput, didOutput metadataObjects: [AVMetadataObject], from connection: AVCaptureConnection) &#123;\n        if isCanScan &#123;\n            let isAchieve: Bool = metadataObjects.count == 1\n            if isAchieve &#123;\n                // 扫到条码\n                guard let device = AVCaptureDevice.default(for: AVMediaType.video) else &#123; return &#125;\n                guard let codeObj = metadataObjects.last as? AVMetadataMachineReadableCodeObject else &#123; return &#125;\n                print(&quot;扫到了条码 codeObj  ：  \\(codeObj)&quot;)\n                guard let str = codeObj.stringValue else &#123; return &#125;\n                self.isCanScan = false\n                print(&quot;扫到了条码 str：  \\(str)&quot;)\n                DispatchQueue.main.asyncAfter(deadline: .now() + scanInterval) &#123;\n                    try? device.lockForConfiguration()\n                    device.videoZoomFactor = 1\n                    device.unlockForConfiguration()\n                    self.isCanScan = true\n                &#125;\n                let barCode = barcodeProcessing(str)\n                delegate?.scanBarcode(barCode)\n            &#125; else &#123;\n                MBProgressHUD.showTipsMessage(&quot;无法识别&quot;)\n            &#125;\n        &#125;\n    &#125;\n    \n    func barcodeProcessing(_ code: String) -&gt; String &#123;\n        var codeStr: String = code.mutableCopy() as! String\n        var newStr = code.uppercased()\n        var index = 0\n        newStr = newStr.replacingOccurrences(of: &quot; &quot;, with: &quot;&quot;, options: .literal, range: nil)\n        codeStr = codeStr.replacingOccurrences(of: &quot; &quot;, with: &quot;&quot;, options: .literal, range: nil)\n        if newStr.hasPrefix(&quot;GREE&quot;) &#123;\n            index = 3\n        &#125; else if newStr.hasPrefix(&quot;KINGHOME&quot;) &#123;\n            index = 7\n        &#125; else if newStr.hasPrefix(&quot;TOSOT&quot;) &#123;\n            index = 4\n        &#125;\n        if index != 0 &#123;\n            let start = codeStr.index(codeStr.startIndex, offsetBy: 0)\n            let end = codeStr.index(codeStr.startIndex, offsetBy: index)\n            codeStr.removeSubrange(start...end)\n        &#125;\n        return codeStr\n    &#125;\n&#125;\n</code></pre>\n<p>这里覆写了这协议方法，表示识别到内容了。然后会回调metadateOutput，原因是前面session里面设置了Output的代理为self,也就是这里，这里就关联起来了。<br>前面是这样的：</p>\n<pre><code class=\"line-numbers language-Swift\"> let `output` = AVCaptureMetadataOutput()\n        self.output = output\n        output.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)\n                \n        //添加元数据输出流到会话对象 给新建的一个Output对象添加到session,session等下会给output赋值\n        session.addOutput(output)\n</code></pre>\n<p>就是因为这个self，当session开始running后，就会走协议的回调方法，在那里面我们间隔3.5才让它进行下次扫描，也是在这里面分析这个条码是否正常之类的。</p>\n<h3 id=\"3-9-设置videoDataOuput代理\"><a href=\"#3-9-设置videoDataOuput代理\" class=\"headerlink\" title=\"3.9 设置videoDataOuput代理\"></a>3.9 设置videoDataOuput代理</h3><p>这个代理，目的是为了识别光线强弱。</p>\n<pre><code class=\"line-numbers language-Swift\">extension GMBaseScanViewController: AVCaptureVideoDataOutputSampleBufferDelegate &#123;\n    \n    func captureOutput(_ output: AVCaptureOutput, didOutput sampleBuffer: CMSampleBuffer, from connection: AVCaptureConnection) &#123;\n        // 获取光照亮度\n        guard let metadataCFDict: CFDictionary = CMCopyDictionaryOfAttachments(allocator: nil, target: sampleBuffer, attachmentMode: 1) else &#123; return &#125;\n        guard let metadataDic: [String: AnyObject] = metadataCFDict as? [String: AnyObject] else &#123; return &#125;\n        guard let exifMetadata: [String: AnyObject] = metadataDic[kCGImagePropertyExifDictionary as String] as? [String : AnyObject] else &#123; return &#125;\n        guard let brightnessValue: CGFloat = exifMetadata[kCGImagePropertyExifBrightnessValue as String] as? CGFloat else &#123; return &#125;\n        // 根据光照亮度展示按钮\n        if brightnessValue &lt; -1 &#123;\n            torchButton.isHidden = false\n        &#125; else &#123;\n            guard let device = AVCaptureDevice.default(for: AVMediaType.video) else &#123; return &#125;\n            if device.hasTorch &amp;&amp; device.isTorchAvailable &#123;\n                try? device.lockForConfiguration()\n                torchButton.isHidden = !(device.torchMode == .on)\n                device.unlockForConfiguration()\n                \n            &#125;\n        &#125;\n        \n    &#125;\n    \n    private func convert(cmage: CIImage) -&gt; UIImage &#123;\n         let context = CIContext(options: nil)\n         let cgImage = context.createCGImage(cmage, from: cmage.extent)!\n         let image = UIImage(cgImage: cgImage)\n         return image\n    &#125;\n    \n&#125;\n</code></pre>\n<p>在代理 captureOutput的回调方法中可以获取光线强弱信息。</p>\n<p>也是在初始化session的时候设置了这个代理。</p>\n<h3 id=\"3-10-识别到后播放声音\"><a href=\"#3-10-识别到后播放声音\" class=\"headerlink\" title=\"3.10 识别到后播放声音\"></a>3.10 识别到后播放声音</h3><p>这里我们额外增加一个方法，主要给外面调用，因为我们会提供一个代理，如果识别到后，通过代理内部方法将识别的条码给外面。这时候外面要震动或声音效果，只需要调用我们内部的一个方法即可。</p>\n<pre><code class=\"line-numbers language-Swift\">func playAudio(success code: Int) &#123;\n        if isPlay == false &#123;\n            return\n        &#125;\n        if code == 1 &#123;\n            var soundID: SystemSoundID = 0\n            guard let path = Bundle.main.path(forResource: &quot;scanSuccess&quot;, ofType: &quot;mp3&quot;) else &#123; return &#125;\n            let url = URL(fileURLWithPath: path)\n            AudioServicesCreateSystemSoundID(url as CFURL, &amp;soundID)\n            AudioServicesPlaySystemSound(soundID) //声音\n        &#125; else &#123;\n            var soundID: SystemSoundID = 0\n            guard let path = Bundle.main.path(forResource: &quot;scanFail&quot;, ofType: &quot;mp3&quot;) else &#123; return &#125;\n            let url = URL(fileURLWithPath: path)\n            AudioServicesCreateSystemSoundID(url as CFURL, &amp;soundID)\n            AudioServicesPlayAlertSound(soundID) //震动+播放声音\n        &#125;\n    &#125;\n</code></pre>\n<p>也是非常简单，只需要先拿到声音路径，转换url，再通过AudioServicesCreateSystemSoundID包装一下，再通过AudioServicesPlaySystemSound来播放这个soundID即可。</p>\n<p>就这样，一个具有扫码能力的Controller就出来了哦。</p>\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4 总结\"></a>4 总结</h2><ul>\n<li><p>如果用到扫码，一定需要申请权限的，必须考虑到是否有权限，如果拒绝了权限，或其它原因导致没有权限，都需要考虑。</p>\n</li>\n<li><p>扫码关键的几个类，AVCaptureSession控制数据流关键类；AVCaptureMetadataOutput接收流，代理方法来处理识别到条码后的逻辑；AVCaptureVideoDataOutput接收流，可以处理光线强弱；AVCaptureVideoPreviewLayer用来预览相机的视图层，可显示在UIView的layer上。</p>\n</li>\n<li><p>一般扫码需要具备的二指缩放，光线太暗打开闪光灯，这些可以算作基本能能力，务必要实现，否则体验很不佳。</p>\n</li>\n<li><p>合理控制识别到条码间隔时间，该停止session的时候务必停止，为了防止频繁识别到相同条码，可以设置间隔时间。</p>\n</li>\n<li><p>可以先定义一个播放声音效果的方法，方便外部直接调用方法播放成功或者失败的声音。声音主要用到AudioServices相关方法。</p>\n</li>\n<li><p>系统类大多都是提供了代理，暴露了一些方法主要都是定义好的方法，我们业务开发也只需要接收和处理这些定义好的类就可以了。</p>\n</li>\n</ul>\n"},{"title":"iOS swift 混编Flutter","date":"2023-02-01T12:05:20.000Z","top":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 集成Flutter原因\n\n最除是项目人员调动，导致产品和开发数量不匹配。领导打算使用跨平台方案，但原有项目都是基于原生实现，如果想转Flutter，肯定得先考虑混编方案，因为需求也是持续迭代的，而且市场上也是由先例，可行性肯定是没问题的。\n\n所以我们考虑使用阿里的Flutter Boost来实现混编，因为已经经过大型App测试过的，我们项目完全是可以用起来的。\n\n## 2 Flutter Boost 初识\n\n从0开始实现混编，首先当然是了解 Flutter Boost如何使用。\n先看下官方文档：[https://github.com/alibaba/flutter_boost/blob/master/docs/install.md](https://github.com/alibaba/flutter_boost/blob/master/docs/install.md)。\n\n文档也很清楚，其它博客没必要重复看了。\n\n大概几个步骤吧：\n* 引用三方库\n* 新建一个代理类，继承FlutterBoostDelegate\n* AppDelegate初始化引擎\n\n## 3 项目结构和引入三方库\n\n这里我们将原生的代码和Flutter代码分两个仓库。\n比如在iOS项目的父文件夹下创建一个Flutter项目，这里面就放Flutter的代码。\n\n首先要明确一点，Flutter Boost是 Flutter代码里面用的三方库。\n这里配置项目结构是混编所需，不是因为依赖了Flutter Boost才这样引用。\n\n为什么原生能用Flutter Boost里面的一些类呢？\n\n这里并不是原生依赖了。\n\n原因是原生项目通过在podFile文件里面配置Flutter项目路径，建立起了链接关系。\n此时原生就可以正常访问Flutter项目里面依赖的三方库提供的一些类了。\n此时就可以在AppDelegate用Flutter Boost提供的类了。\n\n我们是这样配置的：\n```\n# flutter 集成\nflutter_application_path = '../../flutter-pin-module'\nload File.join(flutter_application_path, '.ios', 'Flutter', 'podhelper.rb')\n\nuse_frameworks!\n\ntarget 'GreeSalesSystem' do\n\n# flutter 集成\n  install_all_flutter_pods(flutter_application_path)\n```\n\n这里路径为父文件的父文件下的“flutter-pin-module”，我们将flutter部分单独放置在这个文件夹下，其实这个Flutter部分也是可以单独编译，单独用Android Studio或者VS Code跑起来。\n\n最后再走一次pod install。\n\n这样就成功引入Flutter Boost，可以愉快地在原生项目进行Flutter配置了。\n\n另外可能会有编译问题,没问题就不用加了。\n在podFile文件夹最下面需要加上这段代码：\n```\npost_install do |installer|\n    flutter_post_install(installer) if defined?(flutter_post_install)\n    installer.pods_project.build_configurations.each do |config|\n        config.build_settings[\"EXCLUDED_ARCHS[sdk=iphonesimulator*]\"] = \"arm64\"\n    end\nend\n```\n\n## 4 原生项目配置Flutter\n\n### 4.1 自定义FlutterBoostDelegate\n\n```Swift\n// Flutter Boost 架构Delegate\n// 参考： https://github.com/alibaba/flutter_boost/blob/master/docs/install.md\nclass GMFlutterBoostDelegate : NSObject, FlutterBoostDelegate {\n    \n    ///您用来push的导航栏\n    var navigationController: UINavigationController?\n    \n    ///用来存返回flutter侧返回结果的表\n    var resultTable: Dictionary<String,([AnyHashable:Any]?)->Void> = [:];\n    \n    /// Flutter 跳转 原生\n    func pushNativeRoute(_ pageName: String!, arguments: [AnyHashable : Any]!) {\n        GMFlutterNavigator.pushNative(pageName, arguments: arguments)\n        return\n    }\n    \n    /// 原生 跳转 Flutter\n    func pushFlutterRoute(_ options: FlutterBoostRouteOptions!) {\n        //对这个页面设置结果\n        resultTable[options.pageName] = options.onPageFinished;\n        \n        //用参数来控制是push还是pop\n        let isPresent = (options.arguments?[\"isPresent\"] as? Bool)  ?? false\n        var isAnimated = (options.arguments?[\"isAnimated\"] as? Bool) ?? true\n        \n        // 分销入库成功   distributeWarehousingSuccessPage\n        var vc: FBFlutterViewContainer\n        if options.pageName == DistributeWarehousingSuccessPage.pageName {\n            vc = DistributeWarehousingSuccessPage()\n        } else {\n            .......\n        }\n        \n        vc.hidesBottomBarWhenPushed = true\n        vc.setName(options.pageName, uniqueId: options.uniqueId, params: options.arguments,opaque: options.opaque)\n        \n        \n        //如果是present模式 ，或者要不透明模式，那么就需要以present模式打开页面\n        if(isPresent || !options.opaque){\n            self.navigationController?.present(vc, animated: isAnimated, completion: nil)\n        }else{\n            self.navigationController?.pushViewController(vc, animated: isAnimated)\n        }\n    }\n    \n    /// 原生 pop Flutter\n    func popRoute(_ options: FlutterBoostRouteOptions!) {\n        var animated = true\n        if options.pageName == DisPromotionChooseShopStoreViewController.pageName {\n            animated = false\n        }\n        //如果当前被present的vc是container，那么就执行dismiss逻辑\n        if let vc = self.navigationController?.presentedViewController as? FBFlutterViewContainer, vc.uniqueIDString() == options.uniqueId {\n            \n            //这里分为两种情况，由于UIModalPresentationOverFullScreen下，生命周期显示会有问题\n            //所以需要手动调用的场景，从而使下面底部的vc调用viewAppear相关逻辑\n            if vc.modalPresentationStyle == .overFullScreen {\n                \n                //这里手动beginAppearanceTransition触发页面生命周期\n                self.navigationController?.topViewController?.beginAppearanceTransition(true, animated: false)\n                \n                \n                vc.dismiss(animated: animated) {\n                    self.navigationController?.topViewController?.endAppearanceTransition()\n                }\n            }else{\n                //正常场景，直接dismiss\n                vc.dismiss(animated: animated, completion: nil)\n            }\n        }else{\n            self.navigationController?.popViewController(animated: animated)\n        }\n        //否则直接执行pop逻辑\n        //这里在pop的时候将参数带出,并且从结果表中移除\n        if let onPageFinshed = resultTable[options.pageName] {\n            onPageFinshed(options.arguments)\n            resultTable.removeValue(forKey: options.pageName)\n        }\n    }\n    \n}\n```\n\nFlutter 跳转 原生 主要用这个：pushNativeRoute 方法\n原生 跳转 Flutter 主要用这个： pushFlutterRoute 方法\n\n### 4.2 承载Flutter的容器\n\n其实说白了，Flutter页面本质上还是Controller。\n我们调整到任何一个Flutter，其实都是先跳自己的Controller。\n如下：\n```Swift\nclass DisPromotionChooseShopStoreViewController: FBFlutterViewContainer {\n    \n    static var pageName = \"disPromotionChooseShopStore\"\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n    }\n\n\n}\n```\n这里就是跳转到Flutter的某个页面。\n因为它继承了FBFlutterViewContainer，这个是阿里提供的。\n\n实际上就是一个Controller呀。\n\n### 4.3 应用启动初始化\n\n这个需要再AppDelegate中完成。\n可以搞个扩展方法：\n```Swift\nextension AppDelegate {\n    /// 设置flutter\n    func configFlutterBoost(_ application: UIApplication) {\n        //创建代理，做初始化操作\n        let delegate = GMFlutterBoostDelegate()\n        FlutterBoost.instance().setup(application, delegate: delegate) { engine in\n            \n        }\n    }\n}\n```\n这里面的delegate就是我们前面新建的一个Delegate。\n\n就这样混编没啥问题了。\n\n## 5 混编打包\n\n这里可能还有几个坑要注意下。\n\n在Flutter模块下执行：flutter build ios 报错\n \n 首先我要确保Flutter模块能够在iOS真机上跑起来\n\n### 5.1 真机运行报错\n\n参考了这篇文章：\n[https://honkersk.github.io/2020/07/02/Flutter-09-Flutter%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/](https://honkersk.github.io/2020/07/02/Flutter-09-Flutter%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/)\n\n我这边发现用Xcode单独跑，总是说有些类not found，所以我用Android Studio跑好像可以了。\n\n如果有些依赖有问题可以执行如下命令：\n```\nflutter pub upgrade\npod update\n```\n\n如果还不行可以将flutter项目clean下：\n```\nflutter clean\nflutter pub get\n```\n这样是全新的系统创建的.iOS文件夹，基本没啥问题。\n\n### 5.2 执行flutter build ios 报错\n\n这里报错了的话，先别google。\n\n可以先 flutter clean 再flutter pub get\n然后走 flutter build ios --release --no-codesign\n\n如果有一些shake 图标报错，可以运行这个指令看下：\n`flutter build ios --release --no-tree-shake-icons`\n\n啥都不用改，一次不行，多走几次，我这里试了3次，就成功了。\n<img src=fluttererror2.png>\n这里尝试了几次build，结果成功生成产物了。\n生成路径在flutter模块下的build下的ios文件夹中。\n\n\n### 5.3 build ios 产物分析\n<table><thead><tr><th>产物</th><th>介绍</th></tr></thead><tbody><tr><td>App.framework</td><td>Dart业务源码相关文件，在Debug模式下就是一个很小的空壳，在Release模式下包含全部业务逻辑。</td></tr><tr><td>flutter_assets</td><td>Flutter依赖的静态资源，如字体、图片等。<br><strong>在Flutter 1.9.1这种已经被合并进App.framework</strong>。</td></tr><tr><td>FlutterPluginRegistrant</td><td>Flutter插件注册制，自动注册Flutter插件。</td></tr><tr><td>Flutter.framework</td><td>Flutter库和引擎。</td></tr><tr><td>.symlinks</td><td>指向Flutter插件依赖库的实际地址。</td></tr></tbody></table>\n\n### 5.4 启动App闪退问题\n\n解决方案很简单：在原生主工程配置Release模式 进行archive编译构建\n<img src=fluttererror03.png>\n\n\n## 6 总结\n\n* 明确Flutter混编是系统支持，不是阿里提供的能力，Flutter Boost只是封装好的一个方便混编的工具，其实完全可以不用Flutter Boost，只是为了更好实现混编而已。\n\n* 三部曲，先引入依赖，通过Flutter模块引入，然后通过链接关系，原生可以访问到Flutter依赖，此时再配置Delegate，最后再初始化引擎。\n\n* 打包遇到问题不要急，先保证在真机上能运行起来。然后再走 flutter build ios命令，一次不行，走多次，有其它问题加后缀解决。","source":"_posts/iOS-swift-混编Flutter.md","raw":"---\ntitle: iOS swift 混编Flutter\ndate: 2023-02-01 20:05:20\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- 混编Flutter\ncategories:\n- iOS\n---\n\n## 1 集成Flutter原因\n\n最除是项目人员调动，导致产品和开发数量不匹配。领导打算使用跨平台方案，但原有项目都是基于原生实现，如果想转Flutter，肯定得先考虑混编方案，因为需求也是持续迭代的，而且市场上也是由先例，可行性肯定是没问题的。\n\n所以我们考虑使用阿里的Flutter Boost来实现混编，因为已经经过大型App测试过的，我们项目完全是可以用起来的。\n\n## 2 Flutter Boost 初识\n\n从0开始实现混编，首先当然是了解 Flutter Boost如何使用。\n先看下官方文档：[https://github.com/alibaba/flutter_boost/blob/master/docs/install.md](https://github.com/alibaba/flutter_boost/blob/master/docs/install.md)。\n\n文档也很清楚，其它博客没必要重复看了。\n\n大概几个步骤吧：\n* 引用三方库\n* 新建一个代理类，继承FlutterBoostDelegate\n* AppDelegate初始化引擎\n\n## 3 项目结构和引入三方库\n\n这里我们将原生的代码和Flutter代码分两个仓库。\n比如在iOS项目的父文件夹下创建一个Flutter项目，这里面就放Flutter的代码。\n\n首先要明确一点，Flutter Boost是 Flutter代码里面用的三方库。\n这里配置项目结构是混编所需，不是因为依赖了Flutter Boost才这样引用。\n\n为什么原生能用Flutter Boost里面的一些类呢？\n\n这里并不是原生依赖了。\n\n原因是原生项目通过在podFile文件里面配置Flutter项目路径，建立起了链接关系。\n此时原生就可以正常访问Flutter项目里面依赖的三方库提供的一些类了。\n此时就可以在AppDelegate用Flutter Boost提供的类了。\n\n我们是这样配置的：\n```\n# flutter 集成\nflutter_application_path = '../../flutter-pin-module'\nload File.join(flutter_application_path, '.ios', 'Flutter', 'podhelper.rb')\n\nuse_frameworks!\n\ntarget 'GreeSalesSystem' do\n\n# flutter 集成\n  install_all_flutter_pods(flutter_application_path)\n```\n\n这里路径为父文件的父文件下的“flutter-pin-module”，我们将flutter部分单独放置在这个文件夹下，其实这个Flutter部分也是可以单独编译，单独用Android Studio或者VS Code跑起来。\n\n最后再走一次pod install。\n\n这样就成功引入Flutter Boost，可以愉快地在原生项目进行Flutter配置了。\n\n另外可能会有编译问题,没问题就不用加了。\n在podFile文件夹最下面需要加上这段代码：\n```\npost_install do |installer|\n    flutter_post_install(installer) if defined?(flutter_post_install)\n    installer.pods_project.build_configurations.each do |config|\n        config.build_settings[\"EXCLUDED_ARCHS[sdk=iphonesimulator*]\"] = \"arm64\"\n    end\nend\n```\n\n## 4 原生项目配置Flutter\n\n### 4.1 自定义FlutterBoostDelegate\n\n```Swift\n// Flutter Boost 架构Delegate\n// 参考： https://github.com/alibaba/flutter_boost/blob/master/docs/install.md\nclass GMFlutterBoostDelegate : NSObject, FlutterBoostDelegate {\n    \n    ///您用来push的导航栏\n    var navigationController: UINavigationController?\n    \n    ///用来存返回flutter侧返回结果的表\n    var resultTable: Dictionary<String,([AnyHashable:Any]?)->Void> = [:];\n    \n    /// Flutter 跳转 原生\n    func pushNativeRoute(_ pageName: String!, arguments: [AnyHashable : Any]!) {\n        GMFlutterNavigator.pushNative(pageName, arguments: arguments)\n        return\n    }\n    \n    /// 原生 跳转 Flutter\n    func pushFlutterRoute(_ options: FlutterBoostRouteOptions!) {\n        //对这个页面设置结果\n        resultTable[options.pageName] = options.onPageFinished;\n        \n        //用参数来控制是push还是pop\n        let isPresent = (options.arguments?[\"isPresent\"] as? Bool)  ?? false\n        var isAnimated = (options.arguments?[\"isAnimated\"] as? Bool) ?? true\n        \n        // 分销入库成功   distributeWarehousingSuccessPage\n        var vc: FBFlutterViewContainer\n        if options.pageName == DistributeWarehousingSuccessPage.pageName {\n            vc = DistributeWarehousingSuccessPage()\n        } else {\n            .......\n        }\n        \n        vc.hidesBottomBarWhenPushed = true\n        vc.setName(options.pageName, uniqueId: options.uniqueId, params: options.arguments,opaque: options.opaque)\n        \n        \n        //如果是present模式 ，或者要不透明模式，那么就需要以present模式打开页面\n        if(isPresent || !options.opaque){\n            self.navigationController?.present(vc, animated: isAnimated, completion: nil)\n        }else{\n            self.navigationController?.pushViewController(vc, animated: isAnimated)\n        }\n    }\n    \n    /// 原生 pop Flutter\n    func popRoute(_ options: FlutterBoostRouteOptions!) {\n        var animated = true\n        if options.pageName == DisPromotionChooseShopStoreViewController.pageName {\n            animated = false\n        }\n        //如果当前被present的vc是container，那么就执行dismiss逻辑\n        if let vc = self.navigationController?.presentedViewController as? FBFlutterViewContainer, vc.uniqueIDString() == options.uniqueId {\n            \n            //这里分为两种情况，由于UIModalPresentationOverFullScreen下，生命周期显示会有问题\n            //所以需要手动调用的场景，从而使下面底部的vc调用viewAppear相关逻辑\n            if vc.modalPresentationStyle == .overFullScreen {\n                \n                //这里手动beginAppearanceTransition触发页面生命周期\n                self.navigationController?.topViewController?.beginAppearanceTransition(true, animated: false)\n                \n                \n                vc.dismiss(animated: animated) {\n                    self.navigationController?.topViewController?.endAppearanceTransition()\n                }\n            }else{\n                //正常场景，直接dismiss\n                vc.dismiss(animated: animated, completion: nil)\n            }\n        }else{\n            self.navigationController?.popViewController(animated: animated)\n        }\n        //否则直接执行pop逻辑\n        //这里在pop的时候将参数带出,并且从结果表中移除\n        if let onPageFinshed = resultTable[options.pageName] {\n            onPageFinshed(options.arguments)\n            resultTable.removeValue(forKey: options.pageName)\n        }\n    }\n    \n}\n```\n\nFlutter 跳转 原生 主要用这个：pushNativeRoute 方法\n原生 跳转 Flutter 主要用这个： pushFlutterRoute 方法\n\n### 4.2 承载Flutter的容器\n\n其实说白了，Flutter页面本质上还是Controller。\n我们调整到任何一个Flutter，其实都是先跳自己的Controller。\n如下：\n```Swift\nclass DisPromotionChooseShopStoreViewController: FBFlutterViewContainer {\n    \n    static var pageName = \"disPromotionChooseShopStore\"\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n    }\n\n\n}\n```\n这里就是跳转到Flutter的某个页面。\n因为它继承了FBFlutterViewContainer，这个是阿里提供的。\n\n实际上就是一个Controller呀。\n\n### 4.3 应用启动初始化\n\n这个需要再AppDelegate中完成。\n可以搞个扩展方法：\n```Swift\nextension AppDelegate {\n    /// 设置flutter\n    func configFlutterBoost(_ application: UIApplication) {\n        //创建代理，做初始化操作\n        let delegate = GMFlutterBoostDelegate()\n        FlutterBoost.instance().setup(application, delegate: delegate) { engine in\n            \n        }\n    }\n}\n```\n这里面的delegate就是我们前面新建的一个Delegate。\n\n就这样混编没啥问题了。\n\n## 5 混编打包\n\n这里可能还有几个坑要注意下。\n\n在Flutter模块下执行：flutter build ios 报错\n \n 首先我要确保Flutter模块能够在iOS真机上跑起来\n\n### 5.1 真机运行报错\n\n参考了这篇文章：\n[https://honkersk.github.io/2020/07/02/Flutter-09-Flutter%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/](https://honkersk.github.io/2020/07/02/Flutter-09-Flutter%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/)\n\n我这边发现用Xcode单独跑，总是说有些类not found，所以我用Android Studio跑好像可以了。\n\n如果有些依赖有问题可以执行如下命令：\n```\nflutter pub upgrade\npod update\n```\n\n如果还不行可以将flutter项目clean下：\n```\nflutter clean\nflutter pub get\n```\n这样是全新的系统创建的.iOS文件夹，基本没啥问题。\n\n### 5.2 执行flutter build ios 报错\n\n这里报错了的话，先别google。\n\n可以先 flutter clean 再flutter pub get\n然后走 flutter build ios --release --no-codesign\n\n如果有一些shake 图标报错，可以运行这个指令看下：\n`flutter build ios --release --no-tree-shake-icons`\n\n啥都不用改，一次不行，多走几次，我这里试了3次，就成功了。\n<img src=fluttererror2.png>\n这里尝试了几次build，结果成功生成产物了。\n生成路径在flutter模块下的build下的ios文件夹中。\n\n\n### 5.3 build ios 产物分析\n<table><thead><tr><th>产物</th><th>介绍</th></tr></thead><tbody><tr><td>App.framework</td><td>Dart业务源码相关文件，在Debug模式下就是一个很小的空壳，在Release模式下包含全部业务逻辑。</td></tr><tr><td>flutter_assets</td><td>Flutter依赖的静态资源，如字体、图片等。<br><strong>在Flutter 1.9.1这种已经被合并进App.framework</strong>。</td></tr><tr><td>FlutterPluginRegistrant</td><td>Flutter插件注册制，自动注册Flutter插件。</td></tr><tr><td>Flutter.framework</td><td>Flutter库和引擎。</td></tr><tr><td>.symlinks</td><td>指向Flutter插件依赖库的实际地址。</td></tr></tbody></table>\n\n### 5.4 启动App闪退问题\n\n解决方案很简单：在原生主工程配置Release模式 进行archive编译构建\n<img src=fluttererror03.png>\n\n\n## 6 总结\n\n* 明确Flutter混编是系统支持，不是阿里提供的能力，Flutter Boost只是封装好的一个方便混编的工具，其实完全可以不用Flutter Boost，只是为了更好实现混编而已。\n\n* 三部曲，先引入依赖，通过Flutter模块引入，然后通过链接关系，原生可以访问到Flutter依赖，此时再配置Delegate，最后再初始化引擎。\n\n* 打包遇到问题不要急，先保证在真机上能运行起来。然后再走 flutter build ios命令，一次不行，走多次，有其它问题加后缀解决。","slug":"iOS-swift-混编Flutter","published":1,"updated":"2023-02-01T07:12:22.330Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlc01je000njhv73c3fc29f","content":"<h2 id=\"1-集成Flutter原因\"><a href=\"#1-集成Flutter原因\" class=\"headerlink\" title=\"1 集成Flutter原因\"></a>1 集成Flutter原因</h2><p>最除是项目人员调动，导致产品和开发数量不匹配。领导打算使用跨平台方案，但原有项目都是基于原生实现，如果想转Flutter，肯定得先考虑混编方案，因为需求也是持续迭代的，而且市场上也是由先例，可行性肯定是没问题的。</p>\n<p>所以我们考虑使用阿里的Flutter Boost来实现混编，因为已经经过大型App测试过的，我们项目完全是可以用起来的。</p>\n<h2 id=\"2-Flutter-Boost-初识\"><a href=\"#2-Flutter-Boost-初识\" class=\"headerlink\" title=\"2 Flutter Boost 初识\"></a>2 Flutter Boost 初识</h2><p>从0开始实现混编，首先当然是了解 Flutter Boost如何使用。<br>先看下官方文档：<a href=\"https://github.com/alibaba/flutter_boost/blob/master/docs/install.md\">https://github.com/alibaba/flutter_boost&#x2F;blob&#x2F;master&#x2F;docs&#x2F;install.md</a>。</p>\n<p>文档也很清楚，其它博客没必要重复看了。</p>\n<p>大概几个步骤吧：</p>\n<ul>\n<li>引用三方库</li>\n<li>新建一个代理类，继承FlutterBoostDelegate</li>\n<li>AppDelegate初始化引擎</li>\n</ul>\n<h2 id=\"3-项目结构和引入三方库\"><a href=\"#3-项目结构和引入三方库\" class=\"headerlink\" title=\"3 项目结构和引入三方库\"></a>3 项目结构和引入三方库</h2><p>这里我们将原生的代码和Flutter代码分两个仓库。<br>比如在iOS项目的父文件夹下创建一个Flutter项目，这里面就放Flutter的代码。</p>\n<p>首先要明确一点，Flutter Boost是 Flutter代码里面用的三方库。<br>这里配置项目结构是混编所需，不是因为依赖了Flutter Boost才这样引用。</p>\n<p>为什么原生能用Flutter Boost里面的一些类呢？</p>\n<p>这里并不是原生依赖了。</p>\n<p>原因是原生项目通过在podFile文件里面配置Flutter项目路径，建立起了链接关系。<br>此时原生就可以正常访问Flutter项目里面依赖的三方库提供的一些类了。<br>此时就可以在AppDelegate用Flutter Boost提供的类了。</p>\n<p>我们是这样配置的：</p>\n<pre><code># flutter 集成\nflutter_application_path = &#39;../../flutter-pin-module&#39;\nload File.join(flutter_application_path, &#39;.ios&#39;, &#39;Flutter&#39;, &#39;podhelper.rb&#39;)\n\nuse_frameworks!\n\ntarget &#39;GreeSalesSystem&#39; do\n\n# flutter 集成\n  install_all_flutter_pods(flutter_application_path)\n</code></pre>\n<p>这里路径为父文件的父文件下的“flutter-pin-module”，我们将flutter部分单独放置在这个文件夹下，其实这个Flutter部分也是可以单独编译，单独用Android Studio或者VS Code跑起来。</p>\n<p>最后再走一次pod install。</p>\n<p>这样就成功引入Flutter Boost，可以愉快地在原生项目进行Flutter配置了。</p>\n<p>另外可能会有编译问题,没问题就不用加了。<br>在podFile文件夹最下面需要加上这段代码：</p>\n<pre><code>post_install do |installer|\n    flutter_post_install(installer) if defined?(flutter_post_install)\n    installer.pods_project.build_configurations.each do |config|\n        config.build_settings[&quot;EXCLUDED_ARCHS[sdk=iphonesimulator*]&quot;] = &quot;arm64&quot;\n    end\nend\n</code></pre>\n<h2 id=\"4-原生项目配置Flutter\"><a href=\"#4-原生项目配置Flutter\" class=\"headerlink\" title=\"4 原生项目配置Flutter\"></a>4 原生项目配置Flutter</h2><h3 id=\"4-1-自定义FlutterBoostDelegate\"><a href=\"#4-1-自定义FlutterBoostDelegate\" class=\"headerlink\" title=\"4.1 自定义FlutterBoostDelegate\"></a>4.1 自定义FlutterBoostDelegate</h3><pre><code class=\"line-numbers language-Swift\">// Flutter Boost 架构Delegate\n// 参考： https://github.com/alibaba/flutter_boost/blob/master/docs/install.md\nclass GMFlutterBoostDelegate : NSObject, FlutterBoostDelegate &#123;\n    \n    ///您用来push的导航栏\n    var navigationController: UINavigationController?\n    \n    ///用来存返回flutter侧返回结果的表\n    var resultTable: Dictionary&lt;String,([AnyHashable:Any]?)-&gt;Void&gt; = [:];\n    \n    /// Flutter 跳转 原生\n    func pushNativeRoute(_ pageName: String!, arguments: [AnyHashable : Any]!) &#123;\n        GMFlutterNavigator.pushNative(pageName, arguments: arguments)\n        return\n    &#125;\n    \n    /// 原生 跳转 Flutter\n    func pushFlutterRoute(_ options: FlutterBoostRouteOptions!) &#123;\n        //对这个页面设置结果\n        resultTable[options.pageName] = options.onPageFinished;\n        \n        //用参数来控制是push还是pop\n        let isPresent = (options.arguments?[&quot;isPresent&quot;] as? Bool)  ?? false\n        var isAnimated = (options.arguments?[&quot;isAnimated&quot;] as? Bool) ?? true\n        \n        // 分销入库成功   distributeWarehousingSuccessPage\n        var vc: FBFlutterViewContainer\n        if options.pageName == DistributeWarehousingSuccessPage.pageName &#123;\n            vc = DistributeWarehousingSuccessPage()\n        &#125; else &#123;\n            .......\n        &#125;\n        \n        vc.hidesBottomBarWhenPushed = true\n        vc.setName(options.pageName, uniqueId: options.uniqueId, params: options.arguments,opaque: options.opaque)\n        \n        \n        //如果是present模式 ，或者要不透明模式，那么就需要以present模式打开页面\n        if(isPresent || !options.opaque)&#123;\n            self.navigationController?.present(vc, animated: isAnimated, completion: nil)\n        &#125;else&#123;\n            self.navigationController?.pushViewController(vc, animated: isAnimated)\n        &#125;\n    &#125;\n    \n    /// 原生 pop Flutter\n    func popRoute(_ options: FlutterBoostRouteOptions!) &#123;\n        var animated = true\n        if options.pageName == DisPromotionChooseShopStoreViewController.pageName &#123;\n            animated = false\n        &#125;\n        //如果当前被present的vc是container，那么就执行dismiss逻辑\n        if let vc = self.navigationController?.presentedViewController as? FBFlutterViewContainer, vc.uniqueIDString() == options.uniqueId &#123;\n            \n            //这里分为两种情况，由于UIModalPresentationOverFullScreen下，生命周期显示会有问题\n            //所以需要手动调用的场景，从而使下面底部的vc调用viewAppear相关逻辑\n            if vc.modalPresentationStyle == .overFullScreen &#123;\n                \n                //这里手动beginAppearanceTransition触发页面生命周期\n                self.navigationController?.topViewController?.beginAppearanceTransition(true, animated: false)\n                \n                \n                vc.dismiss(animated: animated) &#123;\n                    self.navigationController?.topViewController?.endAppearanceTransition()\n                &#125;\n            &#125;else&#123;\n                //正常场景，直接dismiss\n                vc.dismiss(animated: animated, completion: nil)\n            &#125;\n        &#125;else&#123;\n            self.navigationController?.popViewController(animated: animated)\n        &#125;\n        //否则直接执行pop逻辑\n        //这里在pop的时候将参数带出,并且从结果表中移除\n        if let onPageFinshed = resultTable[options.pageName] &#123;\n            onPageFinshed(options.arguments)\n            resultTable.removeValue(forKey: options.pageName)\n        &#125;\n    &#125;\n    \n&#125;\n</code></pre>\n<p>Flutter 跳转 原生 主要用这个：pushNativeRoute 方法<br>原生 跳转 Flutter 主要用这个： pushFlutterRoute 方法</p>\n<h3 id=\"4-2-承载Flutter的容器\"><a href=\"#4-2-承载Flutter的容器\" class=\"headerlink\" title=\"4.2 承载Flutter的容器\"></a>4.2 承载Flutter的容器</h3><p>其实说白了，Flutter页面本质上还是Controller。<br>我们调整到任何一个Flutter，其实都是先跳自己的Controller。<br>如下：</p>\n<pre><code class=\"line-numbers language-Swift\">class DisPromotionChooseShopStoreViewController: FBFlutterViewContainer &#123;\n    \n    static var pageName = &quot;disPromotionChooseShopStore&quot;\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n    &#125;\n\n\n&#125;\n</code></pre>\n<p>这里就是跳转到Flutter的某个页面。<br>因为它继承了FBFlutterViewContainer，这个是阿里提供的。</p>\n<p>实际上就是一个Controller呀。</p>\n<h3 id=\"4-3-应用启动初始化\"><a href=\"#4-3-应用启动初始化\" class=\"headerlink\" title=\"4.3 应用启动初始化\"></a>4.3 应用启动初始化</h3><p>这个需要再AppDelegate中完成。<br>可以搞个扩展方法：</p>\n<pre><code class=\"line-numbers language-Swift\">extension AppDelegate &#123;\n    /// 设置flutter\n    func configFlutterBoost(_ application: UIApplication) &#123;\n        //创建代理，做初始化操作\n        let delegate = GMFlutterBoostDelegate()\n        FlutterBoost.instance().setup(application, delegate: delegate) &#123; engine in\n            \n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里面的delegate就是我们前面新建的一个Delegate。</p>\n<p>就这样混编没啥问题了。</p>\n<h2 id=\"5-混编打包\"><a href=\"#5-混编打包\" class=\"headerlink\" title=\"5 混编打包\"></a>5 混编打包</h2><p>这里可能还有几个坑要注意下。</p>\n<p>在Flutter模块下执行：flutter build ios 报错</p>\n<p> 首先我要确保Flutter模块能够在iOS真机上跑起来</p>\n<h3 id=\"5-1-真机运行报错\"><a href=\"#5-1-真机运行报错\" class=\"headerlink\" title=\"5.1 真机运行报错\"></a>5.1 真机运行报错</h3><p>参考了这篇文章：<br><a href=\"https://honkersk.github.io/2020/07/02/Flutter-09-Flutter%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/\">https://honkersk.github.io/2020/07/02/Flutter-09-Flutter%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</a></p>\n<p>我这边发现用Xcode单独跑，总是说有些类not found，所以我用Android Studio跑好像可以了。</p>\n<p>如果有些依赖有问题可以执行如下命令：</p>\n<pre><code>flutter pub upgrade\npod update\n</code></pre>\n<p>如果还不行可以将flutter项目clean下：</p>\n<pre><code>flutter clean\nflutter pub get\n</code></pre>\n<p>这样是全新的系统创建的.iOS文件夹，基本没啥问题。</p>\n<h3 id=\"5-2-执行flutter-build-ios-报错\"><a href=\"#5-2-执行flutter-build-ios-报错\" class=\"headerlink\" title=\"5.2 执行flutter build ios 报错\"></a>5.2 执行flutter build ios 报错</h3><p>这里报错了的话，先别google。</p>\n<p>可以先 flutter clean 再flutter pub get<br>然后走 flutter build ios –release –no-codesign</p>\n<p>如果有一些shake 图标报错，可以运行这个指令看下：<br><code>flutter build ios --release --no-tree-shake-icons</code></p>\n<p>啥都不用改，一次不行，多走几次，我这里试了3次，就成功了。<br><img src=fluttererror2.png><br>这里尝试了几次build，结果成功生成产物了。<br>生成路径在flutter模块下的build下的ios文件夹中。</p>\n<h3 id=\"5-3-build-ios-产物分析\"><a href=\"#5-3-build-ios-产物分析\" class=\"headerlink\" title=\"5.3 build ios 产物分析\"></a>5.3 build ios 产物分析</h3><table><thead><tr><th>产物</th><th>介绍</th></tr></thead><tbody><tr><td>App.framework</td><td>Dart业务源码相关文件，在Debug模式下就是一个很小的空壳，在Release模式下包含全部业务逻辑。</td></tr><tr><td>flutter_assets</td><td>Flutter依赖的静态资源，如字体、图片等。<br><strong>在Flutter 1.9.1这种已经被合并进App.framework</strong>。</td></tr><tr><td>FlutterPluginRegistrant</td><td>Flutter插件注册制，自动注册Flutter插件。</td></tr><tr><td>Flutter.framework</td><td>Flutter库和引擎。</td></tr><tr><td>.symlinks</td><td>指向Flutter插件依赖库的实际地址。</td></tr></tbody></table>\n\n<h3 id=\"5-4-启动App闪退问题\"><a href=\"#5-4-启动App闪退问题\" class=\"headerlink\" title=\"5.4 启动App闪退问题\"></a>5.4 启动App闪退问题</h3><p>解决方案很简单：在原生主工程配置Release模式 进行archive编译构建<br><img src=fluttererror03.png></p>\n<h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6 总结\"></a>6 总结</h2><ul>\n<li><p>明确Flutter混编是系统支持，不是阿里提供的能力，Flutter Boost只是封装好的一个方便混编的工具，其实完全可以不用Flutter Boost，只是为了更好实现混编而已。</p>\n</li>\n<li><p>三部曲，先引入依赖，通过Flutter模块引入，然后通过链接关系，原生可以访问到Flutter依赖，此时再配置Delegate，最后再初始化引擎。</p>\n</li>\n<li><p>打包遇到问题不要急，先保证在真机上能运行起来。然后再走 flutter build ios命令，一次不行，走多次，有其它问题加后缀解决。</p>\n</li>\n</ul>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-集成Flutter原因\"><a href=\"#1-集成Flutter原因\" class=\"headerlink\" title=\"1 集成Flutter原因\"></a>1 集成Flutter原因</h2><p>最除是项目人员调动，导致产品和开发数量不匹配。领导打算使用跨平台方案，但原有项目都是基于原生实现，如果想转Flutter，肯定得先考虑混编方案，因为需求也是持续迭代的，而且市场上也是由先例，可行性肯定是没问题的。</p>\n<p>所以我们考虑使用阿里的Flutter Boost来实现混编，因为已经经过大型App测试过的，我们项目完全是可以用起来的。</p>\n<h2 id=\"2-Flutter-Boost-初识\"><a href=\"#2-Flutter-Boost-初识\" class=\"headerlink\" title=\"2 Flutter Boost 初识\"></a>2 Flutter Boost 初识</h2><p>从0开始实现混编，首先当然是了解 Flutter Boost如何使用。<br>先看下官方文档：<a href=\"https://github.com/alibaba/flutter_boost/blob/master/docs/install.md\">https://github.com/alibaba/flutter_boost&#x2F;blob&#x2F;master&#x2F;docs&#x2F;install.md</a>。</p>\n<p>文档也很清楚，其它博客没必要重复看了。</p>\n<p>大概几个步骤吧：</p>\n<ul>\n<li>引用三方库</li>\n<li>新建一个代理类，继承FlutterBoostDelegate</li>\n<li>AppDelegate初始化引擎</li>\n</ul>\n<h2 id=\"3-项目结构和引入三方库\"><a href=\"#3-项目结构和引入三方库\" class=\"headerlink\" title=\"3 项目结构和引入三方库\"></a>3 项目结构和引入三方库</h2><p>这里我们将原生的代码和Flutter代码分两个仓库。<br>比如在iOS项目的父文件夹下创建一个Flutter项目，这里面就放Flutter的代码。</p>\n<p>首先要明确一点，Flutter Boost是 Flutter代码里面用的三方库。<br>这里配置项目结构是混编所需，不是因为依赖了Flutter Boost才这样引用。</p>\n<p>为什么原生能用Flutter Boost里面的一些类呢？</p>\n<p>这里并不是原生依赖了。</p>\n<p>原因是原生项目通过在podFile文件里面配置Flutter项目路径，建立起了链接关系。<br>此时原生就可以正常访问Flutter项目里面依赖的三方库提供的一些类了。<br>此时就可以在AppDelegate用Flutter Boost提供的类了。</p>\n<p>我们是这样配置的：</p>\n<pre><code># flutter 集成\nflutter_application_path = &#39;../../flutter-pin-module&#39;\nload File.join(flutter_application_path, &#39;.ios&#39;, &#39;Flutter&#39;, &#39;podhelper.rb&#39;)\n\nuse_frameworks!\n\ntarget &#39;GreeSalesSystem&#39; do\n\n# flutter 集成\n  install_all_flutter_pods(flutter_application_path)\n</code></pre>\n<p>这里路径为父文件的父文件下的“flutter-pin-module”，我们将flutter部分单独放置在这个文件夹下，其实这个Flutter部分也是可以单独编译，单独用Android Studio或者VS Code跑起来。</p>\n<p>最后再走一次pod install。</p>\n<p>这样就成功引入Flutter Boost，可以愉快地在原生项目进行Flutter配置了。</p>\n<p>另外可能会有编译问题,没问题就不用加了。<br>在podFile文件夹最下面需要加上这段代码：</p>\n<pre><code>post_install do |installer|\n    flutter_post_install(installer) if defined?(flutter_post_install)\n    installer.pods_project.build_configurations.each do |config|\n        config.build_settings[&quot;EXCLUDED_ARCHS[sdk=iphonesimulator*]&quot;] = &quot;arm64&quot;\n    end\nend\n</code></pre>\n<h2 id=\"4-原生项目配置Flutter\"><a href=\"#4-原生项目配置Flutter\" class=\"headerlink\" title=\"4 原生项目配置Flutter\"></a>4 原生项目配置Flutter</h2><h3 id=\"4-1-自定义FlutterBoostDelegate\"><a href=\"#4-1-自定义FlutterBoostDelegate\" class=\"headerlink\" title=\"4.1 自定义FlutterBoostDelegate\"></a>4.1 自定义FlutterBoostDelegate</h3><pre><code class=\"line-numbers language-Swift\">// Flutter Boost 架构Delegate\n// 参考： https://github.com/alibaba/flutter_boost/blob/master/docs/install.md\nclass GMFlutterBoostDelegate : NSObject, FlutterBoostDelegate &#123;\n    \n    ///您用来push的导航栏\n    var navigationController: UINavigationController?\n    \n    ///用来存返回flutter侧返回结果的表\n    var resultTable: Dictionary&lt;String,([AnyHashable:Any]?)-&gt;Void&gt; = [:];\n    \n    /// Flutter 跳转 原生\n    func pushNativeRoute(_ pageName: String!, arguments: [AnyHashable : Any]!) &#123;\n        GMFlutterNavigator.pushNative(pageName, arguments: arguments)\n        return\n    &#125;\n    \n    /// 原生 跳转 Flutter\n    func pushFlutterRoute(_ options: FlutterBoostRouteOptions!) &#123;\n        //对这个页面设置结果\n        resultTable[options.pageName] = options.onPageFinished;\n        \n        //用参数来控制是push还是pop\n        let isPresent = (options.arguments?[&quot;isPresent&quot;] as? Bool)  ?? false\n        var isAnimated = (options.arguments?[&quot;isAnimated&quot;] as? Bool) ?? true\n        \n        // 分销入库成功   distributeWarehousingSuccessPage\n        var vc: FBFlutterViewContainer\n        if options.pageName == DistributeWarehousingSuccessPage.pageName &#123;\n            vc = DistributeWarehousingSuccessPage()\n        &#125; else &#123;\n            .......\n        &#125;\n        \n        vc.hidesBottomBarWhenPushed = true\n        vc.setName(options.pageName, uniqueId: options.uniqueId, params: options.arguments,opaque: options.opaque)\n        \n        \n        //如果是present模式 ，或者要不透明模式，那么就需要以present模式打开页面\n        if(isPresent || !options.opaque)&#123;\n            self.navigationController?.present(vc, animated: isAnimated, completion: nil)\n        &#125;else&#123;\n            self.navigationController?.pushViewController(vc, animated: isAnimated)\n        &#125;\n    &#125;\n    \n    /// 原生 pop Flutter\n    func popRoute(_ options: FlutterBoostRouteOptions!) &#123;\n        var animated = true\n        if options.pageName == DisPromotionChooseShopStoreViewController.pageName &#123;\n            animated = false\n        &#125;\n        //如果当前被present的vc是container，那么就执行dismiss逻辑\n        if let vc = self.navigationController?.presentedViewController as? FBFlutterViewContainer, vc.uniqueIDString() == options.uniqueId &#123;\n            \n            //这里分为两种情况，由于UIModalPresentationOverFullScreen下，生命周期显示会有问题\n            //所以需要手动调用的场景，从而使下面底部的vc调用viewAppear相关逻辑\n            if vc.modalPresentationStyle == .overFullScreen &#123;\n                \n                //这里手动beginAppearanceTransition触发页面生命周期\n                self.navigationController?.topViewController?.beginAppearanceTransition(true, animated: false)\n                \n                \n                vc.dismiss(animated: animated) &#123;\n                    self.navigationController?.topViewController?.endAppearanceTransition()\n                &#125;\n            &#125;else&#123;\n                //正常场景，直接dismiss\n                vc.dismiss(animated: animated, completion: nil)\n            &#125;\n        &#125;else&#123;\n            self.navigationController?.popViewController(animated: animated)\n        &#125;\n        //否则直接执行pop逻辑\n        //这里在pop的时候将参数带出,并且从结果表中移除\n        if let onPageFinshed = resultTable[options.pageName] &#123;\n            onPageFinshed(options.arguments)\n            resultTable.removeValue(forKey: options.pageName)\n        &#125;\n    &#125;\n    \n&#125;\n</code></pre>\n<p>Flutter 跳转 原生 主要用这个：pushNativeRoute 方法<br>原生 跳转 Flutter 主要用这个： pushFlutterRoute 方法</p>\n<h3 id=\"4-2-承载Flutter的容器\"><a href=\"#4-2-承载Flutter的容器\" class=\"headerlink\" title=\"4.2 承载Flutter的容器\"></a>4.2 承载Flutter的容器</h3><p>其实说白了，Flutter页面本质上还是Controller。<br>我们调整到任何一个Flutter，其实都是先跳自己的Controller。<br>如下：</p>\n<pre><code class=\"line-numbers language-Swift\">class DisPromotionChooseShopStoreViewController: FBFlutterViewContainer &#123;\n    \n    static var pageName = &quot;disPromotionChooseShopStore&quot;\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n    &#125;\n\n\n&#125;\n</code></pre>\n<p>这里就是跳转到Flutter的某个页面。<br>因为它继承了FBFlutterViewContainer，这个是阿里提供的。</p>\n<p>实际上就是一个Controller呀。</p>\n<h3 id=\"4-3-应用启动初始化\"><a href=\"#4-3-应用启动初始化\" class=\"headerlink\" title=\"4.3 应用启动初始化\"></a>4.3 应用启动初始化</h3><p>这个需要再AppDelegate中完成。<br>可以搞个扩展方法：</p>\n<pre><code class=\"line-numbers language-Swift\">extension AppDelegate &#123;\n    /// 设置flutter\n    func configFlutterBoost(_ application: UIApplication) &#123;\n        //创建代理，做初始化操作\n        let delegate = GMFlutterBoostDelegate()\n        FlutterBoost.instance().setup(application, delegate: delegate) &#123; engine in\n            \n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里面的delegate就是我们前面新建的一个Delegate。</p>\n<p>就这样混编没啥问题了。</p>\n<h2 id=\"5-混编打包\"><a href=\"#5-混编打包\" class=\"headerlink\" title=\"5 混编打包\"></a>5 混编打包</h2><p>这里可能还有几个坑要注意下。</p>\n<p>在Flutter模块下执行：flutter build ios 报错</p>\n<p> 首先我要确保Flutter模块能够在iOS真机上跑起来</p>\n<h3 id=\"5-1-真机运行报错\"><a href=\"#5-1-真机运行报错\" class=\"headerlink\" title=\"5.1 真机运行报错\"></a>5.1 真机运行报错</h3><p>参考了这篇文章：<br><a href=\"https://honkersk.github.io/2020/07/02/Flutter-09-Flutter%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/\">https://honkersk.github.io/2020/07/02/Flutter-09-Flutter%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</a></p>\n<p>我这边发现用Xcode单独跑，总是说有些类not found，所以我用Android Studio跑好像可以了。</p>\n<p>如果有些依赖有问题可以执行如下命令：</p>\n<pre><code>flutter pub upgrade\npod update\n</code></pre>\n<p>如果还不行可以将flutter项目clean下：</p>\n<pre><code>flutter clean\nflutter pub get\n</code></pre>\n<p>这样是全新的系统创建的.iOS文件夹，基本没啥问题。</p>\n<h3 id=\"5-2-执行flutter-build-ios-报错\"><a href=\"#5-2-执行flutter-build-ios-报错\" class=\"headerlink\" title=\"5.2 执行flutter build ios 报错\"></a>5.2 执行flutter build ios 报错</h3><p>这里报错了的话，先别google。</p>\n<p>可以先 flutter clean 再flutter pub get<br>然后走 flutter build ios –release –no-codesign</p>\n<p>如果有一些shake 图标报错，可以运行这个指令看下：<br><code>flutter build ios --release --no-tree-shake-icons</code></p>\n<p>啥都不用改，一次不行，多走几次，我这里试了3次，就成功了。<br><img src=fluttererror2.png><br>这里尝试了几次build，结果成功生成产物了。<br>生成路径在flutter模块下的build下的ios文件夹中。</p>\n<h3 id=\"5-3-build-ios-产物分析\"><a href=\"#5-3-build-ios-产物分析\" class=\"headerlink\" title=\"5.3 build ios 产物分析\"></a>5.3 build ios 产物分析</h3><table><thead><tr><th>产物</th><th>介绍</th></tr></thead><tbody><tr><td>App.framework</td><td>Dart业务源码相关文件，在Debug模式下就是一个很小的空壳，在Release模式下包含全部业务逻辑。</td></tr><tr><td>flutter_assets</td><td>Flutter依赖的静态资源，如字体、图片等。<br><strong>在Flutter 1.9.1这种已经被合并进App.framework</strong>。</td></tr><tr><td>FlutterPluginRegistrant</td><td>Flutter插件注册制，自动注册Flutter插件。</td></tr><tr><td>Flutter.framework</td><td>Flutter库和引擎。</td></tr><tr><td>.symlinks</td><td>指向Flutter插件依赖库的实际地址。</td></tr></tbody></table>\n\n<h3 id=\"5-4-启动App闪退问题\"><a href=\"#5-4-启动App闪退问题\" class=\"headerlink\" title=\"5.4 启动App闪退问题\"></a>5.4 启动App闪退问题</h3><p>解决方案很简单：在原生主工程配置Release模式 进行archive编译构建<br><img src=fluttererror03.png></p>\n<h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6 总结\"></a>6 总结</h2><ul>\n<li><p>明确Flutter混编是系统支持，不是阿里提供的能力，Flutter Boost只是封装好的一个方便混编的工具，其实完全可以不用Flutter Boost，只是为了更好实现混编而已。</p>\n</li>\n<li><p>三部曲，先引入依赖，通过Flutter模块引入，然后通过链接关系，原生可以访问到Flutter依赖，此时再配置Delegate，最后再初始化引擎。</p>\n</li>\n<li><p>打包遇到问题不要急，先保证在真机上能运行起来。然后再走 flutter build ios命令，一次不行，走多次，有其它问题加后缀解决。</p>\n</li>\n</ul>\n"},{"title":"iOS swift 数据库realm实践","date":"2023-01-30T08:38:21.000Z","top":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 需求定义\n\n需要获取服务端的条码数据库，存放到本地数据库。\n\n背景：集成了扫码功能，扫到的条码头需要匹配数据库中的条码列表，可以认为这个是一个离线数据库。不会实时判断，因为条码很多，这里先获取所有的条码，存放到本地数据库。然后扫码就按照数据库中的关系表来匹配就好了。\n\n这里我们有两个表，一个商品库表，一个是关系表。为什么有2个表呢？因为我们有配套的关系，2个零件可以看做单个商品，他们组合了也可以看成单独商品哦，这种就是套机了。想必做个电商的人都懂这个道理。比如可以买一件上衣，一条裤子，它们都是独立商品，也可以配套组合一套商品，而且这一套也可以认为是一个商品。\n\n\n## 2 需求分析\n\n这里我们采用 realm数据库。\nrealm非常简介，效率也是不错的。\ngithub地址：[https://github.com/realm/realm-swift](https://github.com/realm/realm-swift)\n\n简单描述下realm吧：Realm 是一个跨平台的移动数据库引擎，其性能要优于 Core Data 和 FMDB - 移动端数据库性能比较, 我们可以在 Android 端 realm-java，iOS端:Realm-Cocoa，同时支持 OC 和 Swift两种语言开发。其使用简单，免费，性能优异，跨平台的特点广受关注。\n\n这里我们会用到2个表。\n\n因为这是个离线数据库，我们需要考虑数据库变更，与服务端同步问题。\n所以我们需要一个接口，判断有无新增或者变更的数据。\n\n需要考虑到增量更新，同时如果数据变更大于一个阙值，比如1000条数据，我们可以认为是全量更新。这时候全量更新的时间和增量插入数据时间几乎相同。\n\n另外如果第一次获取数据，数据量可能会很大，我们需要考虑压缩，与服务端商议，将json数据压缩，然后我们自行解析为实体类。\n\n另外增量更新的时候，要特别注意改数据是删除了还是新增的，还是变更的。\n如果商品删除了，关系表也是要删除的哦。这点很重要，不然后期会导致匹配异常。\n\n\n## 3 准备工作，会用Realm\n\n因为是从0开始，建议熟悉一下Realm使用方法。\n可以参考下这篇博客：[https://juejin.cn/post/6844904117442215944](https://juejin.cn/post/6844904117442215944),写得还是相当不错，有Demo，讲述得非常清晰易懂。\n\n这里就不讲解如何引用这个Realm了。\n\n这里需要会用一个工具：Realm Studio，\n下载地址：[https://www.mongodb.com/docs/realm/studio/install/](https://www.mongodb.com/docs/realm/studio/install/)\n这里按照自己电脑版本下载相应软件就好了，这个也是免费的。\n\n如何分析真机里面的realm数据库呢？\n可以参考下：[https://blog.csdn.net/asfasnjn/article/details/124714242](https://blog.csdn.net/asfasnjn/article/details/124714242) 很简单，打开XCode的window下的设备和模拟器，再 点击更多图标，再下载Container，然后下载后，查看包内容，就可以看到这个应用的realm文件了。然后可以右键，用我们下载好的Realm Studio来查看这个文件，文件以表格形式展示，清晰直观。\n\n## 4 初始化配置数据库\n\n这里需要在AppDelegate中配置下realm数据库。\n很简单的。\n不过我们没有在AppDelegate初始化，因为我们这个绑定了userId，等用户登录后才初始化，当然也是可以的。\n\n重点是初始化这个动作要先于使用就行了。\n```Swift\nfunc configRealm(userID: String?,\n                        keyWord: String? = nil,\n                        schemaVersion: UInt64 = 2, migrationBlock: MigrationBlock? = nil) {\n    // 加密串128位结果为：464e5774625e64306771702463336e316a4074487442325145766477335e21346b715169364c406c6a4976346d695958396245346e356f6a62256d2637566126\n    // let key: Data = \"FNWtb^d0gqp$c3n1j@tHtB2QEvdw3^!4kqQi6L@ljIv4miYX9bE4n5ojb%m&7Va&\".data(using: .utf8, allowLossyConversion: false)!\n    // 加密的key\n    // let key: Data = keyWord.data(using: .utf8, allowLossyConversion: false)!\n    // 打开加密文件\n    // (encryptionKey: key)\n    // 使用默认的目录，但是使用用户 ID 来替换默认的文件名\n    \n    //schemaVersion 数据库版本号从0开始\n    let manager = FileManager.default\n    let document = manager.urls(for: .documentDirectory, in: .userDomainMask)\n    let url = document[0] as URL\n    let urlStr = url.absoluteString\n    let path = urlStr + \"/\" + (\"\\(userID!).realm\")\n    let config = Realm.Configuration(fileURL: URL(string: path), schemaVersion: schemaVersion, migrationBlock: { (migration, oldSchemaVersion) in\n        // 目前我们还未进行数据迁移，因此 oldSchemaVersion == 0\n        if oldSchemaVersion < 100 {\n            // 什么都不要做！Realm 会自行检测新增和需要移除的属性，然后自动更新硬盘上的数据库架构\n            // 属性重命名  migration.renameProperty(onType: Person.className(), from: \"yearsSinceBirth\", to: \"age\")\n            print(oldSchemaVersion)\n            print(\"end\")\n        }\n        // 低版本的数据库迁移......\n        if migrationBlock != nil {\n            migrationBlock!(migration, oldSchemaVersion)\n        }\n    })\n    // 告诉 Realm 为默认的 Realm 数据库使用这个新的配置对象\n    Realm.Configuration.defaultConfiguration = config\n    guard let realm = try? Realm(configuration: config) else {\n        return\n    }\n    currentSchemaVersion = schemaVersion\n    currentRealm = realm\n    currentKeyWord = keyWord\n}\n```\n这个realm实际上以userId为名称了。\n这样就有个弊端了，切换用户后，需要重新下载数据库，特别是数据库特别大的情况下，这对用户体验不是特别好。\n\n\n## 5 走接口拿数据\n\n这里就是拿商品数据了，这里服务端提供的接口，返回的是加密后的字符串。\n类似这样：\n```Json\n{\n  \"message\" : \"请求成功\",\n  \"code\" : 1000,\n  \"data\" : \"H4sIAAAAAAAAAKtWSiwoCCjKTylNLglKzQnz98ksLlGyio7VQZJAFk3OzytJzQ\n  NyDA2NdJRKC1IS\\nS1JDMnNTlayUjAyMjHUNDHWNLBUMTaxMzaxMDJVqAQ0XaZphAAAA\"\n}\n```\n\n比如我们接口是这样请求的，这里我们先扩展了一个方法给控制器：\n```Swift\nextension GMBaseViewController {\n    \n    open func updateOfflinePackageData(tips: String = \"\", successful: @escaping Handler) {\n        MBProgressHUD.showMessage(tips)\n        OfflinePackageManager.update {\n            successful()\n            MBProgressHUD.hide()\n            MBProgressHUD.hide()\n        } failure: {\n            MBProgressHUD.hide()\n            MBProgressHUD.hide()\n            let alerVC = UIAlertController(\n                title: \"\",\n                message: \"检测到商品信息变动，系统为您自动更新商品信息失败，请在网络良好的环境下，手动更新商品信息\",\n                preferredStyle: .alert\n            )\n            alerVC.addAction(\n                UIAlertAction(\n                    title: \"下载商品信息\",\n                    style: .default\n                ) { (action) in\n                    self.updateOfflinePackageData(successful: successful)\n                }\n            )\n            self.present(alerVC, animated: true, completion:nil)\n        }\n        \n    }\n    \n}\n```\n这里我们的OfflinePackageManager就是我们封装好的专门去下载离线库的工具类。\n成功后走successful的逃逸闭包，失败弹一个弹框。\n\n继续走进去：\n```Swift\nclass OfflinePackageManager: NSObject {\n    \n    open class func update(\n        updateTime: String = Defaults[key: DefaultsKeys.updateTime] ?? \"\",\n        successful: @escaping Handler,\n        failure: @escaping Handler\n    ) {\n        let endTimeStr = Defaults[key: DefaultsKeys.updateTime]\n        let updateTimeStr = updateTime\n       \n        productProvider.requestJson(.getProductMetadataForAPP(updateTime: updateTimeStr)) { response in\n            let jsonString = JSON(rawValue: response).jsonString\n            let result = GMBaseRequestModel.deserialize(from: jsonString)\n            if result?.code == 1000 {\n                guard let data = result?.data?.gunzip?.data(using: .utf8) else { return }\n                \n                let file = \"zpi_offline_package_data.txt\"\n                let text = result?.data?.gunzip ?? \"\"\n                \n                if let dir = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first {\n                    let fileURL = dir.appendingPathComponent(file)\n                    do {\n                        try text.write(to: fileURL, atomically: false, encoding: .utf8)\n                    } catch {}\n                }\n                \n                guard let model = try? JSONDecoder().decode(StageOfflinePackageData.self, from: data) else { return }\n                \n                if endTimeStr != nil && (model.appProductVOList.count >= 1000 || model.appProductRelVOList.count >= 1000) {\n                    Defaults[key:DefaultsKeys.updateTime] = nil\n                    OfflinePackageManager.update(updateTime: \"\", successful: successful, failure: failure)\n                } else {\n                    if endTimeStr == nil {\n                        OfflinePackageManager.fullUpdate(model: model)\n                    } else {\n                        OfflinePackageManager.incrementalUpdate(model: model)\n                    }\n                    Defaults[key: DefaultsKeys.updateTime] = model.updateTime\n                    successful()\n                }\n            } else {\n                failure()\n            }\n        } failure: { _ in\n            failure()\n        }\n    }\n```\n\n## 6 解压缩字符串\n\n这里服务端返回的一段加密后的字符串：\n```Json\n{\n  \"message\" : \"请求成功\",\n  \"code\" : 1000,\n  \"data\" : \"H4sIAAAAAAAAAKtWSiwoCCjKTylNLglKzQnz98ksLlGyio7VQZJAFk3OzytJzQNyDA2NdJRKC1IS\\nS1JDMnNTlayUjAyMjHUNDHWNLBUMTaxMzaxMDJVqAQ0XaZphAAAA\"\n}\n```\n不过返回体还是json，我们先拿data里面的字符串。\n再去解压缩。\n\n字符串解压缩可以参考这篇文章：[https://www.cnblogs.com/strengthen/p/10844466.html](https://www.cnblogs.com/strengthen/p/10844466.html)\n\n这里我们用到了GzipSwift框架。\n\n这个框架地址为：[https://github.com/1024jp/GzipSwift](https://github.com/1024jp/GzipSwift) 还是有挺多人star的。\n\n具体细节就不讲解了。\n\n这里我们自己给String做了一个扩展，这样直接能拿到解压缩后的字符串：\n```Swift\nextension String {\n    var gunzip: String? {\n        if let data = Data(base64Encoded: self, options: .ignoreUnknownCharacters) {\n            if data.isGzipped {\n                if let gun = try? data.gunzipped() {\n                    return String(data: gun, encoding: String.Encoding.utf8)\n                }\n            }\n        }\n        return nil\n    }\n}\n```\n\n这里解析后的字符串为：\n```Json\n{\n    \"appProductRelVOList\":[],\n    \"appProductVOList\":[],\n    \"content\":112,\n    \"updateTime\":\"2023-01-29 14:56:41\"\n}\n```\n\n同样也是一个json数组哦。\n所以我们还是得用Json解析下：\n```Swift\nguard let model = try? JSONDecoder().decode(StageOfflinePackageData.self, from: data)\n                else { return }\n```\n\n这时候我们需要一个实体来接收下：\n```Swift\nclass StageOfflinePackageData:Codable{\n    \n    var appProductVOList: [StageGoodsPackgeModelData] = []\n    \n    var appProductRelVOList: [StageGoodsSuitPackgeModelData] = []\n    \n    var updateTime: String = \"\"\n    \n    \n    private enum Codingkeys: String, CodingKey{\n        case appProductVOList,appProductRelVOList,updateTime\n    }\n    \n    func encode(to encoder: Encoder) throws {}\n    \n    required init(from decoder: Decoder) throws {\n        let values = try decoder.container(keyedBy: Codingkeys.self)\n        appProductVOList = try values.decode(Array.self, forKey: .appProductVOList)\n        appProductRelVOList = try values.decode(Array.self, forKey: .appProductRelVOList)\n        updateTime = try values.decode(String.self, forKey: .updateTime)\n    }\n}\n```\n为啥要继承Codable呢？\nCodable 协议在 Swift4.0 开始被引入，目标是取代现有的 NSCoding 协议，它对结构体，枚举和类都支持。Codable 的引入简化了JSON 和 Swift 类型之间相互转换的难度，能够把 JSON 这种弱类型数据转换成代码中使用的强类型数据。具体可以看这篇文章：[https://juejin.cn/post/6971997599725256734](https://juejin.cn/post/6971997599725256734)。\n\n\n解析后就拿到服务端的数据了，可能是增量数据，可能是全量数据。后面我们具体分析下。\n\n\n## 7 数据处理\n\n解析完毕后，我们有一段逻辑是这样的：\n```Swift\nif endTimeStr != nil && (model.appProductVOList.count >= 1000 || model.appProductRelVOList.count >= 1000) {\n                    Defaults[key:DefaultsKeys.updateTime] = nil\n                    OfflinePackageManager.update(updateTime: \"\", successful: successful, failure: failure)\n                } else {\n                    if endTimeStr == nil {\n                        OfflinePackageManager.fullUpdate(model: model)\n                    } else {\n                        OfflinePackageManager.incrementalUpdate(model: model)\n                    }\n                    Defaults[key: DefaultsKeys.updateTime] = model.updateTime\n                    successful()\n                }\n```\n\n这里如果数据大于1000条，我们重新走全量更新接口。\n如果上次更新时间为空，我们默认为全量更新，将所有数据插入数据库。\n如果上次更新时间不为空，而且小于1000条，我们就走增量更新逻辑。\n\n### 7.1 Model层定义\n\n这里是定义的Realm的基础模型。\n\n我们需要定义两个实体，一个是商品模型，一个是关系模型。\n\n商品模型为：\n```Swift\n\nclass StageGoodsPackgeModelData: Object,Codable{\n    \n    @objc dynamic var barcode: String = \"\"\n    @objc dynamic var brand: String = \"\"\n    @objc dynamic var brandId: String = \"\"\n    @objc dynamic var category: String = \"\"\n    @objc dynamic var categoryId: Int = 0\n    @objc dynamic var createBy: String = \"\"\n    @objc dynamic var createTime: String = \"\"\n    @objc dynamic var delFlag: Int = 0\n    @objc dynamic var groupNum: Int = 1         //返回为\"\"时服务器需要传1\n    @objc dynamic var id: String = \"\"\n    @objc dynamic var isGreeProduct: Bool = false\n    @objc dynamic var isGroupedProduct: Bool = false\n    @objc dynamic var isSaleProduct: Bool = false\n    @objc dynamic var length: Double = 0.0\n    @objc dynamic var name: String = \"\"\n    @objc dynamic var orgId: String = \"\"\n    @objc dynamic var skuCode: String = \"\"\n    @objc dynamic var tall: Double = 0\n    @objc dynamic var unit: String = \"\"\n    @objc dynamic var updateBy: String = \"\"\n    @objc dynamic var updateTime: String = \"\"\n    @objc dynamic var volume: Double = 0.0\n    @objc dynamic var weight: Double = 0.0\n    @objc dynamic var wide: Double = 0.0\n    @objc dynamic var isMarketingProduct :Bool = false\n    \n    private enum Codingkeys: String, CodingKey{\n        case barcode\n        ,brand\n        ,brandId\n        ,category\n        ,categoryId\n        ,createBy\n        ,createTime\n        ,delFlag\n        ,groupNum\n        ,id\n        ,isGreeProduct\n        ,isGroupedProduct\n        ,isSaleProduct\n        ,length\n        ,name\n        ,orgId\n        ,skuCode\n        ,tall\n        ,unit\n        ,updateBy\n        ,updateTime\n        ,volume\n        ,weight\n        ,wide,\n        isMarketingProduct\n    }\n    \n    \n    required init(from decoder: Decoder) throws {\n        let values = try decoder.container(keyedBy: Codingkeys.self)\n        \n        do {\n            barcode = try values.decode(String.self, forKey: .barcode)\n        } catch {\n            barcode = \"\"\n        }\n        do {\n            brand = try values.decode(String.self, forKey: .brand)\n        } catch {\n            brand = \"\"\n        }\n        do {\n            brandId = try values.decode(String.self, forKey: .brandId)\n        } catch {\n            brandId = \"\"\n        }\n        do {\n            category = try values.decode(String.self, forKey: .category)\n        } catch {\n            category = \"\"\n        }\n        do {\n            categoryId = try values.decode(Int.self, forKey: .categoryId)\n        } catch {\n            categoryId = 0\n        }\n        do {\n            createBy = try values.decode(String.self, forKey: .createBy)\n        } catch {\n            createBy = \"\"\n        }\n        do {\n            createTime = try values.decode(String.self, forKey: .createTime)\n        } catch {\n            createTime = \"\"\n        }\n        do {\n            delFlag = try values.decode(Int.self, forKey: .delFlag)\n        } catch {\n            delFlag = 0\n        }\n        do {\n            groupNum = try values.decode(Int.self, forKey: .groupNum)\n        } catch {\n            groupNum = 1\n        }\n        do {\n            id = try values.decode(String.self, forKey: .id)\n        } catch {\n            id = \"\"\n        }\n        do {\n            isGreeProduct = try values.decode(Bool.self, forKey: .isGreeProduct)\n        } catch {\n            isGreeProduct = false\n        }\n        do {\n            isGroupedProduct = try values.decode(Bool.self, forKey: .isGroupedProduct)\n        } catch {\n            isGroupedProduct = false\n        }\n        do {\n            isSaleProduct = try values.decode(Bool.self, forKey: .isSaleProduct)\n        } catch {\n            isSaleProduct = false\n        }\n        do {\n            length = try values.decode(CGFloat.self, forKey: .length)\n        } catch {\n            length = 0.0\n        }\n        do {\n            name = try values.decode(String.self, forKey: .name)\n        } catch {\n            name = \"\"\n        }\n        do {\n            orgId = try values.decode(String.self, forKey: .orgId)\n        } catch {\n            orgId = \"\"\n        }\n        do {\n            skuCode = try values.decode(String.self, forKey: .skuCode)\n        } catch {\n            skuCode = \"\"\n        }\n        do {\n            tall = try values.decode(Double.self, forKey: .tall)\n        } catch {\n            tall = 0\n        }\n        do {\n            unit = try values.decode(String.self, forKey: .unit)\n        } catch {\n            unit = \"\"\n        }\n        do {\n            updateBy =  try values.decode(String.self, forKey: .updateBy)\n        } catch {\n            updateBy = \"\"\n        }\n        do {\n            updateTime = try values.decode(String.self, forKey: .updateTime)\n        } catch {\n            updateTime = \"\"\n        }\n        do {\n            volume = try values.decode(Double.self, forKey: .volume)\n        } catch {\n            volume = 0.0\n        }\n        do {\n            weight = try values.decode(Double.self, forKey: .weight)\n        } catch {\n            weight = 0.0\n        }\n        do {\n            wide = try values.decode(Double.self, forKey: .wide)\n        } catch {\n            wide = 0.0\n        }\n        do {\n            isMarketingProduct = try values.decode(Bool.self, forKey: .isMarketingProduct)\n        } catch {\n            isMarketingProduct = false\n        }\n    }\n    \n    func encode(to encoder: Encoder) throws {}\n    \n    override required init(){}\n}\n```\n\n另外一个为：\n```Swift\n\nclass StageGoodsSuitPackgeModelData: Object,Codable{\n\n    @objc dynamic var groupNum: Int = 0\n    @objc dynamic var id: String = \"\"\n    @objc dynamic var orgId: String = \"\"\n    @objc dynamic var productId: String = \"\"\n    @objc dynamic var subProductId: String = \"\"\n    \n    private enum Codingkeys: String, CodingKey {\n        case groupNum\n        case id\n        case orgId\n        case productId\n        case subProductId\n    }\n\n    required init(from decoder: Decoder) throws {\n        let values = try decoder.container(keyedBy: Codingkeys.self)\n        \n        do {\n            groupNum = try values.decode(Int.self, forKey: .groupNum)\n        } catch {\n            groupNum = 0\n        }\n        do {\n            id = try values.decode(String.self, forKey: .id)\n        } catch {\n            id = \"\"\n        }\n        do {\n            orgId = try values.decode(String.self, forKey: .orgId)\n        } catch {\n            orgId = \"\"\n        }\n        do {\n            productId = try values.decode(String.self, forKey: .productId)\n        } catch {\n            productId = \"\"\n        }\n        do {\n            subProductId = try values.decode(String.self, forKey: .subProductId)\n        } catch {\n            subProductId = \"\"\n        }\n    }\n\n    func encode(to encoder: Encoder) throws {}\n    \n    override required init(){}\n}\n```\n\n### 7.2 全量更新\n\n```Swift\nprivate class func fullUpdate(model: StageOfflinePackageData) {\n        let suitResult = objectWithAll(objct: StageGoodsPackgeModelData.self)\n        if suitResult.count != 0 {\n            deleteList(suitResult) {\n                print(\"StageGoodsPackgeModelData表数据清除成功\")\n            }\n        }\n        addList(model.appProductVOList) {\n            print(\"StageGoodsPackgeModelData 插入成功\")\n        }\n        \n        let relationResult = objectWithAll(objct: StageGoodsSuitPackgeModelData.self)\n        if relationResult.count != 0 {\n            deleteList(relationResult) {\n                print(\"StageGoodsSuitPackgeModelData表数据清除成功\")\n            }\n        }\n        addList(model.appProductRelVOList) {\n            print(\"StageGoodsSuitPackgeModelData 插入成功\")\n        }\n    }\n```\n如果是全量更新就比较简单了。\n先把之前的那两个删除掉，然后新增新的model就好了。\n\n### 7.3 增量更新\n\n先声明一下sql\n```Swift\n    private class func incrementalUpdate(model: StageOfflinePackageData) {\n        print(\"增量处理开始时间---->\", Date().currentTime(0))\n        var addGoodsArr: [StageGoodsPackgeModelData] = []\n        var addRelationsArr: [StageGoodsSuitPackgeModelData] = []\n        var relationidArr: [String] = []\n        \n        var goodsSql = \"\"\n        var relationSql = \"\"\n        var deleteGoodsSql = \"\"\n        var deleteRelationSql = \"\"\n```\n\n遍历下服务端返回的增量数据库：\n```Swift\nfor (_,suitModel) in model.appProductVOList.enumerated() {\n    // delFlag为0表示，不是删除哦，这里是新增商品\n    if suitModel.delFlag == 0 {\n        if goodsSql == \"\" {\n            let str1 = String(format:\"id = '%@'\", suitModel.id)\n            let str2 = String(format:\"productId = '%@'\", suitModel.id)\n            goodsSql.append(str1)\n            relationSql.append(str2)\n        } else {\n            let str1 = String(format:\"|| id = '%@'\", suitModel.id)\n            let str2 = String(format:\"|| productId = '%@'\", suitModel.id)\n            goodsSql.append(str1)\n            relationSql.append(str2)\n        }\n        addGoodsArr.append(suitModel)\n        relationidArr.append(suitModel.id)\n    } else {\n        // delFlag为1表示删除了商品\n        if deleteGoodsSql == \"\" {\n            let str1 = String(format:\"id = '%@'\", suitModel.id)\n            let str2 = String(format:\"productId = '%@'\", suitModel.id)\n            deleteGoodsSql.append(str1)\n            deleteRelationSql.append(str2)\n        } else {\n            let str1 = String(format:\"|| id = '%@'\", suitModel.id)\n            let str2 = String(format:\"|| productId = '%@'\", suitModel.id)\n            deleteGoodsSql.append(str1)\n            deleteRelationSql.append(str2)\n        }\n    }\n}\n```\n有个一个delFlag变量，就是表示是否删除的意思。\n如果是删除的话，将sql组合一下，就成为 id = '12' || id = '13' || id = '14' 这种。关系表就是 productId = '12' || productId = '14' 这种。\n\n\n这里就知道哪些商品要删除，哪些要加。哪些关系表要删除，哪些要加。\n\n这里先处理下新增的商品：\n```Swift\nif goodsSql != \"\" {\n    let predicate = NSPredicate(format:goodsSql)\n    let suitArr = objectsWithPredicate(object: StageGoodsPackgeModelData.self, predicate: predicate)\n    // 这里需要把可能之前存在相同的去掉\n    deleteList(suitArr){\n        print(\"删除商品成功\")\n    }\n    if addGoodsArr.count != 0 {\n        addList(addGoodsArr){\n            print(\"增量更新商品数据成功\")\n        }\n    }\n}\n```\n这里用了系统的NSPredicate类来组合sql语句。它其实是用来过滤数据的类。\n使用方法可以参考这篇文章：[https://juejin.cn/post/6844903540805074951](https://juejin.cn/post/6844903540805074951)。\n\n然后处理下要删除的商品：\n```Swift\n if deleteGoodsSql != \"\" {\n    // NSPredicate是swift 过滤数据的类，类似数据库中的where字段\n    let predicate = NSPredicate(format:deleteGoodsSql)\n    let suitArr = objectsWithPredicate(object: StageGoodsPackgeModelData.self, predicate: predicate)\n    deleteList(suitArr){\n        print(\"删除商品成功\")\n    }\n}\n```\n\n商品处理完成，剩下就是关系表了。\n\n这里先处理要新增的关系：\n```Swift\n// 这里是新增的关系表\nfor idStr in relationidArr {\n    for relationModel in model.appProductRelVOList{\n        if idStr == relationModel.productId {\n            addRelationsArr.append(relationModel)\n        }\n    }\n}\n\n// 新增的关系表\nif relationSql != \"\" {\n    let relationPredicate = NSPredicate(format:relationSql)\n    let relationArr = objectsWithPredicate(object: StageGoodsSuitPackgeModelData.self, predicate: relationPredicate)\n    deleteList(relationArr){\n        print(\"删除套机关系模型成功\")\n    }\n    if addRelationsArr.count != 0 {\n        addList(addRelationsArr){\n            print(\"增量更新套机关系模型成功\")\n        }\n    }\n}\n```\n\n然后处理下要删除的关系表：\n```Swift\n if deleteRelationSql != \"\" {\n    let relationPredicate = NSPredicate(format:deleteRelationSql)\n    let relationArr = objectsWithPredicate(object: StageGoodsSuitPackgeModelData.self, predicate: relationPredicate)\n    deleteList(relationArr){\n        print(\"删除套机关系模型成功\")\n    }\n}\n```\n\n这样增量数据就成功插入了。\n\n## 8 预览realm数据库\n\n插入数据成功后，我们可以用 Realm Studio 来预览数据。\n上面有讲解如何使用这个可视化工具。\n\n这里我们就看下最终的结果吧：\n<img src=realm1.png>\n<img src=realm2.png>\n\n## 9 总结\n\n* iOS数据库可以考虑使用realm数据库，这个是跨平台，Android也有相应的三方库，使用非常简洁，可以考虑。\n\n* 对于大量数据，我们务必要注意数据的修改，新增，最好采用增量更新的方式，而且如果全量，最好是先压缩下，减小对网络依赖。\n\n* realm数据库要注意数据库迁移的问题，升级的问题，使用前需要configRealm。\n\n* 真机预览realm数据库可以使用Realm Studio。\n\n* 增量更新一定要注意删除之前的记录，否则数据会很紊乱。\n","source":"_posts/iOS-swift-数据库realm实践.md","raw":"---\ntitle: iOS swift 数据库realm实践\ndate: 2023-01-30 16:38:21\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- 数据库 iOS\ncategories:\n- iOS\n---\n\n## 1 需求定义\n\n需要获取服务端的条码数据库，存放到本地数据库。\n\n背景：集成了扫码功能，扫到的条码头需要匹配数据库中的条码列表，可以认为这个是一个离线数据库。不会实时判断，因为条码很多，这里先获取所有的条码，存放到本地数据库。然后扫码就按照数据库中的关系表来匹配就好了。\n\n这里我们有两个表，一个商品库表，一个是关系表。为什么有2个表呢？因为我们有配套的关系，2个零件可以看做单个商品，他们组合了也可以看成单独商品哦，这种就是套机了。想必做个电商的人都懂这个道理。比如可以买一件上衣，一条裤子，它们都是独立商品，也可以配套组合一套商品，而且这一套也可以认为是一个商品。\n\n\n## 2 需求分析\n\n这里我们采用 realm数据库。\nrealm非常简介，效率也是不错的。\ngithub地址：[https://github.com/realm/realm-swift](https://github.com/realm/realm-swift)\n\n简单描述下realm吧：Realm 是一个跨平台的移动数据库引擎，其性能要优于 Core Data 和 FMDB - 移动端数据库性能比较, 我们可以在 Android 端 realm-java，iOS端:Realm-Cocoa，同时支持 OC 和 Swift两种语言开发。其使用简单，免费，性能优异，跨平台的特点广受关注。\n\n这里我们会用到2个表。\n\n因为这是个离线数据库，我们需要考虑数据库变更，与服务端同步问题。\n所以我们需要一个接口，判断有无新增或者变更的数据。\n\n需要考虑到增量更新，同时如果数据变更大于一个阙值，比如1000条数据，我们可以认为是全量更新。这时候全量更新的时间和增量插入数据时间几乎相同。\n\n另外如果第一次获取数据，数据量可能会很大，我们需要考虑压缩，与服务端商议，将json数据压缩，然后我们自行解析为实体类。\n\n另外增量更新的时候，要特别注意改数据是删除了还是新增的，还是变更的。\n如果商品删除了，关系表也是要删除的哦。这点很重要，不然后期会导致匹配异常。\n\n\n## 3 准备工作，会用Realm\n\n因为是从0开始，建议熟悉一下Realm使用方法。\n可以参考下这篇博客：[https://juejin.cn/post/6844904117442215944](https://juejin.cn/post/6844904117442215944),写得还是相当不错，有Demo，讲述得非常清晰易懂。\n\n这里就不讲解如何引用这个Realm了。\n\n这里需要会用一个工具：Realm Studio，\n下载地址：[https://www.mongodb.com/docs/realm/studio/install/](https://www.mongodb.com/docs/realm/studio/install/)\n这里按照自己电脑版本下载相应软件就好了，这个也是免费的。\n\n如何分析真机里面的realm数据库呢？\n可以参考下：[https://blog.csdn.net/asfasnjn/article/details/124714242](https://blog.csdn.net/asfasnjn/article/details/124714242) 很简单，打开XCode的window下的设备和模拟器，再 点击更多图标，再下载Container，然后下载后，查看包内容，就可以看到这个应用的realm文件了。然后可以右键，用我们下载好的Realm Studio来查看这个文件，文件以表格形式展示，清晰直观。\n\n## 4 初始化配置数据库\n\n这里需要在AppDelegate中配置下realm数据库。\n很简单的。\n不过我们没有在AppDelegate初始化，因为我们这个绑定了userId，等用户登录后才初始化，当然也是可以的。\n\n重点是初始化这个动作要先于使用就行了。\n```Swift\nfunc configRealm(userID: String?,\n                        keyWord: String? = nil,\n                        schemaVersion: UInt64 = 2, migrationBlock: MigrationBlock? = nil) {\n    // 加密串128位结果为：464e5774625e64306771702463336e316a4074487442325145766477335e21346b715169364c406c6a4976346d695958396245346e356f6a62256d2637566126\n    // let key: Data = \"FNWtb^d0gqp$c3n1j@tHtB2QEvdw3^!4kqQi6L@ljIv4miYX9bE4n5ojb%m&7Va&\".data(using: .utf8, allowLossyConversion: false)!\n    // 加密的key\n    // let key: Data = keyWord.data(using: .utf8, allowLossyConversion: false)!\n    // 打开加密文件\n    // (encryptionKey: key)\n    // 使用默认的目录，但是使用用户 ID 来替换默认的文件名\n    \n    //schemaVersion 数据库版本号从0开始\n    let manager = FileManager.default\n    let document = manager.urls(for: .documentDirectory, in: .userDomainMask)\n    let url = document[0] as URL\n    let urlStr = url.absoluteString\n    let path = urlStr + \"/\" + (\"\\(userID!).realm\")\n    let config = Realm.Configuration(fileURL: URL(string: path), schemaVersion: schemaVersion, migrationBlock: { (migration, oldSchemaVersion) in\n        // 目前我们还未进行数据迁移，因此 oldSchemaVersion == 0\n        if oldSchemaVersion < 100 {\n            // 什么都不要做！Realm 会自行检测新增和需要移除的属性，然后自动更新硬盘上的数据库架构\n            // 属性重命名  migration.renameProperty(onType: Person.className(), from: \"yearsSinceBirth\", to: \"age\")\n            print(oldSchemaVersion)\n            print(\"end\")\n        }\n        // 低版本的数据库迁移......\n        if migrationBlock != nil {\n            migrationBlock!(migration, oldSchemaVersion)\n        }\n    })\n    // 告诉 Realm 为默认的 Realm 数据库使用这个新的配置对象\n    Realm.Configuration.defaultConfiguration = config\n    guard let realm = try? Realm(configuration: config) else {\n        return\n    }\n    currentSchemaVersion = schemaVersion\n    currentRealm = realm\n    currentKeyWord = keyWord\n}\n```\n这个realm实际上以userId为名称了。\n这样就有个弊端了，切换用户后，需要重新下载数据库，特别是数据库特别大的情况下，这对用户体验不是特别好。\n\n\n## 5 走接口拿数据\n\n这里就是拿商品数据了，这里服务端提供的接口，返回的是加密后的字符串。\n类似这样：\n```Json\n{\n  \"message\" : \"请求成功\",\n  \"code\" : 1000,\n  \"data\" : \"H4sIAAAAAAAAAKtWSiwoCCjKTylNLglKzQnz98ksLlGyio7VQZJAFk3OzytJzQ\n  NyDA2NdJRKC1IS\\nS1JDMnNTlayUjAyMjHUNDHWNLBUMTaxMzaxMDJVqAQ0XaZphAAAA\"\n}\n```\n\n比如我们接口是这样请求的，这里我们先扩展了一个方法给控制器：\n```Swift\nextension GMBaseViewController {\n    \n    open func updateOfflinePackageData(tips: String = \"\", successful: @escaping Handler) {\n        MBProgressHUD.showMessage(tips)\n        OfflinePackageManager.update {\n            successful()\n            MBProgressHUD.hide()\n            MBProgressHUD.hide()\n        } failure: {\n            MBProgressHUD.hide()\n            MBProgressHUD.hide()\n            let alerVC = UIAlertController(\n                title: \"\",\n                message: \"检测到商品信息变动，系统为您自动更新商品信息失败，请在网络良好的环境下，手动更新商品信息\",\n                preferredStyle: .alert\n            )\n            alerVC.addAction(\n                UIAlertAction(\n                    title: \"下载商品信息\",\n                    style: .default\n                ) { (action) in\n                    self.updateOfflinePackageData(successful: successful)\n                }\n            )\n            self.present(alerVC, animated: true, completion:nil)\n        }\n        \n    }\n    \n}\n```\n这里我们的OfflinePackageManager就是我们封装好的专门去下载离线库的工具类。\n成功后走successful的逃逸闭包，失败弹一个弹框。\n\n继续走进去：\n```Swift\nclass OfflinePackageManager: NSObject {\n    \n    open class func update(\n        updateTime: String = Defaults[key: DefaultsKeys.updateTime] ?? \"\",\n        successful: @escaping Handler,\n        failure: @escaping Handler\n    ) {\n        let endTimeStr = Defaults[key: DefaultsKeys.updateTime]\n        let updateTimeStr = updateTime\n       \n        productProvider.requestJson(.getProductMetadataForAPP(updateTime: updateTimeStr)) { response in\n            let jsonString = JSON(rawValue: response).jsonString\n            let result = GMBaseRequestModel.deserialize(from: jsonString)\n            if result?.code == 1000 {\n                guard let data = result?.data?.gunzip?.data(using: .utf8) else { return }\n                \n                let file = \"zpi_offline_package_data.txt\"\n                let text = result?.data?.gunzip ?? \"\"\n                \n                if let dir = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first {\n                    let fileURL = dir.appendingPathComponent(file)\n                    do {\n                        try text.write(to: fileURL, atomically: false, encoding: .utf8)\n                    } catch {}\n                }\n                \n                guard let model = try? JSONDecoder().decode(StageOfflinePackageData.self, from: data) else { return }\n                \n                if endTimeStr != nil && (model.appProductVOList.count >= 1000 || model.appProductRelVOList.count >= 1000) {\n                    Defaults[key:DefaultsKeys.updateTime] = nil\n                    OfflinePackageManager.update(updateTime: \"\", successful: successful, failure: failure)\n                } else {\n                    if endTimeStr == nil {\n                        OfflinePackageManager.fullUpdate(model: model)\n                    } else {\n                        OfflinePackageManager.incrementalUpdate(model: model)\n                    }\n                    Defaults[key: DefaultsKeys.updateTime] = model.updateTime\n                    successful()\n                }\n            } else {\n                failure()\n            }\n        } failure: { _ in\n            failure()\n        }\n    }\n```\n\n## 6 解压缩字符串\n\n这里服务端返回的一段加密后的字符串：\n```Json\n{\n  \"message\" : \"请求成功\",\n  \"code\" : 1000,\n  \"data\" : \"H4sIAAAAAAAAAKtWSiwoCCjKTylNLglKzQnz98ksLlGyio7VQZJAFk3OzytJzQNyDA2NdJRKC1IS\\nS1JDMnNTlayUjAyMjHUNDHWNLBUMTaxMzaxMDJVqAQ0XaZphAAAA\"\n}\n```\n不过返回体还是json，我们先拿data里面的字符串。\n再去解压缩。\n\n字符串解压缩可以参考这篇文章：[https://www.cnblogs.com/strengthen/p/10844466.html](https://www.cnblogs.com/strengthen/p/10844466.html)\n\n这里我们用到了GzipSwift框架。\n\n这个框架地址为：[https://github.com/1024jp/GzipSwift](https://github.com/1024jp/GzipSwift) 还是有挺多人star的。\n\n具体细节就不讲解了。\n\n这里我们自己给String做了一个扩展，这样直接能拿到解压缩后的字符串：\n```Swift\nextension String {\n    var gunzip: String? {\n        if let data = Data(base64Encoded: self, options: .ignoreUnknownCharacters) {\n            if data.isGzipped {\n                if let gun = try? data.gunzipped() {\n                    return String(data: gun, encoding: String.Encoding.utf8)\n                }\n            }\n        }\n        return nil\n    }\n}\n```\n\n这里解析后的字符串为：\n```Json\n{\n    \"appProductRelVOList\":[],\n    \"appProductVOList\":[],\n    \"content\":112,\n    \"updateTime\":\"2023-01-29 14:56:41\"\n}\n```\n\n同样也是一个json数组哦。\n所以我们还是得用Json解析下：\n```Swift\nguard let model = try? JSONDecoder().decode(StageOfflinePackageData.self, from: data)\n                else { return }\n```\n\n这时候我们需要一个实体来接收下：\n```Swift\nclass StageOfflinePackageData:Codable{\n    \n    var appProductVOList: [StageGoodsPackgeModelData] = []\n    \n    var appProductRelVOList: [StageGoodsSuitPackgeModelData] = []\n    \n    var updateTime: String = \"\"\n    \n    \n    private enum Codingkeys: String, CodingKey{\n        case appProductVOList,appProductRelVOList,updateTime\n    }\n    \n    func encode(to encoder: Encoder) throws {}\n    \n    required init(from decoder: Decoder) throws {\n        let values = try decoder.container(keyedBy: Codingkeys.self)\n        appProductVOList = try values.decode(Array.self, forKey: .appProductVOList)\n        appProductRelVOList = try values.decode(Array.self, forKey: .appProductRelVOList)\n        updateTime = try values.decode(String.self, forKey: .updateTime)\n    }\n}\n```\n为啥要继承Codable呢？\nCodable 协议在 Swift4.0 开始被引入，目标是取代现有的 NSCoding 协议，它对结构体，枚举和类都支持。Codable 的引入简化了JSON 和 Swift 类型之间相互转换的难度，能够把 JSON 这种弱类型数据转换成代码中使用的强类型数据。具体可以看这篇文章：[https://juejin.cn/post/6971997599725256734](https://juejin.cn/post/6971997599725256734)。\n\n\n解析后就拿到服务端的数据了，可能是增量数据，可能是全量数据。后面我们具体分析下。\n\n\n## 7 数据处理\n\n解析完毕后，我们有一段逻辑是这样的：\n```Swift\nif endTimeStr != nil && (model.appProductVOList.count >= 1000 || model.appProductRelVOList.count >= 1000) {\n                    Defaults[key:DefaultsKeys.updateTime] = nil\n                    OfflinePackageManager.update(updateTime: \"\", successful: successful, failure: failure)\n                } else {\n                    if endTimeStr == nil {\n                        OfflinePackageManager.fullUpdate(model: model)\n                    } else {\n                        OfflinePackageManager.incrementalUpdate(model: model)\n                    }\n                    Defaults[key: DefaultsKeys.updateTime] = model.updateTime\n                    successful()\n                }\n```\n\n这里如果数据大于1000条，我们重新走全量更新接口。\n如果上次更新时间为空，我们默认为全量更新，将所有数据插入数据库。\n如果上次更新时间不为空，而且小于1000条，我们就走增量更新逻辑。\n\n### 7.1 Model层定义\n\n这里是定义的Realm的基础模型。\n\n我们需要定义两个实体，一个是商品模型，一个是关系模型。\n\n商品模型为：\n```Swift\n\nclass StageGoodsPackgeModelData: Object,Codable{\n    \n    @objc dynamic var barcode: String = \"\"\n    @objc dynamic var brand: String = \"\"\n    @objc dynamic var brandId: String = \"\"\n    @objc dynamic var category: String = \"\"\n    @objc dynamic var categoryId: Int = 0\n    @objc dynamic var createBy: String = \"\"\n    @objc dynamic var createTime: String = \"\"\n    @objc dynamic var delFlag: Int = 0\n    @objc dynamic var groupNum: Int = 1         //返回为\"\"时服务器需要传1\n    @objc dynamic var id: String = \"\"\n    @objc dynamic var isGreeProduct: Bool = false\n    @objc dynamic var isGroupedProduct: Bool = false\n    @objc dynamic var isSaleProduct: Bool = false\n    @objc dynamic var length: Double = 0.0\n    @objc dynamic var name: String = \"\"\n    @objc dynamic var orgId: String = \"\"\n    @objc dynamic var skuCode: String = \"\"\n    @objc dynamic var tall: Double = 0\n    @objc dynamic var unit: String = \"\"\n    @objc dynamic var updateBy: String = \"\"\n    @objc dynamic var updateTime: String = \"\"\n    @objc dynamic var volume: Double = 0.0\n    @objc dynamic var weight: Double = 0.0\n    @objc dynamic var wide: Double = 0.0\n    @objc dynamic var isMarketingProduct :Bool = false\n    \n    private enum Codingkeys: String, CodingKey{\n        case barcode\n        ,brand\n        ,brandId\n        ,category\n        ,categoryId\n        ,createBy\n        ,createTime\n        ,delFlag\n        ,groupNum\n        ,id\n        ,isGreeProduct\n        ,isGroupedProduct\n        ,isSaleProduct\n        ,length\n        ,name\n        ,orgId\n        ,skuCode\n        ,tall\n        ,unit\n        ,updateBy\n        ,updateTime\n        ,volume\n        ,weight\n        ,wide,\n        isMarketingProduct\n    }\n    \n    \n    required init(from decoder: Decoder) throws {\n        let values = try decoder.container(keyedBy: Codingkeys.self)\n        \n        do {\n            barcode = try values.decode(String.self, forKey: .barcode)\n        } catch {\n            barcode = \"\"\n        }\n        do {\n            brand = try values.decode(String.self, forKey: .brand)\n        } catch {\n            brand = \"\"\n        }\n        do {\n            brandId = try values.decode(String.self, forKey: .brandId)\n        } catch {\n            brandId = \"\"\n        }\n        do {\n            category = try values.decode(String.self, forKey: .category)\n        } catch {\n            category = \"\"\n        }\n        do {\n            categoryId = try values.decode(Int.self, forKey: .categoryId)\n        } catch {\n            categoryId = 0\n        }\n        do {\n            createBy = try values.decode(String.self, forKey: .createBy)\n        } catch {\n            createBy = \"\"\n        }\n        do {\n            createTime = try values.decode(String.self, forKey: .createTime)\n        } catch {\n            createTime = \"\"\n        }\n        do {\n            delFlag = try values.decode(Int.self, forKey: .delFlag)\n        } catch {\n            delFlag = 0\n        }\n        do {\n            groupNum = try values.decode(Int.self, forKey: .groupNum)\n        } catch {\n            groupNum = 1\n        }\n        do {\n            id = try values.decode(String.self, forKey: .id)\n        } catch {\n            id = \"\"\n        }\n        do {\n            isGreeProduct = try values.decode(Bool.self, forKey: .isGreeProduct)\n        } catch {\n            isGreeProduct = false\n        }\n        do {\n            isGroupedProduct = try values.decode(Bool.self, forKey: .isGroupedProduct)\n        } catch {\n            isGroupedProduct = false\n        }\n        do {\n            isSaleProduct = try values.decode(Bool.self, forKey: .isSaleProduct)\n        } catch {\n            isSaleProduct = false\n        }\n        do {\n            length = try values.decode(CGFloat.self, forKey: .length)\n        } catch {\n            length = 0.0\n        }\n        do {\n            name = try values.decode(String.self, forKey: .name)\n        } catch {\n            name = \"\"\n        }\n        do {\n            orgId = try values.decode(String.self, forKey: .orgId)\n        } catch {\n            orgId = \"\"\n        }\n        do {\n            skuCode = try values.decode(String.self, forKey: .skuCode)\n        } catch {\n            skuCode = \"\"\n        }\n        do {\n            tall = try values.decode(Double.self, forKey: .tall)\n        } catch {\n            tall = 0\n        }\n        do {\n            unit = try values.decode(String.self, forKey: .unit)\n        } catch {\n            unit = \"\"\n        }\n        do {\n            updateBy =  try values.decode(String.self, forKey: .updateBy)\n        } catch {\n            updateBy = \"\"\n        }\n        do {\n            updateTime = try values.decode(String.self, forKey: .updateTime)\n        } catch {\n            updateTime = \"\"\n        }\n        do {\n            volume = try values.decode(Double.self, forKey: .volume)\n        } catch {\n            volume = 0.0\n        }\n        do {\n            weight = try values.decode(Double.self, forKey: .weight)\n        } catch {\n            weight = 0.0\n        }\n        do {\n            wide = try values.decode(Double.self, forKey: .wide)\n        } catch {\n            wide = 0.0\n        }\n        do {\n            isMarketingProduct = try values.decode(Bool.self, forKey: .isMarketingProduct)\n        } catch {\n            isMarketingProduct = false\n        }\n    }\n    \n    func encode(to encoder: Encoder) throws {}\n    \n    override required init(){}\n}\n```\n\n另外一个为：\n```Swift\n\nclass StageGoodsSuitPackgeModelData: Object,Codable{\n\n    @objc dynamic var groupNum: Int = 0\n    @objc dynamic var id: String = \"\"\n    @objc dynamic var orgId: String = \"\"\n    @objc dynamic var productId: String = \"\"\n    @objc dynamic var subProductId: String = \"\"\n    \n    private enum Codingkeys: String, CodingKey {\n        case groupNum\n        case id\n        case orgId\n        case productId\n        case subProductId\n    }\n\n    required init(from decoder: Decoder) throws {\n        let values = try decoder.container(keyedBy: Codingkeys.self)\n        \n        do {\n            groupNum = try values.decode(Int.self, forKey: .groupNum)\n        } catch {\n            groupNum = 0\n        }\n        do {\n            id = try values.decode(String.self, forKey: .id)\n        } catch {\n            id = \"\"\n        }\n        do {\n            orgId = try values.decode(String.self, forKey: .orgId)\n        } catch {\n            orgId = \"\"\n        }\n        do {\n            productId = try values.decode(String.self, forKey: .productId)\n        } catch {\n            productId = \"\"\n        }\n        do {\n            subProductId = try values.decode(String.self, forKey: .subProductId)\n        } catch {\n            subProductId = \"\"\n        }\n    }\n\n    func encode(to encoder: Encoder) throws {}\n    \n    override required init(){}\n}\n```\n\n### 7.2 全量更新\n\n```Swift\nprivate class func fullUpdate(model: StageOfflinePackageData) {\n        let suitResult = objectWithAll(objct: StageGoodsPackgeModelData.self)\n        if suitResult.count != 0 {\n            deleteList(suitResult) {\n                print(\"StageGoodsPackgeModelData表数据清除成功\")\n            }\n        }\n        addList(model.appProductVOList) {\n            print(\"StageGoodsPackgeModelData 插入成功\")\n        }\n        \n        let relationResult = objectWithAll(objct: StageGoodsSuitPackgeModelData.self)\n        if relationResult.count != 0 {\n            deleteList(relationResult) {\n                print(\"StageGoodsSuitPackgeModelData表数据清除成功\")\n            }\n        }\n        addList(model.appProductRelVOList) {\n            print(\"StageGoodsSuitPackgeModelData 插入成功\")\n        }\n    }\n```\n如果是全量更新就比较简单了。\n先把之前的那两个删除掉，然后新增新的model就好了。\n\n### 7.3 增量更新\n\n先声明一下sql\n```Swift\n    private class func incrementalUpdate(model: StageOfflinePackageData) {\n        print(\"增量处理开始时间---->\", Date().currentTime(0))\n        var addGoodsArr: [StageGoodsPackgeModelData] = []\n        var addRelationsArr: [StageGoodsSuitPackgeModelData] = []\n        var relationidArr: [String] = []\n        \n        var goodsSql = \"\"\n        var relationSql = \"\"\n        var deleteGoodsSql = \"\"\n        var deleteRelationSql = \"\"\n```\n\n遍历下服务端返回的增量数据库：\n```Swift\nfor (_,suitModel) in model.appProductVOList.enumerated() {\n    // delFlag为0表示，不是删除哦，这里是新增商品\n    if suitModel.delFlag == 0 {\n        if goodsSql == \"\" {\n            let str1 = String(format:\"id = '%@'\", suitModel.id)\n            let str2 = String(format:\"productId = '%@'\", suitModel.id)\n            goodsSql.append(str1)\n            relationSql.append(str2)\n        } else {\n            let str1 = String(format:\"|| id = '%@'\", suitModel.id)\n            let str2 = String(format:\"|| productId = '%@'\", suitModel.id)\n            goodsSql.append(str1)\n            relationSql.append(str2)\n        }\n        addGoodsArr.append(suitModel)\n        relationidArr.append(suitModel.id)\n    } else {\n        // delFlag为1表示删除了商品\n        if deleteGoodsSql == \"\" {\n            let str1 = String(format:\"id = '%@'\", suitModel.id)\n            let str2 = String(format:\"productId = '%@'\", suitModel.id)\n            deleteGoodsSql.append(str1)\n            deleteRelationSql.append(str2)\n        } else {\n            let str1 = String(format:\"|| id = '%@'\", suitModel.id)\n            let str2 = String(format:\"|| productId = '%@'\", suitModel.id)\n            deleteGoodsSql.append(str1)\n            deleteRelationSql.append(str2)\n        }\n    }\n}\n```\n有个一个delFlag变量，就是表示是否删除的意思。\n如果是删除的话，将sql组合一下，就成为 id = '12' || id = '13' || id = '14' 这种。关系表就是 productId = '12' || productId = '14' 这种。\n\n\n这里就知道哪些商品要删除，哪些要加。哪些关系表要删除，哪些要加。\n\n这里先处理下新增的商品：\n```Swift\nif goodsSql != \"\" {\n    let predicate = NSPredicate(format:goodsSql)\n    let suitArr = objectsWithPredicate(object: StageGoodsPackgeModelData.self, predicate: predicate)\n    // 这里需要把可能之前存在相同的去掉\n    deleteList(suitArr){\n        print(\"删除商品成功\")\n    }\n    if addGoodsArr.count != 0 {\n        addList(addGoodsArr){\n            print(\"增量更新商品数据成功\")\n        }\n    }\n}\n```\n这里用了系统的NSPredicate类来组合sql语句。它其实是用来过滤数据的类。\n使用方法可以参考这篇文章：[https://juejin.cn/post/6844903540805074951](https://juejin.cn/post/6844903540805074951)。\n\n然后处理下要删除的商品：\n```Swift\n if deleteGoodsSql != \"\" {\n    // NSPredicate是swift 过滤数据的类，类似数据库中的where字段\n    let predicate = NSPredicate(format:deleteGoodsSql)\n    let suitArr = objectsWithPredicate(object: StageGoodsPackgeModelData.self, predicate: predicate)\n    deleteList(suitArr){\n        print(\"删除商品成功\")\n    }\n}\n```\n\n商品处理完成，剩下就是关系表了。\n\n这里先处理要新增的关系：\n```Swift\n// 这里是新增的关系表\nfor idStr in relationidArr {\n    for relationModel in model.appProductRelVOList{\n        if idStr == relationModel.productId {\n            addRelationsArr.append(relationModel)\n        }\n    }\n}\n\n// 新增的关系表\nif relationSql != \"\" {\n    let relationPredicate = NSPredicate(format:relationSql)\n    let relationArr = objectsWithPredicate(object: StageGoodsSuitPackgeModelData.self, predicate: relationPredicate)\n    deleteList(relationArr){\n        print(\"删除套机关系模型成功\")\n    }\n    if addRelationsArr.count != 0 {\n        addList(addRelationsArr){\n            print(\"增量更新套机关系模型成功\")\n        }\n    }\n}\n```\n\n然后处理下要删除的关系表：\n```Swift\n if deleteRelationSql != \"\" {\n    let relationPredicate = NSPredicate(format:deleteRelationSql)\n    let relationArr = objectsWithPredicate(object: StageGoodsSuitPackgeModelData.self, predicate: relationPredicate)\n    deleteList(relationArr){\n        print(\"删除套机关系模型成功\")\n    }\n}\n```\n\n这样增量数据就成功插入了。\n\n## 8 预览realm数据库\n\n插入数据成功后，我们可以用 Realm Studio 来预览数据。\n上面有讲解如何使用这个可视化工具。\n\n这里我们就看下最终的结果吧：\n<img src=realm1.png>\n<img src=realm2.png>\n\n## 9 总结\n\n* iOS数据库可以考虑使用realm数据库，这个是跨平台，Android也有相应的三方库，使用非常简洁，可以考虑。\n\n* 对于大量数据，我们务必要注意数据的修改，新增，最好采用增量更新的方式，而且如果全量，最好是先压缩下，减小对网络依赖。\n\n* realm数据库要注意数据库迁移的问题，升级的问题，使用前需要configRealm。\n\n* 真机预览realm数据库可以使用Realm Studio。\n\n* 增量更新一定要注意删除之前的记录，否则数据会很紊乱。\n","slug":"iOS-swift-数据库realm实践","published":1,"updated":"2023-02-01T07:12:25.200Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlc01je000ojhv7367k55xj","content":"<h2 id=\"1-需求定义\"><a href=\"#1-需求定义\" class=\"headerlink\" title=\"1 需求定义\"></a>1 需求定义</h2><p>需要获取服务端的条码数据库，存放到本地数据库。</p>\n<p>背景：集成了扫码功能，扫到的条码头需要匹配数据库中的条码列表，可以认为这个是一个离线数据库。不会实时判断，因为条码很多，这里先获取所有的条码，存放到本地数据库。然后扫码就按照数据库中的关系表来匹配就好了。</p>\n<p>这里我们有两个表，一个商品库表，一个是关系表。为什么有2个表呢？因为我们有配套的关系，2个零件可以看做单个商品，他们组合了也可以看成单独商品哦，这种就是套机了。想必做个电商的人都懂这个道理。比如可以买一件上衣，一条裤子，它们都是独立商品，也可以配套组合一套商品，而且这一套也可以认为是一个商品。</p>\n<h2 id=\"2-需求分析\"><a href=\"#2-需求分析\" class=\"headerlink\" title=\"2 需求分析\"></a>2 需求分析</h2><p>这里我们采用 realm数据库。<br>realm非常简介，效率也是不错的。<br>github地址：<a href=\"https://github.com/realm/realm-swift\">https://github.com/realm/realm-swift</a></p>\n<p>简单描述下realm吧：Realm 是一个跨平台的移动数据库引擎，其性能要优于 Core Data 和 FMDB - 移动端数据库性能比较, 我们可以在 Android 端 realm-java，iOS端:Realm-Cocoa，同时支持 OC 和 Swift两种语言开发。其使用简单，免费，性能优异，跨平台的特点广受关注。</p>\n<p>这里我们会用到2个表。</p>\n<p>因为这是个离线数据库，我们需要考虑数据库变更，与服务端同步问题。<br>所以我们需要一个接口，判断有无新增或者变更的数据。</p>\n<p>需要考虑到增量更新，同时如果数据变更大于一个阙值，比如1000条数据，我们可以认为是全量更新。这时候全量更新的时间和增量插入数据时间几乎相同。</p>\n<p>另外如果第一次获取数据，数据量可能会很大，我们需要考虑压缩，与服务端商议，将json数据压缩，然后我们自行解析为实体类。</p>\n<p>另外增量更新的时候，要特别注意改数据是删除了还是新增的，还是变更的。<br>如果商品删除了，关系表也是要删除的哦。这点很重要，不然后期会导致匹配异常。</p>\n<h2 id=\"3-准备工作，会用Realm\"><a href=\"#3-准备工作，会用Realm\" class=\"headerlink\" title=\"3 准备工作，会用Realm\"></a>3 准备工作，会用Realm</h2><p>因为是从0开始，建议熟悉一下Realm使用方法。<br>可以参考下这篇博客：<a href=\"https://juejin.cn/post/6844904117442215944\">https://juejin.cn/post/6844904117442215944</a>,写得还是相当不错，有Demo，讲述得非常清晰易懂。</p>\n<p>这里就不讲解如何引用这个Realm了。</p>\n<p>这里需要会用一个工具：Realm Studio，<br>下载地址：<a href=\"https://www.mongodb.com/docs/realm/studio/install/\">https://www.mongodb.com/docs/realm/studio/install/</a><br>这里按照自己电脑版本下载相应软件就好了，这个也是免费的。</p>\n<p>如何分析真机里面的realm数据库呢？<br>可以参考下：<a href=\"https://blog.csdn.net/asfasnjn/article/details/124714242\">https://blog.csdn.net/asfasnjn/article/details/124714242</a> 很简单，打开XCode的window下的设备和模拟器，再 点击更多图标，再下载Container，然后下载后，查看包内容，就可以看到这个应用的realm文件了。然后可以右键，用我们下载好的Realm Studio来查看这个文件，文件以表格形式展示，清晰直观。</p>\n<h2 id=\"4-初始化配置数据库\"><a href=\"#4-初始化配置数据库\" class=\"headerlink\" title=\"4 初始化配置数据库\"></a>4 初始化配置数据库</h2><p>这里需要在AppDelegate中配置下realm数据库。<br>很简单的。<br>不过我们没有在AppDelegate初始化，因为我们这个绑定了userId，等用户登录后才初始化，当然也是可以的。</p>\n<p>重点是初始化这个动作要先于使用就行了。</p>\n<pre><code class=\"line-numbers language-Swift\">func configRealm(userID: String?,\n                        keyWord: String? = nil,\n                        schemaVersion: UInt64 = 2, migrationBlock: MigrationBlock? = nil) &#123;\n    // 加密串128位结果为：464e5774625e64306771702463336e316a4074487442325145766477335e21346b715169364c406c6a4976346d695958396245346e356f6a62256d2637566126\n    // let key: Data = &quot;FNWtb^d0gqp$c3n1j@tHtB2QEvdw3^!4kqQi6L@ljIv4miYX9bE4n5ojb%m&amp;7Va&amp;&quot;.data(using: .utf8, allowLossyConversion: false)!\n    // 加密的key\n    // let key: Data = keyWord.data(using: .utf8, allowLossyConversion: false)!\n    // 打开加密文件\n    // (encryptionKey: key)\n    // 使用默认的目录，但是使用用户 ID 来替换默认的文件名\n    \n    //schemaVersion 数据库版本号从0开始\n    let manager = FileManager.default\n    let document = manager.urls(for: .documentDirectory, in: .userDomainMask)\n    let url = document[0] as URL\n    let urlStr = url.absoluteString\n    let path = urlStr + &quot;/&quot; + (&quot;\\(userID!).realm&quot;)\n    let config = Realm.Configuration(fileURL: URL(string: path), schemaVersion: schemaVersion, migrationBlock: &#123; (migration, oldSchemaVersion) in\n        // 目前我们还未进行数据迁移，因此 oldSchemaVersion == 0\n        if oldSchemaVersion &lt; 100 &#123;\n            // 什么都不要做！Realm 会自行检测新增和需要移除的属性，然后自动更新硬盘上的数据库架构\n            // 属性重命名  migration.renameProperty(onType: Person.className(), from: &quot;yearsSinceBirth&quot;, to: &quot;age&quot;)\n            print(oldSchemaVersion)\n            print(&quot;end&quot;)\n        &#125;\n        // 低版本的数据库迁移......\n        if migrationBlock != nil &#123;\n            migrationBlock!(migration, oldSchemaVersion)\n        &#125;\n    &#125;)\n    // 告诉 Realm 为默认的 Realm 数据库使用这个新的配置对象\n    Realm.Configuration.defaultConfiguration = config\n    guard let realm = try? Realm(configuration: config) else &#123;\n        return\n    &#125;\n    currentSchemaVersion = schemaVersion\n    currentRealm = realm\n    currentKeyWord = keyWord\n&#125;\n</code></pre>\n<p>这个realm实际上以userId为名称了。<br>这样就有个弊端了，切换用户后，需要重新下载数据库，特别是数据库特别大的情况下，这对用户体验不是特别好。</p>\n<h2 id=\"5-走接口拿数据\"><a href=\"#5-走接口拿数据\" class=\"headerlink\" title=\"5 走接口拿数据\"></a>5 走接口拿数据</h2><p>这里就是拿商品数据了，这里服务端提供的接口，返回的是加密后的字符串。<br>类似这样：</p>\n<pre><code class=\"line-numbers language-Json\">&#123;\n  &quot;message&quot; : &quot;请求成功&quot;,\n  &quot;code&quot; : 1000,\n  &quot;data&quot; : &quot;H4sIAAAAAAAAAKtWSiwoCCjKTylNLglKzQnz98ksLlGyio7VQZJAFk3OzytJzQ\n  NyDA2NdJRKC1IS\\nS1JDMnNTlayUjAyMjHUNDHWNLBUMTaxMzaxMDJVqAQ0XaZphAAAA&quot;\n&#125;\n</code></pre>\n<p>比如我们接口是这样请求的，这里我们先扩展了一个方法给控制器：</p>\n<pre><code class=\"line-numbers language-Swift\">extension GMBaseViewController &#123;\n    \n    open func updateOfflinePackageData(tips: String = &quot;&quot;, successful: @escaping Handler) &#123;\n        MBProgressHUD.showMessage(tips)\n        OfflinePackageManager.update &#123;\n            successful()\n            MBProgressHUD.hide()\n            MBProgressHUD.hide()\n        &#125; failure: &#123;\n            MBProgressHUD.hide()\n            MBProgressHUD.hide()\n            let alerVC = UIAlertController(\n                title: &quot;&quot;,\n                message: &quot;检测到商品信息变动，系统为您自动更新商品信息失败，请在网络良好的环境下，手动更新商品信息&quot;,\n                preferredStyle: .alert\n            )\n            alerVC.addAction(\n                UIAlertAction(\n                    title: &quot;下载商品信息&quot;,\n                    style: .default\n                ) &#123; (action) in\n                    self.updateOfflinePackageData(successful: successful)\n                &#125;\n            )\n            self.present(alerVC, animated: true, completion:nil)\n        &#125;\n        \n    &#125;\n    \n&#125;\n</code></pre>\n<p>这里我们的OfflinePackageManager就是我们封装好的专门去下载离线库的工具类。<br>成功后走successful的逃逸闭包，失败弹一个弹框。</p>\n<p>继续走进去：</p>\n<pre><code class=\"line-numbers language-Swift\">class OfflinePackageManager: NSObject &#123;\n    \n    open class func update(\n        updateTime: String = Defaults[key: DefaultsKeys.updateTime] ?? &quot;&quot;,\n        successful: @escaping Handler,\n        failure: @escaping Handler\n    ) &#123;\n        let endTimeStr = Defaults[key: DefaultsKeys.updateTime]\n        let updateTimeStr = updateTime\n       \n        productProvider.requestJson(.getProductMetadataForAPP(updateTime: updateTimeStr)) &#123; response in\n            let jsonString = JSON(rawValue: response).jsonString\n            let result = GMBaseRequestModel.deserialize(from: jsonString)\n            if result?.code == 1000 &#123;\n                guard let data = result?.data?.gunzip?.data(using: .utf8) else &#123; return &#125;\n                \n                let file = &quot;zpi_offline_package_data.txt&quot;\n                let text = result?.data?.gunzip ?? &quot;&quot;\n                \n                if let dir = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first &#123;\n                    let fileURL = dir.appendingPathComponent(file)\n                    do &#123;\n                        try text.write(to: fileURL, atomically: false, encoding: .utf8)\n                    &#125; catch &#123;&#125;\n                &#125;\n                \n                guard let model = try? JSONDecoder().decode(StageOfflinePackageData.self, from: data) else &#123; return &#125;\n                \n                if endTimeStr != nil &amp;&amp; (model.appProductVOList.count &gt;= 1000 || model.appProductRelVOList.count &gt;= 1000) &#123;\n                    Defaults[key:DefaultsKeys.updateTime] = nil\n                    OfflinePackageManager.update(updateTime: &quot;&quot;, successful: successful, failure: failure)\n                &#125; else &#123;\n                    if endTimeStr == nil &#123;\n                        OfflinePackageManager.fullUpdate(model: model)\n                    &#125; else &#123;\n                        OfflinePackageManager.incrementalUpdate(model: model)\n                    &#125;\n                    Defaults[key: DefaultsKeys.updateTime] = model.updateTime\n                    successful()\n                &#125;\n            &#125; else &#123;\n                failure()\n            &#125;\n        &#125; failure: &#123; _ in\n            failure()\n        &#125;\n    &#125;\n</code></pre>\n<h2 id=\"6-解压缩字符串\"><a href=\"#6-解压缩字符串\" class=\"headerlink\" title=\"6 解压缩字符串\"></a>6 解压缩字符串</h2><p>这里服务端返回的一段加密后的字符串：</p>\n<pre><code class=\"line-numbers language-Json\">&#123;\n  &quot;message&quot; : &quot;请求成功&quot;,\n  &quot;code&quot; : 1000,\n  &quot;data&quot; : &quot;H4sIAAAAAAAAAKtWSiwoCCjKTylNLglKzQnz98ksLlGyio7VQZJAFk3OzytJzQNyDA2NdJRKC1IS\\nS1JDMnNTlayUjAyMjHUNDHWNLBUMTaxMzaxMDJVqAQ0XaZphAAAA&quot;\n&#125;\n</code></pre>\n<p>不过返回体还是json，我们先拿data里面的字符串。<br>再去解压缩。</p>\n<p>字符串解压缩可以参考这篇文章：<a href=\"https://www.cnblogs.com/strengthen/p/10844466.html\">https://www.cnblogs.com/strengthen/p/10844466.html</a></p>\n<p>这里我们用到了GzipSwift框架。</p>\n<p>这个框架地址为：<a href=\"https://github.com/1024jp/GzipSwift\">https://github.com/1024jp/GzipSwift</a> 还是有挺多人star的。</p>\n<p>具体细节就不讲解了。</p>\n<p>这里我们自己给String做了一个扩展，这样直接能拿到解压缩后的字符串：</p>\n<pre><code class=\"line-numbers language-Swift\">extension String &#123;\n    var gunzip: String? &#123;\n        if let data = Data(base64Encoded: self, options: .ignoreUnknownCharacters) &#123;\n            if data.isGzipped &#123;\n                if let gun = try? data.gunzipped() &#123;\n                    return String(data: gun, encoding: String.Encoding.utf8)\n                &#125;\n            &#125;\n        &#125;\n        return nil\n    &#125;\n&#125;\n</code></pre>\n<p>这里解析后的字符串为：</p>\n<pre><code class=\"line-numbers language-Json\">&#123;\n    &quot;appProductRelVOList&quot;:[],\n    &quot;appProductVOList&quot;:[],\n    &quot;content&quot;:112,\n    &quot;updateTime&quot;:&quot;2023-01-29 14:56:41&quot;\n&#125;\n</code></pre>\n<p>同样也是一个json数组哦。<br>所以我们还是得用Json解析下：</p>\n<pre><code class=\"line-numbers language-Swift\">guard let model = try? JSONDecoder().decode(StageOfflinePackageData.self, from: data)\n                else &#123; return &#125;\n</code></pre>\n<p>这时候我们需要一个实体来接收下：</p>\n<pre><code class=\"line-numbers language-Swift\">class StageOfflinePackageData:Codable&#123;\n    \n    var appProductVOList: [StageGoodsPackgeModelData] = []\n    \n    var appProductRelVOList: [StageGoodsSuitPackgeModelData] = []\n    \n    var updateTime: String = &quot;&quot;\n    \n    \n    private enum Codingkeys: String, CodingKey&#123;\n        case appProductVOList,appProductRelVOList,updateTime\n    &#125;\n    \n    func encode(to encoder: Encoder) throws &#123;&#125;\n    \n    required init(from decoder: Decoder) throws &#123;\n        let values = try decoder.container(keyedBy: Codingkeys.self)\n        appProductVOList = try values.decode(Array.self, forKey: .appProductVOList)\n        appProductRelVOList = try values.decode(Array.self, forKey: .appProductRelVOList)\n        updateTime = try values.decode(String.self, forKey: .updateTime)\n    &#125;\n&#125;\n</code></pre>\n<p>为啥要继承Codable呢？<br>Codable 协议在 Swift4.0 开始被引入，目标是取代现有的 NSCoding 协议，它对结构体，枚举和类都支持。Codable 的引入简化了JSON 和 Swift 类型之间相互转换的难度，能够把 JSON 这种弱类型数据转换成代码中使用的强类型数据。具体可以看这篇文章：<a href=\"https://juejin.cn/post/6971997599725256734\">https://juejin.cn/post/6971997599725256734</a>。</p>\n<p>解析后就拿到服务端的数据了，可能是增量数据，可能是全量数据。后面我们具体分析下。</p>\n<h2 id=\"7-数据处理\"><a href=\"#7-数据处理\" class=\"headerlink\" title=\"7 数据处理\"></a>7 数据处理</h2><p>解析完毕后，我们有一段逻辑是这样的：</p>\n<pre><code class=\"line-numbers language-Swift\">if endTimeStr != nil &amp;&amp; (model.appProductVOList.count &gt;= 1000 || model.appProductRelVOList.count &gt;= 1000) &#123;\n                    Defaults[key:DefaultsKeys.updateTime] = nil\n                    OfflinePackageManager.update(updateTime: &quot;&quot;, successful: successful, failure: failure)\n                &#125; else &#123;\n                    if endTimeStr == nil &#123;\n                        OfflinePackageManager.fullUpdate(model: model)\n                    &#125; else &#123;\n                        OfflinePackageManager.incrementalUpdate(model: model)\n                    &#125;\n                    Defaults[key: DefaultsKeys.updateTime] = model.updateTime\n                    successful()\n                &#125;\n</code></pre>\n<p>这里如果数据大于1000条，我们重新走全量更新接口。<br>如果上次更新时间为空，我们默认为全量更新，将所有数据插入数据库。<br>如果上次更新时间不为空，而且小于1000条，我们就走增量更新逻辑。</p>\n<h3 id=\"7-1-Model层定义\"><a href=\"#7-1-Model层定义\" class=\"headerlink\" title=\"7.1 Model层定义\"></a>7.1 Model层定义</h3><p>这里是定义的Realm的基础模型。</p>\n<p>我们需要定义两个实体，一个是商品模型，一个是关系模型。</p>\n<p>商品模型为：</p>\n<pre><code class=\"line-numbers language-Swift\">\nclass StageGoodsPackgeModelData: Object,Codable&#123;\n    \n    @objc dynamic var barcode: String = &quot;&quot;\n    @objc dynamic var brand: String = &quot;&quot;\n    @objc dynamic var brandId: String = &quot;&quot;\n    @objc dynamic var category: String = &quot;&quot;\n    @objc dynamic var categoryId: Int = 0\n    @objc dynamic var createBy: String = &quot;&quot;\n    @objc dynamic var createTime: String = &quot;&quot;\n    @objc dynamic var delFlag: Int = 0\n    @objc dynamic var groupNum: Int = 1         //返回为&quot;&quot;时服务器需要传1\n    @objc dynamic var id: String = &quot;&quot;\n    @objc dynamic var isGreeProduct: Bool = false\n    @objc dynamic var isGroupedProduct: Bool = false\n    @objc dynamic var isSaleProduct: Bool = false\n    @objc dynamic var length: Double = 0.0\n    @objc dynamic var name: String = &quot;&quot;\n    @objc dynamic var orgId: String = &quot;&quot;\n    @objc dynamic var skuCode: String = &quot;&quot;\n    @objc dynamic var tall: Double = 0\n    @objc dynamic var unit: String = &quot;&quot;\n    @objc dynamic var updateBy: String = &quot;&quot;\n    @objc dynamic var updateTime: String = &quot;&quot;\n    @objc dynamic var volume: Double = 0.0\n    @objc dynamic var weight: Double = 0.0\n    @objc dynamic var wide: Double = 0.0\n    @objc dynamic var isMarketingProduct :Bool = false\n    \n    private enum Codingkeys: String, CodingKey&#123;\n        case barcode\n        ,brand\n        ,brandId\n        ,category\n        ,categoryId\n        ,createBy\n        ,createTime\n        ,delFlag\n        ,groupNum\n        ,id\n        ,isGreeProduct\n        ,isGroupedProduct\n        ,isSaleProduct\n        ,length\n        ,name\n        ,orgId\n        ,skuCode\n        ,tall\n        ,unit\n        ,updateBy\n        ,updateTime\n        ,volume\n        ,weight\n        ,wide,\n        isMarketingProduct\n    &#125;\n    \n    \n    required init(from decoder: Decoder) throws &#123;\n        let values = try decoder.container(keyedBy: Codingkeys.self)\n        \n        do &#123;\n            barcode = try values.decode(String.self, forKey: .barcode)\n        &#125; catch &#123;\n            barcode = &quot;&quot;\n        &#125;\n        do &#123;\n            brand = try values.decode(String.self, forKey: .brand)\n        &#125; catch &#123;\n            brand = &quot;&quot;\n        &#125;\n        do &#123;\n            brandId = try values.decode(String.self, forKey: .brandId)\n        &#125; catch &#123;\n            brandId = &quot;&quot;\n        &#125;\n        do &#123;\n            category = try values.decode(String.self, forKey: .category)\n        &#125; catch &#123;\n            category = &quot;&quot;\n        &#125;\n        do &#123;\n            categoryId = try values.decode(Int.self, forKey: .categoryId)\n        &#125; catch &#123;\n            categoryId = 0\n        &#125;\n        do &#123;\n            createBy = try values.decode(String.self, forKey: .createBy)\n        &#125; catch &#123;\n            createBy = &quot;&quot;\n        &#125;\n        do &#123;\n            createTime = try values.decode(String.self, forKey: .createTime)\n        &#125; catch &#123;\n            createTime = &quot;&quot;\n        &#125;\n        do &#123;\n            delFlag = try values.decode(Int.self, forKey: .delFlag)\n        &#125; catch &#123;\n            delFlag = 0\n        &#125;\n        do &#123;\n            groupNum = try values.decode(Int.self, forKey: .groupNum)\n        &#125; catch &#123;\n            groupNum = 1\n        &#125;\n        do &#123;\n            id = try values.decode(String.self, forKey: .id)\n        &#125; catch &#123;\n            id = &quot;&quot;\n        &#125;\n        do &#123;\n            isGreeProduct = try values.decode(Bool.self, forKey: .isGreeProduct)\n        &#125; catch &#123;\n            isGreeProduct = false\n        &#125;\n        do &#123;\n            isGroupedProduct = try values.decode(Bool.self, forKey: .isGroupedProduct)\n        &#125; catch &#123;\n            isGroupedProduct = false\n        &#125;\n        do &#123;\n            isSaleProduct = try values.decode(Bool.self, forKey: .isSaleProduct)\n        &#125; catch &#123;\n            isSaleProduct = false\n        &#125;\n        do &#123;\n            length = try values.decode(CGFloat.self, forKey: .length)\n        &#125; catch &#123;\n            length = 0.0\n        &#125;\n        do &#123;\n            name = try values.decode(String.self, forKey: .name)\n        &#125; catch &#123;\n            name = &quot;&quot;\n        &#125;\n        do &#123;\n            orgId = try values.decode(String.self, forKey: .orgId)\n        &#125; catch &#123;\n            orgId = &quot;&quot;\n        &#125;\n        do &#123;\n            skuCode = try values.decode(String.self, forKey: .skuCode)\n        &#125; catch &#123;\n            skuCode = &quot;&quot;\n        &#125;\n        do &#123;\n            tall = try values.decode(Double.self, forKey: .tall)\n        &#125; catch &#123;\n            tall = 0\n        &#125;\n        do &#123;\n            unit = try values.decode(String.self, forKey: .unit)\n        &#125; catch &#123;\n            unit = &quot;&quot;\n        &#125;\n        do &#123;\n            updateBy =  try values.decode(String.self, forKey: .updateBy)\n        &#125; catch &#123;\n            updateBy = &quot;&quot;\n        &#125;\n        do &#123;\n            updateTime = try values.decode(String.self, forKey: .updateTime)\n        &#125; catch &#123;\n            updateTime = &quot;&quot;\n        &#125;\n        do &#123;\n            volume = try values.decode(Double.self, forKey: .volume)\n        &#125; catch &#123;\n            volume = 0.0\n        &#125;\n        do &#123;\n            weight = try values.decode(Double.self, forKey: .weight)\n        &#125; catch &#123;\n            weight = 0.0\n        &#125;\n        do &#123;\n            wide = try values.decode(Double.self, forKey: .wide)\n        &#125; catch &#123;\n            wide = 0.0\n        &#125;\n        do &#123;\n            isMarketingProduct = try values.decode(Bool.self, forKey: .isMarketingProduct)\n        &#125; catch &#123;\n            isMarketingProduct = false\n        &#125;\n    &#125;\n    \n    func encode(to encoder: Encoder) throws &#123;&#125;\n    \n    override required init()&#123;&#125;\n&#125;\n</code></pre>\n<p>另外一个为：</p>\n<pre><code class=\"line-numbers language-Swift\">\nclass StageGoodsSuitPackgeModelData: Object,Codable&#123;\n\n    @objc dynamic var groupNum: Int = 0\n    @objc dynamic var id: String = &quot;&quot;\n    @objc dynamic var orgId: String = &quot;&quot;\n    @objc dynamic var productId: String = &quot;&quot;\n    @objc dynamic var subProductId: String = &quot;&quot;\n    \n    private enum Codingkeys: String, CodingKey &#123;\n        case groupNum\n        case id\n        case orgId\n        case productId\n        case subProductId\n    &#125;\n\n    required init(from decoder: Decoder) throws &#123;\n        let values = try decoder.container(keyedBy: Codingkeys.self)\n        \n        do &#123;\n            groupNum = try values.decode(Int.self, forKey: .groupNum)\n        &#125; catch &#123;\n            groupNum = 0\n        &#125;\n        do &#123;\n            id = try values.decode(String.self, forKey: .id)\n        &#125; catch &#123;\n            id = &quot;&quot;\n        &#125;\n        do &#123;\n            orgId = try values.decode(String.self, forKey: .orgId)\n        &#125; catch &#123;\n            orgId = &quot;&quot;\n        &#125;\n        do &#123;\n            productId = try values.decode(String.self, forKey: .productId)\n        &#125; catch &#123;\n            productId = &quot;&quot;\n        &#125;\n        do &#123;\n            subProductId = try values.decode(String.self, forKey: .subProductId)\n        &#125; catch &#123;\n            subProductId = &quot;&quot;\n        &#125;\n    &#125;\n\n    func encode(to encoder: Encoder) throws &#123;&#125;\n    \n    override required init()&#123;&#125;\n&#125;\n</code></pre>\n<h3 id=\"7-2-全量更新\"><a href=\"#7-2-全量更新\" class=\"headerlink\" title=\"7.2 全量更新\"></a>7.2 全量更新</h3><pre><code class=\"line-numbers language-Swift\">private class func fullUpdate(model: StageOfflinePackageData) &#123;\n        let suitResult = objectWithAll(objct: StageGoodsPackgeModelData.self)\n        if suitResult.count != 0 &#123;\n            deleteList(suitResult) &#123;\n                print(&quot;StageGoodsPackgeModelData表数据清除成功&quot;)\n            &#125;\n        &#125;\n        addList(model.appProductVOList) &#123;\n            print(&quot;StageGoodsPackgeModelData 插入成功&quot;)\n        &#125;\n        \n        let relationResult = objectWithAll(objct: StageGoodsSuitPackgeModelData.self)\n        if relationResult.count != 0 &#123;\n            deleteList(relationResult) &#123;\n                print(&quot;StageGoodsSuitPackgeModelData表数据清除成功&quot;)\n            &#125;\n        &#125;\n        addList(model.appProductRelVOList) &#123;\n            print(&quot;StageGoodsSuitPackgeModelData 插入成功&quot;)\n        &#125;\n    &#125;\n</code></pre>\n<p>如果是全量更新就比较简单了。<br>先把之前的那两个删除掉，然后新增新的model就好了。</p>\n<h3 id=\"7-3-增量更新\"><a href=\"#7-3-增量更新\" class=\"headerlink\" title=\"7.3 增量更新\"></a>7.3 增量更新</h3><p>先声明一下sql</p>\n<pre><code class=\"line-numbers language-Swift\">    private class func incrementalUpdate(model: StageOfflinePackageData) &#123;\n        print(&quot;增量处理开始时间----&gt;&quot;, Date().currentTime(0))\n        var addGoodsArr: [StageGoodsPackgeModelData] = []\n        var addRelationsArr: [StageGoodsSuitPackgeModelData] = []\n        var relationidArr: [String] = []\n        \n        var goodsSql = &quot;&quot;\n        var relationSql = &quot;&quot;\n        var deleteGoodsSql = &quot;&quot;\n        var deleteRelationSql = &quot;&quot;\n</code></pre>\n<p>遍历下服务端返回的增量数据库：</p>\n<pre><code class=\"line-numbers language-Swift\">for (_,suitModel) in model.appProductVOList.enumerated() &#123;\n    // delFlag为0表示，不是删除哦，这里是新增商品\n    if suitModel.delFlag == 0 &#123;\n        if goodsSql == &quot;&quot; &#123;\n            let str1 = String(format:&quot;id = &#39;%@&#39;&quot;, suitModel.id)\n            let str2 = String(format:&quot;productId = &#39;%@&#39;&quot;, suitModel.id)\n            goodsSql.append(str1)\n            relationSql.append(str2)\n        &#125; else &#123;\n            let str1 = String(format:&quot;|| id = &#39;%@&#39;&quot;, suitModel.id)\n            let str2 = String(format:&quot;|| productId = &#39;%@&#39;&quot;, suitModel.id)\n            goodsSql.append(str1)\n            relationSql.append(str2)\n        &#125;\n        addGoodsArr.append(suitModel)\n        relationidArr.append(suitModel.id)\n    &#125; else &#123;\n        // delFlag为1表示删除了商品\n        if deleteGoodsSql == &quot;&quot; &#123;\n            let str1 = String(format:&quot;id = &#39;%@&#39;&quot;, suitModel.id)\n            let str2 = String(format:&quot;productId = &#39;%@&#39;&quot;, suitModel.id)\n            deleteGoodsSql.append(str1)\n            deleteRelationSql.append(str2)\n        &#125; else &#123;\n            let str1 = String(format:&quot;|| id = &#39;%@&#39;&quot;, suitModel.id)\n            let str2 = String(format:&quot;|| productId = &#39;%@&#39;&quot;, suitModel.id)\n            deleteGoodsSql.append(str1)\n            deleteRelationSql.append(str2)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>有个一个delFlag变量，就是表示是否删除的意思。<br>如果是删除的话，将sql组合一下，就成为 id &#x3D; ‘12’ || id &#x3D; ‘13’ || id &#x3D; ‘14’ 这种。关系表就是 productId &#x3D; ‘12’ || productId &#x3D; ‘14’ 这种。</p>\n<p>这里就知道哪些商品要删除，哪些要加。哪些关系表要删除，哪些要加。</p>\n<p>这里先处理下新增的商品：</p>\n<pre><code class=\"line-numbers language-Swift\">if goodsSql != &quot;&quot; &#123;\n    let predicate = NSPredicate(format:goodsSql)\n    let suitArr = objectsWithPredicate(object: StageGoodsPackgeModelData.self, predicate: predicate)\n    // 这里需要把可能之前存在相同的去掉\n    deleteList(suitArr)&#123;\n        print(&quot;删除商品成功&quot;)\n    &#125;\n    if addGoodsArr.count != 0 &#123;\n        addList(addGoodsArr)&#123;\n            print(&quot;增量更新商品数据成功&quot;)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里用了系统的NSPredicate类来组合sql语句。它其实是用来过滤数据的类。<br>使用方法可以参考这篇文章：<a href=\"https://juejin.cn/post/6844903540805074951\">https://juejin.cn/post/6844903540805074951</a>。</p>\n<p>然后处理下要删除的商品：</p>\n<pre><code class=\"line-numbers language-Swift\"> if deleteGoodsSql != &quot;&quot; &#123;\n    // NSPredicate是swift 过滤数据的类，类似数据库中的where字段\n    let predicate = NSPredicate(format:deleteGoodsSql)\n    let suitArr = objectsWithPredicate(object: StageGoodsPackgeModelData.self, predicate: predicate)\n    deleteList(suitArr)&#123;\n        print(&quot;删除商品成功&quot;)\n    &#125;\n&#125;\n</code></pre>\n<p>商品处理完成，剩下就是关系表了。</p>\n<p>这里先处理要新增的关系：</p>\n<pre><code class=\"line-numbers language-Swift\">// 这里是新增的关系表\nfor idStr in relationidArr &#123;\n    for relationModel in model.appProductRelVOList&#123;\n        if idStr == relationModel.productId &#123;\n            addRelationsArr.append(relationModel)\n        &#125;\n    &#125;\n&#125;\n\n// 新增的关系表\nif relationSql != &quot;&quot; &#123;\n    let relationPredicate = NSPredicate(format:relationSql)\n    let relationArr = objectsWithPredicate(object: StageGoodsSuitPackgeModelData.self, predicate: relationPredicate)\n    deleteList(relationArr)&#123;\n        print(&quot;删除套机关系模型成功&quot;)\n    &#125;\n    if addRelationsArr.count != 0 &#123;\n        addList(addRelationsArr)&#123;\n            print(&quot;增量更新套机关系模型成功&quot;)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>然后处理下要删除的关系表：</p>\n<pre><code class=\"line-numbers language-Swift\"> if deleteRelationSql != &quot;&quot; &#123;\n    let relationPredicate = NSPredicate(format:deleteRelationSql)\n    let relationArr = objectsWithPredicate(object: StageGoodsSuitPackgeModelData.self, predicate: relationPredicate)\n    deleteList(relationArr)&#123;\n        print(&quot;删除套机关系模型成功&quot;)\n    &#125;\n&#125;\n</code></pre>\n<p>这样增量数据就成功插入了。</p>\n<h2 id=\"8-预览realm数据库\"><a href=\"#8-预览realm数据库\" class=\"headerlink\" title=\"8 预览realm数据库\"></a>8 预览realm数据库</h2><p>插入数据成功后，我们可以用 Realm Studio 来预览数据。<br>上面有讲解如何使用这个可视化工具。</p>\n<p>这里我们就看下最终的结果吧：<br><img src=realm1.png><br><img src=realm2.png></p>\n<h2 id=\"9-总结\"><a href=\"#9-总结\" class=\"headerlink\" title=\"9 总结\"></a>9 总结</h2><ul>\n<li><p>iOS数据库可以考虑使用realm数据库，这个是跨平台，Android也有相应的三方库，使用非常简洁，可以考虑。</p>\n</li>\n<li><p>对于大量数据，我们务必要注意数据的修改，新增，最好采用增量更新的方式，而且如果全量，最好是先压缩下，减小对网络依赖。</p>\n</li>\n<li><p>realm数据库要注意数据库迁移的问题，升级的问题，使用前需要configRealm。</p>\n</li>\n<li><p>真机预览realm数据库可以使用Realm Studio。</p>\n</li>\n<li><p>增量更新一定要注意删除之前的记录，否则数据会很紊乱。</p>\n</li>\n</ul>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-需求定义\"><a href=\"#1-需求定义\" class=\"headerlink\" title=\"1 需求定义\"></a>1 需求定义</h2><p>需要获取服务端的条码数据库，存放到本地数据库。</p>\n<p>背景：集成了扫码功能，扫到的条码头需要匹配数据库中的条码列表，可以认为这个是一个离线数据库。不会实时判断，因为条码很多，这里先获取所有的条码，存放到本地数据库。然后扫码就按照数据库中的关系表来匹配就好了。</p>\n<p>这里我们有两个表，一个商品库表，一个是关系表。为什么有2个表呢？因为我们有配套的关系，2个零件可以看做单个商品，他们组合了也可以看成单独商品哦，这种就是套机了。想必做个电商的人都懂这个道理。比如可以买一件上衣，一条裤子，它们都是独立商品，也可以配套组合一套商品，而且这一套也可以认为是一个商品。</p>\n<h2 id=\"2-需求分析\"><a href=\"#2-需求分析\" class=\"headerlink\" title=\"2 需求分析\"></a>2 需求分析</h2><p>这里我们采用 realm数据库。<br>realm非常简介，效率也是不错的。<br>github地址：<a href=\"https://github.com/realm/realm-swift\">https://github.com/realm/realm-swift</a></p>\n<p>简单描述下realm吧：Realm 是一个跨平台的移动数据库引擎，其性能要优于 Core Data 和 FMDB - 移动端数据库性能比较, 我们可以在 Android 端 realm-java，iOS端:Realm-Cocoa，同时支持 OC 和 Swift两种语言开发。其使用简单，免费，性能优异，跨平台的特点广受关注。</p>\n<p>这里我们会用到2个表。</p>\n<p>因为这是个离线数据库，我们需要考虑数据库变更，与服务端同步问题。<br>所以我们需要一个接口，判断有无新增或者变更的数据。</p>\n<p>需要考虑到增量更新，同时如果数据变更大于一个阙值，比如1000条数据，我们可以认为是全量更新。这时候全量更新的时间和增量插入数据时间几乎相同。</p>\n<p>另外如果第一次获取数据，数据量可能会很大，我们需要考虑压缩，与服务端商议，将json数据压缩，然后我们自行解析为实体类。</p>\n<p>另外增量更新的时候，要特别注意改数据是删除了还是新增的，还是变更的。<br>如果商品删除了，关系表也是要删除的哦。这点很重要，不然后期会导致匹配异常。</p>\n<h2 id=\"3-准备工作，会用Realm\"><a href=\"#3-准备工作，会用Realm\" class=\"headerlink\" title=\"3 准备工作，会用Realm\"></a>3 准备工作，会用Realm</h2><p>因为是从0开始，建议熟悉一下Realm使用方法。<br>可以参考下这篇博客：<a href=\"https://juejin.cn/post/6844904117442215944\">https://juejin.cn/post/6844904117442215944</a>,写得还是相当不错，有Demo，讲述得非常清晰易懂。</p>\n<p>这里就不讲解如何引用这个Realm了。</p>\n<p>这里需要会用一个工具：Realm Studio，<br>下载地址：<a href=\"https://www.mongodb.com/docs/realm/studio/install/\">https://www.mongodb.com/docs/realm/studio/install/</a><br>这里按照自己电脑版本下载相应软件就好了，这个也是免费的。</p>\n<p>如何分析真机里面的realm数据库呢？<br>可以参考下：<a href=\"https://blog.csdn.net/asfasnjn/article/details/124714242\">https://blog.csdn.net/asfasnjn/article/details/124714242</a> 很简单，打开XCode的window下的设备和模拟器，再 点击更多图标，再下载Container，然后下载后，查看包内容，就可以看到这个应用的realm文件了。然后可以右键，用我们下载好的Realm Studio来查看这个文件，文件以表格形式展示，清晰直观。</p>\n<h2 id=\"4-初始化配置数据库\"><a href=\"#4-初始化配置数据库\" class=\"headerlink\" title=\"4 初始化配置数据库\"></a>4 初始化配置数据库</h2><p>这里需要在AppDelegate中配置下realm数据库。<br>很简单的。<br>不过我们没有在AppDelegate初始化，因为我们这个绑定了userId，等用户登录后才初始化，当然也是可以的。</p>\n<p>重点是初始化这个动作要先于使用就行了。</p>\n<pre><code class=\"line-numbers language-Swift\">func configRealm(userID: String?,\n                        keyWord: String? = nil,\n                        schemaVersion: UInt64 = 2, migrationBlock: MigrationBlock? = nil) &#123;\n    // 加密串128位结果为：464e5774625e64306771702463336e316a4074487442325145766477335e21346b715169364c406c6a4976346d695958396245346e356f6a62256d2637566126\n    // let key: Data = &quot;FNWtb^d0gqp$c3n1j@tHtB2QEvdw3^!4kqQi6L@ljIv4miYX9bE4n5ojb%m&amp;7Va&amp;&quot;.data(using: .utf8, allowLossyConversion: false)!\n    // 加密的key\n    // let key: Data = keyWord.data(using: .utf8, allowLossyConversion: false)!\n    // 打开加密文件\n    // (encryptionKey: key)\n    // 使用默认的目录，但是使用用户 ID 来替换默认的文件名\n    \n    //schemaVersion 数据库版本号从0开始\n    let manager = FileManager.default\n    let document = manager.urls(for: .documentDirectory, in: .userDomainMask)\n    let url = document[0] as URL\n    let urlStr = url.absoluteString\n    let path = urlStr + &quot;/&quot; + (&quot;\\(userID!).realm&quot;)\n    let config = Realm.Configuration(fileURL: URL(string: path), schemaVersion: schemaVersion, migrationBlock: &#123; (migration, oldSchemaVersion) in\n        // 目前我们还未进行数据迁移，因此 oldSchemaVersion == 0\n        if oldSchemaVersion &lt; 100 &#123;\n            // 什么都不要做！Realm 会自行检测新增和需要移除的属性，然后自动更新硬盘上的数据库架构\n            // 属性重命名  migration.renameProperty(onType: Person.className(), from: &quot;yearsSinceBirth&quot;, to: &quot;age&quot;)\n            print(oldSchemaVersion)\n            print(&quot;end&quot;)\n        &#125;\n        // 低版本的数据库迁移......\n        if migrationBlock != nil &#123;\n            migrationBlock!(migration, oldSchemaVersion)\n        &#125;\n    &#125;)\n    // 告诉 Realm 为默认的 Realm 数据库使用这个新的配置对象\n    Realm.Configuration.defaultConfiguration = config\n    guard let realm = try? Realm(configuration: config) else &#123;\n        return\n    &#125;\n    currentSchemaVersion = schemaVersion\n    currentRealm = realm\n    currentKeyWord = keyWord\n&#125;\n</code></pre>\n<p>这个realm实际上以userId为名称了。<br>这样就有个弊端了，切换用户后，需要重新下载数据库，特别是数据库特别大的情况下，这对用户体验不是特别好。</p>\n<h2 id=\"5-走接口拿数据\"><a href=\"#5-走接口拿数据\" class=\"headerlink\" title=\"5 走接口拿数据\"></a>5 走接口拿数据</h2><p>这里就是拿商品数据了，这里服务端提供的接口，返回的是加密后的字符串。<br>类似这样：</p>\n<pre><code class=\"line-numbers language-Json\">&#123;\n  &quot;message&quot; : &quot;请求成功&quot;,\n  &quot;code&quot; : 1000,\n  &quot;data&quot; : &quot;H4sIAAAAAAAAAKtWSiwoCCjKTylNLglKzQnz98ksLlGyio7VQZJAFk3OzytJzQ\n  NyDA2NdJRKC1IS\\nS1JDMnNTlayUjAyMjHUNDHWNLBUMTaxMzaxMDJVqAQ0XaZphAAAA&quot;\n&#125;\n</code></pre>\n<p>比如我们接口是这样请求的，这里我们先扩展了一个方法给控制器：</p>\n<pre><code class=\"line-numbers language-Swift\">extension GMBaseViewController &#123;\n    \n    open func updateOfflinePackageData(tips: String = &quot;&quot;, successful: @escaping Handler) &#123;\n        MBProgressHUD.showMessage(tips)\n        OfflinePackageManager.update &#123;\n            successful()\n            MBProgressHUD.hide()\n            MBProgressHUD.hide()\n        &#125; failure: &#123;\n            MBProgressHUD.hide()\n            MBProgressHUD.hide()\n            let alerVC = UIAlertController(\n                title: &quot;&quot;,\n                message: &quot;检测到商品信息变动，系统为您自动更新商品信息失败，请在网络良好的环境下，手动更新商品信息&quot;,\n                preferredStyle: .alert\n            )\n            alerVC.addAction(\n                UIAlertAction(\n                    title: &quot;下载商品信息&quot;,\n                    style: .default\n                ) &#123; (action) in\n                    self.updateOfflinePackageData(successful: successful)\n                &#125;\n            )\n            self.present(alerVC, animated: true, completion:nil)\n        &#125;\n        \n    &#125;\n    \n&#125;\n</code></pre>\n<p>这里我们的OfflinePackageManager就是我们封装好的专门去下载离线库的工具类。<br>成功后走successful的逃逸闭包，失败弹一个弹框。</p>\n<p>继续走进去：</p>\n<pre><code class=\"line-numbers language-Swift\">class OfflinePackageManager: NSObject &#123;\n    \n    open class func update(\n        updateTime: String = Defaults[key: DefaultsKeys.updateTime] ?? &quot;&quot;,\n        successful: @escaping Handler,\n        failure: @escaping Handler\n    ) &#123;\n        let endTimeStr = Defaults[key: DefaultsKeys.updateTime]\n        let updateTimeStr = updateTime\n       \n        productProvider.requestJson(.getProductMetadataForAPP(updateTime: updateTimeStr)) &#123; response in\n            let jsonString = JSON(rawValue: response).jsonString\n            let result = GMBaseRequestModel.deserialize(from: jsonString)\n            if result?.code == 1000 &#123;\n                guard let data = result?.data?.gunzip?.data(using: .utf8) else &#123; return &#125;\n                \n                let file = &quot;zpi_offline_package_data.txt&quot;\n                let text = result?.data?.gunzip ?? &quot;&quot;\n                \n                if let dir = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first &#123;\n                    let fileURL = dir.appendingPathComponent(file)\n                    do &#123;\n                        try text.write(to: fileURL, atomically: false, encoding: .utf8)\n                    &#125; catch &#123;&#125;\n                &#125;\n                \n                guard let model = try? JSONDecoder().decode(StageOfflinePackageData.self, from: data) else &#123; return &#125;\n                \n                if endTimeStr != nil &amp;&amp; (model.appProductVOList.count &gt;= 1000 || model.appProductRelVOList.count &gt;= 1000) &#123;\n                    Defaults[key:DefaultsKeys.updateTime] = nil\n                    OfflinePackageManager.update(updateTime: &quot;&quot;, successful: successful, failure: failure)\n                &#125; else &#123;\n                    if endTimeStr == nil &#123;\n                        OfflinePackageManager.fullUpdate(model: model)\n                    &#125; else &#123;\n                        OfflinePackageManager.incrementalUpdate(model: model)\n                    &#125;\n                    Defaults[key: DefaultsKeys.updateTime] = model.updateTime\n                    successful()\n                &#125;\n            &#125; else &#123;\n                failure()\n            &#125;\n        &#125; failure: &#123; _ in\n            failure()\n        &#125;\n    &#125;\n</code></pre>\n<h2 id=\"6-解压缩字符串\"><a href=\"#6-解压缩字符串\" class=\"headerlink\" title=\"6 解压缩字符串\"></a>6 解压缩字符串</h2><p>这里服务端返回的一段加密后的字符串：</p>\n<pre><code class=\"line-numbers language-Json\">&#123;\n  &quot;message&quot; : &quot;请求成功&quot;,\n  &quot;code&quot; : 1000,\n  &quot;data&quot; : &quot;H4sIAAAAAAAAAKtWSiwoCCjKTylNLglKzQnz98ksLlGyio7VQZJAFk3OzytJzQNyDA2NdJRKC1IS\\nS1JDMnNTlayUjAyMjHUNDHWNLBUMTaxMzaxMDJVqAQ0XaZphAAAA&quot;\n&#125;\n</code></pre>\n<p>不过返回体还是json，我们先拿data里面的字符串。<br>再去解压缩。</p>\n<p>字符串解压缩可以参考这篇文章：<a href=\"https://www.cnblogs.com/strengthen/p/10844466.html\">https://www.cnblogs.com/strengthen/p/10844466.html</a></p>\n<p>这里我们用到了GzipSwift框架。</p>\n<p>这个框架地址为：<a href=\"https://github.com/1024jp/GzipSwift\">https://github.com/1024jp/GzipSwift</a> 还是有挺多人star的。</p>\n<p>具体细节就不讲解了。</p>\n<p>这里我们自己给String做了一个扩展，这样直接能拿到解压缩后的字符串：</p>\n<pre><code class=\"line-numbers language-Swift\">extension String &#123;\n    var gunzip: String? &#123;\n        if let data = Data(base64Encoded: self, options: .ignoreUnknownCharacters) &#123;\n            if data.isGzipped &#123;\n                if let gun = try? data.gunzipped() &#123;\n                    return String(data: gun, encoding: String.Encoding.utf8)\n                &#125;\n            &#125;\n        &#125;\n        return nil\n    &#125;\n&#125;\n</code></pre>\n<p>这里解析后的字符串为：</p>\n<pre><code class=\"line-numbers language-Json\">&#123;\n    &quot;appProductRelVOList&quot;:[],\n    &quot;appProductVOList&quot;:[],\n    &quot;content&quot;:112,\n    &quot;updateTime&quot;:&quot;2023-01-29 14:56:41&quot;\n&#125;\n</code></pre>\n<p>同样也是一个json数组哦。<br>所以我们还是得用Json解析下：</p>\n<pre><code class=\"line-numbers language-Swift\">guard let model = try? JSONDecoder().decode(StageOfflinePackageData.self, from: data)\n                else &#123; return &#125;\n</code></pre>\n<p>这时候我们需要一个实体来接收下：</p>\n<pre><code class=\"line-numbers language-Swift\">class StageOfflinePackageData:Codable&#123;\n    \n    var appProductVOList: [StageGoodsPackgeModelData] = []\n    \n    var appProductRelVOList: [StageGoodsSuitPackgeModelData] = []\n    \n    var updateTime: String = &quot;&quot;\n    \n    \n    private enum Codingkeys: String, CodingKey&#123;\n        case appProductVOList,appProductRelVOList,updateTime\n    &#125;\n    \n    func encode(to encoder: Encoder) throws &#123;&#125;\n    \n    required init(from decoder: Decoder) throws &#123;\n        let values = try decoder.container(keyedBy: Codingkeys.self)\n        appProductVOList = try values.decode(Array.self, forKey: .appProductVOList)\n        appProductRelVOList = try values.decode(Array.self, forKey: .appProductRelVOList)\n        updateTime = try values.decode(String.self, forKey: .updateTime)\n    &#125;\n&#125;\n</code></pre>\n<p>为啥要继承Codable呢？<br>Codable 协议在 Swift4.0 开始被引入，目标是取代现有的 NSCoding 协议，它对结构体，枚举和类都支持。Codable 的引入简化了JSON 和 Swift 类型之间相互转换的难度，能够把 JSON 这种弱类型数据转换成代码中使用的强类型数据。具体可以看这篇文章：<a href=\"https://juejin.cn/post/6971997599725256734\">https://juejin.cn/post/6971997599725256734</a>。</p>\n<p>解析后就拿到服务端的数据了，可能是增量数据，可能是全量数据。后面我们具体分析下。</p>\n<h2 id=\"7-数据处理\"><a href=\"#7-数据处理\" class=\"headerlink\" title=\"7 数据处理\"></a>7 数据处理</h2><p>解析完毕后，我们有一段逻辑是这样的：</p>\n<pre><code class=\"line-numbers language-Swift\">if endTimeStr != nil &amp;&amp; (model.appProductVOList.count &gt;= 1000 || model.appProductRelVOList.count &gt;= 1000) &#123;\n                    Defaults[key:DefaultsKeys.updateTime] = nil\n                    OfflinePackageManager.update(updateTime: &quot;&quot;, successful: successful, failure: failure)\n                &#125; else &#123;\n                    if endTimeStr == nil &#123;\n                        OfflinePackageManager.fullUpdate(model: model)\n                    &#125; else &#123;\n                        OfflinePackageManager.incrementalUpdate(model: model)\n                    &#125;\n                    Defaults[key: DefaultsKeys.updateTime] = model.updateTime\n                    successful()\n                &#125;\n</code></pre>\n<p>这里如果数据大于1000条，我们重新走全量更新接口。<br>如果上次更新时间为空，我们默认为全量更新，将所有数据插入数据库。<br>如果上次更新时间不为空，而且小于1000条，我们就走增量更新逻辑。</p>\n<h3 id=\"7-1-Model层定义\"><a href=\"#7-1-Model层定义\" class=\"headerlink\" title=\"7.1 Model层定义\"></a>7.1 Model层定义</h3><p>这里是定义的Realm的基础模型。</p>\n<p>我们需要定义两个实体，一个是商品模型，一个是关系模型。</p>\n<p>商品模型为：</p>\n<pre><code class=\"line-numbers language-Swift\">\nclass StageGoodsPackgeModelData: Object,Codable&#123;\n    \n    @objc dynamic var barcode: String = &quot;&quot;\n    @objc dynamic var brand: String = &quot;&quot;\n    @objc dynamic var brandId: String = &quot;&quot;\n    @objc dynamic var category: String = &quot;&quot;\n    @objc dynamic var categoryId: Int = 0\n    @objc dynamic var createBy: String = &quot;&quot;\n    @objc dynamic var createTime: String = &quot;&quot;\n    @objc dynamic var delFlag: Int = 0\n    @objc dynamic var groupNum: Int = 1         //返回为&quot;&quot;时服务器需要传1\n    @objc dynamic var id: String = &quot;&quot;\n    @objc dynamic var isGreeProduct: Bool = false\n    @objc dynamic var isGroupedProduct: Bool = false\n    @objc dynamic var isSaleProduct: Bool = false\n    @objc dynamic var length: Double = 0.0\n    @objc dynamic var name: String = &quot;&quot;\n    @objc dynamic var orgId: String = &quot;&quot;\n    @objc dynamic var skuCode: String = &quot;&quot;\n    @objc dynamic var tall: Double = 0\n    @objc dynamic var unit: String = &quot;&quot;\n    @objc dynamic var updateBy: String = &quot;&quot;\n    @objc dynamic var updateTime: String = &quot;&quot;\n    @objc dynamic var volume: Double = 0.0\n    @objc dynamic var weight: Double = 0.0\n    @objc dynamic var wide: Double = 0.0\n    @objc dynamic var isMarketingProduct :Bool = false\n    \n    private enum Codingkeys: String, CodingKey&#123;\n        case barcode\n        ,brand\n        ,brandId\n        ,category\n        ,categoryId\n        ,createBy\n        ,createTime\n        ,delFlag\n        ,groupNum\n        ,id\n        ,isGreeProduct\n        ,isGroupedProduct\n        ,isSaleProduct\n        ,length\n        ,name\n        ,orgId\n        ,skuCode\n        ,tall\n        ,unit\n        ,updateBy\n        ,updateTime\n        ,volume\n        ,weight\n        ,wide,\n        isMarketingProduct\n    &#125;\n    \n    \n    required init(from decoder: Decoder) throws &#123;\n        let values = try decoder.container(keyedBy: Codingkeys.self)\n        \n        do &#123;\n            barcode = try values.decode(String.self, forKey: .barcode)\n        &#125; catch &#123;\n            barcode = &quot;&quot;\n        &#125;\n        do &#123;\n            brand = try values.decode(String.self, forKey: .brand)\n        &#125; catch &#123;\n            brand = &quot;&quot;\n        &#125;\n        do &#123;\n            brandId = try values.decode(String.self, forKey: .brandId)\n        &#125; catch &#123;\n            brandId = &quot;&quot;\n        &#125;\n        do &#123;\n            category = try values.decode(String.self, forKey: .category)\n        &#125; catch &#123;\n            category = &quot;&quot;\n        &#125;\n        do &#123;\n            categoryId = try values.decode(Int.self, forKey: .categoryId)\n        &#125; catch &#123;\n            categoryId = 0\n        &#125;\n        do &#123;\n            createBy = try values.decode(String.self, forKey: .createBy)\n        &#125; catch &#123;\n            createBy = &quot;&quot;\n        &#125;\n        do &#123;\n            createTime = try values.decode(String.self, forKey: .createTime)\n        &#125; catch &#123;\n            createTime = &quot;&quot;\n        &#125;\n        do &#123;\n            delFlag = try values.decode(Int.self, forKey: .delFlag)\n        &#125; catch &#123;\n            delFlag = 0\n        &#125;\n        do &#123;\n            groupNum = try values.decode(Int.self, forKey: .groupNum)\n        &#125; catch &#123;\n            groupNum = 1\n        &#125;\n        do &#123;\n            id = try values.decode(String.self, forKey: .id)\n        &#125; catch &#123;\n            id = &quot;&quot;\n        &#125;\n        do &#123;\n            isGreeProduct = try values.decode(Bool.self, forKey: .isGreeProduct)\n        &#125; catch &#123;\n            isGreeProduct = false\n        &#125;\n        do &#123;\n            isGroupedProduct = try values.decode(Bool.self, forKey: .isGroupedProduct)\n        &#125; catch &#123;\n            isGroupedProduct = false\n        &#125;\n        do &#123;\n            isSaleProduct = try values.decode(Bool.self, forKey: .isSaleProduct)\n        &#125; catch &#123;\n            isSaleProduct = false\n        &#125;\n        do &#123;\n            length = try values.decode(CGFloat.self, forKey: .length)\n        &#125; catch &#123;\n            length = 0.0\n        &#125;\n        do &#123;\n            name = try values.decode(String.self, forKey: .name)\n        &#125; catch &#123;\n            name = &quot;&quot;\n        &#125;\n        do &#123;\n            orgId = try values.decode(String.self, forKey: .orgId)\n        &#125; catch &#123;\n            orgId = &quot;&quot;\n        &#125;\n        do &#123;\n            skuCode = try values.decode(String.self, forKey: .skuCode)\n        &#125; catch &#123;\n            skuCode = &quot;&quot;\n        &#125;\n        do &#123;\n            tall = try values.decode(Double.self, forKey: .tall)\n        &#125; catch &#123;\n            tall = 0\n        &#125;\n        do &#123;\n            unit = try values.decode(String.self, forKey: .unit)\n        &#125; catch &#123;\n            unit = &quot;&quot;\n        &#125;\n        do &#123;\n            updateBy =  try values.decode(String.self, forKey: .updateBy)\n        &#125; catch &#123;\n            updateBy = &quot;&quot;\n        &#125;\n        do &#123;\n            updateTime = try values.decode(String.self, forKey: .updateTime)\n        &#125; catch &#123;\n            updateTime = &quot;&quot;\n        &#125;\n        do &#123;\n            volume = try values.decode(Double.self, forKey: .volume)\n        &#125; catch &#123;\n            volume = 0.0\n        &#125;\n        do &#123;\n            weight = try values.decode(Double.self, forKey: .weight)\n        &#125; catch &#123;\n            weight = 0.0\n        &#125;\n        do &#123;\n            wide = try values.decode(Double.self, forKey: .wide)\n        &#125; catch &#123;\n            wide = 0.0\n        &#125;\n        do &#123;\n            isMarketingProduct = try values.decode(Bool.self, forKey: .isMarketingProduct)\n        &#125; catch &#123;\n            isMarketingProduct = false\n        &#125;\n    &#125;\n    \n    func encode(to encoder: Encoder) throws &#123;&#125;\n    \n    override required init()&#123;&#125;\n&#125;\n</code></pre>\n<p>另外一个为：</p>\n<pre><code class=\"line-numbers language-Swift\">\nclass StageGoodsSuitPackgeModelData: Object,Codable&#123;\n\n    @objc dynamic var groupNum: Int = 0\n    @objc dynamic var id: String = &quot;&quot;\n    @objc dynamic var orgId: String = &quot;&quot;\n    @objc dynamic var productId: String = &quot;&quot;\n    @objc dynamic var subProductId: String = &quot;&quot;\n    \n    private enum Codingkeys: String, CodingKey &#123;\n        case groupNum\n        case id\n        case orgId\n        case productId\n        case subProductId\n    &#125;\n\n    required init(from decoder: Decoder) throws &#123;\n        let values = try decoder.container(keyedBy: Codingkeys.self)\n        \n        do &#123;\n            groupNum = try values.decode(Int.self, forKey: .groupNum)\n        &#125; catch &#123;\n            groupNum = 0\n        &#125;\n        do &#123;\n            id = try values.decode(String.self, forKey: .id)\n        &#125; catch &#123;\n            id = &quot;&quot;\n        &#125;\n        do &#123;\n            orgId = try values.decode(String.self, forKey: .orgId)\n        &#125; catch &#123;\n            orgId = &quot;&quot;\n        &#125;\n        do &#123;\n            productId = try values.decode(String.self, forKey: .productId)\n        &#125; catch &#123;\n            productId = &quot;&quot;\n        &#125;\n        do &#123;\n            subProductId = try values.decode(String.self, forKey: .subProductId)\n        &#125; catch &#123;\n            subProductId = &quot;&quot;\n        &#125;\n    &#125;\n\n    func encode(to encoder: Encoder) throws &#123;&#125;\n    \n    override required init()&#123;&#125;\n&#125;\n</code></pre>\n<h3 id=\"7-2-全量更新\"><a href=\"#7-2-全量更新\" class=\"headerlink\" title=\"7.2 全量更新\"></a>7.2 全量更新</h3><pre><code class=\"line-numbers language-Swift\">private class func fullUpdate(model: StageOfflinePackageData) &#123;\n        let suitResult = objectWithAll(objct: StageGoodsPackgeModelData.self)\n        if suitResult.count != 0 &#123;\n            deleteList(suitResult) &#123;\n                print(&quot;StageGoodsPackgeModelData表数据清除成功&quot;)\n            &#125;\n        &#125;\n        addList(model.appProductVOList) &#123;\n            print(&quot;StageGoodsPackgeModelData 插入成功&quot;)\n        &#125;\n        \n        let relationResult = objectWithAll(objct: StageGoodsSuitPackgeModelData.self)\n        if relationResult.count != 0 &#123;\n            deleteList(relationResult) &#123;\n                print(&quot;StageGoodsSuitPackgeModelData表数据清除成功&quot;)\n            &#125;\n        &#125;\n        addList(model.appProductRelVOList) &#123;\n            print(&quot;StageGoodsSuitPackgeModelData 插入成功&quot;)\n        &#125;\n    &#125;\n</code></pre>\n<p>如果是全量更新就比较简单了。<br>先把之前的那两个删除掉，然后新增新的model就好了。</p>\n<h3 id=\"7-3-增量更新\"><a href=\"#7-3-增量更新\" class=\"headerlink\" title=\"7.3 增量更新\"></a>7.3 增量更新</h3><p>先声明一下sql</p>\n<pre><code class=\"line-numbers language-Swift\">    private class func incrementalUpdate(model: StageOfflinePackageData) &#123;\n        print(&quot;增量处理开始时间----&gt;&quot;, Date().currentTime(0))\n        var addGoodsArr: [StageGoodsPackgeModelData] = []\n        var addRelationsArr: [StageGoodsSuitPackgeModelData] = []\n        var relationidArr: [String] = []\n        \n        var goodsSql = &quot;&quot;\n        var relationSql = &quot;&quot;\n        var deleteGoodsSql = &quot;&quot;\n        var deleteRelationSql = &quot;&quot;\n</code></pre>\n<p>遍历下服务端返回的增量数据库：</p>\n<pre><code class=\"line-numbers language-Swift\">for (_,suitModel) in model.appProductVOList.enumerated() &#123;\n    // delFlag为0表示，不是删除哦，这里是新增商品\n    if suitModel.delFlag == 0 &#123;\n        if goodsSql == &quot;&quot; &#123;\n            let str1 = String(format:&quot;id = &#39;%@&#39;&quot;, suitModel.id)\n            let str2 = String(format:&quot;productId = &#39;%@&#39;&quot;, suitModel.id)\n            goodsSql.append(str1)\n            relationSql.append(str2)\n        &#125; else &#123;\n            let str1 = String(format:&quot;|| id = &#39;%@&#39;&quot;, suitModel.id)\n            let str2 = String(format:&quot;|| productId = &#39;%@&#39;&quot;, suitModel.id)\n            goodsSql.append(str1)\n            relationSql.append(str2)\n        &#125;\n        addGoodsArr.append(suitModel)\n        relationidArr.append(suitModel.id)\n    &#125; else &#123;\n        // delFlag为1表示删除了商品\n        if deleteGoodsSql == &quot;&quot; &#123;\n            let str1 = String(format:&quot;id = &#39;%@&#39;&quot;, suitModel.id)\n            let str2 = String(format:&quot;productId = &#39;%@&#39;&quot;, suitModel.id)\n            deleteGoodsSql.append(str1)\n            deleteRelationSql.append(str2)\n        &#125; else &#123;\n            let str1 = String(format:&quot;|| id = &#39;%@&#39;&quot;, suitModel.id)\n            let str2 = String(format:&quot;|| productId = &#39;%@&#39;&quot;, suitModel.id)\n            deleteGoodsSql.append(str1)\n            deleteRelationSql.append(str2)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>有个一个delFlag变量，就是表示是否删除的意思。<br>如果是删除的话，将sql组合一下，就成为 id &#x3D; ‘12’ || id &#x3D; ‘13’ || id &#x3D; ‘14’ 这种。关系表就是 productId &#x3D; ‘12’ || productId &#x3D; ‘14’ 这种。</p>\n<p>这里就知道哪些商品要删除，哪些要加。哪些关系表要删除，哪些要加。</p>\n<p>这里先处理下新增的商品：</p>\n<pre><code class=\"line-numbers language-Swift\">if goodsSql != &quot;&quot; &#123;\n    let predicate = NSPredicate(format:goodsSql)\n    let suitArr = objectsWithPredicate(object: StageGoodsPackgeModelData.self, predicate: predicate)\n    // 这里需要把可能之前存在相同的去掉\n    deleteList(suitArr)&#123;\n        print(&quot;删除商品成功&quot;)\n    &#125;\n    if addGoodsArr.count != 0 &#123;\n        addList(addGoodsArr)&#123;\n            print(&quot;增量更新商品数据成功&quot;)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里用了系统的NSPredicate类来组合sql语句。它其实是用来过滤数据的类。<br>使用方法可以参考这篇文章：<a href=\"https://juejin.cn/post/6844903540805074951\">https://juejin.cn/post/6844903540805074951</a>。</p>\n<p>然后处理下要删除的商品：</p>\n<pre><code class=\"line-numbers language-Swift\"> if deleteGoodsSql != &quot;&quot; &#123;\n    // NSPredicate是swift 过滤数据的类，类似数据库中的where字段\n    let predicate = NSPredicate(format:deleteGoodsSql)\n    let suitArr = objectsWithPredicate(object: StageGoodsPackgeModelData.self, predicate: predicate)\n    deleteList(suitArr)&#123;\n        print(&quot;删除商品成功&quot;)\n    &#125;\n&#125;\n</code></pre>\n<p>商品处理完成，剩下就是关系表了。</p>\n<p>这里先处理要新增的关系：</p>\n<pre><code class=\"line-numbers language-Swift\">// 这里是新增的关系表\nfor idStr in relationidArr &#123;\n    for relationModel in model.appProductRelVOList&#123;\n        if idStr == relationModel.productId &#123;\n            addRelationsArr.append(relationModel)\n        &#125;\n    &#125;\n&#125;\n\n// 新增的关系表\nif relationSql != &quot;&quot; &#123;\n    let relationPredicate = NSPredicate(format:relationSql)\n    let relationArr = objectsWithPredicate(object: StageGoodsSuitPackgeModelData.self, predicate: relationPredicate)\n    deleteList(relationArr)&#123;\n        print(&quot;删除套机关系模型成功&quot;)\n    &#125;\n    if addRelationsArr.count != 0 &#123;\n        addList(addRelationsArr)&#123;\n            print(&quot;增量更新套机关系模型成功&quot;)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>然后处理下要删除的关系表：</p>\n<pre><code class=\"line-numbers language-Swift\"> if deleteRelationSql != &quot;&quot; &#123;\n    let relationPredicate = NSPredicate(format:deleteRelationSql)\n    let relationArr = objectsWithPredicate(object: StageGoodsSuitPackgeModelData.self, predicate: relationPredicate)\n    deleteList(relationArr)&#123;\n        print(&quot;删除套机关系模型成功&quot;)\n    &#125;\n&#125;\n</code></pre>\n<p>这样增量数据就成功插入了。</p>\n<h2 id=\"8-预览realm数据库\"><a href=\"#8-预览realm数据库\" class=\"headerlink\" title=\"8 预览realm数据库\"></a>8 预览realm数据库</h2><p>插入数据成功后，我们可以用 Realm Studio 来预览数据。<br>上面有讲解如何使用这个可视化工具。</p>\n<p>这里我们就看下最终的结果吧：<br><img src=realm1.png><br><img src=realm2.png></p>\n<h2 id=\"9-总结\"><a href=\"#9-总结\" class=\"headerlink\" title=\"9 总结\"></a>9 总结</h2><ul>\n<li><p>iOS数据库可以考虑使用realm数据库，这个是跨平台，Android也有相应的三方库，使用非常简洁，可以考虑。</p>\n</li>\n<li><p>对于大量数据，我们务必要注意数据的修改，新增，最好采用增量更新的方式，而且如果全量，最好是先压缩下，减小对网络依赖。</p>\n</li>\n<li><p>realm数据库要注意数据库迁移的问题，升级的问题，使用前需要configRealm。</p>\n</li>\n<li><p>真机预览realm数据库可以使用Realm Studio。</p>\n</li>\n<li><p>增量更新一定要注意删除之前的记录，否则数据会很紊乱。</p>\n</li>\n</ul>\n"},{"title":"iOS-swift-网络请求二次封装moya","date":"2023-02-01T08:44:45.000Z","top":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 github地址\n\n> [https://github.com/chensx1993/moyaManager](https://github.com/chensx1993/moyaManager)\n\n这个应该是一个小姐姐，我看到我们项目用了这个三方库，所以这边分析下封装细节。\n\n简单介绍下吧：\n\nmoya是对Alamofire的再次封装。它可以实现各种自定义配置，真正实现了对网络层的高度抽象。\n\n还有一个优秀的网络框架([github地址](https://github.com/mmoaay/Bamboots))，大家可以看看，跟`moya`对比一下。\n\n有关moya的介绍可以看看: [Moya的使用](https://www.jianshu.com/p/2ee5258828ff)。\n\n## 2 框架架构\n\n<img src=moya1.png>\n\n* Core应该是核心模块，存放网络状态管理员，Network.swift应该是最关键的暴露给开发者使用的类吧，所有的请求都是经过这层转发的，Request就是内部请求相关，比如get和post请求层的封装吧。\n\n* Extension是扩展层，这里扩展了String，也扩展了网络请求基础返回体，这里可以根据项目来。\n\n* Plugin是插件层，这个可以自由添加。\n\n* Server是网络层，这里我们可以定义一些通过的请求参数，比如token啥的。\n\n* API层，这就和我们自己定义的Api相关了，怎么请求，怎么传参这些定义。\n\n* Error层，这里应该是异常层了。\n\n## 3 实例分析\n\n这里我们考虑用一个真实案例，来深入分析这个封装框架如何实现网络请求的。\n这里就以登录接口为案例吧。\n\n可以建立一个登录相关接口，比如修改密码啥的，跟登录有关的统一用一个Manager。\n如下：\n```swift\nimport Foundation\nimport Moya\n\n// MARK: - 用户登录信息请求\nlet loginApiRequest = Networking<UserLoginAPIManagerService>()\n\n\nenum UserLoginAPIManagerService {\n    /// 账号密码登录\n    case userAccountLogin(userName:String, passWord:String)\n    /// 是否显示注册\n    case isShowRegister\n    /// 注册\n    case register(_ params: [String: Any])\n    /// 更新是否已经提醒用户修改密码标记\n    case signNotFirstLogin(userId:String)\n    /// 修改密码\n    case changePassword(newPassword:String, oldPassword:String, username:String)\n    /// 校验原密码\n    case checkOldPassword(oldPassword:String, username:String)\n    /// 登出\n    case logOut\n\n}\n\nextension UserLoginAPIManagerService : MyServerType {\n    \n    //域名\n    var baseURL: URL {\n        switch self {\n        case .register:\n            return URL(string: mainHost)!\n        case .isShowRegister:\n            return URL(string: mainHost)!\n        case .userAccountLogin:\n            return URL(string: LoginHost)!\n        case .signNotFirstLogin:\n            return URL(string: mainHost)!\n        case .changePassword,.checkOldPassword:\n            return URL(string: mainHost)!\n        default:\n            return URL(string: LoginHost)!\n        }\n        \n    }\n    \n    //接口路径\n    public var path: String {\n        switch self {\n        case .userAccountLogin:\n            return \"oauth/token\"\n        case .register:\n            return \"v1/user/Register\"\n        case.isShowRegister:\n            return \"v1/user/iosIsEnabled\"\n        case .signNotFirstLogin:\n            return \"v1/exposure/password/flag\"\n        case .changePassword:\n            return \"v1/user/reset/myself\"\n        case .logOut:\n            return \"ssoLogout\"\n        case .checkOldPassword:\n            return \"v1/user/check/reset-password\"\n        }\n    }\n    \n    //是否执行Alamofire验证\n    var validate: Bool {\n        return false\n    }\n    \n    //验证方式\n    var validationType: MyValidationType {\n        return .none\n    }\n    \n    //单元测试模拟的数据\n    var sampleData: Data {\n        return \"{}\".data(using: String.Encoding.utf8)!\n    }\n    \n    //请求类型：get、post、delete、put\n    var method: HTTPMethod {\n        switch self {\n        case .userAccountLogin(userName: _ , passWord: _),\n                .register,\n                .isShowRegister,\n                .changePassword,\n                .checkOldPassword:\n            return .post\n        default:\n            return .get\n        }\n    }\n    \n    //请求任务:\n    public var task: Task {\n        switch self {\n        case .userAccountLogin(let userName, let passWord):\n            let secret = \"1234\".toMD5\n            let params = [\"client_id\": clientId,\n                          \"client_secret\":secret,\n                          \"username\": userName,\n                          \"password\": passWord] as [String : Any]\n            return .requestParameters(parameters: params, encoding:URLEncoding.default)\n        case .register(let params):\n            return .requestParameters(parameters: params, encoding:JSONEncoding.default)\n        case .isShowRegister:\n            return .requestParameters(parameters: [: ], encoding: URLEncoding.default)\n        case .logOut:\n            return .requestPlain\n        case .signNotFirstLogin(let userId):\n            let params = [\"userId\": userId] as [String : Any]\n            return .requestParameters(parameters: params, encoding:URLEncoding.default)\n        case .changePassword(let newPassword, let oldPassword, let username):\n            let params = [\"newPassword\":newPassword,\n                          \"oldPassword\":oldPassword,\n                          \"username\": username] as [String : Any]\n            return .requestParameters(parameters: params, encoding: JSONEncoding.default)\n        case .checkOldPassword(let oldPassword, let username):\n            let params = [\"oldPassword\":oldPassword,\n                          \"username\": username] as [String : Any]\n            return .requestParameters(parameters: params, encoding: JSONEncoding.default)\n        }\n        \n    }\n    \n    //请求头\n    var appendHeaders: [String : String]? {\n        switch self {\n        case .register:\n            return [\"Content-Type\": \"application/json\"]\n        case .signNotFirstLogin,\n                .checkOldPassword,\n                .logOut:\n            return [: ]\n        case .changePassword:\n            return [\"menuPath\": MenuPath.changePassword.info]\n        default:\n            return [: ]\n        }\n    }\n    \n}\n```\n\n首先是建立了一个常量，一个Networking包装了MyServerType，当然这个MyServerType和Networking都是封装好的。主要操作就是自定义这个MyServerType了。\n\n这个接口基本就写好了。\n请求头可配置，参数可配置，接口路径可配置，后端怎么改都不怕了。\n\n然后就是我们调用的地方了。\n\n在登录的地方这样用：\n```swift\n loginApiRequest.requestJson(.userAccountLogin(userName: userName, passWord: safePassWord)) {result in\n    let json = JSON.init(rawValue: result)\n    if json?[\"code\"].intValue == 1000 {\n        MBProgressHUD.hide()\n        guard let model = UserInformationData.deserialize(from: json?[\"data\"].jsonString) else { return }\n        self.saveLoginSuccessUserInformation(model: model, userName: userName, passWord: passWord)\n        callBack(model)\n        \n        self.requestUploadLog(userName,1,\"登录成功\")\n    }else{\n        MBProgressHUD.hide()\n        let str = json?[\"message\"].stringValue ?? \"登录失败\"\n        GMToast.showFailure(str)\n        self.requestUploadLog(userName,0,str)\n    }\n    \n} failure: { error in\n    MBProgressHUD.hide()\n    GMToast.showFailure()\n}\n```\n\nloginApiRequest就是我们前面定义的登录类接口的常量。\n\n因为这是一个Networking，所有它有requestJson方法，这个方法也是框架自己二次封装好的，等下具体分析下这里面的代码即可。\n\n注意到这里有传参，需要关注下.userAccoutLogin是啥东西？\n> 原来就是我们定义的泛型类，MyServerType，这里.userAccountLogin是一个枚举也是一个MyServerType，我们可以在这里面添加请求参数，这样就关联起来了。\n\n```swift\nenum UserLoginAPIManagerService {\n    /// 账号密码登录\n    case userAccountLogin(userName:String, passWord:String)\n    /// 是否显示注册\n    case isShowRegister\n    /// 注册\n    case register(_ params: [String: Any])\n    /// 更新是否已经提醒用户修改密码标记\n    case signNotFirstLogin(userId:String)\n    /// 修改密码\n    case changePassword(newPassword:String, oldPassword:String, username:String)\n    /// 校验原密码\n    case checkOldPassword(oldPassword:String, username:String)\n    /// 登出\n    case logOut\n\n}\n```\n果然就是第一个“账号密码登录”。\n\n所有对于使用还是相当方便的，只需要写一个Manager，就可以很方便请求接口了。\n\n## 4 细节分析\n\n继续上面的案例，当我们发送json请求时，走了一个框架封装好的方法，看下：\n```swift\n@discardableResult\n    public func requestJson(_ target: T,\n                            callbackQueue: DispatchQueue? = DispatchQueue.main,\n                            progress: ProgressBlock? = .none,\n                            success: @escaping JsonSuccess,\n                            failure: @escaping Failure) -> Cancellable {\n        return self.request(target, callbackQueue: callbackQueue, progress: progress, success: { (response) in\n            do {\n                let result = try JSON.init(data: response.data)\n                let vc = UIViewController.current()\n                if vc is LoginPageViewController {}else{\n                    if response.statusCode == 403 || response.statusCode == 401 {\n                        //token过期\n                        if tokenInvalidHandle != nil {\n                            tokenInvalidHandle()\n                            return\n                        }\n                    }\n                }\n                #if DEBUG\n                    print(result)\n                #endif\n                success(result)\n            } catch (let error) {\n                failure(error as? NetworkError ?? NetworkError.invalidURL)\n            }\n        }) { (error) in\n            #if DEBUG\n                print(error)\n            #endif\n            failure(error)\n        }\n    }\n```\n这里继续走了内部的self.request方法，T就是我们自定义的MyServerType。\n里面回调是我们自己的逻辑，就是解析了下Json，然后就是403或401的时候，跳转了登录页，这里的逻辑不需要关注。\n\n看下内部的request方法吧：\n```swift\n@discardableResult\n    public func request(_ target: T,\n                        callbackQueue: DispatchQueue? = DispatchQueue.main,\n                        progress: ProgressBlock? = .none,\n                        success: @escaping Success,\n                        failure: @escaping Failure) -> Cancellable {\n        return self.provider.request(target, callbackQueue: callbackQueue, progress: progress) { (result) in\n            switch result {\n            case let .success(response):\n                #if DEBUG\n                if let body = response.request?.httpBody,\n                   let param = String(data: body, encoding: .utf8),\n                   let interface = response.request?.url {\n                    print(\"✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅\")\n                    print(\"接口地址：\\n\\(interface)\")\n                    print(\"✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅\")\n                    print(\"请求参数：\\n\\(param)\")\n                    print(\"✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅\")\n                }\n                #endif\n                success(response);\n            case let .failure(error):\n                #if DEBUG\n                print(\"❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌\")\n                print(error)\n                #endif\n                let err = NetworkError.init(error: error)\n                failure(err);\n                break\n            }\n        }\n    }\n```\n这里的回调队列，进度，都有默认实例，当然可以自由传递。\n另外就是成功和失败的逃逸闭包了。\n\n其实内部继续走了self.provider.request才是重中之重。\n\n\n### 4.1 生产Moya Provider\n首先看下provider怎么来的：\n```swift\npublic struct Networking<T: MyServerType> {\n    public let provider: MoyaProvider<T>\n    \n    public init(provider: MoyaProvider<T> = newDefaultProvider()) {\n        self.provider = provider\n    }\n}\n\npublic static func newDefaultProvider() -> MoyaProvider<T> {\n        return newProvider(plugins: plugins)\n}\n\n/// 如何新建MoyaProvider\nfunc newProvider<T>(plugins: [PluginType],session: Session = newManager()) -> MoyaProvider<T> where T: MyServerType {\n    \n    return MoyaProvider(endpointClosure: Networking<T>.endpointsClosure(),\n                        requestClosure: Networking<T>.endpointResolver(),\n                        stubClosure: Networking<T>.APIKeysBasedStubBehaviour,\n                        session: session,\n                        plugins: plugins,\n                        trackInflights: false\n    )\n}\n\n/// 新建Provider需要的参数1\nfunc newManager(delegate: SessionDelegate = SessionDelegate()) -> Session {\n//    let configuration = URLSessionConfiguration.default\n//    configuration.httpAdditionalHeaders = Alamofire.SessionManager.defaultHTTPHeaders\n    let configuration = Alamofire.Session.default.session.configuration\n    let session = Alamofire.Session(configuration: configuration, delegate: delegate, startRequestsImmediately: false)\n    return session\n}\n\n/// 新建Provider需要的参数2\nstatic var plugins: [PluginType] {\n        let activityPlugin = NewNetworkActivityPlugin { (state, targetType) in\n            switch state {\n            case .began:\n                if targetType.isShowLoading { //这是我扩展的协议\n                    // 显示loading\n                }\n            case .ended:\n                if targetType.isShowLoading { //这是我扩展的协议\n                    // 关闭loading\n                }\n            }\n        }\n        \n        return [\n            activityPlugin, myLoggorPlugin\n        ]\n    }\n\n```\n这里创建的时候，就默认传了一个默认的Provider，这个是Moya官方的哦。\n\n另外新建这个MoyaProvider的时候还需要3个闭包，我们通过Networking来生产：\n```swift\nstatic func endpointsClosure<T>() -> (T) -> Endpoint where T: MyServerType {\n    return { target in\n        var headers: [String: String] = target.headers ?? [:]\n        if apiEnvironment == .product {\n            //生产环境灰度\n            if canary == true {\n                headers[\"canary\"] = \"true\"\n            }\n        }\n        //生产环境api路径设置\n        var str = \"\"\n        str = URL(target: target).absoluteString\n        if apiEnvironment != .test && apiEnvironment != .dev {\n            str = str.replacingOccurrences(of: \"-test\", with: \"\", options: .literal, range: nil)\n        }\n        let absoluteString = str\n        let defaultEndpoint = Endpoint(\n            url: absoluteString,\n            sampleResponseClosure: { target.sampleResponse },\n            method: target.method,\n            task: target.task,\n            httpHeaderFields: headers\n        )\n        return defaultEndpoint;\n    }\n}\n\n//测试网络错误,如超时等.\nstatic func endpointResolver() -> MoyaProvider<T>.RequestClosure {\n    return { (endpoint, closure) in\n        do {\n            var request = try endpoint.urlRequest()\n            request.httpShouldHandleCookies = false\n            request.timeoutInterval = WebService.shared.timeoutInterval\n            closure(.success(request))\n        } catch let error {\n            closure(.failure(MoyaError.underlying(error, nil)))\n        }\n    }\n}   \n\nstatic func APIKeysBasedStubBehaviour<T>(_ target: T) -> Moya.StubBehavior where T: MyServerType {\n        return target.stubBehavior;\n    }\n```\n这里我们自己生产了3个闭包给moya，也是moya需要的3个闭包。\n\n### 4.2 继续走Provider的request\n\n```swift\n/// Designated request-making method. Returns a `Cancellable` token to cancel the request later.\n    @discardableResult\n    open func request(_ target: Target,\n                      callbackQueue: DispatchQueue? = .none,\n                      progress: ProgressBlock? = .none,\n                      completion: @escaping Completion) -> Cancellable {\n\n        let callbackQueue = callbackQueue ?? self.callbackQueue\n        return requestNormal(target, callbackQueue: callbackQueue, progress: progress, completion: completion)\n    }\n```\n这个是moya三方库里面的代码了，简单看下就好，不是我们这期重点。\n\n### 4.3 如何封装MyServerType\n\n个人感觉这个也是非常关键，我们外部使用，需要建立一个枚举，同时也是一个MyServerType，这个携带了请求参数，请求方法之类的，总之它包装了一切我们请求需要的东西。\n\n```swift\nimport Foundation\nimport Moya\n\npublic typealias HTTPMethod = Moya.Method\npublic typealias MyValidationType = Moya.ValidationType\npublic typealias MySampleResponse = Moya.EndpointSampleResponse\npublic typealias MyStubBehavior = Moya.StubBehavior\n\npublic protocol MyServerType: TargetType {\n    var isShowLoading: Bool { get }\n    /// 附加请求头（如需添加额外的，使用这个）\n    var appendHeaders: [String : String]? { get }\n    var parameters: [String: Any]? { get }\n    var stubBehavior: MyStubBehavior { get }\n    var sampleResponse: MySampleResponse { get }\n}\n```\n首先，它这个继承了Moya自己的TargetType，还增加了自己额外的一些协议。\n\n```swift\nextension MyServerType {\n    public var base: String { return WebService.shared.rootUrl}\n    \n    public var baseURL: URL { return URL(string: base)! }\n    /// 请求头 （默认请求头 + appendHeaders），需求添加额外的改appendHeaders\n    public var headers: [String : String]? {\n        var result: [String : String]? = WebService().headers\n        guard let appendHeaders = appendHeaders else { return result }\n        result = WebService().headers?.merging(appendHeaders, uniquingKeysWith: { (_, new) in new })\n        return result\n    }\n    public var appendHeaders: [String : String]? { return nil }\n    public var parameters: [String: Any]? { return WebService.shared.parameters }\n    \n    public var isShowLoading: Bool { return false }\n    \n    public var task: Task {\n        let encoding: ParameterEncoding\n        switch self.method {\n        case .post:\n            encoding = JSONEncoding.default\n        default:\n            encoding = URLEncoding.default\n        }\n        if let requestParameters = parameters {\n            return .requestParameters(parameters: requestParameters, encoding: encoding)\n        }\n        return .requestPlain\n    }\n    \n    \n    public var method: HTTPMethod {\n        return .post\n    }\n    \n    public var validationType: MyValidationType {\n        return .successCodes\n    }\n    \n    public var stubBehavior: StubBehavior {\n        return .never\n    }\n    \n    public var validate: Bool {\n        return false\n    }\n    \n    public var sampleData: Data {\n        return \"response: test data\".data(using: String.Encoding.utf8)!\n    }\n    \n    public var sampleResponse: MySampleResponse {\n        return .networkResponse(200, self.sampleData)\n    }\n}\n```\n这里应该是实现了默认值的设定。\n当然我们是可以更改的。\n\n```swift\nfunc myBaseUrl(_ path: String) -> String {\n    if path.isCompleteUrl { return path }\n    return WebService.shared.rootUrl;\n}\n\nfunc myPath(_ path: String) -> String {\n    if path.isCompleteUrl { return \"\" }\n    return path;\n}\n\nextension String {\n    var isCompleteUrl: Bool {\n        let scheme = self.lowercased()\n        if scheme.contains(\"http\") { return true }\n        return false\n    }\n}\n```\n然后是其它工具方法。\n\n这里有用到一个WebService类，这里面存放的也是一些默认值设定：\n```swift\nimport Foundation\nimport UIKit\nimport AdSupport\nimport Alamofire\nimport Moya\n\nclass WebService: NSObject {\n    \n    var rootUrl: String = mainHost\n    var headers: [String: String]? = defaultHeaders()\n    var parameters: [String: Any]? = defaultParameters()\n    var timeoutInterval: Double = 30.0\n    //和服务器时间相差的时间戳:备注每次app恢复活跃状态需更新一次\n    static var serviceTimeSpace: String?\n    \n    static let shared = WebService()\n    override init() {}\n    \n    static func defaultHeaders() -> [String : String]? {\n        var headers = [\"x-flag\": \"iOS\", \"serverName\": \"APP\", \"clientId\": clientId]\n        if let token = Defaults[key: DefaultsKeys.access_token] {\n            headers[\"Authorization\"] = \"Bearer\" + token\n        }\n        let isMonopoly = Defaults[key: DefaultsKeys.isMonopoly] ?? false\n        /// appVersion 字段，（1表示专业版，0表示简易版）\n        headers[\"appVersion\"] = isMonopoly ? \"0\" : \"1\"\n        return headers\n    }\n    \n    static func defaultParameters() -> [String : Any]? {\n        return [\"platform\" : \"ios\",\n            \"version\" : \"1.2.3\",\n        ]\n    }\n    \n    /**\n     获取当前app版本号\n     */\n    static func getAppShortVersion() -> String {\n        let infoDictionary = Bundle.main.infoDictionary!\n        let version = infoDictionary[\"CFBundleShortVersionString\"] as! String\n        return version\n    }\n    \n    /**\n    获取当前请求User-Agent\n     */\n    static func getUserAgent() -> String {\n        let infoDictionary = Bundle.main.infoDictionary!\n        let version = infoDictionary[\"CFBundleShortVersionString\"] as! String\n        let userAgent = String(format: \"GREEMall%@(%@; iOS %@; Scale/%.2f)\", version, UIDevice.current.model, UIDevice.current.systemVersion, UIScreen.main.scale)\n        \n        return userAgent\n    }\n    \n    /**\n    获取服务器时间和计算时间差\n     */\n    static func setServiceTimeInterval(timeInterval:TimeInterval) {\n        serviceTimeSpace = String(format: \"%@\", timeInterval)\n    }\n    \n    /**\n     获取服务器时间戳\n     */\n    static func getServiceTimeInterval() -> Int {\n        return Int(serviceTimeSpace!)!\n    }\n    \n    /**\n     设置请求统一参数\n     */\n    static func getSystemParameterData() -> Dictionary<String, String> {\n        var data = [String: String]()\n        data[\"source\"] = \"iOS\"\n        var timeSpace: String = \"\"\n        if serviceTimeSpace != nil {\n            let now: TimeInterval = Date.init().timeIntervalSince1970\n            let appTime: TimeInterval = now + Double(CLongLong(serviceTimeSpace!)!)\n            timeSpace = String(format:\"%@\", appTime)\n        } else {\n            timeSpace = String(format:\"%@\", Date.init().timeIntervalSince1970)\n        }\n        data[\"t\"] = timeSpace\n        data[\"version\"] = self.getAppShortVersion()\n        data[\"ios_idfa\"] = ASIdentifierManager.shared().advertisingIdentifier.uuidString\n        return data\n    }\n    \n    /**\n     签名MD5处理\n     */\n    static func appendSign(paramterDic: Dictionary<String, String>, secrekey:String) -> String {\n        var sign:String = \"\"\n        var keys:Array = Array(paramterDic.keys)\n        keys = keys.sorted()\n        for key:String in keys {\n            if key == \"sign\" {\n                continue\n            } else {\n                let keyValue: String = String(format: \"%@\", paramterDic[key]!)\n                sign.append(String(format: \"%@%@\", key, keyValue.EscapesValr))\n            }\n        }\n        sign.append(secrekey)\n        return sign.td.md5.uppercased()\n    }\n}\n```\n\n大致就是这样了。\n\n## 5 总结\n\n* 这个二次封装主要是基于Moya，简化moya流程，提供了一个MyServerType，封装了一些请求参数，请求方法，方便我们进行接口配置。\n\n* 使用方法很简单，不过需要将一类接口单独放置，全部放一起不方便管理，这里比如登录相关接口统一用一个Manger配置，接口参数都写在这个Manager里面，其实也是由一定好处的。\n\n* 这里将moya更加封装成一个系统了，我们需要的结果无非就是接口成功或失败，传参也是我们必要的，将必要的都封装起来了，总体上使用还是比较便捷。\n\n* 如果有特殊请求，比如下载文件这种，需要我们单独抽一个方法处理，这里稍微增加了一点复杂度吧，一般的请求还是可以直接使用的。","source":"_posts/iOS-swift-网络请求二次封装moya.md","raw":"---\ntitle: iOS-swift-网络请求二次封装moya\ndate: 2023-02-01 16:44:45\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- 网络请求\ncategories:\n- iOS\n---\n\n## 1 github地址\n\n> [https://github.com/chensx1993/moyaManager](https://github.com/chensx1993/moyaManager)\n\n这个应该是一个小姐姐，我看到我们项目用了这个三方库，所以这边分析下封装细节。\n\n简单介绍下吧：\n\nmoya是对Alamofire的再次封装。它可以实现各种自定义配置，真正实现了对网络层的高度抽象。\n\n还有一个优秀的网络框架([github地址](https://github.com/mmoaay/Bamboots))，大家可以看看，跟`moya`对比一下。\n\n有关moya的介绍可以看看: [Moya的使用](https://www.jianshu.com/p/2ee5258828ff)。\n\n## 2 框架架构\n\n<img src=moya1.png>\n\n* Core应该是核心模块，存放网络状态管理员，Network.swift应该是最关键的暴露给开发者使用的类吧，所有的请求都是经过这层转发的，Request就是内部请求相关，比如get和post请求层的封装吧。\n\n* Extension是扩展层，这里扩展了String，也扩展了网络请求基础返回体，这里可以根据项目来。\n\n* Plugin是插件层，这个可以自由添加。\n\n* Server是网络层，这里我们可以定义一些通过的请求参数，比如token啥的。\n\n* API层，这就和我们自己定义的Api相关了，怎么请求，怎么传参这些定义。\n\n* Error层，这里应该是异常层了。\n\n## 3 实例分析\n\n这里我们考虑用一个真实案例，来深入分析这个封装框架如何实现网络请求的。\n这里就以登录接口为案例吧。\n\n可以建立一个登录相关接口，比如修改密码啥的，跟登录有关的统一用一个Manager。\n如下：\n```swift\nimport Foundation\nimport Moya\n\n// MARK: - 用户登录信息请求\nlet loginApiRequest = Networking<UserLoginAPIManagerService>()\n\n\nenum UserLoginAPIManagerService {\n    /// 账号密码登录\n    case userAccountLogin(userName:String, passWord:String)\n    /// 是否显示注册\n    case isShowRegister\n    /// 注册\n    case register(_ params: [String: Any])\n    /// 更新是否已经提醒用户修改密码标记\n    case signNotFirstLogin(userId:String)\n    /// 修改密码\n    case changePassword(newPassword:String, oldPassword:String, username:String)\n    /// 校验原密码\n    case checkOldPassword(oldPassword:String, username:String)\n    /// 登出\n    case logOut\n\n}\n\nextension UserLoginAPIManagerService : MyServerType {\n    \n    //域名\n    var baseURL: URL {\n        switch self {\n        case .register:\n            return URL(string: mainHost)!\n        case .isShowRegister:\n            return URL(string: mainHost)!\n        case .userAccountLogin:\n            return URL(string: LoginHost)!\n        case .signNotFirstLogin:\n            return URL(string: mainHost)!\n        case .changePassword,.checkOldPassword:\n            return URL(string: mainHost)!\n        default:\n            return URL(string: LoginHost)!\n        }\n        \n    }\n    \n    //接口路径\n    public var path: String {\n        switch self {\n        case .userAccountLogin:\n            return \"oauth/token\"\n        case .register:\n            return \"v1/user/Register\"\n        case.isShowRegister:\n            return \"v1/user/iosIsEnabled\"\n        case .signNotFirstLogin:\n            return \"v1/exposure/password/flag\"\n        case .changePassword:\n            return \"v1/user/reset/myself\"\n        case .logOut:\n            return \"ssoLogout\"\n        case .checkOldPassword:\n            return \"v1/user/check/reset-password\"\n        }\n    }\n    \n    //是否执行Alamofire验证\n    var validate: Bool {\n        return false\n    }\n    \n    //验证方式\n    var validationType: MyValidationType {\n        return .none\n    }\n    \n    //单元测试模拟的数据\n    var sampleData: Data {\n        return \"{}\".data(using: String.Encoding.utf8)!\n    }\n    \n    //请求类型：get、post、delete、put\n    var method: HTTPMethod {\n        switch self {\n        case .userAccountLogin(userName: _ , passWord: _),\n                .register,\n                .isShowRegister,\n                .changePassword,\n                .checkOldPassword:\n            return .post\n        default:\n            return .get\n        }\n    }\n    \n    //请求任务:\n    public var task: Task {\n        switch self {\n        case .userAccountLogin(let userName, let passWord):\n            let secret = \"1234\".toMD5\n            let params = [\"client_id\": clientId,\n                          \"client_secret\":secret,\n                          \"username\": userName,\n                          \"password\": passWord] as [String : Any]\n            return .requestParameters(parameters: params, encoding:URLEncoding.default)\n        case .register(let params):\n            return .requestParameters(parameters: params, encoding:JSONEncoding.default)\n        case .isShowRegister:\n            return .requestParameters(parameters: [: ], encoding: URLEncoding.default)\n        case .logOut:\n            return .requestPlain\n        case .signNotFirstLogin(let userId):\n            let params = [\"userId\": userId] as [String : Any]\n            return .requestParameters(parameters: params, encoding:URLEncoding.default)\n        case .changePassword(let newPassword, let oldPassword, let username):\n            let params = [\"newPassword\":newPassword,\n                          \"oldPassword\":oldPassword,\n                          \"username\": username] as [String : Any]\n            return .requestParameters(parameters: params, encoding: JSONEncoding.default)\n        case .checkOldPassword(let oldPassword, let username):\n            let params = [\"oldPassword\":oldPassword,\n                          \"username\": username] as [String : Any]\n            return .requestParameters(parameters: params, encoding: JSONEncoding.default)\n        }\n        \n    }\n    \n    //请求头\n    var appendHeaders: [String : String]? {\n        switch self {\n        case .register:\n            return [\"Content-Type\": \"application/json\"]\n        case .signNotFirstLogin,\n                .checkOldPassword,\n                .logOut:\n            return [: ]\n        case .changePassword:\n            return [\"menuPath\": MenuPath.changePassword.info]\n        default:\n            return [: ]\n        }\n    }\n    \n}\n```\n\n首先是建立了一个常量，一个Networking包装了MyServerType，当然这个MyServerType和Networking都是封装好的。主要操作就是自定义这个MyServerType了。\n\n这个接口基本就写好了。\n请求头可配置，参数可配置，接口路径可配置，后端怎么改都不怕了。\n\n然后就是我们调用的地方了。\n\n在登录的地方这样用：\n```swift\n loginApiRequest.requestJson(.userAccountLogin(userName: userName, passWord: safePassWord)) {result in\n    let json = JSON.init(rawValue: result)\n    if json?[\"code\"].intValue == 1000 {\n        MBProgressHUD.hide()\n        guard let model = UserInformationData.deserialize(from: json?[\"data\"].jsonString) else { return }\n        self.saveLoginSuccessUserInformation(model: model, userName: userName, passWord: passWord)\n        callBack(model)\n        \n        self.requestUploadLog(userName,1,\"登录成功\")\n    }else{\n        MBProgressHUD.hide()\n        let str = json?[\"message\"].stringValue ?? \"登录失败\"\n        GMToast.showFailure(str)\n        self.requestUploadLog(userName,0,str)\n    }\n    \n} failure: { error in\n    MBProgressHUD.hide()\n    GMToast.showFailure()\n}\n```\n\nloginApiRequest就是我们前面定义的登录类接口的常量。\n\n因为这是一个Networking，所有它有requestJson方法，这个方法也是框架自己二次封装好的，等下具体分析下这里面的代码即可。\n\n注意到这里有传参，需要关注下.userAccoutLogin是啥东西？\n> 原来就是我们定义的泛型类，MyServerType，这里.userAccountLogin是一个枚举也是一个MyServerType，我们可以在这里面添加请求参数，这样就关联起来了。\n\n```swift\nenum UserLoginAPIManagerService {\n    /// 账号密码登录\n    case userAccountLogin(userName:String, passWord:String)\n    /// 是否显示注册\n    case isShowRegister\n    /// 注册\n    case register(_ params: [String: Any])\n    /// 更新是否已经提醒用户修改密码标记\n    case signNotFirstLogin(userId:String)\n    /// 修改密码\n    case changePassword(newPassword:String, oldPassword:String, username:String)\n    /// 校验原密码\n    case checkOldPassword(oldPassword:String, username:String)\n    /// 登出\n    case logOut\n\n}\n```\n果然就是第一个“账号密码登录”。\n\n所有对于使用还是相当方便的，只需要写一个Manager，就可以很方便请求接口了。\n\n## 4 细节分析\n\n继续上面的案例，当我们发送json请求时，走了一个框架封装好的方法，看下：\n```swift\n@discardableResult\n    public func requestJson(_ target: T,\n                            callbackQueue: DispatchQueue? = DispatchQueue.main,\n                            progress: ProgressBlock? = .none,\n                            success: @escaping JsonSuccess,\n                            failure: @escaping Failure) -> Cancellable {\n        return self.request(target, callbackQueue: callbackQueue, progress: progress, success: { (response) in\n            do {\n                let result = try JSON.init(data: response.data)\n                let vc = UIViewController.current()\n                if vc is LoginPageViewController {}else{\n                    if response.statusCode == 403 || response.statusCode == 401 {\n                        //token过期\n                        if tokenInvalidHandle != nil {\n                            tokenInvalidHandle()\n                            return\n                        }\n                    }\n                }\n                #if DEBUG\n                    print(result)\n                #endif\n                success(result)\n            } catch (let error) {\n                failure(error as? NetworkError ?? NetworkError.invalidURL)\n            }\n        }) { (error) in\n            #if DEBUG\n                print(error)\n            #endif\n            failure(error)\n        }\n    }\n```\n这里继续走了内部的self.request方法，T就是我们自定义的MyServerType。\n里面回调是我们自己的逻辑，就是解析了下Json，然后就是403或401的时候，跳转了登录页，这里的逻辑不需要关注。\n\n看下内部的request方法吧：\n```swift\n@discardableResult\n    public func request(_ target: T,\n                        callbackQueue: DispatchQueue? = DispatchQueue.main,\n                        progress: ProgressBlock? = .none,\n                        success: @escaping Success,\n                        failure: @escaping Failure) -> Cancellable {\n        return self.provider.request(target, callbackQueue: callbackQueue, progress: progress) { (result) in\n            switch result {\n            case let .success(response):\n                #if DEBUG\n                if let body = response.request?.httpBody,\n                   let param = String(data: body, encoding: .utf8),\n                   let interface = response.request?.url {\n                    print(\"✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅\")\n                    print(\"接口地址：\\n\\(interface)\")\n                    print(\"✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅\")\n                    print(\"请求参数：\\n\\(param)\")\n                    print(\"✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅\")\n                }\n                #endif\n                success(response);\n            case let .failure(error):\n                #if DEBUG\n                print(\"❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌\")\n                print(error)\n                #endif\n                let err = NetworkError.init(error: error)\n                failure(err);\n                break\n            }\n        }\n    }\n```\n这里的回调队列，进度，都有默认实例，当然可以自由传递。\n另外就是成功和失败的逃逸闭包了。\n\n其实内部继续走了self.provider.request才是重中之重。\n\n\n### 4.1 生产Moya Provider\n首先看下provider怎么来的：\n```swift\npublic struct Networking<T: MyServerType> {\n    public let provider: MoyaProvider<T>\n    \n    public init(provider: MoyaProvider<T> = newDefaultProvider()) {\n        self.provider = provider\n    }\n}\n\npublic static func newDefaultProvider() -> MoyaProvider<T> {\n        return newProvider(plugins: plugins)\n}\n\n/// 如何新建MoyaProvider\nfunc newProvider<T>(plugins: [PluginType],session: Session = newManager()) -> MoyaProvider<T> where T: MyServerType {\n    \n    return MoyaProvider(endpointClosure: Networking<T>.endpointsClosure(),\n                        requestClosure: Networking<T>.endpointResolver(),\n                        stubClosure: Networking<T>.APIKeysBasedStubBehaviour,\n                        session: session,\n                        plugins: plugins,\n                        trackInflights: false\n    )\n}\n\n/// 新建Provider需要的参数1\nfunc newManager(delegate: SessionDelegate = SessionDelegate()) -> Session {\n//    let configuration = URLSessionConfiguration.default\n//    configuration.httpAdditionalHeaders = Alamofire.SessionManager.defaultHTTPHeaders\n    let configuration = Alamofire.Session.default.session.configuration\n    let session = Alamofire.Session(configuration: configuration, delegate: delegate, startRequestsImmediately: false)\n    return session\n}\n\n/// 新建Provider需要的参数2\nstatic var plugins: [PluginType] {\n        let activityPlugin = NewNetworkActivityPlugin { (state, targetType) in\n            switch state {\n            case .began:\n                if targetType.isShowLoading { //这是我扩展的协议\n                    // 显示loading\n                }\n            case .ended:\n                if targetType.isShowLoading { //这是我扩展的协议\n                    // 关闭loading\n                }\n            }\n        }\n        \n        return [\n            activityPlugin, myLoggorPlugin\n        ]\n    }\n\n```\n这里创建的时候，就默认传了一个默认的Provider，这个是Moya官方的哦。\n\n另外新建这个MoyaProvider的时候还需要3个闭包，我们通过Networking来生产：\n```swift\nstatic func endpointsClosure<T>() -> (T) -> Endpoint where T: MyServerType {\n    return { target in\n        var headers: [String: String] = target.headers ?? [:]\n        if apiEnvironment == .product {\n            //生产环境灰度\n            if canary == true {\n                headers[\"canary\"] = \"true\"\n            }\n        }\n        //生产环境api路径设置\n        var str = \"\"\n        str = URL(target: target).absoluteString\n        if apiEnvironment != .test && apiEnvironment != .dev {\n            str = str.replacingOccurrences(of: \"-test\", with: \"\", options: .literal, range: nil)\n        }\n        let absoluteString = str\n        let defaultEndpoint = Endpoint(\n            url: absoluteString,\n            sampleResponseClosure: { target.sampleResponse },\n            method: target.method,\n            task: target.task,\n            httpHeaderFields: headers\n        )\n        return defaultEndpoint;\n    }\n}\n\n//测试网络错误,如超时等.\nstatic func endpointResolver() -> MoyaProvider<T>.RequestClosure {\n    return { (endpoint, closure) in\n        do {\n            var request = try endpoint.urlRequest()\n            request.httpShouldHandleCookies = false\n            request.timeoutInterval = WebService.shared.timeoutInterval\n            closure(.success(request))\n        } catch let error {\n            closure(.failure(MoyaError.underlying(error, nil)))\n        }\n    }\n}   \n\nstatic func APIKeysBasedStubBehaviour<T>(_ target: T) -> Moya.StubBehavior where T: MyServerType {\n        return target.stubBehavior;\n    }\n```\n这里我们自己生产了3个闭包给moya，也是moya需要的3个闭包。\n\n### 4.2 继续走Provider的request\n\n```swift\n/// Designated request-making method. Returns a `Cancellable` token to cancel the request later.\n    @discardableResult\n    open func request(_ target: Target,\n                      callbackQueue: DispatchQueue? = .none,\n                      progress: ProgressBlock? = .none,\n                      completion: @escaping Completion) -> Cancellable {\n\n        let callbackQueue = callbackQueue ?? self.callbackQueue\n        return requestNormal(target, callbackQueue: callbackQueue, progress: progress, completion: completion)\n    }\n```\n这个是moya三方库里面的代码了，简单看下就好，不是我们这期重点。\n\n### 4.3 如何封装MyServerType\n\n个人感觉这个也是非常关键，我们外部使用，需要建立一个枚举，同时也是一个MyServerType，这个携带了请求参数，请求方法之类的，总之它包装了一切我们请求需要的东西。\n\n```swift\nimport Foundation\nimport Moya\n\npublic typealias HTTPMethod = Moya.Method\npublic typealias MyValidationType = Moya.ValidationType\npublic typealias MySampleResponse = Moya.EndpointSampleResponse\npublic typealias MyStubBehavior = Moya.StubBehavior\n\npublic protocol MyServerType: TargetType {\n    var isShowLoading: Bool { get }\n    /// 附加请求头（如需添加额外的，使用这个）\n    var appendHeaders: [String : String]? { get }\n    var parameters: [String: Any]? { get }\n    var stubBehavior: MyStubBehavior { get }\n    var sampleResponse: MySampleResponse { get }\n}\n```\n首先，它这个继承了Moya自己的TargetType，还增加了自己额外的一些协议。\n\n```swift\nextension MyServerType {\n    public var base: String { return WebService.shared.rootUrl}\n    \n    public var baseURL: URL { return URL(string: base)! }\n    /// 请求头 （默认请求头 + appendHeaders），需求添加额外的改appendHeaders\n    public var headers: [String : String]? {\n        var result: [String : String]? = WebService().headers\n        guard let appendHeaders = appendHeaders else { return result }\n        result = WebService().headers?.merging(appendHeaders, uniquingKeysWith: { (_, new) in new })\n        return result\n    }\n    public var appendHeaders: [String : String]? { return nil }\n    public var parameters: [String: Any]? { return WebService.shared.parameters }\n    \n    public var isShowLoading: Bool { return false }\n    \n    public var task: Task {\n        let encoding: ParameterEncoding\n        switch self.method {\n        case .post:\n            encoding = JSONEncoding.default\n        default:\n            encoding = URLEncoding.default\n        }\n        if let requestParameters = parameters {\n            return .requestParameters(parameters: requestParameters, encoding: encoding)\n        }\n        return .requestPlain\n    }\n    \n    \n    public var method: HTTPMethod {\n        return .post\n    }\n    \n    public var validationType: MyValidationType {\n        return .successCodes\n    }\n    \n    public var stubBehavior: StubBehavior {\n        return .never\n    }\n    \n    public var validate: Bool {\n        return false\n    }\n    \n    public var sampleData: Data {\n        return \"response: test data\".data(using: String.Encoding.utf8)!\n    }\n    \n    public var sampleResponse: MySampleResponse {\n        return .networkResponse(200, self.sampleData)\n    }\n}\n```\n这里应该是实现了默认值的设定。\n当然我们是可以更改的。\n\n```swift\nfunc myBaseUrl(_ path: String) -> String {\n    if path.isCompleteUrl { return path }\n    return WebService.shared.rootUrl;\n}\n\nfunc myPath(_ path: String) -> String {\n    if path.isCompleteUrl { return \"\" }\n    return path;\n}\n\nextension String {\n    var isCompleteUrl: Bool {\n        let scheme = self.lowercased()\n        if scheme.contains(\"http\") { return true }\n        return false\n    }\n}\n```\n然后是其它工具方法。\n\n这里有用到一个WebService类，这里面存放的也是一些默认值设定：\n```swift\nimport Foundation\nimport UIKit\nimport AdSupport\nimport Alamofire\nimport Moya\n\nclass WebService: NSObject {\n    \n    var rootUrl: String = mainHost\n    var headers: [String: String]? = defaultHeaders()\n    var parameters: [String: Any]? = defaultParameters()\n    var timeoutInterval: Double = 30.0\n    //和服务器时间相差的时间戳:备注每次app恢复活跃状态需更新一次\n    static var serviceTimeSpace: String?\n    \n    static let shared = WebService()\n    override init() {}\n    \n    static func defaultHeaders() -> [String : String]? {\n        var headers = [\"x-flag\": \"iOS\", \"serverName\": \"APP\", \"clientId\": clientId]\n        if let token = Defaults[key: DefaultsKeys.access_token] {\n            headers[\"Authorization\"] = \"Bearer\" + token\n        }\n        let isMonopoly = Defaults[key: DefaultsKeys.isMonopoly] ?? false\n        /// appVersion 字段，（1表示专业版，0表示简易版）\n        headers[\"appVersion\"] = isMonopoly ? \"0\" : \"1\"\n        return headers\n    }\n    \n    static func defaultParameters() -> [String : Any]? {\n        return [\"platform\" : \"ios\",\n            \"version\" : \"1.2.3\",\n        ]\n    }\n    \n    /**\n     获取当前app版本号\n     */\n    static func getAppShortVersion() -> String {\n        let infoDictionary = Bundle.main.infoDictionary!\n        let version = infoDictionary[\"CFBundleShortVersionString\"] as! String\n        return version\n    }\n    \n    /**\n    获取当前请求User-Agent\n     */\n    static func getUserAgent() -> String {\n        let infoDictionary = Bundle.main.infoDictionary!\n        let version = infoDictionary[\"CFBundleShortVersionString\"] as! String\n        let userAgent = String(format: \"GREEMall%@(%@; iOS %@; Scale/%.2f)\", version, UIDevice.current.model, UIDevice.current.systemVersion, UIScreen.main.scale)\n        \n        return userAgent\n    }\n    \n    /**\n    获取服务器时间和计算时间差\n     */\n    static func setServiceTimeInterval(timeInterval:TimeInterval) {\n        serviceTimeSpace = String(format: \"%@\", timeInterval)\n    }\n    \n    /**\n     获取服务器时间戳\n     */\n    static func getServiceTimeInterval() -> Int {\n        return Int(serviceTimeSpace!)!\n    }\n    \n    /**\n     设置请求统一参数\n     */\n    static func getSystemParameterData() -> Dictionary<String, String> {\n        var data = [String: String]()\n        data[\"source\"] = \"iOS\"\n        var timeSpace: String = \"\"\n        if serviceTimeSpace != nil {\n            let now: TimeInterval = Date.init().timeIntervalSince1970\n            let appTime: TimeInterval = now + Double(CLongLong(serviceTimeSpace!)!)\n            timeSpace = String(format:\"%@\", appTime)\n        } else {\n            timeSpace = String(format:\"%@\", Date.init().timeIntervalSince1970)\n        }\n        data[\"t\"] = timeSpace\n        data[\"version\"] = self.getAppShortVersion()\n        data[\"ios_idfa\"] = ASIdentifierManager.shared().advertisingIdentifier.uuidString\n        return data\n    }\n    \n    /**\n     签名MD5处理\n     */\n    static func appendSign(paramterDic: Dictionary<String, String>, secrekey:String) -> String {\n        var sign:String = \"\"\n        var keys:Array = Array(paramterDic.keys)\n        keys = keys.sorted()\n        for key:String in keys {\n            if key == \"sign\" {\n                continue\n            } else {\n                let keyValue: String = String(format: \"%@\", paramterDic[key]!)\n                sign.append(String(format: \"%@%@\", key, keyValue.EscapesValr))\n            }\n        }\n        sign.append(secrekey)\n        return sign.td.md5.uppercased()\n    }\n}\n```\n\n大致就是这样了。\n\n## 5 总结\n\n* 这个二次封装主要是基于Moya，简化moya流程，提供了一个MyServerType，封装了一些请求参数，请求方法，方便我们进行接口配置。\n\n* 使用方法很简单，不过需要将一类接口单独放置，全部放一起不方便管理，这里比如登录相关接口统一用一个Manger配置，接口参数都写在这个Manager里面，其实也是由一定好处的。\n\n* 这里将moya更加封装成一个系统了，我们需要的结果无非就是接口成功或失败，传参也是我们必要的，将必要的都封装起来了，总体上使用还是比较便捷。\n\n* 如果有特殊请求，比如下载文件这种，需要我们单独抽一个方法处理，这里稍微增加了一点复杂度吧，一般的请求还是可以直接使用的。","slug":"iOS-swift-网络请求二次封装moya","published":1,"updated":"2023-02-01T06:34:58.913Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlc01jf000sjhv7afmadpfr","content":"<h2 id=\"1-github地址\"><a href=\"#1-github地址\" class=\"headerlink\" title=\"1 github地址\"></a>1 github地址</h2><blockquote>\n<p><a href=\"https://github.com/chensx1993/moyaManager\">https://github.com/chensx1993/moyaManager</a></p>\n</blockquote>\n<p>这个应该是一个小姐姐，我看到我们项目用了这个三方库，所以这边分析下封装细节。</p>\n<p>简单介绍下吧：</p>\n<p>moya是对Alamofire的再次封装。它可以实现各种自定义配置，真正实现了对网络层的高度抽象。</p>\n<p>还有一个优秀的网络框架(<a href=\"https://github.com/mmoaay/Bamboots\">github地址</a>)，大家可以看看，跟<code>moya</code>对比一下。</p>\n<p>有关moya的介绍可以看看: <a href=\"https://www.jianshu.com/p/2ee5258828ff\">Moya的使用</a>。</p>\n<h2 id=\"2-框架架构\"><a href=\"#2-框架架构\" class=\"headerlink\" title=\"2 框架架构\"></a>2 框架架构</h2><img src=moya1.png>\n\n<ul>\n<li><p>Core应该是核心模块，存放网络状态管理员，Network.swift应该是最关键的暴露给开发者使用的类吧，所有的请求都是经过这层转发的，Request就是内部请求相关，比如get和post请求层的封装吧。</p>\n</li>\n<li><p>Extension是扩展层，这里扩展了String，也扩展了网络请求基础返回体，这里可以根据项目来。</p>\n</li>\n<li><p>Plugin是插件层，这个可以自由添加。</p>\n</li>\n<li><p>Server是网络层，这里我们可以定义一些通过的请求参数，比如token啥的。</p>\n</li>\n<li><p>API层，这就和我们自己定义的Api相关了，怎么请求，怎么传参这些定义。</p>\n</li>\n<li><p>Error层，这里应该是异常层了。</p>\n</li>\n</ul>\n<h2 id=\"3-实例分析\"><a href=\"#3-实例分析\" class=\"headerlink\" title=\"3 实例分析\"></a>3 实例分析</h2><p>这里我们考虑用一个真实案例，来深入分析这个封装框架如何实现网络请求的。<br>这里就以登录接口为案例吧。</p>\n<p>可以建立一个登录相关接口，比如修改密码啥的，跟登录有关的统一用一个Manager。<br>如下：</p>\n<pre><code class=\"line-numbers language-swift\">import Foundation\nimport Moya\n\n// MARK: - 用户登录信息请求\nlet loginApiRequest = Networking&lt;UserLoginAPIManagerService&gt;()\n\n\nenum UserLoginAPIManagerService &#123;\n    /// 账号密码登录\n    case userAccountLogin(userName:String, passWord:String)\n    /// 是否显示注册\n    case isShowRegister\n    /// 注册\n    case register(_ params: [String: Any])\n    /// 更新是否已经提醒用户修改密码标记\n    case signNotFirstLogin(userId:String)\n    /// 修改密码\n    case changePassword(newPassword:String, oldPassword:String, username:String)\n    /// 校验原密码\n    case checkOldPassword(oldPassword:String, username:String)\n    /// 登出\n    case logOut\n\n&#125;\n\nextension UserLoginAPIManagerService : MyServerType &#123;\n    \n    //域名\n    var baseURL: URL &#123;\n        switch self &#123;\n        case .register:\n            return URL(string: mainHost)!\n        case .isShowRegister:\n            return URL(string: mainHost)!\n        case .userAccountLogin:\n            return URL(string: LoginHost)!\n        case .signNotFirstLogin:\n            return URL(string: mainHost)!\n        case .changePassword,.checkOldPassword:\n            return URL(string: mainHost)!\n        default:\n            return URL(string: LoginHost)!\n        &#125;\n        \n    &#125;\n    \n    //接口路径\n    public var path: String &#123;\n        switch self &#123;\n        case .userAccountLogin:\n            return &quot;oauth/token&quot;\n        case .register:\n            return &quot;v1/user/Register&quot;\n        case.isShowRegister:\n            return &quot;v1/user/iosIsEnabled&quot;\n        case .signNotFirstLogin:\n            return &quot;v1/exposure/password/flag&quot;\n        case .changePassword:\n            return &quot;v1/user/reset/myself&quot;\n        case .logOut:\n            return &quot;ssoLogout&quot;\n        case .checkOldPassword:\n            return &quot;v1/user/check/reset-password&quot;\n        &#125;\n    &#125;\n    \n    //是否执行Alamofire验证\n    var validate: Bool &#123;\n        return false\n    &#125;\n    \n    //验证方式\n    var validationType: MyValidationType &#123;\n        return .none\n    &#125;\n    \n    //单元测试模拟的数据\n    var sampleData: Data &#123;\n        return &quot;&#123;&#125;&quot;.data(using: String.Encoding.utf8)!\n    &#125;\n    \n    //请求类型：get、post、delete、put\n    var method: HTTPMethod &#123;\n        switch self &#123;\n        case .userAccountLogin(userName: _ , passWord: _),\n                .register,\n                .isShowRegister,\n                .changePassword,\n                .checkOldPassword:\n            return .post\n        default:\n            return .get\n        &#125;\n    &#125;\n    \n    //请求任务:\n    public var task: Task &#123;\n        switch self &#123;\n        case .userAccountLogin(let userName, let passWord):\n            let secret = &quot;1234&quot;.toMD5\n            let params = [&quot;client_id&quot;: clientId,\n                          &quot;client_secret&quot;:secret,\n                          &quot;username&quot;: userName,\n                          &quot;password&quot;: passWord] as [String : Any]\n            return .requestParameters(parameters: params, encoding:URLEncoding.default)\n        case .register(let params):\n            return .requestParameters(parameters: params, encoding:JSONEncoding.default)\n        case .isShowRegister:\n            return .requestParameters(parameters: [: ], encoding: URLEncoding.default)\n        case .logOut:\n            return .requestPlain\n        case .signNotFirstLogin(let userId):\n            let params = [&quot;userId&quot;: userId] as [String : Any]\n            return .requestParameters(parameters: params, encoding:URLEncoding.default)\n        case .changePassword(let newPassword, let oldPassword, let username):\n            let params = [&quot;newPassword&quot;:newPassword,\n                          &quot;oldPassword&quot;:oldPassword,\n                          &quot;username&quot;: username] as [String : Any]\n            return .requestParameters(parameters: params, encoding: JSONEncoding.default)\n        case .checkOldPassword(let oldPassword, let username):\n            let params = [&quot;oldPassword&quot;:oldPassword,\n                          &quot;username&quot;: username] as [String : Any]\n            return .requestParameters(parameters: params, encoding: JSONEncoding.default)\n        &#125;\n        \n    &#125;\n    \n    //请求头\n    var appendHeaders: [String : String]? &#123;\n        switch self &#123;\n        case .register:\n            return [&quot;Content-Type&quot;: &quot;application/json&quot;]\n        case .signNotFirstLogin,\n                .checkOldPassword,\n                .logOut:\n            return [: ]\n        case .changePassword:\n            return [&quot;menuPath&quot;: MenuPath.changePassword.info]\n        default:\n            return [: ]\n        &#125;\n    &#125;\n    \n&#125;\n</code></pre>\n<p>首先是建立了一个常量，一个Networking包装了MyServerType，当然这个MyServerType和Networking都是封装好的。主要操作就是自定义这个MyServerType了。</p>\n<p>这个接口基本就写好了。<br>请求头可配置，参数可配置，接口路径可配置，后端怎么改都不怕了。</p>\n<p>然后就是我们调用的地方了。</p>\n<p>在登录的地方这样用：</p>\n<pre><code class=\"line-numbers language-swift\"> loginApiRequest.requestJson(.userAccountLogin(userName: userName, passWord: safePassWord)) &#123;result in\n    let json = JSON.init(rawValue: result)\n    if json?[&quot;code&quot;].intValue == 1000 &#123;\n        MBProgressHUD.hide()\n        guard let model = UserInformationData.deserialize(from: json?[&quot;data&quot;].jsonString) else &#123; return &#125;\n        self.saveLoginSuccessUserInformation(model: model, userName: userName, passWord: passWord)\n        callBack(model)\n        \n        self.requestUploadLog(userName,1,&quot;登录成功&quot;)\n    &#125;else&#123;\n        MBProgressHUD.hide()\n        let str = json?[&quot;message&quot;].stringValue ?? &quot;登录失败&quot;\n        GMToast.showFailure(str)\n        self.requestUploadLog(userName,0,str)\n    &#125;\n    \n&#125; failure: &#123; error in\n    MBProgressHUD.hide()\n    GMToast.showFailure()\n&#125;\n</code></pre>\n<p>loginApiRequest就是我们前面定义的登录类接口的常量。</p>\n<p>因为这是一个Networking，所有它有requestJson方法，这个方法也是框架自己二次封装好的，等下具体分析下这里面的代码即可。</p>\n<p>注意到这里有传参，需要关注下.userAccoutLogin是啥东西？</p>\n<blockquote>\n<p>原来就是我们定义的泛型类，MyServerType，这里.userAccountLogin是一个枚举也是一个MyServerType，我们可以在这里面添加请求参数，这样就关联起来了。</p>\n</blockquote>\n<pre><code class=\"line-numbers language-swift\">enum UserLoginAPIManagerService &#123;\n    /// 账号密码登录\n    case userAccountLogin(userName:String, passWord:String)\n    /// 是否显示注册\n    case isShowRegister\n    /// 注册\n    case register(_ params: [String: Any])\n    /// 更新是否已经提醒用户修改密码标记\n    case signNotFirstLogin(userId:String)\n    /// 修改密码\n    case changePassword(newPassword:String, oldPassword:String, username:String)\n    /// 校验原密码\n    case checkOldPassword(oldPassword:String, username:String)\n    /// 登出\n    case logOut\n\n&#125;\n</code></pre>\n<p>果然就是第一个“账号密码登录”。</p>\n<p>所有对于使用还是相当方便的，只需要写一个Manager，就可以很方便请求接口了。</p>\n<h2 id=\"4-细节分析\"><a href=\"#4-细节分析\" class=\"headerlink\" title=\"4 细节分析\"></a>4 细节分析</h2><p>继续上面的案例，当我们发送json请求时，走了一个框架封装好的方法，看下：</p>\n<pre><code class=\"line-numbers language-swift\">@discardableResult\n    public func requestJson(_ target: T,\n                            callbackQueue: DispatchQueue? = DispatchQueue.main,\n                            progress: ProgressBlock? = .none,\n                            success: @escaping JsonSuccess,\n                            failure: @escaping Failure) -&gt; Cancellable &#123;\n        return self.request(target, callbackQueue: callbackQueue, progress: progress, success: &#123; (response) in\n            do &#123;\n                let result = try JSON.init(data: response.data)\n                let vc = UIViewController.current()\n                if vc is LoginPageViewController &#123;&#125;else&#123;\n                    if response.statusCode == 403 || response.statusCode == 401 &#123;\n                        //token过期\n                        if tokenInvalidHandle != nil &#123;\n                            tokenInvalidHandle()\n                            return\n                        &#125;\n                    &#125;\n                &#125;\n                #if DEBUG\n                    print(result)\n                #endif\n                success(result)\n            &#125; catch (let error) &#123;\n                failure(error as? NetworkError ?? NetworkError.invalidURL)\n            &#125;\n        &#125;) &#123; (error) in\n            #if DEBUG\n                print(error)\n            #endif\n            failure(error)\n        &#125;\n    &#125;\n</code></pre>\n<p>这里继续走了内部的self.request方法，T就是我们自定义的MyServerType。<br>里面回调是我们自己的逻辑，就是解析了下Json，然后就是403或401的时候，跳转了登录页，这里的逻辑不需要关注。</p>\n<p>看下内部的request方法吧：</p>\n<pre><code class=\"line-numbers language-swift\">@discardableResult\n    public func request(_ target: T,\n                        callbackQueue: DispatchQueue? = DispatchQueue.main,\n                        progress: ProgressBlock? = .none,\n                        success: @escaping Success,\n                        failure: @escaping Failure) -&gt; Cancellable &#123;\n        return self.provider.request(target, callbackQueue: callbackQueue, progress: progress) &#123; (result) in\n            switch result &#123;\n            case let .success(response):\n                #if DEBUG\n                if let body = response.request?.httpBody,\n                   let param = String(data: body, encoding: .utf8),\n                   let interface = response.request?.url &#123;\n                    print(&quot;✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅&quot;)\n                    print(&quot;接口地址：\\n\\(interface)&quot;)\n                    print(&quot;✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅&quot;)\n                    print(&quot;请求参数：\\n\\(param)&quot;)\n                    print(&quot;✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅&quot;)\n                &#125;\n                #endif\n                success(response);\n            case let .failure(error):\n                #if DEBUG\n                print(&quot;❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌&quot;)\n                print(error)\n                #endif\n                let err = NetworkError.init(error: error)\n                failure(err);\n                break\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>这里的回调队列，进度，都有默认实例，当然可以自由传递。<br>另外就是成功和失败的逃逸闭包了。</p>\n<p>其实内部继续走了self.provider.request才是重中之重。</p>\n<h3 id=\"4-1-生产Moya-Provider\"><a href=\"#4-1-生产Moya-Provider\" class=\"headerlink\" title=\"4.1 生产Moya Provider\"></a>4.1 生产Moya Provider</h3><p>首先看下provider怎么来的：</p>\n<pre><code class=\"line-numbers language-swift\">public struct Networking&lt;T: MyServerType&gt; &#123;\n    public let provider: MoyaProvider&lt;T&gt;\n    \n    public init(provider: MoyaProvider&lt;T&gt; = newDefaultProvider()) &#123;\n        self.provider = provider\n    &#125;\n&#125;\n\npublic static func newDefaultProvider() -&gt; MoyaProvider&lt;T&gt; &#123;\n        return newProvider(plugins: plugins)\n&#125;\n\n/// 如何新建MoyaProvider\nfunc newProvider&lt;T&gt;(plugins: [PluginType],session: Session = newManager()) -&gt; MoyaProvider&lt;T&gt; where T: MyServerType &#123;\n    \n    return MoyaProvider(endpointClosure: Networking&lt;T&gt;.endpointsClosure(),\n                        requestClosure: Networking&lt;T&gt;.endpointResolver(),\n                        stubClosure: Networking&lt;T&gt;.APIKeysBasedStubBehaviour,\n                        session: session,\n                        plugins: plugins,\n                        trackInflights: false\n    )\n&#125;\n\n/// 新建Provider需要的参数1\nfunc newManager(delegate: SessionDelegate = SessionDelegate()) -&gt; Session &#123;\n//    let configuration = URLSessionConfiguration.default\n//    configuration.httpAdditionalHeaders = Alamofire.SessionManager.defaultHTTPHeaders\n    let configuration = Alamofire.Session.default.session.configuration\n    let session = Alamofire.Session(configuration: configuration, delegate: delegate, startRequestsImmediately: false)\n    return session\n&#125;\n\n/// 新建Provider需要的参数2\nstatic var plugins: [PluginType] &#123;\n        let activityPlugin = NewNetworkActivityPlugin &#123; (state, targetType) in\n            switch state &#123;\n            case .began:\n                if targetType.isShowLoading &#123; //这是我扩展的协议\n                    // 显示loading\n                &#125;\n            case .ended:\n                if targetType.isShowLoading &#123; //这是我扩展的协议\n                    // 关闭loading\n                &#125;\n            &#125;\n        &#125;\n        \n        return [\n            activityPlugin, myLoggorPlugin\n        ]\n    &#125;\n</code></pre>\n<p>这里创建的时候，就默认传了一个默认的Provider，这个是Moya官方的哦。</p>\n<p>另外新建这个MoyaProvider的时候还需要3个闭包，我们通过Networking来生产：</p>\n<pre><code class=\"line-numbers language-swift\">static func endpointsClosure&lt;T&gt;() -&gt; (T) -&gt; Endpoint where T: MyServerType &#123;\n    return &#123; target in\n        var headers: [String: String] = target.headers ?? [:]\n        if apiEnvironment == .product &#123;\n            //生产环境灰度\n            if canary == true &#123;\n                headers[&quot;canary&quot;] = &quot;true&quot;\n            &#125;\n        &#125;\n        //生产环境api路径设置\n        var str = &quot;&quot;\n        str = URL(target: target).absoluteString\n        if apiEnvironment != .test &amp;&amp; apiEnvironment != .dev &#123;\n            str = str.replacingOccurrences(of: &quot;-test&quot;, with: &quot;&quot;, options: .literal, range: nil)\n        &#125;\n        let absoluteString = str\n        let defaultEndpoint = Endpoint(\n            url: absoluteString,\n            sampleResponseClosure: &#123; target.sampleResponse &#125;,\n            method: target.method,\n            task: target.task,\n            httpHeaderFields: headers\n        )\n        return defaultEndpoint;\n    &#125;\n&#125;\n\n//测试网络错误,如超时等.\nstatic func endpointResolver() -&gt; MoyaProvider&lt;T&gt;.RequestClosure &#123;\n    return &#123; (endpoint, closure) in\n        do &#123;\n            var request = try endpoint.urlRequest()\n            request.httpShouldHandleCookies = false\n            request.timeoutInterval = WebService.shared.timeoutInterval\n            closure(.success(request))\n        &#125; catch let error &#123;\n            closure(.failure(MoyaError.underlying(error, nil)))\n        &#125;\n    &#125;\n&#125;   \n\nstatic func APIKeysBasedStubBehaviour&lt;T&gt;(_ target: T) -&gt; Moya.StubBehavior where T: MyServerType &#123;\n        return target.stubBehavior;\n    &#125;\n</code></pre>\n<p>这里我们自己生产了3个闭包给moya，也是moya需要的3个闭包。</p>\n<h3 id=\"4-2-继续走Provider的request\"><a href=\"#4-2-继续走Provider的request\" class=\"headerlink\" title=\"4.2 继续走Provider的request\"></a>4.2 继续走Provider的request</h3><pre><code class=\"line-numbers language-swift\">/// Designated request-making method. Returns a `Cancellable` token to cancel the request later.\n    @discardableResult\n    open func request(_ target: Target,\n                      callbackQueue: DispatchQueue? = .none,\n                      progress: ProgressBlock? = .none,\n                      completion: @escaping Completion) -&gt; Cancellable &#123;\n\n        let callbackQueue = callbackQueue ?? self.callbackQueue\n        return requestNormal(target, callbackQueue: callbackQueue, progress: progress, completion: completion)\n    &#125;\n</code></pre>\n<p>这个是moya三方库里面的代码了，简单看下就好，不是我们这期重点。</p>\n<h3 id=\"4-3-如何封装MyServerType\"><a href=\"#4-3-如何封装MyServerType\" class=\"headerlink\" title=\"4.3 如何封装MyServerType\"></a>4.3 如何封装MyServerType</h3><p>个人感觉这个也是非常关键，我们外部使用，需要建立一个枚举，同时也是一个MyServerType，这个携带了请求参数，请求方法之类的，总之它包装了一切我们请求需要的东西。</p>\n<pre><code class=\"line-numbers language-swift\">import Foundation\nimport Moya\n\npublic typealias HTTPMethod = Moya.Method\npublic typealias MyValidationType = Moya.ValidationType\npublic typealias MySampleResponse = Moya.EndpointSampleResponse\npublic typealias MyStubBehavior = Moya.StubBehavior\n\npublic protocol MyServerType: TargetType &#123;\n    var isShowLoading: Bool &#123; get &#125;\n    /// 附加请求头（如需添加额外的，使用这个）\n    var appendHeaders: [String : String]? &#123; get &#125;\n    var parameters: [String: Any]? &#123; get &#125;\n    var stubBehavior: MyStubBehavior &#123; get &#125;\n    var sampleResponse: MySampleResponse &#123; get &#125;\n&#125;\n</code></pre>\n<p>首先，它这个继承了Moya自己的TargetType，还增加了自己额外的一些协议。</p>\n<pre><code class=\"line-numbers language-swift\">extension MyServerType &#123;\n    public var base: String &#123; return WebService.shared.rootUrl&#125;\n    \n    public var baseURL: URL &#123; return URL(string: base)! &#125;\n    /// 请求头 （默认请求头 + appendHeaders），需求添加额外的改appendHeaders\n    public var headers: [String : String]? &#123;\n        var result: [String : String]? = WebService().headers\n        guard let appendHeaders = appendHeaders else &#123; return result &#125;\n        result = WebService().headers?.merging(appendHeaders, uniquingKeysWith: &#123; (_, new) in new &#125;)\n        return result\n    &#125;\n    public var appendHeaders: [String : String]? &#123; return nil &#125;\n    public var parameters: [String: Any]? &#123; return WebService.shared.parameters &#125;\n    \n    public var isShowLoading: Bool &#123; return false &#125;\n    \n    public var task: Task &#123;\n        let encoding: ParameterEncoding\n        switch self.method &#123;\n        case .post:\n            encoding = JSONEncoding.default\n        default:\n            encoding = URLEncoding.default\n        &#125;\n        if let requestParameters = parameters &#123;\n            return .requestParameters(parameters: requestParameters, encoding: encoding)\n        &#125;\n        return .requestPlain\n    &#125;\n    \n    \n    public var method: HTTPMethod &#123;\n        return .post\n    &#125;\n    \n    public var validationType: MyValidationType &#123;\n        return .successCodes\n    &#125;\n    \n    public var stubBehavior: StubBehavior &#123;\n        return .never\n    &#125;\n    \n    public var validate: Bool &#123;\n        return false\n    &#125;\n    \n    public var sampleData: Data &#123;\n        return &quot;response: test data&quot;.data(using: String.Encoding.utf8)!\n    &#125;\n    \n    public var sampleResponse: MySampleResponse &#123;\n        return .networkResponse(200, self.sampleData)\n    &#125;\n&#125;\n</code></pre>\n<p>这里应该是实现了默认值的设定。<br>当然我们是可以更改的。</p>\n<pre><code class=\"line-numbers language-swift\">func myBaseUrl(_ path: String) -&gt; String &#123;\n    if path.isCompleteUrl &#123; return path &#125;\n    return WebService.shared.rootUrl;\n&#125;\n\nfunc myPath(_ path: String) -&gt; String &#123;\n    if path.isCompleteUrl &#123; return &quot;&quot; &#125;\n    return path;\n&#125;\n\nextension String &#123;\n    var isCompleteUrl: Bool &#123;\n        let scheme = self.lowercased()\n        if scheme.contains(&quot;http&quot;) &#123; return true &#125;\n        return false\n    &#125;\n&#125;\n</code></pre>\n<p>然后是其它工具方法。</p>\n<p>这里有用到一个WebService类，这里面存放的也是一些默认值设定：</p>\n<pre><code class=\"line-numbers language-swift\">import Foundation\nimport UIKit\nimport AdSupport\nimport Alamofire\nimport Moya\n\nclass WebService: NSObject &#123;\n    \n    var rootUrl: String = mainHost\n    var headers: [String: String]? = defaultHeaders()\n    var parameters: [String: Any]? = defaultParameters()\n    var timeoutInterval: Double = 30.0\n    //和服务器时间相差的时间戳:备注每次app恢复活跃状态需更新一次\n    static var serviceTimeSpace: String?\n    \n    static let shared = WebService()\n    override init() &#123;&#125;\n    \n    static func defaultHeaders() -&gt; [String : String]? &#123;\n        var headers = [&quot;x-flag&quot;: &quot;iOS&quot;, &quot;serverName&quot;: &quot;APP&quot;, &quot;clientId&quot;: clientId]\n        if let token = Defaults[key: DefaultsKeys.access_token] &#123;\n            headers[&quot;Authorization&quot;] = &quot;Bearer&quot; + token\n        &#125;\n        let isMonopoly = Defaults[key: DefaultsKeys.isMonopoly] ?? false\n        /// appVersion 字段，（1表示专业版，0表示简易版）\n        headers[&quot;appVersion&quot;] = isMonopoly ? &quot;0&quot; : &quot;1&quot;\n        return headers\n    &#125;\n    \n    static func defaultParameters() -&gt; [String : Any]? &#123;\n        return [&quot;platform&quot; : &quot;ios&quot;,\n            &quot;version&quot; : &quot;1.2.3&quot;,\n        ]\n    &#125;\n    \n    /**\n     获取当前app版本号\n     */\n    static func getAppShortVersion() -&gt; String &#123;\n        let infoDictionary = Bundle.main.infoDictionary!\n        let version = infoDictionary[&quot;CFBundleShortVersionString&quot;] as! String\n        return version\n    &#125;\n    \n    /**\n    获取当前请求User-Agent\n     */\n    static func getUserAgent() -&gt; String &#123;\n        let infoDictionary = Bundle.main.infoDictionary!\n        let version = infoDictionary[&quot;CFBundleShortVersionString&quot;] as! String\n        let userAgent = String(format: &quot;GREEMall%@(%@; iOS %@; Scale/%.2f)&quot;, version, UIDevice.current.model, UIDevice.current.systemVersion, UIScreen.main.scale)\n        \n        return userAgent\n    &#125;\n    \n    /**\n    获取服务器时间和计算时间差\n     */\n    static func setServiceTimeInterval(timeInterval:TimeInterval) &#123;\n        serviceTimeSpace = String(format: &quot;%@&quot;, timeInterval)\n    &#125;\n    \n    /**\n     获取服务器时间戳\n     */\n    static func getServiceTimeInterval() -&gt; Int &#123;\n        return Int(serviceTimeSpace!)!\n    &#125;\n    \n    /**\n     设置请求统一参数\n     */\n    static func getSystemParameterData() -&gt; Dictionary&lt;String, String&gt; &#123;\n        var data = [String: String]()\n        data[&quot;source&quot;] = &quot;iOS&quot;\n        var timeSpace: String = &quot;&quot;\n        if serviceTimeSpace != nil &#123;\n            let now: TimeInterval = Date.init().timeIntervalSince1970\n            let appTime: TimeInterval = now + Double(CLongLong(serviceTimeSpace!)!)\n            timeSpace = String(format:&quot;%@&quot;, appTime)\n        &#125; else &#123;\n            timeSpace = String(format:&quot;%@&quot;, Date.init().timeIntervalSince1970)\n        &#125;\n        data[&quot;t&quot;] = timeSpace\n        data[&quot;version&quot;] = self.getAppShortVersion()\n        data[&quot;ios_idfa&quot;] = ASIdentifierManager.shared().advertisingIdentifier.uuidString\n        return data\n    &#125;\n    \n    /**\n     签名MD5处理\n     */\n    static func appendSign(paramterDic: Dictionary&lt;String, String&gt;, secrekey:String) -&gt; String &#123;\n        var sign:String = &quot;&quot;\n        var keys:Array = Array(paramterDic.keys)\n        keys = keys.sorted()\n        for key:String in keys &#123;\n            if key == &quot;sign&quot; &#123;\n                continue\n            &#125; else &#123;\n                let keyValue: String = String(format: &quot;%@&quot;, paramterDic[key]!)\n                sign.append(String(format: &quot;%@%@&quot;, key, keyValue.EscapesValr))\n            &#125;\n        &#125;\n        sign.append(secrekey)\n        return sign.td.md5.uppercased()\n    &#125;\n&#125;\n</code></pre>\n<p>大致就是这样了。</p>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5 总结\"></a>5 总结</h2><ul>\n<li><p>这个二次封装主要是基于Moya，简化moya流程，提供了一个MyServerType，封装了一些请求参数，请求方法，方便我们进行接口配置。</p>\n</li>\n<li><p>使用方法很简单，不过需要将一类接口单独放置，全部放一起不方便管理，这里比如登录相关接口统一用一个Manger配置，接口参数都写在这个Manager里面，其实也是由一定好处的。</p>\n</li>\n<li><p>这里将moya更加封装成一个系统了，我们需要的结果无非就是接口成功或失败，传参也是我们必要的，将必要的都封装起来了，总体上使用还是比较便捷。</p>\n</li>\n<li><p>如果有特殊请求，比如下载文件这种，需要我们单独抽一个方法处理，这里稍微增加了一点复杂度吧，一般的请求还是可以直接使用的。</p>\n</li>\n</ul>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-github地址\"><a href=\"#1-github地址\" class=\"headerlink\" title=\"1 github地址\"></a>1 github地址</h2><blockquote>\n<p><a href=\"https://github.com/chensx1993/moyaManager\">https://github.com/chensx1993/moyaManager</a></p>\n</blockquote>\n<p>这个应该是一个小姐姐，我看到我们项目用了这个三方库，所以这边分析下封装细节。</p>\n<p>简单介绍下吧：</p>\n<p>moya是对Alamofire的再次封装。它可以实现各种自定义配置，真正实现了对网络层的高度抽象。</p>\n<p>还有一个优秀的网络框架(<a href=\"https://github.com/mmoaay/Bamboots\">github地址</a>)，大家可以看看，跟<code>moya</code>对比一下。</p>\n<p>有关moya的介绍可以看看: <a href=\"https://www.jianshu.com/p/2ee5258828ff\">Moya的使用</a>。</p>\n<h2 id=\"2-框架架构\"><a href=\"#2-框架架构\" class=\"headerlink\" title=\"2 框架架构\"></a>2 框架架构</h2><img src=moya1.png>\n\n<ul>\n<li><p>Core应该是核心模块，存放网络状态管理员，Network.swift应该是最关键的暴露给开发者使用的类吧，所有的请求都是经过这层转发的，Request就是内部请求相关，比如get和post请求层的封装吧。</p>\n</li>\n<li><p>Extension是扩展层，这里扩展了String，也扩展了网络请求基础返回体，这里可以根据项目来。</p>\n</li>\n<li><p>Plugin是插件层，这个可以自由添加。</p>\n</li>\n<li><p>Server是网络层，这里我们可以定义一些通过的请求参数，比如token啥的。</p>\n</li>\n<li><p>API层，这就和我们自己定义的Api相关了，怎么请求，怎么传参这些定义。</p>\n</li>\n<li><p>Error层，这里应该是异常层了。</p>\n</li>\n</ul>\n<h2 id=\"3-实例分析\"><a href=\"#3-实例分析\" class=\"headerlink\" title=\"3 实例分析\"></a>3 实例分析</h2><p>这里我们考虑用一个真实案例，来深入分析这个封装框架如何实现网络请求的。<br>这里就以登录接口为案例吧。</p>\n<p>可以建立一个登录相关接口，比如修改密码啥的，跟登录有关的统一用一个Manager。<br>如下：</p>\n<pre><code class=\"line-numbers language-swift\">import Foundation\nimport Moya\n\n// MARK: - 用户登录信息请求\nlet loginApiRequest = Networking&lt;UserLoginAPIManagerService&gt;()\n\n\nenum UserLoginAPIManagerService &#123;\n    /// 账号密码登录\n    case userAccountLogin(userName:String, passWord:String)\n    /// 是否显示注册\n    case isShowRegister\n    /// 注册\n    case register(_ params: [String: Any])\n    /// 更新是否已经提醒用户修改密码标记\n    case signNotFirstLogin(userId:String)\n    /// 修改密码\n    case changePassword(newPassword:String, oldPassword:String, username:String)\n    /// 校验原密码\n    case checkOldPassword(oldPassword:String, username:String)\n    /// 登出\n    case logOut\n\n&#125;\n\nextension UserLoginAPIManagerService : MyServerType &#123;\n    \n    //域名\n    var baseURL: URL &#123;\n        switch self &#123;\n        case .register:\n            return URL(string: mainHost)!\n        case .isShowRegister:\n            return URL(string: mainHost)!\n        case .userAccountLogin:\n            return URL(string: LoginHost)!\n        case .signNotFirstLogin:\n            return URL(string: mainHost)!\n        case .changePassword,.checkOldPassword:\n            return URL(string: mainHost)!\n        default:\n            return URL(string: LoginHost)!\n        &#125;\n        \n    &#125;\n    \n    //接口路径\n    public var path: String &#123;\n        switch self &#123;\n        case .userAccountLogin:\n            return &quot;oauth/token&quot;\n        case .register:\n            return &quot;v1/user/Register&quot;\n        case.isShowRegister:\n            return &quot;v1/user/iosIsEnabled&quot;\n        case .signNotFirstLogin:\n            return &quot;v1/exposure/password/flag&quot;\n        case .changePassword:\n            return &quot;v1/user/reset/myself&quot;\n        case .logOut:\n            return &quot;ssoLogout&quot;\n        case .checkOldPassword:\n            return &quot;v1/user/check/reset-password&quot;\n        &#125;\n    &#125;\n    \n    //是否执行Alamofire验证\n    var validate: Bool &#123;\n        return false\n    &#125;\n    \n    //验证方式\n    var validationType: MyValidationType &#123;\n        return .none\n    &#125;\n    \n    //单元测试模拟的数据\n    var sampleData: Data &#123;\n        return &quot;&#123;&#125;&quot;.data(using: String.Encoding.utf8)!\n    &#125;\n    \n    //请求类型：get、post、delete、put\n    var method: HTTPMethod &#123;\n        switch self &#123;\n        case .userAccountLogin(userName: _ , passWord: _),\n                .register,\n                .isShowRegister,\n                .changePassword,\n                .checkOldPassword:\n            return .post\n        default:\n            return .get\n        &#125;\n    &#125;\n    \n    //请求任务:\n    public var task: Task &#123;\n        switch self &#123;\n        case .userAccountLogin(let userName, let passWord):\n            let secret = &quot;1234&quot;.toMD5\n            let params = [&quot;client_id&quot;: clientId,\n                          &quot;client_secret&quot;:secret,\n                          &quot;username&quot;: userName,\n                          &quot;password&quot;: passWord] as [String : Any]\n            return .requestParameters(parameters: params, encoding:URLEncoding.default)\n        case .register(let params):\n            return .requestParameters(parameters: params, encoding:JSONEncoding.default)\n        case .isShowRegister:\n            return .requestParameters(parameters: [: ], encoding: URLEncoding.default)\n        case .logOut:\n            return .requestPlain\n        case .signNotFirstLogin(let userId):\n            let params = [&quot;userId&quot;: userId] as [String : Any]\n            return .requestParameters(parameters: params, encoding:URLEncoding.default)\n        case .changePassword(let newPassword, let oldPassword, let username):\n            let params = [&quot;newPassword&quot;:newPassword,\n                          &quot;oldPassword&quot;:oldPassword,\n                          &quot;username&quot;: username] as [String : Any]\n            return .requestParameters(parameters: params, encoding: JSONEncoding.default)\n        case .checkOldPassword(let oldPassword, let username):\n            let params = [&quot;oldPassword&quot;:oldPassword,\n                          &quot;username&quot;: username] as [String : Any]\n            return .requestParameters(parameters: params, encoding: JSONEncoding.default)\n        &#125;\n        \n    &#125;\n    \n    //请求头\n    var appendHeaders: [String : String]? &#123;\n        switch self &#123;\n        case .register:\n            return [&quot;Content-Type&quot;: &quot;application/json&quot;]\n        case .signNotFirstLogin,\n                .checkOldPassword,\n                .logOut:\n            return [: ]\n        case .changePassword:\n            return [&quot;menuPath&quot;: MenuPath.changePassword.info]\n        default:\n            return [: ]\n        &#125;\n    &#125;\n    \n&#125;\n</code></pre>\n<p>首先是建立了一个常量，一个Networking包装了MyServerType，当然这个MyServerType和Networking都是封装好的。主要操作就是自定义这个MyServerType了。</p>\n<p>这个接口基本就写好了。<br>请求头可配置，参数可配置，接口路径可配置，后端怎么改都不怕了。</p>\n<p>然后就是我们调用的地方了。</p>\n<p>在登录的地方这样用：</p>\n<pre><code class=\"line-numbers language-swift\"> loginApiRequest.requestJson(.userAccountLogin(userName: userName, passWord: safePassWord)) &#123;result in\n    let json = JSON.init(rawValue: result)\n    if json?[&quot;code&quot;].intValue == 1000 &#123;\n        MBProgressHUD.hide()\n        guard let model = UserInformationData.deserialize(from: json?[&quot;data&quot;].jsonString) else &#123; return &#125;\n        self.saveLoginSuccessUserInformation(model: model, userName: userName, passWord: passWord)\n        callBack(model)\n        \n        self.requestUploadLog(userName,1,&quot;登录成功&quot;)\n    &#125;else&#123;\n        MBProgressHUD.hide()\n        let str = json?[&quot;message&quot;].stringValue ?? &quot;登录失败&quot;\n        GMToast.showFailure(str)\n        self.requestUploadLog(userName,0,str)\n    &#125;\n    \n&#125; failure: &#123; error in\n    MBProgressHUD.hide()\n    GMToast.showFailure()\n&#125;\n</code></pre>\n<p>loginApiRequest就是我们前面定义的登录类接口的常量。</p>\n<p>因为这是一个Networking，所有它有requestJson方法，这个方法也是框架自己二次封装好的，等下具体分析下这里面的代码即可。</p>\n<p>注意到这里有传参，需要关注下.userAccoutLogin是啥东西？</p>\n<blockquote>\n<p>原来就是我们定义的泛型类，MyServerType，这里.userAccountLogin是一个枚举也是一个MyServerType，我们可以在这里面添加请求参数，这样就关联起来了。</p>\n</blockquote>\n<pre><code class=\"line-numbers language-swift\">enum UserLoginAPIManagerService &#123;\n    /// 账号密码登录\n    case userAccountLogin(userName:String, passWord:String)\n    /// 是否显示注册\n    case isShowRegister\n    /// 注册\n    case register(_ params: [String: Any])\n    /// 更新是否已经提醒用户修改密码标记\n    case signNotFirstLogin(userId:String)\n    /// 修改密码\n    case changePassword(newPassword:String, oldPassword:String, username:String)\n    /// 校验原密码\n    case checkOldPassword(oldPassword:String, username:String)\n    /// 登出\n    case logOut\n\n&#125;\n</code></pre>\n<p>果然就是第一个“账号密码登录”。</p>\n<p>所有对于使用还是相当方便的，只需要写一个Manager，就可以很方便请求接口了。</p>\n<h2 id=\"4-细节分析\"><a href=\"#4-细节分析\" class=\"headerlink\" title=\"4 细节分析\"></a>4 细节分析</h2><p>继续上面的案例，当我们发送json请求时，走了一个框架封装好的方法，看下：</p>\n<pre><code class=\"line-numbers language-swift\">@discardableResult\n    public func requestJson(_ target: T,\n                            callbackQueue: DispatchQueue? = DispatchQueue.main,\n                            progress: ProgressBlock? = .none,\n                            success: @escaping JsonSuccess,\n                            failure: @escaping Failure) -&gt; Cancellable &#123;\n        return self.request(target, callbackQueue: callbackQueue, progress: progress, success: &#123; (response) in\n            do &#123;\n                let result = try JSON.init(data: response.data)\n                let vc = UIViewController.current()\n                if vc is LoginPageViewController &#123;&#125;else&#123;\n                    if response.statusCode == 403 || response.statusCode == 401 &#123;\n                        //token过期\n                        if tokenInvalidHandle != nil &#123;\n                            tokenInvalidHandle()\n                            return\n                        &#125;\n                    &#125;\n                &#125;\n                #if DEBUG\n                    print(result)\n                #endif\n                success(result)\n            &#125; catch (let error) &#123;\n                failure(error as? NetworkError ?? NetworkError.invalidURL)\n            &#125;\n        &#125;) &#123; (error) in\n            #if DEBUG\n                print(error)\n            #endif\n            failure(error)\n        &#125;\n    &#125;\n</code></pre>\n<p>这里继续走了内部的self.request方法，T就是我们自定义的MyServerType。<br>里面回调是我们自己的逻辑，就是解析了下Json，然后就是403或401的时候，跳转了登录页，这里的逻辑不需要关注。</p>\n<p>看下内部的request方法吧：</p>\n<pre><code class=\"line-numbers language-swift\">@discardableResult\n    public func request(_ target: T,\n                        callbackQueue: DispatchQueue? = DispatchQueue.main,\n                        progress: ProgressBlock? = .none,\n                        success: @escaping Success,\n                        failure: @escaping Failure) -&gt; Cancellable &#123;\n        return self.provider.request(target, callbackQueue: callbackQueue, progress: progress) &#123; (result) in\n            switch result &#123;\n            case let .success(response):\n                #if DEBUG\n                if let body = response.request?.httpBody,\n                   let param = String(data: body, encoding: .utf8),\n                   let interface = response.request?.url &#123;\n                    print(&quot;✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅&quot;)\n                    print(&quot;接口地址：\\n\\(interface)&quot;)\n                    print(&quot;✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅&quot;)\n                    print(&quot;请求参数：\\n\\(param)&quot;)\n                    print(&quot;✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅&quot;)\n                &#125;\n                #endif\n                success(response);\n            case let .failure(error):\n                #if DEBUG\n                print(&quot;❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌&quot;)\n                print(error)\n                #endif\n                let err = NetworkError.init(error: error)\n                failure(err);\n                break\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>这里的回调队列，进度，都有默认实例，当然可以自由传递。<br>另外就是成功和失败的逃逸闭包了。</p>\n<p>其实内部继续走了self.provider.request才是重中之重。</p>\n<h3 id=\"4-1-生产Moya-Provider\"><a href=\"#4-1-生产Moya-Provider\" class=\"headerlink\" title=\"4.1 生产Moya Provider\"></a>4.1 生产Moya Provider</h3><p>首先看下provider怎么来的：</p>\n<pre><code class=\"line-numbers language-swift\">public struct Networking&lt;T: MyServerType&gt; &#123;\n    public let provider: MoyaProvider&lt;T&gt;\n    \n    public init(provider: MoyaProvider&lt;T&gt; = newDefaultProvider()) &#123;\n        self.provider = provider\n    &#125;\n&#125;\n\npublic static func newDefaultProvider() -&gt; MoyaProvider&lt;T&gt; &#123;\n        return newProvider(plugins: plugins)\n&#125;\n\n/// 如何新建MoyaProvider\nfunc newProvider&lt;T&gt;(plugins: [PluginType],session: Session = newManager()) -&gt; MoyaProvider&lt;T&gt; where T: MyServerType &#123;\n    \n    return MoyaProvider(endpointClosure: Networking&lt;T&gt;.endpointsClosure(),\n                        requestClosure: Networking&lt;T&gt;.endpointResolver(),\n                        stubClosure: Networking&lt;T&gt;.APIKeysBasedStubBehaviour,\n                        session: session,\n                        plugins: plugins,\n                        trackInflights: false\n    )\n&#125;\n\n/// 新建Provider需要的参数1\nfunc newManager(delegate: SessionDelegate = SessionDelegate()) -&gt; Session &#123;\n//    let configuration = URLSessionConfiguration.default\n//    configuration.httpAdditionalHeaders = Alamofire.SessionManager.defaultHTTPHeaders\n    let configuration = Alamofire.Session.default.session.configuration\n    let session = Alamofire.Session(configuration: configuration, delegate: delegate, startRequestsImmediately: false)\n    return session\n&#125;\n\n/// 新建Provider需要的参数2\nstatic var plugins: [PluginType] &#123;\n        let activityPlugin = NewNetworkActivityPlugin &#123; (state, targetType) in\n            switch state &#123;\n            case .began:\n                if targetType.isShowLoading &#123; //这是我扩展的协议\n                    // 显示loading\n                &#125;\n            case .ended:\n                if targetType.isShowLoading &#123; //这是我扩展的协议\n                    // 关闭loading\n                &#125;\n            &#125;\n        &#125;\n        \n        return [\n            activityPlugin, myLoggorPlugin\n        ]\n    &#125;\n</code></pre>\n<p>这里创建的时候，就默认传了一个默认的Provider，这个是Moya官方的哦。</p>\n<p>另外新建这个MoyaProvider的时候还需要3个闭包，我们通过Networking来生产：</p>\n<pre><code class=\"line-numbers language-swift\">static func endpointsClosure&lt;T&gt;() -&gt; (T) -&gt; Endpoint where T: MyServerType &#123;\n    return &#123; target in\n        var headers: [String: String] = target.headers ?? [:]\n        if apiEnvironment == .product &#123;\n            //生产环境灰度\n            if canary == true &#123;\n                headers[&quot;canary&quot;] = &quot;true&quot;\n            &#125;\n        &#125;\n        //生产环境api路径设置\n        var str = &quot;&quot;\n        str = URL(target: target).absoluteString\n        if apiEnvironment != .test &amp;&amp; apiEnvironment != .dev &#123;\n            str = str.replacingOccurrences(of: &quot;-test&quot;, with: &quot;&quot;, options: .literal, range: nil)\n        &#125;\n        let absoluteString = str\n        let defaultEndpoint = Endpoint(\n            url: absoluteString,\n            sampleResponseClosure: &#123; target.sampleResponse &#125;,\n            method: target.method,\n            task: target.task,\n            httpHeaderFields: headers\n        )\n        return defaultEndpoint;\n    &#125;\n&#125;\n\n//测试网络错误,如超时等.\nstatic func endpointResolver() -&gt; MoyaProvider&lt;T&gt;.RequestClosure &#123;\n    return &#123; (endpoint, closure) in\n        do &#123;\n            var request = try endpoint.urlRequest()\n            request.httpShouldHandleCookies = false\n            request.timeoutInterval = WebService.shared.timeoutInterval\n            closure(.success(request))\n        &#125; catch let error &#123;\n            closure(.failure(MoyaError.underlying(error, nil)))\n        &#125;\n    &#125;\n&#125;   \n\nstatic func APIKeysBasedStubBehaviour&lt;T&gt;(_ target: T) -&gt; Moya.StubBehavior where T: MyServerType &#123;\n        return target.stubBehavior;\n    &#125;\n</code></pre>\n<p>这里我们自己生产了3个闭包给moya，也是moya需要的3个闭包。</p>\n<h3 id=\"4-2-继续走Provider的request\"><a href=\"#4-2-继续走Provider的request\" class=\"headerlink\" title=\"4.2 继续走Provider的request\"></a>4.2 继续走Provider的request</h3><pre><code class=\"line-numbers language-swift\">/// Designated request-making method. Returns a `Cancellable` token to cancel the request later.\n    @discardableResult\n    open func request(_ target: Target,\n                      callbackQueue: DispatchQueue? = .none,\n                      progress: ProgressBlock? = .none,\n                      completion: @escaping Completion) -&gt; Cancellable &#123;\n\n        let callbackQueue = callbackQueue ?? self.callbackQueue\n        return requestNormal(target, callbackQueue: callbackQueue, progress: progress, completion: completion)\n    &#125;\n</code></pre>\n<p>这个是moya三方库里面的代码了，简单看下就好，不是我们这期重点。</p>\n<h3 id=\"4-3-如何封装MyServerType\"><a href=\"#4-3-如何封装MyServerType\" class=\"headerlink\" title=\"4.3 如何封装MyServerType\"></a>4.3 如何封装MyServerType</h3><p>个人感觉这个也是非常关键，我们外部使用，需要建立一个枚举，同时也是一个MyServerType，这个携带了请求参数，请求方法之类的，总之它包装了一切我们请求需要的东西。</p>\n<pre><code class=\"line-numbers language-swift\">import Foundation\nimport Moya\n\npublic typealias HTTPMethod = Moya.Method\npublic typealias MyValidationType = Moya.ValidationType\npublic typealias MySampleResponse = Moya.EndpointSampleResponse\npublic typealias MyStubBehavior = Moya.StubBehavior\n\npublic protocol MyServerType: TargetType &#123;\n    var isShowLoading: Bool &#123; get &#125;\n    /// 附加请求头（如需添加额外的，使用这个）\n    var appendHeaders: [String : String]? &#123; get &#125;\n    var parameters: [String: Any]? &#123; get &#125;\n    var stubBehavior: MyStubBehavior &#123; get &#125;\n    var sampleResponse: MySampleResponse &#123; get &#125;\n&#125;\n</code></pre>\n<p>首先，它这个继承了Moya自己的TargetType，还增加了自己额外的一些协议。</p>\n<pre><code class=\"line-numbers language-swift\">extension MyServerType &#123;\n    public var base: String &#123; return WebService.shared.rootUrl&#125;\n    \n    public var baseURL: URL &#123; return URL(string: base)! &#125;\n    /// 请求头 （默认请求头 + appendHeaders），需求添加额外的改appendHeaders\n    public var headers: [String : String]? &#123;\n        var result: [String : String]? = WebService().headers\n        guard let appendHeaders = appendHeaders else &#123; return result &#125;\n        result = WebService().headers?.merging(appendHeaders, uniquingKeysWith: &#123; (_, new) in new &#125;)\n        return result\n    &#125;\n    public var appendHeaders: [String : String]? &#123; return nil &#125;\n    public var parameters: [String: Any]? &#123; return WebService.shared.parameters &#125;\n    \n    public var isShowLoading: Bool &#123; return false &#125;\n    \n    public var task: Task &#123;\n        let encoding: ParameterEncoding\n        switch self.method &#123;\n        case .post:\n            encoding = JSONEncoding.default\n        default:\n            encoding = URLEncoding.default\n        &#125;\n        if let requestParameters = parameters &#123;\n            return .requestParameters(parameters: requestParameters, encoding: encoding)\n        &#125;\n        return .requestPlain\n    &#125;\n    \n    \n    public var method: HTTPMethod &#123;\n        return .post\n    &#125;\n    \n    public var validationType: MyValidationType &#123;\n        return .successCodes\n    &#125;\n    \n    public var stubBehavior: StubBehavior &#123;\n        return .never\n    &#125;\n    \n    public var validate: Bool &#123;\n        return false\n    &#125;\n    \n    public var sampleData: Data &#123;\n        return &quot;response: test data&quot;.data(using: String.Encoding.utf8)!\n    &#125;\n    \n    public var sampleResponse: MySampleResponse &#123;\n        return .networkResponse(200, self.sampleData)\n    &#125;\n&#125;\n</code></pre>\n<p>这里应该是实现了默认值的设定。<br>当然我们是可以更改的。</p>\n<pre><code class=\"line-numbers language-swift\">func myBaseUrl(_ path: String) -&gt; String &#123;\n    if path.isCompleteUrl &#123; return path &#125;\n    return WebService.shared.rootUrl;\n&#125;\n\nfunc myPath(_ path: String) -&gt; String &#123;\n    if path.isCompleteUrl &#123; return &quot;&quot; &#125;\n    return path;\n&#125;\n\nextension String &#123;\n    var isCompleteUrl: Bool &#123;\n        let scheme = self.lowercased()\n        if scheme.contains(&quot;http&quot;) &#123; return true &#125;\n        return false\n    &#125;\n&#125;\n</code></pre>\n<p>然后是其它工具方法。</p>\n<p>这里有用到一个WebService类，这里面存放的也是一些默认值设定：</p>\n<pre><code class=\"line-numbers language-swift\">import Foundation\nimport UIKit\nimport AdSupport\nimport Alamofire\nimport Moya\n\nclass WebService: NSObject &#123;\n    \n    var rootUrl: String = mainHost\n    var headers: [String: String]? = defaultHeaders()\n    var parameters: [String: Any]? = defaultParameters()\n    var timeoutInterval: Double = 30.0\n    //和服务器时间相差的时间戳:备注每次app恢复活跃状态需更新一次\n    static var serviceTimeSpace: String?\n    \n    static let shared = WebService()\n    override init() &#123;&#125;\n    \n    static func defaultHeaders() -&gt; [String : String]? &#123;\n        var headers = [&quot;x-flag&quot;: &quot;iOS&quot;, &quot;serverName&quot;: &quot;APP&quot;, &quot;clientId&quot;: clientId]\n        if let token = Defaults[key: DefaultsKeys.access_token] &#123;\n            headers[&quot;Authorization&quot;] = &quot;Bearer&quot; + token\n        &#125;\n        let isMonopoly = Defaults[key: DefaultsKeys.isMonopoly] ?? false\n        /// appVersion 字段，（1表示专业版，0表示简易版）\n        headers[&quot;appVersion&quot;] = isMonopoly ? &quot;0&quot; : &quot;1&quot;\n        return headers\n    &#125;\n    \n    static func defaultParameters() -&gt; [String : Any]? &#123;\n        return [&quot;platform&quot; : &quot;ios&quot;,\n            &quot;version&quot; : &quot;1.2.3&quot;,\n        ]\n    &#125;\n    \n    /**\n     获取当前app版本号\n     */\n    static func getAppShortVersion() -&gt; String &#123;\n        let infoDictionary = Bundle.main.infoDictionary!\n        let version = infoDictionary[&quot;CFBundleShortVersionString&quot;] as! String\n        return version\n    &#125;\n    \n    /**\n    获取当前请求User-Agent\n     */\n    static func getUserAgent() -&gt; String &#123;\n        let infoDictionary = Bundle.main.infoDictionary!\n        let version = infoDictionary[&quot;CFBundleShortVersionString&quot;] as! String\n        let userAgent = String(format: &quot;GREEMall%@(%@; iOS %@; Scale/%.2f)&quot;, version, UIDevice.current.model, UIDevice.current.systemVersion, UIScreen.main.scale)\n        \n        return userAgent\n    &#125;\n    \n    /**\n    获取服务器时间和计算时间差\n     */\n    static func setServiceTimeInterval(timeInterval:TimeInterval) &#123;\n        serviceTimeSpace = String(format: &quot;%@&quot;, timeInterval)\n    &#125;\n    \n    /**\n     获取服务器时间戳\n     */\n    static func getServiceTimeInterval() -&gt; Int &#123;\n        return Int(serviceTimeSpace!)!\n    &#125;\n    \n    /**\n     设置请求统一参数\n     */\n    static func getSystemParameterData() -&gt; Dictionary&lt;String, String&gt; &#123;\n        var data = [String: String]()\n        data[&quot;source&quot;] = &quot;iOS&quot;\n        var timeSpace: String = &quot;&quot;\n        if serviceTimeSpace != nil &#123;\n            let now: TimeInterval = Date.init().timeIntervalSince1970\n            let appTime: TimeInterval = now + Double(CLongLong(serviceTimeSpace!)!)\n            timeSpace = String(format:&quot;%@&quot;, appTime)\n        &#125; else &#123;\n            timeSpace = String(format:&quot;%@&quot;, Date.init().timeIntervalSince1970)\n        &#125;\n        data[&quot;t&quot;] = timeSpace\n        data[&quot;version&quot;] = self.getAppShortVersion()\n        data[&quot;ios_idfa&quot;] = ASIdentifierManager.shared().advertisingIdentifier.uuidString\n        return data\n    &#125;\n    \n    /**\n     签名MD5处理\n     */\n    static func appendSign(paramterDic: Dictionary&lt;String, String&gt;, secrekey:String) -&gt; String &#123;\n        var sign:String = &quot;&quot;\n        var keys:Array = Array(paramterDic.keys)\n        keys = keys.sorted()\n        for key:String in keys &#123;\n            if key == &quot;sign&quot; &#123;\n                continue\n            &#125; else &#123;\n                let keyValue: String = String(format: &quot;%@&quot;, paramterDic[key]!)\n                sign.append(String(format: &quot;%@%@&quot;, key, keyValue.EscapesValr))\n            &#125;\n        &#125;\n        sign.append(secrekey)\n        return sign.td.md5.uppercased()\n    &#125;\n&#125;\n</code></pre>\n<p>大致就是这样了。</p>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5 总结\"></a>5 总结</h2><ul>\n<li><p>这个二次封装主要是基于Moya，简化moya流程，提供了一个MyServerType，封装了一些请求参数，请求方法，方便我们进行接口配置。</p>\n</li>\n<li><p>使用方法很简单，不过需要将一类接口单独放置，全部放一起不方便管理，这里比如登录相关接口统一用一个Manger配置，接口参数都写在这个Manager里面，其实也是由一定好处的。</p>\n</li>\n<li><p>这里将moya更加封装成一个系统了，我们需要的结果无非就是接口成功或失败，传参也是我们必要的，将必要的都封装起来了，总体上使用还是比较便捷。</p>\n</li>\n<li><p>如果有特殊请求，比如下载文件这种，需要我们单独抽一个方法处理，这里稍微增加了一点复杂度吧，一般的请求还是可以直接使用的。</p>\n</li>\n</ul>\n"},{"title":"iOS swift 自定义View之步进器","date":"2023-01-26T02:54:54.000Z","top":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 需求分析\n 需要实现一个步进器效果，比如我们在购买商品时，需要添加这个商品，可以点击+或者-，也可以手动输入购买数量。\n 效果如下：\n \n <img src=\"stepper0.png\">\n <img src=\"stepper5.png\">\n\n 基本交互很简单，有最小值和最大值，点击减号就将数量减1，点击加号就将数量加1，如果是最大值或者最小值，就将图标置灰不可点击。\n\n## 2 代码实现\n\n### 2.1 类外声明\n\n```Swift\n/// 定义一个闭包，主要是需要暴露里面的数字给外面，可以理解成定义一个接口类型\npublic typealias ResultClosure = (_ number: String)->()\n```\n\n这个主要是给调用步进器的地方使用，当用户行为导致数量变更，肯定要通知外部处理自己逻辑，这是封装自定义View的基本常识，一定要给外部一定的可操作空间。\n\n### 2.2 创建步进器类\n```Swift\n/// 这里是自定义步进器了  @IBDesignable关键字用来声明一个类是可以被设计的，可以实时渲染在interface builder 上\n/// @IBInspectable关键字用来声明一个属性，可以在interface builder上修改该属性，就可以实时渲染border的变化\n/// open 修饰的 class 在 Module 内部和外部都可以被访问和继承\n@IBDesignable open class PPNumberButton: UIView {\n```\n这里继承了UIView，这个注解只是用来实时预览，这里不要也行。如果想了解自定义View实时预览功能，可以参考下这篇文档：[https://blog.wangruofeng007.com/posts/56184/]()\n\n### 2.3 定义类属性\n```Swift\n    /// 0为默认，1为零售开单\n    var documentType:Int = 0\n    \n    /// 结果闭包，用自定义的闭包类型\n    var NumberResultClosure: ResultClosure?\n    \n    var decreaseBtn: UIButton!     // 减按钮\n    var increaseBtn: UIButton!     // 加按钮\n    var textField: UITextField!    // 数量展示/输入框\n    var timer: Timer!              // 快速加减定时器\n    public var _minValue = 1                 // 最小值\n    public var _maxValue = Int.max           // 最大值\n    public var shakeAnimation: Bool = false  // 是否打开抖动动画\n    \n    var decreaseBgBtn:UIButton!  //减按钮(增大可触面积)\n    var increaseBgBtn:UIButton!  //加按钮(增大可触面积)\n    \n    /// rxSwift生命的袋子\n    let bag = DisposeBag()\n```\n\n这里documentType是自己的业务逻辑，忽略。结果闭包2.1声明的那个类型。然后就是几个基本视图了。这里还有个timer，主要用途是长按实现持续增加数字的功能，体验会好一点。\n最大值最小值就是步进器的最大值和最小值。\n抖动动画，是如果已经到最大值了，用户还在按加，就弹一个动画效果。\n然后还有两个UIButton覆盖在增加和减号的图标上面，只是为了扩大点击热区。\n\n### 2.4 生命周期函数\n\n```Swift\n/// UIView的初始化函数，这里一般会覆写这个方法\noverride public init(frame: CGRect) {\n    super.init(frame: frame)\n    \n    setupUI()\n    \n    //整个控件的默认尺寸\n    if frame.isEmpty {\n        self.frame = CGRect(x: 0, y: 0, width: 110, height: 30)\n    }\n    \n}\n\nrequired public init?(coder aDecoder: NSCoder) {\n    super.init(coder: aDecoder)\n\n}\n```\n一般情况，自定义View都需要覆写下这两个init函数。用来初始化UI。\n\n```Swift\n//设置UI布局\nfileprivate func setupUI() {\n    /// 背景颜色清空\n    backgroundColor = UIColor.clear\n\n    /// 加图标和热区加按钮\n    decreaseBtn = setupButton(title: \"reduce_available\")\n    decreaseBgBtn = setupButton(title: \" \")\n    increaseBtn = setupButton(title: \"increase_available\")\n    increaseBgBtn = setupButton(title: \" \")\n    \n    decreaseBtn.backgroundColor = .clear\n    increaseBtn.backgroundColor = .clear\n    //减按钮(增大可触面积)\n    decreaseBgBtn.backgroundColor = .clear\n    //加按钮(增大可触面积)\n    increaseBgBtn.backgroundColor = .clear\n    \n    /// 中间区域的编辑框\n    textField = UITextField.init()\n    textField.font = UIFont.pingFangMedium(size: 16)\n    textField.layer.borderColor = UIColor(red: 0.79, green: 0.80, blue: 0.83, alpha: 1.00).cgColor\n    textField.layer.borderWidth = 1\n    textField.backgroundColor = UIColor(red: 0.97, green: 0.97, blue: 0.99, alpha: 1.00)\n    textField.layer.cornerRadius = 8\n    textField.textColor = UIColor(hex:\"#3B4058\")\n    textField.delegate = self\n    textField.adjustsFontSizeToFitWidth = true        //当文字超出文本框宽度时，自动调整文字大小\n    textField.minimumFontSize = 14                   //最小可缩小的字号\n    textField.keyboardType = UIKeyboardType.numberPad\n    textField.textAlignment = NSTextAlignment.center\n    self.addSubview(textField)\n}\n```\n\n内部用了一个setupButton给按钮增加背景，看下哈：\n```Swift\n//设置加减按钮的公共方法 设置action\nfileprivate func setupButton(title:String) -> UIButton {\n    let button = UIButton.init();\n    button.setBackgroundImage(UIImage.init(named: title), for: .normal)\n    button.setTitleColor(UIColor.gray, for: .normal)\n    button.addTarget(self, action:#selector(self.touchDown(_:)) , for: .touchDown)\n    button.addTarget(self, action:#selector(self.touchUp) , for:.touchUpOutside)\n    button.addTarget(self, action:#selector(self.touchUp) , for:.touchUpInside)\n    button.addTarget(self, action:#selector(self.touchUp) , for:.touchCancel)\n    self.addSubview(button)\n    \n    return button;\n}\n```\n\n这里给按钮增加了一个action，主要是处理用户行为点击加号或者减号的逻辑：\n```Swift\n@objc fileprivate func touchDown(_ button: UIButton) {\n        textField.endEditing(false)\n        if button == decreaseBtn || button == decreaseBgBtn {\n            timer = Timer.scheduledTimer(timeInterval: 0.15, target: self, selector: #selector(self.decrease), userInfo: nil, repeats: true)\n        } else {\n            timer = Timer.scheduledTimer(timeInterval: 0.15, target: self, selector: #selector(self.increase), userInfo: nil, repeats: true)\n        }\n        timer.fire()\n    }\n```\n这里给按钮添加的action的函数，都需要@objc注解，原因是swift是静态编程语言，objc是动态的，所以这里需要转换为动态效果，所以要声明这个注解，不知道我理解得对不对。\n\n这里只有点击了就去执行加或者减的逻辑，用了一个定时器，保证150ms才走一次。\n加的逻辑看下哈：\n```Swift\n@objc fileprivate func increase() {\n        if (textField.text?.count)! == 0 || Int(textField.text!)! <= _minValue {\n            textField.text = \"\\(_minValue)\"\n        }\n        \n        let number = Int(textField.text!)! + 1;\n        \n        if number <= _maxValue {\n            textField.text = \"\\(number)\";\n            //闭包回调\n            NumberResultClosure?(\"\\(number)\")\n        } else {\n            //添加抖动动画\n            if shakeAnimation {shakeAnimationFunc()}\n            print(\"已超过最大数量\\(_maxValue)\");\n            if documentType == 1 {\n                MBProgressHUD.showTipsMessage(\"数量已超出零售上限\")\n            }\n        }\n        /// 触发rxSwift监听处更新\n        textField.sendActions(for: .valueChanged)\n        \n        if Int(textField.text!)! >= maxValue {\n            decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_available\"), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_Disable\"), for: .normal)\n        }else{\n            decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_available\"), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_available\"), for: .normal)\n        }\n    }\n```\n这里主要就是最大值和最小值判断，这里有个sendActions的方法，个人不是很理解。猜测是用了RxSwift的话，内部编辑框的值变更，会通知到rx的回调处，其实也是通知外部同步刷新。\n\n减的逻辑基本一致，这里就不再看了。\n\n上面还遗漏了一个抬起手后，将定时器取消，这点很重要，如果不及时处理，很容易造成内存泄漏。看下上面给touchCancel和其它按钮状态绑定的事件：\n```Swift\n//松开按钮:清除定时器\n@objc fileprivate func touchUp()  {\n    cleanTimer()\n}\n\n/// 内部实现\nfileprivate func cleanTimer() {\n        if ((timer?.isValid) != nil) {\n            timer.invalidate()\n            timer = nil;\n        }\n    }\n    \n/// 析构函数    \ndeinit {\n    cleanTimer()\n}\n```\n\n这里还有一个非常关键的生命周期函数：\n```Swift\n// MARK: - 重新布局UI\n    /// https://juejin.cn/post/6984250995874365448 layoutSubviews调用时机\n    /// 改变一个UIView的Frame会触发layoutSubviews\n    /// layoutSubviews, 当我们在某个类的内部调整子视图位置时，需要调用。反过来的意思就是说：如果你想要在外部设置subviews的位置，就不要重写。\n    /// 这个方法，默认没有做任何事情，需要子类进行重写\n    /// 如果没有这个方法，那么结果会是空白的，看不到任何东西\n    override open func layoutSubviews() {\n        super.layoutSubviews()\n        \n        let height = frame.size.height\n        let width = frame.size.width\n        let textFieldWidth:CGFloat = 90\n        let BgBtnWidth:CGFloat = 42\n        let btnSize:CGFloat = 28\n        decreaseBtn.frame = CGRect(x: 0, y: (height-btnSize)/2, width: btnSize, height: btnSize)\n        //减按钮(增大可触面积)\n        decreaseBgBtn.frame = CGRect(x: 0, y: 0, width: BgBtnWidth, height: height)\n        increaseBtn.frame = CGRect(x: width-btnSize, y: (height-btnSize)/2, width: btnSize, height: btnSize)\n        //加按钮(增大可触面积)\n        increaseBgBtn.frame = CGRect(x: BgBtnWidth + textFieldWidth, y: 0, width: BgBtnWidth, height: height)\n        textField.frame = CGRect(x: BgBtnWidth, y: 0, width: textFieldWidth, height: height)\n    }\n```\n这个方法必须要实现，确定视图frame，才可以真正显示到屏幕上。\n\n### 2.5 给TextField绑定代理\n在前面初始化UI里面有句代码是这样的：\n`textField.delegate = self`\n这里需要新建一个代理类来支持一下：\n```Swift\nextension PPNumberButton: UITextFieldDelegate {\n    \n    // MARK: - UITextFieldDelegate\n    public func textFieldDidEndEditing(_ textField: UITextField) {\n        if (textField.text?.count)! == 0 || Int(textField.text!) ?? 999999999 < _minValue {\n            textField.text = \"\\(_minValue)\"\n        }\n        if Int(textField.text!) ?? 999999999 > _maxValue {\n            if documentType == 1 {\n                MBProgressHUD.showTipsMessage(\"数量已超出零售上限\")\n            }\n        }\n        if Int(textField.text!) ?? 999999999 >= _maxValue {\n            textField.text = \"\\(_maxValue)\"\n        }\n        //闭包回调，传递值给外部\n        NumberResultClosure?(\"\\(textField.text!)\")\n        //delegate的回调，暴露内部值给外部\n//        delegate2?.numberButtonResult(self, number: \"\\(textField.text!)\")\n        \n        print(\"当前值:   \\(textField.text?.int ?? 0)\")\n        \n        if (textField.text?.int ?? 0) <= 0 {\n            decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_Disable\"), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_available\"), for: .normal)\n        }else if (textField.text?.int ?? 0) >= maxValue {\n            decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_available\"), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_Disable\"), for: .normal)\n        }else{\n            decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_available\"), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_available\"), for: .normal)\n        }\n    }\n    \n    public func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {\n        \n        if range.location <= 8 {\n            return true\n        }else{\n            return false\n        }\n    }\n    \n}\n```\n这里重写了官方文本代理的两个函数：\n· textFieldDidEndEditing 结束编辑调用\n· textField 实时调用，能否显示\n\n### 2.6 自定义扩展函数\n原因是每个地方使用场景不同，这里需要通过扩展函数，可以自己添加一些逻辑，方便调用处能够实现效果。\n```Swift\npublic extension PPNumberButton {\n    \n    /**\n     输入框中的内容\n     */\n    var currentNumber: String? {\n        get {\n            return (textField.text!)\n        }\n        set {\n            textField.text = newValue\n            if isUserInteractionEnabled {\n                if (newValue?.int ?? 0) <= 0 {\n                    decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_Disable\"), for: .normal)\n                    increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_available\"), for: .normal)\n                } else if (newValue?.int ?? 0) >= maxValue {\n                    decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_available\"), for: .normal)\n                    increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_Disable\"), for: .normal)\n                }else{\n                    decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_available\"), for: .normal)\n                    increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_available\"), for: .normal)\n                }\n            }\n        }\n    }\n    /**\n     设置最小值\n     */\n    var minValue: Int {\n        get {\n            return _minValue\n        }\n        set {\n            _minValue = newValue\n            textField.text = \"\\(newValue)\"\n        }\n    }\n    /**\n     设置最大值\n     */\n    var maxValue: Int {\n        get {\n            return _maxValue\n        }\n        set {\n            _maxValue = newValue\n        }\n    }\n    \n    /**\n     * 加减按钮的响应闭包回调\n     * 当数字变化后，暴露给外部，执行自己逻辑\n     */\n    func numberResult(_ finished: @escaping ResultClosure) {\n        NumberResultClosure = finished\n    }\n    \n    /**\n     输入框中的字体属性\n     */\n    func inputFieldFont(_ inputFieldFont: UIFont) {\n        textField.font = inputFieldFont;\n    }\n    \n    /**\n     加减按钮的字体属性\n     */\n    func buttonTitleFont(_ buttonTitleFont: UIFont) {\n        increaseBtn.titleLabel!.font = buttonTitleFont;\n        decreaseBtn.titleLabel!.font = buttonTitleFont;\n    }\n    \n    /**\n     设置按钮的边框颜色\n     */\n    func borderColor(_ borderColor: UIColor) {\n//        layer.borderColor = borderColor.cgColor;\n        decreaseBtn.layer.borderColor = borderColor.cgColor;\n        increaseBtn.layer.borderColor = borderColor.cgColor;\n        \n//        layer.borderWidth = 0.5;\n        decreaseBtn.layer.borderWidth = 0.5;\n        increaseBtn.layer.borderWidth = 0.5;\n    }\n    \n    //注意:加减号按钮的标题和背景图片只能设置其中一个,若全部设置,则以最后设置的类型为准\n    \n    /**\n     设置加/减按钮的标题\n     \n     - parameter decreaseTitle: 减按钮标题\n     - parameter increaseTitle: 加按钮标题\n     */\n    func setTitle(decreaseTitle: String, increaseTitle: String) {\n        decreaseBtn.setBackgroundImage(nil, for: .normal)\n        increaseBtn.setBackgroundImage(nil, for: .normal)\n        \n        decreaseBtn.setTitle(decreaseTitle, for: .normal)\n        increaseBtn.setTitle(increaseTitle, for: .normal)\n    }\n    \n    /**\n     设置加/减按钮的背景图片\n     \n     - parameter decreaseImage: 减按钮背景图片\n     - parameter increaseImage: 加按钮背景图片\n     */\n    func setImage(decreaseImage: UIImage, increaseImage: UIImage) {\n        decreaseBtn.setTitle(nil, for: .normal)\n        increaseBtn.setTitle(nil, for: .normal)\n        \n        decreaseBtn.setBackgroundImage(decreaseImage, for: .normal)\n        increaseBtn.setBackgroundImage(increaseImage, for: .normal)\n    }\n    \n}\n\n```\n这些都是暴露给外部调用者的函数，外部可以轻松改变背景，改变边框颜色等。\n\n```Swift\npublic extension PPNumberButton {\n    \n    /// 是否开启交互 这里主要是设置能否点击，业务需求是某些情况没有超过最大值或低于最小值也不可点击哦\n    var enabled: Bool {\n        get {\n            return isUserInteractionEnabled\n        }\n        set {\n            isUserInteractionEnabled = newValue\n            if isUserInteractionEnabled {\n                let text = textField.text\n                currentNumber = text\n            } else {\n                decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_Disable\"), for: .normal)\n                increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_Disable\"), for: .normal)\n            }\n        }\n    }\n    \n}\n```\n上面的代码也是因为增加了 特殊需求，添加的一个扩展方法。\n\n另外还有一部分代码是使用RxSwift，增加了扩展方法，看下哈：\n```Swift\nextension Reactive where Base: PPNumberButton {\n    var gmMaxValue: Binder<Int> {\n        return Binder(self.base) { (pp, max) in\n            pp.maxValue = max\n        }\n    }\n}\n```\n这里应该是获取最大值，pp指代这个步进器，max就是最大值。\n\n### 2.7 调用者如何使用\n上面基本就把步进器实现完了。\n下面看看调用者如何来使用步进器，这里简单示例下：\n\n先声明一个步进器\n```Swift\nprivate weak var cus_stepper: PPNumberButton!\n```\n\n然后目标地方创建一个步进器，并且初始化步进器相关属性\n```Swift\nlet stepperViewW: CGFloat = 178.0\nlet stepperViewH: CGFloat = 40.0\nlet stepperViewB: CGFloat = 24.0\n\n/// 创建步进器并初始化\nlet cus_stepper = PPNumberButton()\ncus_stepper.shakeAnimation = true\ncus_stepper.maxValue = 999999999\ncus_stepper.minValue = 0\n\n/// 暴露回调给外部，里面就是自己逻辑了\ncus_stepper.numberResult { [weak self] number in\n    guard let self = self else { return }\n    self.act_stepperCountChnage(number)\n}\n\n/// 添加到目标contentView里面\ncontentView.addSubview(cus_stepper)\nself.cus_stepper = cus_stepper\n\n/// 布局设置\ncus_stepper.snp.makeConstraints { make in\n    make.top.equalTo(imgV_photo.snp.bottom).offset(ySuperVerPad)\n    make.right.equalTo(contentView).offset(-ySuperHorPad)\n    make.width.equalTo(stepperViewW)\n    make.height.equalTo(stepperViewH)\n}\n\ncus_stepper.snp.makeConstraints { make in\n    make.bottom.equalTo(contentView).offset(-stepperViewB)\n}\n```\n\n基本就这样。\n\n## 3 总结\n\n1.自定义View需要先分析下交互，确定下如何拆分这个自定义View，再复杂的视图都是一块砖一块瓦拼接起来的，其实这个步进器就3个结构，左右图标，中间编辑框。\n2.iOS自定义View一般都是继承UIView，重写两个init函数，layoutSubviews这个方法确定视图frame，才能显示到屏幕上。\n3.给UIButton添加action一定要用@objc注解，表示可以使用动态方法。\n4.对于封装自定义View一定要严格将某些方法暴露出去，某些方法私有，因为调用者不知道具体细节，所以封装者就一定要注意扩展性，一方面提供好用的扩展方法出去，能够方便调用者去设置各种属性，另一方面要注意类安全性，以及解耦性，尽量不要跟数据太耦合了。\n","source":"_posts/iOS-swift-自定义View之步进器.md","raw":"---\ntitle: iOS swift 自定义View之步进器\ndate: 2023-01-26 10:54:54\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- iOS 自定义View\ncategories:\n- iOS\n---\n\n## 1 需求分析\n 需要实现一个步进器效果，比如我们在购买商品时，需要添加这个商品，可以点击+或者-，也可以手动输入购买数量。\n 效果如下：\n \n <img src=\"stepper0.png\">\n <img src=\"stepper5.png\">\n\n 基本交互很简单，有最小值和最大值，点击减号就将数量减1，点击加号就将数量加1，如果是最大值或者最小值，就将图标置灰不可点击。\n\n## 2 代码实现\n\n### 2.1 类外声明\n\n```Swift\n/// 定义一个闭包，主要是需要暴露里面的数字给外面，可以理解成定义一个接口类型\npublic typealias ResultClosure = (_ number: String)->()\n```\n\n这个主要是给调用步进器的地方使用，当用户行为导致数量变更，肯定要通知外部处理自己逻辑，这是封装自定义View的基本常识，一定要给外部一定的可操作空间。\n\n### 2.2 创建步进器类\n```Swift\n/// 这里是自定义步进器了  @IBDesignable关键字用来声明一个类是可以被设计的，可以实时渲染在interface builder 上\n/// @IBInspectable关键字用来声明一个属性，可以在interface builder上修改该属性，就可以实时渲染border的变化\n/// open 修饰的 class 在 Module 内部和外部都可以被访问和继承\n@IBDesignable open class PPNumberButton: UIView {\n```\n这里继承了UIView，这个注解只是用来实时预览，这里不要也行。如果想了解自定义View实时预览功能，可以参考下这篇文档：[https://blog.wangruofeng007.com/posts/56184/]()\n\n### 2.3 定义类属性\n```Swift\n    /// 0为默认，1为零售开单\n    var documentType:Int = 0\n    \n    /// 结果闭包，用自定义的闭包类型\n    var NumberResultClosure: ResultClosure?\n    \n    var decreaseBtn: UIButton!     // 减按钮\n    var increaseBtn: UIButton!     // 加按钮\n    var textField: UITextField!    // 数量展示/输入框\n    var timer: Timer!              // 快速加减定时器\n    public var _minValue = 1                 // 最小值\n    public var _maxValue = Int.max           // 最大值\n    public var shakeAnimation: Bool = false  // 是否打开抖动动画\n    \n    var decreaseBgBtn:UIButton!  //减按钮(增大可触面积)\n    var increaseBgBtn:UIButton!  //加按钮(增大可触面积)\n    \n    /// rxSwift生命的袋子\n    let bag = DisposeBag()\n```\n\n这里documentType是自己的业务逻辑，忽略。结果闭包2.1声明的那个类型。然后就是几个基本视图了。这里还有个timer，主要用途是长按实现持续增加数字的功能，体验会好一点。\n最大值最小值就是步进器的最大值和最小值。\n抖动动画，是如果已经到最大值了，用户还在按加，就弹一个动画效果。\n然后还有两个UIButton覆盖在增加和减号的图标上面，只是为了扩大点击热区。\n\n### 2.4 生命周期函数\n\n```Swift\n/// UIView的初始化函数，这里一般会覆写这个方法\noverride public init(frame: CGRect) {\n    super.init(frame: frame)\n    \n    setupUI()\n    \n    //整个控件的默认尺寸\n    if frame.isEmpty {\n        self.frame = CGRect(x: 0, y: 0, width: 110, height: 30)\n    }\n    \n}\n\nrequired public init?(coder aDecoder: NSCoder) {\n    super.init(coder: aDecoder)\n\n}\n```\n一般情况，自定义View都需要覆写下这两个init函数。用来初始化UI。\n\n```Swift\n//设置UI布局\nfileprivate func setupUI() {\n    /// 背景颜色清空\n    backgroundColor = UIColor.clear\n\n    /// 加图标和热区加按钮\n    decreaseBtn = setupButton(title: \"reduce_available\")\n    decreaseBgBtn = setupButton(title: \" \")\n    increaseBtn = setupButton(title: \"increase_available\")\n    increaseBgBtn = setupButton(title: \" \")\n    \n    decreaseBtn.backgroundColor = .clear\n    increaseBtn.backgroundColor = .clear\n    //减按钮(增大可触面积)\n    decreaseBgBtn.backgroundColor = .clear\n    //加按钮(增大可触面积)\n    increaseBgBtn.backgroundColor = .clear\n    \n    /// 中间区域的编辑框\n    textField = UITextField.init()\n    textField.font = UIFont.pingFangMedium(size: 16)\n    textField.layer.borderColor = UIColor(red: 0.79, green: 0.80, blue: 0.83, alpha: 1.00).cgColor\n    textField.layer.borderWidth = 1\n    textField.backgroundColor = UIColor(red: 0.97, green: 0.97, blue: 0.99, alpha: 1.00)\n    textField.layer.cornerRadius = 8\n    textField.textColor = UIColor(hex:\"#3B4058\")\n    textField.delegate = self\n    textField.adjustsFontSizeToFitWidth = true        //当文字超出文本框宽度时，自动调整文字大小\n    textField.minimumFontSize = 14                   //最小可缩小的字号\n    textField.keyboardType = UIKeyboardType.numberPad\n    textField.textAlignment = NSTextAlignment.center\n    self.addSubview(textField)\n}\n```\n\n内部用了一个setupButton给按钮增加背景，看下哈：\n```Swift\n//设置加减按钮的公共方法 设置action\nfileprivate func setupButton(title:String) -> UIButton {\n    let button = UIButton.init();\n    button.setBackgroundImage(UIImage.init(named: title), for: .normal)\n    button.setTitleColor(UIColor.gray, for: .normal)\n    button.addTarget(self, action:#selector(self.touchDown(_:)) , for: .touchDown)\n    button.addTarget(self, action:#selector(self.touchUp) , for:.touchUpOutside)\n    button.addTarget(self, action:#selector(self.touchUp) , for:.touchUpInside)\n    button.addTarget(self, action:#selector(self.touchUp) , for:.touchCancel)\n    self.addSubview(button)\n    \n    return button;\n}\n```\n\n这里给按钮增加了一个action，主要是处理用户行为点击加号或者减号的逻辑：\n```Swift\n@objc fileprivate func touchDown(_ button: UIButton) {\n        textField.endEditing(false)\n        if button == decreaseBtn || button == decreaseBgBtn {\n            timer = Timer.scheduledTimer(timeInterval: 0.15, target: self, selector: #selector(self.decrease), userInfo: nil, repeats: true)\n        } else {\n            timer = Timer.scheduledTimer(timeInterval: 0.15, target: self, selector: #selector(self.increase), userInfo: nil, repeats: true)\n        }\n        timer.fire()\n    }\n```\n这里给按钮添加的action的函数，都需要@objc注解，原因是swift是静态编程语言，objc是动态的，所以这里需要转换为动态效果，所以要声明这个注解，不知道我理解得对不对。\n\n这里只有点击了就去执行加或者减的逻辑，用了一个定时器，保证150ms才走一次。\n加的逻辑看下哈：\n```Swift\n@objc fileprivate func increase() {\n        if (textField.text?.count)! == 0 || Int(textField.text!)! <= _minValue {\n            textField.text = \"\\(_minValue)\"\n        }\n        \n        let number = Int(textField.text!)! + 1;\n        \n        if number <= _maxValue {\n            textField.text = \"\\(number)\";\n            //闭包回调\n            NumberResultClosure?(\"\\(number)\")\n        } else {\n            //添加抖动动画\n            if shakeAnimation {shakeAnimationFunc()}\n            print(\"已超过最大数量\\(_maxValue)\");\n            if documentType == 1 {\n                MBProgressHUD.showTipsMessage(\"数量已超出零售上限\")\n            }\n        }\n        /// 触发rxSwift监听处更新\n        textField.sendActions(for: .valueChanged)\n        \n        if Int(textField.text!)! >= maxValue {\n            decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_available\"), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_Disable\"), for: .normal)\n        }else{\n            decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_available\"), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_available\"), for: .normal)\n        }\n    }\n```\n这里主要就是最大值和最小值判断，这里有个sendActions的方法，个人不是很理解。猜测是用了RxSwift的话，内部编辑框的值变更，会通知到rx的回调处，其实也是通知外部同步刷新。\n\n减的逻辑基本一致，这里就不再看了。\n\n上面还遗漏了一个抬起手后，将定时器取消，这点很重要，如果不及时处理，很容易造成内存泄漏。看下上面给touchCancel和其它按钮状态绑定的事件：\n```Swift\n//松开按钮:清除定时器\n@objc fileprivate func touchUp()  {\n    cleanTimer()\n}\n\n/// 内部实现\nfileprivate func cleanTimer() {\n        if ((timer?.isValid) != nil) {\n            timer.invalidate()\n            timer = nil;\n        }\n    }\n    \n/// 析构函数    \ndeinit {\n    cleanTimer()\n}\n```\n\n这里还有一个非常关键的生命周期函数：\n```Swift\n// MARK: - 重新布局UI\n    /// https://juejin.cn/post/6984250995874365448 layoutSubviews调用时机\n    /// 改变一个UIView的Frame会触发layoutSubviews\n    /// layoutSubviews, 当我们在某个类的内部调整子视图位置时，需要调用。反过来的意思就是说：如果你想要在外部设置subviews的位置，就不要重写。\n    /// 这个方法，默认没有做任何事情，需要子类进行重写\n    /// 如果没有这个方法，那么结果会是空白的，看不到任何东西\n    override open func layoutSubviews() {\n        super.layoutSubviews()\n        \n        let height = frame.size.height\n        let width = frame.size.width\n        let textFieldWidth:CGFloat = 90\n        let BgBtnWidth:CGFloat = 42\n        let btnSize:CGFloat = 28\n        decreaseBtn.frame = CGRect(x: 0, y: (height-btnSize)/2, width: btnSize, height: btnSize)\n        //减按钮(增大可触面积)\n        decreaseBgBtn.frame = CGRect(x: 0, y: 0, width: BgBtnWidth, height: height)\n        increaseBtn.frame = CGRect(x: width-btnSize, y: (height-btnSize)/2, width: btnSize, height: btnSize)\n        //加按钮(增大可触面积)\n        increaseBgBtn.frame = CGRect(x: BgBtnWidth + textFieldWidth, y: 0, width: BgBtnWidth, height: height)\n        textField.frame = CGRect(x: BgBtnWidth, y: 0, width: textFieldWidth, height: height)\n    }\n```\n这个方法必须要实现，确定视图frame，才可以真正显示到屏幕上。\n\n### 2.5 给TextField绑定代理\n在前面初始化UI里面有句代码是这样的：\n`textField.delegate = self`\n这里需要新建一个代理类来支持一下：\n```Swift\nextension PPNumberButton: UITextFieldDelegate {\n    \n    // MARK: - UITextFieldDelegate\n    public func textFieldDidEndEditing(_ textField: UITextField) {\n        if (textField.text?.count)! == 0 || Int(textField.text!) ?? 999999999 < _minValue {\n            textField.text = \"\\(_minValue)\"\n        }\n        if Int(textField.text!) ?? 999999999 > _maxValue {\n            if documentType == 1 {\n                MBProgressHUD.showTipsMessage(\"数量已超出零售上限\")\n            }\n        }\n        if Int(textField.text!) ?? 999999999 >= _maxValue {\n            textField.text = \"\\(_maxValue)\"\n        }\n        //闭包回调，传递值给外部\n        NumberResultClosure?(\"\\(textField.text!)\")\n        //delegate的回调，暴露内部值给外部\n//        delegate2?.numberButtonResult(self, number: \"\\(textField.text!)\")\n        \n        print(\"当前值:   \\(textField.text?.int ?? 0)\")\n        \n        if (textField.text?.int ?? 0) <= 0 {\n            decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_Disable\"), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_available\"), for: .normal)\n        }else if (textField.text?.int ?? 0) >= maxValue {\n            decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_available\"), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_Disable\"), for: .normal)\n        }else{\n            decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_available\"), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_available\"), for: .normal)\n        }\n    }\n    \n    public func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {\n        \n        if range.location <= 8 {\n            return true\n        }else{\n            return false\n        }\n    }\n    \n}\n```\n这里重写了官方文本代理的两个函数：\n· textFieldDidEndEditing 结束编辑调用\n· textField 实时调用，能否显示\n\n### 2.6 自定义扩展函数\n原因是每个地方使用场景不同，这里需要通过扩展函数，可以自己添加一些逻辑，方便调用处能够实现效果。\n```Swift\npublic extension PPNumberButton {\n    \n    /**\n     输入框中的内容\n     */\n    var currentNumber: String? {\n        get {\n            return (textField.text!)\n        }\n        set {\n            textField.text = newValue\n            if isUserInteractionEnabled {\n                if (newValue?.int ?? 0) <= 0 {\n                    decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_Disable\"), for: .normal)\n                    increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_available\"), for: .normal)\n                } else if (newValue?.int ?? 0) >= maxValue {\n                    decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_available\"), for: .normal)\n                    increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_Disable\"), for: .normal)\n                }else{\n                    decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_available\"), for: .normal)\n                    increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_available\"), for: .normal)\n                }\n            }\n        }\n    }\n    /**\n     设置最小值\n     */\n    var minValue: Int {\n        get {\n            return _minValue\n        }\n        set {\n            _minValue = newValue\n            textField.text = \"\\(newValue)\"\n        }\n    }\n    /**\n     设置最大值\n     */\n    var maxValue: Int {\n        get {\n            return _maxValue\n        }\n        set {\n            _maxValue = newValue\n        }\n    }\n    \n    /**\n     * 加减按钮的响应闭包回调\n     * 当数字变化后，暴露给外部，执行自己逻辑\n     */\n    func numberResult(_ finished: @escaping ResultClosure) {\n        NumberResultClosure = finished\n    }\n    \n    /**\n     输入框中的字体属性\n     */\n    func inputFieldFont(_ inputFieldFont: UIFont) {\n        textField.font = inputFieldFont;\n    }\n    \n    /**\n     加减按钮的字体属性\n     */\n    func buttonTitleFont(_ buttonTitleFont: UIFont) {\n        increaseBtn.titleLabel!.font = buttonTitleFont;\n        decreaseBtn.titleLabel!.font = buttonTitleFont;\n    }\n    \n    /**\n     设置按钮的边框颜色\n     */\n    func borderColor(_ borderColor: UIColor) {\n//        layer.borderColor = borderColor.cgColor;\n        decreaseBtn.layer.borderColor = borderColor.cgColor;\n        increaseBtn.layer.borderColor = borderColor.cgColor;\n        \n//        layer.borderWidth = 0.5;\n        decreaseBtn.layer.borderWidth = 0.5;\n        increaseBtn.layer.borderWidth = 0.5;\n    }\n    \n    //注意:加减号按钮的标题和背景图片只能设置其中一个,若全部设置,则以最后设置的类型为准\n    \n    /**\n     设置加/减按钮的标题\n     \n     - parameter decreaseTitle: 减按钮标题\n     - parameter increaseTitle: 加按钮标题\n     */\n    func setTitle(decreaseTitle: String, increaseTitle: String) {\n        decreaseBtn.setBackgroundImage(nil, for: .normal)\n        increaseBtn.setBackgroundImage(nil, for: .normal)\n        \n        decreaseBtn.setTitle(decreaseTitle, for: .normal)\n        increaseBtn.setTitle(increaseTitle, for: .normal)\n    }\n    \n    /**\n     设置加/减按钮的背景图片\n     \n     - parameter decreaseImage: 减按钮背景图片\n     - parameter increaseImage: 加按钮背景图片\n     */\n    func setImage(decreaseImage: UIImage, increaseImage: UIImage) {\n        decreaseBtn.setTitle(nil, for: .normal)\n        increaseBtn.setTitle(nil, for: .normal)\n        \n        decreaseBtn.setBackgroundImage(decreaseImage, for: .normal)\n        increaseBtn.setBackgroundImage(increaseImage, for: .normal)\n    }\n    \n}\n\n```\n这些都是暴露给外部调用者的函数，外部可以轻松改变背景，改变边框颜色等。\n\n```Swift\npublic extension PPNumberButton {\n    \n    /// 是否开启交互 这里主要是设置能否点击，业务需求是某些情况没有超过最大值或低于最小值也不可点击哦\n    var enabled: Bool {\n        get {\n            return isUserInteractionEnabled\n        }\n        set {\n            isUserInteractionEnabled = newValue\n            if isUserInteractionEnabled {\n                let text = textField.text\n                currentNumber = text\n            } else {\n                decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_Disable\"), for: .normal)\n                increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_Disable\"), for: .normal)\n            }\n        }\n    }\n    \n}\n```\n上面的代码也是因为增加了 特殊需求，添加的一个扩展方法。\n\n另外还有一部分代码是使用RxSwift，增加了扩展方法，看下哈：\n```Swift\nextension Reactive where Base: PPNumberButton {\n    var gmMaxValue: Binder<Int> {\n        return Binder(self.base) { (pp, max) in\n            pp.maxValue = max\n        }\n    }\n}\n```\n这里应该是获取最大值，pp指代这个步进器，max就是最大值。\n\n### 2.7 调用者如何使用\n上面基本就把步进器实现完了。\n下面看看调用者如何来使用步进器，这里简单示例下：\n\n先声明一个步进器\n```Swift\nprivate weak var cus_stepper: PPNumberButton!\n```\n\n然后目标地方创建一个步进器，并且初始化步进器相关属性\n```Swift\nlet stepperViewW: CGFloat = 178.0\nlet stepperViewH: CGFloat = 40.0\nlet stepperViewB: CGFloat = 24.0\n\n/// 创建步进器并初始化\nlet cus_stepper = PPNumberButton()\ncus_stepper.shakeAnimation = true\ncus_stepper.maxValue = 999999999\ncus_stepper.minValue = 0\n\n/// 暴露回调给外部，里面就是自己逻辑了\ncus_stepper.numberResult { [weak self] number in\n    guard let self = self else { return }\n    self.act_stepperCountChnage(number)\n}\n\n/// 添加到目标contentView里面\ncontentView.addSubview(cus_stepper)\nself.cus_stepper = cus_stepper\n\n/// 布局设置\ncus_stepper.snp.makeConstraints { make in\n    make.top.equalTo(imgV_photo.snp.bottom).offset(ySuperVerPad)\n    make.right.equalTo(contentView).offset(-ySuperHorPad)\n    make.width.equalTo(stepperViewW)\n    make.height.equalTo(stepperViewH)\n}\n\ncus_stepper.snp.makeConstraints { make in\n    make.bottom.equalTo(contentView).offset(-stepperViewB)\n}\n```\n\n基本就这样。\n\n## 3 总结\n\n1.自定义View需要先分析下交互，确定下如何拆分这个自定义View，再复杂的视图都是一块砖一块瓦拼接起来的，其实这个步进器就3个结构，左右图标，中间编辑框。\n2.iOS自定义View一般都是继承UIView，重写两个init函数，layoutSubviews这个方法确定视图frame，才能显示到屏幕上。\n3.给UIButton添加action一定要用@objc注解，表示可以使用动态方法。\n4.对于封装自定义View一定要严格将某些方法暴露出去，某些方法私有，因为调用者不知道具体细节，所以封装者就一定要注意扩展性，一方面提供好用的扩展方法出去，能够方便调用者去设置各种属性，另一方面要注意类安全性，以及解耦性，尽量不要跟数据太耦合了。\n","slug":"iOS-swift-自定义View之步进器","published":1,"updated":"2023-02-01T07:12:30.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlc01jf000tjhv75g6weh8d","content":"<h2 id=\"1-需求分析\"><a href=\"#1-需求分析\" class=\"headerlink\" title=\"1 需求分析\"></a>1 需求分析</h2><p> 需要实现一个步进器效果，比如我们在购买商品时，需要添加这个商品，可以点击+或者-，也可以手动输入购买数量。<br> 效果如下：</p>\n <img src=\"stepper0.png\">\n <img src=\"stepper5.png\">\n\n<p> 基本交互很简单，有最小值和最大值，点击减号就将数量减1，点击加号就将数量加1，如果是最大值或者最小值，就将图标置灰不可点击。</p>\n<h2 id=\"2-代码实现\"><a href=\"#2-代码实现\" class=\"headerlink\" title=\"2 代码实现\"></a>2 代码实现</h2><h3 id=\"2-1-类外声明\"><a href=\"#2-1-类外声明\" class=\"headerlink\" title=\"2.1 类外声明\"></a>2.1 类外声明</h3><pre><code class=\"line-numbers language-Swift\">/// 定义一个闭包，主要是需要暴露里面的数字给外面，可以理解成定义一个接口类型\npublic typealias ResultClosure = (_ number: String)-&gt;()\n</code></pre>\n<p>这个主要是给调用步进器的地方使用，当用户行为导致数量变更，肯定要通知外部处理自己逻辑，这是封装自定义View的基本常识，一定要给外部一定的可操作空间。</p>\n<h3 id=\"2-2-创建步进器类\"><a href=\"#2-2-创建步进器类\" class=\"headerlink\" title=\"2.2 创建步进器类\"></a>2.2 创建步进器类</h3><pre><code class=\"line-numbers language-Swift\">/// 这里是自定义步进器了  @IBDesignable关键字用来声明一个类是可以被设计的，可以实时渲染在interface builder 上\n/// @IBInspectable关键字用来声明一个属性，可以在interface builder上修改该属性，就可以实时渲染border的变化\n/// open 修饰的 class 在 Module 内部和外部都可以被访问和继承\n@IBDesignable open class PPNumberButton: UIView &#123;\n</code></pre>\n<p>这里继承了UIView，这个注解只是用来实时预览，这里不要也行。如果想了解自定义View实时预览功能，可以参考下这篇文档：<a href=\"\">https://blog.wangruofeng007.com/posts/56184/</a></p>\n<h3 id=\"2-3-定义类属性\"><a href=\"#2-3-定义类属性\" class=\"headerlink\" title=\"2.3 定义类属性\"></a>2.3 定义类属性</h3><pre><code class=\"line-numbers language-Swift\">    /// 0为默认，1为零售开单\n    var documentType:Int = 0\n    \n    /// 结果闭包，用自定义的闭包类型\n    var NumberResultClosure: ResultClosure?\n    \n    var decreaseBtn: UIButton!     // 减按钮\n    var increaseBtn: UIButton!     // 加按钮\n    var textField: UITextField!    // 数量展示/输入框\n    var timer: Timer!              // 快速加减定时器\n    public var _minValue = 1                 // 最小值\n    public var _maxValue = Int.max           // 最大值\n    public var shakeAnimation: Bool = false  // 是否打开抖动动画\n    \n    var decreaseBgBtn:UIButton!  //减按钮(增大可触面积)\n    var increaseBgBtn:UIButton!  //加按钮(增大可触面积)\n    \n    /// rxSwift生命的袋子\n    let bag = DisposeBag()\n</code></pre>\n<p>这里documentType是自己的业务逻辑，忽略。结果闭包2.1声明的那个类型。然后就是几个基本视图了。这里还有个timer，主要用途是长按实现持续增加数字的功能，体验会好一点。<br>最大值最小值就是步进器的最大值和最小值。<br>抖动动画，是如果已经到最大值了，用户还在按加，就弹一个动画效果。<br>然后还有两个UIButton覆盖在增加和减号的图标上面，只是为了扩大点击热区。</p>\n<h3 id=\"2-4-生命周期函数\"><a href=\"#2-4-生命周期函数\" class=\"headerlink\" title=\"2.4 生命周期函数\"></a>2.4 生命周期函数</h3><pre><code class=\"line-numbers language-Swift\">/// UIView的初始化函数，这里一般会覆写这个方法\noverride public init(frame: CGRect) &#123;\n    super.init(frame: frame)\n    \n    setupUI()\n    \n    //整个控件的默认尺寸\n    if frame.isEmpty &#123;\n        self.frame = CGRect(x: 0, y: 0, width: 110, height: 30)\n    &#125;\n    \n&#125;\n\nrequired public init?(coder aDecoder: NSCoder) &#123;\n    super.init(coder: aDecoder)\n\n&#125;\n</code></pre>\n<p>一般情况，自定义View都需要覆写下这两个init函数。用来初始化UI。</p>\n<pre><code class=\"line-numbers language-Swift\">//设置UI布局\nfileprivate func setupUI() &#123;\n    /// 背景颜色清空\n    backgroundColor = UIColor.clear\n\n    /// 加图标和热区加按钮\n    decreaseBtn = setupButton(title: &quot;reduce_available&quot;)\n    decreaseBgBtn = setupButton(title: &quot; &quot;)\n    increaseBtn = setupButton(title: &quot;increase_available&quot;)\n    increaseBgBtn = setupButton(title: &quot; &quot;)\n    \n    decreaseBtn.backgroundColor = .clear\n    increaseBtn.backgroundColor = .clear\n    //减按钮(增大可触面积)\n    decreaseBgBtn.backgroundColor = .clear\n    //加按钮(增大可触面积)\n    increaseBgBtn.backgroundColor = .clear\n    \n    /// 中间区域的编辑框\n    textField = UITextField.init()\n    textField.font = UIFont.pingFangMedium(size: 16)\n    textField.layer.borderColor = UIColor(red: 0.79, green: 0.80, blue: 0.83, alpha: 1.00).cgColor\n    textField.layer.borderWidth = 1\n    textField.backgroundColor = UIColor(red: 0.97, green: 0.97, blue: 0.99, alpha: 1.00)\n    textField.layer.cornerRadius = 8\n    textField.textColor = UIColor(hex:&quot;#3B4058&quot;)\n    textField.delegate = self\n    textField.adjustsFontSizeToFitWidth = true        //当文字超出文本框宽度时，自动调整文字大小\n    textField.minimumFontSize = 14                   //最小可缩小的字号\n    textField.keyboardType = UIKeyboardType.numberPad\n    textField.textAlignment = NSTextAlignment.center\n    self.addSubview(textField)\n&#125;\n</code></pre>\n<p>内部用了一个setupButton给按钮增加背景，看下哈：</p>\n<pre><code class=\"line-numbers language-Swift\">//设置加减按钮的公共方法 设置action\nfileprivate func setupButton(title:String) -&gt; UIButton &#123;\n    let button = UIButton.init();\n    button.setBackgroundImage(UIImage.init(named: title), for: .normal)\n    button.setTitleColor(UIColor.gray, for: .normal)\n    button.addTarget(self, action:#selector(self.touchDown(_:)) , for: .touchDown)\n    button.addTarget(self, action:#selector(self.touchUp) , for:.touchUpOutside)\n    button.addTarget(self, action:#selector(self.touchUp) , for:.touchUpInside)\n    button.addTarget(self, action:#selector(self.touchUp) , for:.touchCancel)\n    self.addSubview(button)\n    \n    return button;\n&#125;\n</code></pre>\n<p>这里给按钮增加了一个action，主要是处理用户行为点击加号或者减号的逻辑：</p>\n<pre><code class=\"line-numbers language-Swift\">@objc fileprivate func touchDown(_ button: UIButton) &#123;\n        textField.endEditing(false)\n        if button == decreaseBtn || button == decreaseBgBtn &#123;\n            timer = Timer.scheduledTimer(timeInterval: 0.15, target: self, selector: #selector(self.decrease), userInfo: nil, repeats: true)\n        &#125; else &#123;\n            timer = Timer.scheduledTimer(timeInterval: 0.15, target: self, selector: #selector(self.increase), userInfo: nil, repeats: true)\n        &#125;\n        timer.fire()\n    &#125;\n</code></pre>\n<p>这里给按钮添加的action的函数，都需要@objc注解，原因是swift是静态编程语言，objc是动态的，所以这里需要转换为动态效果，所以要声明这个注解，不知道我理解得对不对。</p>\n<p>这里只有点击了就去执行加或者减的逻辑，用了一个定时器，保证150ms才走一次。<br>加的逻辑看下哈：</p>\n<pre><code class=\"line-numbers language-Swift\">@objc fileprivate func increase() &#123;\n        if (textField.text?.count)! == 0 || Int(textField.text!)! &lt;= _minValue &#123;\n            textField.text = &quot;\\(_minValue)&quot;\n        &#125;\n        \n        let number = Int(textField.text!)! + 1;\n        \n        if number &lt;= _maxValue &#123;\n            textField.text = &quot;\\(number)&quot;;\n            //闭包回调\n            NumberResultClosure?(&quot;\\(number)&quot;)\n        &#125; else &#123;\n            //添加抖动动画\n            if shakeAnimation &#123;shakeAnimationFunc()&#125;\n            print(&quot;已超过最大数量\\(_maxValue)&quot;);\n            if documentType == 1 &#123;\n                MBProgressHUD.showTipsMessage(&quot;数量已超出零售上限&quot;)\n            &#125;\n        &#125;\n        /// 触发rxSwift监听处更新\n        textField.sendActions(for: .valueChanged)\n        \n        if Int(textField.text!)! &gt;= maxValue &#123;\n            decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_available&quot;), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_Disable&quot;), for: .normal)\n        &#125;else&#123;\n            decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_available&quot;), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_available&quot;), for: .normal)\n        &#125;\n    &#125;\n</code></pre>\n<p>这里主要就是最大值和最小值判断，这里有个sendActions的方法，个人不是很理解。猜测是用了RxSwift的话，内部编辑框的值变更，会通知到rx的回调处，其实也是通知外部同步刷新。</p>\n<p>减的逻辑基本一致，这里就不再看了。</p>\n<p>上面还遗漏了一个抬起手后，将定时器取消，这点很重要，如果不及时处理，很容易造成内存泄漏。看下上面给touchCancel和其它按钮状态绑定的事件：</p>\n<pre><code class=\"line-numbers language-Swift\">//松开按钮:清除定时器\n@objc fileprivate func touchUp()  &#123;\n    cleanTimer()\n&#125;\n\n/// 内部实现\nfileprivate func cleanTimer() &#123;\n        if ((timer?.isValid) != nil) &#123;\n            timer.invalidate()\n            timer = nil;\n        &#125;\n    &#125;\n    \n/// 析构函数    \ndeinit &#123;\n    cleanTimer()\n&#125;\n</code></pre>\n<p>这里还有一个非常关键的生命周期函数：</p>\n<pre><code class=\"line-numbers language-Swift\">// MARK: - 重新布局UI\n    /// https://juejin.cn/post/6984250995874365448 layoutSubviews调用时机\n    /// 改变一个UIView的Frame会触发layoutSubviews\n    /// layoutSubviews, 当我们在某个类的内部调整子视图位置时，需要调用。反过来的意思就是说：如果你想要在外部设置subviews的位置，就不要重写。\n    /// 这个方法，默认没有做任何事情，需要子类进行重写\n    /// 如果没有这个方法，那么结果会是空白的，看不到任何东西\n    override open func layoutSubviews() &#123;\n        super.layoutSubviews()\n        \n        let height = frame.size.height\n        let width = frame.size.width\n        let textFieldWidth:CGFloat = 90\n        let BgBtnWidth:CGFloat = 42\n        let btnSize:CGFloat = 28\n        decreaseBtn.frame = CGRect(x: 0, y: (height-btnSize)/2, width: btnSize, height: btnSize)\n        //减按钮(增大可触面积)\n        decreaseBgBtn.frame = CGRect(x: 0, y: 0, width: BgBtnWidth, height: height)\n        increaseBtn.frame = CGRect(x: width-btnSize, y: (height-btnSize)/2, width: btnSize, height: btnSize)\n        //加按钮(增大可触面积)\n        increaseBgBtn.frame = CGRect(x: BgBtnWidth + textFieldWidth, y: 0, width: BgBtnWidth, height: height)\n        textField.frame = CGRect(x: BgBtnWidth, y: 0, width: textFieldWidth, height: height)\n    &#125;\n</code></pre>\n<p>这个方法必须要实现，确定视图frame，才可以真正显示到屏幕上。</p>\n<h3 id=\"2-5-给TextField绑定代理\"><a href=\"#2-5-给TextField绑定代理\" class=\"headerlink\" title=\"2.5 给TextField绑定代理\"></a>2.5 给TextField绑定代理</h3><p>在前面初始化UI里面有句代码是这样的：<br><code>textField.delegate = self</code><br>这里需要新建一个代理类来支持一下：</p>\n<pre><code class=\"line-numbers language-Swift\">extension PPNumberButton: UITextFieldDelegate &#123;\n    \n    // MARK: - UITextFieldDelegate\n    public func textFieldDidEndEditing(_ textField: UITextField) &#123;\n        if (textField.text?.count)! == 0 || Int(textField.text!) ?? 999999999 &lt; _minValue &#123;\n            textField.text = &quot;\\(_minValue)&quot;\n        &#125;\n        if Int(textField.text!) ?? 999999999 &gt; _maxValue &#123;\n            if documentType == 1 &#123;\n                MBProgressHUD.showTipsMessage(&quot;数量已超出零售上限&quot;)\n            &#125;\n        &#125;\n        if Int(textField.text!) ?? 999999999 &gt;= _maxValue &#123;\n            textField.text = &quot;\\(_maxValue)&quot;\n        &#125;\n        //闭包回调，传递值给外部\n        NumberResultClosure?(&quot;\\(textField.text!)&quot;)\n        //delegate的回调，暴露内部值给外部\n//        delegate2?.numberButtonResult(self, number: &quot;\\(textField.text!)&quot;)\n        \n        print(&quot;当前值:   \\(textField.text?.int ?? 0)&quot;)\n        \n        if (textField.text?.int ?? 0) &lt;= 0 &#123;\n            decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_Disable&quot;), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_available&quot;), for: .normal)\n        &#125;else if (textField.text?.int ?? 0) &gt;= maxValue &#123;\n            decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_available&quot;), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_Disable&quot;), for: .normal)\n        &#125;else&#123;\n            decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_available&quot;), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_available&quot;), for: .normal)\n        &#125;\n    &#125;\n    \n    public func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -&gt; Bool &#123;\n        \n        if range.location &lt;= 8 &#123;\n            return true\n        &#125;else&#123;\n            return false\n        &#125;\n    &#125;\n    \n&#125;\n</code></pre>\n<p>这里重写了官方文本代理的两个函数：<br>· textFieldDidEndEditing 结束编辑调用<br>· textField 实时调用，能否显示</p>\n<h3 id=\"2-6-自定义扩展函数\"><a href=\"#2-6-自定义扩展函数\" class=\"headerlink\" title=\"2.6 自定义扩展函数\"></a>2.6 自定义扩展函数</h3><p>原因是每个地方使用场景不同，这里需要通过扩展函数，可以自己添加一些逻辑，方便调用处能够实现效果。</p>\n<pre><code class=\"line-numbers language-Swift\">public extension PPNumberButton &#123;\n    \n    /**\n     输入框中的内容\n     */\n    var currentNumber: String? &#123;\n        get &#123;\n            return (textField.text!)\n        &#125;\n        set &#123;\n            textField.text = newValue\n            if isUserInteractionEnabled &#123;\n                if (newValue?.int ?? 0) &lt;= 0 &#123;\n                    decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_Disable&quot;), for: .normal)\n                    increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_available&quot;), for: .normal)\n                &#125; else if (newValue?.int ?? 0) &gt;= maxValue &#123;\n                    decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_available&quot;), for: .normal)\n                    increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_Disable&quot;), for: .normal)\n                &#125;else&#123;\n                    decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_available&quot;), for: .normal)\n                    increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_available&quot;), for: .normal)\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    /**\n     设置最小值\n     */\n    var minValue: Int &#123;\n        get &#123;\n            return _minValue\n        &#125;\n        set &#123;\n            _minValue = newValue\n            textField.text = &quot;\\(newValue)&quot;\n        &#125;\n    &#125;\n    /**\n     设置最大值\n     */\n    var maxValue: Int &#123;\n        get &#123;\n            return _maxValue\n        &#125;\n        set &#123;\n            _maxValue = newValue\n        &#125;\n    &#125;\n    \n    /**\n     * 加减按钮的响应闭包回调\n     * 当数字变化后，暴露给外部，执行自己逻辑\n     */\n    func numberResult(_ finished: @escaping ResultClosure) &#123;\n        NumberResultClosure = finished\n    &#125;\n    \n    /**\n     输入框中的字体属性\n     */\n    func inputFieldFont(_ inputFieldFont: UIFont) &#123;\n        textField.font = inputFieldFont;\n    &#125;\n    \n    /**\n     加减按钮的字体属性\n     */\n    func buttonTitleFont(_ buttonTitleFont: UIFont) &#123;\n        increaseBtn.titleLabel!.font = buttonTitleFont;\n        decreaseBtn.titleLabel!.font = buttonTitleFont;\n    &#125;\n    \n    /**\n     设置按钮的边框颜色\n     */\n    func borderColor(_ borderColor: UIColor) &#123;\n//        layer.borderColor = borderColor.cgColor;\n        decreaseBtn.layer.borderColor = borderColor.cgColor;\n        increaseBtn.layer.borderColor = borderColor.cgColor;\n        \n//        layer.borderWidth = 0.5;\n        decreaseBtn.layer.borderWidth = 0.5;\n        increaseBtn.layer.borderWidth = 0.5;\n    &#125;\n    \n    //注意:加减号按钮的标题和背景图片只能设置其中一个,若全部设置,则以最后设置的类型为准\n    \n    /**\n     设置加/减按钮的标题\n     \n     - parameter decreaseTitle: 减按钮标题\n     - parameter increaseTitle: 加按钮标题\n     */\n    func setTitle(decreaseTitle: String, increaseTitle: String) &#123;\n        decreaseBtn.setBackgroundImage(nil, for: .normal)\n        increaseBtn.setBackgroundImage(nil, for: .normal)\n        \n        decreaseBtn.setTitle(decreaseTitle, for: .normal)\n        increaseBtn.setTitle(increaseTitle, for: .normal)\n    &#125;\n    \n    /**\n     设置加/减按钮的背景图片\n     \n     - parameter decreaseImage: 减按钮背景图片\n     - parameter increaseImage: 加按钮背景图片\n     */\n    func setImage(decreaseImage: UIImage, increaseImage: UIImage) &#123;\n        decreaseBtn.setTitle(nil, for: .normal)\n        increaseBtn.setTitle(nil, for: .normal)\n        \n        decreaseBtn.setBackgroundImage(decreaseImage, for: .normal)\n        increaseBtn.setBackgroundImage(increaseImage, for: .normal)\n    &#125;\n    \n&#125;\n</code></pre>\n<p>这些都是暴露给外部调用者的函数，外部可以轻松改变背景，改变边框颜色等。</p>\n<pre><code class=\"line-numbers language-Swift\">public extension PPNumberButton &#123;\n    \n    /// 是否开启交互 这里主要是设置能否点击，业务需求是某些情况没有超过最大值或低于最小值也不可点击哦\n    var enabled: Bool &#123;\n        get &#123;\n            return isUserInteractionEnabled\n        &#125;\n        set &#123;\n            isUserInteractionEnabled = newValue\n            if isUserInteractionEnabled &#123;\n                let text = textField.text\n                currentNumber = text\n            &#125; else &#123;\n                decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_Disable&quot;), for: .normal)\n                increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_Disable&quot;), for: .normal)\n            &#125;\n        &#125;\n    &#125;\n    \n&#125;\n</code></pre>\n<p>上面的代码也是因为增加了 特殊需求，添加的一个扩展方法。</p>\n<p>另外还有一部分代码是使用RxSwift，增加了扩展方法，看下哈：</p>\n<pre><code class=\"line-numbers language-Swift\">extension Reactive where Base: PPNumberButton &#123;\n    var gmMaxValue: Binder&lt;Int&gt; &#123;\n        return Binder(self.base) &#123; (pp, max) in\n            pp.maxValue = max\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里应该是获取最大值，pp指代这个步进器，max就是最大值。</p>\n<h3 id=\"2-7-调用者如何使用\"><a href=\"#2-7-调用者如何使用\" class=\"headerlink\" title=\"2.7 调用者如何使用\"></a>2.7 调用者如何使用</h3><p>上面基本就把步进器实现完了。<br>下面看看调用者如何来使用步进器，这里简单示例下：</p>\n<p>先声明一个步进器</p>\n<pre><code class=\"line-numbers language-Swift\">private weak var cus_stepper: PPNumberButton!\n</code></pre>\n<p>然后目标地方创建一个步进器，并且初始化步进器相关属性</p>\n<pre><code class=\"line-numbers language-Swift\">let stepperViewW: CGFloat = 178.0\nlet stepperViewH: CGFloat = 40.0\nlet stepperViewB: CGFloat = 24.0\n\n/// 创建步进器并初始化\nlet cus_stepper = PPNumberButton()\ncus_stepper.shakeAnimation = true\ncus_stepper.maxValue = 999999999\ncus_stepper.minValue = 0\n\n/// 暴露回调给外部，里面就是自己逻辑了\ncus_stepper.numberResult &#123; [weak self] number in\n    guard let self = self else &#123; return &#125;\n    self.act_stepperCountChnage(number)\n&#125;\n\n/// 添加到目标contentView里面\ncontentView.addSubview(cus_stepper)\nself.cus_stepper = cus_stepper\n\n/// 布局设置\ncus_stepper.snp.makeConstraints &#123; make in\n    make.top.equalTo(imgV_photo.snp.bottom).offset(ySuperVerPad)\n    make.right.equalTo(contentView).offset(-ySuperHorPad)\n    make.width.equalTo(stepperViewW)\n    make.height.equalTo(stepperViewH)\n&#125;\n\ncus_stepper.snp.makeConstraints &#123; make in\n    make.bottom.equalTo(contentView).offset(-stepperViewB)\n&#125;\n</code></pre>\n<p>基本就这样。</p>\n<h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3 总结\"></a>3 总结</h2><p>1.自定义View需要先分析下交互，确定下如何拆分这个自定义View，再复杂的视图都是一块砖一块瓦拼接起来的，其实这个步进器就3个结构，左右图标，中间编辑框。<br>2.iOS自定义View一般都是继承UIView，重写两个init函数，layoutSubviews这个方法确定视图frame，才能显示到屏幕上。<br>3.给UIButton添加action一定要用@objc注解，表示可以使用动态方法。<br>4.对于封装自定义View一定要严格将某些方法暴露出去，某些方法私有，因为调用者不知道具体细节，所以封装者就一定要注意扩展性，一方面提供好用的扩展方法出去，能够方便调用者去设置各种属性，另一方面要注意类安全性，以及解耦性，尽量不要跟数据太耦合了。</p>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-需求分析\"><a href=\"#1-需求分析\" class=\"headerlink\" title=\"1 需求分析\"></a>1 需求分析</h2><p> 需要实现一个步进器效果，比如我们在购买商品时，需要添加这个商品，可以点击+或者-，也可以手动输入购买数量。<br> 效果如下：</p>\n <img src=\"stepper0.png\">\n <img src=\"stepper5.png\">\n\n<p> 基本交互很简单，有最小值和最大值，点击减号就将数量减1，点击加号就将数量加1，如果是最大值或者最小值，就将图标置灰不可点击。</p>\n<h2 id=\"2-代码实现\"><a href=\"#2-代码实现\" class=\"headerlink\" title=\"2 代码实现\"></a>2 代码实现</h2><h3 id=\"2-1-类外声明\"><a href=\"#2-1-类外声明\" class=\"headerlink\" title=\"2.1 类外声明\"></a>2.1 类外声明</h3><pre><code class=\"line-numbers language-Swift\">/// 定义一个闭包，主要是需要暴露里面的数字给外面，可以理解成定义一个接口类型\npublic typealias ResultClosure = (_ number: String)-&gt;()\n</code></pre>\n<p>这个主要是给调用步进器的地方使用，当用户行为导致数量变更，肯定要通知外部处理自己逻辑，这是封装自定义View的基本常识，一定要给外部一定的可操作空间。</p>\n<h3 id=\"2-2-创建步进器类\"><a href=\"#2-2-创建步进器类\" class=\"headerlink\" title=\"2.2 创建步进器类\"></a>2.2 创建步进器类</h3><pre><code class=\"line-numbers language-Swift\">/// 这里是自定义步进器了  @IBDesignable关键字用来声明一个类是可以被设计的，可以实时渲染在interface builder 上\n/// @IBInspectable关键字用来声明一个属性，可以在interface builder上修改该属性，就可以实时渲染border的变化\n/// open 修饰的 class 在 Module 内部和外部都可以被访问和继承\n@IBDesignable open class PPNumberButton: UIView &#123;\n</code></pre>\n<p>这里继承了UIView，这个注解只是用来实时预览，这里不要也行。如果想了解自定义View实时预览功能，可以参考下这篇文档：<a href=\"\">https://blog.wangruofeng007.com/posts/56184/</a></p>\n<h3 id=\"2-3-定义类属性\"><a href=\"#2-3-定义类属性\" class=\"headerlink\" title=\"2.3 定义类属性\"></a>2.3 定义类属性</h3><pre><code class=\"line-numbers language-Swift\">    /// 0为默认，1为零售开单\n    var documentType:Int = 0\n    \n    /// 结果闭包，用自定义的闭包类型\n    var NumberResultClosure: ResultClosure?\n    \n    var decreaseBtn: UIButton!     // 减按钮\n    var increaseBtn: UIButton!     // 加按钮\n    var textField: UITextField!    // 数量展示/输入框\n    var timer: Timer!              // 快速加减定时器\n    public var _minValue = 1                 // 最小值\n    public var _maxValue = Int.max           // 最大值\n    public var shakeAnimation: Bool = false  // 是否打开抖动动画\n    \n    var decreaseBgBtn:UIButton!  //减按钮(增大可触面积)\n    var increaseBgBtn:UIButton!  //加按钮(增大可触面积)\n    \n    /// rxSwift生命的袋子\n    let bag = DisposeBag()\n</code></pre>\n<p>这里documentType是自己的业务逻辑，忽略。结果闭包2.1声明的那个类型。然后就是几个基本视图了。这里还有个timer，主要用途是长按实现持续增加数字的功能，体验会好一点。<br>最大值最小值就是步进器的最大值和最小值。<br>抖动动画，是如果已经到最大值了，用户还在按加，就弹一个动画效果。<br>然后还有两个UIButton覆盖在增加和减号的图标上面，只是为了扩大点击热区。</p>\n<h3 id=\"2-4-生命周期函数\"><a href=\"#2-4-生命周期函数\" class=\"headerlink\" title=\"2.4 生命周期函数\"></a>2.4 生命周期函数</h3><pre><code class=\"line-numbers language-Swift\">/// UIView的初始化函数，这里一般会覆写这个方法\noverride public init(frame: CGRect) &#123;\n    super.init(frame: frame)\n    \n    setupUI()\n    \n    //整个控件的默认尺寸\n    if frame.isEmpty &#123;\n        self.frame = CGRect(x: 0, y: 0, width: 110, height: 30)\n    &#125;\n    \n&#125;\n\nrequired public init?(coder aDecoder: NSCoder) &#123;\n    super.init(coder: aDecoder)\n\n&#125;\n</code></pre>\n<p>一般情况，自定义View都需要覆写下这两个init函数。用来初始化UI。</p>\n<pre><code class=\"line-numbers language-Swift\">//设置UI布局\nfileprivate func setupUI() &#123;\n    /// 背景颜色清空\n    backgroundColor = UIColor.clear\n\n    /// 加图标和热区加按钮\n    decreaseBtn = setupButton(title: &quot;reduce_available&quot;)\n    decreaseBgBtn = setupButton(title: &quot; &quot;)\n    increaseBtn = setupButton(title: &quot;increase_available&quot;)\n    increaseBgBtn = setupButton(title: &quot; &quot;)\n    \n    decreaseBtn.backgroundColor = .clear\n    increaseBtn.backgroundColor = .clear\n    //减按钮(增大可触面积)\n    decreaseBgBtn.backgroundColor = .clear\n    //加按钮(增大可触面积)\n    increaseBgBtn.backgroundColor = .clear\n    \n    /// 中间区域的编辑框\n    textField = UITextField.init()\n    textField.font = UIFont.pingFangMedium(size: 16)\n    textField.layer.borderColor = UIColor(red: 0.79, green: 0.80, blue: 0.83, alpha: 1.00).cgColor\n    textField.layer.borderWidth = 1\n    textField.backgroundColor = UIColor(red: 0.97, green: 0.97, blue: 0.99, alpha: 1.00)\n    textField.layer.cornerRadius = 8\n    textField.textColor = UIColor(hex:&quot;#3B4058&quot;)\n    textField.delegate = self\n    textField.adjustsFontSizeToFitWidth = true        //当文字超出文本框宽度时，自动调整文字大小\n    textField.minimumFontSize = 14                   //最小可缩小的字号\n    textField.keyboardType = UIKeyboardType.numberPad\n    textField.textAlignment = NSTextAlignment.center\n    self.addSubview(textField)\n&#125;\n</code></pre>\n<p>内部用了一个setupButton给按钮增加背景，看下哈：</p>\n<pre><code class=\"line-numbers language-Swift\">//设置加减按钮的公共方法 设置action\nfileprivate func setupButton(title:String) -&gt; UIButton &#123;\n    let button = UIButton.init();\n    button.setBackgroundImage(UIImage.init(named: title), for: .normal)\n    button.setTitleColor(UIColor.gray, for: .normal)\n    button.addTarget(self, action:#selector(self.touchDown(_:)) , for: .touchDown)\n    button.addTarget(self, action:#selector(self.touchUp) , for:.touchUpOutside)\n    button.addTarget(self, action:#selector(self.touchUp) , for:.touchUpInside)\n    button.addTarget(self, action:#selector(self.touchUp) , for:.touchCancel)\n    self.addSubview(button)\n    \n    return button;\n&#125;\n</code></pre>\n<p>这里给按钮增加了一个action，主要是处理用户行为点击加号或者减号的逻辑：</p>\n<pre><code class=\"line-numbers language-Swift\">@objc fileprivate func touchDown(_ button: UIButton) &#123;\n        textField.endEditing(false)\n        if button == decreaseBtn || button == decreaseBgBtn &#123;\n            timer = Timer.scheduledTimer(timeInterval: 0.15, target: self, selector: #selector(self.decrease), userInfo: nil, repeats: true)\n        &#125; else &#123;\n            timer = Timer.scheduledTimer(timeInterval: 0.15, target: self, selector: #selector(self.increase), userInfo: nil, repeats: true)\n        &#125;\n        timer.fire()\n    &#125;\n</code></pre>\n<p>这里给按钮添加的action的函数，都需要@objc注解，原因是swift是静态编程语言，objc是动态的，所以这里需要转换为动态效果，所以要声明这个注解，不知道我理解得对不对。</p>\n<p>这里只有点击了就去执行加或者减的逻辑，用了一个定时器，保证150ms才走一次。<br>加的逻辑看下哈：</p>\n<pre><code class=\"line-numbers language-Swift\">@objc fileprivate func increase() &#123;\n        if (textField.text?.count)! == 0 || Int(textField.text!)! &lt;= _minValue &#123;\n            textField.text = &quot;\\(_minValue)&quot;\n        &#125;\n        \n        let number = Int(textField.text!)! + 1;\n        \n        if number &lt;= _maxValue &#123;\n            textField.text = &quot;\\(number)&quot;;\n            //闭包回调\n            NumberResultClosure?(&quot;\\(number)&quot;)\n        &#125; else &#123;\n            //添加抖动动画\n            if shakeAnimation &#123;shakeAnimationFunc()&#125;\n            print(&quot;已超过最大数量\\(_maxValue)&quot;);\n            if documentType == 1 &#123;\n                MBProgressHUD.showTipsMessage(&quot;数量已超出零售上限&quot;)\n            &#125;\n        &#125;\n        /// 触发rxSwift监听处更新\n        textField.sendActions(for: .valueChanged)\n        \n        if Int(textField.text!)! &gt;= maxValue &#123;\n            decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_available&quot;), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_Disable&quot;), for: .normal)\n        &#125;else&#123;\n            decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_available&quot;), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_available&quot;), for: .normal)\n        &#125;\n    &#125;\n</code></pre>\n<p>这里主要就是最大值和最小值判断，这里有个sendActions的方法，个人不是很理解。猜测是用了RxSwift的话，内部编辑框的值变更，会通知到rx的回调处，其实也是通知外部同步刷新。</p>\n<p>减的逻辑基本一致，这里就不再看了。</p>\n<p>上面还遗漏了一个抬起手后，将定时器取消，这点很重要，如果不及时处理，很容易造成内存泄漏。看下上面给touchCancel和其它按钮状态绑定的事件：</p>\n<pre><code class=\"line-numbers language-Swift\">//松开按钮:清除定时器\n@objc fileprivate func touchUp()  &#123;\n    cleanTimer()\n&#125;\n\n/// 内部实现\nfileprivate func cleanTimer() &#123;\n        if ((timer?.isValid) != nil) &#123;\n            timer.invalidate()\n            timer = nil;\n        &#125;\n    &#125;\n    \n/// 析构函数    \ndeinit &#123;\n    cleanTimer()\n&#125;\n</code></pre>\n<p>这里还有一个非常关键的生命周期函数：</p>\n<pre><code class=\"line-numbers language-Swift\">// MARK: - 重新布局UI\n    /// https://juejin.cn/post/6984250995874365448 layoutSubviews调用时机\n    /// 改变一个UIView的Frame会触发layoutSubviews\n    /// layoutSubviews, 当我们在某个类的内部调整子视图位置时，需要调用。反过来的意思就是说：如果你想要在外部设置subviews的位置，就不要重写。\n    /// 这个方法，默认没有做任何事情，需要子类进行重写\n    /// 如果没有这个方法，那么结果会是空白的，看不到任何东西\n    override open func layoutSubviews() &#123;\n        super.layoutSubviews()\n        \n        let height = frame.size.height\n        let width = frame.size.width\n        let textFieldWidth:CGFloat = 90\n        let BgBtnWidth:CGFloat = 42\n        let btnSize:CGFloat = 28\n        decreaseBtn.frame = CGRect(x: 0, y: (height-btnSize)/2, width: btnSize, height: btnSize)\n        //减按钮(增大可触面积)\n        decreaseBgBtn.frame = CGRect(x: 0, y: 0, width: BgBtnWidth, height: height)\n        increaseBtn.frame = CGRect(x: width-btnSize, y: (height-btnSize)/2, width: btnSize, height: btnSize)\n        //加按钮(增大可触面积)\n        increaseBgBtn.frame = CGRect(x: BgBtnWidth + textFieldWidth, y: 0, width: BgBtnWidth, height: height)\n        textField.frame = CGRect(x: BgBtnWidth, y: 0, width: textFieldWidth, height: height)\n    &#125;\n</code></pre>\n<p>这个方法必须要实现，确定视图frame，才可以真正显示到屏幕上。</p>\n<h3 id=\"2-5-给TextField绑定代理\"><a href=\"#2-5-给TextField绑定代理\" class=\"headerlink\" title=\"2.5 给TextField绑定代理\"></a>2.5 给TextField绑定代理</h3><p>在前面初始化UI里面有句代码是这样的：<br><code>textField.delegate = self</code><br>这里需要新建一个代理类来支持一下：</p>\n<pre><code class=\"line-numbers language-Swift\">extension PPNumberButton: UITextFieldDelegate &#123;\n    \n    // MARK: - UITextFieldDelegate\n    public func textFieldDidEndEditing(_ textField: UITextField) &#123;\n        if (textField.text?.count)! == 0 || Int(textField.text!) ?? 999999999 &lt; _minValue &#123;\n            textField.text = &quot;\\(_minValue)&quot;\n        &#125;\n        if Int(textField.text!) ?? 999999999 &gt; _maxValue &#123;\n            if documentType == 1 &#123;\n                MBProgressHUD.showTipsMessage(&quot;数量已超出零售上限&quot;)\n            &#125;\n        &#125;\n        if Int(textField.text!) ?? 999999999 &gt;= _maxValue &#123;\n            textField.text = &quot;\\(_maxValue)&quot;\n        &#125;\n        //闭包回调，传递值给外部\n        NumberResultClosure?(&quot;\\(textField.text!)&quot;)\n        //delegate的回调，暴露内部值给外部\n//        delegate2?.numberButtonResult(self, number: &quot;\\(textField.text!)&quot;)\n        \n        print(&quot;当前值:   \\(textField.text?.int ?? 0)&quot;)\n        \n        if (textField.text?.int ?? 0) &lt;= 0 &#123;\n            decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_Disable&quot;), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_available&quot;), for: .normal)\n        &#125;else if (textField.text?.int ?? 0) &gt;= maxValue &#123;\n            decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_available&quot;), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_Disable&quot;), for: .normal)\n        &#125;else&#123;\n            decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_available&quot;), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_available&quot;), for: .normal)\n        &#125;\n    &#125;\n    \n    public func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -&gt; Bool &#123;\n        \n        if range.location &lt;= 8 &#123;\n            return true\n        &#125;else&#123;\n            return false\n        &#125;\n    &#125;\n    \n&#125;\n</code></pre>\n<p>这里重写了官方文本代理的两个函数：<br>· textFieldDidEndEditing 结束编辑调用<br>· textField 实时调用，能否显示</p>\n<h3 id=\"2-6-自定义扩展函数\"><a href=\"#2-6-自定义扩展函数\" class=\"headerlink\" title=\"2.6 自定义扩展函数\"></a>2.6 自定义扩展函数</h3><p>原因是每个地方使用场景不同，这里需要通过扩展函数，可以自己添加一些逻辑，方便调用处能够实现效果。</p>\n<pre><code class=\"line-numbers language-Swift\">public extension PPNumberButton &#123;\n    \n    /**\n     输入框中的内容\n     */\n    var currentNumber: String? &#123;\n        get &#123;\n            return (textField.text!)\n        &#125;\n        set &#123;\n            textField.text = newValue\n            if isUserInteractionEnabled &#123;\n                if (newValue?.int ?? 0) &lt;= 0 &#123;\n                    decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_Disable&quot;), for: .normal)\n                    increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_available&quot;), for: .normal)\n                &#125; else if (newValue?.int ?? 0) &gt;= maxValue &#123;\n                    decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_available&quot;), for: .normal)\n                    increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_Disable&quot;), for: .normal)\n                &#125;else&#123;\n                    decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_available&quot;), for: .normal)\n                    increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_available&quot;), for: .normal)\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    /**\n     设置最小值\n     */\n    var minValue: Int &#123;\n        get &#123;\n            return _minValue\n        &#125;\n        set &#123;\n            _minValue = newValue\n            textField.text = &quot;\\(newValue)&quot;\n        &#125;\n    &#125;\n    /**\n     设置最大值\n     */\n    var maxValue: Int &#123;\n        get &#123;\n            return _maxValue\n        &#125;\n        set &#123;\n            _maxValue = newValue\n        &#125;\n    &#125;\n    \n    /**\n     * 加减按钮的响应闭包回调\n     * 当数字变化后，暴露给外部，执行自己逻辑\n     */\n    func numberResult(_ finished: @escaping ResultClosure) &#123;\n        NumberResultClosure = finished\n    &#125;\n    \n    /**\n     输入框中的字体属性\n     */\n    func inputFieldFont(_ inputFieldFont: UIFont) &#123;\n        textField.font = inputFieldFont;\n    &#125;\n    \n    /**\n     加减按钮的字体属性\n     */\n    func buttonTitleFont(_ buttonTitleFont: UIFont) &#123;\n        increaseBtn.titleLabel!.font = buttonTitleFont;\n        decreaseBtn.titleLabel!.font = buttonTitleFont;\n    &#125;\n    \n    /**\n     设置按钮的边框颜色\n     */\n    func borderColor(_ borderColor: UIColor) &#123;\n//        layer.borderColor = borderColor.cgColor;\n        decreaseBtn.layer.borderColor = borderColor.cgColor;\n        increaseBtn.layer.borderColor = borderColor.cgColor;\n        \n//        layer.borderWidth = 0.5;\n        decreaseBtn.layer.borderWidth = 0.5;\n        increaseBtn.layer.borderWidth = 0.5;\n    &#125;\n    \n    //注意:加减号按钮的标题和背景图片只能设置其中一个,若全部设置,则以最后设置的类型为准\n    \n    /**\n     设置加/减按钮的标题\n     \n     - parameter decreaseTitle: 减按钮标题\n     - parameter increaseTitle: 加按钮标题\n     */\n    func setTitle(decreaseTitle: String, increaseTitle: String) &#123;\n        decreaseBtn.setBackgroundImage(nil, for: .normal)\n        increaseBtn.setBackgroundImage(nil, for: .normal)\n        \n        decreaseBtn.setTitle(decreaseTitle, for: .normal)\n        increaseBtn.setTitle(increaseTitle, for: .normal)\n    &#125;\n    \n    /**\n     设置加/减按钮的背景图片\n     \n     - parameter decreaseImage: 减按钮背景图片\n     - parameter increaseImage: 加按钮背景图片\n     */\n    func setImage(decreaseImage: UIImage, increaseImage: UIImage) &#123;\n        decreaseBtn.setTitle(nil, for: .normal)\n        increaseBtn.setTitle(nil, for: .normal)\n        \n        decreaseBtn.setBackgroundImage(decreaseImage, for: .normal)\n        increaseBtn.setBackgroundImage(increaseImage, for: .normal)\n    &#125;\n    \n&#125;\n</code></pre>\n<p>这些都是暴露给外部调用者的函数，外部可以轻松改变背景，改变边框颜色等。</p>\n<pre><code class=\"line-numbers language-Swift\">public extension PPNumberButton &#123;\n    \n    /// 是否开启交互 这里主要是设置能否点击，业务需求是某些情况没有超过最大值或低于最小值也不可点击哦\n    var enabled: Bool &#123;\n        get &#123;\n            return isUserInteractionEnabled\n        &#125;\n        set &#123;\n            isUserInteractionEnabled = newValue\n            if isUserInteractionEnabled &#123;\n                let text = textField.text\n                currentNumber = text\n            &#125; else &#123;\n                decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_Disable&quot;), for: .normal)\n                increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_Disable&quot;), for: .normal)\n            &#125;\n        &#125;\n    &#125;\n    \n&#125;\n</code></pre>\n<p>上面的代码也是因为增加了 特殊需求，添加的一个扩展方法。</p>\n<p>另外还有一部分代码是使用RxSwift，增加了扩展方法，看下哈：</p>\n<pre><code class=\"line-numbers language-Swift\">extension Reactive where Base: PPNumberButton &#123;\n    var gmMaxValue: Binder&lt;Int&gt; &#123;\n        return Binder(self.base) &#123; (pp, max) in\n            pp.maxValue = max\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里应该是获取最大值，pp指代这个步进器，max就是最大值。</p>\n<h3 id=\"2-7-调用者如何使用\"><a href=\"#2-7-调用者如何使用\" class=\"headerlink\" title=\"2.7 调用者如何使用\"></a>2.7 调用者如何使用</h3><p>上面基本就把步进器实现完了。<br>下面看看调用者如何来使用步进器，这里简单示例下：</p>\n<p>先声明一个步进器</p>\n<pre><code class=\"line-numbers language-Swift\">private weak var cus_stepper: PPNumberButton!\n</code></pre>\n<p>然后目标地方创建一个步进器，并且初始化步进器相关属性</p>\n<pre><code class=\"line-numbers language-Swift\">let stepperViewW: CGFloat = 178.0\nlet stepperViewH: CGFloat = 40.0\nlet stepperViewB: CGFloat = 24.0\n\n/// 创建步进器并初始化\nlet cus_stepper = PPNumberButton()\ncus_stepper.shakeAnimation = true\ncus_stepper.maxValue = 999999999\ncus_stepper.minValue = 0\n\n/// 暴露回调给外部，里面就是自己逻辑了\ncus_stepper.numberResult &#123; [weak self] number in\n    guard let self = self else &#123; return &#125;\n    self.act_stepperCountChnage(number)\n&#125;\n\n/// 添加到目标contentView里面\ncontentView.addSubview(cus_stepper)\nself.cus_stepper = cus_stepper\n\n/// 布局设置\ncus_stepper.snp.makeConstraints &#123; make in\n    make.top.equalTo(imgV_photo.snp.bottom).offset(ySuperVerPad)\n    make.right.equalTo(contentView).offset(-ySuperHorPad)\n    make.width.equalTo(stepperViewW)\n    make.height.equalTo(stepperViewH)\n&#125;\n\ncus_stepper.snp.makeConstraints &#123; make in\n    make.bottom.equalTo(contentView).offset(-stepperViewB)\n&#125;\n</code></pre>\n<p>基本就这样。</p>\n<h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3 总结\"></a>3 总结</h2><p>1.自定义View需要先分析下交互，确定下如何拆分这个自定义View，再复杂的视图都是一块砖一块瓦拼接起来的，其实这个步进器就3个结构，左右图标，中间编辑框。<br>2.iOS自定义View一般都是继承UIView，重写两个init函数，layoutSubviews这个方法确定视图frame，才能显示到屏幕上。<br>3.给UIButton添加action一定要用@objc注解，表示可以使用动态方法。<br>4.对于封装自定义View一定要严格将某些方法暴露出去，某些方法私有，因为调用者不知道具体细节，所以封装者就一定要注意扩展性，一方面提供好用的扩展方法出去，能够方便调用者去设置各种属性，另一方面要注意类安全性，以及解耦性，尽量不要跟数据太耦合了。</p>\n"},{"title":"iOS-swift-自定义View之四级地址","date":"2023-01-27T08:26:44.000Z","top":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 需求分析\n目标是可以选择四级地址，什么是四级地址呢？省市区街道。类似淘宝买东西时，支付订单时需要填写收货地址，这里就需要构造一个四级地址弹框，让用户去选择。具体效果如下：\n<img src=%E5%9B%9B%E7%BA%A7%E5%9C%B0%E5%9D%80.gif>\n\n这个我们可以单独将这个地址弹框单独封装一下，本身就是一个工具，很多地方可能会用的。\n另外还需要提供传参，因为可能用户之前选择了某些地址，现在要更改，就需要跳转到已选择的四级地址，并且可以自己切换任何一个省市区，如果重新选择省，那么下级地址都需要清空；如果重新更新了市，那么下级清空，上级保留。\n大概就是这样子。\n\n所以我们就可以将四级地址视图用一个UIView来实现。\n\n## 2 控件结构\n\n首先我们分析下如何来完成这个需求，代码如何实现。\n这里我们考虑将ui提供的四级地址，通过自定义View来实现。\n\n顶部有一个列表，就是记录用户已选地址，省市区街道。\n底部也有一个列表，而且有分组，以地址的拼音首字母分组，组下也可能有会有不定行数的cell。\n\n这里我们就考虑 用两个UITableView来承载顶部和底部的列表。\n两个UITableView都放在  AddressView 的自定义View里面吧。\n\n所以会多出两个Cell，一个是顶部Cell，就叫做AddressCell吧；一个是底部Cell，承载底部列表，就叫做AddressSelectorCell吧。\n\n另外还有数据层，就叫它 AddressModel吧，放地址数据的。\n\n所以我们只需要4个文件就可以完成这个需求了。\n\n* AddressView 四级地址自定义View\n* AddressCell 顶部Cell\n* AddressSelectorCell 底部Cell\n* AddressModel 数据层\n\n## 3 AddressView 实现逻辑\n\n### 3.1 全局变量定义\n```Swift\nclass AddressView: UIView {\n    \n    typealias selectAddressBlock = (Array<RegionModel>)->()\n    var selectAddressHandle: selectAddressBlock?\n    var cancelAddressHandle: Handler?\n    \n    var modelArray: Array<Any> = []\n    var addressArray: Array<(key: Swift.String, value: Array<RegionModel>)> = []\n    var selectedIndex: Int = 0\n```\n这里定义一个闭包，就是用户勾选了4级地址后，需要将地址暴露个调用方，肯定需要一个方法发出去的。\n\ncancelAddressHandle是一个取消函数，主要处理用户点击蒙层或者点击取消的事件。\n\nmodelArray是记录顶部列表数据的数组。\n\naddressArray是记录底部列表数据的数组。\n\nselectedIndex是记录顶部选择了第几项的全局变量记录。\n\n然后是2个懒加载的UITableView，看下哈：\n```Swift\n/// 顶部视图列表\nprivate lazy var tblView: UITableView = {\n    let tableView = UITableView.init(frame: CGRect(x: 0, y: 196, width: ScreenWidth, height: ScreenHeight - 196), style: .grouped)\n    tableView.register(AddressCell.self, forCellReuseIdentifier: AddressCell.identifier)\n    tableView.delegate = self\n    tableView.dataSource = self\n    tableView.separatorStyle = .none\n    tableView.backgroundColor = .white\n    tableView.showsVerticalScrollIndicator = false\n    tableView.showsHorizontalScrollIndicator = false\n    tableView.isScrollEnabled = false\n    tableView.layer.cornerRadius = 14\n    tableView.layer.maskedCorners = [.layerMinXMinYCorner,.layerMaxXMinYCorner]\n    return tableView\n}()\n```\n\n还有一个底部的列表：\n```Swift\n/// 底部视图列表\nprivate lazy var addressTblView: UITableView = {\n    let tableView = UITableView.init(frame: CGRect.zero, style: .grouped)\n    tableView.register(AddressSelectorCell.self, forCellReuseIdentifier: AddressSelectorCell.identifier)\n    tableView.delegate = self\n    tableView.dataSource = self\n    tableView.backgroundColor = .white\n    tableView.separatorStyle = .none\n    tableView.showsVerticalScrollIndicator = false\n    tableView.showsHorizontalScrollIndicator = false\n    return tableView\n}()\n```\n虽然是两个UITableView，但可以共享同一个代理和数据源，需要在里面另外加if else判断下。\n\n### 3.2 生命周期函数\n这里只有一个初始化，但其实没有做什么，也没有把那两个UITableView加进去，这里应该就是空白的区域。\n```Swift\n  override init(frame: CGRect) {\n        super.init(frame: frame)\n        self.backgroundColor = UIColor.init(red: 0, green: 0, blue: 0, alpha: 0.6)\n    }\n    \n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n```\n\n### 3.3 初始化数据\n这里是另外提供的函数，来初始化，所以需要调用方额外调用这个方法。\n也正是这个方法，才会去加载ui的。\n\n```Swift\nfunc traverse(province: String, city: String, area: String, street: String){\n        modelArray.removeAll()\n        let dataArr: [RegionModel] = globalAddressModel?.data ?? AddressModel.init().data\n        self.recursive(dataArr: dataArr, province: province, city: city, area: area, street: street)\n        \n        if globalAddressModel != nil {\n            if modelArray.count == 0 {\n                /// 这里就展示省列表\n                self.setData(data: globalAddressModel!)\n            }else if modelArray.count == 4{\n                /// 这里展示街道列表\n                let model = modelArray[2]\n                self.setData(data: model)\n            } else{\n                /// 其它情况，就拿最后一个数据，在设置给底部内容tableView里面\n                let model = modelArray.last as! RegionModel\n                self.setData(data: model)\n            }\n        }\n        if modelArray.count < 4 {\n            modelArray.append(\"请选择\")\n        }\n        \n        /// 大概意思就是找到“请选择”在哪一个位置\n        selectedIndex = modelArray.firstIndex{$0 is String} ?? modelArray.count-1\n        /// 开始加载UI\n        self.loadUI()\n    }\n```\nglobalAddressModel 实际上再AppDelegate初始化的时候就去异步加载json文件了，这个应该就是保存的所有的四级地址信息了。\n\n然后这里用到了一个函数 recursive函数，是递归来寻找目标四级地址。\n```Swift\n/// 递归获取目标地址\nfunc recursive(dataArr: [RegionModel], province: String, city: String, area: String, street: String){\n    for model in dataArr{\n        if model.name.contains(province) ||\n            model.name.contains(city) ||\n            model.name.contains(area) ||\n            model.name.contains(street){\n            modelArray.append(model)\n            self.recursive(dataArr: model.children, province: province, city: city, area: area, street: street)\n            break\n        }\n    }\n}\n```\n找到后，会将实体append到这个数组中。\n\n然后上面初始化数据还用到一个函数：setData，作用是设置底部数据，因为这里底部自始至终都是同一个UITableView，会经常需要刷新数据。这里就是刷新底部数据的意思吧。\n\n看下这个setData函数哈：\n```Swift\nfunc setData(data: Any){\n        var dataArr: [RegionModel] = []\n        if data is AddressModel {\n            let tmpData = data as! AddressModel\n            dataArr = tmpData.data\n        }else{\n            let tmpData = data as! RegionModel\n            dataArr = tmpData.children\n        }\n        /// 上面的代码目的是为了拿到 RegionModel数组\n        \n        if dataArr.count == 0 {\n            return\n        }\n        \n        var tmpDic: Dictionary<String,Array<RegionModel>> = Dictionary<String,Array<RegionModel>>()\n        for model in dataArr{\n            var key: String = \"\"\n            key = self.findFirstLetterFromString(aString: model.name)\n            var arr = tmpDic[key] ?? Array<RegionModel>()\n            arr.append(model)\n            tmpDic[key] = arr\n        }\n        \n        //处理了第二个字首字母排序\n        _ = tmpDic.keys.compactMap{ key in\n            var tmpArr = tmpDic[key]!\n            tmpArr = tmpArr.sorted{(model1,model2) in\n                var key1 = \"\"\n                var key2 = \"\"\n                key1 = self.findFirstLetterFromString(aString: model1.name, isSecond: true)\n                key2 = self.findFirstLetterFromString(aString: model2.name, isSecond: true)\n                return key1 < key2\n            }\n            tmpDic[key] = tmpArr\n        }\n        addressArray = tmpDic.sorted{$0.key < $1.key}\n        \n        /// addressArray应该是拿到目前展示的内容区域数据 底部区域\n        self.addressTblView.reloadData()\n    }\n```\n这里代码虽然长，但实际上具体还是挺简单的，主要是生成一个字典的映射关系，key存放首字母，value存放同一个首字母下对应的地址列表。大概意思就是这个tmpDic是一个key value形式的map集合，key是这些比如省份首字母为G，那么value就对应广东省，甘肃省，广西，贵州省等下的所有地址。这里就对应tableView里面的每一组的数据了。然后处理下第二个首字母排序的问题。\n\n好的，这里打住了，回到第一个函数 traverse方法中，里面根据modelArray的长度去决定刷新哪一个列表，因为调用方给的地址不一定是四级，可能是1级或2级或3级，这里也是需要考虑到的。能在哪个层级搜索到，就定位到哪个层级，那么最后一个层级这里使用 append一个“请选择”，这里说明如果是字符串了，那么这里就是最后一层级。感觉这还可以优化下，比较用字符串来判断到哪一层级不太合适的。\n\ntraverse最后一个方法是加载UI。\n```Swift\nfunc loadUI(){\n        /// 先加顶部\n        self.addSubview(tblView)\n        /// 顶部布局\n        self.updateUI()\n        \n        /// 再加底部\n        self.addSubview(addressTblView)\n        /// 底部布局\n        addressTblView.snp.remakeConstraints{make in\n            make.leading.trailing.bottom.equalTo(0)\n            make.top.equalTo(tblView.snp.bottom).offset(0)\n        }\n    }\n\nfunc updateUI(){\n        tblView.snp.remakeConstraints{make in\n            make.leading.trailing.equalTo(0)\n            make.top.equalTo(196)\n            if modelArray.count == 1 {\n                make.height.equalTo(96)\n            }else{\n                make.height.equalTo(96+modelArray.count*48)\n            }\n        }\n        self.tblView.reloadData()\n    }\n```\n大概意思就是把那两个UITableView加给父View。\n\n然后需要用的扩展方法有下面这个：\n```Swift\nextension AddressView{\n    \n    /// 找到中文对应的第一个字符对应的第一个字母拼音\n    func findFirstLetterFromString(aString: String, isSecond : Bool = false) -> String {\n        //转变成可变字符串\n        let mutableString = NSMutableString.init(string: aString)\n        \n        //将中文转换成带声调的拼音\n        CFStringTransform(mutableString as CFMutableString, nil,      kCFStringTransformToLatin, false)\n        \n        //去掉声调\n        let pinyinString = mutableString.folding(options:          String.CompareOptions.diacriticInsensitive, locale:   NSLocale.current)\n        \n        //将拼音首字母换成大写\n        let strPinYin = polyphoneStringHandle(nameString: aString,    pinyinString: pinyinString).uppercased()\n        \n        //截取大写首字母\n        let arr = strPinYin.components(separatedBy: \" \")\n        let completeStr = isSecond == false ? arr[0] : arr[1]\n        let firstString = completeStr.subScript(index: 0, length: 1)\n        //判断首字母是否为大写\n        let regexA = \"^[A-Z]$\"\n        let predA = NSPredicate.init(format: \"SELF MATCHES %@\", regexA)\n        return predA.evaluate(with: firstString) ? firstString : \"#\"\n    }\n    \n    //多音字处理，根据需要添自行加\n    func polyphoneStringHandle(nameString: String, pinyinString: String) -> String {\n        //        if nameString.hasPrefix(\"长\") {return \"chang\"}\n        //        if nameString.hasPrefix(\"沈\") {return \"shen\"}\n        //        if nameString.hasPrefix(\"厦\") {return \"xia\"}\n        //        if nameString.hasPrefix(\"地\") {return \"di\"}\n        //        if nameString.hasPrefix(\"重\") {return \"chong\"}\n        return pinyinString\n    }\n}\n```\n这里主要是一个工具方法，内部使用，无需多讲。\n\n好了，前面的ui基本就这些。\n下面主要是讲解下UITableView的代理方法和数据源配置。\n\n```Swift\n/// 设置顶部tableView 代理和数据\nextension AddressView: UITableViewDelegate,UITableViewDataSource{\n    func numberOfSections(in tableView: UITableView) -> Int {\n        if tableView == tblView {\n            return 1    /// 顶部tableView只有一组\n        }else{\n            return addressArray.count   /// 很多组 26个字母都有的话，就26组\n        }\n    }\n```\n这里扩展AddressView，去实现UITableViewDelegate和UITableViewDataSource协议。\n这是第一个方法，numberOfSections，返回有多少组。这里因为顶部只有一种类型，也就只有一组，底部用了一个数组记录，组数就是数组的长度。\n\n```Swift\nfunc tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        if tableView == tblView {\n            /// 顶部，如果没有 历史地址，则为0，有则显示 一组多少个\n            if modelArray.count == 1 && (modelArray.last is String) {\n                return 0\n            }else{\n                return modelArray.count\n            }\n        }else{\n            /// 取当前组里面多少个\n            let dic = addressArray[section]\n            let arr = dic.value\n            return arr.count\n        }\n    }\n```\n这是第二个方法，numberOfRowsInSection，意思就是这个组下有多少行。\n\n```Swift\n func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n        /// 上面下面都是48\n        if tableView == tblView {\n            return 48\n        }else{\n            return 48\n        }\n    }\n```\n这里是每行的高度。\n\n```Swift\n/// 每个cell怎么显示\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    /// 如果是顶部\n    if tblView == tableView {\n        /// 顶部用AddressCell\n        let cell = tableView.dequeueReusableCell(withIdentifier: AddressCell.identifier, for: indexPath) as! AddressCell\n        let model = modelArray[indexPath.row]\n        /// 数据用modelArray里面的数据\n        cell.model = model\n        /// 选中的话，高亮显示文字颜色\n        if selectedIndex == indexPath.row {\n            cell.titleLb.textColor = UIColor.init(hex: \"#409EFF\")\n        }else{\n            cell.titleLb.textColor = UIColor.init(hex: \"#3B4058\")\n        }\n        /// 这里是请选择什么\n        if model is String {\n            cell.updateUI(indexPath: indexPath)\n        }\n        \n        /// 指示剂方向\n        if indexPath.row == 0 {\n            cell.position = .down // 第0行，只有下面的\n        }else if indexPath.row == modelArray.count-1{\n            cell.position = .top /// 最后一行，只有上面\n        }else{\n            cell.position = .middle /// 其它都有\n        }\n        \n        return cell\n    }else{\n        /// 如果是底部，数据取addressArray里面的\n        let dic = addressArray[indexPath.section]\n        let arr = dic.value\n        let model = arr[indexPath.row] // 这个字母类别里面的 第row行\n        \n        /// 这个cell用 AddressSelector来实现\n        let cell = tableView.dequeueReusableCell(withIdentifier: AddressSelectorCell.identifier, for: indexPath) as! AddressSelectorCell\n        \n        /// 第1行才有字母\n        if indexPath.row == 0 {\n            cell.indexLb.text = dic.key\n        }else{\n            cell.indexLb.text = \"\"\n        }\n        \n        /// 当前在那个层级 比如是广东省\n        let obj = modelArray[selectedIndex]\n        if obj is String { /// 请选择层级\n            cell.checkImgView.isHidden = true\n            cell.nameLb.textColor = UIColor.init(hex: \"#3B4058\")\n        }else{\n            /// 已选层级\n            let selectedModel = obj as! RegionModel\n            if selectedModel.name == model.name { /// 列表中的就是已选的，高亮一下\n                cell.nameLb.textColor = UIColor.init(hex: \"#409EFF\")\n                cell.checkImgView.isHidden = false\n            }else{\n                cell.nameLb.textColor = UIColor.init(hex: \"#3B4058\")\n                cell.checkImgView.isHidden = true\n            }\n        }\n        \n        ///  显示目标地址名称\n        cell.nameLb.text = model.name\n        return cell\n    }\n}\n```\n这个方法就比较关键了，就是每行怎么展现的。\n用哪个Cell，是否要高亮，指示剂怎么展示，这里有点像Android的adpter里面的bindAdapter实现逻辑。这里需要按照需求在item里面自行处理逻辑。\n\n如果是底部，就需要考虑是否显示字母，是否高亮这些了。\n\n```Swift\n/// 标题和单元格间隔\nfunc tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {\n    /// 顶部头部预留48dp显示标题“请选择所在地区”\n    if tableView == tblView {\n        return 48\n    }else{\n        return 0.01\n    }\n}\n```\n顶部预留高度，用来展示自己的标题。\n\n```Swift\n/// 和上面对应，预留48个dp怎么显示\nfunc tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {\n    if tableView == tblView {\n        let view = UIView.init(frame: CGRect.init(x: 0, y: 0, width: ScreenWidth, height: 48))\n        let label = UILabel.init()\n        label.font = .pingFangSemibold(size: 18)\n        label.textColor = UIColor.init(hex: \"#3B4058\")\n        label.text = \"请选择所在地区\"\n        \n        let closeBtn: UIButton = {\n            let btn = UIButton()\n            btn.setTitle(\"取消\", for: .normal)\n            btn.setTitleColor(UIColor.init(hex: \"#409EFF\"), for: .normal)\n            btn.titleLabel?.font = .pingFangRegular(size: 16)\n            btn.addTarget(self, action: #selector(actionForClose), for: .touchUpInside)\n            return btn\n        }()\n        \n        view.addSubview(label)\n        view.addSubview(closeBtn)\n        label.snp.makeConstraints{make in\n            make.centerY.equalTo(view)\n            make.centerX.equalTo(view)\n            make.width.equalTo(130)\n            make.height.equalTo(30)\n        }\n        closeBtn.snp.makeConstraints{make in\n            make.trailing.equalTo(-16)\n            make.centerY.equalTo(view)\n            make.width.equalTo(48)\n            make.height.equalTo(48)\n        }\n        return view\n    }else{\n        return UIView()\n    }\n}\n```\n标题和取消按钮显示逻辑。\n\n```Swift\n/// 单元格尾巴怎么显示\nfunc tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -> CGFloat {\n    /// 如果是顶部tableView，预留48个dp\n    if tableView == tblView {\n        return 48\n    }else{\n        return 0.01\n    }\n}\n```\n这里顶部有效，有48个单位长度，用来显示底部标题。\n\n```Swift\n/// 尾部显示 选择下级地址\nfunc tableView(_ tableView: UITableView, viewForFooterInSection section: Int) -> UIView? {\n    if tableView == tblView {\n        let view = UIView.init(frame: CGRect.init(x: 0, y: 0, width: ScreenWidth, height: 48))\n        \n        let lineView = UIView()\n        lineView.backgroundColor = UIColor.init(hex: \"#F6F6F6\")\n        let label = UILabel.init()\n        label.font = .pingFangSemibold(size: 16)\n        label.textColor = UIColor.init(hex: \"#3B4058\")\n        \n        if selectedIndex == 0 {\n            label.text = \"选择省份/地区\"\n        }else if selectedIndex == 1{\n            label.text = \"选择城市\"\n        }else if selectedIndex == 2{\n            label.text = \"选择区/县\"\n        }else{\n            label.text = \"选择街道/镇\"\n        }\n        \n        view.addSubview(lineView)\n        view.addSubview(label)\n        \n        lineView.snp.makeConstraints{make in\n            make.top.equalTo(4)\n            make.leading.trailing.equalTo(0)\n            make.height.equalTo(0.5)\n        }\n        label.snp.makeConstraints{make in\n            make.top.equalTo(16)\n            make.leading.equalTo(8)\n            make.width.equalTo(150)\n            make.height.equalTo(30)\n        }\n        return view\n    }else{\n        return UIView()\n    }\n}\n```\n这里就是确定底部标题的怎么显示的。\n\n```Swift\n/// 点击了单元格\nfunc tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n    if tblView == tableView {\n        /// 顶部点击了哪个单元格\n        if indexPath.row == 0 {\n            self.setData(data: globalAddressModel!)\n        }else{\n            let model = modelArray[indexPath.row-1]\n            self.setData(data: model)\n        }\n        selectedIndex = indexPath.row\n        /// 改变全局变量 selectedIndex，再去加载\n        self.tblView.reloadData()\n    }else{\n        /// 当前是哪一组\n        let dic = addressArray[indexPath.section]\n        let arr = dic.value\n        /// 当前是哪一行\n        let model = arr[indexPath.row]\n        \n        /// 请选择是第几个\n        let index = modelArray.firstIndex{$0 is String} ?? 0\n        /// 顶部是请选择\n        if modelArray[selectedIndex] is String && modelArray.count < 5{\n            /// 插入目标点击的地址 给modelArray\n            modelArray.insert(model, at: index)\n            if modelArray.count == 5 {\n                modelArray.removeLast()\n            }\n        }else{\n            /// 顶部不是请选择,而已已选择的地址\n            modelArray[selectedIndex] = model\n            /// 下面有请选择，需要清空之前选择的值\n            let isContain = modelArray.contains(where: {$0 is String})\n            if isContain {\n                for i in (selectedIndex+1 ... modelArray.count-1).reversed(){\n                    if modelArray[i] is String {\n                        continue\n                    }\n                    modelArray.remove(at: i)\n                }\n            } else if !isContain && selectedIndex != 3{\n                for i in (selectedIndex+1 ... modelArray.count-1).reversed(){\n                    modelArray.remove(at: i)\n                }\n            }\n            \n            if modelArray.count < 4 && !modelArray.contains(where: {$0 is String}){\n                modelArray.append(\"请选择\")\n            }\n        }\n        \n        /// 没有请选择了，会直接关闭弹框，执行回调\n        if modelArray.count == 4 && !modelArray.contains(where: {$0 is String}){\n            var arr: [RegionModel] = []\n            for model in modelArray {\n                let obj = model as! RegionModel\n                arr.append(obj)\n            }\n            selectAddressHandle?(arr)\n            self.removeFromSuperview()\n        }else{\n            /// 更新底部数据，以及顶部选择index\n            self.setData(data: model)\n            self.updateUI()\n            selectedIndex += 1\n        }\n    }\n}\n```\n上面的代码逻辑，主要就是处理点击顶部单元格，和底部单元格的逻辑。\n顶部点击会调用setData,会同步刷新底部。\n\n底部点击也会setData,刷新底部数据，如果全部选择，则会走闭包回调，将用户选择的四级地址回调出去。\n\n然后还有一些其它扩展方法，简单看下哈。\n```Swift\n/// 扩展给外部\nextension AddressView{\n    /// 通知调用者当有一个或者多个手指触摸到了视图或者窗口时触发此方法。\n    /// touches是UITouch的集合，通过UITouch我们可以检测触摸事件的属性，是单拍还是双拍，还有触摸的位置等。\n    /// 这里应该是触摸到蒙层后关闭弹框\n    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {\n        guard let point = touches.first?.location(in: self) else { return }\n        let p = self.layer.convert(point, from: self.layer)\n        if self.layer.contains(p) {\n            self.actionForClose()\n        }\n    }\n    \n    /// 移除自己，类似关闭弹框效果\n    @objc func actionForClose(){\n        cancelAddressHandle?()\n        self.removeFromSuperview()\n    }\n}\n```\n这里actionForClose是UiButton设置的一个action，上面哪个是覆写的官方方法，应该是触摸到蒙层自动关闭弹框。\n\n## 4 AddressCell 实现逻辑\n这个可以理解成Android中的Adapter了。也就是item怎么显示。\n```Swift\n/// 顶部cell\nclass AddressCell: UITableViewCell {\n    \n    enum LinePosition {\n        case down\n        case middle\n        case top\n    }\n    \n    static var identifier: String = \"AddressCell\"\n```\n这里需要继承UITableViewCell，必须要有一个identifier，这个主要是为了复用，因为列表可能会很长，为了合理复用，这里一般都需要一个标识符。\n\n### 4.1 子View定义\n```Swift\n /// 安徽省\nlazy var titleLb: UILabel = {\n    let label = UILabel()\n    label.font = .pingFangMedium(size: 16)\n    label.textColor = UIColor.init(hex: \"#3B4058\")\n    return label\n}()\n\n/// 实心圆\nlazy var roundView: UIView = {\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: \"#409EFF\")\n    view.layer.cornerRadius = 3.5\n    view.layer.borderWidth = 1\n    view.layer.borderColor = UIColor.init(hex: \"#409EFF\").cgColor\n    return view\n}()\n\n/// 圆上面的线条\nlazy private var toplineView: UIView = {\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: \"#409EFF\")\n    return view\n}()\n\n/// 圆下面的线条\nlazy private var downlineView: UIView = {\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: \"#409EFF\")\n    return view\n}()\n\n/// 右侧箭头\nlazy private var rightImgView: UIImageView = {\n    let imgView = UIImageView()\n    imgView.image = UIImage.init(named: \"客户信息_右箭头\")\n    return imgView\n}()\n```\n这里是顶部item用的一些零部件。\n比如上下线图，右侧箭头，中间文字。实心圆。\n这里变空心，实际上只是设置了中间颜色为纯白。\n\n### 4.2 数据定义\n```Swift\n/// 监听数据变化 数据填充\nvar model: Any?{\n    didSet{\n        guard let _model = model else{return}\n        if _model is RegionModel {\n            let tmp = _model as! RegionModel\n            titleLb.text = tmp.name\n        }\n    }\n}\n    \n/// 线条位置\nvar position: LinePosition?{\n    didSet{\n        guard let _position = position else{return}\n        /// 上面和下面的线条都先一出去\n        toplineView.removeFromSuperview()\n        downlineView.removeFromSuperview()\n        \n        /// 如果在下面 空心圆\n        if _position == .down {\n            contentView.addSubview(downlineView)\n            downlineView.snp.makeConstraints{make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(roundView.snp.top).offset(0)\n                make.bottom.equalTo(0)\n                make.width.equalTo(1)\n            }\n            roundView.backgroundColor = UIColor.init(hex: \"#409EFF\")\n        }else if _position == .top{\n            /// 如果在上面 空心圆\n            contentView.addSubview(toplineView)\n            toplineView.snp.makeConstraints{make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(0)\n                make.bottom.equalTo(roundView.snp.top)\n                make.width.equalTo(1)\n            }\n            if model is String {\n                roundView.backgroundColor = .white\n            }else{\n                roundView.backgroundColor = UIColor.init(hex: \"#409EFF\")\n            }\n        }else{\n            /// 都不在，也是都存在的意思\n            contentView.addSubview(toplineView)\n            contentView.addSubview(downlineView)\n            toplineView.snp.makeConstraints{make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(0)\n                make.bottom.equalTo(roundView.snp.top)\n                make.width.equalTo(1)\n            }\n            downlineView.snp.remakeConstraints{make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(roundView.snp.bottom)\n                make.bottom.equalTo(0)\n                make.width.equalTo(1)\n            }\n            roundView.backgroundColor = UIColor.init(hex: \"#409EFF\")\n        }\n    }\n}\n```\n这里定义了2个数据，1个是具体显示什么的数据，一个是线条怎么展示，什么时候展示实心和空心圆的逻辑。\n\n### 4.3 生命周期函数\n首先看下初始化。\n```Swift\noverride init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        \n        self.selectionStyle = .none\n        \n        /// 添加安徽省\n        contentView.addSubview(titleLb)\n        titleLb.snp.makeConstraints{make in\n            make.centerY.equalToSuperview()\n            make.leading.equalTo(roundView.snp.trailing).offset(22)\n            make.trailing.equalTo(rightImgView.snp.leading).offset(10)\n            make.height.equalTo(20)\n        }\n        \n        /// 添加圆形指示器\n        contentView.addSubview(roundView)\n        roundView.snp.makeConstraints{make in\n            make.centerY.equalToSuperview()\n            make.leading.equalTo(14)\n            make.width.equalTo(7)\n            make.height.equalTo(7)\n        }\n        \n        /// 添加右侧箭头\n        contentView.addSubview(rightImgView)\n        rightImgView.snp.makeConstraints{make in\n            make.centerY.equalToSuperview()\n            make.trailing.equalTo(-16)\n            make.width.equalTo(19)\n            make.height.equalTo(19)\n        }\n        \n    }\n    \n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n```\n这里就加了3个视图，并且布局了。\n\n### 4.4 其它扩展方法\n```Swift\nextension AddressCell{\n    func updateUI(indexPath: IndexPath){\n        if indexPath.row == 1 {\n            titleLb.text = \"请选择城市\"\n        }else if indexPath.row == 2 {\n            titleLb.text = \"请选择县\"\n        }else if indexPath.row == 3{\n            titleLb.text = \"请选街道\"\n        }else{\n            titleLb.text = \"\"//model as? String\n        }\n    }\n}\n```\n这里就是显示item特殊情况的文案。\n\n## 5 AddressSelectorCell 实现逻辑\n这里也同上面的Cell，有一个标识符。\n```Swift\n/// 底部Cell\nclass AddressSelectorCell: UITableViewCell {\n    \n    static var identifier: String = \"UITableViewCell\"\n```\n\n### 5.1 子View\n这里需要哪些子View呢？\n```Swift\n//索引 eg: A字母\nlazy var indexLb: UILabel = {\n    let label = UILabel()\n    label.font = .pingFangMedium(size: 12)\n    label.textColor = UIColor.init(hex: \"#9B9DA7\")\n    return label\n}()\n\n//名称 eg: 安徽省\nlazy var nameLb: UILabel = {\n    let label = UILabel()\n    label.font = .pingFangMedium(size: 14)\n    label.textColor = UIColor.init(hex: \"#3B4058\")\n    return label\n}()\n\n//勾选图标\nlazy var checkImgView: UIImageView = {\n    let imgView = UIImageView()\n    imgView.isHidden = true\n    imgView.image = UIImage.init(named: \"勾选\")\n    return imgView\n}()\n```\n这里非常简单，只有3个子视图，字母，中间名称，是否勾选。\n\n### 5.2 生命周期函数\n看下初始化吧。\n```Swift\noverride init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        self.selectionStyle = .none\n        \n        /// 添加索引，并且布局\n        contentView.addSubview(indexLb)\n        indexLb.snp.makeConstraints{make in\n            make.leading.equalTo(8)\n            make.centerY.equalToSuperview()\n            make.width.equalTo(10)\n            make.height.equalTo(20)\n        }\n        \n        /// 添加名称，并且位置确定\n        contentView.addSubview(nameLb)\n        nameLb.snp.makeConstraints{make in\n            make.leading.equalTo(indexLb.snp.trailing).offset(16)\n            make.trailing.equalTo(-16)\n            make.centerY.equalToSuperview()\n            make.height.equalTo(20)\n        }\n        \n        /// 确定勾选图标\n        contentView.addSubview(checkImgView)\n        checkImgView.snp.makeConstraints{make in\n            make.trailing.equalTo(-16)\n            make.centerY.equalToSuperview()\n            make.width.equalTo(16)\n            make.height.equalTo(16)\n        }\n    }\n    \n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n```\n也是非常简单，添加了3个子视图，并且确定位置了。\n\n## 6 AddressModel 实现逻辑\n这个是四级地址的数据模型，可以看下：\n```Swift\nimport Foundation\nimport HandyJSON\n\nclass AddressModel: HandyJSON {\n    var data: [RegionModel] = []\n    required init() {}\n}\n\nclass RegionModel: HandyJSON {\n    var code: String = \"\"\n    var name: String = \"\"\n    var children: [RegionModel] = []\n    required init() {}\n}\n```\n继承了HandyJSON，方便解析。\n这里AddressModel实际上内部也是由 RegionModel数组构成的。\n这个AddressModel用来存放省列表比较合适。\n\nRegionModel可以存放市，区，街道，都没问题。\n\n封装四级地址基本上就这些了。\n\n## 7 外部调用方式\n\n### 7.1 先声明一个四级地址View\n```Swift\nlazy private var addressView: AddressView = {\n        let tmpview = AddressView(frame: CGRect.init(x: 0, y: 0, width: ScreenWidth, height: ScreenHeight))\n        return tmpview\n    }()\n```\n这里设定了它的frame，也就是大小位置。\n\n### 7.2  弹出四级地址\n```Swift\nfunc showAddressSelector(){\n        self.view.addSubview(self.addressView)\n        self.addressView.traverse(province: self.orderAddressModel?.province ?? \"\", city: self.orderAddressModel?.city ?? \"\", area: self.orderAddressModel?.region ?? \"\", street: self.orderAddressModel?.street ?? \"\")\n        addressView.selectAddressHandle = {[weak self] (arr)in\n            guard let weakSelf = self else{return}\n            let pModel = arr[0]\n            let cModel = arr[1]\n            let aModel = arr[2]\n            let tModel = arr[3]\n            ...\n            \n        }\n    }\n```\n这里通过addSubview的方式，将这个四级地址添加到这个UIViewController的根布局上。类似叠加布局的方式。\n\n然后调用了一个关键的函数，traverse，将初始地址设置进去。\n\n然后设置了选择回调函数，这里用户选择了四级地址后，会回调到这个handle里面哦。\n\n## 8 总结\n\n* 做一个复杂的自定义View，一定要化繁为简，将复杂的结构一步一步拆分成一个一个基本视图，这样能够很好规划实现方案。\n\n* 任何一个自定义View实现方案可能会有多种，可以选择自己最熟悉的一种，然后进行研究，觉得不合适可以换其它方案来实现。\n\n* 四级地址最关键的应该是数据了，这里我们实现方案是单页面，数据同步刷新的方式，其实也可以考虑多页面，可自由切换，毕竟地址层级不会太多。\n\n* 需要考虑到用户之前填写的地址，可能只填了1到3级，所以一定要考虑全面一点，作为封装视图者，不能只考虑到最完美的情况。\n\n* 多个UITableView是可以共用同一个代理和数据源的，只需要再代理里面区分下是那个UITableView即可。\n\n* UITableView有很多代理协议，这里可以设置多个组类，一个组多少行，头部View，尾部View，头部高度，尾部高度，点击item，等多种方法，可以实现很复杂的逻辑。\n\n* UITableView的Cell一定要分配一个标识符，用来复用，增加程序稳定性。","source":"_posts/iOS-swift-自定义View之四级地址.md","raw":"---\ntitle: iOS-swift-自定义View之四级地址\ndate: 2023-01-27 16:26:44\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- iOS 自定义View\ncategories:\n- iOS\n---\n\n## 1 需求分析\n目标是可以选择四级地址，什么是四级地址呢？省市区街道。类似淘宝买东西时，支付订单时需要填写收货地址，这里就需要构造一个四级地址弹框，让用户去选择。具体效果如下：\n<img src=%E5%9B%9B%E7%BA%A7%E5%9C%B0%E5%9D%80.gif>\n\n这个我们可以单独将这个地址弹框单独封装一下，本身就是一个工具，很多地方可能会用的。\n另外还需要提供传参，因为可能用户之前选择了某些地址，现在要更改，就需要跳转到已选择的四级地址，并且可以自己切换任何一个省市区，如果重新选择省，那么下级地址都需要清空；如果重新更新了市，那么下级清空，上级保留。\n大概就是这样子。\n\n所以我们就可以将四级地址视图用一个UIView来实现。\n\n## 2 控件结构\n\n首先我们分析下如何来完成这个需求，代码如何实现。\n这里我们考虑将ui提供的四级地址，通过自定义View来实现。\n\n顶部有一个列表，就是记录用户已选地址，省市区街道。\n底部也有一个列表，而且有分组，以地址的拼音首字母分组，组下也可能有会有不定行数的cell。\n\n这里我们就考虑 用两个UITableView来承载顶部和底部的列表。\n两个UITableView都放在  AddressView 的自定义View里面吧。\n\n所以会多出两个Cell，一个是顶部Cell，就叫做AddressCell吧；一个是底部Cell，承载底部列表，就叫做AddressSelectorCell吧。\n\n另外还有数据层，就叫它 AddressModel吧，放地址数据的。\n\n所以我们只需要4个文件就可以完成这个需求了。\n\n* AddressView 四级地址自定义View\n* AddressCell 顶部Cell\n* AddressSelectorCell 底部Cell\n* AddressModel 数据层\n\n## 3 AddressView 实现逻辑\n\n### 3.1 全局变量定义\n```Swift\nclass AddressView: UIView {\n    \n    typealias selectAddressBlock = (Array<RegionModel>)->()\n    var selectAddressHandle: selectAddressBlock?\n    var cancelAddressHandle: Handler?\n    \n    var modelArray: Array<Any> = []\n    var addressArray: Array<(key: Swift.String, value: Array<RegionModel>)> = []\n    var selectedIndex: Int = 0\n```\n这里定义一个闭包，就是用户勾选了4级地址后，需要将地址暴露个调用方，肯定需要一个方法发出去的。\n\ncancelAddressHandle是一个取消函数，主要处理用户点击蒙层或者点击取消的事件。\n\nmodelArray是记录顶部列表数据的数组。\n\naddressArray是记录底部列表数据的数组。\n\nselectedIndex是记录顶部选择了第几项的全局变量记录。\n\n然后是2个懒加载的UITableView，看下哈：\n```Swift\n/// 顶部视图列表\nprivate lazy var tblView: UITableView = {\n    let tableView = UITableView.init(frame: CGRect(x: 0, y: 196, width: ScreenWidth, height: ScreenHeight - 196), style: .grouped)\n    tableView.register(AddressCell.self, forCellReuseIdentifier: AddressCell.identifier)\n    tableView.delegate = self\n    tableView.dataSource = self\n    tableView.separatorStyle = .none\n    tableView.backgroundColor = .white\n    tableView.showsVerticalScrollIndicator = false\n    tableView.showsHorizontalScrollIndicator = false\n    tableView.isScrollEnabled = false\n    tableView.layer.cornerRadius = 14\n    tableView.layer.maskedCorners = [.layerMinXMinYCorner,.layerMaxXMinYCorner]\n    return tableView\n}()\n```\n\n还有一个底部的列表：\n```Swift\n/// 底部视图列表\nprivate lazy var addressTblView: UITableView = {\n    let tableView = UITableView.init(frame: CGRect.zero, style: .grouped)\n    tableView.register(AddressSelectorCell.self, forCellReuseIdentifier: AddressSelectorCell.identifier)\n    tableView.delegate = self\n    tableView.dataSource = self\n    tableView.backgroundColor = .white\n    tableView.separatorStyle = .none\n    tableView.showsVerticalScrollIndicator = false\n    tableView.showsHorizontalScrollIndicator = false\n    return tableView\n}()\n```\n虽然是两个UITableView，但可以共享同一个代理和数据源，需要在里面另外加if else判断下。\n\n### 3.2 生命周期函数\n这里只有一个初始化，但其实没有做什么，也没有把那两个UITableView加进去，这里应该就是空白的区域。\n```Swift\n  override init(frame: CGRect) {\n        super.init(frame: frame)\n        self.backgroundColor = UIColor.init(red: 0, green: 0, blue: 0, alpha: 0.6)\n    }\n    \n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n```\n\n### 3.3 初始化数据\n这里是另外提供的函数，来初始化，所以需要调用方额外调用这个方法。\n也正是这个方法，才会去加载ui的。\n\n```Swift\nfunc traverse(province: String, city: String, area: String, street: String){\n        modelArray.removeAll()\n        let dataArr: [RegionModel] = globalAddressModel?.data ?? AddressModel.init().data\n        self.recursive(dataArr: dataArr, province: province, city: city, area: area, street: street)\n        \n        if globalAddressModel != nil {\n            if modelArray.count == 0 {\n                /// 这里就展示省列表\n                self.setData(data: globalAddressModel!)\n            }else if modelArray.count == 4{\n                /// 这里展示街道列表\n                let model = modelArray[2]\n                self.setData(data: model)\n            } else{\n                /// 其它情况，就拿最后一个数据，在设置给底部内容tableView里面\n                let model = modelArray.last as! RegionModel\n                self.setData(data: model)\n            }\n        }\n        if modelArray.count < 4 {\n            modelArray.append(\"请选择\")\n        }\n        \n        /// 大概意思就是找到“请选择”在哪一个位置\n        selectedIndex = modelArray.firstIndex{$0 is String} ?? modelArray.count-1\n        /// 开始加载UI\n        self.loadUI()\n    }\n```\nglobalAddressModel 实际上再AppDelegate初始化的时候就去异步加载json文件了，这个应该就是保存的所有的四级地址信息了。\n\n然后这里用到了一个函数 recursive函数，是递归来寻找目标四级地址。\n```Swift\n/// 递归获取目标地址\nfunc recursive(dataArr: [RegionModel], province: String, city: String, area: String, street: String){\n    for model in dataArr{\n        if model.name.contains(province) ||\n            model.name.contains(city) ||\n            model.name.contains(area) ||\n            model.name.contains(street){\n            modelArray.append(model)\n            self.recursive(dataArr: model.children, province: province, city: city, area: area, street: street)\n            break\n        }\n    }\n}\n```\n找到后，会将实体append到这个数组中。\n\n然后上面初始化数据还用到一个函数：setData，作用是设置底部数据，因为这里底部自始至终都是同一个UITableView，会经常需要刷新数据。这里就是刷新底部数据的意思吧。\n\n看下这个setData函数哈：\n```Swift\nfunc setData(data: Any){\n        var dataArr: [RegionModel] = []\n        if data is AddressModel {\n            let tmpData = data as! AddressModel\n            dataArr = tmpData.data\n        }else{\n            let tmpData = data as! RegionModel\n            dataArr = tmpData.children\n        }\n        /// 上面的代码目的是为了拿到 RegionModel数组\n        \n        if dataArr.count == 0 {\n            return\n        }\n        \n        var tmpDic: Dictionary<String,Array<RegionModel>> = Dictionary<String,Array<RegionModel>>()\n        for model in dataArr{\n            var key: String = \"\"\n            key = self.findFirstLetterFromString(aString: model.name)\n            var arr = tmpDic[key] ?? Array<RegionModel>()\n            arr.append(model)\n            tmpDic[key] = arr\n        }\n        \n        //处理了第二个字首字母排序\n        _ = tmpDic.keys.compactMap{ key in\n            var tmpArr = tmpDic[key]!\n            tmpArr = tmpArr.sorted{(model1,model2) in\n                var key1 = \"\"\n                var key2 = \"\"\n                key1 = self.findFirstLetterFromString(aString: model1.name, isSecond: true)\n                key2 = self.findFirstLetterFromString(aString: model2.name, isSecond: true)\n                return key1 < key2\n            }\n            tmpDic[key] = tmpArr\n        }\n        addressArray = tmpDic.sorted{$0.key < $1.key}\n        \n        /// addressArray应该是拿到目前展示的内容区域数据 底部区域\n        self.addressTblView.reloadData()\n    }\n```\n这里代码虽然长，但实际上具体还是挺简单的，主要是生成一个字典的映射关系，key存放首字母，value存放同一个首字母下对应的地址列表。大概意思就是这个tmpDic是一个key value形式的map集合，key是这些比如省份首字母为G，那么value就对应广东省，甘肃省，广西，贵州省等下的所有地址。这里就对应tableView里面的每一组的数据了。然后处理下第二个首字母排序的问题。\n\n好的，这里打住了，回到第一个函数 traverse方法中，里面根据modelArray的长度去决定刷新哪一个列表，因为调用方给的地址不一定是四级，可能是1级或2级或3级，这里也是需要考虑到的。能在哪个层级搜索到，就定位到哪个层级，那么最后一个层级这里使用 append一个“请选择”，这里说明如果是字符串了，那么这里就是最后一层级。感觉这还可以优化下，比较用字符串来判断到哪一层级不太合适的。\n\ntraverse最后一个方法是加载UI。\n```Swift\nfunc loadUI(){\n        /// 先加顶部\n        self.addSubview(tblView)\n        /// 顶部布局\n        self.updateUI()\n        \n        /// 再加底部\n        self.addSubview(addressTblView)\n        /// 底部布局\n        addressTblView.snp.remakeConstraints{make in\n            make.leading.trailing.bottom.equalTo(0)\n            make.top.equalTo(tblView.snp.bottom).offset(0)\n        }\n    }\n\nfunc updateUI(){\n        tblView.snp.remakeConstraints{make in\n            make.leading.trailing.equalTo(0)\n            make.top.equalTo(196)\n            if modelArray.count == 1 {\n                make.height.equalTo(96)\n            }else{\n                make.height.equalTo(96+modelArray.count*48)\n            }\n        }\n        self.tblView.reloadData()\n    }\n```\n大概意思就是把那两个UITableView加给父View。\n\n然后需要用的扩展方法有下面这个：\n```Swift\nextension AddressView{\n    \n    /// 找到中文对应的第一个字符对应的第一个字母拼音\n    func findFirstLetterFromString(aString: String, isSecond : Bool = false) -> String {\n        //转变成可变字符串\n        let mutableString = NSMutableString.init(string: aString)\n        \n        //将中文转换成带声调的拼音\n        CFStringTransform(mutableString as CFMutableString, nil,      kCFStringTransformToLatin, false)\n        \n        //去掉声调\n        let pinyinString = mutableString.folding(options:          String.CompareOptions.diacriticInsensitive, locale:   NSLocale.current)\n        \n        //将拼音首字母换成大写\n        let strPinYin = polyphoneStringHandle(nameString: aString,    pinyinString: pinyinString).uppercased()\n        \n        //截取大写首字母\n        let arr = strPinYin.components(separatedBy: \" \")\n        let completeStr = isSecond == false ? arr[0] : arr[1]\n        let firstString = completeStr.subScript(index: 0, length: 1)\n        //判断首字母是否为大写\n        let regexA = \"^[A-Z]$\"\n        let predA = NSPredicate.init(format: \"SELF MATCHES %@\", regexA)\n        return predA.evaluate(with: firstString) ? firstString : \"#\"\n    }\n    \n    //多音字处理，根据需要添自行加\n    func polyphoneStringHandle(nameString: String, pinyinString: String) -> String {\n        //        if nameString.hasPrefix(\"长\") {return \"chang\"}\n        //        if nameString.hasPrefix(\"沈\") {return \"shen\"}\n        //        if nameString.hasPrefix(\"厦\") {return \"xia\"}\n        //        if nameString.hasPrefix(\"地\") {return \"di\"}\n        //        if nameString.hasPrefix(\"重\") {return \"chong\"}\n        return pinyinString\n    }\n}\n```\n这里主要是一个工具方法，内部使用，无需多讲。\n\n好了，前面的ui基本就这些。\n下面主要是讲解下UITableView的代理方法和数据源配置。\n\n```Swift\n/// 设置顶部tableView 代理和数据\nextension AddressView: UITableViewDelegate,UITableViewDataSource{\n    func numberOfSections(in tableView: UITableView) -> Int {\n        if tableView == tblView {\n            return 1    /// 顶部tableView只有一组\n        }else{\n            return addressArray.count   /// 很多组 26个字母都有的话，就26组\n        }\n    }\n```\n这里扩展AddressView，去实现UITableViewDelegate和UITableViewDataSource协议。\n这是第一个方法，numberOfSections，返回有多少组。这里因为顶部只有一种类型，也就只有一组，底部用了一个数组记录，组数就是数组的长度。\n\n```Swift\nfunc tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        if tableView == tblView {\n            /// 顶部，如果没有 历史地址，则为0，有则显示 一组多少个\n            if modelArray.count == 1 && (modelArray.last is String) {\n                return 0\n            }else{\n                return modelArray.count\n            }\n        }else{\n            /// 取当前组里面多少个\n            let dic = addressArray[section]\n            let arr = dic.value\n            return arr.count\n        }\n    }\n```\n这是第二个方法，numberOfRowsInSection，意思就是这个组下有多少行。\n\n```Swift\n func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n        /// 上面下面都是48\n        if tableView == tblView {\n            return 48\n        }else{\n            return 48\n        }\n    }\n```\n这里是每行的高度。\n\n```Swift\n/// 每个cell怎么显示\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    /// 如果是顶部\n    if tblView == tableView {\n        /// 顶部用AddressCell\n        let cell = tableView.dequeueReusableCell(withIdentifier: AddressCell.identifier, for: indexPath) as! AddressCell\n        let model = modelArray[indexPath.row]\n        /// 数据用modelArray里面的数据\n        cell.model = model\n        /// 选中的话，高亮显示文字颜色\n        if selectedIndex == indexPath.row {\n            cell.titleLb.textColor = UIColor.init(hex: \"#409EFF\")\n        }else{\n            cell.titleLb.textColor = UIColor.init(hex: \"#3B4058\")\n        }\n        /// 这里是请选择什么\n        if model is String {\n            cell.updateUI(indexPath: indexPath)\n        }\n        \n        /// 指示剂方向\n        if indexPath.row == 0 {\n            cell.position = .down // 第0行，只有下面的\n        }else if indexPath.row == modelArray.count-1{\n            cell.position = .top /// 最后一行，只有上面\n        }else{\n            cell.position = .middle /// 其它都有\n        }\n        \n        return cell\n    }else{\n        /// 如果是底部，数据取addressArray里面的\n        let dic = addressArray[indexPath.section]\n        let arr = dic.value\n        let model = arr[indexPath.row] // 这个字母类别里面的 第row行\n        \n        /// 这个cell用 AddressSelector来实现\n        let cell = tableView.dequeueReusableCell(withIdentifier: AddressSelectorCell.identifier, for: indexPath) as! AddressSelectorCell\n        \n        /// 第1行才有字母\n        if indexPath.row == 0 {\n            cell.indexLb.text = dic.key\n        }else{\n            cell.indexLb.text = \"\"\n        }\n        \n        /// 当前在那个层级 比如是广东省\n        let obj = modelArray[selectedIndex]\n        if obj is String { /// 请选择层级\n            cell.checkImgView.isHidden = true\n            cell.nameLb.textColor = UIColor.init(hex: \"#3B4058\")\n        }else{\n            /// 已选层级\n            let selectedModel = obj as! RegionModel\n            if selectedModel.name == model.name { /// 列表中的就是已选的，高亮一下\n                cell.nameLb.textColor = UIColor.init(hex: \"#409EFF\")\n                cell.checkImgView.isHidden = false\n            }else{\n                cell.nameLb.textColor = UIColor.init(hex: \"#3B4058\")\n                cell.checkImgView.isHidden = true\n            }\n        }\n        \n        ///  显示目标地址名称\n        cell.nameLb.text = model.name\n        return cell\n    }\n}\n```\n这个方法就比较关键了，就是每行怎么展现的。\n用哪个Cell，是否要高亮，指示剂怎么展示，这里有点像Android的adpter里面的bindAdapter实现逻辑。这里需要按照需求在item里面自行处理逻辑。\n\n如果是底部，就需要考虑是否显示字母，是否高亮这些了。\n\n```Swift\n/// 标题和单元格间隔\nfunc tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {\n    /// 顶部头部预留48dp显示标题“请选择所在地区”\n    if tableView == tblView {\n        return 48\n    }else{\n        return 0.01\n    }\n}\n```\n顶部预留高度，用来展示自己的标题。\n\n```Swift\n/// 和上面对应，预留48个dp怎么显示\nfunc tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {\n    if tableView == tblView {\n        let view = UIView.init(frame: CGRect.init(x: 0, y: 0, width: ScreenWidth, height: 48))\n        let label = UILabel.init()\n        label.font = .pingFangSemibold(size: 18)\n        label.textColor = UIColor.init(hex: \"#3B4058\")\n        label.text = \"请选择所在地区\"\n        \n        let closeBtn: UIButton = {\n            let btn = UIButton()\n            btn.setTitle(\"取消\", for: .normal)\n            btn.setTitleColor(UIColor.init(hex: \"#409EFF\"), for: .normal)\n            btn.titleLabel?.font = .pingFangRegular(size: 16)\n            btn.addTarget(self, action: #selector(actionForClose), for: .touchUpInside)\n            return btn\n        }()\n        \n        view.addSubview(label)\n        view.addSubview(closeBtn)\n        label.snp.makeConstraints{make in\n            make.centerY.equalTo(view)\n            make.centerX.equalTo(view)\n            make.width.equalTo(130)\n            make.height.equalTo(30)\n        }\n        closeBtn.snp.makeConstraints{make in\n            make.trailing.equalTo(-16)\n            make.centerY.equalTo(view)\n            make.width.equalTo(48)\n            make.height.equalTo(48)\n        }\n        return view\n    }else{\n        return UIView()\n    }\n}\n```\n标题和取消按钮显示逻辑。\n\n```Swift\n/// 单元格尾巴怎么显示\nfunc tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -> CGFloat {\n    /// 如果是顶部tableView，预留48个dp\n    if tableView == tblView {\n        return 48\n    }else{\n        return 0.01\n    }\n}\n```\n这里顶部有效，有48个单位长度，用来显示底部标题。\n\n```Swift\n/// 尾部显示 选择下级地址\nfunc tableView(_ tableView: UITableView, viewForFooterInSection section: Int) -> UIView? {\n    if tableView == tblView {\n        let view = UIView.init(frame: CGRect.init(x: 0, y: 0, width: ScreenWidth, height: 48))\n        \n        let lineView = UIView()\n        lineView.backgroundColor = UIColor.init(hex: \"#F6F6F6\")\n        let label = UILabel.init()\n        label.font = .pingFangSemibold(size: 16)\n        label.textColor = UIColor.init(hex: \"#3B4058\")\n        \n        if selectedIndex == 0 {\n            label.text = \"选择省份/地区\"\n        }else if selectedIndex == 1{\n            label.text = \"选择城市\"\n        }else if selectedIndex == 2{\n            label.text = \"选择区/县\"\n        }else{\n            label.text = \"选择街道/镇\"\n        }\n        \n        view.addSubview(lineView)\n        view.addSubview(label)\n        \n        lineView.snp.makeConstraints{make in\n            make.top.equalTo(4)\n            make.leading.trailing.equalTo(0)\n            make.height.equalTo(0.5)\n        }\n        label.snp.makeConstraints{make in\n            make.top.equalTo(16)\n            make.leading.equalTo(8)\n            make.width.equalTo(150)\n            make.height.equalTo(30)\n        }\n        return view\n    }else{\n        return UIView()\n    }\n}\n```\n这里就是确定底部标题的怎么显示的。\n\n```Swift\n/// 点击了单元格\nfunc tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n    if tblView == tableView {\n        /// 顶部点击了哪个单元格\n        if indexPath.row == 0 {\n            self.setData(data: globalAddressModel!)\n        }else{\n            let model = modelArray[indexPath.row-1]\n            self.setData(data: model)\n        }\n        selectedIndex = indexPath.row\n        /// 改变全局变量 selectedIndex，再去加载\n        self.tblView.reloadData()\n    }else{\n        /// 当前是哪一组\n        let dic = addressArray[indexPath.section]\n        let arr = dic.value\n        /// 当前是哪一行\n        let model = arr[indexPath.row]\n        \n        /// 请选择是第几个\n        let index = modelArray.firstIndex{$0 is String} ?? 0\n        /// 顶部是请选择\n        if modelArray[selectedIndex] is String && modelArray.count < 5{\n            /// 插入目标点击的地址 给modelArray\n            modelArray.insert(model, at: index)\n            if modelArray.count == 5 {\n                modelArray.removeLast()\n            }\n        }else{\n            /// 顶部不是请选择,而已已选择的地址\n            modelArray[selectedIndex] = model\n            /// 下面有请选择，需要清空之前选择的值\n            let isContain = modelArray.contains(where: {$0 is String})\n            if isContain {\n                for i in (selectedIndex+1 ... modelArray.count-1).reversed(){\n                    if modelArray[i] is String {\n                        continue\n                    }\n                    modelArray.remove(at: i)\n                }\n            } else if !isContain && selectedIndex != 3{\n                for i in (selectedIndex+1 ... modelArray.count-1).reversed(){\n                    modelArray.remove(at: i)\n                }\n            }\n            \n            if modelArray.count < 4 && !modelArray.contains(where: {$0 is String}){\n                modelArray.append(\"请选择\")\n            }\n        }\n        \n        /// 没有请选择了，会直接关闭弹框，执行回调\n        if modelArray.count == 4 && !modelArray.contains(where: {$0 is String}){\n            var arr: [RegionModel] = []\n            for model in modelArray {\n                let obj = model as! RegionModel\n                arr.append(obj)\n            }\n            selectAddressHandle?(arr)\n            self.removeFromSuperview()\n        }else{\n            /// 更新底部数据，以及顶部选择index\n            self.setData(data: model)\n            self.updateUI()\n            selectedIndex += 1\n        }\n    }\n}\n```\n上面的代码逻辑，主要就是处理点击顶部单元格，和底部单元格的逻辑。\n顶部点击会调用setData,会同步刷新底部。\n\n底部点击也会setData,刷新底部数据，如果全部选择，则会走闭包回调，将用户选择的四级地址回调出去。\n\n然后还有一些其它扩展方法，简单看下哈。\n```Swift\n/// 扩展给外部\nextension AddressView{\n    /// 通知调用者当有一个或者多个手指触摸到了视图或者窗口时触发此方法。\n    /// touches是UITouch的集合，通过UITouch我们可以检测触摸事件的属性，是单拍还是双拍，还有触摸的位置等。\n    /// 这里应该是触摸到蒙层后关闭弹框\n    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {\n        guard let point = touches.first?.location(in: self) else { return }\n        let p = self.layer.convert(point, from: self.layer)\n        if self.layer.contains(p) {\n            self.actionForClose()\n        }\n    }\n    \n    /// 移除自己，类似关闭弹框效果\n    @objc func actionForClose(){\n        cancelAddressHandle?()\n        self.removeFromSuperview()\n    }\n}\n```\n这里actionForClose是UiButton设置的一个action，上面哪个是覆写的官方方法，应该是触摸到蒙层自动关闭弹框。\n\n## 4 AddressCell 实现逻辑\n这个可以理解成Android中的Adapter了。也就是item怎么显示。\n```Swift\n/// 顶部cell\nclass AddressCell: UITableViewCell {\n    \n    enum LinePosition {\n        case down\n        case middle\n        case top\n    }\n    \n    static var identifier: String = \"AddressCell\"\n```\n这里需要继承UITableViewCell，必须要有一个identifier，这个主要是为了复用，因为列表可能会很长，为了合理复用，这里一般都需要一个标识符。\n\n### 4.1 子View定义\n```Swift\n /// 安徽省\nlazy var titleLb: UILabel = {\n    let label = UILabel()\n    label.font = .pingFangMedium(size: 16)\n    label.textColor = UIColor.init(hex: \"#3B4058\")\n    return label\n}()\n\n/// 实心圆\nlazy var roundView: UIView = {\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: \"#409EFF\")\n    view.layer.cornerRadius = 3.5\n    view.layer.borderWidth = 1\n    view.layer.borderColor = UIColor.init(hex: \"#409EFF\").cgColor\n    return view\n}()\n\n/// 圆上面的线条\nlazy private var toplineView: UIView = {\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: \"#409EFF\")\n    return view\n}()\n\n/// 圆下面的线条\nlazy private var downlineView: UIView = {\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: \"#409EFF\")\n    return view\n}()\n\n/// 右侧箭头\nlazy private var rightImgView: UIImageView = {\n    let imgView = UIImageView()\n    imgView.image = UIImage.init(named: \"客户信息_右箭头\")\n    return imgView\n}()\n```\n这里是顶部item用的一些零部件。\n比如上下线图，右侧箭头，中间文字。实心圆。\n这里变空心，实际上只是设置了中间颜色为纯白。\n\n### 4.2 数据定义\n```Swift\n/// 监听数据变化 数据填充\nvar model: Any?{\n    didSet{\n        guard let _model = model else{return}\n        if _model is RegionModel {\n            let tmp = _model as! RegionModel\n            titleLb.text = tmp.name\n        }\n    }\n}\n    \n/// 线条位置\nvar position: LinePosition?{\n    didSet{\n        guard let _position = position else{return}\n        /// 上面和下面的线条都先一出去\n        toplineView.removeFromSuperview()\n        downlineView.removeFromSuperview()\n        \n        /// 如果在下面 空心圆\n        if _position == .down {\n            contentView.addSubview(downlineView)\n            downlineView.snp.makeConstraints{make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(roundView.snp.top).offset(0)\n                make.bottom.equalTo(0)\n                make.width.equalTo(1)\n            }\n            roundView.backgroundColor = UIColor.init(hex: \"#409EFF\")\n        }else if _position == .top{\n            /// 如果在上面 空心圆\n            contentView.addSubview(toplineView)\n            toplineView.snp.makeConstraints{make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(0)\n                make.bottom.equalTo(roundView.snp.top)\n                make.width.equalTo(1)\n            }\n            if model is String {\n                roundView.backgroundColor = .white\n            }else{\n                roundView.backgroundColor = UIColor.init(hex: \"#409EFF\")\n            }\n        }else{\n            /// 都不在，也是都存在的意思\n            contentView.addSubview(toplineView)\n            contentView.addSubview(downlineView)\n            toplineView.snp.makeConstraints{make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(0)\n                make.bottom.equalTo(roundView.snp.top)\n                make.width.equalTo(1)\n            }\n            downlineView.snp.remakeConstraints{make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(roundView.snp.bottom)\n                make.bottom.equalTo(0)\n                make.width.equalTo(1)\n            }\n            roundView.backgroundColor = UIColor.init(hex: \"#409EFF\")\n        }\n    }\n}\n```\n这里定义了2个数据，1个是具体显示什么的数据，一个是线条怎么展示，什么时候展示实心和空心圆的逻辑。\n\n### 4.3 生命周期函数\n首先看下初始化。\n```Swift\noverride init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        \n        self.selectionStyle = .none\n        \n        /// 添加安徽省\n        contentView.addSubview(titleLb)\n        titleLb.snp.makeConstraints{make in\n            make.centerY.equalToSuperview()\n            make.leading.equalTo(roundView.snp.trailing).offset(22)\n            make.trailing.equalTo(rightImgView.snp.leading).offset(10)\n            make.height.equalTo(20)\n        }\n        \n        /// 添加圆形指示器\n        contentView.addSubview(roundView)\n        roundView.snp.makeConstraints{make in\n            make.centerY.equalToSuperview()\n            make.leading.equalTo(14)\n            make.width.equalTo(7)\n            make.height.equalTo(7)\n        }\n        \n        /// 添加右侧箭头\n        contentView.addSubview(rightImgView)\n        rightImgView.snp.makeConstraints{make in\n            make.centerY.equalToSuperview()\n            make.trailing.equalTo(-16)\n            make.width.equalTo(19)\n            make.height.equalTo(19)\n        }\n        \n    }\n    \n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n```\n这里就加了3个视图，并且布局了。\n\n### 4.4 其它扩展方法\n```Swift\nextension AddressCell{\n    func updateUI(indexPath: IndexPath){\n        if indexPath.row == 1 {\n            titleLb.text = \"请选择城市\"\n        }else if indexPath.row == 2 {\n            titleLb.text = \"请选择县\"\n        }else if indexPath.row == 3{\n            titleLb.text = \"请选街道\"\n        }else{\n            titleLb.text = \"\"//model as? String\n        }\n    }\n}\n```\n这里就是显示item特殊情况的文案。\n\n## 5 AddressSelectorCell 实现逻辑\n这里也同上面的Cell，有一个标识符。\n```Swift\n/// 底部Cell\nclass AddressSelectorCell: UITableViewCell {\n    \n    static var identifier: String = \"UITableViewCell\"\n```\n\n### 5.1 子View\n这里需要哪些子View呢？\n```Swift\n//索引 eg: A字母\nlazy var indexLb: UILabel = {\n    let label = UILabel()\n    label.font = .pingFangMedium(size: 12)\n    label.textColor = UIColor.init(hex: \"#9B9DA7\")\n    return label\n}()\n\n//名称 eg: 安徽省\nlazy var nameLb: UILabel = {\n    let label = UILabel()\n    label.font = .pingFangMedium(size: 14)\n    label.textColor = UIColor.init(hex: \"#3B4058\")\n    return label\n}()\n\n//勾选图标\nlazy var checkImgView: UIImageView = {\n    let imgView = UIImageView()\n    imgView.isHidden = true\n    imgView.image = UIImage.init(named: \"勾选\")\n    return imgView\n}()\n```\n这里非常简单，只有3个子视图，字母，中间名称，是否勾选。\n\n### 5.2 生命周期函数\n看下初始化吧。\n```Swift\noverride init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        self.selectionStyle = .none\n        \n        /// 添加索引，并且布局\n        contentView.addSubview(indexLb)\n        indexLb.snp.makeConstraints{make in\n            make.leading.equalTo(8)\n            make.centerY.equalToSuperview()\n            make.width.equalTo(10)\n            make.height.equalTo(20)\n        }\n        \n        /// 添加名称，并且位置确定\n        contentView.addSubview(nameLb)\n        nameLb.snp.makeConstraints{make in\n            make.leading.equalTo(indexLb.snp.trailing).offset(16)\n            make.trailing.equalTo(-16)\n            make.centerY.equalToSuperview()\n            make.height.equalTo(20)\n        }\n        \n        /// 确定勾选图标\n        contentView.addSubview(checkImgView)\n        checkImgView.snp.makeConstraints{make in\n            make.trailing.equalTo(-16)\n            make.centerY.equalToSuperview()\n            make.width.equalTo(16)\n            make.height.equalTo(16)\n        }\n    }\n    \n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n```\n也是非常简单，添加了3个子视图，并且确定位置了。\n\n## 6 AddressModel 实现逻辑\n这个是四级地址的数据模型，可以看下：\n```Swift\nimport Foundation\nimport HandyJSON\n\nclass AddressModel: HandyJSON {\n    var data: [RegionModel] = []\n    required init() {}\n}\n\nclass RegionModel: HandyJSON {\n    var code: String = \"\"\n    var name: String = \"\"\n    var children: [RegionModel] = []\n    required init() {}\n}\n```\n继承了HandyJSON，方便解析。\n这里AddressModel实际上内部也是由 RegionModel数组构成的。\n这个AddressModel用来存放省列表比较合适。\n\nRegionModel可以存放市，区，街道，都没问题。\n\n封装四级地址基本上就这些了。\n\n## 7 外部调用方式\n\n### 7.1 先声明一个四级地址View\n```Swift\nlazy private var addressView: AddressView = {\n        let tmpview = AddressView(frame: CGRect.init(x: 0, y: 0, width: ScreenWidth, height: ScreenHeight))\n        return tmpview\n    }()\n```\n这里设定了它的frame，也就是大小位置。\n\n### 7.2  弹出四级地址\n```Swift\nfunc showAddressSelector(){\n        self.view.addSubview(self.addressView)\n        self.addressView.traverse(province: self.orderAddressModel?.province ?? \"\", city: self.orderAddressModel?.city ?? \"\", area: self.orderAddressModel?.region ?? \"\", street: self.orderAddressModel?.street ?? \"\")\n        addressView.selectAddressHandle = {[weak self] (arr)in\n            guard let weakSelf = self else{return}\n            let pModel = arr[0]\n            let cModel = arr[1]\n            let aModel = arr[2]\n            let tModel = arr[3]\n            ...\n            \n        }\n    }\n```\n这里通过addSubview的方式，将这个四级地址添加到这个UIViewController的根布局上。类似叠加布局的方式。\n\n然后调用了一个关键的函数，traverse，将初始地址设置进去。\n\n然后设置了选择回调函数，这里用户选择了四级地址后，会回调到这个handle里面哦。\n\n## 8 总结\n\n* 做一个复杂的自定义View，一定要化繁为简，将复杂的结构一步一步拆分成一个一个基本视图，这样能够很好规划实现方案。\n\n* 任何一个自定义View实现方案可能会有多种，可以选择自己最熟悉的一种，然后进行研究，觉得不合适可以换其它方案来实现。\n\n* 四级地址最关键的应该是数据了，这里我们实现方案是单页面，数据同步刷新的方式，其实也可以考虑多页面，可自由切换，毕竟地址层级不会太多。\n\n* 需要考虑到用户之前填写的地址，可能只填了1到3级，所以一定要考虑全面一点，作为封装视图者，不能只考虑到最完美的情况。\n\n* 多个UITableView是可以共用同一个代理和数据源的，只需要再代理里面区分下是那个UITableView即可。\n\n* UITableView有很多代理协议，这里可以设置多个组类，一个组多少行，头部View，尾部View，头部高度，尾部高度，点击item，等多种方法，可以实现很复杂的逻辑。\n\n* UITableView的Cell一定要分配一个标识符，用来复用，增加程序稳定性。","slug":"iOS-swift-自定义View之四级地址","published":1,"updated":"2023-02-01T07:12:26.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlc01jg000xjhv7adrn5y1c","content":"<h2 id=\"1-需求分析\"><a href=\"#1-需求分析\" class=\"headerlink\" title=\"1 需求分析\"></a>1 需求分析</h2><p>目标是可以选择四级地址，什么是四级地址呢？省市区街道。类似淘宝买东西时，支付订单时需要填写收货地址，这里就需要构造一个四级地址弹框，让用户去选择。具体效果如下：<br><img src=%E5%9B%9B%E7%BA%A7%E5%9C%B0%E5%9D%80.gif></p>\n<p>这个我们可以单独将这个地址弹框单独封装一下，本身就是一个工具，很多地方可能会用的。<br>另外还需要提供传参，因为可能用户之前选择了某些地址，现在要更改，就需要跳转到已选择的四级地址，并且可以自己切换任何一个省市区，如果重新选择省，那么下级地址都需要清空；如果重新更新了市，那么下级清空，上级保留。<br>大概就是这样子。</p>\n<p>所以我们就可以将四级地址视图用一个UIView来实现。</p>\n<h2 id=\"2-控件结构\"><a href=\"#2-控件结构\" class=\"headerlink\" title=\"2 控件结构\"></a>2 控件结构</h2><p>首先我们分析下如何来完成这个需求，代码如何实现。<br>这里我们考虑将ui提供的四级地址，通过自定义View来实现。</p>\n<p>顶部有一个列表，就是记录用户已选地址，省市区街道。<br>底部也有一个列表，而且有分组，以地址的拼音首字母分组，组下也可能有会有不定行数的cell。</p>\n<p>这里我们就考虑 用两个UITableView来承载顶部和底部的列表。<br>两个UITableView都放在  AddressView 的自定义View里面吧。</p>\n<p>所以会多出两个Cell，一个是顶部Cell，就叫做AddressCell吧；一个是底部Cell，承载底部列表，就叫做AddressSelectorCell吧。</p>\n<p>另外还有数据层，就叫它 AddressModel吧，放地址数据的。</p>\n<p>所以我们只需要4个文件就可以完成这个需求了。</p>\n<ul>\n<li>AddressView 四级地址自定义View</li>\n<li>AddressCell 顶部Cell</li>\n<li>AddressSelectorCell 底部Cell</li>\n<li>AddressModel 数据层</li>\n</ul>\n<h2 id=\"3-AddressView-实现逻辑\"><a href=\"#3-AddressView-实现逻辑\" class=\"headerlink\" title=\"3 AddressView 实现逻辑\"></a>3 AddressView 实现逻辑</h2><h3 id=\"3-1-全局变量定义\"><a href=\"#3-1-全局变量定义\" class=\"headerlink\" title=\"3.1 全局变量定义\"></a>3.1 全局变量定义</h3><pre><code class=\"line-numbers language-Swift\">class AddressView: UIView &#123;\n    \n    typealias selectAddressBlock = (Array&lt;RegionModel&gt;)-&gt;()\n    var selectAddressHandle: selectAddressBlock?\n    var cancelAddressHandle: Handler?\n    \n    var modelArray: Array&lt;Any&gt; = []\n    var addressArray: Array&lt;(key: Swift.String, value: Array&lt;RegionModel&gt;)&gt; = []\n    var selectedIndex: Int = 0\n</code></pre>\n<p>这里定义一个闭包，就是用户勾选了4级地址后，需要将地址暴露个调用方，肯定需要一个方法发出去的。</p>\n<p>cancelAddressHandle是一个取消函数，主要处理用户点击蒙层或者点击取消的事件。</p>\n<p>modelArray是记录顶部列表数据的数组。</p>\n<p>addressArray是记录底部列表数据的数组。</p>\n<p>selectedIndex是记录顶部选择了第几项的全局变量记录。</p>\n<p>然后是2个懒加载的UITableView，看下哈：</p>\n<pre><code class=\"line-numbers language-Swift\">/// 顶部视图列表\nprivate lazy var tblView: UITableView = &#123;\n    let tableView = UITableView.init(frame: CGRect(x: 0, y: 196, width: ScreenWidth, height: ScreenHeight - 196), style: .grouped)\n    tableView.register(AddressCell.self, forCellReuseIdentifier: AddressCell.identifier)\n    tableView.delegate = self\n    tableView.dataSource = self\n    tableView.separatorStyle = .none\n    tableView.backgroundColor = .white\n    tableView.showsVerticalScrollIndicator = false\n    tableView.showsHorizontalScrollIndicator = false\n    tableView.isScrollEnabled = false\n    tableView.layer.cornerRadius = 14\n    tableView.layer.maskedCorners = [.layerMinXMinYCorner,.layerMaxXMinYCorner]\n    return tableView\n&#125;()\n</code></pre>\n<p>还有一个底部的列表：</p>\n<pre><code class=\"line-numbers language-Swift\">/// 底部视图列表\nprivate lazy var addressTblView: UITableView = &#123;\n    let tableView = UITableView.init(frame: CGRect.zero, style: .grouped)\n    tableView.register(AddressSelectorCell.self, forCellReuseIdentifier: AddressSelectorCell.identifier)\n    tableView.delegate = self\n    tableView.dataSource = self\n    tableView.backgroundColor = .white\n    tableView.separatorStyle = .none\n    tableView.showsVerticalScrollIndicator = false\n    tableView.showsHorizontalScrollIndicator = false\n    return tableView\n&#125;()\n</code></pre>\n<p>虽然是两个UITableView，但可以共享同一个代理和数据源，需要在里面另外加if else判断下。</p>\n<h3 id=\"3-2-生命周期函数\"><a href=\"#3-2-生命周期函数\" class=\"headerlink\" title=\"3.2 生命周期函数\"></a>3.2 生命周期函数</h3><p>这里只有一个初始化，但其实没有做什么，也没有把那两个UITableView加进去，这里应该就是空白的区域。</p>\n<pre><code class=\"line-numbers language-Swift\">  override init(frame: CGRect) &#123;\n        super.init(frame: frame)\n        self.backgroundColor = UIColor.init(red: 0, green: 0, blue: 0, alpha: 0.6)\n    &#125;\n    \n    required init?(coder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n</code></pre>\n<h3 id=\"3-3-初始化数据\"><a href=\"#3-3-初始化数据\" class=\"headerlink\" title=\"3.3 初始化数据\"></a>3.3 初始化数据</h3><p>这里是另外提供的函数，来初始化，所以需要调用方额外调用这个方法。<br>也正是这个方法，才会去加载ui的。</p>\n<pre><code class=\"line-numbers language-Swift\">func traverse(province: String, city: String, area: String, street: String)&#123;\n        modelArray.removeAll()\n        let dataArr: [RegionModel] = globalAddressModel?.data ?? AddressModel.init().data\n        self.recursive(dataArr: dataArr, province: province, city: city, area: area, street: street)\n        \n        if globalAddressModel != nil &#123;\n            if modelArray.count == 0 &#123;\n                /// 这里就展示省列表\n                self.setData(data: globalAddressModel!)\n            &#125;else if modelArray.count == 4&#123;\n                /// 这里展示街道列表\n                let model = modelArray[2]\n                self.setData(data: model)\n            &#125; else&#123;\n                /// 其它情况，就拿最后一个数据，在设置给底部内容tableView里面\n                let model = modelArray.last as! RegionModel\n                self.setData(data: model)\n            &#125;\n        &#125;\n        if modelArray.count &lt; 4 &#123;\n            modelArray.append(&quot;请选择&quot;)\n        &#125;\n        \n        /// 大概意思就是找到“请选择”在哪一个位置\n        selectedIndex = modelArray.firstIndex&#123;$0 is String&#125; ?? modelArray.count-1\n        /// 开始加载UI\n        self.loadUI()\n    &#125;\n</code></pre>\n<p>globalAddressModel 实际上再AppDelegate初始化的时候就去异步加载json文件了，这个应该就是保存的所有的四级地址信息了。</p>\n<p>然后这里用到了一个函数 recursive函数，是递归来寻找目标四级地址。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 递归获取目标地址\nfunc recursive(dataArr: [RegionModel], province: String, city: String, area: String, street: String)&#123;\n    for model in dataArr&#123;\n        if model.name.contains(province) ||\n            model.name.contains(city) ||\n            model.name.contains(area) ||\n            model.name.contains(street)&#123;\n            modelArray.append(model)\n            self.recursive(dataArr: model.children, province: province, city: city, area: area, street: street)\n            break\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>找到后，会将实体append到这个数组中。</p>\n<p>然后上面初始化数据还用到一个函数：setData，作用是设置底部数据，因为这里底部自始至终都是同一个UITableView，会经常需要刷新数据。这里就是刷新底部数据的意思吧。</p>\n<p>看下这个setData函数哈：</p>\n<pre><code class=\"line-numbers language-Swift\">func setData(data: Any)&#123;\n        var dataArr: [RegionModel] = []\n        if data is AddressModel &#123;\n            let tmpData = data as! AddressModel\n            dataArr = tmpData.data\n        &#125;else&#123;\n            let tmpData = data as! RegionModel\n            dataArr = tmpData.children\n        &#125;\n        /// 上面的代码目的是为了拿到 RegionModel数组\n        \n        if dataArr.count == 0 &#123;\n            return\n        &#125;\n        \n        var tmpDic: Dictionary&lt;String,Array&lt;RegionModel&gt;&gt; = Dictionary&lt;String,Array&lt;RegionModel&gt;&gt;()\n        for model in dataArr&#123;\n            var key: String = &quot;&quot;\n            key = self.findFirstLetterFromString(aString: model.name)\n            var arr = tmpDic[key] ?? Array&lt;RegionModel&gt;()\n            arr.append(model)\n            tmpDic[key] = arr\n        &#125;\n        \n        //处理了第二个字首字母排序\n        _ = tmpDic.keys.compactMap&#123; key in\n            var tmpArr = tmpDic[key]!\n            tmpArr = tmpArr.sorted&#123;(model1,model2) in\n                var key1 = &quot;&quot;\n                var key2 = &quot;&quot;\n                key1 = self.findFirstLetterFromString(aString: model1.name, isSecond: true)\n                key2 = self.findFirstLetterFromString(aString: model2.name, isSecond: true)\n                return key1 &lt; key2\n            &#125;\n            tmpDic[key] = tmpArr\n        &#125;\n        addressArray = tmpDic.sorted&#123;$0.key &lt; $1.key&#125;\n        \n        /// addressArray应该是拿到目前展示的内容区域数据 底部区域\n        self.addressTblView.reloadData()\n    &#125;\n</code></pre>\n<p>这里代码虽然长，但实际上具体还是挺简单的，主要是生成一个字典的映射关系，key存放首字母，value存放同一个首字母下对应的地址列表。大概意思就是这个tmpDic是一个key value形式的map集合，key是这些比如省份首字母为G，那么value就对应广东省，甘肃省，广西，贵州省等下的所有地址。这里就对应tableView里面的每一组的数据了。然后处理下第二个首字母排序的问题。</p>\n<p>好的，这里打住了，回到第一个函数 traverse方法中，里面根据modelArray的长度去决定刷新哪一个列表，因为调用方给的地址不一定是四级，可能是1级或2级或3级，这里也是需要考虑到的。能在哪个层级搜索到，就定位到哪个层级，那么最后一个层级这里使用 append一个“请选择”，这里说明如果是字符串了，那么这里就是最后一层级。感觉这还可以优化下，比较用字符串来判断到哪一层级不太合适的。</p>\n<p>traverse最后一个方法是加载UI。</p>\n<pre><code class=\"line-numbers language-Swift\">func loadUI()&#123;\n        /// 先加顶部\n        self.addSubview(tblView)\n        /// 顶部布局\n        self.updateUI()\n        \n        /// 再加底部\n        self.addSubview(addressTblView)\n        /// 底部布局\n        addressTblView.snp.remakeConstraints&#123;make in\n            make.leading.trailing.bottom.equalTo(0)\n            make.top.equalTo(tblView.snp.bottom).offset(0)\n        &#125;\n    &#125;\n\nfunc updateUI()&#123;\n        tblView.snp.remakeConstraints&#123;make in\n            make.leading.trailing.equalTo(0)\n            make.top.equalTo(196)\n            if modelArray.count == 1 &#123;\n                make.height.equalTo(96)\n            &#125;else&#123;\n                make.height.equalTo(96+modelArray.count*48)\n            &#125;\n        &#125;\n        self.tblView.reloadData()\n    &#125;\n</code></pre>\n<p>大概意思就是把那两个UITableView加给父View。</p>\n<p>然后需要用的扩展方法有下面这个：</p>\n<pre><code class=\"line-numbers language-Swift\">extension AddressView&#123;\n    \n    /// 找到中文对应的第一个字符对应的第一个字母拼音\n    func findFirstLetterFromString(aString: String, isSecond : Bool = false) -&gt; String &#123;\n        //转变成可变字符串\n        let mutableString = NSMutableString.init(string: aString)\n        \n        //将中文转换成带声调的拼音\n        CFStringTransform(mutableString as CFMutableString, nil,      kCFStringTransformToLatin, false)\n        \n        //去掉声调\n        let pinyinString = mutableString.folding(options:          String.CompareOptions.diacriticInsensitive, locale:   NSLocale.current)\n        \n        //将拼音首字母换成大写\n        let strPinYin = polyphoneStringHandle(nameString: aString,    pinyinString: pinyinString).uppercased()\n        \n        //截取大写首字母\n        let arr = strPinYin.components(separatedBy: &quot; &quot;)\n        let completeStr = isSecond == false ? arr[0] : arr[1]\n        let firstString = completeStr.subScript(index: 0, length: 1)\n        //判断首字母是否为大写\n        let regexA = &quot;^[A-Z]$&quot;\n        let predA = NSPredicate.init(format: &quot;SELF MATCHES %@&quot;, regexA)\n        return predA.evaluate(with: firstString) ? firstString : &quot;#&quot;\n    &#125;\n    \n    //多音字处理，根据需要添自行加\n    func polyphoneStringHandle(nameString: String, pinyinString: String) -&gt; String &#123;\n        //        if nameString.hasPrefix(&quot;长&quot;) &#123;return &quot;chang&quot;&#125;\n        //        if nameString.hasPrefix(&quot;沈&quot;) &#123;return &quot;shen&quot;&#125;\n        //        if nameString.hasPrefix(&quot;厦&quot;) &#123;return &quot;xia&quot;&#125;\n        //        if nameString.hasPrefix(&quot;地&quot;) &#123;return &quot;di&quot;&#125;\n        //        if nameString.hasPrefix(&quot;重&quot;) &#123;return &quot;chong&quot;&#125;\n        return pinyinString\n    &#125;\n&#125;\n</code></pre>\n<p>这里主要是一个工具方法，内部使用，无需多讲。</p>\n<p>好了，前面的ui基本就这些。<br>下面主要是讲解下UITableView的代理方法和数据源配置。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 设置顶部tableView 代理和数据\nextension AddressView: UITableViewDelegate,UITableViewDataSource&#123;\n    func numberOfSections(in tableView: UITableView) -&gt; Int &#123;\n        if tableView == tblView &#123;\n            return 1    /// 顶部tableView只有一组\n        &#125;else&#123;\n            return addressArray.count   /// 很多组 26个字母都有的话，就26组\n        &#125;\n    &#125;\n</code></pre>\n<p>这里扩展AddressView，去实现UITableViewDelegate和UITableViewDataSource协议。<br>这是第一个方法，numberOfSections，返回有多少组。这里因为顶部只有一种类型，也就只有一组，底部用了一个数组记录，组数就是数组的长度。</p>\n<pre><code class=\"line-numbers language-Swift\">func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n        if tableView == tblView &#123;\n            /// 顶部，如果没有 历史地址，则为0，有则显示 一组多少个\n            if modelArray.count == 1 &amp;&amp; (modelArray.last is String) &#123;\n                return 0\n            &#125;else&#123;\n                return modelArray.count\n            &#125;\n        &#125;else&#123;\n            /// 取当前组里面多少个\n            let dic = addressArray[section]\n            let arr = dic.value\n            return arr.count\n        &#125;\n    &#125;\n</code></pre>\n<p>这是第二个方法，numberOfRowsInSection，意思就是这个组下有多少行。</p>\n<pre><code class=\"line-numbers language-Swift\"> func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n        /// 上面下面都是48\n        if tableView == tblView &#123;\n            return 48\n        &#125;else&#123;\n            return 48\n        &#125;\n    &#125;\n</code></pre>\n<p>这里是每行的高度。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 每个cell怎么显示\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n    /// 如果是顶部\n    if tblView == tableView &#123;\n        /// 顶部用AddressCell\n        let cell = tableView.dequeueReusableCell(withIdentifier: AddressCell.identifier, for: indexPath) as! AddressCell\n        let model = modelArray[indexPath.row]\n        /// 数据用modelArray里面的数据\n        cell.model = model\n        /// 选中的话，高亮显示文字颜色\n        if selectedIndex == indexPath.row &#123;\n            cell.titleLb.textColor = UIColor.init(hex: &quot;#409EFF&quot;)\n        &#125;else&#123;\n            cell.titleLb.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n        &#125;\n        /// 这里是请选择什么\n        if model is String &#123;\n            cell.updateUI(indexPath: indexPath)\n        &#125;\n        \n        /// 指示剂方向\n        if indexPath.row == 0 &#123;\n            cell.position = .down // 第0行，只有下面的\n        &#125;else if indexPath.row == modelArray.count-1&#123;\n            cell.position = .top /// 最后一行，只有上面\n        &#125;else&#123;\n            cell.position = .middle /// 其它都有\n        &#125;\n        \n        return cell\n    &#125;else&#123;\n        /// 如果是底部，数据取addressArray里面的\n        let dic = addressArray[indexPath.section]\n        let arr = dic.value\n        let model = arr[indexPath.row] // 这个字母类别里面的 第row行\n        \n        /// 这个cell用 AddressSelector来实现\n        let cell = tableView.dequeueReusableCell(withIdentifier: AddressSelectorCell.identifier, for: indexPath) as! AddressSelectorCell\n        \n        /// 第1行才有字母\n        if indexPath.row == 0 &#123;\n            cell.indexLb.text = dic.key\n        &#125;else&#123;\n            cell.indexLb.text = &quot;&quot;\n        &#125;\n        \n        /// 当前在那个层级 比如是广东省\n        let obj = modelArray[selectedIndex]\n        if obj is String &#123; /// 请选择层级\n            cell.checkImgView.isHidden = true\n            cell.nameLb.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n        &#125;else&#123;\n            /// 已选层级\n            let selectedModel = obj as! RegionModel\n            if selectedModel.name == model.name &#123; /// 列表中的就是已选的，高亮一下\n                cell.nameLb.textColor = UIColor.init(hex: &quot;#409EFF&quot;)\n                cell.checkImgView.isHidden = false\n            &#125;else&#123;\n                cell.nameLb.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n                cell.checkImgView.isHidden = true\n            &#125;\n        &#125;\n        \n        ///  显示目标地址名称\n        cell.nameLb.text = model.name\n        return cell\n    &#125;\n&#125;\n</code></pre>\n<p>这个方法就比较关键了，就是每行怎么展现的。<br>用哪个Cell，是否要高亮，指示剂怎么展示，这里有点像Android的adpter里面的bindAdapter实现逻辑。这里需要按照需求在item里面自行处理逻辑。</p>\n<p>如果是底部，就需要考虑是否显示字母，是否高亮这些了。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 标题和单元格间隔\nfunc tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat &#123;\n    /// 顶部头部预留48dp显示标题“请选择所在地区”\n    if tableView == tblView &#123;\n        return 48\n    &#125;else&#123;\n        return 0.01\n    &#125;\n&#125;\n</code></pre>\n<p>顶部预留高度，用来展示自己的标题。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 和上面对应，预留48个dp怎么显示\nfunc tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -&gt; UIView? &#123;\n    if tableView == tblView &#123;\n        let view = UIView.init(frame: CGRect.init(x: 0, y: 0, width: ScreenWidth, height: 48))\n        let label = UILabel.init()\n        label.font = .pingFangSemibold(size: 18)\n        label.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n        label.text = &quot;请选择所在地区&quot;\n        \n        let closeBtn: UIButton = &#123;\n            let btn = UIButton()\n            btn.setTitle(&quot;取消&quot;, for: .normal)\n            btn.setTitleColor(UIColor.init(hex: &quot;#409EFF&quot;), for: .normal)\n            btn.titleLabel?.font = .pingFangRegular(size: 16)\n            btn.addTarget(self, action: #selector(actionForClose), for: .touchUpInside)\n            return btn\n        &#125;()\n        \n        view.addSubview(label)\n        view.addSubview(closeBtn)\n        label.snp.makeConstraints&#123;make in\n            make.centerY.equalTo(view)\n            make.centerX.equalTo(view)\n            make.width.equalTo(130)\n            make.height.equalTo(30)\n        &#125;\n        closeBtn.snp.makeConstraints&#123;make in\n            make.trailing.equalTo(-16)\n            make.centerY.equalTo(view)\n            make.width.equalTo(48)\n            make.height.equalTo(48)\n        &#125;\n        return view\n    &#125;else&#123;\n        return UIView()\n    &#125;\n&#125;\n</code></pre>\n<p>标题和取消按钮显示逻辑。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 单元格尾巴怎么显示\nfunc tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -&gt; CGFloat &#123;\n    /// 如果是顶部tableView，预留48个dp\n    if tableView == tblView &#123;\n        return 48\n    &#125;else&#123;\n        return 0.01\n    &#125;\n&#125;\n</code></pre>\n<p>这里顶部有效，有48个单位长度，用来显示底部标题。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 尾部显示 选择下级地址\nfunc tableView(_ tableView: UITableView, viewForFooterInSection section: Int) -&gt; UIView? &#123;\n    if tableView == tblView &#123;\n        let view = UIView.init(frame: CGRect.init(x: 0, y: 0, width: ScreenWidth, height: 48))\n        \n        let lineView = UIView()\n        lineView.backgroundColor = UIColor.init(hex: &quot;#F6F6F6&quot;)\n        let label = UILabel.init()\n        label.font = .pingFangSemibold(size: 16)\n        label.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n        \n        if selectedIndex == 0 &#123;\n            label.text = &quot;选择省份/地区&quot;\n        &#125;else if selectedIndex == 1&#123;\n            label.text = &quot;选择城市&quot;\n        &#125;else if selectedIndex == 2&#123;\n            label.text = &quot;选择区/县&quot;\n        &#125;else&#123;\n            label.text = &quot;选择街道/镇&quot;\n        &#125;\n        \n        view.addSubview(lineView)\n        view.addSubview(label)\n        \n        lineView.snp.makeConstraints&#123;make in\n            make.top.equalTo(4)\n            make.leading.trailing.equalTo(0)\n            make.height.equalTo(0.5)\n        &#125;\n        label.snp.makeConstraints&#123;make in\n            make.top.equalTo(16)\n            make.leading.equalTo(8)\n            make.width.equalTo(150)\n            make.height.equalTo(30)\n        &#125;\n        return view\n    &#125;else&#123;\n        return UIView()\n    &#125;\n&#125;\n</code></pre>\n<p>这里就是确定底部标题的怎么显示的。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 点击了单元格\nfunc tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123;\n    if tblView == tableView &#123;\n        /// 顶部点击了哪个单元格\n        if indexPath.row == 0 &#123;\n            self.setData(data: globalAddressModel!)\n        &#125;else&#123;\n            let model = modelArray[indexPath.row-1]\n            self.setData(data: model)\n        &#125;\n        selectedIndex = indexPath.row\n        /// 改变全局变量 selectedIndex，再去加载\n        self.tblView.reloadData()\n    &#125;else&#123;\n        /// 当前是哪一组\n        let dic = addressArray[indexPath.section]\n        let arr = dic.value\n        /// 当前是哪一行\n        let model = arr[indexPath.row]\n        \n        /// 请选择是第几个\n        let index = modelArray.firstIndex&#123;$0 is String&#125; ?? 0\n        /// 顶部是请选择\n        if modelArray[selectedIndex] is String &amp;&amp; modelArray.count &lt; 5&#123;\n            /// 插入目标点击的地址 给modelArray\n            modelArray.insert(model, at: index)\n            if modelArray.count == 5 &#123;\n                modelArray.removeLast()\n            &#125;\n        &#125;else&#123;\n            /// 顶部不是请选择,而已已选择的地址\n            modelArray[selectedIndex] = model\n            /// 下面有请选择，需要清空之前选择的值\n            let isContain = modelArray.contains(where: &#123;$0 is String&#125;)\n            if isContain &#123;\n                for i in (selectedIndex+1 ... modelArray.count-1).reversed()&#123;\n                    if modelArray[i] is String &#123;\n                        continue\n                    &#125;\n                    modelArray.remove(at: i)\n                &#125;\n            &#125; else if !isContain &amp;&amp; selectedIndex != 3&#123;\n                for i in (selectedIndex+1 ... modelArray.count-1).reversed()&#123;\n                    modelArray.remove(at: i)\n                &#125;\n            &#125;\n            \n            if modelArray.count &lt; 4 &amp;&amp; !modelArray.contains(where: &#123;$0 is String&#125;)&#123;\n                modelArray.append(&quot;请选择&quot;)\n            &#125;\n        &#125;\n        \n        /// 没有请选择了，会直接关闭弹框，执行回调\n        if modelArray.count == 4 &amp;&amp; !modelArray.contains(where: &#123;$0 is String&#125;)&#123;\n            var arr: [RegionModel] = []\n            for model in modelArray &#123;\n                let obj = model as! RegionModel\n                arr.append(obj)\n            &#125;\n            selectAddressHandle?(arr)\n            self.removeFromSuperview()\n        &#125;else&#123;\n            /// 更新底部数据，以及顶部选择index\n            self.setData(data: model)\n            self.updateUI()\n            selectedIndex += 1\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>上面的代码逻辑，主要就是处理点击顶部单元格，和底部单元格的逻辑。<br>顶部点击会调用setData,会同步刷新底部。</p>\n<p>底部点击也会setData,刷新底部数据，如果全部选择，则会走闭包回调，将用户选择的四级地址回调出去。</p>\n<p>然后还有一些其它扩展方法，简单看下哈。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 扩展给外部\nextension AddressView&#123;\n    /// 通知调用者当有一个或者多个手指触摸到了视图或者窗口时触发此方法。\n    /// touches是UITouch的集合，通过UITouch我们可以检测触摸事件的属性，是单拍还是双拍，还有触摸的位置等。\n    /// 这里应该是触摸到蒙层后关闭弹框\n    override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123;\n        guard let point = touches.first?.location(in: self) else &#123; return &#125;\n        let p = self.layer.convert(point, from: self.layer)\n        if self.layer.contains(p) &#123;\n            self.actionForClose()\n        &#125;\n    &#125;\n    \n    /// 移除自己，类似关闭弹框效果\n    @objc func actionForClose()&#123;\n        cancelAddressHandle?()\n        self.removeFromSuperview()\n    &#125;\n&#125;\n</code></pre>\n<p>这里actionForClose是UiButton设置的一个action，上面哪个是覆写的官方方法，应该是触摸到蒙层自动关闭弹框。</p>\n<h2 id=\"4-AddressCell-实现逻辑\"><a href=\"#4-AddressCell-实现逻辑\" class=\"headerlink\" title=\"4 AddressCell 实现逻辑\"></a>4 AddressCell 实现逻辑</h2><p>这个可以理解成Android中的Adapter了。也就是item怎么显示。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 顶部cell\nclass AddressCell: UITableViewCell &#123;\n    \n    enum LinePosition &#123;\n        case down\n        case middle\n        case top\n    &#125;\n    \n    static var identifier: String = &quot;AddressCell&quot;\n</code></pre>\n<p>这里需要继承UITableViewCell，必须要有一个identifier，这个主要是为了复用，因为列表可能会很长，为了合理复用，这里一般都需要一个标识符。</p>\n<h3 id=\"4-1-子View定义\"><a href=\"#4-1-子View定义\" class=\"headerlink\" title=\"4.1 子View定义\"></a>4.1 子View定义</h3><pre><code class=\"line-numbers language-Swift\"> /// 安徽省\nlazy var titleLb: UILabel = &#123;\n    let label = UILabel()\n    label.font = .pingFangMedium(size: 16)\n    label.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n    return label\n&#125;()\n\n/// 实心圆\nlazy var roundView: UIView = &#123;\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n    view.layer.cornerRadius = 3.5\n    view.layer.borderWidth = 1\n    view.layer.borderColor = UIColor.init(hex: &quot;#409EFF&quot;).cgColor\n    return view\n&#125;()\n\n/// 圆上面的线条\nlazy private var toplineView: UIView = &#123;\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n    return view\n&#125;()\n\n/// 圆下面的线条\nlazy private var downlineView: UIView = &#123;\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n    return view\n&#125;()\n\n/// 右侧箭头\nlazy private var rightImgView: UIImageView = &#123;\n    let imgView = UIImageView()\n    imgView.image = UIImage.init(named: &quot;客户信息_右箭头&quot;)\n    return imgView\n&#125;()\n</code></pre>\n<p>这里是顶部item用的一些零部件。<br>比如上下线图，右侧箭头，中间文字。实心圆。<br>这里变空心，实际上只是设置了中间颜色为纯白。</p>\n<h3 id=\"4-2-数据定义\"><a href=\"#4-2-数据定义\" class=\"headerlink\" title=\"4.2 数据定义\"></a>4.2 数据定义</h3><pre><code class=\"line-numbers language-Swift\">/// 监听数据变化 数据填充\nvar model: Any?&#123;\n    didSet&#123;\n        guard let _model = model else&#123;return&#125;\n        if _model is RegionModel &#123;\n            let tmp = _model as! RegionModel\n            titleLb.text = tmp.name\n        &#125;\n    &#125;\n&#125;\n    \n/// 线条位置\nvar position: LinePosition?&#123;\n    didSet&#123;\n        guard let _position = position else&#123;return&#125;\n        /// 上面和下面的线条都先一出去\n        toplineView.removeFromSuperview()\n        downlineView.removeFromSuperview()\n        \n        /// 如果在下面 空心圆\n        if _position == .down &#123;\n            contentView.addSubview(downlineView)\n            downlineView.snp.makeConstraints&#123;make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(roundView.snp.top).offset(0)\n                make.bottom.equalTo(0)\n                make.width.equalTo(1)\n            &#125;\n            roundView.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n        &#125;else if _position == .top&#123;\n            /// 如果在上面 空心圆\n            contentView.addSubview(toplineView)\n            toplineView.snp.makeConstraints&#123;make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(0)\n                make.bottom.equalTo(roundView.snp.top)\n                make.width.equalTo(1)\n            &#125;\n            if model is String &#123;\n                roundView.backgroundColor = .white\n            &#125;else&#123;\n                roundView.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n            &#125;\n        &#125;else&#123;\n            /// 都不在，也是都存在的意思\n            contentView.addSubview(toplineView)\n            contentView.addSubview(downlineView)\n            toplineView.snp.makeConstraints&#123;make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(0)\n                make.bottom.equalTo(roundView.snp.top)\n                make.width.equalTo(1)\n            &#125;\n            downlineView.snp.remakeConstraints&#123;make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(roundView.snp.bottom)\n                make.bottom.equalTo(0)\n                make.width.equalTo(1)\n            &#125;\n            roundView.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里定义了2个数据，1个是具体显示什么的数据，一个是线条怎么展示，什么时候展示实心和空心圆的逻辑。</p>\n<h3 id=\"4-3-生命周期函数\"><a href=\"#4-3-生命周期函数\" class=\"headerlink\" title=\"4.3 生命周期函数\"></a>4.3 生命周期函数</h3><p>首先看下初始化。</p>\n<pre><code class=\"line-numbers language-Swift\">override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) &#123;\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        \n        self.selectionStyle = .none\n        \n        /// 添加安徽省\n        contentView.addSubview(titleLb)\n        titleLb.snp.makeConstraints&#123;make in\n            make.centerY.equalToSuperview()\n            make.leading.equalTo(roundView.snp.trailing).offset(22)\n            make.trailing.equalTo(rightImgView.snp.leading).offset(10)\n            make.height.equalTo(20)\n        &#125;\n        \n        /// 添加圆形指示器\n        contentView.addSubview(roundView)\n        roundView.snp.makeConstraints&#123;make in\n            make.centerY.equalToSuperview()\n            make.leading.equalTo(14)\n            make.width.equalTo(7)\n            make.height.equalTo(7)\n        &#125;\n        \n        /// 添加右侧箭头\n        contentView.addSubview(rightImgView)\n        rightImgView.snp.makeConstraints&#123;make in\n            make.centerY.equalToSuperview()\n            make.trailing.equalTo(-16)\n            make.width.equalTo(19)\n            make.height.equalTo(19)\n        &#125;\n        \n    &#125;\n    \n    required init?(coder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n</code></pre>\n<p>这里就加了3个视图，并且布局了。</p>\n<h3 id=\"4-4-其它扩展方法\"><a href=\"#4-4-其它扩展方法\" class=\"headerlink\" title=\"4.4 其它扩展方法\"></a>4.4 其它扩展方法</h3><pre><code class=\"line-numbers language-Swift\">extension AddressCell&#123;\n    func updateUI(indexPath: IndexPath)&#123;\n        if indexPath.row == 1 &#123;\n            titleLb.text = &quot;请选择城市&quot;\n        &#125;else if indexPath.row == 2 &#123;\n            titleLb.text = &quot;请选择县&quot;\n        &#125;else if indexPath.row == 3&#123;\n            titleLb.text = &quot;请选街道&quot;\n        &#125;else&#123;\n            titleLb.text = &quot;&quot;//model as? String\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里就是显示item特殊情况的文案。</p>\n<h2 id=\"5-AddressSelectorCell-实现逻辑\"><a href=\"#5-AddressSelectorCell-实现逻辑\" class=\"headerlink\" title=\"5 AddressSelectorCell 实现逻辑\"></a>5 AddressSelectorCell 实现逻辑</h2><p>这里也同上面的Cell，有一个标识符。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 底部Cell\nclass AddressSelectorCell: UITableViewCell &#123;\n    \n    static var identifier: String = &quot;UITableViewCell&quot;\n</code></pre>\n<h3 id=\"5-1-子View\"><a href=\"#5-1-子View\" class=\"headerlink\" title=\"5.1 子View\"></a>5.1 子View</h3><p>这里需要哪些子View呢？</p>\n<pre><code class=\"line-numbers language-Swift\">//索引 eg: A字母\nlazy var indexLb: UILabel = &#123;\n    let label = UILabel()\n    label.font = .pingFangMedium(size: 12)\n    label.textColor = UIColor.init(hex: &quot;#9B9DA7&quot;)\n    return label\n&#125;()\n\n//名称 eg: 安徽省\nlazy var nameLb: UILabel = &#123;\n    let label = UILabel()\n    label.font = .pingFangMedium(size: 14)\n    label.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n    return label\n&#125;()\n\n//勾选图标\nlazy var checkImgView: UIImageView = &#123;\n    let imgView = UIImageView()\n    imgView.isHidden = true\n    imgView.image = UIImage.init(named: &quot;勾选&quot;)\n    return imgView\n&#125;()\n</code></pre>\n<p>这里非常简单，只有3个子视图，字母，中间名称，是否勾选。</p>\n<h3 id=\"5-2-生命周期函数\"><a href=\"#5-2-生命周期函数\" class=\"headerlink\" title=\"5.2 生命周期函数\"></a>5.2 生命周期函数</h3><p>看下初始化吧。</p>\n<pre><code class=\"line-numbers language-Swift\">override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) &#123;\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        self.selectionStyle = .none\n        \n        /// 添加索引，并且布局\n        contentView.addSubview(indexLb)\n        indexLb.snp.makeConstraints&#123;make in\n            make.leading.equalTo(8)\n            make.centerY.equalToSuperview()\n            make.width.equalTo(10)\n            make.height.equalTo(20)\n        &#125;\n        \n        /// 添加名称，并且位置确定\n        contentView.addSubview(nameLb)\n        nameLb.snp.makeConstraints&#123;make in\n            make.leading.equalTo(indexLb.snp.trailing).offset(16)\n            make.trailing.equalTo(-16)\n            make.centerY.equalToSuperview()\n            make.height.equalTo(20)\n        &#125;\n        \n        /// 确定勾选图标\n        contentView.addSubview(checkImgView)\n        checkImgView.snp.makeConstraints&#123;make in\n            make.trailing.equalTo(-16)\n            make.centerY.equalToSuperview()\n            make.width.equalTo(16)\n            make.height.equalTo(16)\n        &#125;\n    &#125;\n    \n    required init?(coder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n</code></pre>\n<p>也是非常简单，添加了3个子视图，并且确定位置了。</p>\n<h2 id=\"6-AddressModel-实现逻辑\"><a href=\"#6-AddressModel-实现逻辑\" class=\"headerlink\" title=\"6 AddressModel 实现逻辑\"></a>6 AddressModel 实现逻辑</h2><p>这个是四级地址的数据模型，可以看下：</p>\n<pre><code class=\"line-numbers language-Swift\">import Foundation\nimport HandyJSON\n\nclass AddressModel: HandyJSON &#123;\n    var data: [RegionModel] = []\n    required init() &#123;&#125;\n&#125;\n\nclass RegionModel: HandyJSON &#123;\n    var code: String = &quot;&quot;\n    var name: String = &quot;&quot;\n    var children: [RegionModel] = []\n    required init() &#123;&#125;\n&#125;\n</code></pre>\n<p>继承了HandyJSON，方便解析。<br>这里AddressModel实际上内部也是由 RegionModel数组构成的。<br>这个AddressModel用来存放省列表比较合适。</p>\n<p>RegionModel可以存放市，区，街道，都没问题。</p>\n<p>封装四级地址基本上就这些了。</p>\n<h2 id=\"7-外部调用方式\"><a href=\"#7-外部调用方式\" class=\"headerlink\" title=\"7 外部调用方式\"></a>7 外部调用方式</h2><h3 id=\"7-1-先声明一个四级地址View\"><a href=\"#7-1-先声明一个四级地址View\" class=\"headerlink\" title=\"7.1 先声明一个四级地址View\"></a>7.1 先声明一个四级地址View</h3><pre><code class=\"line-numbers language-Swift\">lazy private var addressView: AddressView = &#123;\n        let tmpview = AddressView(frame: CGRect.init(x: 0, y: 0, width: ScreenWidth, height: ScreenHeight))\n        return tmpview\n    &#125;()\n</code></pre>\n<p>这里设定了它的frame，也就是大小位置。</p>\n<h3 id=\"7-2-弹出四级地址\"><a href=\"#7-2-弹出四级地址\" class=\"headerlink\" title=\"7.2  弹出四级地址\"></a>7.2  弹出四级地址</h3><pre><code class=\"line-numbers language-Swift\">func showAddressSelector()&#123;\n        self.view.addSubview(self.addressView)\n        self.addressView.traverse(province: self.orderAddressModel?.province ?? &quot;&quot;, city: self.orderAddressModel?.city ?? &quot;&quot;, area: self.orderAddressModel?.region ?? &quot;&quot;, street: self.orderAddressModel?.street ?? &quot;&quot;)\n        addressView.selectAddressHandle = &#123;[weak self] (arr)in\n            guard let weakSelf = self else&#123;return&#125;\n            let pModel = arr[0]\n            let cModel = arr[1]\n            let aModel = arr[2]\n            let tModel = arr[3]\n            ...\n            \n        &#125;\n    &#125;\n</code></pre>\n<p>这里通过addSubview的方式，将这个四级地址添加到这个UIViewController的根布局上。类似叠加布局的方式。</p>\n<p>然后调用了一个关键的函数，traverse，将初始地址设置进去。</p>\n<p>然后设置了选择回调函数，这里用户选择了四级地址后，会回调到这个handle里面哦。</p>\n<h2 id=\"8-总结\"><a href=\"#8-总结\" class=\"headerlink\" title=\"8 总结\"></a>8 总结</h2><ul>\n<li><p>做一个复杂的自定义View，一定要化繁为简，将复杂的结构一步一步拆分成一个一个基本视图，这样能够很好规划实现方案。</p>\n</li>\n<li><p>任何一个自定义View实现方案可能会有多种，可以选择自己最熟悉的一种，然后进行研究，觉得不合适可以换其它方案来实现。</p>\n</li>\n<li><p>四级地址最关键的应该是数据了，这里我们实现方案是单页面，数据同步刷新的方式，其实也可以考虑多页面，可自由切换，毕竟地址层级不会太多。</p>\n</li>\n<li><p>需要考虑到用户之前填写的地址，可能只填了1到3级，所以一定要考虑全面一点，作为封装视图者，不能只考虑到最完美的情况。</p>\n</li>\n<li><p>多个UITableView是可以共用同一个代理和数据源的，只需要再代理里面区分下是那个UITableView即可。</p>\n</li>\n<li><p>UITableView有很多代理协议，这里可以设置多个组类，一个组多少行，头部View，尾部View，头部高度，尾部高度，点击item，等多种方法，可以实现很复杂的逻辑。</p>\n</li>\n<li><p>UITableView的Cell一定要分配一个标识符，用来复用，增加程序稳定性。</p>\n</li>\n</ul>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-需求分析\"><a href=\"#1-需求分析\" class=\"headerlink\" title=\"1 需求分析\"></a>1 需求分析</h2><p>目标是可以选择四级地址，什么是四级地址呢？省市区街道。类似淘宝买东西时，支付订单时需要填写收货地址，这里就需要构造一个四级地址弹框，让用户去选择。具体效果如下：<br><img src=%E5%9B%9B%E7%BA%A7%E5%9C%B0%E5%9D%80.gif></p>\n<p>这个我们可以单独将这个地址弹框单独封装一下，本身就是一个工具，很多地方可能会用的。<br>另外还需要提供传参，因为可能用户之前选择了某些地址，现在要更改，就需要跳转到已选择的四级地址，并且可以自己切换任何一个省市区，如果重新选择省，那么下级地址都需要清空；如果重新更新了市，那么下级清空，上级保留。<br>大概就是这样子。</p>\n<p>所以我们就可以将四级地址视图用一个UIView来实现。</p>\n<h2 id=\"2-控件结构\"><a href=\"#2-控件结构\" class=\"headerlink\" title=\"2 控件结构\"></a>2 控件结构</h2><p>首先我们分析下如何来完成这个需求，代码如何实现。<br>这里我们考虑将ui提供的四级地址，通过自定义View来实现。</p>\n<p>顶部有一个列表，就是记录用户已选地址，省市区街道。<br>底部也有一个列表，而且有分组，以地址的拼音首字母分组，组下也可能有会有不定行数的cell。</p>\n<p>这里我们就考虑 用两个UITableView来承载顶部和底部的列表。<br>两个UITableView都放在  AddressView 的自定义View里面吧。</p>\n<p>所以会多出两个Cell，一个是顶部Cell，就叫做AddressCell吧；一个是底部Cell，承载底部列表，就叫做AddressSelectorCell吧。</p>\n<p>另外还有数据层，就叫它 AddressModel吧，放地址数据的。</p>\n<p>所以我们只需要4个文件就可以完成这个需求了。</p>\n<ul>\n<li>AddressView 四级地址自定义View</li>\n<li>AddressCell 顶部Cell</li>\n<li>AddressSelectorCell 底部Cell</li>\n<li>AddressModel 数据层</li>\n</ul>\n<h2 id=\"3-AddressView-实现逻辑\"><a href=\"#3-AddressView-实现逻辑\" class=\"headerlink\" title=\"3 AddressView 实现逻辑\"></a>3 AddressView 实现逻辑</h2><h3 id=\"3-1-全局变量定义\"><a href=\"#3-1-全局变量定义\" class=\"headerlink\" title=\"3.1 全局变量定义\"></a>3.1 全局变量定义</h3><pre><code class=\"line-numbers language-Swift\">class AddressView: UIView &#123;\n    \n    typealias selectAddressBlock = (Array&lt;RegionModel&gt;)-&gt;()\n    var selectAddressHandle: selectAddressBlock?\n    var cancelAddressHandle: Handler?\n    \n    var modelArray: Array&lt;Any&gt; = []\n    var addressArray: Array&lt;(key: Swift.String, value: Array&lt;RegionModel&gt;)&gt; = []\n    var selectedIndex: Int = 0\n</code></pre>\n<p>这里定义一个闭包，就是用户勾选了4级地址后，需要将地址暴露个调用方，肯定需要一个方法发出去的。</p>\n<p>cancelAddressHandle是一个取消函数，主要处理用户点击蒙层或者点击取消的事件。</p>\n<p>modelArray是记录顶部列表数据的数组。</p>\n<p>addressArray是记录底部列表数据的数组。</p>\n<p>selectedIndex是记录顶部选择了第几项的全局变量记录。</p>\n<p>然后是2个懒加载的UITableView，看下哈：</p>\n<pre><code class=\"line-numbers language-Swift\">/// 顶部视图列表\nprivate lazy var tblView: UITableView = &#123;\n    let tableView = UITableView.init(frame: CGRect(x: 0, y: 196, width: ScreenWidth, height: ScreenHeight - 196), style: .grouped)\n    tableView.register(AddressCell.self, forCellReuseIdentifier: AddressCell.identifier)\n    tableView.delegate = self\n    tableView.dataSource = self\n    tableView.separatorStyle = .none\n    tableView.backgroundColor = .white\n    tableView.showsVerticalScrollIndicator = false\n    tableView.showsHorizontalScrollIndicator = false\n    tableView.isScrollEnabled = false\n    tableView.layer.cornerRadius = 14\n    tableView.layer.maskedCorners = [.layerMinXMinYCorner,.layerMaxXMinYCorner]\n    return tableView\n&#125;()\n</code></pre>\n<p>还有一个底部的列表：</p>\n<pre><code class=\"line-numbers language-Swift\">/// 底部视图列表\nprivate lazy var addressTblView: UITableView = &#123;\n    let tableView = UITableView.init(frame: CGRect.zero, style: .grouped)\n    tableView.register(AddressSelectorCell.self, forCellReuseIdentifier: AddressSelectorCell.identifier)\n    tableView.delegate = self\n    tableView.dataSource = self\n    tableView.backgroundColor = .white\n    tableView.separatorStyle = .none\n    tableView.showsVerticalScrollIndicator = false\n    tableView.showsHorizontalScrollIndicator = false\n    return tableView\n&#125;()\n</code></pre>\n<p>虽然是两个UITableView，但可以共享同一个代理和数据源，需要在里面另外加if else判断下。</p>\n<h3 id=\"3-2-生命周期函数\"><a href=\"#3-2-生命周期函数\" class=\"headerlink\" title=\"3.2 生命周期函数\"></a>3.2 生命周期函数</h3><p>这里只有一个初始化，但其实没有做什么，也没有把那两个UITableView加进去，这里应该就是空白的区域。</p>\n<pre><code class=\"line-numbers language-Swift\">  override init(frame: CGRect) &#123;\n        super.init(frame: frame)\n        self.backgroundColor = UIColor.init(red: 0, green: 0, blue: 0, alpha: 0.6)\n    &#125;\n    \n    required init?(coder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n</code></pre>\n<h3 id=\"3-3-初始化数据\"><a href=\"#3-3-初始化数据\" class=\"headerlink\" title=\"3.3 初始化数据\"></a>3.3 初始化数据</h3><p>这里是另外提供的函数，来初始化，所以需要调用方额外调用这个方法。<br>也正是这个方法，才会去加载ui的。</p>\n<pre><code class=\"line-numbers language-Swift\">func traverse(province: String, city: String, area: String, street: String)&#123;\n        modelArray.removeAll()\n        let dataArr: [RegionModel] = globalAddressModel?.data ?? AddressModel.init().data\n        self.recursive(dataArr: dataArr, province: province, city: city, area: area, street: street)\n        \n        if globalAddressModel != nil &#123;\n            if modelArray.count == 0 &#123;\n                /// 这里就展示省列表\n                self.setData(data: globalAddressModel!)\n            &#125;else if modelArray.count == 4&#123;\n                /// 这里展示街道列表\n                let model = modelArray[2]\n                self.setData(data: model)\n            &#125; else&#123;\n                /// 其它情况，就拿最后一个数据，在设置给底部内容tableView里面\n                let model = modelArray.last as! RegionModel\n                self.setData(data: model)\n            &#125;\n        &#125;\n        if modelArray.count &lt; 4 &#123;\n            modelArray.append(&quot;请选择&quot;)\n        &#125;\n        \n        /// 大概意思就是找到“请选择”在哪一个位置\n        selectedIndex = modelArray.firstIndex&#123;$0 is String&#125; ?? modelArray.count-1\n        /// 开始加载UI\n        self.loadUI()\n    &#125;\n</code></pre>\n<p>globalAddressModel 实际上再AppDelegate初始化的时候就去异步加载json文件了，这个应该就是保存的所有的四级地址信息了。</p>\n<p>然后这里用到了一个函数 recursive函数，是递归来寻找目标四级地址。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 递归获取目标地址\nfunc recursive(dataArr: [RegionModel], province: String, city: String, area: String, street: String)&#123;\n    for model in dataArr&#123;\n        if model.name.contains(province) ||\n            model.name.contains(city) ||\n            model.name.contains(area) ||\n            model.name.contains(street)&#123;\n            modelArray.append(model)\n            self.recursive(dataArr: model.children, province: province, city: city, area: area, street: street)\n            break\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>找到后，会将实体append到这个数组中。</p>\n<p>然后上面初始化数据还用到一个函数：setData，作用是设置底部数据，因为这里底部自始至终都是同一个UITableView，会经常需要刷新数据。这里就是刷新底部数据的意思吧。</p>\n<p>看下这个setData函数哈：</p>\n<pre><code class=\"line-numbers language-Swift\">func setData(data: Any)&#123;\n        var dataArr: [RegionModel] = []\n        if data is AddressModel &#123;\n            let tmpData = data as! AddressModel\n            dataArr = tmpData.data\n        &#125;else&#123;\n            let tmpData = data as! RegionModel\n            dataArr = tmpData.children\n        &#125;\n        /// 上面的代码目的是为了拿到 RegionModel数组\n        \n        if dataArr.count == 0 &#123;\n            return\n        &#125;\n        \n        var tmpDic: Dictionary&lt;String,Array&lt;RegionModel&gt;&gt; = Dictionary&lt;String,Array&lt;RegionModel&gt;&gt;()\n        for model in dataArr&#123;\n            var key: String = &quot;&quot;\n            key = self.findFirstLetterFromString(aString: model.name)\n            var arr = tmpDic[key] ?? Array&lt;RegionModel&gt;()\n            arr.append(model)\n            tmpDic[key] = arr\n        &#125;\n        \n        //处理了第二个字首字母排序\n        _ = tmpDic.keys.compactMap&#123; key in\n            var tmpArr = tmpDic[key]!\n            tmpArr = tmpArr.sorted&#123;(model1,model2) in\n                var key1 = &quot;&quot;\n                var key2 = &quot;&quot;\n                key1 = self.findFirstLetterFromString(aString: model1.name, isSecond: true)\n                key2 = self.findFirstLetterFromString(aString: model2.name, isSecond: true)\n                return key1 &lt; key2\n            &#125;\n            tmpDic[key] = tmpArr\n        &#125;\n        addressArray = tmpDic.sorted&#123;$0.key &lt; $1.key&#125;\n        \n        /// addressArray应该是拿到目前展示的内容区域数据 底部区域\n        self.addressTblView.reloadData()\n    &#125;\n</code></pre>\n<p>这里代码虽然长，但实际上具体还是挺简单的，主要是生成一个字典的映射关系，key存放首字母，value存放同一个首字母下对应的地址列表。大概意思就是这个tmpDic是一个key value形式的map集合，key是这些比如省份首字母为G，那么value就对应广东省，甘肃省，广西，贵州省等下的所有地址。这里就对应tableView里面的每一组的数据了。然后处理下第二个首字母排序的问题。</p>\n<p>好的，这里打住了，回到第一个函数 traverse方法中，里面根据modelArray的长度去决定刷新哪一个列表，因为调用方给的地址不一定是四级，可能是1级或2级或3级，这里也是需要考虑到的。能在哪个层级搜索到，就定位到哪个层级，那么最后一个层级这里使用 append一个“请选择”，这里说明如果是字符串了，那么这里就是最后一层级。感觉这还可以优化下，比较用字符串来判断到哪一层级不太合适的。</p>\n<p>traverse最后一个方法是加载UI。</p>\n<pre><code class=\"line-numbers language-Swift\">func loadUI()&#123;\n        /// 先加顶部\n        self.addSubview(tblView)\n        /// 顶部布局\n        self.updateUI()\n        \n        /// 再加底部\n        self.addSubview(addressTblView)\n        /// 底部布局\n        addressTblView.snp.remakeConstraints&#123;make in\n            make.leading.trailing.bottom.equalTo(0)\n            make.top.equalTo(tblView.snp.bottom).offset(0)\n        &#125;\n    &#125;\n\nfunc updateUI()&#123;\n        tblView.snp.remakeConstraints&#123;make in\n            make.leading.trailing.equalTo(0)\n            make.top.equalTo(196)\n            if modelArray.count == 1 &#123;\n                make.height.equalTo(96)\n            &#125;else&#123;\n                make.height.equalTo(96+modelArray.count*48)\n            &#125;\n        &#125;\n        self.tblView.reloadData()\n    &#125;\n</code></pre>\n<p>大概意思就是把那两个UITableView加给父View。</p>\n<p>然后需要用的扩展方法有下面这个：</p>\n<pre><code class=\"line-numbers language-Swift\">extension AddressView&#123;\n    \n    /// 找到中文对应的第一个字符对应的第一个字母拼音\n    func findFirstLetterFromString(aString: String, isSecond : Bool = false) -&gt; String &#123;\n        //转变成可变字符串\n        let mutableString = NSMutableString.init(string: aString)\n        \n        //将中文转换成带声调的拼音\n        CFStringTransform(mutableString as CFMutableString, nil,      kCFStringTransformToLatin, false)\n        \n        //去掉声调\n        let pinyinString = mutableString.folding(options:          String.CompareOptions.diacriticInsensitive, locale:   NSLocale.current)\n        \n        //将拼音首字母换成大写\n        let strPinYin = polyphoneStringHandle(nameString: aString,    pinyinString: pinyinString).uppercased()\n        \n        //截取大写首字母\n        let arr = strPinYin.components(separatedBy: &quot; &quot;)\n        let completeStr = isSecond == false ? arr[0] : arr[1]\n        let firstString = completeStr.subScript(index: 0, length: 1)\n        //判断首字母是否为大写\n        let regexA = &quot;^[A-Z]$&quot;\n        let predA = NSPredicate.init(format: &quot;SELF MATCHES %@&quot;, regexA)\n        return predA.evaluate(with: firstString) ? firstString : &quot;#&quot;\n    &#125;\n    \n    //多音字处理，根据需要添自行加\n    func polyphoneStringHandle(nameString: String, pinyinString: String) -&gt; String &#123;\n        //        if nameString.hasPrefix(&quot;长&quot;) &#123;return &quot;chang&quot;&#125;\n        //        if nameString.hasPrefix(&quot;沈&quot;) &#123;return &quot;shen&quot;&#125;\n        //        if nameString.hasPrefix(&quot;厦&quot;) &#123;return &quot;xia&quot;&#125;\n        //        if nameString.hasPrefix(&quot;地&quot;) &#123;return &quot;di&quot;&#125;\n        //        if nameString.hasPrefix(&quot;重&quot;) &#123;return &quot;chong&quot;&#125;\n        return pinyinString\n    &#125;\n&#125;\n</code></pre>\n<p>这里主要是一个工具方法，内部使用，无需多讲。</p>\n<p>好了，前面的ui基本就这些。<br>下面主要是讲解下UITableView的代理方法和数据源配置。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 设置顶部tableView 代理和数据\nextension AddressView: UITableViewDelegate,UITableViewDataSource&#123;\n    func numberOfSections(in tableView: UITableView) -&gt; Int &#123;\n        if tableView == tblView &#123;\n            return 1    /// 顶部tableView只有一组\n        &#125;else&#123;\n            return addressArray.count   /// 很多组 26个字母都有的话，就26组\n        &#125;\n    &#125;\n</code></pre>\n<p>这里扩展AddressView，去实现UITableViewDelegate和UITableViewDataSource协议。<br>这是第一个方法，numberOfSections，返回有多少组。这里因为顶部只有一种类型，也就只有一组，底部用了一个数组记录，组数就是数组的长度。</p>\n<pre><code class=\"line-numbers language-Swift\">func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n        if tableView == tblView &#123;\n            /// 顶部，如果没有 历史地址，则为0，有则显示 一组多少个\n            if modelArray.count == 1 &amp;&amp; (modelArray.last is String) &#123;\n                return 0\n            &#125;else&#123;\n                return modelArray.count\n            &#125;\n        &#125;else&#123;\n            /// 取当前组里面多少个\n            let dic = addressArray[section]\n            let arr = dic.value\n            return arr.count\n        &#125;\n    &#125;\n</code></pre>\n<p>这是第二个方法，numberOfRowsInSection，意思就是这个组下有多少行。</p>\n<pre><code class=\"line-numbers language-Swift\"> func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n        /// 上面下面都是48\n        if tableView == tblView &#123;\n            return 48\n        &#125;else&#123;\n            return 48\n        &#125;\n    &#125;\n</code></pre>\n<p>这里是每行的高度。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 每个cell怎么显示\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n    /// 如果是顶部\n    if tblView == tableView &#123;\n        /// 顶部用AddressCell\n        let cell = tableView.dequeueReusableCell(withIdentifier: AddressCell.identifier, for: indexPath) as! AddressCell\n        let model = modelArray[indexPath.row]\n        /// 数据用modelArray里面的数据\n        cell.model = model\n        /// 选中的话，高亮显示文字颜色\n        if selectedIndex == indexPath.row &#123;\n            cell.titleLb.textColor = UIColor.init(hex: &quot;#409EFF&quot;)\n        &#125;else&#123;\n            cell.titleLb.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n        &#125;\n        /// 这里是请选择什么\n        if model is String &#123;\n            cell.updateUI(indexPath: indexPath)\n        &#125;\n        \n        /// 指示剂方向\n        if indexPath.row == 0 &#123;\n            cell.position = .down // 第0行，只有下面的\n        &#125;else if indexPath.row == modelArray.count-1&#123;\n            cell.position = .top /// 最后一行，只有上面\n        &#125;else&#123;\n            cell.position = .middle /// 其它都有\n        &#125;\n        \n        return cell\n    &#125;else&#123;\n        /// 如果是底部，数据取addressArray里面的\n        let dic = addressArray[indexPath.section]\n        let arr = dic.value\n        let model = arr[indexPath.row] // 这个字母类别里面的 第row行\n        \n        /// 这个cell用 AddressSelector来实现\n        let cell = tableView.dequeueReusableCell(withIdentifier: AddressSelectorCell.identifier, for: indexPath) as! AddressSelectorCell\n        \n        /// 第1行才有字母\n        if indexPath.row == 0 &#123;\n            cell.indexLb.text = dic.key\n        &#125;else&#123;\n            cell.indexLb.text = &quot;&quot;\n        &#125;\n        \n        /// 当前在那个层级 比如是广东省\n        let obj = modelArray[selectedIndex]\n        if obj is String &#123; /// 请选择层级\n            cell.checkImgView.isHidden = true\n            cell.nameLb.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n        &#125;else&#123;\n            /// 已选层级\n            let selectedModel = obj as! RegionModel\n            if selectedModel.name == model.name &#123; /// 列表中的就是已选的，高亮一下\n                cell.nameLb.textColor = UIColor.init(hex: &quot;#409EFF&quot;)\n                cell.checkImgView.isHidden = false\n            &#125;else&#123;\n                cell.nameLb.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n                cell.checkImgView.isHidden = true\n            &#125;\n        &#125;\n        \n        ///  显示目标地址名称\n        cell.nameLb.text = model.name\n        return cell\n    &#125;\n&#125;\n</code></pre>\n<p>这个方法就比较关键了，就是每行怎么展现的。<br>用哪个Cell，是否要高亮，指示剂怎么展示，这里有点像Android的adpter里面的bindAdapter实现逻辑。这里需要按照需求在item里面自行处理逻辑。</p>\n<p>如果是底部，就需要考虑是否显示字母，是否高亮这些了。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 标题和单元格间隔\nfunc tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat &#123;\n    /// 顶部头部预留48dp显示标题“请选择所在地区”\n    if tableView == tblView &#123;\n        return 48\n    &#125;else&#123;\n        return 0.01\n    &#125;\n&#125;\n</code></pre>\n<p>顶部预留高度，用来展示自己的标题。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 和上面对应，预留48个dp怎么显示\nfunc tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -&gt; UIView? &#123;\n    if tableView == tblView &#123;\n        let view = UIView.init(frame: CGRect.init(x: 0, y: 0, width: ScreenWidth, height: 48))\n        let label = UILabel.init()\n        label.font = .pingFangSemibold(size: 18)\n        label.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n        label.text = &quot;请选择所在地区&quot;\n        \n        let closeBtn: UIButton = &#123;\n            let btn = UIButton()\n            btn.setTitle(&quot;取消&quot;, for: .normal)\n            btn.setTitleColor(UIColor.init(hex: &quot;#409EFF&quot;), for: .normal)\n            btn.titleLabel?.font = .pingFangRegular(size: 16)\n            btn.addTarget(self, action: #selector(actionForClose), for: .touchUpInside)\n            return btn\n        &#125;()\n        \n        view.addSubview(label)\n        view.addSubview(closeBtn)\n        label.snp.makeConstraints&#123;make in\n            make.centerY.equalTo(view)\n            make.centerX.equalTo(view)\n            make.width.equalTo(130)\n            make.height.equalTo(30)\n        &#125;\n        closeBtn.snp.makeConstraints&#123;make in\n            make.trailing.equalTo(-16)\n            make.centerY.equalTo(view)\n            make.width.equalTo(48)\n            make.height.equalTo(48)\n        &#125;\n        return view\n    &#125;else&#123;\n        return UIView()\n    &#125;\n&#125;\n</code></pre>\n<p>标题和取消按钮显示逻辑。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 单元格尾巴怎么显示\nfunc tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -&gt; CGFloat &#123;\n    /// 如果是顶部tableView，预留48个dp\n    if tableView == tblView &#123;\n        return 48\n    &#125;else&#123;\n        return 0.01\n    &#125;\n&#125;\n</code></pre>\n<p>这里顶部有效，有48个单位长度，用来显示底部标题。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 尾部显示 选择下级地址\nfunc tableView(_ tableView: UITableView, viewForFooterInSection section: Int) -&gt; UIView? &#123;\n    if tableView == tblView &#123;\n        let view = UIView.init(frame: CGRect.init(x: 0, y: 0, width: ScreenWidth, height: 48))\n        \n        let lineView = UIView()\n        lineView.backgroundColor = UIColor.init(hex: &quot;#F6F6F6&quot;)\n        let label = UILabel.init()\n        label.font = .pingFangSemibold(size: 16)\n        label.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n        \n        if selectedIndex == 0 &#123;\n            label.text = &quot;选择省份/地区&quot;\n        &#125;else if selectedIndex == 1&#123;\n            label.text = &quot;选择城市&quot;\n        &#125;else if selectedIndex == 2&#123;\n            label.text = &quot;选择区/县&quot;\n        &#125;else&#123;\n            label.text = &quot;选择街道/镇&quot;\n        &#125;\n        \n        view.addSubview(lineView)\n        view.addSubview(label)\n        \n        lineView.snp.makeConstraints&#123;make in\n            make.top.equalTo(4)\n            make.leading.trailing.equalTo(0)\n            make.height.equalTo(0.5)\n        &#125;\n        label.snp.makeConstraints&#123;make in\n            make.top.equalTo(16)\n            make.leading.equalTo(8)\n            make.width.equalTo(150)\n            make.height.equalTo(30)\n        &#125;\n        return view\n    &#125;else&#123;\n        return UIView()\n    &#125;\n&#125;\n</code></pre>\n<p>这里就是确定底部标题的怎么显示的。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 点击了单元格\nfunc tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123;\n    if tblView == tableView &#123;\n        /// 顶部点击了哪个单元格\n        if indexPath.row == 0 &#123;\n            self.setData(data: globalAddressModel!)\n        &#125;else&#123;\n            let model = modelArray[indexPath.row-1]\n            self.setData(data: model)\n        &#125;\n        selectedIndex = indexPath.row\n        /// 改变全局变量 selectedIndex，再去加载\n        self.tblView.reloadData()\n    &#125;else&#123;\n        /// 当前是哪一组\n        let dic = addressArray[indexPath.section]\n        let arr = dic.value\n        /// 当前是哪一行\n        let model = arr[indexPath.row]\n        \n        /// 请选择是第几个\n        let index = modelArray.firstIndex&#123;$0 is String&#125; ?? 0\n        /// 顶部是请选择\n        if modelArray[selectedIndex] is String &amp;&amp; modelArray.count &lt; 5&#123;\n            /// 插入目标点击的地址 给modelArray\n            modelArray.insert(model, at: index)\n            if modelArray.count == 5 &#123;\n                modelArray.removeLast()\n            &#125;\n        &#125;else&#123;\n            /// 顶部不是请选择,而已已选择的地址\n            modelArray[selectedIndex] = model\n            /// 下面有请选择，需要清空之前选择的值\n            let isContain = modelArray.contains(where: &#123;$0 is String&#125;)\n            if isContain &#123;\n                for i in (selectedIndex+1 ... modelArray.count-1).reversed()&#123;\n                    if modelArray[i] is String &#123;\n                        continue\n                    &#125;\n                    modelArray.remove(at: i)\n                &#125;\n            &#125; else if !isContain &amp;&amp; selectedIndex != 3&#123;\n                for i in (selectedIndex+1 ... modelArray.count-1).reversed()&#123;\n                    modelArray.remove(at: i)\n                &#125;\n            &#125;\n            \n            if modelArray.count &lt; 4 &amp;&amp; !modelArray.contains(where: &#123;$0 is String&#125;)&#123;\n                modelArray.append(&quot;请选择&quot;)\n            &#125;\n        &#125;\n        \n        /// 没有请选择了，会直接关闭弹框，执行回调\n        if modelArray.count == 4 &amp;&amp; !modelArray.contains(where: &#123;$0 is String&#125;)&#123;\n            var arr: [RegionModel] = []\n            for model in modelArray &#123;\n                let obj = model as! RegionModel\n                arr.append(obj)\n            &#125;\n            selectAddressHandle?(arr)\n            self.removeFromSuperview()\n        &#125;else&#123;\n            /// 更新底部数据，以及顶部选择index\n            self.setData(data: model)\n            self.updateUI()\n            selectedIndex += 1\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>上面的代码逻辑，主要就是处理点击顶部单元格，和底部单元格的逻辑。<br>顶部点击会调用setData,会同步刷新底部。</p>\n<p>底部点击也会setData,刷新底部数据，如果全部选择，则会走闭包回调，将用户选择的四级地址回调出去。</p>\n<p>然后还有一些其它扩展方法，简单看下哈。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 扩展给外部\nextension AddressView&#123;\n    /// 通知调用者当有一个或者多个手指触摸到了视图或者窗口时触发此方法。\n    /// touches是UITouch的集合，通过UITouch我们可以检测触摸事件的属性，是单拍还是双拍，还有触摸的位置等。\n    /// 这里应该是触摸到蒙层后关闭弹框\n    override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123;\n        guard let point = touches.first?.location(in: self) else &#123; return &#125;\n        let p = self.layer.convert(point, from: self.layer)\n        if self.layer.contains(p) &#123;\n            self.actionForClose()\n        &#125;\n    &#125;\n    \n    /// 移除自己，类似关闭弹框效果\n    @objc func actionForClose()&#123;\n        cancelAddressHandle?()\n        self.removeFromSuperview()\n    &#125;\n&#125;\n</code></pre>\n<p>这里actionForClose是UiButton设置的一个action，上面哪个是覆写的官方方法，应该是触摸到蒙层自动关闭弹框。</p>\n<h2 id=\"4-AddressCell-实现逻辑\"><a href=\"#4-AddressCell-实现逻辑\" class=\"headerlink\" title=\"4 AddressCell 实现逻辑\"></a>4 AddressCell 实现逻辑</h2><p>这个可以理解成Android中的Adapter了。也就是item怎么显示。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 顶部cell\nclass AddressCell: UITableViewCell &#123;\n    \n    enum LinePosition &#123;\n        case down\n        case middle\n        case top\n    &#125;\n    \n    static var identifier: String = &quot;AddressCell&quot;\n</code></pre>\n<p>这里需要继承UITableViewCell，必须要有一个identifier，这个主要是为了复用，因为列表可能会很长，为了合理复用，这里一般都需要一个标识符。</p>\n<h3 id=\"4-1-子View定义\"><a href=\"#4-1-子View定义\" class=\"headerlink\" title=\"4.1 子View定义\"></a>4.1 子View定义</h3><pre><code class=\"line-numbers language-Swift\"> /// 安徽省\nlazy var titleLb: UILabel = &#123;\n    let label = UILabel()\n    label.font = .pingFangMedium(size: 16)\n    label.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n    return label\n&#125;()\n\n/// 实心圆\nlazy var roundView: UIView = &#123;\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n    view.layer.cornerRadius = 3.5\n    view.layer.borderWidth = 1\n    view.layer.borderColor = UIColor.init(hex: &quot;#409EFF&quot;).cgColor\n    return view\n&#125;()\n\n/// 圆上面的线条\nlazy private var toplineView: UIView = &#123;\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n    return view\n&#125;()\n\n/// 圆下面的线条\nlazy private var downlineView: UIView = &#123;\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n    return view\n&#125;()\n\n/// 右侧箭头\nlazy private var rightImgView: UIImageView = &#123;\n    let imgView = UIImageView()\n    imgView.image = UIImage.init(named: &quot;客户信息_右箭头&quot;)\n    return imgView\n&#125;()\n</code></pre>\n<p>这里是顶部item用的一些零部件。<br>比如上下线图，右侧箭头，中间文字。实心圆。<br>这里变空心，实际上只是设置了中间颜色为纯白。</p>\n<h3 id=\"4-2-数据定义\"><a href=\"#4-2-数据定义\" class=\"headerlink\" title=\"4.2 数据定义\"></a>4.2 数据定义</h3><pre><code class=\"line-numbers language-Swift\">/// 监听数据变化 数据填充\nvar model: Any?&#123;\n    didSet&#123;\n        guard let _model = model else&#123;return&#125;\n        if _model is RegionModel &#123;\n            let tmp = _model as! RegionModel\n            titleLb.text = tmp.name\n        &#125;\n    &#125;\n&#125;\n    \n/// 线条位置\nvar position: LinePosition?&#123;\n    didSet&#123;\n        guard let _position = position else&#123;return&#125;\n        /// 上面和下面的线条都先一出去\n        toplineView.removeFromSuperview()\n        downlineView.removeFromSuperview()\n        \n        /// 如果在下面 空心圆\n        if _position == .down &#123;\n            contentView.addSubview(downlineView)\n            downlineView.snp.makeConstraints&#123;make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(roundView.snp.top).offset(0)\n                make.bottom.equalTo(0)\n                make.width.equalTo(1)\n            &#125;\n            roundView.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n        &#125;else if _position == .top&#123;\n            /// 如果在上面 空心圆\n            contentView.addSubview(toplineView)\n            toplineView.snp.makeConstraints&#123;make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(0)\n                make.bottom.equalTo(roundView.snp.top)\n                make.width.equalTo(1)\n            &#125;\n            if model is String &#123;\n                roundView.backgroundColor = .white\n            &#125;else&#123;\n                roundView.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n            &#125;\n        &#125;else&#123;\n            /// 都不在，也是都存在的意思\n            contentView.addSubview(toplineView)\n            contentView.addSubview(downlineView)\n            toplineView.snp.makeConstraints&#123;make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(0)\n                make.bottom.equalTo(roundView.snp.top)\n                make.width.equalTo(1)\n            &#125;\n            downlineView.snp.remakeConstraints&#123;make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(roundView.snp.bottom)\n                make.bottom.equalTo(0)\n                make.width.equalTo(1)\n            &#125;\n            roundView.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里定义了2个数据，1个是具体显示什么的数据，一个是线条怎么展示，什么时候展示实心和空心圆的逻辑。</p>\n<h3 id=\"4-3-生命周期函数\"><a href=\"#4-3-生命周期函数\" class=\"headerlink\" title=\"4.3 生命周期函数\"></a>4.3 生命周期函数</h3><p>首先看下初始化。</p>\n<pre><code class=\"line-numbers language-Swift\">override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) &#123;\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        \n        self.selectionStyle = .none\n        \n        /// 添加安徽省\n        contentView.addSubview(titleLb)\n        titleLb.snp.makeConstraints&#123;make in\n            make.centerY.equalToSuperview()\n            make.leading.equalTo(roundView.snp.trailing).offset(22)\n            make.trailing.equalTo(rightImgView.snp.leading).offset(10)\n            make.height.equalTo(20)\n        &#125;\n        \n        /// 添加圆形指示器\n        contentView.addSubview(roundView)\n        roundView.snp.makeConstraints&#123;make in\n            make.centerY.equalToSuperview()\n            make.leading.equalTo(14)\n            make.width.equalTo(7)\n            make.height.equalTo(7)\n        &#125;\n        \n        /// 添加右侧箭头\n        contentView.addSubview(rightImgView)\n        rightImgView.snp.makeConstraints&#123;make in\n            make.centerY.equalToSuperview()\n            make.trailing.equalTo(-16)\n            make.width.equalTo(19)\n            make.height.equalTo(19)\n        &#125;\n        \n    &#125;\n    \n    required init?(coder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n</code></pre>\n<p>这里就加了3个视图，并且布局了。</p>\n<h3 id=\"4-4-其它扩展方法\"><a href=\"#4-4-其它扩展方法\" class=\"headerlink\" title=\"4.4 其它扩展方法\"></a>4.4 其它扩展方法</h3><pre><code class=\"line-numbers language-Swift\">extension AddressCell&#123;\n    func updateUI(indexPath: IndexPath)&#123;\n        if indexPath.row == 1 &#123;\n            titleLb.text = &quot;请选择城市&quot;\n        &#125;else if indexPath.row == 2 &#123;\n            titleLb.text = &quot;请选择县&quot;\n        &#125;else if indexPath.row == 3&#123;\n            titleLb.text = &quot;请选街道&quot;\n        &#125;else&#123;\n            titleLb.text = &quot;&quot;//model as? String\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里就是显示item特殊情况的文案。</p>\n<h2 id=\"5-AddressSelectorCell-实现逻辑\"><a href=\"#5-AddressSelectorCell-实现逻辑\" class=\"headerlink\" title=\"5 AddressSelectorCell 实现逻辑\"></a>5 AddressSelectorCell 实现逻辑</h2><p>这里也同上面的Cell，有一个标识符。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 底部Cell\nclass AddressSelectorCell: UITableViewCell &#123;\n    \n    static var identifier: String = &quot;UITableViewCell&quot;\n</code></pre>\n<h3 id=\"5-1-子View\"><a href=\"#5-1-子View\" class=\"headerlink\" title=\"5.1 子View\"></a>5.1 子View</h3><p>这里需要哪些子View呢？</p>\n<pre><code class=\"line-numbers language-Swift\">//索引 eg: A字母\nlazy var indexLb: UILabel = &#123;\n    let label = UILabel()\n    label.font = .pingFangMedium(size: 12)\n    label.textColor = UIColor.init(hex: &quot;#9B9DA7&quot;)\n    return label\n&#125;()\n\n//名称 eg: 安徽省\nlazy var nameLb: UILabel = &#123;\n    let label = UILabel()\n    label.font = .pingFangMedium(size: 14)\n    label.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n    return label\n&#125;()\n\n//勾选图标\nlazy var checkImgView: UIImageView = &#123;\n    let imgView = UIImageView()\n    imgView.isHidden = true\n    imgView.image = UIImage.init(named: &quot;勾选&quot;)\n    return imgView\n&#125;()\n</code></pre>\n<p>这里非常简单，只有3个子视图，字母，中间名称，是否勾选。</p>\n<h3 id=\"5-2-生命周期函数\"><a href=\"#5-2-生命周期函数\" class=\"headerlink\" title=\"5.2 生命周期函数\"></a>5.2 生命周期函数</h3><p>看下初始化吧。</p>\n<pre><code class=\"line-numbers language-Swift\">override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) &#123;\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        self.selectionStyle = .none\n        \n        /// 添加索引，并且布局\n        contentView.addSubview(indexLb)\n        indexLb.snp.makeConstraints&#123;make in\n            make.leading.equalTo(8)\n            make.centerY.equalToSuperview()\n            make.width.equalTo(10)\n            make.height.equalTo(20)\n        &#125;\n        \n        /// 添加名称，并且位置确定\n        contentView.addSubview(nameLb)\n        nameLb.snp.makeConstraints&#123;make in\n            make.leading.equalTo(indexLb.snp.trailing).offset(16)\n            make.trailing.equalTo(-16)\n            make.centerY.equalToSuperview()\n            make.height.equalTo(20)\n        &#125;\n        \n        /// 确定勾选图标\n        contentView.addSubview(checkImgView)\n        checkImgView.snp.makeConstraints&#123;make in\n            make.trailing.equalTo(-16)\n            make.centerY.equalToSuperview()\n            make.width.equalTo(16)\n            make.height.equalTo(16)\n        &#125;\n    &#125;\n    \n    required init?(coder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n</code></pre>\n<p>也是非常简单，添加了3个子视图，并且确定位置了。</p>\n<h2 id=\"6-AddressModel-实现逻辑\"><a href=\"#6-AddressModel-实现逻辑\" class=\"headerlink\" title=\"6 AddressModel 实现逻辑\"></a>6 AddressModel 实现逻辑</h2><p>这个是四级地址的数据模型，可以看下：</p>\n<pre><code class=\"line-numbers language-Swift\">import Foundation\nimport HandyJSON\n\nclass AddressModel: HandyJSON &#123;\n    var data: [RegionModel] = []\n    required init() &#123;&#125;\n&#125;\n\nclass RegionModel: HandyJSON &#123;\n    var code: String = &quot;&quot;\n    var name: String = &quot;&quot;\n    var children: [RegionModel] = []\n    required init() &#123;&#125;\n&#125;\n</code></pre>\n<p>继承了HandyJSON，方便解析。<br>这里AddressModel实际上内部也是由 RegionModel数组构成的。<br>这个AddressModel用来存放省列表比较合适。</p>\n<p>RegionModel可以存放市，区，街道，都没问题。</p>\n<p>封装四级地址基本上就这些了。</p>\n<h2 id=\"7-外部调用方式\"><a href=\"#7-外部调用方式\" class=\"headerlink\" title=\"7 外部调用方式\"></a>7 外部调用方式</h2><h3 id=\"7-1-先声明一个四级地址View\"><a href=\"#7-1-先声明一个四级地址View\" class=\"headerlink\" title=\"7.1 先声明一个四级地址View\"></a>7.1 先声明一个四级地址View</h3><pre><code class=\"line-numbers language-Swift\">lazy private var addressView: AddressView = &#123;\n        let tmpview = AddressView(frame: CGRect.init(x: 0, y: 0, width: ScreenWidth, height: ScreenHeight))\n        return tmpview\n    &#125;()\n</code></pre>\n<p>这里设定了它的frame，也就是大小位置。</p>\n<h3 id=\"7-2-弹出四级地址\"><a href=\"#7-2-弹出四级地址\" class=\"headerlink\" title=\"7.2  弹出四级地址\"></a>7.2  弹出四级地址</h3><pre><code class=\"line-numbers language-Swift\">func showAddressSelector()&#123;\n        self.view.addSubview(self.addressView)\n        self.addressView.traverse(province: self.orderAddressModel?.province ?? &quot;&quot;, city: self.orderAddressModel?.city ?? &quot;&quot;, area: self.orderAddressModel?.region ?? &quot;&quot;, street: self.orderAddressModel?.street ?? &quot;&quot;)\n        addressView.selectAddressHandle = &#123;[weak self] (arr)in\n            guard let weakSelf = self else&#123;return&#125;\n            let pModel = arr[0]\n            let cModel = arr[1]\n            let aModel = arr[2]\n            let tModel = arr[3]\n            ...\n            \n        &#125;\n    &#125;\n</code></pre>\n<p>这里通过addSubview的方式，将这个四级地址添加到这个UIViewController的根布局上。类似叠加布局的方式。</p>\n<p>然后调用了一个关键的函数，traverse，将初始地址设置进去。</p>\n<p>然后设置了选择回调函数，这里用户选择了四级地址后，会回调到这个handle里面哦。</p>\n<h2 id=\"8-总结\"><a href=\"#8-总结\" class=\"headerlink\" title=\"8 总结\"></a>8 总结</h2><ul>\n<li><p>做一个复杂的自定义View，一定要化繁为简，将复杂的结构一步一步拆分成一个一个基本视图，这样能够很好规划实现方案。</p>\n</li>\n<li><p>任何一个自定义View实现方案可能会有多种，可以选择自己最熟悉的一种，然后进行研究，觉得不合适可以换其它方案来实现。</p>\n</li>\n<li><p>四级地址最关键的应该是数据了，这里我们实现方案是单页面，数据同步刷新的方式，其实也可以考虑多页面，可自由切换，毕竟地址层级不会太多。</p>\n</li>\n<li><p>需要考虑到用户之前填写的地址，可能只填了1到3级，所以一定要考虑全面一点，作为封装视图者，不能只考虑到最完美的情况。</p>\n</li>\n<li><p>多个UITableView是可以共用同一个代理和数据源的，只需要再代理里面区分下是那个UITableView即可。</p>\n</li>\n<li><p>UITableView有很多代理协议，这里可以设置多个组类，一个组多少行，头部View，尾部View，头部高度，尾部高度，点击item，等多种方法，可以实现很复杂的逻辑。</p>\n</li>\n<li><p>UITableView的Cell一定要分配一个标识符，用来复用，增加程序稳定性。</p>\n</li>\n</ul>\n"},{"title":"iOS swift 实现简易地图功能","date":"2023-01-31T07:27:26.000Z","top":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 需求定义\n\n产品需要我们实现这样一个需求，就是根据一个地址（可能有经纬度也可能没有）,然后跳转到地图页面去，地图中间会显示这个地址。运行用户自行点击定位，这样中间会显示当前位置。允许左右滑动，地图中心也会随之变更。支持搜索功能，根据用户搜索关键词，获取一个搜索列表。然后就是一个提交功能，这样需要将经纬度提交到服务端。\n\n大致是这样的需求。\n实现效果是这样的：\n<img src=map.png>\n\n## 2 需求分析\n\n根据产品的需求，我们考虑接入高德地图。所以我们需要事先调研下如何接入高德才行。\n\n其实这个应该非常简单，高德提供了Map，我们只需要将中间的坐标设置为我们自己的坐标。如果没有坐标，我们也调研高德的搜索接口，将搜索结果默认第一条，这应该是最准的吧，然后设置给高德的中间坐标即可。\n\n支持用户滑动，高德就应该支持的，这里应该会提供一个代理，我们在这个代理的回调类里面重新去调用下搜索接口，就能出现附近10条地址。\n\n二指放大，高德应该也是支持的，不需要我们额外设置啥。\n\n另外就是定位可能复杂一点，需要实现获取下定位权限，如果没有权限，需要跳转到系统设置。定位就不需要高德支持了，我们直接调用系统接口，获取经纬度，然后设置给高德就行了。\n\n## 3 准备工作：了解高德\n\n首先附上高德官方文档：[https://lbs.amap.com/api/ios-sdk/summary](https://lbs.amap.com/api/ios-sdk/summary)\n\n申请key这些工作就不用交给我们了，让产品自己申请吧。\n\n接入高德地图，做很复杂的需求，可以参考这篇文档，写得还不错：\n[https://www.jianshu.com/p/770728626874](https://www.jianshu.com/p/770728626874) 但是这个是objective-C，不过基本原理是类似的，还是有参考价值的。\n\n另外附上高德地图可配置参数：\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>logoCenter</td>\n<td>CGPoint</td>\n<td>可设置Logo的位置。必须在mapView.bounds之内，否则会被忽略。</td>\n</tr>\n<tr>\n<td>showsCompass</td>\n<td>Bool</td>\n<td>是否显示指南针。</td>\n</tr>\n<tr>\n<td>compassOrigin</td>\n<td>CGPoint</td>\n<td>设置指南针的位置。</td>\n</tr>\n<tr>\n<td>showsScale</td>\n<td>Bool</td>\n<td>是否显示比例值。</td>\n</tr>\n<tr>\n<td>scaleOrigin</td>\n<td>CGPoint</td>\n<td>设置比例尺的位置。</td>\n</tr>\n<tr>\n<td>zoomEnabled</td>\n<td>Bool</td>\n<td>是否开启缩放手势，默认true。</td>\n</tr>\n<tr>\n<td>scrollEnabled</td>\n<td>Bool</td>\n<td>是否开启滑动手势，默认true。</td>\n</tr>\n<tr>\n<td>rotateEnabled</td>\n<td>Bool</td>\n<td>是否开启旋转手势，默认true。</td>\n</tr>\n<tr>\n<td>rotateCameraEnabled</td>\n<td>Bool</td>\n<td>是否开启倾斜旋转手势，默认true。用户可以在地图上放置两个手指，移动它们一起向下或向上去增加或减小倾斜角。</td>\n</tr>\n<tr>\n<td>setZoomLevel</td>\n<td>CGFloat</td>\n<td>改变地图缩放级别。范围从3级到19级，共17级。级别越高，展示的内容越细，例如街道等等。</td>\n</tr>\n<tr>\n<td>setCenter</td>\n<td>CLLocationCoordinate2D</td>\n<td>改变地图中心的位置。传递具体的经纬度。</td>\n</tr>\n</tbody>\n</table>\n\n另外一个就是需要我们在AppDelegate中注册key：\n```Swift\n /// 设置高德地图\nfunc configAMap() {\n    AMapServices.shared().apiKey = \"你申请的key\"\n    AMapServices.shared().enableHTTPS = true\n}\n```\n\n这里，准备工作基本就完成了。\n\n## 4 代码实现\n\n### 4.1 新建两个实体类\n\n```Swift\nclass GMLocationPickerLocationResult: NSObject {\n    \n    //MARK: - property\n    \n    var coordinate: CLLocationCoordinate2D?     // 经纬度\n    \n    var poiName: String = \"\"                    // 名称\n    \n    var province: String = \"\"                   // 省\n    var provinceCode: String = \"\"               // 省编码\n    var city: String = \"\"                       // 市\n    var citycode: String = \"\"                   // 市编码\n    var district: String = \"\"                   // 区\n    var adcode: String = \"\"                     // 区编码\n    var township: String = \"\"                   // 乡镇街道\n    var towncode: String = \"\"                   // 乡镇街道编码(截取前9位)\n    \n    var detailAddress: String = \"\"              // 详细地址\n    var formattedAddress: String = \"\"           // 格式化全地址(4级+详细)\n    \n    var locationInfo: GMLocationPickerLocationInfo? //\n    \n    /// 模型转换\n    convenience init(location: AMapGeoPoint, reGeocode: AMapReGeocode, locationInfo: GMLocationPickerLocationInfo?) {\n        self.init()\n        \n        let latitude = location.latitude\n        let longitude = location.longitude\n        self.coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n        \n        if let locationInfo = locationInfo {\n            // 1.转换基础信息\n            self.poiName = locationInfo.poiName\n            self.province = locationInfo.province\n            self.city = locationInfo.city\n            self.district = locationInfo.district\n            self.township = locationInfo.street\n            self.detailAddress = locationInfo.address\n            self.formattedAddress = locationInfo.province + locationInfo.city + locationInfo.district + locationInfo.address\n        }\n        if let addressComponent = reGeocode.addressComponent {\n            // 2.转换所有信息\n            var poiName = \"\"\n            if let locationInfo = locationInfo {\n                poiName = locationInfo.poiName\n            } else if let aoisName = reGeocode.aois.first?.name {\n                poiName = aoisName\n            } else if let roadinterName = reGeocode.roadinters.first?.firstName {\n                poiName = roadinterName\n            } else {\n                poiName = addressComponent.township ?? \"\"\n            }\n            self.poiName = self.poiName.ty_forEmpty(poiName)\n            \n            self.province = self.province.ty_forEmpty(addressComponent.province ?? \"\")\n            self.city = self.city.ty_forEmpty(addressComponent.city ?? \"\")\n            self.district = self.district.ty_forEmpty(addressComponent.district ?? \"\")\n            self.township = self.township.ty_forEmpty(addressComponent.township ?? \"\")\n            self.formattedAddress = self.formattedAddress.ty_forEmpty(reGeocode.formattedAddress ?? \"\")\n        }\n        if let addressComponent = reGeocode.addressComponent {\n            // 设置编码\n            self.citycode = addressComponent.citycode ?? \"\"\n            self.adcode = addressComponent.adcode ?? \"\"\n            self.towncode = String(addressComponent.towncode.prefix(9)) // 截取前九位\n        }\n        // 设置省份编码 用自带plist\n        if let globalAddressModel = globalAddressModel {\n            for currProvince in globalAddressModel.data {\n                if currProvince.name == self.province {\n                    self.provinceCode = currProvince.code\n                    break\n                }\n            }\n        }\n        self.locationInfo = locationInfo\n    }\n}\n```\n\n这个用了一个convenience关键字来声明init，主要是覆写的作用，重载。可以参考这篇文章：[https://www.jianshu.com/p/09c6c88ed61e](https://www.jianshu.com/p/09c6c88ed61e)。这里面初始化已经用了高德的实体类AMapGeoPoint,这个包含了经纬度；AMapReGeocode，这个是逆地址编码；然后还有一个自定义实体，这个是Info，上面那个是result，info如下定义：\n\n```Swift\n\nclass GMLocationPickerLocationInfo: NSObject {\n    \n    //MARK: - property\n    \n    var coordinate: CLLocationCoordinate2D?     // 经纬度\n    \n    var poiName: String = \"\"                    // 名称\n    var province: String = \"\"                   // 省\n    var city: String = \"\"                       // 市\n    var district: String = \"\"                   // 区\n    var street: String = \"\"                     // 街道(*)\n    var number: String = \"\"                     // 门牌号(*)\n    \n    var address: String = \"\"                    // 地址(街道 + 门牌)\n    \n    var distance: Int = 0                       // 与选中点距离\n    \n    // UI\n    \n    var ui_isSelected = false                   // cell是否选中中\n    \n    //MARK: - life cycle\n    \n    // ------------------------- map 内转换 -------------------------\n    \n    /// 模型转换 根据 [实时定位]获取的 经纬度 & 逆地理信息\n    convenience init(coordinate: CLLocationCoordinate2D?, reGeocode: AMapLocationReGeocode?) {\n        self.init()\n        \n        self.coordinate = coordinate\n        \n        self.poiName = reGeocode?.poiName ?? \"\"\n        self.province = reGeocode?.province ?? \"\"\n        self.city = reGeocode?.city ?? \"\"\n        self.district = reGeocode?.district ?? \"\"\n        self.street = reGeocode?.street ?? \"\"\n        self.number = reGeocode?.number ?? \"\"\n        self.address = (self.street + self.number)\n        if self.street.isEmpty || self.number.isEmpty {\n            let detailAddress = reGeocode?.formattedAddress ?? \"\"\n            self.address = abbreviationAddressIn(detailAddress: detailAddress, province: province, city: city, district: district)\n        }\n        \n        self.distance = 0\n    }\n    \n    /// 模型转换 根据 [搜索{附近|关键词}]获取的 POI模型\n    convenience init(mapPOI: AMapPOI) {\n        self.init()\n        \n        if let location = mapPOI.location {\n            let latitude = location.latitude\n            let longitude = location.longitude\n            self.coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n        }\n        \n        self.poiName = mapPOI.name\n        self.province = mapPOI.province\n        self.city = mapPOI.city\n        self.district = mapPOI.district\n        self.street = \"\"\n        self.number = \"\"\n        self.address = mapPOI.address\n        \n        self.distance = mapPOI.distance // 周边搜索可用\n    }\n    \n    /// 模型转换 根据 [逆地理编码]获取的 经纬度 & 逆地理编码结果\n    convenience init(location: AMapGeoPoint, reGeocode: AMapReGeocode) {\n        self.init()\n        \n        let addressComponent = reGeocode.addressComponent\n        \n        let latitude = location.latitude\n        let longitude = location.longitude\n        self.coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n        \n        if let aoisName = reGeocode.aois.first?.name {\n            self.poiName = aoisName\n        } else if let roadinterName = reGeocode.roadinters.first?.firstName {\n            self.poiName = roadinterName\n        } else {\n            self.poiName = addressComponent?.township ?? \"\"\n        }\n        self.province = addressComponent?.province ?? \"\"\n        self.city = addressComponent?.city ?? \"\"\n        self.district = addressComponent?.district ?? \"\"\n        self.street = addressComponent?.streetNumber?.street ?? \"\"\n        self.number = addressComponent?.streetNumber?.number ?? \"\"\n        self.address = (self.street + self.number)\n        if self.street.isEmpty || self.number.isEmpty {\n            let detailAddress = reGeocode.formattedAddress ?? \"\"\n            self.address = abbreviationAddressIn(detailAddress: detailAddress, province: province, city: city, district: district)\n        }\n        self.distance = 0\n    }\n    \n    /// 详细地址中获取缩略地址\n    /// - Parameters:\n    ///   - detailAddress: 详细地址\n    ///   - province: 省份\n    ///   - city: 城市\n    ///   - district: 区域\n    private func abbreviationAddressIn(detailAddress: String, province: String, city: String, district: String) -> String {\n        var address = detailAddress\n        address = address.replacingOccurrences(of: province, with: \"\")\n        address = address.replacingOccurrences(of: city, with: \"\")\n        address = address.replacingOccurrences(of: city, with: \"\")\n        return address\n    }\n    \n    // ------------------------- model 转换 -------------------------\n    \n    /// 模型转换 根据 地理信息结果模型\n    convenience init(locationResult: GMLocationPickerLocationResult) {\n        self.init()\n        \n        self.coordinate = locationResult.coordinate\n        \n        self.poiName = locationResult.poiName\n        self.province = locationResult.province\n        self.city = locationResult.city\n        self.district = locationResult.district\n        let street = locationResult.township\n        self.address = street\n        \n        self.distance = 0\n    }\n    \n    /// 模型转换 根据 仓库模型\n    convenience init(warehouseInfo: GMWarehouseInfoHomeList) {\n        self.init()\n        \n        self.coordinate = warehouseInfo.cus_coordinate\n        \n        self.poiName = warehouseInfo.name\n        self.province = warehouseInfo.province\n        self.city = warehouseInfo.city\n        self.district = warehouseInfo.region\n        self.street = \"\"\n        self.number = \"\"\n        self.address = warehouseInfo.address\n        \n        self.distance = 0\n    }\n    \n    /// 模型转换 根据 门店模型\n    convenience init(storeInfo: GMStoreInfoHomeModel) {\n        self.init()\n        \n        self.coordinate = storeInfo.cus_coordinate\n        \n        self.poiName = storeInfo.shopName\n        self.province = storeInfo.shopProvince\n        self.city = storeInfo.shopCity\n        self.district = storeInfo.shopCounty\n        self.street = storeInfo.shopStreet\n        self.number = \"\"\n        self.address = storeInfo.shopAddress\n        \n        self.distance = 0\n    }\n}\n```\n这个是地图内部使用，上面那个实体，是为了更好对接服务端设定的一个实体。\n\n### 4.2 外部类定义\n\n```Swift\n/// 地图选择 闭包，向外吐出去\ntypealias GMLocationResultHandler = (GMLocationPickerLocationResult?) -> Swift.Void\n\nprotocol GMLocationPickerControllerDelegate: AnyObject {\n    /// 提交所选位置\n    func locationPickerController(_ collection: GMLocationPickerController, didSubmit locationInfo: GMLocationPickerLocationResult)\n    \n    /// 页面将要pop出\n    func locationPickerControllerWillPop(_ collection: GMLocationPickerController)\n}\n\n/// 从哪里进来的 枚举类\nenum GMLocationPickerFor {\n    case warehouseCreate                                        // 仓库创建\n    case warehouseEdit(warehouseInfo: GMWarehouseInfoHomeList)  // 仓库编辑\n    case storeEdit(storeInfo: GMStoreInfoHomeModel)             // 门店编辑\n}\n\n/// 选择地理位置的原因 什么时候走高德接口\nenum GMLocationPickerRegionChageFor {\n    case located                                                // 实时定位\n    case itemSelected                                           // 搜索项选择\n    case keywordSearchSelected                                  // 关键词搜索 自动选择(第一个)\n    case slideByCustomer                                        // 用户滑动逆地理\n}\n```\n这里定义了可能需要的枚举类和协议。\n枚举类主要跟我们自己业务有关系了，协议也是跟业务有关系。这里并不是实现地图的必须。\n\n### 4.3 UI声明\n\n```Swift\nclass GMLocationPickerController: GMBaseViewController {\n\n    //MARK: - property\n    \n    // UI\n    \n    private weak var btn_submit: UIButton!                      // 提交按钮\n    private weak var mapView: MAMapView!                        // 地图\n    private weak var textF_search: UITextField!                 // 搜索 输入栏\n    private weak var tableView: TYTableView!                    // 搜索 列表\n    private weak var ai_spinner: UIActivityIndicatorView!       // 加载loading\n    private weak var btn_located: UIButton!                     // 定位按钮\n    \n    private weak var imgV_pointAnnotation: UIImageView!         // 自定义大头针\n```\n\n这里声明了实现地图用到的一些材料，当然最关键的是MAMapView了，这个View是高德提供的哦。\n\n### 4.4 数据声明\n\n```Swift\n// Data\nvar navTitle: String?                                       // Nav标题 (可选)\nweak var delegate: GMLocationPickerControllerDelegate?      // 代理\nvar locationResultBlock: GMLocationResultHandler?\n\nprivate var locationInfos = [GMLocationPickerLocationInfo]()// 搜索 地点信息\nprivate var selectingLocationInfo: GMLocationPickerLocationInfo? // 选中地点信息\n\n// Pre Data\n\nvar preLocationInfo: GMLocationPickerLocationInfo?          // 预地理位置信息\nvar preCoordinate: CLLocationCoordinate2D?                  // 预经纬度\nvar preKeyword: String?                                     // 预搜索关键词\nvar pickerFor: GMLocationPickerFor = .warehouseCreate       // 地图选择用于\n```\n这里大致列举了需要用的数据。\n预数据，就是外部传过来的数据，然后我们新建了两个info实体报错搜索的地址和选中的地址。\n\n### 4.5 其它成员声明\n\n```Swift\n// Tool\nprivate var search: AMapSearchAPI!                          // 地图 搜索功能\nprivate var locationManager: AMapLocationManager!           // 地图 定位功能\nprivate var authorizationManager = TYLocationAuthorization()// 权限管理\n\n// flag\n\nprivate var lastSearchKey = \"\"                              // 最后搜索字段\nprivate var isRegionChangedFromCustomer = false             // 地图领域变化原因为用户手动滑动\nprivate var isReGeoRequestForSubmit = false                 // 逆地理请求用于提交\nprivate var viewDidAppear = false  \n```\n\n这里是一些工具和一些flag变量，工具包含地图搜索接口和地图定位功能工具，这些都是高德提供，另外权限是自定义的一个工具来处理的。\n\n### 4.6 生命周期之viewDidLoad\n\n这个走一次，看下做了什么：\n```Swift\noverride func viewDidLoad() {\n        super.viewDidLoad()\n        self.layoutSubviews()\n        self.loadData()\n    }\n```\n加载了子View，然后去加载数据。\n```Swift\nprivate func layoutSubviews() {\n        \n        self.view.backgroundColor = .white\n        \n        // ------------------------- 导航栏 -------------------------\n        let submitBtnF: UIFont = .pingFangRegular(size: 16.0)\n        \n        let btn_submit = UIButton()\n        btn_submit.isEnabled = false\n        btn_submit.ty_setButtonWith(text: \"提交\", font: submitBtnF, color: .ty_409EFF, state: .normal)\n        btn_submit.ty_setButtonWith(text: \"提交\", font: submitBtnF, color: .ty_409EFF.alpha(0.5), state: .disabled)\n        btn_submit.addTarget(self, action: #selector(act_submitBtnClicked(button:)), for: .touchUpInside)\n        let item_submit = UIBarButtonItem(customView: btn_submit)\n        self.navigationItem.rightBarButtonItem = item_submit\n        self.btn_submit = btn_submit\n        \n        // ------------------------- 底部控件 -------------------------\n        let searchListBGW: CGFloat = yScreenWidth\n        let searchListBGH: CGFloat = 104.0\n        let searchListBGR = CGRect(x: 0, y: 0, width: searchListBGW, height: searchListBGH)\n        let searchListBGRadius = 16.0\n        let searchListBGRadiusS = CGSize(width: searchListBGRadius, height: searchListBGRadius)\n        \n        let view_searchListBG = UIView.ty_viewWith(bgColor: .ty_ThemeWhite)\n        view_searchListBG.ty_setCornerWith(rect: searchListBGR, corners: [.topLeft, .topRight], radii: searchListBGRadiusS)\n        self.view.addSubview(view_searchListBG)\n        view_searchListBG.snp.makeConstraints { make in\n            make.bottom.equalTo(self.view.snp.bottom)\n            make.centerX.equalTo(self.view)\n            make.width.equalTo(searchListBGW)\n            make.height.equalTo(searchListBGH)\n        }\n        \n        // 搜索栏\n        let searchBtnF: UIFont = .pingFangRegular(size: 14.0)\n        let searchBtnW: CGFloat = 80.0\n        let searchBtnH: CGFloat = 32.0\n        let searchBarTextFF: UIFont = .pingFangRegular(size: 14.0)\n        let searchBarTextFLeftImageS = CGSize(width: 16.0, height: 16.0)\n        let searchBarTextFLeftViewS = CGSize(width: 32.0, height: 32.0)\n        let searchBarTextFR: CGFloat = 10.0\n        let searchBarTextFH: CGFloat = searchBtnH\n        \n        // 搜索按钮\n        let btn_search = UIButton()\n        btn_search.ty_setButtonWith(text: \"搜索\", font: searchBtnF, color: .ty_TextWhite, state: .normal)\n        btn_search.ty_setBackgroundColor(.ty_409EFF, state: .normal)\n        btn_search.ty_setCornerRadius(searchBtnH/2.0)\n        btn_search.addTarget(self, action: #selector(act_searchBtnClicked(button:)), for: .touchUpInside)\n        \n        view_searchListBG.addSubview(btn_search)\n        btn_search.snp.makeConstraints { make in\n            make.top.equalTo(view_searchListBG).offset(ySuperVerPad)\n            make.right.equalTo(view_searchListBG).offset(-ySuperHorPad)\n            make.width.equalTo(searchBtnW)\n            make.height.equalTo(searchBtnH)\n        }\n        \n        // 搜索栏\n        let textF_search = UITextField.ty_textFieldWith(font: searchBarTextFF, color: .ty_222222)\n        textF_search.backgroundColor = .ty_F7F9FA\n        textF_search.ty_setPlaceholderWith(placeholder: \"请输入地址\", color: .ty_9B9DA7, font: searchBarTextFF)\n        textF_search.ty_setLeftPaddingImage(imageName: \"locationPicker_img_search\", imageSize: searchBarTextFLeftImageS, paddingSize: searchBarTextFLeftViewS)\n        textF_search.ty_setCornerRadius(searchBarTextFH/2.0)\n        \n        textF_search.addTarget(self, action: #selector(act_searchTextFEditChange(textF:)), for: .editingChanged)\n        textF_search.addObserver(self, forKeyPath: \"text\", options: [.new, .old], context: nil)\n        \n        textF_search.delegate = self\n        textF_search.returnKeyType = .search\n        \n        view_searchListBG.addSubview(textF_search)\n        self.textF_search = textF_search\n        textF_search.snp.makeConstraints { make in\n            make.top.equalTo(view_searchListBG).offset(ySuperVerPad)\n            make.left.equalTo(view_searchListBG).offset(ySuperHorPad)\n            make.right.equalTo(btn_search.snp.left).offset(-searchBarTextFR)\n            make.height.equalTo(searchBarTextFH)\n        }\n        \n        // TableView\n        let tableViewT: CGFloat = 6.0\n        \n        let tableView = TYTableView(delegate: self, dataSource: self, style: .plain)\n        tableView.showsVerticalScrollIndicator = false\n        view_searchListBG.addSubview(tableView)\n        self.tableView = tableView\n        tableView.snp.makeConstraints { make in\n            make.top.equalTo(textF_search.snp.bottom).offset(tableViewT)\n            make.left.equalTo(view_searchListBG)\n            make.right.equalTo(view_searchListBG)\n            make.bottom.equalTo(view_searchListBG)\n        }\n        \n        // loading 旋转图\n        let indicatorStyle: UIActivityIndicatorView.Style\n        if #available(iOS 13.0, * ) {\n            indicatorStyle = .medium\n        } else {\n            indicatorStyle = .gray\n        }\n        let ai_spinner = UIActivityIndicatorView(style: indicatorStyle)\n        ai_spinner.startAnimating()\n        view_searchListBG.addSubview(ai_spinner)\n        self.ai_spinner = ai_spinner\n        ai_spinner.snp.makeConstraints { make in\n            make.center.equalTo(view_searchListBG)\n        }\n        \n        // ------------------------- mapView -------------------------\n        let mapViewW: CGFloat = yScreenWidth\n        let mapViewH: CGFloat = yScreenHeight - searchListBGH + searchListBGRadius/2.0\n        let cus_mapViewR = CGRect(x: 0, y: 0, width: mapViewW, height: mapViewH)\n        \n        // MapView\n        let mapView = MAMapView(frame: cus_mapViewR)\n        mapView.zoomLevel = 13.0                // 缩放比例\n        mapView.showsCompass = false            // 显示罗盘\n        mapView.showsScale = false              // 显示比例尺\n        mapView.delegate = self\n        self.view.addSubview(mapView)\n        self.mapView = mapView\n        \n        // 大头针\n        let pointAnnotationImgVW: CGFloat = 40.0\n        let pointAnnotationImgVH: CGFloat = 40.0\n        let imgV_pointAnnotation = UIImageView.ty_imageViewWith(imageName: \"locationPicker_icon_point_annotation\")\n        self.view.addSubview(imgV_pointAnnotation)\n        self.imgV_pointAnnotation = imgV_pointAnnotation\n        imgV_pointAnnotation.snp.makeConstraints { make in\n            make.centerX.equalTo(mapView)\n            make.centerY.equalTo(mapView).offset(-pointAnnotationImgVH/2.0)\n            make.width.equalTo(pointAnnotationImgVW)\n            make.height.equalTo(pointAnnotationImgVH)\n        }\n        \n        // 回归定位按钮\n        let locatedBtnWH: CGFloat = 46.0\n        let locatedBtnR: CGFloat = 9.0\n        let locatedBtnB: CGFloat = 9.0\n        \n        let btn_located = UIButton()\n        btn_located.setImage(UIImage(named: \"locationPicker_btn_located_Blue\"), for: .selected)     // 在当前定位\n        btn_located.setImage(UIImage(named: \"locationPicker_btn_located_Black\"), for: .normal)      // 不在当前定位\n        btn_located.addTarget(self, action: #selector(act_locatedBtnClicked(button:)), for: .touchUpInside)\n        self.view.addSubview(btn_located)\n        self.btn_located = btn_located\n        btn_located.snp.makeConstraints { make in\n            make.right.equalTo(self.view).offset(-locatedBtnR)\n            make.bottom.equalTo(view_searchListBG.snp.top).offset(-locatedBtnB)\n            make.width.equalTo(locatedBtnWH)\n            make.height.equalTo(locatedBtnWH)\n        }\n        \n        self.view.bringSubviewToFront(view_searchListBG)\n    }\n```\n逻辑也是非常清晰，一个一个把视图堆叠进去了。\n这里大头针跟地图一点关系没有，这个只是把大头针放在中间而已。没有跟地图绑定任何关系。\n\n然后去加载数据：\n```Swift\nprivate func loadData() {\n    // 设置标题\n    if let navTitle = self.navTitle, !navTitle.isEmpty {\n        self.title = \"\\(navTitle) 地图定位\"\n    } else {\n        self.title = \"地图定位\"\n    }\n    \n    // 定位功能\n    // 更新App是否显示隐私弹窗的状态，隐私弹窗是否包含高德SDK隐私协议内容的状态\n    AMapLocationManager.updatePrivacyShow(.didShow, privacyInfo: .didContain)\n    // 更新用户授权高德SDK隐私协议状态\n    AMapLocationManager.updatePrivacyAgree(.didAgree)\n    let locationManager = AMapLocationManager()\n    locationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters\n    if #available(iOS 14.0, *) {\n        locationManager.locationAccuracyMode = .fullAccuracy\n    }\n    self.locationManager = locationManager\n    \n    // 搜索\n    let search = AMapSearchAPI()\n    search?.timeout = 10\n    search?.delegate = self\n    self.search = search\n    \n    // 预地理位置信息处理\n    self.data_preLocatedHandle(locationInfo: self.preLocationInfo,\n                                preCoordinate: self.preCoordinate,\n                                preKeyword: self.preKeyword)\n}\n```\n这里设置了标题，然后就去走预地理位置信息处理的方法。这里的pre相关的数据，在跳转前，就给这个controller赋值了，这里跟Android不太一样，Android还要通过intent来传，它这个居然可以直接用controller的实例传值。\n\n具体预制方法为：\n```Swift\n/// 根据预地理位置信息 按照优先级 决定预定位方式\nfunc data_preLocatedHandle(locationInfo: GMLocationPickerLocationInfo? = nil,\n                            preCoordinate: CLLocationCoordinate2D? = nil, preKeyword: String? = nil) {\n    \n    // 预定位处理规则\n    // 完整数据 - 经纬度 - 位置关键词 - 实时定位 - 默认'北京'定位\n    if let preLocationInfo = locationInfo {\n        // 1.完整信息\n        if let coordinate = preLocationInfo.coordinate,\n            coordinate.latitude != 0, coordinate.longitude != 0 {\n            // 1.1 经纬度信息完整\n            self.data_changeRegionTo(preLocationInfo, for: .itemSelected)\n            self.map_searchLocationForNearby()  // 搜索附近\n        } else if !preLocationInfo.address.isEmpty {\n            // 1.2 无经纬度、有地名：搜索地名\n            let searchKey = \"\\(preLocationInfo.city)\\(preLocationInfo.district)\\(preLocationInfo.address)\"\n            self.data_preLocatedHandle(preKeyword: searchKey)\n        } else {\n            // 1.3 都没有：默认操作\n            self.data_preLocatedHandle()\n        }\n    } else if let preCoordinate = preCoordinate {\n        // 2.显示经纬度位置\n        self.mapView.centerCoordinate = preCoordinate\n        self.map_searchLocationForReGeo(isForSubmit: false) // 搜索逆地理编码\n    } else if let preKeyword = preKeyword, preKeyword.count > 0 {\n        // 3.关键词配置\n        self.textF_search.text = preKeyword\n        self.act_searchBtnClicked(button: nil)\n    } else {\n        var isLocationEnable = self.authorizationManager.isLocationAuthroizationEnable()\n        if #available(iOS 14.0, *) {\n            isLocationEnable = isLocationEnable && self.authorizationManager.isAccuracyAuthorizationFull()\n        }\n        if isLocationEnable {\n            // 4.实时定位\n            self.act_locatedBtnClicked(button: nil)\n        } else {\n            // 5.默认北京\n            self.mapView.centerCoordinate = CLLocationCoordinate2D(latitude: 39.909115, longitude: 116.397535)\n            self.map_searchLocationForReGeo(isForSubmit: false) // 搜索逆地理编码\n        }\n    }\n}\n```\n这里就是一段逻辑，如果之前有地址，然后如何去显示的逻辑。如何去移动地图。\n主要是用了一个 self.mapView.centerCoordinate来设置地图中心坐标，然后这里调用搜索词是走了这个方法：\n```Swift\n/// 根据当前地图中间位置 搜索逆地理\n/// - Parameter isForSubmit: 用于提交 or 用户滑动地理获取(顺带搜索附近)\nprivate func map_searchLocationForReGeo(isForSubmit: Bool) {\n    self.isReGeoRequestForSubmit = isForSubmit\n    if isForSubmit {\n        self.ty_showLoadingHUD()\n    } else {\n        // 清空列表数据\n        self.data_reloadTableViewToEmpty(forRequest: true)\n    }\n    \n    // 取消上一个请求\n    self.search.cancelAllRequests()\n    \n    // 逆地理位置请求\n    let coordinate = self.mapView.centerCoordinate\n    let regeo = AMapReGeocodeSearchRequest()\n    regeo.location = AMapGeoPoint.location(withLatitude: coordinate.latitude, longitude: coordinate.longitude)\n    regeo.requireExtension = true\n    self.search.aMapReGoecodeSearch(regeo)\n}\n```\n这里根据地图中心位置调用了搜索接口,具体请求在这里：\n```Swift\nself.search.aMapReGoecodeSearch(regeo)\n```\n\n如何搜索附近地址呢？\n```Swift\n/// 根据选中位置 搜索附近POI\nprivate func map_searchLocationForNearby() {\n    guard let coordinate = self.selectingLocationInfo?.coordinate else { return }\n    // 清空列表数据\n    self.data_reloadTableViewToEmpty(forRequest: true)\n    \n    // 取消上一个请求\n    self.search.cancelAllRequests()\n    \n    // 附近搜索请求\n    let aroundRequest = AMapPOIAroundSearchRequest()\n    let geoPoint = AMapGeoPoint.location(withLatitude: coordinate.latitude,\n                                            longitude: coordinate.longitude)\n    aroundRequest.location = geoPoint\n//        aroundRequest.special = true\n    self.search.aMapPOIAroundSearch(aroundRequest)\n}\n```\n跟上面方法也比较类似。\n\n### 4.7 生命周期之viewWillAppear\n\n```Swift\noverride func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n        setupWhiteNavBarColor()\n        setupWhiteClickCallBack()\n        \n        isHiddenNavBar(isHidden: false)\n    }\n```\n主要处理了导航栏相关的。\n\n### 4.8 生命周期之viewDidAppear\n\n```Swift\noverride func viewDidAppear(_ animated: Bool) {\n        super.viewDidAppear(animated)\n        self.viewDidAppear = true\n    }\n```\n这里没干啥，就设置了一个flag。\n\n### 4.9 析构函数\n\n```Swift\ndeinit {\n        self.tydev_logDeinit()\n    }\n```\n这里也没干啥，打印下日志：\n```Swift\n/// 输出对象销毁日志\nfunc tydev_logDeinit() {\n    self.tydev_logDeinit(nil)\n}\n\n/// 输出对象销毁日志\n/// - Parameter mark: 自定义标识\nfunc tydev_logDeinit(_ mark: String?) {\n    if let mark = mark {\n        print(\">>>>>>>>>>>>>>> deinit view [\\(self)] (\\(mark) <<<<<<<<<<<<<<<\")\n    } else {\n        print(\">>>>>>>>>>>>>>> deinit view [\\(self)] <<<<<<<<<<<<<<<\")\n    }\n}\n```\n\n### 4.10 地图代理\n\n前面我们设置了代理为自己，需要处理下：\n```Swift\n// 地图Delegate - Map\nextension GMLocationPickerController : MAMapViewDelegate {\n    \n    /// 地图区域改变完成后会调用此接口\n    func mapView(_ mapView: MAMapView!, regionDidChangeAnimated animated: Bool) {\n        if !self.viewDidAppear { return }\n        \n        // 大头针动画\n        self.ui_pointAnnotationAnimate()\n        if self.isRegionChangedFromCustomer, self.mapView.userTrackingMode == .none {\n            // 用户手动滑动模式\n            // 搜索逆地理编码(顺带搜索附近)\n            self.map_searchLocationForReGeo(isForSubmit: false)\n        }\n        self.isRegionChangedFromCustomer = true\n    }\n}\n```\n这里是高德自己调用的，估计是滑动后区域改变，这里会走。\n这里我们走完后需要顺带搜索下附近地址，所以需要加上我们自己逻辑哦。\n\n### 4.11 搜索代理\n\n```Swift\n// 地图Delegate - Search\nextension GMLocationPickerController : AMapSearchDelegate {\n    /// POI查询回调函数 [定位获取附近POI、搜索POI]\n    func onPOISearchDone(_ request: AMapPOISearchBaseRequest!, response: AMapPOISearchResponse!) {\n//        if response.pois.count <= 0 {\n//            GMBannerTips.showWarningTips(\"没有找到定位\")\n//            data_reloadTableViewToEmpty(forRequest: false)\n//            return\n//        }\n        \n        let prefixPois = response.pois.prefix(20)     // 最多获取20个数据\n        var locationInfos = prefixPois.map({ GMLocationPickerLocationInfo(mapPOI: $0) })\n        \n        if request.isKind(of: AMapPOIKeywordsSearchRequest.self) {\n            // 1. 搜索关键词(搜索关键词)\n            \n            // 没有搜索到则提示\n            if response.pois.count <= 0 {\n                GMBannerTips.showWarningTips(\"没有找到定位\")\n                data_reloadTableViewToEmpty(forRequest: false)\n                return\n            }\n            \n            // 自动选择第一个位置\n            var selectingInfo = self.selectingLocationInfo\n            if let firstInfo = locationInfos.first {\n                selectingInfo = firstInfo\n                // 移动地图位置\n                self.data_changeRegionTo(firstInfo, for: .keywordSearchSelected)\n            }\n            // 搜索POI距离补全\n            if let selectingInfo = selectingInfo, let selectingCoordinate = selectingInfo.coordinate {\n                let selectingPoint = MAMapPointForCoordinate(selectingCoordinate)\n                for currLocationInfo in locationInfos {\n                    if selectingInfo == currLocationInfo { continue }\n                    if let currCoordinate = currLocationInfo.coordinate {\n                        let currPoint = MAMapPointForCoordinate(currCoordinate)\n                        currLocationInfo.distance = Int(MAMetersBetweenMapPoints(selectingPoint,currPoint))\n                    }\n                }\n            }\n            \n        } else if request.isKind(of: AMapPOIAroundSearchRequest.self) {\n            // 2. 搜索附近位置(定位or选中)\n            \n            // 没有找到定位 则选中当前选中的定位\n            if prefixPois.count <= 0, let selectingInfo = self.selectingLocationInfo {\n                locationInfos.insert(selectingInfo, at: 0)\n            }\n            \n            // 则确保第一个选项为当前地理位置（不匹配则手动添加）\n            if let firstInfo = locationInfos.first, let selectingInfo = self.selectingLocationInfo,\n               firstInfo.poiName != selectingInfo.poiName, firstInfo.address != selectingInfo.address {\n                // 当前第一个位置 非选中中位置\n                locationInfos.insert(selectingInfo, at: 0)\n            }\n            if let firstInfo = locationInfos.first {\n                // 纠正/同步选择中地理位置\n                self.selectingLocationInfo = firstInfo\n            }\n        }\n        \n        // 刷新TableView数据\n        self.data_reloadTableViewWith(locationInfos: locationInfos)\n    }\n    \n    /// 逆地理编码回调 [手动滑动地图时用]\n    func onReGeocodeSearchDone(_ request: AMapReGeocodeSearchRequest!, response: AMapReGeocodeSearchResponse!) {\n        if self.isReGeoRequestForSubmit {\n            // 1. 用于提交的逆地理编码搜索\n            self.ty_hideLoadingHUD()\n            self.isReGeoRequestForSubmit = false\n            \n            guard let location = request.location, let regeocode = response.regeocode else { return }\n            \n            self.view.endEditing(true)\n            let selectingInfo = GMLocationPickerLocationResult(location: location, reGeocode: regeocode, locationInfo: self.selectingLocationInfo)\n            \n            // 提交地址\n            self.delegate?.locationPickerController(self, didSubmit: selectingInfo)\n            locationResultBlock?(selectingInfo)\n            self.popViewController()\n        } else {\n            // 2. 用于用户滑动的逆地理编码搜索\n            guard let location = request.location, let regeocode = response.regeocode else { return }\n            \n            // 设置 locationInfos\n            let prefixPois = regeocode.pois.prefix(20)     // 最多获取20个数据\n            var locationInfos = prefixPois.map({ GMLocationPickerLocationInfo(mapPOI: $0) })\n            \n            let selectingInfo = GMLocationPickerLocationInfo(location: location, reGeocode: regeocode)\n            // 移动地图位置\n            self.data_changeRegionTo(selectingInfo, for: .slideByCustomer)\n            locationInfos.insert(selectingInfo, at: 0)\n            \n            // 刷新TableView数据\n            self.data_reloadTableViewWith(locationInfos: locationInfos)\n        }\n    }\n    \n    /// 当请求发生错误 (timeout)\n    func aMapSearchRequest(_ request: Any!, didFailWithError error: Error!) {\n        let errorCode = error._code\n        \n        var errMsg = \"\"\n        if let searchErrorCode = AMapSearchErrorCode(rawValue: errorCode) {\n            switch searchErrorCode {\n            case .notConnectedToInternet:   break// 网络连接异常\n                //errMsg = AMapSearchError.errorInfo(with: searchErrorCode)\n            default:\n                break\n            }\n        } else {\n            print(\"asdf\")\n        }\n        if !errMsg.isEmpty {\n            self.ty_showMsgHud(errMsg)\n        }\n    }\n    \n}\n```\n这里是高德提供的搜索代理。\n一个是手动滑动，一个是自行搜索，走接口不一样哦。\n\n### 4.12 其它代理\n\n```Swift\n\n// TableView Delegate\nextension GMLocationPickerController: UITableViewDelegate, UITableViewDataSource {\n    \n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        return self.locationInfos.count\n    }\n\n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n        let cell = GMLocationPickerCell.cellWithTableView(tableView)\n        cell.locationInfo = self.locationInfos[indexPath.row]\n        return cell\n    }\n    \n    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n        return GMLocationPickerCell.cellHeight()\n    }\n    \n    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n        let locationInfo = self.locationInfos[indexPath.row]\n        // 清除搜索栏内容\n        self.ui_clearSearchTextF()\n        // 移动地图位置\n        self.data_changeRegionTo(locationInfo, for: .itemSelected)\n        // 搜索附近\n        self.map_searchLocationForNearby()\n    }\n}\n\n// 输入框 & 自定义 Delegate\nextension GMLocationPickerController : UITextFieldDelegate\n{\n    func textFieldShouldReturn(_ textField: UITextField) -> Bool {\n        // 搜索\n        self.act_searchBtnClicked(button: nil)\n        return true\n    }\n}\n```\n这里还用了2个代理，一个是搜索列表的tableView的列表展示，一个是搜索框代理。\n\n### 4.13 如何定位\n\n```Swift\n/// 定位当前位置\nprivate func map_requestLocation(_ completion: ((CLLocation?, AMapLocationReGeocode?) -> ())?) {\n    // 定位请求\n    func requestLocation(_ completion: ((CLLocation?, AMapLocationReGeocode?) -> ())?) {\n        // 单次定位\n        self.locationManager.requestLocation(withReGeocode: true, completionBlock: { (location: CLLocation?, reGeocode: AMapLocationReGeocode?, error: Error?) in\n            // 定位回调\n            if let completion = completion { completion(location, reGeocode) }\n        })\n    }\n    \n    let manager = self.authorizationManager\n    manager.verifyLocationAuthroization(showAlertIn: self, completion: {\n        if #available(iOS 14.0, *) {\n            manager.verifyAccuracyAuthroization(completion: {\n                requestLocation(completion)\n            }, failure: nil)\n        } else {\n            requestLocation(completion)\n        }\n    }, failure: nil)\n}\n```\n别慌，高德也是提供了方法，支持去定位。\n\n### 4.14 地址权限工具\n\n```Swift\n/// 地址权限管理器 配置\nclass TYLocationAuthorizationConfig: NSObject {\n    \n    // info.plist 上配置的 精读权限获取描述\n    // <key>NSLocationTemporaryUsageDescriptionDictionary</key>\n    var accuracyPurposeKey = \"AccuracyUsageDescription\"\n    \n    var locationAlertTitle = \"您需要开启GPS权限\"\n    var locationAlertMessage = \"地图定位需要获取您的GPS权限才能正常使用\"\n}\n\n/// 地址权限管理器\nclass TYLocationAuthorization: NSObject {\n    \n    //MARK: - property\n    \n    // Data\n    \n    private var locationManager: CLLocationManager!             // 定位权限管理\n    \n    private var locationAuthVerifyCompletion: (() -> ())?       // 定位权限获取完成Block (用于权限首次询问)\n    private var locationAuthVerifyFailure: (() -> ())?          // 定位权限获取失败Block (用于权限首次请求)\n    \n    private var config = TYLocationAuthorizationConfig()              // 文本相关配置\n    \n    // State\n    \n    /// 定位权限状态\n    var locationAuthorization: CLAuthorizationStatus {\n        if #available(iOS 14.0, *) {\n            return self.locationManager.authorizationStatus\n        } else {\n            return CLLocationManager.authorizationStatus()\n        }\n    }\n    \n    /// 精读权限状态\n    @available(iOS 14.0, *)\n    var accuracyAuthorization: CLAccuracyAuthorization {\n        return self.locationManager.accuracyAuthorization\n    }\n    \n    \n    //MARK: - life cycle\n    \n    convenience init(config: TYLocationAuthorizationConfig) {\n        self.init()\n        self.config = config\n    }\n    \n    override init() {\n        super.init()\n        self.loadData()\n    }\n    \n    private func loadData() {\n        // 定位权限管理\n        let locationManager = CLLocationManager()\n        locationManager.delegate = self\n        self.locationManager = locationManager\n    }\n    \n    deinit {\n        print(\">>>>>>>>>>>>>>> deinit view [\\(self)] <<<<<<<<<<<<<<<\")\n    }\n    \n    //MARK: - public methods\n    \n    // ------------------------- 权限请求封装 -------------------------\n    \n    /// 定位权限判断\n    func verifyLocationAuthroization(showAlertIn controller: UIViewController? = nil,\n                                     completion: (() -> ())? = nil,\n                                     failure: (() -> ())? = nil) {\n\n        switch self.locationAuthorization {\n        case .notDetermined:                            // 1. 首次打开App时\n            self.locationAuthVerifyCompletion = completion\n            self.locationAuthVerifyFailure = failure\n            self.locationManager.requestWhenInUseAuthorization()    // 使用时 *\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            self.ui_showAlertForDeniedLocationAuthorization(in: controller)\n            if let failure = failure { failure() }\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            if let completion  = completion { completion() }\n        @unknown default:                               // 4. 未知情况\n            self.ui_showAlertForDeniedLocationAuthorization(in: controller)\n            if let failure = failure { failure() }\n        }\n    }\n    \n    /// 精读权限判断(高精读)\n    @available(iOS 14.0, *)\n    func verifyAccuracyAuthroization(completion: (() -> ())? = nil,\n                                     failure: (() -> ())? = nil) {\n        if self.isAccuracyAuthorizationFull() {\n            if let completion = completion { completion() }\n        } else {\n            let key = self.config.accuracyPurposeKey\n            self.locationManager.requestTemporaryFullAccuracyAuthorization(withPurposeKey: key) { err in\n                if self.isAccuracyAuthorizationFull() {\n                    if let completion = completion { completion() }\n                } else {\n                    if let failure = failure { failure() }\n                }\n            }\n        }\n    }\n    \n    // ------------------------- 权限状态 -------------------------\n    \n    /// 定位权限是否被拒绝\n    func isLocationAuthroizationDenied() -> Bool {\n        switch self.locationAuthorization {\n        case .notDetermined:                            // 1. 首次打开App时\n            return false\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            return true\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            return false\n        @unknown default:                               // 4. 未知情况\n            return true\n        }\n    }\n    \n    /// 定位权限是否被允许\n    func isLocationAuthroizationEnable() -> Bool {\n        switch self.locationAuthorization {\n        case .notDetermined:                            // 1. 首次打开App时\n            return false\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            return false\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            return true\n        @unknown default:                               // 4. 未知情况\n            return false\n        }\n    }\n    \n    /// 精准定位\n    @available(iOS 14.0, *)\n    func isAccuracyAuthorizationFull() -> Bool {\n        return self.locationManager.accuracyAuthorization == .fullAccuracy\n    }\n    \n    //MARK: - private methods\n    \n    /// 显示定位权限拒绝 Alert\n    private func ui_showAlertForDeniedLocationAuthorization(in controller: UIViewController?) {\n        guard let controller = controller else { return }\n\n        let title = self.config.locationAlertTitle\n        let message = self.config.locationAlertMessage\n        let alertVC = UIAlertController.ty_doubleOptionAlertWith(title: title, message: message, optionTitle1: \"去设置\", action1: {\n            if let settingURL = URL(string: UIApplication.openSettingsURLString),\n                UIApplication.shared.canOpenURL(settingURL) {\n                UIApplication.shared.open(settingURL, options: [:], completionHandler: nil)\n            }\n        }, optionTitle2: \"取消\", action2: nil)\n        controller.present(alertVC, animated: true, completion: nil)\n    }\n    \n    \n    /// 清空 定位权限获取Block\n    private func clearLocationAuthorizationBlock() {\n        self.locationAuthVerifyCompletion = nil\n        self.locationAuthVerifyFailure = nil\n    }\n}\n\nextension TYLocationAuthorization : CLLocationManagerDelegate {\n    \n    /// 定位权限修改 (iOS 4.2 - 14.0)\n    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {\n        self.data_locationAuthorizationDidChange()\n    }\n    \n    /// 定位权限修改 (iOS 14.0+)\n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {\n        self.data_locationAuthorizationDidChange()\n    }\n    \n    /// 权限状态修改\n    private func data_locationAuthorizationDidChange() {\n        if self.locationAuthVerifyCompletion == nil, self.locationAuthVerifyFailure == nil { return }\n              \n        switch self.locationAuthorization {\n        case .notDetermined:                            // 1. 首次打开App时\n            break\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            if let failure = self.locationAuthVerifyFailure { failure() }\n            self.clearLocationAuthorizationBlock()\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            if let completion = self.locationAuthVerifyCompletion { completion() }\n            self.clearLocationAuthorizationBlock()\n        @unknown default:                               // 4. 未知情况\n            if let failure = self.locationAuthVerifyFailure { failure() }\n            self.clearLocationAuthorizationBlock()\n        }\n        \n    }\n}\n```\n这里需要考虑到多种情况，是否拒绝权限，是否拥有了权限以及不同手机系统的问题。\n用法也是相当简单：\n```Swift\nlet manager = self.authorizationManager\nmanager.verifyLocationAuthroization(showAlertIn: self, completion: {\n    if #available(iOS 14.0, *) {\n        manager.verifyAccuracyAuthroization(completion: {\n            requestLocation(completion)\n        }, failure: nil)\n    } else {\n        requestLocation(completion)\n    }\n}, failure: nil)\n```\n这个manager就是我们的工具类。\n\n大致就是这么多了。\n\n## 5 总结\n\n* 如果要做一个需要三方支持的东西，请务必要提前调研下，如地图，推送，埋点等，这些最后提前了解下三方的接入指南，这样更好去实现需求。\n\n* 高德地图对接非常简单，拿到key后，主要工作就是对Map的处理，用户行为二指缩放这种高德自行实现，我们只需要设置坐标给中间的位置即可。\n\n* 对于地图，一定要考虑是否有权限的情况，没有权限的情况也需要跳转到系统设置，这样才能加强用户体验。万万不可出现没有权限直接闪退的问题。\n\n* 一般做地图都会有一个搜索能力，这样就需要高德搜索接口了，需要了解AMapSearchAPI 这个接口的用法，定位的话就用到AMapLocationManager。","source":"_posts/iOS-swift-实现简易地图功能.md","raw":"---\ntitle: iOS swift 实现简易地图功能\ndate: 2023-01-31 15:27:26\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- 地图\ncategories:\n- iOS\n---\n\n## 1 需求定义\n\n产品需要我们实现这样一个需求，就是根据一个地址（可能有经纬度也可能没有）,然后跳转到地图页面去，地图中间会显示这个地址。运行用户自行点击定位，这样中间会显示当前位置。允许左右滑动，地图中心也会随之变更。支持搜索功能，根据用户搜索关键词，获取一个搜索列表。然后就是一个提交功能，这样需要将经纬度提交到服务端。\n\n大致是这样的需求。\n实现效果是这样的：\n<img src=map.png>\n\n## 2 需求分析\n\n根据产品的需求，我们考虑接入高德地图。所以我们需要事先调研下如何接入高德才行。\n\n其实这个应该非常简单，高德提供了Map，我们只需要将中间的坐标设置为我们自己的坐标。如果没有坐标，我们也调研高德的搜索接口，将搜索结果默认第一条，这应该是最准的吧，然后设置给高德的中间坐标即可。\n\n支持用户滑动，高德就应该支持的，这里应该会提供一个代理，我们在这个代理的回调类里面重新去调用下搜索接口，就能出现附近10条地址。\n\n二指放大，高德应该也是支持的，不需要我们额外设置啥。\n\n另外就是定位可能复杂一点，需要实现获取下定位权限，如果没有权限，需要跳转到系统设置。定位就不需要高德支持了，我们直接调用系统接口，获取经纬度，然后设置给高德就行了。\n\n## 3 准备工作：了解高德\n\n首先附上高德官方文档：[https://lbs.amap.com/api/ios-sdk/summary](https://lbs.amap.com/api/ios-sdk/summary)\n\n申请key这些工作就不用交给我们了，让产品自己申请吧。\n\n接入高德地图，做很复杂的需求，可以参考这篇文档，写得还不错：\n[https://www.jianshu.com/p/770728626874](https://www.jianshu.com/p/770728626874) 但是这个是objective-C，不过基本原理是类似的，还是有参考价值的。\n\n另外附上高德地图可配置参数：\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>logoCenter</td>\n<td>CGPoint</td>\n<td>可设置Logo的位置。必须在mapView.bounds之内，否则会被忽略。</td>\n</tr>\n<tr>\n<td>showsCompass</td>\n<td>Bool</td>\n<td>是否显示指南针。</td>\n</tr>\n<tr>\n<td>compassOrigin</td>\n<td>CGPoint</td>\n<td>设置指南针的位置。</td>\n</tr>\n<tr>\n<td>showsScale</td>\n<td>Bool</td>\n<td>是否显示比例值。</td>\n</tr>\n<tr>\n<td>scaleOrigin</td>\n<td>CGPoint</td>\n<td>设置比例尺的位置。</td>\n</tr>\n<tr>\n<td>zoomEnabled</td>\n<td>Bool</td>\n<td>是否开启缩放手势，默认true。</td>\n</tr>\n<tr>\n<td>scrollEnabled</td>\n<td>Bool</td>\n<td>是否开启滑动手势，默认true。</td>\n</tr>\n<tr>\n<td>rotateEnabled</td>\n<td>Bool</td>\n<td>是否开启旋转手势，默认true。</td>\n</tr>\n<tr>\n<td>rotateCameraEnabled</td>\n<td>Bool</td>\n<td>是否开启倾斜旋转手势，默认true。用户可以在地图上放置两个手指，移动它们一起向下或向上去增加或减小倾斜角。</td>\n</tr>\n<tr>\n<td>setZoomLevel</td>\n<td>CGFloat</td>\n<td>改变地图缩放级别。范围从3级到19级，共17级。级别越高，展示的内容越细，例如街道等等。</td>\n</tr>\n<tr>\n<td>setCenter</td>\n<td>CLLocationCoordinate2D</td>\n<td>改变地图中心的位置。传递具体的经纬度。</td>\n</tr>\n</tbody>\n</table>\n\n另外一个就是需要我们在AppDelegate中注册key：\n```Swift\n /// 设置高德地图\nfunc configAMap() {\n    AMapServices.shared().apiKey = \"你申请的key\"\n    AMapServices.shared().enableHTTPS = true\n}\n```\n\n这里，准备工作基本就完成了。\n\n## 4 代码实现\n\n### 4.1 新建两个实体类\n\n```Swift\nclass GMLocationPickerLocationResult: NSObject {\n    \n    //MARK: - property\n    \n    var coordinate: CLLocationCoordinate2D?     // 经纬度\n    \n    var poiName: String = \"\"                    // 名称\n    \n    var province: String = \"\"                   // 省\n    var provinceCode: String = \"\"               // 省编码\n    var city: String = \"\"                       // 市\n    var citycode: String = \"\"                   // 市编码\n    var district: String = \"\"                   // 区\n    var adcode: String = \"\"                     // 区编码\n    var township: String = \"\"                   // 乡镇街道\n    var towncode: String = \"\"                   // 乡镇街道编码(截取前9位)\n    \n    var detailAddress: String = \"\"              // 详细地址\n    var formattedAddress: String = \"\"           // 格式化全地址(4级+详细)\n    \n    var locationInfo: GMLocationPickerLocationInfo? //\n    \n    /// 模型转换\n    convenience init(location: AMapGeoPoint, reGeocode: AMapReGeocode, locationInfo: GMLocationPickerLocationInfo?) {\n        self.init()\n        \n        let latitude = location.latitude\n        let longitude = location.longitude\n        self.coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n        \n        if let locationInfo = locationInfo {\n            // 1.转换基础信息\n            self.poiName = locationInfo.poiName\n            self.province = locationInfo.province\n            self.city = locationInfo.city\n            self.district = locationInfo.district\n            self.township = locationInfo.street\n            self.detailAddress = locationInfo.address\n            self.formattedAddress = locationInfo.province + locationInfo.city + locationInfo.district + locationInfo.address\n        }\n        if let addressComponent = reGeocode.addressComponent {\n            // 2.转换所有信息\n            var poiName = \"\"\n            if let locationInfo = locationInfo {\n                poiName = locationInfo.poiName\n            } else if let aoisName = reGeocode.aois.first?.name {\n                poiName = aoisName\n            } else if let roadinterName = reGeocode.roadinters.first?.firstName {\n                poiName = roadinterName\n            } else {\n                poiName = addressComponent.township ?? \"\"\n            }\n            self.poiName = self.poiName.ty_forEmpty(poiName)\n            \n            self.province = self.province.ty_forEmpty(addressComponent.province ?? \"\")\n            self.city = self.city.ty_forEmpty(addressComponent.city ?? \"\")\n            self.district = self.district.ty_forEmpty(addressComponent.district ?? \"\")\n            self.township = self.township.ty_forEmpty(addressComponent.township ?? \"\")\n            self.formattedAddress = self.formattedAddress.ty_forEmpty(reGeocode.formattedAddress ?? \"\")\n        }\n        if let addressComponent = reGeocode.addressComponent {\n            // 设置编码\n            self.citycode = addressComponent.citycode ?? \"\"\n            self.adcode = addressComponent.adcode ?? \"\"\n            self.towncode = String(addressComponent.towncode.prefix(9)) // 截取前九位\n        }\n        // 设置省份编码 用自带plist\n        if let globalAddressModel = globalAddressModel {\n            for currProvince in globalAddressModel.data {\n                if currProvince.name == self.province {\n                    self.provinceCode = currProvince.code\n                    break\n                }\n            }\n        }\n        self.locationInfo = locationInfo\n    }\n}\n```\n\n这个用了一个convenience关键字来声明init，主要是覆写的作用，重载。可以参考这篇文章：[https://www.jianshu.com/p/09c6c88ed61e](https://www.jianshu.com/p/09c6c88ed61e)。这里面初始化已经用了高德的实体类AMapGeoPoint,这个包含了经纬度；AMapReGeocode，这个是逆地址编码；然后还有一个自定义实体，这个是Info，上面那个是result，info如下定义：\n\n```Swift\n\nclass GMLocationPickerLocationInfo: NSObject {\n    \n    //MARK: - property\n    \n    var coordinate: CLLocationCoordinate2D?     // 经纬度\n    \n    var poiName: String = \"\"                    // 名称\n    var province: String = \"\"                   // 省\n    var city: String = \"\"                       // 市\n    var district: String = \"\"                   // 区\n    var street: String = \"\"                     // 街道(*)\n    var number: String = \"\"                     // 门牌号(*)\n    \n    var address: String = \"\"                    // 地址(街道 + 门牌)\n    \n    var distance: Int = 0                       // 与选中点距离\n    \n    // UI\n    \n    var ui_isSelected = false                   // cell是否选中中\n    \n    //MARK: - life cycle\n    \n    // ------------------------- map 内转换 -------------------------\n    \n    /// 模型转换 根据 [实时定位]获取的 经纬度 & 逆地理信息\n    convenience init(coordinate: CLLocationCoordinate2D?, reGeocode: AMapLocationReGeocode?) {\n        self.init()\n        \n        self.coordinate = coordinate\n        \n        self.poiName = reGeocode?.poiName ?? \"\"\n        self.province = reGeocode?.province ?? \"\"\n        self.city = reGeocode?.city ?? \"\"\n        self.district = reGeocode?.district ?? \"\"\n        self.street = reGeocode?.street ?? \"\"\n        self.number = reGeocode?.number ?? \"\"\n        self.address = (self.street + self.number)\n        if self.street.isEmpty || self.number.isEmpty {\n            let detailAddress = reGeocode?.formattedAddress ?? \"\"\n            self.address = abbreviationAddressIn(detailAddress: detailAddress, province: province, city: city, district: district)\n        }\n        \n        self.distance = 0\n    }\n    \n    /// 模型转换 根据 [搜索{附近|关键词}]获取的 POI模型\n    convenience init(mapPOI: AMapPOI) {\n        self.init()\n        \n        if let location = mapPOI.location {\n            let latitude = location.latitude\n            let longitude = location.longitude\n            self.coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n        }\n        \n        self.poiName = mapPOI.name\n        self.province = mapPOI.province\n        self.city = mapPOI.city\n        self.district = mapPOI.district\n        self.street = \"\"\n        self.number = \"\"\n        self.address = mapPOI.address\n        \n        self.distance = mapPOI.distance // 周边搜索可用\n    }\n    \n    /// 模型转换 根据 [逆地理编码]获取的 经纬度 & 逆地理编码结果\n    convenience init(location: AMapGeoPoint, reGeocode: AMapReGeocode) {\n        self.init()\n        \n        let addressComponent = reGeocode.addressComponent\n        \n        let latitude = location.latitude\n        let longitude = location.longitude\n        self.coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n        \n        if let aoisName = reGeocode.aois.first?.name {\n            self.poiName = aoisName\n        } else if let roadinterName = reGeocode.roadinters.first?.firstName {\n            self.poiName = roadinterName\n        } else {\n            self.poiName = addressComponent?.township ?? \"\"\n        }\n        self.province = addressComponent?.province ?? \"\"\n        self.city = addressComponent?.city ?? \"\"\n        self.district = addressComponent?.district ?? \"\"\n        self.street = addressComponent?.streetNumber?.street ?? \"\"\n        self.number = addressComponent?.streetNumber?.number ?? \"\"\n        self.address = (self.street + self.number)\n        if self.street.isEmpty || self.number.isEmpty {\n            let detailAddress = reGeocode.formattedAddress ?? \"\"\n            self.address = abbreviationAddressIn(detailAddress: detailAddress, province: province, city: city, district: district)\n        }\n        self.distance = 0\n    }\n    \n    /// 详细地址中获取缩略地址\n    /// - Parameters:\n    ///   - detailAddress: 详细地址\n    ///   - province: 省份\n    ///   - city: 城市\n    ///   - district: 区域\n    private func abbreviationAddressIn(detailAddress: String, province: String, city: String, district: String) -> String {\n        var address = detailAddress\n        address = address.replacingOccurrences(of: province, with: \"\")\n        address = address.replacingOccurrences(of: city, with: \"\")\n        address = address.replacingOccurrences(of: city, with: \"\")\n        return address\n    }\n    \n    // ------------------------- model 转换 -------------------------\n    \n    /// 模型转换 根据 地理信息结果模型\n    convenience init(locationResult: GMLocationPickerLocationResult) {\n        self.init()\n        \n        self.coordinate = locationResult.coordinate\n        \n        self.poiName = locationResult.poiName\n        self.province = locationResult.province\n        self.city = locationResult.city\n        self.district = locationResult.district\n        let street = locationResult.township\n        self.address = street\n        \n        self.distance = 0\n    }\n    \n    /// 模型转换 根据 仓库模型\n    convenience init(warehouseInfo: GMWarehouseInfoHomeList) {\n        self.init()\n        \n        self.coordinate = warehouseInfo.cus_coordinate\n        \n        self.poiName = warehouseInfo.name\n        self.province = warehouseInfo.province\n        self.city = warehouseInfo.city\n        self.district = warehouseInfo.region\n        self.street = \"\"\n        self.number = \"\"\n        self.address = warehouseInfo.address\n        \n        self.distance = 0\n    }\n    \n    /// 模型转换 根据 门店模型\n    convenience init(storeInfo: GMStoreInfoHomeModel) {\n        self.init()\n        \n        self.coordinate = storeInfo.cus_coordinate\n        \n        self.poiName = storeInfo.shopName\n        self.province = storeInfo.shopProvince\n        self.city = storeInfo.shopCity\n        self.district = storeInfo.shopCounty\n        self.street = storeInfo.shopStreet\n        self.number = \"\"\n        self.address = storeInfo.shopAddress\n        \n        self.distance = 0\n    }\n}\n```\n这个是地图内部使用，上面那个实体，是为了更好对接服务端设定的一个实体。\n\n### 4.2 外部类定义\n\n```Swift\n/// 地图选择 闭包，向外吐出去\ntypealias GMLocationResultHandler = (GMLocationPickerLocationResult?) -> Swift.Void\n\nprotocol GMLocationPickerControllerDelegate: AnyObject {\n    /// 提交所选位置\n    func locationPickerController(_ collection: GMLocationPickerController, didSubmit locationInfo: GMLocationPickerLocationResult)\n    \n    /// 页面将要pop出\n    func locationPickerControllerWillPop(_ collection: GMLocationPickerController)\n}\n\n/// 从哪里进来的 枚举类\nenum GMLocationPickerFor {\n    case warehouseCreate                                        // 仓库创建\n    case warehouseEdit(warehouseInfo: GMWarehouseInfoHomeList)  // 仓库编辑\n    case storeEdit(storeInfo: GMStoreInfoHomeModel)             // 门店编辑\n}\n\n/// 选择地理位置的原因 什么时候走高德接口\nenum GMLocationPickerRegionChageFor {\n    case located                                                // 实时定位\n    case itemSelected                                           // 搜索项选择\n    case keywordSearchSelected                                  // 关键词搜索 自动选择(第一个)\n    case slideByCustomer                                        // 用户滑动逆地理\n}\n```\n这里定义了可能需要的枚举类和协议。\n枚举类主要跟我们自己业务有关系了，协议也是跟业务有关系。这里并不是实现地图的必须。\n\n### 4.3 UI声明\n\n```Swift\nclass GMLocationPickerController: GMBaseViewController {\n\n    //MARK: - property\n    \n    // UI\n    \n    private weak var btn_submit: UIButton!                      // 提交按钮\n    private weak var mapView: MAMapView!                        // 地图\n    private weak var textF_search: UITextField!                 // 搜索 输入栏\n    private weak var tableView: TYTableView!                    // 搜索 列表\n    private weak var ai_spinner: UIActivityIndicatorView!       // 加载loading\n    private weak var btn_located: UIButton!                     // 定位按钮\n    \n    private weak var imgV_pointAnnotation: UIImageView!         // 自定义大头针\n```\n\n这里声明了实现地图用到的一些材料，当然最关键的是MAMapView了，这个View是高德提供的哦。\n\n### 4.4 数据声明\n\n```Swift\n// Data\nvar navTitle: String?                                       // Nav标题 (可选)\nweak var delegate: GMLocationPickerControllerDelegate?      // 代理\nvar locationResultBlock: GMLocationResultHandler?\n\nprivate var locationInfos = [GMLocationPickerLocationInfo]()// 搜索 地点信息\nprivate var selectingLocationInfo: GMLocationPickerLocationInfo? // 选中地点信息\n\n// Pre Data\n\nvar preLocationInfo: GMLocationPickerLocationInfo?          // 预地理位置信息\nvar preCoordinate: CLLocationCoordinate2D?                  // 预经纬度\nvar preKeyword: String?                                     // 预搜索关键词\nvar pickerFor: GMLocationPickerFor = .warehouseCreate       // 地图选择用于\n```\n这里大致列举了需要用的数据。\n预数据，就是外部传过来的数据，然后我们新建了两个info实体报错搜索的地址和选中的地址。\n\n### 4.5 其它成员声明\n\n```Swift\n// Tool\nprivate var search: AMapSearchAPI!                          // 地图 搜索功能\nprivate var locationManager: AMapLocationManager!           // 地图 定位功能\nprivate var authorizationManager = TYLocationAuthorization()// 权限管理\n\n// flag\n\nprivate var lastSearchKey = \"\"                              // 最后搜索字段\nprivate var isRegionChangedFromCustomer = false             // 地图领域变化原因为用户手动滑动\nprivate var isReGeoRequestForSubmit = false                 // 逆地理请求用于提交\nprivate var viewDidAppear = false  \n```\n\n这里是一些工具和一些flag变量，工具包含地图搜索接口和地图定位功能工具，这些都是高德提供，另外权限是自定义的一个工具来处理的。\n\n### 4.6 生命周期之viewDidLoad\n\n这个走一次，看下做了什么：\n```Swift\noverride func viewDidLoad() {\n        super.viewDidLoad()\n        self.layoutSubviews()\n        self.loadData()\n    }\n```\n加载了子View，然后去加载数据。\n```Swift\nprivate func layoutSubviews() {\n        \n        self.view.backgroundColor = .white\n        \n        // ------------------------- 导航栏 -------------------------\n        let submitBtnF: UIFont = .pingFangRegular(size: 16.0)\n        \n        let btn_submit = UIButton()\n        btn_submit.isEnabled = false\n        btn_submit.ty_setButtonWith(text: \"提交\", font: submitBtnF, color: .ty_409EFF, state: .normal)\n        btn_submit.ty_setButtonWith(text: \"提交\", font: submitBtnF, color: .ty_409EFF.alpha(0.5), state: .disabled)\n        btn_submit.addTarget(self, action: #selector(act_submitBtnClicked(button:)), for: .touchUpInside)\n        let item_submit = UIBarButtonItem(customView: btn_submit)\n        self.navigationItem.rightBarButtonItem = item_submit\n        self.btn_submit = btn_submit\n        \n        // ------------------------- 底部控件 -------------------------\n        let searchListBGW: CGFloat = yScreenWidth\n        let searchListBGH: CGFloat = 104.0\n        let searchListBGR = CGRect(x: 0, y: 0, width: searchListBGW, height: searchListBGH)\n        let searchListBGRadius = 16.0\n        let searchListBGRadiusS = CGSize(width: searchListBGRadius, height: searchListBGRadius)\n        \n        let view_searchListBG = UIView.ty_viewWith(bgColor: .ty_ThemeWhite)\n        view_searchListBG.ty_setCornerWith(rect: searchListBGR, corners: [.topLeft, .topRight], radii: searchListBGRadiusS)\n        self.view.addSubview(view_searchListBG)\n        view_searchListBG.snp.makeConstraints { make in\n            make.bottom.equalTo(self.view.snp.bottom)\n            make.centerX.equalTo(self.view)\n            make.width.equalTo(searchListBGW)\n            make.height.equalTo(searchListBGH)\n        }\n        \n        // 搜索栏\n        let searchBtnF: UIFont = .pingFangRegular(size: 14.0)\n        let searchBtnW: CGFloat = 80.0\n        let searchBtnH: CGFloat = 32.0\n        let searchBarTextFF: UIFont = .pingFangRegular(size: 14.0)\n        let searchBarTextFLeftImageS = CGSize(width: 16.0, height: 16.0)\n        let searchBarTextFLeftViewS = CGSize(width: 32.0, height: 32.0)\n        let searchBarTextFR: CGFloat = 10.0\n        let searchBarTextFH: CGFloat = searchBtnH\n        \n        // 搜索按钮\n        let btn_search = UIButton()\n        btn_search.ty_setButtonWith(text: \"搜索\", font: searchBtnF, color: .ty_TextWhite, state: .normal)\n        btn_search.ty_setBackgroundColor(.ty_409EFF, state: .normal)\n        btn_search.ty_setCornerRadius(searchBtnH/2.0)\n        btn_search.addTarget(self, action: #selector(act_searchBtnClicked(button:)), for: .touchUpInside)\n        \n        view_searchListBG.addSubview(btn_search)\n        btn_search.snp.makeConstraints { make in\n            make.top.equalTo(view_searchListBG).offset(ySuperVerPad)\n            make.right.equalTo(view_searchListBG).offset(-ySuperHorPad)\n            make.width.equalTo(searchBtnW)\n            make.height.equalTo(searchBtnH)\n        }\n        \n        // 搜索栏\n        let textF_search = UITextField.ty_textFieldWith(font: searchBarTextFF, color: .ty_222222)\n        textF_search.backgroundColor = .ty_F7F9FA\n        textF_search.ty_setPlaceholderWith(placeholder: \"请输入地址\", color: .ty_9B9DA7, font: searchBarTextFF)\n        textF_search.ty_setLeftPaddingImage(imageName: \"locationPicker_img_search\", imageSize: searchBarTextFLeftImageS, paddingSize: searchBarTextFLeftViewS)\n        textF_search.ty_setCornerRadius(searchBarTextFH/2.0)\n        \n        textF_search.addTarget(self, action: #selector(act_searchTextFEditChange(textF:)), for: .editingChanged)\n        textF_search.addObserver(self, forKeyPath: \"text\", options: [.new, .old], context: nil)\n        \n        textF_search.delegate = self\n        textF_search.returnKeyType = .search\n        \n        view_searchListBG.addSubview(textF_search)\n        self.textF_search = textF_search\n        textF_search.snp.makeConstraints { make in\n            make.top.equalTo(view_searchListBG).offset(ySuperVerPad)\n            make.left.equalTo(view_searchListBG).offset(ySuperHorPad)\n            make.right.equalTo(btn_search.snp.left).offset(-searchBarTextFR)\n            make.height.equalTo(searchBarTextFH)\n        }\n        \n        // TableView\n        let tableViewT: CGFloat = 6.0\n        \n        let tableView = TYTableView(delegate: self, dataSource: self, style: .plain)\n        tableView.showsVerticalScrollIndicator = false\n        view_searchListBG.addSubview(tableView)\n        self.tableView = tableView\n        tableView.snp.makeConstraints { make in\n            make.top.equalTo(textF_search.snp.bottom).offset(tableViewT)\n            make.left.equalTo(view_searchListBG)\n            make.right.equalTo(view_searchListBG)\n            make.bottom.equalTo(view_searchListBG)\n        }\n        \n        // loading 旋转图\n        let indicatorStyle: UIActivityIndicatorView.Style\n        if #available(iOS 13.0, * ) {\n            indicatorStyle = .medium\n        } else {\n            indicatorStyle = .gray\n        }\n        let ai_spinner = UIActivityIndicatorView(style: indicatorStyle)\n        ai_spinner.startAnimating()\n        view_searchListBG.addSubview(ai_spinner)\n        self.ai_spinner = ai_spinner\n        ai_spinner.snp.makeConstraints { make in\n            make.center.equalTo(view_searchListBG)\n        }\n        \n        // ------------------------- mapView -------------------------\n        let mapViewW: CGFloat = yScreenWidth\n        let mapViewH: CGFloat = yScreenHeight - searchListBGH + searchListBGRadius/2.0\n        let cus_mapViewR = CGRect(x: 0, y: 0, width: mapViewW, height: mapViewH)\n        \n        // MapView\n        let mapView = MAMapView(frame: cus_mapViewR)\n        mapView.zoomLevel = 13.0                // 缩放比例\n        mapView.showsCompass = false            // 显示罗盘\n        mapView.showsScale = false              // 显示比例尺\n        mapView.delegate = self\n        self.view.addSubview(mapView)\n        self.mapView = mapView\n        \n        // 大头针\n        let pointAnnotationImgVW: CGFloat = 40.0\n        let pointAnnotationImgVH: CGFloat = 40.0\n        let imgV_pointAnnotation = UIImageView.ty_imageViewWith(imageName: \"locationPicker_icon_point_annotation\")\n        self.view.addSubview(imgV_pointAnnotation)\n        self.imgV_pointAnnotation = imgV_pointAnnotation\n        imgV_pointAnnotation.snp.makeConstraints { make in\n            make.centerX.equalTo(mapView)\n            make.centerY.equalTo(mapView).offset(-pointAnnotationImgVH/2.0)\n            make.width.equalTo(pointAnnotationImgVW)\n            make.height.equalTo(pointAnnotationImgVH)\n        }\n        \n        // 回归定位按钮\n        let locatedBtnWH: CGFloat = 46.0\n        let locatedBtnR: CGFloat = 9.0\n        let locatedBtnB: CGFloat = 9.0\n        \n        let btn_located = UIButton()\n        btn_located.setImage(UIImage(named: \"locationPicker_btn_located_Blue\"), for: .selected)     // 在当前定位\n        btn_located.setImage(UIImage(named: \"locationPicker_btn_located_Black\"), for: .normal)      // 不在当前定位\n        btn_located.addTarget(self, action: #selector(act_locatedBtnClicked(button:)), for: .touchUpInside)\n        self.view.addSubview(btn_located)\n        self.btn_located = btn_located\n        btn_located.snp.makeConstraints { make in\n            make.right.equalTo(self.view).offset(-locatedBtnR)\n            make.bottom.equalTo(view_searchListBG.snp.top).offset(-locatedBtnB)\n            make.width.equalTo(locatedBtnWH)\n            make.height.equalTo(locatedBtnWH)\n        }\n        \n        self.view.bringSubviewToFront(view_searchListBG)\n    }\n```\n逻辑也是非常清晰，一个一个把视图堆叠进去了。\n这里大头针跟地图一点关系没有，这个只是把大头针放在中间而已。没有跟地图绑定任何关系。\n\n然后去加载数据：\n```Swift\nprivate func loadData() {\n    // 设置标题\n    if let navTitle = self.navTitle, !navTitle.isEmpty {\n        self.title = \"\\(navTitle) 地图定位\"\n    } else {\n        self.title = \"地图定位\"\n    }\n    \n    // 定位功能\n    // 更新App是否显示隐私弹窗的状态，隐私弹窗是否包含高德SDK隐私协议内容的状态\n    AMapLocationManager.updatePrivacyShow(.didShow, privacyInfo: .didContain)\n    // 更新用户授权高德SDK隐私协议状态\n    AMapLocationManager.updatePrivacyAgree(.didAgree)\n    let locationManager = AMapLocationManager()\n    locationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters\n    if #available(iOS 14.0, *) {\n        locationManager.locationAccuracyMode = .fullAccuracy\n    }\n    self.locationManager = locationManager\n    \n    // 搜索\n    let search = AMapSearchAPI()\n    search?.timeout = 10\n    search?.delegate = self\n    self.search = search\n    \n    // 预地理位置信息处理\n    self.data_preLocatedHandle(locationInfo: self.preLocationInfo,\n                                preCoordinate: self.preCoordinate,\n                                preKeyword: self.preKeyword)\n}\n```\n这里设置了标题，然后就去走预地理位置信息处理的方法。这里的pre相关的数据，在跳转前，就给这个controller赋值了，这里跟Android不太一样，Android还要通过intent来传，它这个居然可以直接用controller的实例传值。\n\n具体预制方法为：\n```Swift\n/// 根据预地理位置信息 按照优先级 决定预定位方式\nfunc data_preLocatedHandle(locationInfo: GMLocationPickerLocationInfo? = nil,\n                            preCoordinate: CLLocationCoordinate2D? = nil, preKeyword: String? = nil) {\n    \n    // 预定位处理规则\n    // 完整数据 - 经纬度 - 位置关键词 - 实时定位 - 默认'北京'定位\n    if let preLocationInfo = locationInfo {\n        // 1.完整信息\n        if let coordinate = preLocationInfo.coordinate,\n            coordinate.latitude != 0, coordinate.longitude != 0 {\n            // 1.1 经纬度信息完整\n            self.data_changeRegionTo(preLocationInfo, for: .itemSelected)\n            self.map_searchLocationForNearby()  // 搜索附近\n        } else if !preLocationInfo.address.isEmpty {\n            // 1.2 无经纬度、有地名：搜索地名\n            let searchKey = \"\\(preLocationInfo.city)\\(preLocationInfo.district)\\(preLocationInfo.address)\"\n            self.data_preLocatedHandle(preKeyword: searchKey)\n        } else {\n            // 1.3 都没有：默认操作\n            self.data_preLocatedHandle()\n        }\n    } else if let preCoordinate = preCoordinate {\n        // 2.显示经纬度位置\n        self.mapView.centerCoordinate = preCoordinate\n        self.map_searchLocationForReGeo(isForSubmit: false) // 搜索逆地理编码\n    } else if let preKeyword = preKeyword, preKeyword.count > 0 {\n        // 3.关键词配置\n        self.textF_search.text = preKeyword\n        self.act_searchBtnClicked(button: nil)\n    } else {\n        var isLocationEnable = self.authorizationManager.isLocationAuthroizationEnable()\n        if #available(iOS 14.0, *) {\n            isLocationEnable = isLocationEnable && self.authorizationManager.isAccuracyAuthorizationFull()\n        }\n        if isLocationEnable {\n            // 4.实时定位\n            self.act_locatedBtnClicked(button: nil)\n        } else {\n            // 5.默认北京\n            self.mapView.centerCoordinate = CLLocationCoordinate2D(latitude: 39.909115, longitude: 116.397535)\n            self.map_searchLocationForReGeo(isForSubmit: false) // 搜索逆地理编码\n        }\n    }\n}\n```\n这里就是一段逻辑，如果之前有地址，然后如何去显示的逻辑。如何去移动地图。\n主要是用了一个 self.mapView.centerCoordinate来设置地图中心坐标，然后这里调用搜索词是走了这个方法：\n```Swift\n/// 根据当前地图中间位置 搜索逆地理\n/// - Parameter isForSubmit: 用于提交 or 用户滑动地理获取(顺带搜索附近)\nprivate func map_searchLocationForReGeo(isForSubmit: Bool) {\n    self.isReGeoRequestForSubmit = isForSubmit\n    if isForSubmit {\n        self.ty_showLoadingHUD()\n    } else {\n        // 清空列表数据\n        self.data_reloadTableViewToEmpty(forRequest: true)\n    }\n    \n    // 取消上一个请求\n    self.search.cancelAllRequests()\n    \n    // 逆地理位置请求\n    let coordinate = self.mapView.centerCoordinate\n    let regeo = AMapReGeocodeSearchRequest()\n    regeo.location = AMapGeoPoint.location(withLatitude: coordinate.latitude, longitude: coordinate.longitude)\n    regeo.requireExtension = true\n    self.search.aMapReGoecodeSearch(regeo)\n}\n```\n这里根据地图中心位置调用了搜索接口,具体请求在这里：\n```Swift\nself.search.aMapReGoecodeSearch(regeo)\n```\n\n如何搜索附近地址呢？\n```Swift\n/// 根据选中位置 搜索附近POI\nprivate func map_searchLocationForNearby() {\n    guard let coordinate = self.selectingLocationInfo?.coordinate else { return }\n    // 清空列表数据\n    self.data_reloadTableViewToEmpty(forRequest: true)\n    \n    // 取消上一个请求\n    self.search.cancelAllRequests()\n    \n    // 附近搜索请求\n    let aroundRequest = AMapPOIAroundSearchRequest()\n    let geoPoint = AMapGeoPoint.location(withLatitude: coordinate.latitude,\n                                            longitude: coordinate.longitude)\n    aroundRequest.location = geoPoint\n//        aroundRequest.special = true\n    self.search.aMapPOIAroundSearch(aroundRequest)\n}\n```\n跟上面方法也比较类似。\n\n### 4.7 生命周期之viewWillAppear\n\n```Swift\noverride func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n        setupWhiteNavBarColor()\n        setupWhiteClickCallBack()\n        \n        isHiddenNavBar(isHidden: false)\n    }\n```\n主要处理了导航栏相关的。\n\n### 4.8 生命周期之viewDidAppear\n\n```Swift\noverride func viewDidAppear(_ animated: Bool) {\n        super.viewDidAppear(animated)\n        self.viewDidAppear = true\n    }\n```\n这里没干啥，就设置了一个flag。\n\n### 4.9 析构函数\n\n```Swift\ndeinit {\n        self.tydev_logDeinit()\n    }\n```\n这里也没干啥，打印下日志：\n```Swift\n/// 输出对象销毁日志\nfunc tydev_logDeinit() {\n    self.tydev_logDeinit(nil)\n}\n\n/// 输出对象销毁日志\n/// - Parameter mark: 自定义标识\nfunc tydev_logDeinit(_ mark: String?) {\n    if let mark = mark {\n        print(\">>>>>>>>>>>>>>> deinit view [\\(self)] (\\(mark) <<<<<<<<<<<<<<<\")\n    } else {\n        print(\">>>>>>>>>>>>>>> deinit view [\\(self)] <<<<<<<<<<<<<<<\")\n    }\n}\n```\n\n### 4.10 地图代理\n\n前面我们设置了代理为自己，需要处理下：\n```Swift\n// 地图Delegate - Map\nextension GMLocationPickerController : MAMapViewDelegate {\n    \n    /// 地图区域改变完成后会调用此接口\n    func mapView(_ mapView: MAMapView!, regionDidChangeAnimated animated: Bool) {\n        if !self.viewDidAppear { return }\n        \n        // 大头针动画\n        self.ui_pointAnnotationAnimate()\n        if self.isRegionChangedFromCustomer, self.mapView.userTrackingMode == .none {\n            // 用户手动滑动模式\n            // 搜索逆地理编码(顺带搜索附近)\n            self.map_searchLocationForReGeo(isForSubmit: false)\n        }\n        self.isRegionChangedFromCustomer = true\n    }\n}\n```\n这里是高德自己调用的，估计是滑动后区域改变，这里会走。\n这里我们走完后需要顺带搜索下附近地址，所以需要加上我们自己逻辑哦。\n\n### 4.11 搜索代理\n\n```Swift\n// 地图Delegate - Search\nextension GMLocationPickerController : AMapSearchDelegate {\n    /// POI查询回调函数 [定位获取附近POI、搜索POI]\n    func onPOISearchDone(_ request: AMapPOISearchBaseRequest!, response: AMapPOISearchResponse!) {\n//        if response.pois.count <= 0 {\n//            GMBannerTips.showWarningTips(\"没有找到定位\")\n//            data_reloadTableViewToEmpty(forRequest: false)\n//            return\n//        }\n        \n        let prefixPois = response.pois.prefix(20)     // 最多获取20个数据\n        var locationInfos = prefixPois.map({ GMLocationPickerLocationInfo(mapPOI: $0) })\n        \n        if request.isKind(of: AMapPOIKeywordsSearchRequest.self) {\n            // 1. 搜索关键词(搜索关键词)\n            \n            // 没有搜索到则提示\n            if response.pois.count <= 0 {\n                GMBannerTips.showWarningTips(\"没有找到定位\")\n                data_reloadTableViewToEmpty(forRequest: false)\n                return\n            }\n            \n            // 自动选择第一个位置\n            var selectingInfo = self.selectingLocationInfo\n            if let firstInfo = locationInfos.first {\n                selectingInfo = firstInfo\n                // 移动地图位置\n                self.data_changeRegionTo(firstInfo, for: .keywordSearchSelected)\n            }\n            // 搜索POI距离补全\n            if let selectingInfo = selectingInfo, let selectingCoordinate = selectingInfo.coordinate {\n                let selectingPoint = MAMapPointForCoordinate(selectingCoordinate)\n                for currLocationInfo in locationInfos {\n                    if selectingInfo == currLocationInfo { continue }\n                    if let currCoordinate = currLocationInfo.coordinate {\n                        let currPoint = MAMapPointForCoordinate(currCoordinate)\n                        currLocationInfo.distance = Int(MAMetersBetweenMapPoints(selectingPoint,currPoint))\n                    }\n                }\n            }\n            \n        } else if request.isKind(of: AMapPOIAroundSearchRequest.self) {\n            // 2. 搜索附近位置(定位or选中)\n            \n            // 没有找到定位 则选中当前选中的定位\n            if prefixPois.count <= 0, let selectingInfo = self.selectingLocationInfo {\n                locationInfos.insert(selectingInfo, at: 0)\n            }\n            \n            // 则确保第一个选项为当前地理位置（不匹配则手动添加）\n            if let firstInfo = locationInfos.first, let selectingInfo = self.selectingLocationInfo,\n               firstInfo.poiName != selectingInfo.poiName, firstInfo.address != selectingInfo.address {\n                // 当前第一个位置 非选中中位置\n                locationInfos.insert(selectingInfo, at: 0)\n            }\n            if let firstInfo = locationInfos.first {\n                // 纠正/同步选择中地理位置\n                self.selectingLocationInfo = firstInfo\n            }\n        }\n        \n        // 刷新TableView数据\n        self.data_reloadTableViewWith(locationInfos: locationInfos)\n    }\n    \n    /// 逆地理编码回调 [手动滑动地图时用]\n    func onReGeocodeSearchDone(_ request: AMapReGeocodeSearchRequest!, response: AMapReGeocodeSearchResponse!) {\n        if self.isReGeoRequestForSubmit {\n            // 1. 用于提交的逆地理编码搜索\n            self.ty_hideLoadingHUD()\n            self.isReGeoRequestForSubmit = false\n            \n            guard let location = request.location, let regeocode = response.regeocode else { return }\n            \n            self.view.endEditing(true)\n            let selectingInfo = GMLocationPickerLocationResult(location: location, reGeocode: regeocode, locationInfo: self.selectingLocationInfo)\n            \n            // 提交地址\n            self.delegate?.locationPickerController(self, didSubmit: selectingInfo)\n            locationResultBlock?(selectingInfo)\n            self.popViewController()\n        } else {\n            // 2. 用于用户滑动的逆地理编码搜索\n            guard let location = request.location, let regeocode = response.regeocode else { return }\n            \n            // 设置 locationInfos\n            let prefixPois = regeocode.pois.prefix(20)     // 最多获取20个数据\n            var locationInfos = prefixPois.map({ GMLocationPickerLocationInfo(mapPOI: $0) })\n            \n            let selectingInfo = GMLocationPickerLocationInfo(location: location, reGeocode: regeocode)\n            // 移动地图位置\n            self.data_changeRegionTo(selectingInfo, for: .slideByCustomer)\n            locationInfos.insert(selectingInfo, at: 0)\n            \n            // 刷新TableView数据\n            self.data_reloadTableViewWith(locationInfos: locationInfos)\n        }\n    }\n    \n    /// 当请求发生错误 (timeout)\n    func aMapSearchRequest(_ request: Any!, didFailWithError error: Error!) {\n        let errorCode = error._code\n        \n        var errMsg = \"\"\n        if let searchErrorCode = AMapSearchErrorCode(rawValue: errorCode) {\n            switch searchErrorCode {\n            case .notConnectedToInternet:   break// 网络连接异常\n                //errMsg = AMapSearchError.errorInfo(with: searchErrorCode)\n            default:\n                break\n            }\n        } else {\n            print(\"asdf\")\n        }\n        if !errMsg.isEmpty {\n            self.ty_showMsgHud(errMsg)\n        }\n    }\n    \n}\n```\n这里是高德提供的搜索代理。\n一个是手动滑动，一个是自行搜索，走接口不一样哦。\n\n### 4.12 其它代理\n\n```Swift\n\n// TableView Delegate\nextension GMLocationPickerController: UITableViewDelegate, UITableViewDataSource {\n    \n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        return self.locationInfos.count\n    }\n\n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n        let cell = GMLocationPickerCell.cellWithTableView(tableView)\n        cell.locationInfo = self.locationInfos[indexPath.row]\n        return cell\n    }\n    \n    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n        return GMLocationPickerCell.cellHeight()\n    }\n    \n    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n        let locationInfo = self.locationInfos[indexPath.row]\n        // 清除搜索栏内容\n        self.ui_clearSearchTextF()\n        // 移动地图位置\n        self.data_changeRegionTo(locationInfo, for: .itemSelected)\n        // 搜索附近\n        self.map_searchLocationForNearby()\n    }\n}\n\n// 输入框 & 自定义 Delegate\nextension GMLocationPickerController : UITextFieldDelegate\n{\n    func textFieldShouldReturn(_ textField: UITextField) -> Bool {\n        // 搜索\n        self.act_searchBtnClicked(button: nil)\n        return true\n    }\n}\n```\n这里还用了2个代理，一个是搜索列表的tableView的列表展示，一个是搜索框代理。\n\n### 4.13 如何定位\n\n```Swift\n/// 定位当前位置\nprivate func map_requestLocation(_ completion: ((CLLocation?, AMapLocationReGeocode?) -> ())?) {\n    // 定位请求\n    func requestLocation(_ completion: ((CLLocation?, AMapLocationReGeocode?) -> ())?) {\n        // 单次定位\n        self.locationManager.requestLocation(withReGeocode: true, completionBlock: { (location: CLLocation?, reGeocode: AMapLocationReGeocode?, error: Error?) in\n            // 定位回调\n            if let completion = completion { completion(location, reGeocode) }\n        })\n    }\n    \n    let manager = self.authorizationManager\n    manager.verifyLocationAuthroization(showAlertIn: self, completion: {\n        if #available(iOS 14.0, *) {\n            manager.verifyAccuracyAuthroization(completion: {\n                requestLocation(completion)\n            }, failure: nil)\n        } else {\n            requestLocation(completion)\n        }\n    }, failure: nil)\n}\n```\n别慌，高德也是提供了方法，支持去定位。\n\n### 4.14 地址权限工具\n\n```Swift\n/// 地址权限管理器 配置\nclass TYLocationAuthorizationConfig: NSObject {\n    \n    // info.plist 上配置的 精读权限获取描述\n    // <key>NSLocationTemporaryUsageDescriptionDictionary</key>\n    var accuracyPurposeKey = \"AccuracyUsageDescription\"\n    \n    var locationAlertTitle = \"您需要开启GPS权限\"\n    var locationAlertMessage = \"地图定位需要获取您的GPS权限才能正常使用\"\n}\n\n/// 地址权限管理器\nclass TYLocationAuthorization: NSObject {\n    \n    //MARK: - property\n    \n    // Data\n    \n    private var locationManager: CLLocationManager!             // 定位权限管理\n    \n    private var locationAuthVerifyCompletion: (() -> ())?       // 定位权限获取完成Block (用于权限首次询问)\n    private var locationAuthVerifyFailure: (() -> ())?          // 定位权限获取失败Block (用于权限首次请求)\n    \n    private var config = TYLocationAuthorizationConfig()              // 文本相关配置\n    \n    // State\n    \n    /// 定位权限状态\n    var locationAuthorization: CLAuthorizationStatus {\n        if #available(iOS 14.0, *) {\n            return self.locationManager.authorizationStatus\n        } else {\n            return CLLocationManager.authorizationStatus()\n        }\n    }\n    \n    /// 精读权限状态\n    @available(iOS 14.0, *)\n    var accuracyAuthorization: CLAccuracyAuthorization {\n        return self.locationManager.accuracyAuthorization\n    }\n    \n    \n    //MARK: - life cycle\n    \n    convenience init(config: TYLocationAuthorizationConfig) {\n        self.init()\n        self.config = config\n    }\n    \n    override init() {\n        super.init()\n        self.loadData()\n    }\n    \n    private func loadData() {\n        // 定位权限管理\n        let locationManager = CLLocationManager()\n        locationManager.delegate = self\n        self.locationManager = locationManager\n    }\n    \n    deinit {\n        print(\">>>>>>>>>>>>>>> deinit view [\\(self)] <<<<<<<<<<<<<<<\")\n    }\n    \n    //MARK: - public methods\n    \n    // ------------------------- 权限请求封装 -------------------------\n    \n    /// 定位权限判断\n    func verifyLocationAuthroization(showAlertIn controller: UIViewController? = nil,\n                                     completion: (() -> ())? = nil,\n                                     failure: (() -> ())? = nil) {\n\n        switch self.locationAuthorization {\n        case .notDetermined:                            // 1. 首次打开App时\n            self.locationAuthVerifyCompletion = completion\n            self.locationAuthVerifyFailure = failure\n            self.locationManager.requestWhenInUseAuthorization()    // 使用时 *\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            self.ui_showAlertForDeniedLocationAuthorization(in: controller)\n            if let failure = failure { failure() }\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            if let completion  = completion { completion() }\n        @unknown default:                               // 4. 未知情况\n            self.ui_showAlertForDeniedLocationAuthorization(in: controller)\n            if let failure = failure { failure() }\n        }\n    }\n    \n    /// 精读权限判断(高精读)\n    @available(iOS 14.0, *)\n    func verifyAccuracyAuthroization(completion: (() -> ())? = nil,\n                                     failure: (() -> ())? = nil) {\n        if self.isAccuracyAuthorizationFull() {\n            if let completion = completion { completion() }\n        } else {\n            let key = self.config.accuracyPurposeKey\n            self.locationManager.requestTemporaryFullAccuracyAuthorization(withPurposeKey: key) { err in\n                if self.isAccuracyAuthorizationFull() {\n                    if let completion = completion { completion() }\n                } else {\n                    if let failure = failure { failure() }\n                }\n            }\n        }\n    }\n    \n    // ------------------------- 权限状态 -------------------------\n    \n    /// 定位权限是否被拒绝\n    func isLocationAuthroizationDenied() -> Bool {\n        switch self.locationAuthorization {\n        case .notDetermined:                            // 1. 首次打开App时\n            return false\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            return true\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            return false\n        @unknown default:                               // 4. 未知情况\n            return true\n        }\n    }\n    \n    /// 定位权限是否被允许\n    func isLocationAuthroizationEnable() -> Bool {\n        switch self.locationAuthorization {\n        case .notDetermined:                            // 1. 首次打开App时\n            return false\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            return false\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            return true\n        @unknown default:                               // 4. 未知情况\n            return false\n        }\n    }\n    \n    /// 精准定位\n    @available(iOS 14.0, *)\n    func isAccuracyAuthorizationFull() -> Bool {\n        return self.locationManager.accuracyAuthorization == .fullAccuracy\n    }\n    \n    //MARK: - private methods\n    \n    /// 显示定位权限拒绝 Alert\n    private func ui_showAlertForDeniedLocationAuthorization(in controller: UIViewController?) {\n        guard let controller = controller else { return }\n\n        let title = self.config.locationAlertTitle\n        let message = self.config.locationAlertMessage\n        let alertVC = UIAlertController.ty_doubleOptionAlertWith(title: title, message: message, optionTitle1: \"去设置\", action1: {\n            if let settingURL = URL(string: UIApplication.openSettingsURLString),\n                UIApplication.shared.canOpenURL(settingURL) {\n                UIApplication.shared.open(settingURL, options: [:], completionHandler: nil)\n            }\n        }, optionTitle2: \"取消\", action2: nil)\n        controller.present(alertVC, animated: true, completion: nil)\n    }\n    \n    \n    /// 清空 定位权限获取Block\n    private func clearLocationAuthorizationBlock() {\n        self.locationAuthVerifyCompletion = nil\n        self.locationAuthVerifyFailure = nil\n    }\n}\n\nextension TYLocationAuthorization : CLLocationManagerDelegate {\n    \n    /// 定位权限修改 (iOS 4.2 - 14.0)\n    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {\n        self.data_locationAuthorizationDidChange()\n    }\n    \n    /// 定位权限修改 (iOS 14.0+)\n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {\n        self.data_locationAuthorizationDidChange()\n    }\n    \n    /// 权限状态修改\n    private func data_locationAuthorizationDidChange() {\n        if self.locationAuthVerifyCompletion == nil, self.locationAuthVerifyFailure == nil { return }\n              \n        switch self.locationAuthorization {\n        case .notDetermined:                            // 1. 首次打开App时\n            break\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            if let failure = self.locationAuthVerifyFailure { failure() }\n            self.clearLocationAuthorizationBlock()\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            if let completion = self.locationAuthVerifyCompletion { completion() }\n            self.clearLocationAuthorizationBlock()\n        @unknown default:                               // 4. 未知情况\n            if let failure = self.locationAuthVerifyFailure { failure() }\n            self.clearLocationAuthorizationBlock()\n        }\n        \n    }\n}\n```\n这里需要考虑到多种情况，是否拒绝权限，是否拥有了权限以及不同手机系统的问题。\n用法也是相当简单：\n```Swift\nlet manager = self.authorizationManager\nmanager.verifyLocationAuthroization(showAlertIn: self, completion: {\n    if #available(iOS 14.0, *) {\n        manager.verifyAccuracyAuthroization(completion: {\n            requestLocation(completion)\n        }, failure: nil)\n    } else {\n        requestLocation(completion)\n    }\n}, failure: nil)\n```\n这个manager就是我们的工具类。\n\n大致就是这么多了。\n\n## 5 总结\n\n* 如果要做一个需要三方支持的东西，请务必要提前调研下，如地图，推送，埋点等，这些最后提前了解下三方的接入指南，这样更好去实现需求。\n\n* 高德地图对接非常简单，拿到key后，主要工作就是对Map的处理，用户行为二指缩放这种高德自行实现，我们只需要设置坐标给中间的位置即可。\n\n* 对于地图，一定要考虑是否有权限的情况，没有权限的情况也需要跳转到系统设置，这样才能加强用户体验。万万不可出现没有权限直接闪退的问题。\n\n* 一般做地图都会有一个搜索能力，这样就需要高德搜索接口了，需要了解AMapSearchAPI 这个接口的用法，定位的话就用到AMapLocationManager。","slug":"iOS-swift-实现简易地图功能","published":1,"updated":"2023-02-01T07:12:24.284Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlc01jg000zjhv723ul7ueo","content":"<h2 id=\"1-需求定义\"><a href=\"#1-需求定义\" class=\"headerlink\" title=\"1 需求定义\"></a>1 需求定义</h2><p>产品需要我们实现这样一个需求，就是根据一个地址（可能有经纬度也可能没有）,然后跳转到地图页面去，地图中间会显示这个地址。运行用户自行点击定位，这样中间会显示当前位置。允许左右滑动，地图中心也会随之变更。支持搜索功能，根据用户搜索关键词，获取一个搜索列表。然后就是一个提交功能，这样需要将经纬度提交到服务端。</p>\n<p>大致是这样的需求。<br>实现效果是这样的：<br><img src=map.png></p>\n<h2 id=\"2-需求分析\"><a href=\"#2-需求分析\" class=\"headerlink\" title=\"2 需求分析\"></a>2 需求分析</h2><p>根据产品的需求，我们考虑接入高德地图。所以我们需要事先调研下如何接入高德才行。</p>\n<p>其实这个应该非常简单，高德提供了Map，我们只需要将中间的坐标设置为我们自己的坐标。如果没有坐标，我们也调研高德的搜索接口，将搜索结果默认第一条，这应该是最准的吧，然后设置给高德的中间坐标即可。</p>\n<p>支持用户滑动，高德就应该支持的，这里应该会提供一个代理，我们在这个代理的回调类里面重新去调用下搜索接口，就能出现附近10条地址。</p>\n<p>二指放大，高德应该也是支持的，不需要我们额外设置啥。</p>\n<p>另外就是定位可能复杂一点，需要实现获取下定位权限，如果没有权限，需要跳转到系统设置。定位就不需要高德支持了，我们直接调用系统接口，获取经纬度，然后设置给高德就行了。</p>\n<h2 id=\"3-准备工作：了解高德\"><a href=\"#3-准备工作：了解高德\" class=\"headerlink\" title=\"3 准备工作：了解高德\"></a>3 准备工作：了解高德</h2><p>首先附上高德官方文档：<a href=\"https://lbs.amap.com/api/ios-sdk/summary\">https://lbs.amap.com/api/ios-sdk/summary</a></p>\n<p>申请key这些工作就不用交给我们了，让产品自己申请吧。</p>\n<p>接入高德地图，做很复杂的需求，可以参考这篇文档，写得还不错：<br><a href=\"https://www.jianshu.com/p/770728626874\">https://www.jianshu.com/p/770728626874</a> 但是这个是objective-C，不过基本原理是类似的，还是有参考价值的。</p>\n<p>另外附上高德地图可配置参数：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>logoCenter</td>\n<td>CGPoint</td>\n<td>可设置Logo的位置。必须在mapView.bounds之内，否则会被忽略。</td>\n</tr>\n<tr>\n<td>showsCompass</td>\n<td>Bool</td>\n<td>是否显示指南针。</td>\n</tr>\n<tr>\n<td>compassOrigin</td>\n<td>CGPoint</td>\n<td>设置指南针的位置。</td>\n</tr>\n<tr>\n<td>showsScale</td>\n<td>Bool</td>\n<td>是否显示比例值。</td>\n</tr>\n<tr>\n<td>scaleOrigin</td>\n<td>CGPoint</td>\n<td>设置比例尺的位置。</td>\n</tr>\n<tr>\n<td>zoomEnabled</td>\n<td>Bool</td>\n<td>是否开启缩放手势，默认true。</td>\n</tr>\n<tr>\n<td>scrollEnabled</td>\n<td>Bool</td>\n<td>是否开启滑动手势，默认true。</td>\n</tr>\n<tr>\n<td>rotateEnabled</td>\n<td>Bool</td>\n<td>是否开启旋转手势，默认true。</td>\n</tr>\n<tr>\n<td>rotateCameraEnabled</td>\n<td>Bool</td>\n<td>是否开启倾斜旋转手势，默认true。用户可以在地图上放置两个手指，移动它们一起向下或向上去增加或减小倾斜角。</td>\n</tr>\n<tr>\n<td>setZoomLevel</td>\n<td>CGFloat</td>\n<td>改变地图缩放级别。范围从3级到19级，共17级。级别越高，展示的内容越细，例如街道等等。</td>\n</tr>\n<tr>\n<td>setCenter</td>\n<td>CLLocationCoordinate2D</td>\n<td>改变地图中心的位置。传递具体的经纬度。</td>\n</tr>\n</tbody>\n</table>\n\n<p>另外一个就是需要我们在AppDelegate中注册key：</p>\n<pre><code class=\"line-numbers language-Swift\"> /// 设置高德地图\nfunc configAMap() &#123;\n    AMapServices.shared().apiKey = &quot;你申请的key&quot;\n    AMapServices.shared().enableHTTPS = true\n&#125;\n</code></pre>\n<p>这里，准备工作基本就完成了。</p>\n<h2 id=\"4-代码实现\"><a href=\"#4-代码实现\" class=\"headerlink\" title=\"4 代码实现\"></a>4 代码实现</h2><h3 id=\"4-1-新建两个实体类\"><a href=\"#4-1-新建两个实体类\" class=\"headerlink\" title=\"4.1 新建两个实体类\"></a>4.1 新建两个实体类</h3><pre><code class=\"line-numbers language-Swift\">class GMLocationPickerLocationResult: NSObject &#123;\n    \n    //MARK: - property\n    \n    var coordinate: CLLocationCoordinate2D?     // 经纬度\n    \n    var poiName: String = &quot;&quot;                    // 名称\n    \n    var province: String = &quot;&quot;                   // 省\n    var provinceCode: String = &quot;&quot;               // 省编码\n    var city: String = &quot;&quot;                       // 市\n    var citycode: String = &quot;&quot;                   // 市编码\n    var district: String = &quot;&quot;                   // 区\n    var adcode: String = &quot;&quot;                     // 区编码\n    var township: String = &quot;&quot;                   // 乡镇街道\n    var towncode: String = &quot;&quot;                   // 乡镇街道编码(截取前9位)\n    \n    var detailAddress: String = &quot;&quot;              // 详细地址\n    var formattedAddress: String = &quot;&quot;           // 格式化全地址(4级+详细)\n    \n    var locationInfo: GMLocationPickerLocationInfo? //\n    \n    /// 模型转换\n    convenience init(location: AMapGeoPoint, reGeocode: AMapReGeocode, locationInfo: GMLocationPickerLocationInfo?) &#123;\n        self.init()\n        \n        let latitude = location.latitude\n        let longitude = location.longitude\n        self.coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n        \n        if let locationInfo = locationInfo &#123;\n            // 1.转换基础信息\n            self.poiName = locationInfo.poiName\n            self.province = locationInfo.province\n            self.city = locationInfo.city\n            self.district = locationInfo.district\n            self.township = locationInfo.street\n            self.detailAddress = locationInfo.address\n            self.formattedAddress = locationInfo.province + locationInfo.city + locationInfo.district + locationInfo.address\n        &#125;\n        if let addressComponent = reGeocode.addressComponent &#123;\n            // 2.转换所有信息\n            var poiName = &quot;&quot;\n            if let locationInfo = locationInfo &#123;\n                poiName = locationInfo.poiName\n            &#125; else if let aoisName = reGeocode.aois.first?.name &#123;\n                poiName = aoisName\n            &#125; else if let roadinterName = reGeocode.roadinters.first?.firstName &#123;\n                poiName = roadinterName\n            &#125; else &#123;\n                poiName = addressComponent.township ?? &quot;&quot;\n            &#125;\n            self.poiName = self.poiName.ty_forEmpty(poiName)\n            \n            self.province = self.province.ty_forEmpty(addressComponent.province ?? &quot;&quot;)\n            self.city = self.city.ty_forEmpty(addressComponent.city ?? &quot;&quot;)\n            self.district = self.district.ty_forEmpty(addressComponent.district ?? &quot;&quot;)\n            self.township = self.township.ty_forEmpty(addressComponent.township ?? &quot;&quot;)\n            self.formattedAddress = self.formattedAddress.ty_forEmpty(reGeocode.formattedAddress ?? &quot;&quot;)\n        &#125;\n        if let addressComponent = reGeocode.addressComponent &#123;\n            // 设置编码\n            self.citycode = addressComponent.citycode ?? &quot;&quot;\n            self.adcode = addressComponent.adcode ?? &quot;&quot;\n            self.towncode = String(addressComponent.towncode.prefix(9)) // 截取前九位\n        &#125;\n        // 设置省份编码 用自带plist\n        if let globalAddressModel = globalAddressModel &#123;\n            for currProvince in globalAddressModel.data &#123;\n                if currProvince.name == self.province &#123;\n                    self.provinceCode = currProvince.code\n                    break\n                &#125;\n            &#125;\n        &#125;\n        self.locationInfo = locationInfo\n    &#125;\n&#125;\n</code></pre>\n<p>这个用了一个convenience关键字来声明init，主要是覆写的作用，重载。可以参考这篇文章：<a href=\"https://www.jianshu.com/p/09c6c88ed61e\">https://www.jianshu.com/p/09c6c88ed61e</a>。这里面初始化已经用了高德的实体类AMapGeoPoint,这个包含了经纬度；AMapReGeocode，这个是逆地址编码；然后还有一个自定义实体，这个是Info，上面那个是result，info如下定义：</p>\n<pre><code class=\"line-numbers language-Swift\">\nclass GMLocationPickerLocationInfo: NSObject &#123;\n    \n    //MARK: - property\n    \n    var coordinate: CLLocationCoordinate2D?     // 经纬度\n    \n    var poiName: String = &quot;&quot;                    // 名称\n    var province: String = &quot;&quot;                   // 省\n    var city: String = &quot;&quot;                       // 市\n    var district: String = &quot;&quot;                   // 区\n    var street: String = &quot;&quot;                     // 街道(*)\n    var number: String = &quot;&quot;                     // 门牌号(*)\n    \n    var address: String = &quot;&quot;                    // 地址(街道 + 门牌)\n    \n    var distance: Int = 0                       // 与选中点距离\n    \n    // UI\n    \n    var ui_isSelected = false                   // cell是否选中中\n    \n    //MARK: - life cycle\n    \n    // ------------------------- map 内转换 -------------------------\n    \n    /// 模型转换 根据 [实时定位]获取的 经纬度 &amp; 逆地理信息\n    convenience init(coordinate: CLLocationCoordinate2D?, reGeocode: AMapLocationReGeocode?) &#123;\n        self.init()\n        \n        self.coordinate = coordinate\n        \n        self.poiName = reGeocode?.poiName ?? &quot;&quot;\n        self.province = reGeocode?.province ?? &quot;&quot;\n        self.city = reGeocode?.city ?? &quot;&quot;\n        self.district = reGeocode?.district ?? &quot;&quot;\n        self.street = reGeocode?.street ?? &quot;&quot;\n        self.number = reGeocode?.number ?? &quot;&quot;\n        self.address = (self.street + self.number)\n        if self.street.isEmpty || self.number.isEmpty &#123;\n            let detailAddress = reGeocode?.formattedAddress ?? &quot;&quot;\n            self.address = abbreviationAddressIn(detailAddress: detailAddress, province: province, city: city, district: district)\n        &#125;\n        \n        self.distance = 0\n    &#125;\n    \n    /// 模型转换 根据 [搜索&#123;附近|关键词&#125;]获取的 POI模型\n    convenience init(mapPOI: AMapPOI) &#123;\n        self.init()\n        \n        if let location = mapPOI.location &#123;\n            let latitude = location.latitude\n            let longitude = location.longitude\n            self.coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n        &#125;\n        \n        self.poiName = mapPOI.name\n        self.province = mapPOI.province\n        self.city = mapPOI.city\n        self.district = mapPOI.district\n        self.street = &quot;&quot;\n        self.number = &quot;&quot;\n        self.address = mapPOI.address\n        \n        self.distance = mapPOI.distance // 周边搜索可用\n    &#125;\n    \n    /// 模型转换 根据 [逆地理编码]获取的 经纬度 &amp; 逆地理编码结果\n    convenience init(location: AMapGeoPoint, reGeocode: AMapReGeocode) &#123;\n        self.init()\n        \n        let addressComponent = reGeocode.addressComponent\n        \n        let latitude = location.latitude\n        let longitude = location.longitude\n        self.coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n        \n        if let aoisName = reGeocode.aois.first?.name &#123;\n            self.poiName = aoisName\n        &#125; else if let roadinterName = reGeocode.roadinters.first?.firstName &#123;\n            self.poiName = roadinterName\n        &#125; else &#123;\n            self.poiName = addressComponent?.township ?? &quot;&quot;\n        &#125;\n        self.province = addressComponent?.province ?? &quot;&quot;\n        self.city = addressComponent?.city ?? &quot;&quot;\n        self.district = addressComponent?.district ?? &quot;&quot;\n        self.street = addressComponent?.streetNumber?.street ?? &quot;&quot;\n        self.number = addressComponent?.streetNumber?.number ?? &quot;&quot;\n        self.address = (self.street + self.number)\n        if self.street.isEmpty || self.number.isEmpty &#123;\n            let detailAddress = reGeocode.formattedAddress ?? &quot;&quot;\n            self.address = abbreviationAddressIn(detailAddress: detailAddress, province: province, city: city, district: district)\n        &#125;\n        self.distance = 0\n    &#125;\n    \n    /// 详细地址中获取缩略地址\n    /// - Parameters:\n    ///   - detailAddress: 详细地址\n    ///   - province: 省份\n    ///   - city: 城市\n    ///   - district: 区域\n    private func abbreviationAddressIn(detailAddress: String, province: String, city: String, district: String) -&gt; String &#123;\n        var address = detailAddress\n        address = address.replacingOccurrences(of: province, with: &quot;&quot;)\n        address = address.replacingOccurrences(of: city, with: &quot;&quot;)\n        address = address.replacingOccurrences(of: city, with: &quot;&quot;)\n        return address\n    &#125;\n    \n    // ------------------------- model 转换 -------------------------\n    \n    /// 模型转换 根据 地理信息结果模型\n    convenience init(locationResult: GMLocationPickerLocationResult) &#123;\n        self.init()\n        \n        self.coordinate = locationResult.coordinate\n        \n        self.poiName = locationResult.poiName\n        self.province = locationResult.province\n        self.city = locationResult.city\n        self.district = locationResult.district\n        let street = locationResult.township\n        self.address = street\n        \n        self.distance = 0\n    &#125;\n    \n    /// 模型转换 根据 仓库模型\n    convenience init(warehouseInfo: GMWarehouseInfoHomeList) &#123;\n        self.init()\n        \n        self.coordinate = warehouseInfo.cus_coordinate\n        \n        self.poiName = warehouseInfo.name\n        self.province = warehouseInfo.province\n        self.city = warehouseInfo.city\n        self.district = warehouseInfo.region\n        self.street = &quot;&quot;\n        self.number = &quot;&quot;\n        self.address = warehouseInfo.address\n        \n        self.distance = 0\n    &#125;\n    \n    /// 模型转换 根据 门店模型\n    convenience init(storeInfo: GMStoreInfoHomeModel) &#123;\n        self.init()\n        \n        self.coordinate = storeInfo.cus_coordinate\n        \n        self.poiName = storeInfo.shopName\n        self.province = storeInfo.shopProvince\n        self.city = storeInfo.shopCity\n        self.district = storeInfo.shopCounty\n        self.street = storeInfo.shopStreet\n        self.number = &quot;&quot;\n        self.address = storeInfo.shopAddress\n        \n        self.distance = 0\n    &#125;\n&#125;\n</code></pre>\n<p>这个是地图内部使用，上面那个实体，是为了更好对接服务端设定的一个实体。</p>\n<h3 id=\"4-2-外部类定义\"><a href=\"#4-2-外部类定义\" class=\"headerlink\" title=\"4.2 外部类定义\"></a>4.2 外部类定义</h3><pre><code class=\"line-numbers language-Swift\">/// 地图选择 闭包，向外吐出去\ntypealias GMLocationResultHandler = (GMLocationPickerLocationResult?) -&gt; Swift.Void\n\nprotocol GMLocationPickerControllerDelegate: AnyObject &#123;\n    /// 提交所选位置\n    func locationPickerController(_ collection: GMLocationPickerController, didSubmit locationInfo: GMLocationPickerLocationResult)\n    \n    /// 页面将要pop出\n    func locationPickerControllerWillPop(_ collection: GMLocationPickerController)\n&#125;\n\n/// 从哪里进来的 枚举类\nenum GMLocationPickerFor &#123;\n    case warehouseCreate                                        // 仓库创建\n    case warehouseEdit(warehouseInfo: GMWarehouseInfoHomeList)  // 仓库编辑\n    case storeEdit(storeInfo: GMStoreInfoHomeModel)             // 门店编辑\n&#125;\n\n/// 选择地理位置的原因 什么时候走高德接口\nenum GMLocationPickerRegionChageFor &#123;\n    case located                                                // 实时定位\n    case itemSelected                                           // 搜索项选择\n    case keywordSearchSelected                                  // 关键词搜索 自动选择(第一个)\n    case slideByCustomer                                        // 用户滑动逆地理\n&#125;\n</code></pre>\n<p>这里定义了可能需要的枚举类和协议。<br>枚举类主要跟我们自己业务有关系了，协议也是跟业务有关系。这里并不是实现地图的必须。</p>\n<h3 id=\"4-3-UI声明\"><a href=\"#4-3-UI声明\" class=\"headerlink\" title=\"4.3 UI声明\"></a>4.3 UI声明</h3><pre><code class=\"line-numbers language-Swift\">class GMLocationPickerController: GMBaseViewController &#123;\n\n    //MARK: - property\n    \n    // UI\n    \n    private weak var btn_submit: UIButton!                      // 提交按钮\n    private weak var mapView: MAMapView!                        // 地图\n    private weak var textF_search: UITextField!                 // 搜索 输入栏\n    private weak var tableView: TYTableView!                    // 搜索 列表\n    private weak var ai_spinner: UIActivityIndicatorView!       // 加载loading\n    private weak var btn_located: UIButton!                     // 定位按钮\n    \n    private weak var imgV_pointAnnotation: UIImageView!         // 自定义大头针\n</code></pre>\n<p>这里声明了实现地图用到的一些材料，当然最关键的是MAMapView了，这个View是高德提供的哦。</p>\n<h3 id=\"4-4-数据声明\"><a href=\"#4-4-数据声明\" class=\"headerlink\" title=\"4.4 数据声明\"></a>4.4 数据声明</h3><pre><code class=\"line-numbers language-Swift\">// Data\nvar navTitle: String?                                       // Nav标题 (可选)\nweak var delegate: GMLocationPickerControllerDelegate?      // 代理\nvar locationResultBlock: GMLocationResultHandler?\n\nprivate var locationInfos = [GMLocationPickerLocationInfo]()// 搜索 地点信息\nprivate var selectingLocationInfo: GMLocationPickerLocationInfo? // 选中地点信息\n\n// Pre Data\n\nvar preLocationInfo: GMLocationPickerLocationInfo?          // 预地理位置信息\nvar preCoordinate: CLLocationCoordinate2D?                  // 预经纬度\nvar preKeyword: String?                                     // 预搜索关键词\nvar pickerFor: GMLocationPickerFor = .warehouseCreate       // 地图选择用于\n</code></pre>\n<p>这里大致列举了需要用的数据。<br>预数据，就是外部传过来的数据，然后我们新建了两个info实体报错搜索的地址和选中的地址。</p>\n<h3 id=\"4-5-其它成员声明\"><a href=\"#4-5-其它成员声明\" class=\"headerlink\" title=\"4.5 其它成员声明\"></a>4.5 其它成员声明</h3><pre><code class=\"line-numbers language-Swift\">// Tool\nprivate var search: AMapSearchAPI!                          // 地图 搜索功能\nprivate var locationManager: AMapLocationManager!           // 地图 定位功能\nprivate var authorizationManager = TYLocationAuthorization()// 权限管理\n\n// flag\n\nprivate var lastSearchKey = &quot;&quot;                              // 最后搜索字段\nprivate var isRegionChangedFromCustomer = false             // 地图领域变化原因为用户手动滑动\nprivate var isReGeoRequestForSubmit = false                 // 逆地理请求用于提交\nprivate var viewDidAppear = false  \n</code></pre>\n<p>这里是一些工具和一些flag变量，工具包含地图搜索接口和地图定位功能工具，这些都是高德提供，另外权限是自定义的一个工具来处理的。</p>\n<h3 id=\"4-6-生命周期之viewDidLoad\"><a href=\"#4-6-生命周期之viewDidLoad\" class=\"headerlink\" title=\"4.6 生命周期之viewDidLoad\"></a>4.6 生命周期之viewDidLoad</h3><p>这个走一次，看下做了什么：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        self.layoutSubviews()\n        self.loadData()\n    &#125;\n</code></pre>\n<p>加载了子View，然后去加载数据。</p>\n<pre><code class=\"line-numbers language-Swift\">private func layoutSubviews() &#123;\n        \n        self.view.backgroundColor = .white\n        \n        // ------------------------- 导航栏 -------------------------\n        let submitBtnF: UIFont = .pingFangRegular(size: 16.0)\n        \n        let btn_submit = UIButton()\n        btn_submit.isEnabled = false\n        btn_submit.ty_setButtonWith(text: &quot;提交&quot;, font: submitBtnF, color: .ty_409EFF, state: .normal)\n        btn_submit.ty_setButtonWith(text: &quot;提交&quot;, font: submitBtnF, color: .ty_409EFF.alpha(0.5), state: .disabled)\n        btn_submit.addTarget(self, action: #selector(act_submitBtnClicked(button:)), for: .touchUpInside)\n        let item_submit = UIBarButtonItem(customView: btn_submit)\n        self.navigationItem.rightBarButtonItem = item_submit\n        self.btn_submit = btn_submit\n        \n        // ------------------------- 底部控件 -------------------------\n        let searchListBGW: CGFloat = yScreenWidth\n        let searchListBGH: CGFloat = 104.0\n        let searchListBGR = CGRect(x: 0, y: 0, width: searchListBGW, height: searchListBGH)\n        let searchListBGRadius = 16.0\n        let searchListBGRadiusS = CGSize(width: searchListBGRadius, height: searchListBGRadius)\n        \n        let view_searchListBG = UIView.ty_viewWith(bgColor: .ty_ThemeWhite)\n        view_searchListBG.ty_setCornerWith(rect: searchListBGR, corners: [.topLeft, .topRight], radii: searchListBGRadiusS)\n        self.view.addSubview(view_searchListBG)\n        view_searchListBG.snp.makeConstraints &#123; make in\n            make.bottom.equalTo(self.view.snp.bottom)\n            make.centerX.equalTo(self.view)\n            make.width.equalTo(searchListBGW)\n            make.height.equalTo(searchListBGH)\n        &#125;\n        \n        // 搜索栏\n        let searchBtnF: UIFont = .pingFangRegular(size: 14.0)\n        let searchBtnW: CGFloat = 80.0\n        let searchBtnH: CGFloat = 32.0\n        let searchBarTextFF: UIFont = .pingFangRegular(size: 14.0)\n        let searchBarTextFLeftImageS = CGSize(width: 16.0, height: 16.0)\n        let searchBarTextFLeftViewS = CGSize(width: 32.0, height: 32.0)\n        let searchBarTextFR: CGFloat = 10.0\n        let searchBarTextFH: CGFloat = searchBtnH\n        \n        // 搜索按钮\n        let btn_search = UIButton()\n        btn_search.ty_setButtonWith(text: &quot;搜索&quot;, font: searchBtnF, color: .ty_TextWhite, state: .normal)\n        btn_search.ty_setBackgroundColor(.ty_409EFF, state: .normal)\n        btn_search.ty_setCornerRadius(searchBtnH/2.0)\n        btn_search.addTarget(self, action: #selector(act_searchBtnClicked(button:)), for: .touchUpInside)\n        \n        view_searchListBG.addSubview(btn_search)\n        btn_search.snp.makeConstraints &#123; make in\n            make.top.equalTo(view_searchListBG).offset(ySuperVerPad)\n            make.right.equalTo(view_searchListBG).offset(-ySuperHorPad)\n            make.width.equalTo(searchBtnW)\n            make.height.equalTo(searchBtnH)\n        &#125;\n        \n        // 搜索栏\n        let textF_search = UITextField.ty_textFieldWith(font: searchBarTextFF, color: .ty_222222)\n        textF_search.backgroundColor = .ty_F7F9FA\n        textF_search.ty_setPlaceholderWith(placeholder: &quot;请输入地址&quot;, color: .ty_9B9DA7, font: searchBarTextFF)\n        textF_search.ty_setLeftPaddingImage(imageName: &quot;locationPicker_img_search&quot;, imageSize: searchBarTextFLeftImageS, paddingSize: searchBarTextFLeftViewS)\n        textF_search.ty_setCornerRadius(searchBarTextFH/2.0)\n        \n        textF_search.addTarget(self, action: #selector(act_searchTextFEditChange(textF:)), for: .editingChanged)\n        textF_search.addObserver(self, forKeyPath: &quot;text&quot;, options: [.new, .old], context: nil)\n        \n        textF_search.delegate = self\n        textF_search.returnKeyType = .search\n        \n        view_searchListBG.addSubview(textF_search)\n        self.textF_search = textF_search\n        textF_search.snp.makeConstraints &#123; make in\n            make.top.equalTo(view_searchListBG).offset(ySuperVerPad)\n            make.left.equalTo(view_searchListBG).offset(ySuperHorPad)\n            make.right.equalTo(btn_search.snp.left).offset(-searchBarTextFR)\n            make.height.equalTo(searchBarTextFH)\n        &#125;\n        \n        // TableView\n        let tableViewT: CGFloat = 6.0\n        \n        let tableView = TYTableView(delegate: self, dataSource: self, style: .plain)\n        tableView.showsVerticalScrollIndicator = false\n        view_searchListBG.addSubview(tableView)\n        self.tableView = tableView\n        tableView.snp.makeConstraints &#123; make in\n            make.top.equalTo(textF_search.snp.bottom).offset(tableViewT)\n            make.left.equalTo(view_searchListBG)\n            make.right.equalTo(view_searchListBG)\n            make.bottom.equalTo(view_searchListBG)\n        &#125;\n        \n        // loading 旋转图\n        let indicatorStyle: UIActivityIndicatorView.Style\n        if #available(iOS 13.0, * ) &#123;\n            indicatorStyle = .medium\n        &#125; else &#123;\n            indicatorStyle = .gray\n        &#125;\n        let ai_spinner = UIActivityIndicatorView(style: indicatorStyle)\n        ai_spinner.startAnimating()\n        view_searchListBG.addSubview(ai_spinner)\n        self.ai_spinner = ai_spinner\n        ai_spinner.snp.makeConstraints &#123; make in\n            make.center.equalTo(view_searchListBG)\n        &#125;\n        \n        // ------------------------- mapView -------------------------\n        let mapViewW: CGFloat = yScreenWidth\n        let mapViewH: CGFloat = yScreenHeight - searchListBGH + searchListBGRadius/2.0\n        let cus_mapViewR = CGRect(x: 0, y: 0, width: mapViewW, height: mapViewH)\n        \n        // MapView\n        let mapView = MAMapView(frame: cus_mapViewR)\n        mapView.zoomLevel = 13.0                // 缩放比例\n        mapView.showsCompass = false            // 显示罗盘\n        mapView.showsScale = false              // 显示比例尺\n        mapView.delegate = self\n        self.view.addSubview(mapView)\n        self.mapView = mapView\n        \n        // 大头针\n        let pointAnnotationImgVW: CGFloat = 40.0\n        let pointAnnotationImgVH: CGFloat = 40.0\n        let imgV_pointAnnotation = UIImageView.ty_imageViewWith(imageName: &quot;locationPicker_icon_point_annotation&quot;)\n        self.view.addSubview(imgV_pointAnnotation)\n        self.imgV_pointAnnotation = imgV_pointAnnotation\n        imgV_pointAnnotation.snp.makeConstraints &#123; make in\n            make.centerX.equalTo(mapView)\n            make.centerY.equalTo(mapView).offset(-pointAnnotationImgVH/2.0)\n            make.width.equalTo(pointAnnotationImgVW)\n            make.height.equalTo(pointAnnotationImgVH)\n        &#125;\n        \n        // 回归定位按钮\n        let locatedBtnWH: CGFloat = 46.0\n        let locatedBtnR: CGFloat = 9.0\n        let locatedBtnB: CGFloat = 9.0\n        \n        let btn_located = UIButton()\n        btn_located.setImage(UIImage(named: &quot;locationPicker_btn_located_Blue&quot;), for: .selected)     // 在当前定位\n        btn_located.setImage(UIImage(named: &quot;locationPicker_btn_located_Black&quot;), for: .normal)      // 不在当前定位\n        btn_located.addTarget(self, action: #selector(act_locatedBtnClicked(button:)), for: .touchUpInside)\n        self.view.addSubview(btn_located)\n        self.btn_located = btn_located\n        btn_located.snp.makeConstraints &#123; make in\n            make.right.equalTo(self.view).offset(-locatedBtnR)\n            make.bottom.equalTo(view_searchListBG.snp.top).offset(-locatedBtnB)\n            make.width.equalTo(locatedBtnWH)\n            make.height.equalTo(locatedBtnWH)\n        &#125;\n        \n        self.view.bringSubviewToFront(view_searchListBG)\n    &#125;\n</code></pre>\n<p>逻辑也是非常清晰，一个一个把视图堆叠进去了。<br>这里大头针跟地图一点关系没有，这个只是把大头针放在中间而已。没有跟地图绑定任何关系。</p>\n<p>然后去加载数据：</p>\n<pre><code class=\"line-numbers language-Swift\">private func loadData() &#123;\n    // 设置标题\n    if let navTitle = self.navTitle, !navTitle.isEmpty &#123;\n        self.title = &quot;\\(navTitle) 地图定位&quot;\n    &#125; else &#123;\n        self.title = &quot;地图定位&quot;\n    &#125;\n    \n    // 定位功能\n    // 更新App是否显示隐私弹窗的状态，隐私弹窗是否包含高德SDK隐私协议内容的状态\n    AMapLocationManager.updatePrivacyShow(.didShow, privacyInfo: .didContain)\n    // 更新用户授权高德SDK隐私协议状态\n    AMapLocationManager.updatePrivacyAgree(.didAgree)\n    let locationManager = AMapLocationManager()\n    locationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters\n    if #available(iOS 14.0, *) &#123;\n        locationManager.locationAccuracyMode = .fullAccuracy\n    &#125;\n    self.locationManager = locationManager\n    \n    // 搜索\n    let search = AMapSearchAPI()\n    search?.timeout = 10\n    search?.delegate = self\n    self.search = search\n    \n    // 预地理位置信息处理\n    self.data_preLocatedHandle(locationInfo: self.preLocationInfo,\n                                preCoordinate: self.preCoordinate,\n                                preKeyword: self.preKeyword)\n&#125;\n</code></pre>\n<p>这里设置了标题，然后就去走预地理位置信息处理的方法。这里的pre相关的数据，在跳转前，就给这个controller赋值了，这里跟Android不太一样，Android还要通过intent来传，它这个居然可以直接用controller的实例传值。</p>\n<p>具体预制方法为：</p>\n<pre><code class=\"line-numbers language-Swift\">/// 根据预地理位置信息 按照优先级 决定预定位方式\nfunc data_preLocatedHandle(locationInfo: GMLocationPickerLocationInfo? = nil,\n                            preCoordinate: CLLocationCoordinate2D? = nil, preKeyword: String? = nil) &#123;\n    \n    // 预定位处理规则\n    // 完整数据 - 经纬度 - 位置关键词 - 实时定位 - 默认&#39;北京&#39;定位\n    if let preLocationInfo = locationInfo &#123;\n        // 1.完整信息\n        if let coordinate = preLocationInfo.coordinate,\n            coordinate.latitude != 0, coordinate.longitude != 0 &#123;\n            // 1.1 经纬度信息完整\n            self.data_changeRegionTo(preLocationInfo, for: .itemSelected)\n            self.map_searchLocationForNearby()  // 搜索附近\n        &#125; else if !preLocationInfo.address.isEmpty &#123;\n            // 1.2 无经纬度、有地名：搜索地名\n            let searchKey = &quot;\\(preLocationInfo.city)\\(preLocationInfo.district)\\(preLocationInfo.address)&quot;\n            self.data_preLocatedHandle(preKeyword: searchKey)\n        &#125; else &#123;\n            // 1.3 都没有：默认操作\n            self.data_preLocatedHandle()\n        &#125;\n    &#125; else if let preCoordinate = preCoordinate &#123;\n        // 2.显示经纬度位置\n        self.mapView.centerCoordinate = preCoordinate\n        self.map_searchLocationForReGeo(isForSubmit: false) // 搜索逆地理编码\n    &#125; else if let preKeyword = preKeyword, preKeyword.count &gt; 0 &#123;\n        // 3.关键词配置\n        self.textF_search.text = preKeyword\n        self.act_searchBtnClicked(button: nil)\n    &#125; else &#123;\n        var isLocationEnable = self.authorizationManager.isLocationAuthroizationEnable()\n        if #available(iOS 14.0, *) &#123;\n            isLocationEnable = isLocationEnable &amp;&amp; self.authorizationManager.isAccuracyAuthorizationFull()\n        &#125;\n        if isLocationEnable &#123;\n            // 4.实时定位\n            self.act_locatedBtnClicked(button: nil)\n        &#125; else &#123;\n            // 5.默认北京\n            self.mapView.centerCoordinate = CLLocationCoordinate2D(latitude: 39.909115, longitude: 116.397535)\n            self.map_searchLocationForReGeo(isForSubmit: false) // 搜索逆地理编码\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里就是一段逻辑，如果之前有地址，然后如何去显示的逻辑。如何去移动地图。<br>主要是用了一个 self.mapView.centerCoordinate来设置地图中心坐标，然后这里调用搜索词是走了这个方法：</p>\n<pre><code class=\"line-numbers language-Swift\">/// 根据当前地图中间位置 搜索逆地理\n/// - Parameter isForSubmit: 用于提交 or 用户滑动地理获取(顺带搜索附近)\nprivate func map_searchLocationForReGeo(isForSubmit: Bool) &#123;\n    self.isReGeoRequestForSubmit = isForSubmit\n    if isForSubmit &#123;\n        self.ty_showLoadingHUD()\n    &#125; else &#123;\n        // 清空列表数据\n        self.data_reloadTableViewToEmpty(forRequest: true)\n    &#125;\n    \n    // 取消上一个请求\n    self.search.cancelAllRequests()\n    \n    // 逆地理位置请求\n    let coordinate = self.mapView.centerCoordinate\n    let regeo = AMapReGeocodeSearchRequest()\n    regeo.location = AMapGeoPoint.location(withLatitude: coordinate.latitude, longitude: coordinate.longitude)\n    regeo.requireExtension = true\n    self.search.aMapReGoecodeSearch(regeo)\n&#125;\n</code></pre>\n<p>这里根据地图中心位置调用了搜索接口,具体请求在这里：</p>\n<pre><code class=\"line-numbers language-Swift\">self.search.aMapReGoecodeSearch(regeo)\n</code></pre>\n<p>如何搜索附近地址呢？</p>\n<pre><code class=\"line-numbers language-Swift\">/// 根据选中位置 搜索附近POI\nprivate func map_searchLocationForNearby() &#123;\n    guard let coordinate = self.selectingLocationInfo?.coordinate else &#123; return &#125;\n    // 清空列表数据\n    self.data_reloadTableViewToEmpty(forRequest: true)\n    \n    // 取消上一个请求\n    self.search.cancelAllRequests()\n    \n    // 附近搜索请求\n    let aroundRequest = AMapPOIAroundSearchRequest()\n    let geoPoint = AMapGeoPoint.location(withLatitude: coordinate.latitude,\n                                            longitude: coordinate.longitude)\n    aroundRequest.location = geoPoint\n//        aroundRequest.special = true\n    self.search.aMapPOIAroundSearch(aroundRequest)\n&#125;\n</code></pre>\n<p>跟上面方法也比较类似。</p>\n<h3 id=\"4-7-生命周期之viewWillAppear\"><a href=\"#4-7-生命周期之viewWillAppear\" class=\"headerlink\" title=\"4.7 生命周期之viewWillAppear\"></a>4.7 生命周期之viewWillAppear</h3><pre><code class=\"line-numbers language-Swift\">override func viewWillAppear(_ animated: Bool) &#123;\n        super.viewWillAppear(animated)\n        setupWhiteNavBarColor()\n        setupWhiteClickCallBack()\n        \n        isHiddenNavBar(isHidden: false)\n    &#125;\n</code></pre>\n<p>主要处理了导航栏相关的。</p>\n<h3 id=\"4-8-生命周期之viewDidAppear\"><a href=\"#4-8-生命周期之viewDidAppear\" class=\"headerlink\" title=\"4.8 生命周期之viewDidAppear\"></a>4.8 生命周期之viewDidAppear</h3><pre><code class=\"line-numbers language-Swift\">override func viewDidAppear(_ animated: Bool) &#123;\n        super.viewDidAppear(animated)\n        self.viewDidAppear = true\n    &#125;\n</code></pre>\n<p>这里没干啥，就设置了一个flag。</p>\n<h3 id=\"4-9-析构函数\"><a href=\"#4-9-析构函数\" class=\"headerlink\" title=\"4.9 析构函数\"></a>4.9 析构函数</h3><pre><code class=\"line-numbers language-Swift\">deinit &#123;\n        self.tydev_logDeinit()\n    &#125;\n</code></pre>\n<p>这里也没干啥，打印下日志：</p>\n<pre><code class=\"line-numbers language-Swift\">/// 输出对象销毁日志\nfunc tydev_logDeinit() &#123;\n    self.tydev_logDeinit(nil)\n&#125;\n\n/// 输出对象销毁日志\n/// - Parameter mark: 自定义标识\nfunc tydev_logDeinit(_ mark: String?) &#123;\n    if let mark = mark &#123;\n        print(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; deinit view [\\(self)] (\\(mark) &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;)\n    &#125; else &#123;\n        print(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; deinit view [\\(self)] &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;)\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"4-10-地图代理\"><a href=\"#4-10-地图代理\" class=\"headerlink\" title=\"4.10 地图代理\"></a>4.10 地图代理</h3><p>前面我们设置了代理为自己，需要处理下：</p>\n<pre><code class=\"line-numbers language-Swift\">// 地图Delegate - Map\nextension GMLocationPickerController : MAMapViewDelegate &#123;\n    \n    /// 地图区域改变完成后会调用此接口\n    func mapView(_ mapView: MAMapView!, regionDidChangeAnimated animated: Bool) &#123;\n        if !self.viewDidAppear &#123; return &#125;\n        \n        // 大头针动画\n        self.ui_pointAnnotationAnimate()\n        if self.isRegionChangedFromCustomer, self.mapView.userTrackingMode == .none &#123;\n            // 用户手动滑动模式\n            // 搜索逆地理编码(顺带搜索附近)\n            self.map_searchLocationForReGeo(isForSubmit: false)\n        &#125;\n        self.isRegionChangedFromCustomer = true\n    &#125;\n&#125;\n</code></pre>\n<p>这里是高德自己调用的，估计是滑动后区域改变，这里会走。<br>这里我们走完后需要顺带搜索下附近地址，所以需要加上我们自己逻辑哦。</p>\n<h3 id=\"4-11-搜索代理\"><a href=\"#4-11-搜索代理\" class=\"headerlink\" title=\"4.11 搜索代理\"></a>4.11 搜索代理</h3><pre><code class=\"line-numbers language-Swift\">// 地图Delegate - Search\nextension GMLocationPickerController : AMapSearchDelegate &#123;\n    /// POI查询回调函数 [定位获取附近POI、搜索POI]\n    func onPOISearchDone(_ request: AMapPOISearchBaseRequest!, response: AMapPOISearchResponse!) &#123;\n//        if response.pois.count &lt;= 0 &#123;\n//            GMBannerTips.showWarningTips(&quot;没有找到定位&quot;)\n//            data_reloadTableViewToEmpty(forRequest: false)\n//            return\n//        &#125;\n        \n        let prefixPois = response.pois.prefix(20)     // 最多获取20个数据\n        var locationInfos = prefixPois.map(&#123; GMLocationPickerLocationInfo(mapPOI: $0) &#125;)\n        \n        if request.isKind(of: AMapPOIKeywordsSearchRequest.self) &#123;\n            // 1. 搜索关键词(搜索关键词)\n            \n            // 没有搜索到则提示\n            if response.pois.count &lt;= 0 &#123;\n                GMBannerTips.showWarningTips(&quot;没有找到定位&quot;)\n                data_reloadTableViewToEmpty(forRequest: false)\n                return\n            &#125;\n            \n            // 自动选择第一个位置\n            var selectingInfo = self.selectingLocationInfo\n            if let firstInfo = locationInfos.first &#123;\n                selectingInfo = firstInfo\n                // 移动地图位置\n                self.data_changeRegionTo(firstInfo, for: .keywordSearchSelected)\n            &#125;\n            // 搜索POI距离补全\n            if let selectingInfo = selectingInfo, let selectingCoordinate = selectingInfo.coordinate &#123;\n                let selectingPoint = MAMapPointForCoordinate(selectingCoordinate)\n                for currLocationInfo in locationInfos &#123;\n                    if selectingInfo == currLocationInfo &#123; continue &#125;\n                    if let currCoordinate = currLocationInfo.coordinate &#123;\n                        let currPoint = MAMapPointForCoordinate(currCoordinate)\n                        currLocationInfo.distance = Int(MAMetersBetweenMapPoints(selectingPoint,currPoint))\n                    &#125;\n                &#125;\n            &#125;\n            \n        &#125; else if request.isKind(of: AMapPOIAroundSearchRequest.self) &#123;\n            // 2. 搜索附近位置(定位or选中)\n            \n            // 没有找到定位 则选中当前选中的定位\n            if prefixPois.count &lt;= 0, let selectingInfo = self.selectingLocationInfo &#123;\n                locationInfos.insert(selectingInfo, at: 0)\n            &#125;\n            \n            // 则确保第一个选项为当前地理位置（不匹配则手动添加）\n            if let firstInfo = locationInfos.first, let selectingInfo = self.selectingLocationInfo,\n               firstInfo.poiName != selectingInfo.poiName, firstInfo.address != selectingInfo.address &#123;\n                // 当前第一个位置 非选中中位置\n                locationInfos.insert(selectingInfo, at: 0)\n            &#125;\n            if let firstInfo = locationInfos.first &#123;\n                // 纠正/同步选择中地理位置\n                self.selectingLocationInfo = firstInfo\n            &#125;\n        &#125;\n        \n        // 刷新TableView数据\n        self.data_reloadTableViewWith(locationInfos: locationInfos)\n    &#125;\n    \n    /// 逆地理编码回调 [手动滑动地图时用]\n    func onReGeocodeSearchDone(_ request: AMapReGeocodeSearchRequest!, response: AMapReGeocodeSearchResponse!) &#123;\n        if self.isReGeoRequestForSubmit &#123;\n            // 1. 用于提交的逆地理编码搜索\n            self.ty_hideLoadingHUD()\n            self.isReGeoRequestForSubmit = false\n            \n            guard let location = request.location, let regeocode = response.regeocode else &#123; return &#125;\n            \n            self.view.endEditing(true)\n            let selectingInfo = GMLocationPickerLocationResult(location: location, reGeocode: regeocode, locationInfo: self.selectingLocationInfo)\n            \n            // 提交地址\n            self.delegate?.locationPickerController(self, didSubmit: selectingInfo)\n            locationResultBlock?(selectingInfo)\n            self.popViewController()\n        &#125; else &#123;\n            // 2. 用于用户滑动的逆地理编码搜索\n            guard let location = request.location, let regeocode = response.regeocode else &#123; return &#125;\n            \n            // 设置 locationInfos\n            let prefixPois = regeocode.pois.prefix(20)     // 最多获取20个数据\n            var locationInfos = prefixPois.map(&#123; GMLocationPickerLocationInfo(mapPOI: $0) &#125;)\n            \n            let selectingInfo = GMLocationPickerLocationInfo(location: location, reGeocode: regeocode)\n            // 移动地图位置\n            self.data_changeRegionTo(selectingInfo, for: .slideByCustomer)\n            locationInfos.insert(selectingInfo, at: 0)\n            \n            // 刷新TableView数据\n            self.data_reloadTableViewWith(locationInfos: locationInfos)\n        &#125;\n    &#125;\n    \n    /// 当请求发生错误 (timeout)\n    func aMapSearchRequest(_ request: Any!, didFailWithError error: Error!) &#123;\n        let errorCode = error._code\n        \n        var errMsg = &quot;&quot;\n        if let searchErrorCode = AMapSearchErrorCode(rawValue: errorCode) &#123;\n            switch searchErrorCode &#123;\n            case .notConnectedToInternet:   break// 网络连接异常\n                //errMsg = AMapSearchError.errorInfo(with: searchErrorCode)\n            default:\n                break\n            &#125;\n        &#125; else &#123;\n            print(&quot;asdf&quot;)\n        &#125;\n        if !errMsg.isEmpty &#123;\n            self.ty_showMsgHud(errMsg)\n        &#125;\n    &#125;\n    \n&#125;\n</code></pre>\n<p>这里是高德提供的搜索代理。<br>一个是手动滑动，一个是自行搜索，走接口不一样哦。</p>\n<h3 id=\"4-12-其它代理\"><a href=\"#4-12-其它代理\" class=\"headerlink\" title=\"4.12 其它代理\"></a>4.12 其它代理</h3><pre><code class=\"line-numbers language-Swift\">\n// TableView Delegate\nextension GMLocationPickerController: UITableViewDelegate, UITableViewDataSource &#123;\n    \n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n        return self.locationInfos.count\n    &#125;\n\n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n        let cell = GMLocationPickerCell.cellWithTableView(tableView)\n        cell.locationInfo = self.locationInfos[indexPath.row]\n        return cell\n    &#125;\n    \n    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n        return GMLocationPickerCell.cellHeight()\n    &#125;\n    \n    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123;\n        let locationInfo = self.locationInfos[indexPath.row]\n        // 清除搜索栏内容\n        self.ui_clearSearchTextF()\n        // 移动地图位置\n        self.data_changeRegionTo(locationInfo, for: .itemSelected)\n        // 搜索附近\n        self.map_searchLocationForNearby()\n    &#125;\n&#125;\n\n// 输入框 &amp; 自定义 Delegate\nextension GMLocationPickerController : UITextFieldDelegate\n&#123;\n    func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool &#123;\n        // 搜索\n        self.act_searchBtnClicked(button: nil)\n        return true\n    &#125;\n&#125;\n</code></pre>\n<p>这里还用了2个代理，一个是搜索列表的tableView的列表展示，一个是搜索框代理。</p>\n<h3 id=\"4-13-如何定位\"><a href=\"#4-13-如何定位\" class=\"headerlink\" title=\"4.13 如何定位\"></a>4.13 如何定位</h3><pre><code class=\"line-numbers language-Swift\">/// 定位当前位置\nprivate func map_requestLocation(_ completion: ((CLLocation?, AMapLocationReGeocode?) -&gt; ())?) &#123;\n    // 定位请求\n    func requestLocation(_ completion: ((CLLocation?, AMapLocationReGeocode?) -&gt; ())?) &#123;\n        // 单次定位\n        self.locationManager.requestLocation(withReGeocode: true, completionBlock: &#123; (location: CLLocation?, reGeocode: AMapLocationReGeocode?, error: Error?) in\n            // 定位回调\n            if let completion = completion &#123; completion(location, reGeocode) &#125;\n        &#125;)\n    &#125;\n    \n    let manager = self.authorizationManager\n    manager.verifyLocationAuthroization(showAlertIn: self, completion: &#123;\n        if #available(iOS 14.0, *) &#123;\n            manager.verifyAccuracyAuthroization(completion: &#123;\n                requestLocation(completion)\n            &#125;, failure: nil)\n        &#125; else &#123;\n            requestLocation(completion)\n        &#125;\n    &#125;, failure: nil)\n&#125;\n</code></pre>\n<p>别慌，高德也是提供了方法，支持去定位。</p>\n<h3 id=\"4-14-地址权限工具\"><a href=\"#4-14-地址权限工具\" class=\"headerlink\" title=\"4.14 地址权限工具\"></a>4.14 地址权限工具</h3><pre><code class=\"line-numbers language-Swift\">/// 地址权限管理器 配置\nclass TYLocationAuthorizationConfig: NSObject &#123;\n    \n    // info.plist 上配置的 精读权限获取描述\n    // &lt;key&gt;NSLocationTemporaryUsageDescriptionDictionary&lt;/key&gt;\n    var accuracyPurposeKey = &quot;AccuracyUsageDescription&quot;\n    \n    var locationAlertTitle = &quot;您需要开启GPS权限&quot;\n    var locationAlertMessage = &quot;地图定位需要获取您的GPS权限才能正常使用&quot;\n&#125;\n\n/// 地址权限管理器\nclass TYLocationAuthorization: NSObject &#123;\n    \n    //MARK: - property\n    \n    // Data\n    \n    private var locationManager: CLLocationManager!             // 定位权限管理\n    \n    private var locationAuthVerifyCompletion: (() -&gt; ())?       // 定位权限获取完成Block (用于权限首次询问)\n    private var locationAuthVerifyFailure: (() -&gt; ())?          // 定位权限获取失败Block (用于权限首次请求)\n    \n    private var config = TYLocationAuthorizationConfig()              // 文本相关配置\n    \n    // State\n    \n    /// 定位权限状态\n    var locationAuthorization: CLAuthorizationStatus &#123;\n        if #available(iOS 14.0, *) &#123;\n            return self.locationManager.authorizationStatus\n        &#125; else &#123;\n            return CLLocationManager.authorizationStatus()\n        &#125;\n    &#125;\n    \n    /// 精读权限状态\n    @available(iOS 14.0, *)\n    var accuracyAuthorization: CLAccuracyAuthorization &#123;\n        return self.locationManager.accuracyAuthorization\n    &#125;\n    \n    \n    //MARK: - life cycle\n    \n    convenience init(config: TYLocationAuthorizationConfig) &#123;\n        self.init()\n        self.config = config\n    &#125;\n    \n    override init() &#123;\n        super.init()\n        self.loadData()\n    &#125;\n    \n    private func loadData() &#123;\n        // 定位权限管理\n        let locationManager = CLLocationManager()\n        locationManager.delegate = self\n        self.locationManager = locationManager\n    &#125;\n    \n    deinit &#123;\n        print(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; deinit view [\\(self)] &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;)\n    &#125;\n    \n    //MARK: - public methods\n    \n    // ------------------------- 权限请求封装 -------------------------\n    \n    /// 定位权限判断\n    func verifyLocationAuthroization(showAlertIn controller: UIViewController? = nil,\n                                     completion: (() -&gt; ())? = nil,\n                                     failure: (() -&gt; ())? = nil) &#123;\n\n        switch self.locationAuthorization &#123;\n        case .notDetermined:                            // 1. 首次打开App时\n            self.locationAuthVerifyCompletion = completion\n            self.locationAuthVerifyFailure = failure\n            self.locationManager.requestWhenInUseAuthorization()    // 使用时 *\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            self.ui_showAlertForDeniedLocationAuthorization(in: controller)\n            if let failure = failure &#123; failure() &#125;\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            if let completion  = completion &#123; completion() &#125;\n        @unknown default:                               // 4. 未知情况\n            self.ui_showAlertForDeniedLocationAuthorization(in: controller)\n            if let failure = failure &#123; failure() &#125;\n        &#125;\n    &#125;\n    \n    /// 精读权限判断(高精读)\n    @available(iOS 14.0, *)\n    func verifyAccuracyAuthroization(completion: (() -&gt; ())? = nil,\n                                     failure: (() -&gt; ())? = nil) &#123;\n        if self.isAccuracyAuthorizationFull() &#123;\n            if let completion = completion &#123; completion() &#125;\n        &#125; else &#123;\n            let key = self.config.accuracyPurposeKey\n            self.locationManager.requestTemporaryFullAccuracyAuthorization(withPurposeKey: key) &#123; err in\n                if self.isAccuracyAuthorizationFull() &#123;\n                    if let completion = completion &#123; completion() &#125;\n                &#125; else &#123;\n                    if let failure = failure &#123; failure() &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    \n    // ------------------------- 权限状态 -------------------------\n    \n    /// 定位权限是否被拒绝\n    func isLocationAuthroizationDenied() -&gt; Bool &#123;\n        switch self.locationAuthorization &#123;\n        case .notDetermined:                            // 1. 首次打开App时\n            return false\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            return true\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            return false\n        @unknown default:                               // 4. 未知情况\n            return true\n        &#125;\n    &#125;\n    \n    /// 定位权限是否被允许\n    func isLocationAuthroizationEnable() -&gt; Bool &#123;\n        switch self.locationAuthorization &#123;\n        case .notDetermined:                            // 1. 首次打开App时\n            return false\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            return false\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            return true\n        @unknown default:                               // 4. 未知情况\n            return false\n        &#125;\n    &#125;\n    \n    /// 精准定位\n    @available(iOS 14.0, *)\n    func isAccuracyAuthorizationFull() -&gt; Bool &#123;\n        return self.locationManager.accuracyAuthorization == .fullAccuracy\n    &#125;\n    \n    //MARK: - private methods\n    \n    /// 显示定位权限拒绝 Alert\n    private func ui_showAlertForDeniedLocationAuthorization(in controller: UIViewController?) &#123;\n        guard let controller = controller else &#123; return &#125;\n\n        let title = self.config.locationAlertTitle\n        let message = self.config.locationAlertMessage\n        let alertVC = UIAlertController.ty_doubleOptionAlertWith(title: title, message: message, optionTitle1: &quot;去设置&quot;, action1: &#123;\n            if let settingURL = URL(string: UIApplication.openSettingsURLString),\n                UIApplication.shared.canOpenURL(settingURL) &#123;\n                UIApplication.shared.open(settingURL, options: [:], completionHandler: nil)\n            &#125;\n        &#125;, optionTitle2: &quot;取消&quot;, action2: nil)\n        controller.present(alertVC, animated: true, completion: nil)\n    &#125;\n    \n    \n    /// 清空 定位权限获取Block\n    private func clearLocationAuthorizationBlock() &#123;\n        self.locationAuthVerifyCompletion = nil\n        self.locationAuthVerifyFailure = nil\n    &#125;\n&#125;\n\nextension TYLocationAuthorization : CLLocationManagerDelegate &#123;\n    \n    /// 定位权限修改 (iOS 4.2 - 14.0)\n    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) &#123;\n        self.data_locationAuthorizationDidChange()\n    &#125;\n    \n    /// 定位权限修改 (iOS 14.0+)\n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) &#123;\n        self.data_locationAuthorizationDidChange()\n    &#125;\n    \n    /// 权限状态修改\n    private func data_locationAuthorizationDidChange() &#123;\n        if self.locationAuthVerifyCompletion == nil, self.locationAuthVerifyFailure == nil &#123; return &#125;\n              \n        switch self.locationAuthorization &#123;\n        case .notDetermined:                            // 1. 首次打开App时\n            break\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            if let failure = self.locationAuthVerifyFailure &#123; failure() &#125;\n            self.clearLocationAuthorizationBlock()\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            if let completion = self.locationAuthVerifyCompletion &#123; completion() &#125;\n            self.clearLocationAuthorizationBlock()\n        @unknown default:                               // 4. 未知情况\n            if let failure = self.locationAuthVerifyFailure &#123; failure() &#125;\n            self.clearLocationAuthorizationBlock()\n        &#125;\n        \n    &#125;\n&#125;\n</code></pre>\n<p>这里需要考虑到多种情况，是否拒绝权限，是否拥有了权限以及不同手机系统的问题。<br>用法也是相当简单：</p>\n<pre><code class=\"line-numbers language-Swift\">let manager = self.authorizationManager\nmanager.verifyLocationAuthroization(showAlertIn: self, completion: &#123;\n    if #available(iOS 14.0, *) &#123;\n        manager.verifyAccuracyAuthroization(completion: &#123;\n            requestLocation(completion)\n        &#125;, failure: nil)\n    &#125; else &#123;\n        requestLocation(completion)\n    &#125;\n&#125;, failure: nil)\n</code></pre>\n<p>这个manager就是我们的工具类。</p>\n<p>大致就是这么多了。</p>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5 总结\"></a>5 总结</h2><ul>\n<li><p>如果要做一个需要三方支持的东西，请务必要提前调研下，如地图，推送，埋点等，这些最后提前了解下三方的接入指南，这样更好去实现需求。</p>\n</li>\n<li><p>高德地图对接非常简单，拿到key后，主要工作就是对Map的处理，用户行为二指缩放这种高德自行实现，我们只需要设置坐标给中间的位置即可。</p>\n</li>\n<li><p>对于地图，一定要考虑是否有权限的情况，没有权限的情况也需要跳转到系统设置，这样才能加强用户体验。万万不可出现没有权限直接闪退的问题。</p>\n</li>\n<li><p>一般做地图都会有一个搜索能力，这样就需要高德搜索接口了，需要了解AMapSearchAPI 这个接口的用法，定位的话就用到AMapLocationManager。</p>\n</li>\n</ul>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-需求定义\"><a href=\"#1-需求定义\" class=\"headerlink\" title=\"1 需求定义\"></a>1 需求定义</h2><p>产品需要我们实现这样一个需求，就是根据一个地址（可能有经纬度也可能没有）,然后跳转到地图页面去，地图中间会显示这个地址。运行用户自行点击定位，这样中间会显示当前位置。允许左右滑动，地图中心也会随之变更。支持搜索功能，根据用户搜索关键词，获取一个搜索列表。然后就是一个提交功能，这样需要将经纬度提交到服务端。</p>\n<p>大致是这样的需求。<br>实现效果是这样的：<br><img src=map.png></p>\n<h2 id=\"2-需求分析\"><a href=\"#2-需求分析\" class=\"headerlink\" title=\"2 需求分析\"></a>2 需求分析</h2><p>根据产品的需求，我们考虑接入高德地图。所以我们需要事先调研下如何接入高德才行。</p>\n<p>其实这个应该非常简单，高德提供了Map，我们只需要将中间的坐标设置为我们自己的坐标。如果没有坐标，我们也调研高德的搜索接口，将搜索结果默认第一条，这应该是最准的吧，然后设置给高德的中间坐标即可。</p>\n<p>支持用户滑动，高德就应该支持的，这里应该会提供一个代理，我们在这个代理的回调类里面重新去调用下搜索接口，就能出现附近10条地址。</p>\n<p>二指放大，高德应该也是支持的，不需要我们额外设置啥。</p>\n<p>另外就是定位可能复杂一点，需要实现获取下定位权限，如果没有权限，需要跳转到系统设置。定位就不需要高德支持了，我们直接调用系统接口，获取经纬度，然后设置给高德就行了。</p>\n<h2 id=\"3-准备工作：了解高德\"><a href=\"#3-准备工作：了解高德\" class=\"headerlink\" title=\"3 准备工作：了解高德\"></a>3 准备工作：了解高德</h2><p>首先附上高德官方文档：<a href=\"https://lbs.amap.com/api/ios-sdk/summary\">https://lbs.amap.com/api/ios-sdk/summary</a></p>\n<p>申请key这些工作就不用交给我们了，让产品自己申请吧。</p>\n<p>接入高德地图，做很复杂的需求，可以参考这篇文档，写得还不错：<br><a href=\"https://www.jianshu.com/p/770728626874\">https://www.jianshu.com/p/770728626874</a> 但是这个是objective-C，不过基本原理是类似的，还是有参考价值的。</p>\n<p>另外附上高德地图可配置参数：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>logoCenter</td>\n<td>CGPoint</td>\n<td>可设置Logo的位置。必须在mapView.bounds之内，否则会被忽略。</td>\n</tr>\n<tr>\n<td>showsCompass</td>\n<td>Bool</td>\n<td>是否显示指南针。</td>\n</tr>\n<tr>\n<td>compassOrigin</td>\n<td>CGPoint</td>\n<td>设置指南针的位置。</td>\n</tr>\n<tr>\n<td>showsScale</td>\n<td>Bool</td>\n<td>是否显示比例值。</td>\n</tr>\n<tr>\n<td>scaleOrigin</td>\n<td>CGPoint</td>\n<td>设置比例尺的位置。</td>\n</tr>\n<tr>\n<td>zoomEnabled</td>\n<td>Bool</td>\n<td>是否开启缩放手势，默认true。</td>\n</tr>\n<tr>\n<td>scrollEnabled</td>\n<td>Bool</td>\n<td>是否开启滑动手势，默认true。</td>\n</tr>\n<tr>\n<td>rotateEnabled</td>\n<td>Bool</td>\n<td>是否开启旋转手势，默认true。</td>\n</tr>\n<tr>\n<td>rotateCameraEnabled</td>\n<td>Bool</td>\n<td>是否开启倾斜旋转手势，默认true。用户可以在地图上放置两个手指，移动它们一起向下或向上去增加或减小倾斜角。</td>\n</tr>\n<tr>\n<td>setZoomLevel</td>\n<td>CGFloat</td>\n<td>改变地图缩放级别。范围从3级到19级，共17级。级别越高，展示的内容越细，例如街道等等。</td>\n</tr>\n<tr>\n<td>setCenter</td>\n<td>CLLocationCoordinate2D</td>\n<td>改变地图中心的位置。传递具体的经纬度。</td>\n</tr>\n</tbody>\n</table>\n\n<p>另外一个就是需要我们在AppDelegate中注册key：</p>\n<pre><code class=\"line-numbers language-Swift\"> /// 设置高德地图\nfunc configAMap() &#123;\n    AMapServices.shared().apiKey = &quot;你申请的key&quot;\n    AMapServices.shared().enableHTTPS = true\n&#125;\n</code></pre>\n<p>这里，准备工作基本就完成了。</p>\n<h2 id=\"4-代码实现\"><a href=\"#4-代码实现\" class=\"headerlink\" title=\"4 代码实现\"></a>4 代码实现</h2><h3 id=\"4-1-新建两个实体类\"><a href=\"#4-1-新建两个实体类\" class=\"headerlink\" title=\"4.1 新建两个实体类\"></a>4.1 新建两个实体类</h3><pre><code class=\"line-numbers language-Swift\">class GMLocationPickerLocationResult: NSObject &#123;\n    \n    //MARK: - property\n    \n    var coordinate: CLLocationCoordinate2D?     // 经纬度\n    \n    var poiName: String = &quot;&quot;                    // 名称\n    \n    var province: String = &quot;&quot;                   // 省\n    var provinceCode: String = &quot;&quot;               // 省编码\n    var city: String = &quot;&quot;                       // 市\n    var citycode: String = &quot;&quot;                   // 市编码\n    var district: String = &quot;&quot;                   // 区\n    var adcode: String = &quot;&quot;                     // 区编码\n    var township: String = &quot;&quot;                   // 乡镇街道\n    var towncode: String = &quot;&quot;                   // 乡镇街道编码(截取前9位)\n    \n    var detailAddress: String = &quot;&quot;              // 详细地址\n    var formattedAddress: String = &quot;&quot;           // 格式化全地址(4级+详细)\n    \n    var locationInfo: GMLocationPickerLocationInfo? //\n    \n    /// 模型转换\n    convenience init(location: AMapGeoPoint, reGeocode: AMapReGeocode, locationInfo: GMLocationPickerLocationInfo?) &#123;\n        self.init()\n        \n        let latitude = location.latitude\n        let longitude = location.longitude\n        self.coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n        \n        if let locationInfo = locationInfo &#123;\n            // 1.转换基础信息\n            self.poiName = locationInfo.poiName\n            self.province = locationInfo.province\n            self.city = locationInfo.city\n            self.district = locationInfo.district\n            self.township = locationInfo.street\n            self.detailAddress = locationInfo.address\n            self.formattedAddress = locationInfo.province + locationInfo.city + locationInfo.district + locationInfo.address\n        &#125;\n        if let addressComponent = reGeocode.addressComponent &#123;\n            // 2.转换所有信息\n            var poiName = &quot;&quot;\n            if let locationInfo = locationInfo &#123;\n                poiName = locationInfo.poiName\n            &#125; else if let aoisName = reGeocode.aois.first?.name &#123;\n                poiName = aoisName\n            &#125; else if let roadinterName = reGeocode.roadinters.first?.firstName &#123;\n                poiName = roadinterName\n            &#125; else &#123;\n                poiName = addressComponent.township ?? &quot;&quot;\n            &#125;\n            self.poiName = self.poiName.ty_forEmpty(poiName)\n            \n            self.province = self.province.ty_forEmpty(addressComponent.province ?? &quot;&quot;)\n            self.city = self.city.ty_forEmpty(addressComponent.city ?? &quot;&quot;)\n            self.district = self.district.ty_forEmpty(addressComponent.district ?? &quot;&quot;)\n            self.township = self.township.ty_forEmpty(addressComponent.township ?? &quot;&quot;)\n            self.formattedAddress = self.formattedAddress.ty_forEmpty(reGeocode.formattedAddress ?? &quot;&quot;)\n        &#125;\n        if let addressComponent = reGeocode.addressComponent &#123;\n            // 设置编码\n            self.citycode = addressComponent.citycode ?? &quot;&quot;\n            self.adcode = addressComponent.adcode ?? &quot;&quot;\n            self.towncode = String(addressComponent.towncode.prefix(9)) // 截取前九位\n        &#125;\n        // 设置省份编码 用自带plist\n        if let globalAddressModel = globalAddressModel &#123;\n            for currProvince in globalAddressModel.data &#123;\n                if currProvince.name == self.province &#123;\n                    self.provinceCode = currProvince.code\n                    break\n                &#125;\n            &#125;\n        &#125;\n        self.locationInfo = locationInfo\n    &#125;\n&#125;\n</code></pre>\n<p>这个用了一个convenience关键字来声明init，主要是覆写的作用，重载。可以参考这篇文章：<a href=\"https://www.jianshu.com/p/09c6c88ed61e\">https://www.jianshu.com/p/09c6c88ed61e</a>。这里面初始化已经用了高德的实体类AMapGeoPoint,这个包含了经纬度；AMapReGeocode，这个是逆地址编码；然后还有一个自定义实体，这个是Info，上面那个是result，info如下定义：</p>\n<pre><code class=\"line-numbers language-Swift\">\nclass GMLocationPickerLocationInfo: NSObject &#123;\n    \n    //MARK: - property\n    \n    var coordinate: CLLocationCoordinate2D?     // 经纬度\n    \n    var poiName: String = &quot;&quot;                    // 名称\n    var province: String = &quot;&quot;                   // 省\n    var city: String = &quot;&quot;                       // 市\n    var district: String = &quot;&quot;                   // 区\n    var street: String = &quot;&quot;                     // 街道(*)\n    var number: String = &quot;&quot;                     // 门牌号(*)\n    \n    var address: String = &quot;&quot;                    // 地址(街道 + 门牌)\n    \n    var distance: Int = 0                       // 与选中点距离\n    \n    // UI\n    \n    var ui_isSelected = false                   // cell是否选中中\n    \n    //MARK: - life cycle\n    \n    // ------------------------- map 内转换 -------------------------\n    \n    /// 模型转换 根据 [实时定位]获取的 经纬度 &amp; 逆地理信息\n    convenience init(coordinate: CLLocationCoordinate2D?, reGeocode: AMapLocationReGeocode?) &#123;\n        self.init()\n        \n        self.coordinate = coordinate\n        \n        self.poiName = reGeocode?.poiName ?? &quot;&quot;\n        self.province = reGeocode?.province ?? &quot;&quot;\n        self.city = reGeocode?.city ?? &quot;&quot;\n        self.district = reGeocode?.district ?? &quot;&quot;\n        self.street = reGeocode?.street ?? &quot;&quot;\n        self.number = reGeocode?.number ?? &quot;&quot;\n        self.address = (self.street + self.number)\n        if self.street.isEmpty || self.number.isEmpty &#123;\n            let detailAddress = reGeocode?.formattedAddress ?? &quot;&quot;\n            self.address = abbreviationAddressIn(detailAddress: detailAddress, province: province, city: city, district: district)\n        &#125;\n        \n        self.distance = 0\n    &#125;\n    \n    /// 模型转换 根据 [搜索&#123;附近|关键词&#125;]获取的 POI模型\n    convenience init(mapPOI: AMapPOI) &#123;\n        self.init()\n        \n        if let location = mapPOI.location &#123;\n            let latitude = location.latitude\n            let longitude = location.longitude\n            self.coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n        &#125;\n        \n        self.poiName = mapPOI.name\n        self.province = mapPOI.province\n        self.city = mapPOI.city\n        self.district = mapPOI.district\n        self.street = &quot;&quot;\n        self.number = &quot;&quot;\n        self.address = mapPOI.address\n        \n        self.distance = mapPOI.distance // 周边搜索可用\n    &#125;\n    \n    /// 模型转换 根据 [逆地理编码]获取的 经纬度 &amp; 逆地理编码结果\n    convenience init(location: AMapGeoPoint, reGeocode: AMapReGeocode) &#123;\n        self.init()\n        \n        let addressComponent = reGeocode.addressComponent\n        \n        let latitude = location.latitude\n        let longitude = location.longitude\n        self.coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n        \n        if let aoisName = reGeocode.aois.first?.name &#123;\n            self.poiName = aoisName\n        &#125; else if let roadinterName = reGeocode.roadinters.first?.firstName &#123;\n            self.poiName = roadinterName\n        &#125; else &#123;\n            self.poiName = addressComponent?.township ?? &quot;&quot;\n        &#125;\n        self.province = addressComponent?.province ?? &quot;&quot;\n        self.city = addressComponent?.city ?? &quot;&quot;\n        self.district = addressComponent?.district ?? &quot;&quot;\n        self.street = addressComponent?.streetNumber?.street ?? &quot;&quot;\n        self.number = addressComponent?.streetNumber?.number ?? &quot;&quot;\n        self.address = (self.street + self.number)\n        if self.street.isEmpty || self.number.isEmpty &#123;\n            let detailAddress = reGeocode.formattedAddress ?? &quot;&quot;\n            self.address = abbreviationAddressIn(detailAddress: detailAddress, province: province, city: city, district: district)\n        &#125;\n        self.distance = 0\n    &#125;\n    \n    /// 详细地址中获取缩略地址\n    /// - Parameters:\n    ///   - detailAddress: 详细地址\n    ///   - province: 省份\n    ///   - city: 城市\n    ///   - district: 区域\n    private func abbreviationAddressIn(detailAddress: String, province: String, city: String, district: String) -&gt; String &#123;\n        var address = detailAddress\n        address = address.replacingOccurrences(of: province, with: &quot;&quot;)\n        address = address.replacingOccurrences(of: city, with: &quot;&quot;)\n        address = address.replacingOccurrences(of: city, with: &quot;&quot;)\n        return address\n    &#125;\n    \n    // ------------------------- model 转换 -------------------------\n    \n    /// 模型转换 根据 地理信息结果模型\n    convenience init(locationResult: GMLocationPickerLocationResult) &#123;\n        self.init()\n        \n        self.coordinate = locationResult.coordinate\n        \n        self.poiName = locationResult.poiName\n        self.province = locationResult.province\n        self.city = locationResult.city\n        self.district = locationResult.district\n        let street = locationResult.township\n        self.address = street\n        \n        self.distance = 0\n    &#125;\n    \n    /// 模型转换 根据 仓库模型\n    convenience init(warehouseInfo: GMWarehouseInfoHomeList) &#123;\n        self.init()\n        \n        self.coordinate = warehouseInfo.cus_coordinate\n        \n        self.poiName = warehouseInfo.name\n        self.province = warehouseInfo.province\n        self.city = warehouseInfo.city\n        self.district = warehouseInfo.region\n        self.street = &quot;&quot;\n        self.number = &quot;&quot;\n        self.address = warehouseInfo.address\n        \n        self.distance = 0\n    &#125;\n    \n    /// 模型转换 根据 门店模型\n    convenience init(storeInfo: GMStoreInfoHomeModel) &#123;\n        self.init()\n        \n        self.coordinate = storeInfo.cus_coordinate\n        \n        self.poiName = storeInfo.shopName\n        self.province = storeInfo.shopProvince\n        self.city = storeInfo.shopCity\n        self.district = storeInfo.shopCounty\n        self.street = storeInfo.shopStreet\n        self.number = &quot;&quot;\n        self.address = storeInfo.shopAddress\n        \n        self.distance = 0\n    &#125;\n&#125;\n</code></pre>\n<p>这个是地图内部使用，上面那个实体，是为了更好对接服务端设定的一个实体。</p>\n<h3 id=\"4-2-外部类定义\"><a href=\"#4-2-外部类定义\" class=\"headerlink\" title=\"4.2 外部类定义\"></a>4.2 外部类定义</h3><pre><code class=\"line-numbers language-Swift\">/// 地图选择 闭包，向外吐出去\ntypealias GMLocationResultHandler = (GMLocationPickerLocationResult?) -&gt; Swift.Void\n\nprotocol GMLocationPickerControllerDelegate: AnyObject &#123;\n    /// 提交所选位置\n    func locationPickerController(_ collection: GMLocationPickerController, didSubmit locationInfo: GMLocationPickerLocationResult)\n    \n    /// 页面将要pop出\n    func locationPickerControllerWillPop(_ collection: GMLocationPickerController)\n&#125;\n\n/// 从哪里进来的 枚举类\nenum GMLocationPickerFor &#123;\n    case warehouseCreate                                        // 仓库创建\n    case warehouseEdit(warehouseInfo: GMWarehouseInfoHomeList)  // 仓库编辑\n    case storeEdit(storeInfo: GMStoreInfoHomeModel)             // 门店编辑\n&#125;\n\n/// 选择地理位置的原因 什么时候走高德接口\nenum GMLocationPickerRegionChageFor &#123;\n    case located                                                // 实时定位\n    case itemSelected                                           // 搜索项选择\n    case keywordSearchSelected                                  // 关键词搜索 自动选择(第一个)\n    case slideByCustomer                                        // 用户滑动逆地理\n&#125;\n</code></pre>\n<p>这里定义了可能需要的枚举类和协议。<br>枚举类主要跟我们自己业务有关系了，协议也是跟业务有关系。这里并不是实现地图的必须。</p>\n<h3 id=\"4-3-UI声明\"><a href=\"#4-3-UI声明\" class=\"headerlink\" title=\"4.3 UI声明\"></a>4.3 UI声明</h3><pre><code class=\"line-numbers language-Swift\">class GMLocationPickerController: GMBaseViewController &#123;\n\n    //MARK: - property\n    \n    // UI\n    \n    private weak var btn_submit: UIButton!                      // 提交按钮\n    private weak var mapView: MAMapView!                        // 地图\n    private weak var textF_search: UITextField!                 // 搜索 输入栏\n    private weak var tableView: TYTableView!                    // 搜索 列表\n    private weak var ai_spinner: UIActivityIndicatorView!       // 加载loading\n    private weak var btn_located: UIButton!                     // 定位按钮\n    \n    private weak var imgV_pointAnnotation: UIImageView!         // 自定义大头针\n</code></pre>\n<p>这里声明了实现地图用到的一些材料，当然最关键的是MAMapView了，这个View是高德提供的哦。</p>\n<h3 id=\"4-4-数据声明\"><a href=\"#4-4-数据声明\" class=\"headerlink\" title=\"4.4 数据声明\"></a>4.4 数据声明</h3><pre><code class=\"line-numbers language-Swift\">// Data\nvar navTitle: String?                                       // Nav标题 (可选)\nweak var delegate: GMLocationPickerControllerDelegate?      // 代理\nvar locationResultBlock: GMLocationResultHandler?\n\nprivate var locationInfos = [GMLocationPickerLocationInfo]()// 搜索 地点信息\nprivate var selectingLocationInfo: GMLocationPickerLocationInfo? // 选中地点信息\n\n// Pre Data\n\nvar preLocationInfo: GMLocationPickerLocationInfo?          // 预地理位置信息\nvar preCoordinate: CLLocationCoordinate2D?                  // 预经纬度\nvar preKeyword: String?                                     // 预搜索关键词\nvar pickerFor: GMLocationPickerFor = .warehouseCreate       // 地图选择用于\n</code></pre>\n<p>这里大致列举了需要用的数据。<br>预数据，就是外部传过来的数据，然后我们新建了两个info实体报错搜索的地址和选中的地址。</p>\n<h3 id=\"4-5-其它成员声明\"><a href=\"#4-5-其它成员声明\" class=\"headerlink\" title=\"4.5 其它成员声明\"></a>4.5 其它成员声明</h3><pre><code class=\"line-numbers language-Swift\">// Tool\nprivate var search: AMapSearchAPI!                          // 地图 搜索功能\nprivate var locationManager: AMapLocationManager!           // 地图 定位功能\nprivate var authorizationManager = TYLocationAuthorization()// 权限管理\n\n// flag\n\nprivate var lastSearchKey = &quot;&quot;                              // 最后搜索字段\nprivate var isRegionChangedFromCustomer = false             // 地图领域变化原因为用户手动滑动\nprivate var isReGeoRequestForSubmit = false                 // 逆地理请求用于提交\nprivate var viewDidAppear = false  \n</code></pre>\n<p>这里是一些工具和一些flag变量，工具包含地图搜索接口和地图定位功能工具，这些都是高德提供，另外权限是自定义的一个工具来处理的。</p>\n<h3 id=\"4-6-生命周期之viewDidLoad\"><a href=\"#4-6-生命周期之viewDidLoad\" class=\"headerlink\" title=\"4.6 生命周期之viewDidLoad\"></a>4.6 生命周期之viewDidLoad</h3><p>这个走一次，看下做了什么：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        self.layoutSubviews()\n        self.loadData()\n    &#125;\n</code></pre>\n<p>加载了子View，然后去加载数据。</p>\n<pre><code class=\"line-numbers language-Swift\">private func layoutSubviews() &#123;\n        \n        self.view.backgroundColor = .white\n        \n        // ------------------------- 导航栏 -------------------------\n        let submitBtnF: UIFont = .pingFangRegular(size: 16.0)\n        \n        let btn_submit = UIButton()\n        btn_submit.isEnabled = false\n        btn_submit.ty_setButtonWith(text: &quot;提交&quot;, font: submitBtnF, color: .ty_409EFF, state: .normal)\n        btn_submit.ty_setButtonWith(text: &quot;提交&quot;, font: submitBtnF, color: .ty_409EFF.alpha(0.5), state: .disabled)\n        btn_submit.addTarget(self, action: #selector(act_submitBtnClicked(button:)), for: .touchUpInside)\n        let item_submit = UIBarButtonItem(customView: btn_submit)\n        self.navigationItem.rightBarButtonItem = item_submit\n        self.btn_submit = btn_submit\n        \n        // ------------------------- 底部控件 -------------------------\n        let searchListBGW: CGFloat = yScreenWidth\n        let searchListBGH: CGFloat = 104.0\n        let searchListBGR = CGRect(x: 0, y: 0, width: searchListBGW, height: searchListBGH)\n        let searchListBGRadius = 16.0\n        let searchListBGRadiusS = CGSize(width: searchListBGRadius, height: searchListBGRadius)\n        \n        let view_searchListBG = UIView.ty_viewWith(bgColor: .ty_ThemeWhite)\n        view_searchListBG.ty_setCornerWith(rect: searchListBGR, corners: [.topLeft, .topRight], radii: searchListBGRadiusS)\n        self.view.addSubview(view_searchListBG)\n        view_searchListBG.snp.makeConstraints &#123; make in\n            make.bottom.equalTo(self.view.snp.bottom)\n            make.centerX.equalTo(self.view)\n            make.width.equalTo(searchListBGW)\n            make.height.equalTo(searchListBGH)\n        &#125;\n        \n        // 搜索栏\n        let searchBtnF: UIFont = .pingFangRegular(size: 14.0)\n        let searchBtnW: CGFloat = 80.0\n        let searchBtnH: CGFloat = 32.0\n        let searchBarTextFF: UIFont = .pingFangRegular(size: 14.0)\n        let searchBarTextFLeftImageS = CGSize(width: 16.0, height: 16.0)\n        let searchBarTextFLeftViewS = CGSize(width: 32.0, height: 32.0)\n        let searchBarTextFR: CGFloat = 10.0\n        let searchBarTextFH: CGFloat = searchBtnH\n        \n        // 搜索按钮\n        let btn_search = UIButton()\n        btn_search.ty_setButtonWith(text: &quot;搜索&quot;, font: searchBtnF, color: .ty_TextWhite, state: .normal)\n        btn_search.ty_setBackgroundColor(.ty_409EFF, state: .normal)\n        btn_search.ty_setCornerRadius(searchBtnH/2.0)\n        btn_search.addTarget(self, action: #selector(act_searchBtnClicked(button:)), for: .touchUpInside)\n        \n        view_searchListBG.addSubview(btn_search)\n        btn_search.snp.makeConstraints &#123; make in\n            make.top.equalTo(view_searchListBG).offset(ySuperVerPad)\n            make.right.equalTo(view_searchListBG).offset(-ySuperHorPad)\n            make.width.equalTo(searchBtnW)\n            make.height.equalTo(searchBtnH)\n        &#125;\n        \n        // 搜索栏\n        let textF_search = UITextField.ty_textFieldWith(font: searchBarTextFF, color: .ty_222222)\n        textF_search.backgroundColor = .ty_F7F9FA\n        textF_search.ty_setPlaceholderWith(placeholder: &quot;请输入地址&quot;, color: .ty_9B9DA7, font: searchBarTextFF)\n        textF_search.ty_setLeftPaddingImage(imageName: &quot;locationPicker_img_search&quot;, imageSize: searchBarTextFLeftImageS, paddingSize: searchBarTextFLeftViewS)\n        textF_search.ty_setCornerRadius(searchBarTextFH/2.0)\n        \n        textF_search.addTarget(self, action: #selector(act_searchTextFEditChange(textF:)), for: .editingChanged)\n        textF_search.addObserver(self, forKeyPath: &quot;text&quot;, options: [.new, .old], context: nil)\n        \n        textF_search.delegate = self\n        textF_search.returnKeyType = .search\n        \n        view_searchListBG.addSubview(textF_search)\n        self.textF_search = textF_search\n        textF_search.snp.makeConstraints &#123; make in\n            make.top.equalTo(view_searchListBG).offset(ySuperVerPad)\n            make.left.equalTo(view_searchListBG).offset(ySuperHorPad)\n            make.right.equalTo(btn_search.snp.left).offset(-searchBarTextFR)\n            make.height.equalTo(searchBarTextFH)\n        &#125;\n        \n        // TableView\n        let tableViewT: CGFloat = 6.0\n        \n        let tableView = TYTableView(delegate: self, dataSource: self, style: .plain)\n        tableView.showsVerticalScrollIndicator = false\n        view_searchListBG.addSubview(tableView)\n        self.tableView = tableView\n        tableView.snp.makeConstraints &#123; make in\n            make.top.equalTo(textF_search.snp.bottom).offset(tableViewT)\n            make.left.equalTo(view_searchListBG)\n            make.right.equalTo(view_searchListBG)\n            make.bottom.equalTo(view_searchListBG)\n        &#125;\n        \n        // loading 旋转图\n        let indicatorStyle: UIActivityIndicatorView.Style\n        if #available(iOS 13.0, * ) &#123;\n            indicatorStyle = .medium\n        &#125; else &#123;\n            indicatorStyle = .gray\n        &#125;\n        let ai_spinner = UIActivityIndicatorView(style: indicatorStyle)\n        ai_spinner.startAnimating()\n        view_searchListBG.addSubview(ai_spinner)\n        self.ai_spinner = ai_spinner\n        ai_spinner.snp.makeConstraints &#123; make in\n            make.center.equalTo(view_searchListBG)\n        &#125;\n        \n        // ------------------------- mapView -------------------------\n        let mapViewW: CGFloat = yScreenWidth\n        let mapViewH: CGFloat = yScreenHeight - searchListBGH + searchListBGRadius/2.0\n        let cus_mapViewR = CGRect(x: 0, y: 0, width: mapViewW, height: mapViewH)\n        \n        // MapView\n        let mapView = MAMapView(frame: cus_mapViewR)\n        mapView.zoomLevel = 13.0                // 缩放比例\n        mapView.showsCompass = false            // 显示罗盘\n        mapView.showsScale = false              // 显示比例尺\n        mapView.delegate = self\n        self.view.addSubview(mapView)\n        self.mapView = mapView\n        \n        // 大头针\n        let pointAnnotationImgVW: CGFloat = 40.0\n        let pointAnnotationImgVH: CGFloat = 40.0\n        let imgV_pointAnnotation = UIImageView.ty_imageViewWith(imageName: &quot;locationPicker_icon_point_annotation&quot;)\n        self.view.addSubview(imgV_pointAnnotation)\n        self.imgV_pointAnnotation = imgV_pointAnnotation\n        imgV_pointAnnotation.snp.makeConstraints &#123; make in\n            make.centerX.equalTo(mapView)\n            make.centerY.equalTo(mapView).offset(-pointAnnotationImgVH/2.0)\n            make.width.equalTo(pointAnnotationImgVW)\n            make.height.equalTo(pointAnnotationImgVH)\n        &#125;\n        \n        // 回归定位按钮\n        let locatedBtnWH: CGFloat = 46.0\n        let locatedBtnR: CGFloat = 9.0\n        let locatedBtnB: CGFloat = 9.0\n        \n        let btn_located = UIButton()\n        btn_located.setImage(UIImage(named: &quot;locationPicker_btn_located_Blue&quot;), for: .selected)     // 在当前定位\n        btn_located.setImage(UIImage(named: &quot;locationPicker_btn_located_Black&quot;), for: .normal)      // 不在当前定位\n        btn_located.addTarget(self, action: #selector(act_locatedBtnClicked(button:)), for: .touchUpInside)\n        self.view.addSubview(btn_located)\n        self.btn_located = btn_located\n        btn_located.snp.makeConstraints &#123; make in\n            make.right.equalTo(self.view).offset(-locatedBtnR)\n            make.bottom.equalTo(view_searchListBG.snp.top).offset(-locatedBtnB)\n            make.width.equalTo(locatedBtnWH)\n            make.height.equalTo(locatedBtnWH)\n        &#125;\n        \n        self.view.bringSubviewToFront(view_searchListBG)\n    &#125;\n</code></pre>\n<p>逻辑也是非常清晰，一个一个把视图堆叠进去了。<br>这里大头针跟地图一点关系没有，这个只是把大头针放在中间而已。没有跟地图绑定任何关系。</p>\n<p>然后去加载数据：</p>\n<pre><code class=\"line-numbers language-Swift\">private func loadData() &#123;\n    // 设置标题\n    if let navTitle = self.navTitle, !navTitle.isEmpty &#123;\n        self.title = &quot;\\(navTitle) 地图定位&quot;\n    &#125; else &#123;\n        self.title = &quot;地图定位&quot;\n    &#125;\n    \n    // 定位功能\n    // 更新App是否显示隐私弹窗的状态，隐私弹窗是否包含高德SDK隐私协议内容的状态\n    AMapLocationManager.updatePrivacyShow(.didShow, privacyInfo: .didContain)\n    // 更新用户授权高德SDK隐私协议状态\n    AMapLocationManager.updatePrivacyAgree(.didAgree)\n    let locationManager = AMapLocationManager()\n    locationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters\n    if #available(iOS 14.0, *) &#123;\n        locationManager.locationAccuracyMode = .fullAccuracy\n    &#125;\n    self.locationManager = locationManager\n    \n    // 搜索\n    let search = AMapSearchAPI()\n    search?.timeout = 10\n    search?.delegate = self\n    self.search = search\n    \n    // 预地理位置信息处理\n    self.data_preLocatedHandle(locationInfo: self.preLocationInfo,\n                                preCoordinate: self.preCoordinate,\n                                preKeyword: self.preKeyword)\n&#125;\n</code></pre>\n<p>这里设置了标题，然后就去走预地理位置信息处理的方法。这里的pre相关的数据，在跳转前，就给这个controller赋值了，这里跟Android不太一样，Android还要通过intent来传，它这个居然可以直接用controller的实例传值。</p>\n<p>具体预制方法为：</p>\n<pre><code class=\"line-numbers language-Swift\">/// 根据预地理位置信息 按照优先级 决定预定位方式\nfunc data_preLocatedHandle(locationInfo: GMLocationPickerLocationInfo? = nil,\n                            preCoordinate: CLLocationCoordinate2D? = nil, preKeyword: String? = nil) &#123;\n    \n    // 预定位处理规则\n    // 完整数据 - 经纬度 - 位置关键词 - 实时定位 - 默认&#39;北京&#39;定位\n    if let preLocationInfo = locationInfo &#123;\n        // 1.完整信息\n        if let coordinate = preLocationInfo.coordinate,\n            coordinate.latitude != 0, coordinate.longitude != 0 &#123;\n            // 1.1 经纬度信息完整\n            self.data_changeRegionTo(preLocationInfo, for: .itemSelected)\n            self.map_searchLocationForNearby()  // 搜索附近\n        &#125; else if !preLocationInfo.address.isEmpty &#123;\n            // 1.2 无经纬度、有地名：搜索地名\n            let searchKey = &quot;\\(preLocationInfo.city)\\(preLocationInfo.district)\\(preLocationInfo.address)&quot;\n            self.data_preLocatedHandle(preKeyword: searchKey)\n        &#125; else &#123;\n            // 1.3 都没有：默认操作\n            self.data_preLocatedHandle()\n        &#125;\n    &#125; else if let preCoordinate = preCoordinate &#123;\n        // 2.显示经纬度位置\n        self.mapView.centerCoordinate = preCoordinate\n        self.map_searchLocationForReGeo(isForSubmit: false) // 搜索逆地理编码\n    &#125; else if let preKeyword = preKeyword, preKeyword.count &gt; 0 &#123;\n        // 3.关键词配置\n        self.textF_search.text = preKeyword\n        self.act_searchBtnClicked(button: nil)\n    &#125; else &#123;\n        var isLocationEnable = self.authorizationManager.isLocationAuthroizationEnable()\n        if #available(iOS 14.0, *) &#123;\n            isLocationEnable = isLocationEnable &amp;&amp; self.authorizationManager.isAccuracyAuthorizationFull()\n        &#125;\n        if isLocationEnable &#123;\n            // 4.实时定位\n            self.act_locatedBtnClicked(button: nil)\n        &#125; else &#123;\n            // 5.默认北京\n            self.mapView.centerCoordinate = CLLocationCoordinate2D(latitude: 39.909115, longitude: 116.397535)\n            self.map_searchLocationForReGeo(isForSubmit: false) // 搜索逆地理编码\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里就是一段逻辑，如果之前有地址，然后如何去显示的逻辑。如何去移动地图。<br>主要是用了一个 self.mapView.centerCoordinate来设置地图中心坐标，然后这里调用搜索词是走了这个方法：</p>\n<pre><code class=\"line-numbers language-Swift\">/// 根据当前地图中间位置 搜索逆地理\n/// - Parameter isForSubmit: 用于提交 or 用户滑动地理获取(顺带搜索附近)\nprivate func map_searchLocationForReGeo(isForSubmit: Bool) &#123;\n    self.isReGeoRequestForSubmit = isForSubmit\n    if isForSubmit &#123;\n        self.ty_showLoadingHUD()\n    &#125; else &#123;\n        // 清空列表数据\n        self.data_reloadTableViewToEmpty(forRequest: true)\n    &#125;\n    \n    // 取消上一个请求\n    self.search.cancelAllRequests()\n    \n    // 逆地理位置请求\n    let coordinate = self.mapView.centerCoordinate\n    let regeo = AMapReGeocodeSearchRequest()\n    regeo.location = AMapGeoPoint.location(withLatitude: coordinate.latitude, longitude: coordinate.longitude)\n    regeo.requireExtension = true\n    self.search.aMapReGoecodeSearch(regeo)\n&#125;\n</code></pre>\n<p>这里根据地图中心位置调用了搜索接口,具体请求在这里：</p>\n<pre><code class=\"line-numbers language-Swift\">self.search.aMapReGoecodeSearch(regeo)\n</code></pre>\n<p>如何搜索附近地址呢？</p>\n<pre><code class=\"line-numbers language-Swift\">/// 根据选中位置 搜索附近POI\nprivate func map_searchLocationForNearby() &#123;\n    guard let coordinate = self.selectingLocationInfo?.coordinate else &#123; return &#125;\n    // 清空列表数据\n    self.data_reloadTableViewToEmpty(forRequest: true)\n    \n    // 取消上一个请求\n    self.search.cancelAllRequests()\n    \n    // 附近搜索请求\n    let aroundRequest = AMapPOIAroundSearchRequest()\n    let geoPoint = AMapGeoPoint.location(withLatitude: coordinate.latitude,\n                                            longitude: coordinate.longitude)\n    aroundRequest.location = geoPoint\n//        aroundRequest.special = true\n    self.search.aMapPOIAroundSearch(aroundRequest)\n&#125;\n</code></pre>\n<p>跟上面方法也比较类似。</p>\n<h3 id=\"4-7-生命周期之viewWillAppear\"><a href=\"#4-7-生命周期之viewWillAppear\" class=\"headerlink\" title=\"4.7 生命周期之viewWillAppear\"></a>4.7 生命周期之viewWillAppear</h3><pre><code class=\"line-numbers language-Swift\">override func viewWillAppear(_ animated: Bool) &#123;\n        super.viewWillAppear(animated)\n        setupWhiteNavBarColor()\n        setupWhiteClickCallBack()\n        \n        isHiddenNavBar(isHidden: false)\n    &#125;\n</code></pre>\n<p>主要处理了导航栏相关的。</p>\n<h3 id=\"4-8-生命周期之viewDidAppear\"><a href=\"#4-8-生命周期之viewDidAppear\" class=\"headerlink\" title=\"4.8 生命周期之viewDidAppear\"></a>4.8 生命周期之viewDidAppear</h3><pre><code class=\"line-numbers language-Swift\">override func viewDidAppear(_ animated: Bool) &#123;\n        super.viewDidAppear(animated)\n        self.viewDidAppear = true\n    &#125;\n</code></pre>\n<p>这里没干啥，就设置了一个flag。</p>\n<h3 id=\"4-9-析构函数\"><a href=\"#4-9-析构函数\" class=\"headerlink\" title=\"4.9 析构函数\"></a>4.9 析构函数</h3><pre><code class=\"line-numbers language-Swift\">deinit &#123;\n        self.tydev_logDeinit()\n    &#125;\n</code></pre>\n<p>这里也没干啥，打印下日志：</p>\n<pre><code class=\"line-numbers language-Swift\">/// 输出对象销毁日志\nfunc tydev_logDeinit() &#123;\n    self.tydev_logDeinit(nil)\n&#125;\n\n/// 输出对象销毁日志\n/// - Parameter mark: 自定义标识\nfunc tydev_logDeinit(_ mark: String?) &#123;\n    if let mark = mark &#123;\n        print(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; deinit view [\\(self)] (\\(mark) &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;)\n    &#125; else &#123;\n        print(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; deinit view [\\(self)] &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;)\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"4-10-地图代理\"><a href=\"#4-10-地图代理\" class=\"headerlink\" title=\"4.10 地图代理\"></a>4.10 地图代理</h3><p>前面我们设置了代理为自己，需要处理下：</p>\n<pre><code class=\"line-numbers language-Swift\">// 地图Delegate - Map\nextension GMLocationPickerController : MAMapViewDelegate &#123;\n    \n    /// 地图区域改变完成后会调用此接口\n    func mapView(_ mapView: MAMapView!, regionDidChangeAnimated animated: Bool) &#123;\n        if !self.viewDidAppear &#123; return &#125;\n        \n        // 大头针动画\n        self.ui_pointAnnotationAnimate()\n        if self.isRegionChangedFromCustomer, self.mapView.userTrackingMode == .none &#123;\n            // 用户手动滑动模式\n            // 搜索逆地理编码(顺带搜索附近)\n            self.map_searchLocationForReGeo(isForSubmit: false)\n        &#125;\n        self.isRegionChangedFromCustomer = true\n    &#125;\n&#125;\n</code></pre>\n<p>这里是高德自己调用的，估计是滑动后区域改变，这里会走。<br>这里我们走完后需要顺带搜索下附近地址，所以需要加上我们自己逻辑哦。</p>\n<h3 id=\"4-11-搜索代理\"><a href=\"#4-11-搜索代理\" class=\"headerlink\" title=\"4.11 搜索代理\"></a>4.11 搜索代理</h3><pre><code class=\"line-numbers language-Swift\">// 地图Delegate - Search\nextension GMLocationPickerController : AMapSearchDelegate &#123;\n    /// POI查询回调函数 [定位获取附近POI、搜索POI]\n    func onPOISearchDone(_ request: AMapPOISearchBaseRequest!, response: AMapPOISearchResponse!) &#123;\n//        if response.pois.count &lt;= 0 &#123;\n//            GMBannerTips.showWarningTips(&quot;没有找到定位&quot;)\n//            data_reloadTableViewToEmpty(forRequest: false)\n//            return\n//        &#125;\n        \n        let prefixPois = response.pois.prefix(20)     // 最多获取20个数据\n        var locationInfos = prefixPois.map(&#123; GMLocationPickerLocationInfo(mapPOI: $0) &#125;)\n        \n        if request.isKind(of: AMapPOIKeywordsSearchRequest.self) &#123;\n            // 1. 搜索关键词(搜索关键词)\n            \n            // 没有搜索到则提示\n            if response.pois.count &lt;= 0 &#123;\n                GMBannerTips.showWarningTips(&quot;没有找到定位&quot;)\n                data_reloadTableViewToEmpty(forRequest: false)\n                return\n            &#125;\n            \n            // 自动选择第一个位置\n            var selectingInfo = self.selectingLocationInfo\n            if let firstInfo = locationInfos.first &#123;\n                selectingInfo = firstInfo\n                // 移动地图位置\n                self.data_changeRegionTo(firstInfo, for: .keywordSearchSelected)\n            &#125;\n            // 搜索POI距离补全\n            if let selectingInfo = selectingInfo, let selectingCoordinate = selectingInfo.coordinate &#123;\n                let selectingPoint = MAMapPointForCoordinate(selectingCoordinate)\n                for currLocationInfo in locationInfos &#123;\n                    if selectingInfo == currLocationInfo &#123; continue &#125;\n                    if let currCoordinate = currLocationInfo.coordinate &#123;\n                        let currPoint = MAMapPointForCoordinate(currCoordinate)\n                        currLocationInfo.distance = Int(MAMetersBetweenMapPoints(selectingPoint,currPoint))\n                    &#125;\n                &#125;\n            &#125;\n            \n        &#125; else if request.isKind(of: AMapPOIAroundSearchRequest.self) &#123;\n            // 2. 搜索附近位置(定位or选中)\n            \n            // 没有找到定位 则选中当前选中的定位\n            if prefixPois.count &lt;= 0, let selectingInfo = self.selectingLocationInfo &#123;\n                locationInfos.insert(selectingInfo, at: 0)\n            &#125;\n            \n            // 则确保第一个选项为当前地理位置（不匹配则手动添加）\n            if let firstInfo = locationInfos.first, let selectingInfo = self.selectingLocationInfo,\n               firstInfo.poiName != selectingInfo.poiName, firstInfo.address != selectingInfo.address &#123;\n                // 当前第一个位置 非选中中位置\n                locationInfos.insert(selectingInfo, at: 0)\n            &#125;\n            if let firstInfo = locationInfos.first &#123;\n                // 纠正/同步选择中地理位置\n                self.selectingLocationInfo = firstInfo\n            &#125;\n        &#125;\n        \n        // 刷新TableView数据\n        self.data_reloadTableViewWith(locationInfos: locationInfos)\n    &#125;\n    \n    /// 逆地理编码回调 [手动滑动地图时用]\n    func onReGeocodeSearchDone(_ request: AMapReGeocodeSearchRequest!, response: AMapReGeocodeSearchResponse!) &#123;\n        if self.isReGeoRequestForSubmit &#123;\n            // 1. 用于提交的逆地理编码搜索\n            self.ty_hideLoadingHUD()\n            self.isReGeoRequestForSubmit = false\n            \n            guard let location = request.location, let regeocode = response.regeocode else &#123; return &#125;\n            \n            self.view.endEditing(true)\n            let selectingInfo = GMLocationPickerLocationResult(location: location, reGeocode: regeocode, locationInfo: self.selectingLocationInfo)\n            \n            // 提交地址\n            self.delegate?.locationPickerController(self, didSubmit: selectingInfo)\n            locationResultBlock?(selectingInfo)\n            self.popViewController()\n        &#125; else &#123;\n            // 2. 用于用户滑动的逆地理编码搜索\n            guard let location = request.location, let regeocode = response.regeocode else &#123; return &#125;\n            \n            // 设置 locationInfos\n            let prefixPois = regeocode.pois.prefix(20)     // 最多获取20个数据\n            var locationInfos = prefixPois.map(&#123; GMLocationPickerLocationInfo(mapPOI: $0) &#125;)\n            \n            let selectingInfo = GMLocationPickerLocationInfo(location: location, reGeocode: regeocode)\n            // 移动地图位置\n            self.data_changeRegionTo(selectingInfo, for: .slideByCustomer)\n            locationInfos.insert(selectingInfo, at: 0)\n            \n            // 刷新TableView数据\n            self.data_reloadTableViewWith(locationInfos: locationInfos)\n        &#125;\n    &#125;\n    \n    /// 当请求发生错误 (timeout)\n    func aMapSearchRequest(_ request: Any!, didFailWithError error: Error!) &#123;\n        let errorCode = error._code\n        \n        var errMsg = &quot;&quot;\n        if let searchErrorCode = AMapSearchErrorCode(rawValue: errorCode) &#123;\n            switch searchErrorCode &#123;\n            case .notConnectedToInternet:   break// 网络连接异常\n                //errMsg = AMapSearchError.errorInfo(with: searchErrorCode)\n            default:\n                break\n            &#125;\n        &#125; else &#123;\n            print(&quot;asdf&quot;)\n        &#125;\n        if !errMsg.isEmpty &#123;\n            self.ty_showMsgHud(errMsg)\n        &#125;\n    &#125;\n    \n&#125;\n</code></pre>\n<p>这里是高德提供的搜索代理。<br>一个是手动滑动，一个是自行搜索，走接口不一样哦。</p>\n<h3 id=\"4-12-其它代理\"><a href=\"#4-12-其它代理\" class=\"headerlink\" title=\"4.12 其它代理\"></a>4.12 其它代理</h3><pre><code class=\"line-numbers language-Swift\">\n// TableView Delegate\nextension GMLocationPickerController: UITableViewDelegate, UITableViewDataSource &#123;\n    \n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n        return self.locationInfos.count\n    &#125;\n\n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n        let cell = GMLocationPickerCell.cellWithTableView(tableView)\n        cell.locationInfo = self.locationInfos[indexPath.row]\n        return cell\n    &#125;\n    \n    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n        return GMLocationPickerCell.cellHeight()\n    &#125;\n    \n    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123;\n        let locationInfo = self.locationInfos[indexPath.row]\n        // 清除搜索栏内容\n        self.ui_clearSearchTextF()\n        // 移动地图位置\n        self.data_changeRegionTo(locationInfo, for: .itemSelected)\n        // 搜索附近\n        self.map_searchLocationForNearby()\n    &#125;\n&#125;\n\n// 输入框 &amp; 自定义 Delegate\nextension GMLocationPickerController : UITextFieldDelegate\n&#123;\n    func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool &#123;\n        // 搜索\n        self.act_searchBtnClicked(button: nil)\n        return true\n    &#125;\n&#125;\n</code></pre>\n<p>这里还用了2个代理，一个是搜索列表的tableView的列表展示，一个是搜索框代理。</p>\n<h3 id=\"4-13-如何定位\"><a href=\"#4-13-如何定位\" class=\"headerlink\" title=\"4.13 如何定位\"></a>4.13 如何定位</h3><pre><code class=\"line-numbers language-Swift\">/// 定位当前位置\nprivate func map_requestLocation(_ completion: ((CLLocation?, AMapLocationReGeocode?) -&gt; ())?) &#123;\n    // 定位请求\n    func requestLocation(_ completion: ((CLLocation?, AMapLocationReGeocode?) -&gt; ())?) &#123;\n        // 单次定位\n        self.locationManager.requestLocation(withReGeocode: true, completionBlock: &#123; (location: CLLocation?, reGeocode: AMapLocationReGeocode?, error: Error?) in\n            // 定位回调\n            if let completion = completion &#123; completion(location, reGeocode) &#125;\n        &#125;)\n    &#125;\n    \n    let manager = self.authorizationManager\n    manager.verifyLocationAuthroization(showAlertIn: self, completion: &#123;\n        if #available(iOS 14.0, *) &#123;\n            manager.verifyAccuracyAuthroization(completion: &#123;\n                requestLocation(completion)\n            &#125;, failure: nil)\n        &#125; else &#123;\n            requestLocation(completion)\n        &#125;\n    &#125;, failure: nil)\n&#125;\n</code></pre>\n<p>别慌，高德也是提供了方法，支持去定位。</p>\n<h3 id=\"4-14-地址权限工具\"><a href=\"#4-14-地址权限工具\" class=\"headerlink\" title=\"4.14 地址权限工具\"></a>4.14 地址权限工具</h3><pre><code class=\"line-numbers language-Swift\">/// 地址权限管理器 配置\nclass TYLocationAuthorizationConfig: NSObject &#123;\n    \n    // info.plist 上配置的 精读权限获取描述\n    // &lt;key&gt;NSLocationTemporaryUsageDescriptionDictionary&lt;/key&gt;\n    var accuracyPurposeKey = &quot;AccuracyUsageDescription&quot;\n    \n    var locationAlertTitle = &quot;您需要开启GPS权限&quot;\n    var locationAlertMessage = &quot;地图定位需要获取您的GPS权限才能正常使用&quot;\n&#125;\n\n/// 地址权限管理器\nclass TYLocationAuthorization: NSObject &#123;\n    \n    //MARK: - property\n    \n    // Data\n    \n    private var locationManager: CLLocationManager!             // 定位权限管理\n    \n    private var locationAuthVerifyCompletion: (() -&gt; ())?       // 定位权限获取完成Block (用于权限首次询问)\n    private var locationAuthVerifyFailure: (() -&gt; ())?          // 定位权限获取失败Block (用于权限首次请求)\n    \n    private var config = TYLocationAuthorizationConfig()              // 文本相关配置\n    \n    // State\n    \n    /// 定位权限状态\n    var locationAuthorization: CLAuthorizationStatus &#123;\n        if #available(iOS 14.0, *) &#123;\n            return self.locationManager.authorizationStatus\n        &#125; else &#123;\n            return CLLocationManager.authorizationStatus()\n        &#125;\n    &#125;\n    \n    /// 精读权限状态\n    @available(iOS 14.0, *)\n    var accuracyAuthorization: CLAccuracyAuthorization &#123;\n        return self.locationManager.accuracyAuthorization\n    &#125;\n    \n    \n    //MARK: - life cycle\n    \n    convenience init(config: TYLocationAuthorizationConfig) &#123;\n        self.init()\n        self.config = config\n    &#125;\n    \n    override init() &#123;\n        super.init()\n        self.loadData()\n    &#125;\n    \n    private func loadData() &#123;\n        // 定位权限管理\n        let locationManager = CLLocationManager()\n        locationManager.delegate = self\n        self.locationManager = locationManager\n    &#125;\n    \n    deinit &#123;\n        print(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; deinit view [\\(self)] &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;)\n    &#125;\n    \n    //MARK: - public methods\n    \n    // ------------------------- 权限请求封装 -------------------------\n    \n    /// 定位权限判断\n    func verifyLocationAuthroization(showAlertIn controller: UIViewController? = nil,\n                                     completion: (() -&gt; ())? = nil,\n                                     failure: (() -&gt; ())? = nil) &#123;\n\n        switch self.locationAuthorization &#123;\n        case .notDetermined:                            // 1. 首次打开App时\n            self.locationAuthVerifyCompletion = completion\n            self.locationAuthVerifyFailure = failure\n            self.locationManager.requestWhenInUseAuthorization()    // 使用时 *\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            self.ui_showAlertForDeniedLocationAuthorization(in: controller)\n            if let failure = failure &#123; failure() &#125;\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            if let completion  = completion &#123; completion() &#125;\n        @unknown default:                               // 4. 未知情况\n            self.ui_showAlertForDeniedLocationAuthorization(in: controller)\n            if let failure = failure &#123; failure() &#125;\n        &#125;\n    &#125;\n    \n    /// 精读权限判断(高精读)\n    @available(iOS 14.0, *)\n    func verifyAccuracyAuthroization(completion: (() -&gt; ())? = nil,\n                                     failure: (() -&gt; ())? = nil) &#123;\n        if self.isAccuracyAuthorizationFull() &#123;\n            if let completion = completion &#123; completion() &#125;\n        &#125; else &#123;\n            let key = self.config.accuracyPurposeKey\n            self.locationManager.requestTemporaryFullAccuracyAuthorization(withPurposeKey: key) &#123; err in\n                if self.isAccuracyAuthorizationFull() &#123;\n                    if let completion = completion &#123; completion() &#125;\n                &#125; else &#123;\n                    if let failure = failure &#123; failure() &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    \n    // ------------------------- 权限状态 -------------------------\n    \n    /// 定位权限是否被拒绝\n    func isLocationAuthroizationDenied() -&gt; Bool &#123;\n        switch self.locationAuthorization &#123;\n        case .notDetermined:                            // 1. 首次打开App时\n            return false\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            return true\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            return false\n        @unknown default:                               // 4. 未知情况\n            return true\n        &#125;\n    &#125;\n    \n    /// 定位权限是否被允许\n    func isLocationAuthroizationEnable() -&gt; Bool &#123;\n        switch self.locationAuthorization &#123;\n        case .notDetermined:                            // 1. 首次打开App时\n            return false\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            return false\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            return true\n        @unknown default:                               // 4. 未知情况\n            return false\n        &#125;\n    &#125;\n    \n    /// 精准定位\n    @available(iOS 14.0, *)\n    func isAccuracyAuthorizationFull() -&gt; Bool &#123;\n        return self.locationManager.accuracyAuthorization == .fullAccuracy\n    &#125;\n    \n    //MARK: - private methods\n    \n    /// 显示定位权限拒绝 Alert\n    private func ui_showAlertForDeniedLocationAuthorization(in controller: UIViewController?) &#123;\n        guard let controller = controller else &#123; return &#125;\n\n        let title = self.config.locationAlertTitle\n        let message = self.config.locationAlertMessage\n        let alertVC = UIAlertController.ty_doubleOptionAlertWith(title: title, message: message, optionTitle1: &quot;去设置&quot;, action1: &#123;\n            if let settingURL = URL(string: UIApplication.openSettingsURLString),\n                UIApplication.shared.canOpenURL(settingURL) &#123;\n                UIApplication.shared.open(settingURL, options: [:], completionHandler: nil)\n            &#125;\n        &#125;, optionTitle2: &quot;取消&quot;, action2: nil)\n        controller.present(alertVC, animated: true, completion: nil)\n    &#125;\n    \n    \n    /// 清空 定位权限获取Block\n    private func clearLocationAuthorizationBlock() &#123;\n        self.locationAuthVerifyCompletion = nil\n        self.locationAuthVerifyFailure = nil\n    &#125;\n&#125;\n\nextension TYLocationAuthorization : CLLocationManagerDelegate &#123;\n    \n    /// 定位权限修改 (iOS 4.2 - 14.0)\n    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) &#123;\n        self.data_locationAuthorizationDidChange()\n    &#125;\n    \n    /// 定位权限修改 (iOS 14.0+)\n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) &#123;\n        self.data_locationAuthorizationDidChange()\n    &#125;\n    \n    /// 权限状态修改\n    private func data_locationAuthorizationDidChange() &#123;\n        if self.locationAuthVerifyCompletion == nil, self.locationAuthVerifyFailure == nil &#123; return &#125;\n              \n        switch self.locationAuthorization &#123;\n        case .notDetermined:                            // 1. 首次打开App时\n            break\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            if let failure = self.locationAuthVerifyFailure &#123; failure() &#125;\n            self.clearLocationAuthorizationBlock()\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            if let completion = self.locationAuthVerifyCompletion &#123; completion() &#125;\n            self.clearLocationAuthorizationBlock()\n        @unknown default:                               // 4. 未知情况\n            if let failure = self.locationAuthVerifyFailure &#123; failure() &#125;\n            self.clearLocationAuthorizationBlock()\n        &#125;\n        \n    &#125;\n&#125;\n</code></pre>\n<p>这里需要考虑到多种情况，是否拒绝权限，是否拥有了权限以及不同手机系统的问题。<br>用法也是相当简单：</p>\n<pre><code class=\"line-numbers language-Swift\">let manager = self.authorizationManager\nmanager.verifyLocationAuthroization(showAlertIn: self, completion: &#123;\n    if #available(iOS 14.0, *) &#123;\n        manager.verifyAccuracyAuthroization(completion: &#123;\n            requestLocation(completion)\n        &#125;, failure: nil)\n    &#125; else &#123;\n        requestLocation(completion)\n    &#125;\n&#125;, failure: nil)\n</code></pre>\n<p>这个manager就是我们的工具类。</p>\n<p>大致就是这么多了。</p>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5 总结\"></a>5 总结</h2><ul>\n<li><p>如果要做一个需要三方支持的东西，请务必要提前调研下，如地图，推送，埋点等，这些最后提前了解下三方的接入指南，这样更好去实现需求。</p>\n</li>\n<li><p>高德地图对接非常简单，拿到key后，主要工作就是对Map的处理，用户行为二指缩放这种高德自行实现，我们只需要设置坐标给中间的位置即可。</p>\n</li>\n<li><p>对于地图，一定要考虑是否有权限的情况，没有权限的情况也需要跳转到系统设置，这样才能加强用户体验。万万不可出现没有权限直接闪退的问题。</p>\n</li>\n<li><p>一般做地图都会有一个搜索能力，这样就需要高德搜索接口了，需要了解AMapSearchAPI 这个接口的用法，定位的话就用到AMapLocationManager。</p>\n</li>\n</ul>\n"},{"title":"iOS-swift-自定义View之时间选择器","date":"2023-01-28T01:56:57.000Z","top":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 需求分析\n当我们选择购买一个东西时，有时需要预约发货，这时候需要用户手动选择某一天某一个时间，ui给的方案是这样的：\n预约日期：\n<img src=%E9%A2%84%E7%BA%A6%E6%97%A5%E6%9C%9F.png>\n\n预约时间：\n<img src=%E9%A2%84%E7%BA%A6%E6%97%B6%E9%97%B4.png>\n这里是间隔了2个小时一个时间。\n\n可以看到这个日期是以日历形式展现，可以选择未来某个日期；时间是以滚轮的方式展现，可以上下滑动到目标时间点。\n\n对于这个需求，我们要如何实现呢？‘\n\n答案当然是自定义View了。\n\n## 2 结构分析\n显而易见，这个因为设计到分页，我们可以考虑分页区域使用一个UIScrollView，水平滑动，宽度设置为屏幕的2倍，一半用来展示日历，一半用来展示预约时间的UIPickerView。\n\n所以需要我们自定义一个UIView，这里面先绘制顶部分割线，再绘制标题，“预约日期”和“预约时间”和“取消”的文案。\n\n然后是一个显示日历操作栏，包括左右箭头和中间的月份显示，这个要放到UIScrollView的左半边，包括星期视图和日历的UICollectionView的集合View，这里日历我们采用这个集合View很容易实现的。\n\n然后右侧就是一个UIPickerView,这个系统封装好了，使用很方便，我们主要负责填充数据。\n\n那这个结构大体出来了，一个是整个自定义View，暂且把它叫做CalenderView，还有一个就是日历内部的Cell，暂且叫做CalenderCell。\n\n## 3 撸下CalenderView\n\n### 3.1 全局变量\n\n```Swift\nclass CalendarView: UIView {\n    \n    /// 传出去给调用者\n    typealias DoneBlock = (TimeModel)->()\n    var doneHandle: DoneBlock!\n    \n    // 当月日期Model\n    var modelArr: [TimeModel] = []\n    \n    // 动态调整上下月的时间变量\n    var dynamicDate = Date()\n    \n    //默认选中的日期\n    var timeModel: TimeModel = TimeModel()\n    \n    //时间时短数据\n    static let range: String = \"                      \"\n    private var timeArr: [String] = [\"08:00\\(range)10:00\",\n                                   \"10:00\\(range)12:00\",\n                                   \"12:00\\(range)14:00\",\n                                   \"14:00\\(range)16:00\",\n                                   \"16:00\\(range)18:00\",\n                                   \"18:00\\(range)20:00\",\n                                   \"20:00\\(range)22:00\"]\n    private var selectIndex = 0\n    \n```\n这里定义了一个闭包返回，主要是用户选择后，回调给外部。\n\n然后有一个TimeModel的数组， 也就是填充我们的日历视图。\n\ntimeModel是我们选择的日期，会高亮显示。\n\ntimeArr是我们右侧使用的UIPickerView要用的数据。\n\n### 3.2 UI定义\n\n这里我们大致会用到这些视图。\n```Swift\n//白色背景底 整个半屏的视图\nprivate lazy var acView: UIView = {\n    let view = UIView()\n    view.backgroundColor = .white\n    return view\n}()\n\n//选中条\nprivate lazy var lineView: UIView = {\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: \"#409EFF\")\n    return view\n}()\n\n/// 预约日期按钮\nprivate lazy var dateBtn: UIButton = {\n    let btn = UIButton()\n    btn.setTitle(\"预约日期\", for: .normal)\n    btn.titleFont = .pingFangMedium(size: 16)\n    btn.setTitleColor(UIColor.lightGray, for: .normal)\n    btn.setTitleColor(UIColor.black, for: .selected)\n    btn.addTarget(self, action: #selector(actionForChooseDate), for: .touchUpInside)\n    btn.isSelected = true\n    return btn\n}()\n\n/// 预约时间按钮\nprivate lazy var timeBtn: UIButton = {\n    let btn = UIButton()\n    btn.setTitle(\"预约时间\", for: .normal)\n    btn.titleFont = .pingFangMedium(size: 16)\n    btn.setTitleColor(UIColor.lightGray, for: .normal)\n    btn.setTitleColor(UIColor.black, for: .selected)\n    btn.addTarget(self, action: #selector(actionForChooseTime), for: .touchUpInside)\n    return btn\n}()\n\n/// 取消按钮\nprivate lazy var cancelBtn: UIButton = {\n    let btn = UIButton()\n    btn.setTitle(\"取消\", for: .normal)\n    btn.setTitleColor(UIColor.init(hex: \"#409EFF\"), for: .normal)\n    btn.titleFont = .pingFangRegular(size: 16)\n    btn.addTarget(self, action: #selector(actionForCancel), for: .touchUpInside)\n    return btn\n}()\n\n//日历工具条\nprivate lazy var dateToolView: UIView = {\n    let view = UIView()\n    return view\n}()\n\n//日历工具条显示当前月份标签\nprivate lazy var monthLb: UILabel = {\n    let lab = UILabel()\n    lab.font = .pingFangMedium(size: 16)\n    lab.textColor = UIColor.init(hex: \"#3B4058\")\n    lab.text = \"\"\n    lab.textAlignment = .center\n    return lab\n}()\n\n//日历工具条左箭头\nprivate lazy var toolLeftBtn: UIButton = {\n    let btn = UIButton()\n    btn.setImage(UIImage.init(named: \"日历_左箭头\"), for: .normal)\n    btn.addTarget(self, action: #selector(actionForLeftEvent), for: .touchUpInside)\n    btn.isHidden = true\n    return btn\n}()\n\n//日历工具条右箭头\nprivate lazy var toolRightBtn: UIButton =  {\n    let btn = UIButton()\n    btn.setImage(UIImage.init(named: \"日历_右箭头\"), for: .normal)\n    btn.addTarget(self, action: #selector(actionForRightEvent), for: .touchUpInside)\n    return btn\n}()\n\n//星期X显示条\nprivate lazy var weeksView: UIView = {\n    let view = UIView()\n    view.backgroundColor = .white\n    view.layer.shadowColor = UIColor.init(hex: \"#7D7E80\").cgColor\n    view.layer.shadowOffset = CGSize.init(width: 0, height: 2)\n    view.layer.shadowRadius = 10\n    view.layer.shadowOpacity = 0.16\n    return view\n}()\n\n//滚动视图 左右滚动\nprivate lazy var scrollView: UIScrollView = {\n    let _scrollView = UIScrollView()\n    _scrollView.contentSize = CGSize.init(width: ScreenWidth*2, height: _scrollView.size.height)\n    _scrollView.bounces = false\n    _scrollView.isScrollEnabled = true\n    _scrollView.isPagingEnabled = true\n    _scrollView.showsVerticalScrollIndicator = false\n    _scrollView.showsHorizontalScrollIndicator = false\n    return _scrollView\n}()\n\n//月份水印背景\nprivate lazy var watermarkView: CalendarWatermark = {\n    let view = CalendarWatermark()\n    view.backgroundColor = .white\n    view.isHidden = true  //当前版本隐藏水印\n    return view\n}()\n\n//日历展示表\n    private lazy var collectionView: UICollectionView = {\n        let layout = UICollectionViewFlowLayout()\n        layout.scrollDirection = .vertical\n        let collection = UICollectionView(frame: CGRect.init(x: 0, y: 34+40, width: ScreenWidth, height: ScreenHeight*0.57*0.57), collectionViewLayout: layout)\n        collection.backgroundColor = .clear\n        collection.delegate = self\n        collection.dataSource = self\n        collection.isPagingEnabled = true\n        collection.showsHorizontalScrollIndicator = false\n        collection.bounces = false\n        collection.register(CalendarCell.self, forCellWithReuseIdentifier: CalendarCell.identifier)\n        return collection\n}()\n\n//时间选择器 x轴以 屏幕宽度为起点，刚好在第二屏了\nprivate lazy var pickerView: UIPickerView = {\n    let picker = UIPickerView.init(frame: CGRect.init(x: ScreenWidth, y: 0, width: ScreenWidth, height: ScreenHeight*0.57*0.57+34+40))\n    picker.delegate = self\n    picker.dataSource = self\n    return picker\n}()\n```\n\n这些需要用代理和数据源的都设置self，后面再具体实现。\n\n这里可以认为是我们搭建房子用到的一些素材。先写好，后期再拼接下。\n\n### 3.3 生命周期函数\n\n初始化看下，应该要先设置一个蒙层。\n```Swift\noverride init(frame: CGRect){\n        super.init(frame: frame)\n        /// 这里应该是蒙层\n        self.backgroundColor = UIColor.init(r: 100, g: 1, b: 1, a: 0.3)\n        self.alpha = 0\n        \n        let lastDyaDate = YSDateTool.lastDay()\n        let com = YSDateTool.currentDateCom(date: lastDyaDate)\n        watermarkView.monthStr = \"\\(com.month!)\"\n    }\n    \n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n```\n确实如此，这里就只加了个颜色。\n\n### 3.4 定义方法，展示和隐藏选择器\n\n```Swift\nextension CalendarView{\n    /// 显示弹窗\n    public func showAlertView() {\n        let str = \"\\(timeModel.startTime)\\(CalendarView.range)\\(timeModel.endTime)\"\n        selectIndex = timeArr.firstIndex(of:str) ?? 0\n        let timeStr = \"\\(timeModel.year)-\\(timeModel.month)-\\(timeModel.day)\"\n        let date = YSDateTool.dateStringToDate(timeStr)\n        self.setDate(date: date)\n        self.setUI()\n        pickerView.selectRow(selectIndex, inComponent: 0, animated: false)\n        UIView.animate(withDuration: 0.25) {\n            self.alpha = 1\n        }\n    }\n\n    /// 隐藏弹窗\n    public func dismissAlertView() {\n        self.animate(duration: 0.25) {\n            self.alpha = 0\n        } completion: { finish in\n            self.removeFromSuperview()\n        }\n    }\n}\n```\n这个方法很重要，主要提供给外部使用，这里帮助外部设置数据，因为外部调用者可能不知道内部细节，所以我们最好在这个类里面实现展示弹框的方法。\n\n### 3.5 设置初始化日期\n\n外部可能有选择好的日期，所以我们必须提供一个方法，设置数据。\n```Swift\nextension CalendarView{\n    /// 按照这个date获取这个月的数据\n    func setDate(date: Date = Date()){\n        modelArr.removeAll()\n        let count = YSDateTool.countOfDaysInCurrentMonth(date: date)    //当月天数\n        for i in 0..<count{\n            let model = self.initializeModel(date: date, day: i+1)\n            modelArr.append(model)\n        }\n        let firstWeekDay = YSDateTool.firstWeekDayInCurrentMonth(date: date)    //当月第一天周几\n        \n        //头部空缺数据填充 插入一个空的model\n        if firstWeekDay != 7 {\n            for _ in 0 ..< firstWeekDay{\n                let model = self.initializeModel(date: date, day: 0)\n                modelArr.insert(model, at: 0)\n            }\n        }\n        //尾部空缺数据填充,插入一个空的model\n        if modelArr.count < 35{\n            for _ in modelArr.count ..< 35{\n                let model = self.initializeModel(date: date, day: 0)\n                modelArr.append(model)\n            }\n        }\n        \n        collectionView.reloadData()\n    }\n    \n    /// 初始化数据，返回\n    func initializeModel(date: Date, day: Int)->TimeModel{\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        let model = TimeModel()\n        model.year = com.year!\n        model.month = com.month!\n        model.day = day\n        \n        // model指代当前时间\n        let monthStr = com.month! < 10 ? \"0\\(model.month)\" : \"\\(model.month)\"\n        let dayStr = com.day! < 10 ? \"0\\(model.day)\" : \"\\(model.day)\"\n        model.dateStr = \"\\(com.year!)-\\(monthStr)-\\(dayStr)\"\n        return model\n    }\n}\n```\n这里也搞了2个扩展函数，会根据目标日期，获取到该日期的一个月的数据，然后会填充第一天非星期天的情况的数据，也会填最后几天空白区域的数据。\n\n### 3.6 设置UI\n\n有了日期就可以设置UI了，所以我们看下如何填充视图的。\n\n```Swift\nextension CalendarView {\n    func setUI() {\n        \n        //日历顶部按钮布局\n        self.addSubview(acView)\n        acView.snp.makeConstraints{make in\n            make.leading.trailing.bottom.equalTo(0)\n            make.height.equalTo(ScreenHeight*0.57)\n        }\n        \n        // 加顶部横线 左上角默认位置\n        acView.addSubview(lineView)\n        self.lineViewLayout()\n        \n        // 加预约日期\n        acView.addSubview(dateBtn)\n        dateBtn.snp.makeConstraints{make in\n            make.top.equalTo(11)\n            make.leading.equalTo(28)\n            make.width.equalTo(66)\n            make.height.equalTo(22)\n        }\n        \n        // 预约时间\n        acView.addSubview(timeBtn)\n        timeBtn.snp.makeConstraints{make in\n            make.top.equalTo(11)\n            make.centerX.equalToSuperview()\n            make.width.equalTo(66)\n            make.height.equalTo(22)\n        }\n        \n        // 加取消按钮\n        acView.addSubview(cancelBtn)\n        cancelBtn.snp.makeConstraints{make in\n            make.top.equalTo(11)\n            make.trailing.equalTo(-16)\n            make.width.equalTo(66)\n            make.height.equalTo(22)\n        }\n        \n        \n        // 继续加滚动视图\n        acView.addSubview(scrollView)\n        scrollView.snp.makeConstraints{make in\n            make.top.equalTo(dateBtn.snp.bottom).offset(10)\n            make.leading.trailing.equalToSuperview()\n            make.bottom.equalToSuperview()\n        }\n        \n        // acView添加完毕，现在到内部ScrollView层级了--------------\n    \n        // 加个集合View 集合View因为初始化确定了y轴高度，这里无需重复布局\n        scrollView.addSubview(collectionView)\n        \n        // 再加个pickerView 时间滚轮，这里直接加到ScrollView里面了，也无需布局，直接覆盖到上层的\n        scrollView.addSubview(pickerView)\n        \n        // 先加工具栏\n        scrollView.addSubview(dateToolView)\n        dateToolView.snp.makeConstraints{make in\n            make.top.leading.equalTo(0)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(40)\n        }\n        \n        // 滚动视图再加星期视图\n        scrollView.addSubview(weeksView)\n        weeksView.snp.makeConstraints{make in\n            make.top.equalTo(dateToolView.snp.bottom).offset(4)\n            make.leading.equalTo(0)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(30)\n        }\n        \n        \n        // 处理下工具栏内部布局\n        dateToolView.addSubview(monthLb)\n        monthLb.snp.makeConstraints{make in\n            make.centerY.equalToSuperview()\n            make.centerX.equalToSuperview()\n            make.width.equalTo(100)\n            make.height.equalTo(20)\n        }\n        \n        // 日历工具条加左按钮\n        dateToolView.addSubview(toolLeftBtn)\n        toolLeftBtn.snp.makeConstraints{make in\n            make.centerY.equalToSuperview()\n            make.width.height.equalTo(40)\n            make.leading.equalTo(16)\n        }\n\n        // 日历工具条加右侧箭头\n        dateToolView.addSubview(toolRightBtn)\n        toolRightBtn.snp.makeConstraints{make in\n            make.centerY.equalToSuperview()\n            make.width.height.equalTo(40)\n            make.trailing.equalTo(-16)\n        }\n        \n        // 设置星期几内部布局\n        setWeekUiInner()\n        \n        // 地址底部按钮\n        addBottomUI()\n    \n    }\n```\n中规中矩，老老实实从上到下，从左到右布局。\n\n内部星期几看下如何布局的：\n```Swift\nfunc setWeekUiInner() {\n        let arr = [\"日\",\"一\",\"二\",\"三\",\"四\",\"五\",\"六\"]\n\n        for i in 0 ..< arr.count {\n            let width = ScreenWidth/7\n            let lab = UILabel()\n            lab.text = arr[i]\n            lab.textColor = UIColor.init(hex: \"#323233\")\n            lab.font = .pingFangRegular(size: 12)\n            lab.textAlignment = .center\n            weeksView.addSubview(lab)\n            lab.snp.makeConstraints{make in\n                make.leading.equalTo(width*CGFloat(i))\n                make.centerY.equalToSuperview()\n                make.width.equalTo(width)\n                make.height.equalTo(20)\n            }\n        }\n    }\n```\n\n还有底部的下一步和完成：\n```Swift\nfunc addBottomUI() {\n        let nextBtn: UIButton = UIButton.init(type: .custom)\n        nextBtn.frame = CGRect.init(x: 16, y: ScreenHeight*0.57*0.57+8+34+40, width: (ScreenWidth-32), height: 44)\n        nextBtn.titleFont = .pingFangMedium(size: 16)\n        nextBtn.setTitleColor(.white, for: .normal)\n        nextBtn.backgroundColor = UIColor.init(hex: \"#409EFF\")\n        nextBtn.setTitle(\"下一步\", for: .normal)\n        nextBtn.layer.cornerRadius = 22\n        nextBtn.addTarget(self, action: #selector(actionForNext), for: .touchUpInside)\n        scrollView.addSubview(nextBtn)\n        \n        let doneBtn: UIButton = UIButton.init(type: .custom)\n        doneBtn.frame = CGRect.init(x: ScreenWidth+16, y: ScreenHeight*0.57*0.57+8+34+40, width: (ScreenWidth-32), height: 44)\n        doneBtn.titleFont = .pingFangMedium(size: 16)\n        doneBtn.setTitleColor(.white, for: .normal)\n        doneBtn.backgroundColor = UIColor.init(hex: \"#409EFF\")\n        doneBtn.setTitle(\"完成\", for: .normal)\n        doneBtn.layer.cornerRadius = 22\n        doneBtn.addTarget(self, action: #selector(actionForDone), for: .touchUpInside)\n        scrollView.addSubview(doneBtn)\n    }\n```\n\n### 3.7 填充数据\n\n这里先看下日历数据如何使用代理和数据源的：\n```Swift\nextension CalendarView: UICollectionViewDelegate,UICollectionViewDataSource,UICollectionViewDelegateFlowLayout{\n    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {\n        return modelArr.count\n    }\n    \n    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: CalendarCell.identifier, for: indexPath) as! CalendarCell\n        cell.model = modelArr[indexPath.item]\n        cell.selectedModel = timeModel\n        return cell\n    }\n\n    // 定义每个Cell的大小\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {\n        let width = ScreenWidth/7\n        let height = modelArr.count > 35 ? (ScreenHeight*0.57*0.57)/6 : (ScreenHeight*0.57*0.57)/5\n        return CGSize(width: width-2, height: height-1)\n    }\n    \n    // 定义每个Section的四边间距\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -> UIEdgeInsets {\n        return UIEdgeInsets(top: 0, left: 3.5, bottom: 0, right: 0)\n    }\n    \n    // 这个是两行cell之间的间距（上下行cell的间距）\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -> CGFloat {\n        return 1.0\n    }\n    \n    // 两个cell之间的间距（同一行的cell的间距）\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Int) -> CGFloat {\n        return 1.0\n    }\n    \n    // 选中某个ietm\n    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {\n        let model = modelArr[indexPath.item]\n        let com = YSDateTool.currentDateCom()\n        if com.year == model.year && com.month == model.month && model.day <= com.day! || model.day == 0{\n            return\n        }\n\n        timeModel.year = model.year\n        timeModel.month = model.month\n        timeModel.day = model.day\n        collectionView.reloadData()\n    }\n}\n```\n主要逻辑委托给Cell来实现了。后面再看下。\n\n### 3.8 UIPickerView数据填充\n\n然后看下预约时间如何填充数据的。\n```Swift\nextension CalendarView:UIPickerViewDelegate,UIPickerViewDataSource {\n\n    func numberOfComponents(in pickerView: UIPickerView) -> Int {\n        return 1\n    }\n    \n    func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -> Int {\n        return timeArr.count\n    }\n\n    func pickerView(_ pickerView: UIPickerView, widthForComponent component: Int) -> CGFloat {\n        return ScreenWidth\n    }\n    \n    func pickerView(_ pickerView: UIPickerView, rowHeightForComponent component: Int) -> CGFloat {\n        44\n    }\n    \n    func pickerView(_ pickerView: UIPickerView, viewForRow row: Int, forComponent component: Int, reusing view: UIView?) -> UIView {\n        \n        //设置分割线 pickerView的subvews的第二个一般用来做分割线 subviews会有2个view\n        for view in pickerView.subviews {\n            print(\"view.height=\\(view.size.height) 长度为：\\(pickerView.subviews.count)\")\n            if view.size.height <= 50 {\n                view.backgroundColor = .clear\n                //自定义分割线\n                let toplayer = CALayer()\n                toplayer.frame = CGRect.init(x: 0, y: 0, width: ScreenWidth, height: 1)\n                toplayer.backgroundColor = UIColor.init(hex: \"#EBEDF0\").cgColor\n                view.layer.addSublayer(toplayer)\n\n                let bottomlayer = CALayer()\n                bottomlayer.frame = CGRect.init(x: 0, y: 44-1, width: ScreenWidth, height: 1)\n                bottomlayer.backgroundColor = UIColor.init(hex: \"#EBEDF0\").cgColor\n                view.layer.addSublayer(bottomlayer)\n               \n            }else{\n                view.backgroundColor = .clear\n            }\n        }\n        \n        //设置内容样式\n        var label = view as? UILabel\n        if label == nil {\n            label = UILabel.init()\n            label?.backgroundColor = .clear\n            label?.frame = CGRect.init(x: 0, y: 0, width:ScreenWidth, height:44)\n        }\n        if row == selectIndex {\n            label?.textColor = UIColor.init(hex: \"#409EFF\")\n        }else{\n            label?.textColor = UIColor.init(hex: \"#3B4058\")\n        }\n        label?.textAlignment = .center\n        label?.font = .pingFangRegular(size: 16)\n        //label?.minimumScaleFactor = 0.5\n        //label?.adjustsFontSizeToFitWidth = true\n        label?.text = timeArr[row]\n        return label!\n    }\n    \n    func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) {\n        selectIndex = row\n        pickerView.reloadAllComponents()\n    }\n}\n```\n主要逻辑是viewForRow覆写的方法里面。\n交代了如何绘制分割线和选中高亮显示。\n这里有个点要注意，这个分割线用到了 UIPickerView的subViews，这里通常设置分割线都要用到这个东西，具体细节我不是很清楚，预测这个subViews第二个就是居中的item。第一个item很长，不能用来分割线。\n\n然后就是didSelectRow用来响应用户点击事件，需要刷新下components。\n\n### 3.9 交互事件\n\n这里交互事件统一用一个扩展类来实现。\n```Swift\nextension CalendarView {\n    \n    @objc func actionForChooseDate(){\n        self.lineViewLayout()\n        self.scrollDate()\n    }\n    \n    @objc func actionForChooseTime(){\n        self.lineViewLayout(leading: 1)\n        self.scrollTime()\n    }\n    \n    @objc func actionForCancel(){\n        self.dismissAlertView()\n    }\n    \n    @objc func actionForLeftEvent(){\n        dynamicDate = YSDateTool.lastMonth(date: dynamicDate)\n        self.isRefrenshMonth()\n    }\n    \n    @objc func actionForRightEvent(){\n        dynamicDate = YSDateTool.nextMonth(date: dynamicDate)\n        self.isRefrenshMonth()\n    }\n    \n    @objc func actionForNext(){\n        self.lineViewLayout(leading: 1)\n        self.scrollTime()\n    }\n    \n    @objc func actionForDone(){\n        if doneHandle != nil {\n            let str = timeArr[selectIndex]\n            let arr = str.components(separatedBy: CalendarView.range)\n            timeModel.startTime = arr[0]\n            timeModel.endTime = arr[1]\n            \n            let monthStr = timeModel.month < 10 ? \"0\\(timeModel.month)\" : \"\\(timeModel.month)\"\n            let dayStr = timeModel.day < 10 ? \"0\\(timeModel.day)\" : \"\\(timeModel.day)\"\n            timeModel.dateStr = \"\\(timeModel.year)-\\(monthStr)-\\(dayStr)\"\n            \n            doneHandle(timeModel)\n        }\n        self.dismissAlertView()\n    }\n    \n    // 滑动到日期\n    func scrollDate(){\n        dateBtn.isSelected = true\n        timeBtn.isSelected = false\n        scrollView.setContentOffset(CGPoint.init(x: 0, y: 0), animated: true)\n    }\n    \n    // 滑动到时间\n    func scrollTime(){\n        dateBtn.isSelected = false\n        timeBtn.isSelected = true\n        scrollView.setContentOffset(CGPoint.init(x: ScreenWidth, y: 0), animated: true)\n    }\n    \n    func isRefrenshMonth(){\n        self.setDate(date: dynamicDate)\n        let com = YSDateTool.currentDateCom(date: dynamicDate)\n        monthLb.text = \"\\(com.year!)年\\(com.month!)月\"\n        watermarkView.monthStr = \"\\(com.month!)\"\n        \n        let currentCom = YSDateTool.currentDateCom()\n        if (com.year! == currentCom.year!  && com.month! > currentCom.month!) || (com.year! > currentCom.year!){\n            toolLeftBtn.isHidden = false\n        }else{\n            toolLeftBtn.isHidden = true\n        }\n    }\n    \n    func lineViewLayout(leading: Int = 0){\n        lineView.snp.remakeConstraints{make in\n            make.top.equalTo(0)\n            if leading == 0 {\n                make.leading.equalTo(leading)\n            }else{\n                make.centerX.equalToSuperview() // 居中了\n            }\n            make.width.equalTo(66+56) // 宽度\n            make.height.equalTo(2)  // 高度\n        }\n    }\n}\n```\n\n## 4 撸下时间工具\n\n这个只是个单纯工具，不必重复造轮子。\n```Swift\nclass YSDateTool {\n    // MARK: - 当前时间组件\n    static func currentDateCom(date: Date = Date()) -> DateComponents{\n        let calendar = Calendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com\n    }\n    // MARK: - 今年\n    static func currentYear(date: Date = Date()) -> Int {\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com.year!\n    }\n  \n    // MARK: - 今月\n    static func currentMonth(date: Date = Date()) -> Int {\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com.month!\n    }\n  \n    // MARK: - 今日\n    static func currentDay(date: Date = Date()) -> Int {\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com.day!\n    }\n    \n    // MARK: - 今天星期几\n    static func currentWeekDay(date: Date = Date()) -> Int {\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.weekday], from: date)\n        return com.weekday!\n    }\n    \n    // MARK: - 农历今年\n    static func currentChineseYear(date: Date = Date()) -> String {\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.year], from: date)\n        return numberToChina(yearNum: (com?.year)!) + \"年\"\n    }\n    \n    // MARK: - 农历今月\n    static func currentChineseMonth(date: Date = Date()) -> String {\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.month], from: date)\n        return numberToChina(monthNum: (com?.month)!)\n    }\n\n    // MARK: - 农历今日\n    static func currentChineseDay(date: Date = Date()) -> String {\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.day], from: date)\n        return numberToChina(dayNum: (com?.day)!)\n    }\n    \n    // MARK: - 农历今日\n    static func currentChineseDayInt(date: Date = Date()) -> Int {\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.day], from: date)\n        return (com?.day)!\n    }\n    \n    // MARK: - 农历星期\n    static func currentChineseWeekYear(date: Date = Date()) -> String {\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.weekday], from: date)\n        return numberToChina(weekNum: (com?.weekday)!)\n    }\n  \n    // MARK: - 下个月\n    static func nextMonth(date: Date = Date()) -> Date {\n        let calendar = NSCalendar.current\n        let nDate = calendar.date(byAdding: DateComponents(month: 1), to: date)\n        return nDate!\n    }\n    \n    // MARK: - 上个月\n    static func lastMonth(date: Date = Date()) -> Date {\n        let calendar = NSCalendar.current\n        let lDate = calendar.date(byAdding: DateComponents(month: -1), to: date)\n        return lDate!\n    }\n    \n    // MARK: - 下一天\n    static func lastDay(date: Date = Date()) -> Date{\n        let calendar = NSCalendar.current\n        let lDate = calendar.date(byAdding: DateComponents(day: 1), to: date)\n        return lDate!\n    }\n  \n    // MARK: - 本月天数\n    static func countOfDaysInCurrentMonth(date: Date = Date()) -> Int {\n        let calendar = Calendar(identifier: Calendar.Identifier.gregorian)\n        let range = (calendar as NSCalendar?)?.range(of: NSCalendar.Unit.day, in: NSCalendar.Unit.month, for: date)\n        return (range?.length)!\n    }\n \n    // MARK: - 当月第一天是星期几\n    static func firstWeekDayInCurrentMonth(date: Date = Date()) -> Int {\n        // 星期和数字一一对应 星期日：7\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = \"yyyy-MM\"\n        let date = dateFormatter.date(from: String(date.xj.year)+\"-\"+String(date.xj.month))\n        let calender = Calendar(identifier: Calendar.Identifier.gregorian)\n        let comps = (calender as NSCalendar?)?.components(NSCalendar.Unit.weekday, from: date!)\n        var week = comps?.weekday\n        if week == 1 {\n            week = 8\n        }\n        return week! - 1\n    }\n\n    // MARK: - - 获取指定日期各种值\n    // 根据年月得到某月天数\n    static func getCountOfDaysInMonth(year: Int, month: Int) -> Int{\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = \"yyyy-MM\"\n        let date = dateFormatter.date(from: String(year)+\"-\"+String(month))\n        let calendar = Calendar(identifier: Calendar.Identifier.gregorian)\n        let range = (calendar as NSCalendar?)?.range(of: NSCalendar.Unit.day, in: NSCalendar.Unit.month, for: date!)\n        return (range?.length)!\n    }\n    \n    // MARK: - 根据年月得到某月第一天是周几\n    static func getfirstWeekDayInMonth(year: Int, month: Int) -> Int{\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = \"yyyy-MM\"\n        let date = dateFormatter.date(from: String(year)+\"-\"+String(month))\n        let calendar = Calendar(identifier: Calendar.Identifier.gregorian)\n        let comps = (calendar as NSCalendar?)?.components(NSCalendar.Unit.weekday, from: date!)\n        let week = comps?.weekday\n        return week! - 1\n    }\n\n    // MARK: - date转日期字符串\n    static func dateToDateString(_ date: Date, dateFormat: String) -> String {\n        let timeZone = NSTimeZone.default\n        let formatter = DateFormatter()\n        formatter.timeZone = timeZone\n        formatter.dateFormat = dateFormat\n        let date = formatter.string(from: date)\n        return date\n    }\n\n    // MARK: - 日期字符串转date\n    static func dateStringToDate(_ dateStr: String) -> Date {\n        let dateFormatter = DateFormatter()\n        dateFormatter.timeZone = TimeZone(abbreviation: \"UTC+8\")\n        dateFormatter.dateFormat = \"yyyy-MM-dd\"\n        let date = dateFormatter.date(from: dateStr)\n        return date!\n    }\n    \n    // MARK: - 时间字符串转date\n    static func timeStringToDate(_ dateStr: String) -> Date {\n        let dateFormatter = DateFormatter()\n        dateFormatter.timeZone = TimeZone(abbreviation: \"UTC+8\")\n        dateFormatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n        let date = dateFormatter.date(from: dateStr)\n        return date!\n    }\n\n    // MARK: - 计算天数差\n    static func dateDifference(_ dateA: Date, from dateB: Date) -> Double {\n        let interval = dateA.timeIntervalSince(dateB)\n        return interval/86400\n    }\n\n    // MARK: - 比较时间先后\n    static func compareOneDay(oneDay: Date, withAnotherDay anotherDay: Date) -> Int {\n        let dateFormatter: DateFormatter = DateFormatter()\n        dateFormatter.dateFormat = \"yyyy-MM-dd\"\n        let oneDayStr: String = dateFormatter.string(from: oneDay)\n        let anotherDayStr: String = dateFormatter.string(from: anotherDay)\n        let dateA = dateFormatter.date(from: oneDayStr)\n        let dateB = dateFormatter.date(from: anotherDayStr)\n        let result: ComparisonResult = (dateA?.compare(dateB!))!\n        // Date1 is in the future\n        if(result == ComparisonResult.orderedDescending ) {\n            return 1\n        }\n        // Date1 is in the past\n        else if(result == ComparisonResult.orderedAscending) {\n            return 2\n        }\n            // Both dates are the same\n        else {\n            return 0\n        }\n    }\n\n    // MARK: - 时间与时间戳之间的转化\n    // 将时间转换为时间戳\n    static func stringToTimeStamp(_ stringTime: String) -> Int {\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat = \"yyyy-MM-dd HH: mm: ss\"\n        dfmatter.locale = Locale.current\n        let date = dfmatter.date(from: stringTime)\n        let dateStamp: TimeInterval = date!.timeIntervalSince1970\n        let dateSt: Int = Int(dateStamp)\n        return dateSt\n    }\n    \n    // 将时间戳转换为年月日\n    static func timeStampToString(_ timeStamp: String) -> String {\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=\"yyyy年MM月dd日\"\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    }\n    \n    // 将时间戳转换为具体时间\n    static func timeStampToStringDetail(_ timeStamp: String) -> String {\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=\"yyyy年MM月dd日HH: mm: ss\"\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    }\n    \n    // 将时间戳转换为时分秒\n    static func timeStampToHHMMSS(_ timeStamp: String) -> String {\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=\"HH: mm: ss\"\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    }\n    \n    // 将时间戳转换为时分\n    static func timeStampToHHMM(_ timeStamp: String) -> String {\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=\"HH: mm\"\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    }\n    \n    // 获取系统的当前时间戳\n    static func getStamp(date: Date = Date()) -> Int{\n        // 获取当前时间戳\n        let timeInterval: Int = Int(date.timeIntervalSince1970)\n        return timeInterval\n    }\n    \n    // 日数字转汉字\n    static func numberToChina(yearNum: Int) -> String {\n        // 以一个天干和一个地支相配，排列起来，天干在前，地支在后，天干由甲起，地支由子起，阳干对阳支，阴干对阴支（阳干不配阴支，阴干不配阳支）\n        // 就会得到六十年一周期的甲子回圈，一般称为“六十甲子”或“花甲子”\n        // 十天干： 甲（jiǎ）、乙（yǐ）、丙（bǐng）、丁（dīng）、戊（wù）、己（jǐ）、庚（gēng）、辛（xīn）、壬（rén）、癸（guǐ）\n        // 十二地支： 子（zǐ）、丑（chǒu）、寅（yín）、卯（mǎo）、辰（chén）、巳（sì）、午（wǔ）、未（wèi）、申（shēn）、酉（yǒu）、戌（xū）、亥（hài）\n        let ChinaArray = [ \"甲子\", \"乙丑\", \"丙寅\", \"丁卯\", \"戊辰\", \"己巳\", \"庚午\", \"辛未\", \"壬申\", \"癸酉\",\n                         \"甲戌\", \"乙亥\", \"丙子\", \"丁丑\", \"戊寅\", \"己卯\", \"庚辰\", \"辛己\", \"壬午\", \"癸未\",\n                         \"甲申\", \"乙酉\", \"丙戌\", \"丁亥\", \"戊子\", \"己丑\", \"庚寅\", \"辛卯\", \"壬辰\", \"癸巳\",\n                         \"甲午\", \"乙未\", \"丙申\", \"丁酉\", \"戊戌\", \"己亥\", \"庚子\", \"辛丑\", \"壬寅\", \"癸丑\",\n                         \"甲辰\", \"乙巳\", \"丙午\", \"丁未\", \"戊申\", \"己酉\", \"庚戌\", \"辛亥\", \"壬子\", \"癸丑\",\n                         \"甲寅\", \"乙卯\", \"丙辰\", \"丁巳\", \"戊午\", \"己未\", \"庚申\", \"辛酉\", \"壬戌\", \"癸亥\"]\n        let ChinaStr: String = ChinaArray[yearNum - 1]\n        return ChinaStr\n    }\n    \n    // 月份数字转汉字\n    static func numberToChina(monthNum: Int) -> String {\n        let ChinaArray = [\"一月\", \"二月\", \"三月\", \"四月\", \"五月\", \"六月\", \"七月\", \"八月\", \"九月\", \"十月\", \"十一月\", \"十二月\"]\n        let ChinaStr: String = ChinaArray[monthNum - 1]\n        return ChinaStr\n    }\n    \n    // 日数字转汉字\n    static func numberToChina(dayNum: Int) -> String {\n        let ChinaArray = [ \"初一\", \"初二\", \"初三\", \"初四\", \"初五\", \"初六\", \"初七\", \"初八\", \"初九\", \"初十\",\n                         \"十一\", \"十二\", \"十三\", \"十四\", \"十五\", \"十六\", \"十七\", \"十八\", \"十九\", \"二十\",\n                         \"廿一\", \"廿二\", \"廿三\", \"廿四\", \"廿五\", \"廿六\", \"廿七\", \"廿八\", \"廿九\", \"三十\"]\n        let ChinaStr: String = ChinaArray[dayNum - 1]\n        return ChinaStr\n    }\n      \n    // 星期数字转汉字\n    static func numberToChina(weekNum: Int) -> String {\n        let ChinaArray = [\"一月\", \"二月\", \"三月\", \"四月\", \"五月\", \"六月\", \"七月\", \"八月\", \"九月\", \"十月\", \"十一月\", \"十二月\"]\n        let ChinaStr: String = ChinaArray[weekNum - 1]\n        return ChinaStr\n    }\n    \n    // MARK: - 数字前补0\n    static func add0BeforeNumber(_ number: Int) -> String {\n        if number >= 10 {\n            return String(number)\n        }else{\n            return \"0\" + String(number)\n        }\n    }\n    \n    static func getCurrentSystemDate() -> Date{\n        let date = Date() // 获得时间对象\n        let zone = NSTimeZone.system // 获得系统的时区\n        let time = zone.secondsFromGMT(for: date)// 以秒为单位返回当前时间与系统格林尼治时间的差\n        return date.addingTimeInterval(TimeInterval(time))// 然后把差的时间加上,就是当前系统准确的时间\n    }\n    \n    static func date(_ date: String?, dateFormat: String = \"yyyy-MM-dd\") -> Date? {\n        guard let date = date else {\n            return nil\n        }\n        let dateformatter = DateFormatter()\n        dateformatter.timeZone = TimeZone.init(secondsFromGMT: 0)\n        dateformatter.dateFormat = dateFormat\n        return dateformatter.date(from: date)\n    }\n\n    // MARK: - 将时间显示为（几分钟前，几小时前，几天前）\n    static func compareCurrentTime(str: String) -> String {\n        //let currentDateStr = dateToDateString(Date(), dateFormat: \"yyyy-MM-dd hh:mm:ss\")\n        let currentDate = getCurrentSystemDate()\n        let sendTimeDate = date(str,dateFormat: \"yyyy-MM-dd HH:mm:ss\")!//self.timeStringToDate(str)\n        let sendTimeInterval = Double(getStamp(date: sendTimeDate))\n        let timeInterval = currentDate.timeIntervalSince(sendTimeDate)\n\n        var todayStr = dateToDateString(Date(), dateFormat: \"yyyy-MM-dd\")\n        todayStr = todayStr+\" 00:00\"\n        let todayTimeInterval = Double(Date().stringToSecondTimeStamp(todayStr)) ?? 0\n        let yestDayTimeInterval = Double(todayTimeInterval - 86400)\n        let nextDayTimeInterval = Double(todayTimeInterval + 86400)\n\n        var temp: Double = 0\n        var result: String = \"\"\n        if timeInterval/60 < 1 {\n            result = \"刚刚\"\n        }else if (timeInterval/60) < 60{\n            temp = timeInterval/60\n            result = \"\\(Int(temp))分钟前\"\n        }else if sendTimeInterval > todayTimeInterval && sendTimeInterval < nextDayTimeInterval{\n\n            //let interval = nextDayTimeInterval - sendTimeInterval\n            temp = timeInterval/60/60\n            result = \"\\(Int(temp))小时前\"\n        }else if sendTimeInterval > yestDayTimeInterval && sendTimeInterval < todayTimeInterval{\n            //let str = timeStampToHHMM(String.init(format: \"%d\", sendTimeInterval))\n            let timeStr = str.components(separatedBy: \" \").last ?? \"\"\n            let str = timeStr.prefix(5)\n            result = \"昨天\\(str)\"\n        }else{\n            let timeStr = str.components(separatedBy: \" \").first ?? \"\"\n            let timeArr = timeStr.components(separatedBy: \"-\")\n            if !timeArr.isEmpty {\n                result = \"\\(timeArr[0])年\\(timeArr[1])月\\(timeArr[2])日\"\n            }\n            //result = timeStampToString(String.init(format: \"%d\", sendTimeInterval))\n        }\n        \n//        else if timeInterval/(30 * 24 * 60 * 60) < 12 {\n//            temp = timeInterval/(30 * 24 * 60 * 60)\n//            result = \"\\(Int(temp))个月前\"\n//        }else{\n//            temp = timeInterval/(12 * 30 * 24 * 60 * 60)\n//            result = \"\\(Int(temp))年前\"\n//        }\n        return result\n    }\n}\n\n```\n\n## 5 撸下最后的日历Cell\n\n这个就是日历里面的item，还是相当简单的。\n\n### 5.1 全局变量\n```Swift\nclass CalendarCell: UICollectionViewCell {\n    \n    static var identifier = \"UICollectionViewCell\"\n    \n    var isGreaterThan: Bool = false     //是否取大于今天的值\n    \n    var isShowPassTime: Int = 0         //是否设定禁选\n    \n    var model:TimeModel?{\n        didSet{\n            guard let _model = model else {return}\n            if _model.day != 0 {\n                titleLab.text = \"\\(_model.day)\"\n            }else{\n                titleLab.text = \"\" // 为0，啥也不显示\n            }\n            \n            let com = YSDateTool.currentDateCom()\n            \n            // 是否是选中的日子\n            if com.year == _model.year && com.month == _model.month && com.day == _model.day {\n                titleLab.textColor = UIColor.init(hex: \"#409EFF\")\n            }else{\n                titleLab.textColor = UIColor.init(hex: \"#323233\")\n            }\n            \n            // 禁用还是可用\n            if isShowPassTime == 0 {\n                if isGreaterThan {\n                    if (com.year == _model.year && com.month == _model.month && _model.day > com.day!) || (_model.year == com.year! && _model.month > com.month!) || (_model.year > com.year!){\n                        titleLab.textColor = UIColor.init(hex: \"#C8C9CC\")\n                    }\n                }else{\n                    // 如果要大于今天，那么前面的时间就的置灰了 前一个月的点不过去，不考虑了\n                    if com.year == _model.year && com.month == _model.month && _model.day < com.day!{\n                        titleLab.textColor = UIColor.init(hex: \"#C8C9CC\")\n                    }\n                }\n            }\n        }\n    }\n    \n    // 选中的item，背景颜色高亮\n    var selectedModel: TimeModel?{\n        didSet{\n            guard let _model = selectedModel else{return}\n            if _model.year == model?.year && _model.month == model?.month && _model.day == model?.day{\n                titleLab.backgroundColor = UIColor.init(hex: \"#409EFF\")\n                titleLab.textColor = UIColor.white\n            }else{\n                titleLab.backgroundColor = UIColor.clear\n            }\n        }\n    }\n```\n比较重要的是model，表示当前时间实体类。这里监听变量改变，利用didSet实现动态改变文案效果。\n\n另外一个是selectedModel，这个是当前选中的item，会比对item是否为选中，选中样式会有所不同。\n\n### 5.2 UI子View\n\n这里只用到一个子View。\n```Swift\nvar titleLab: UILabel = {\n        let lan = UILabel()\n        lan.font = .pingFangRegular(size: 16)\n        lan.textAlignment = .center\n        lan.textColor = UIColor.init(hex: \"#323233\")\n        \n        lan.layer.cornerRadius = 4\n        lan.layer.masksToBounds = true\n        return lan\n    }()\n```\n\n### 5.3 生命周期函数\n\n```Swift\noverride init(frame: CGRect) {\n        super.init(frame: frame)\n        contentView.backgroundColor = .clear\n        contentView.addSubview(titleLab)\n        titleLab.snp.makeConstraints{make in\n            make.top.bottom.leading.trailing.equalToSuperview()\n        }\n    }\n    \n    required init?(coder aDecoder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n```\n把那个子View添加到Cell里面去了。\n\n大概就是这样子。\n\n## 6 总结\n\n* 如果UI图有那种Tab页，就可以考虑使用多种方案来实现，iOS直接用简单的Button也是可以实现的，分割线也是可以用最简单的UIView来实现，不一定要用封装好的框架，谁用挖掘机来搬小石头呢，大材小用了。\n\n* 分页效果可以使用UIScrollView来实现，把它宽度设置为屏幕的n倍，这样最有滑动可以很好控制的，不要动画也可以设置的，办法总是就很多的。\n\n* 日历效果可以用UICollectionView来实现，看着很复杂，其实很简单，主要逻辑也不复杂，控制好数据刷新就好了。UICollectionView可以实现类似网格的效果，我们只需要在Cell里面绘制一个一个Cell，空的部分，我们啥不展示就好了。\n\n* 系统的UIPickerView设置分割线很简单，利用UIPickerView下有一个subViews，这里寻找高度为item高度大小的，然后给view设置一个Layer即可。","source":"_posts/iOS-swift-自定义View之时间选择器.md","raw":"---\ntitle: iOS-swift-自定义View之时间选择器\ndate: 2023-01-28 09:56:57\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- iOS 自定义View\ncategories:\n- iOS\n---\n\n## 1 需求分析\n当我们选择购买一个东西时，有时需要预约发货，这时候需要用户手动选择某一天某一个时间，ui给的方案是这样的：\n预约日期：\n<img src=%E9%A2%84%E7%BA%A6%E6%97%A5%E6%9C%9F.png>\n\n预约时间：\n<img src=%E9%A2%84%E7%BA%A6%E6%97%B6%E9%97%B4.png>\n这里是间隔了2个小时一个时间。\n\n可以看到这个日期是以日历形式展现，可以选择未来某个日期；时间是以滚轮的方式展现，可以上下滑动到目标时间点。\n\n对于这个需求，我们要如何实现呢？‘\n\n答案当然是自定义View了。\n\n## 2 结构分析\n显而易见，这个因为设计到分页，我们可以考虑分页区域使用一个UIScrollView，水平滑动，宽度设置为屏幕的2倍，一半用来展示日历，一半用来展示预约时间的UIPickerView。\n\n所以需要我们自定义一个UIView，这里面先绘制顶部分割线，再绘制标题，“预约日期”和“预约时间”和“取消”的文案。\n\n然后是一个显示日历操作栏，包括左右箭头和中间的月份显示，这个要放到UIScrollView的左半边，包括星期视图和日历的UICollectionView的集合View，这里日历我们采用这个集合View很容易实现的。\n\n然后右侧就是一个UIPickerView,这个系统封装好了，使用很方便，我们主要负责填充数据。\n\n那这个结构大体出来了，一个是整个自定义View，暂且把它叫做CalenderView，还有一个就是日历内部的Cell，暂且叫做CalenderCell。\n\n## 3 撸下CalenderView\n\n### 3.1 全局变量\n\n```Swift\nclass CalendarView: UIView {\n    \n    /// 传出去给调用者\n    typealias DoneBlock = (TimeModel)->()\n    var doneHandle: DoneBlock!\n    \n    // 当月日期Model\n    var modelArr: [TimeModel] = []\n    \n    // 动态调整上下月的时间变量\n    var dynamicDate = Date()\n    \n    //默认选中的日期\n    var timeModel: TimeModel = TimeModel()\n    \n    //时间时短数据\n    static let range: String = \"                      \"\n    private var timeArr: [String] = [\"08:00\\(range)10:00\",\n                                   \"10:00\\(range)12:00\",\n                                   \"12:00\\(range)14:00\",\n                                   \"14:00\\(range)16:00\",\n                                   \"16:00\\(range)18:00\",\n                                   \"18:00\\(range)20:00\",\n                                   \"20:00\\(range)22:00\"]\n    private var selectIndex = 0\n    \n```\n这里定义了一个闭包返回，主要是用户选择后，回调给外部。\n\n然后有一个TimeModel的数组， 也就是填充我们的日历视图。\n\ntimeModel是我们选择的日期，会高亮显示。\n\ntimeArr是我们右侧使用的UIPickerView要用的数据。\n\n### 3.2 UI定义\n\n这里我们大致会用到这些视图。\n```Swift\n//白色背景底 整个半屏的视图\nprivate lazy var acView: UIView = {\n    let view = UIView()\n    view.backgroundColor = .white\n    return view\n}()\n\n//选中条\nprivate lazy var lineView: UIView = {\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: \"#409EFF\")\n    return view\n}()\n\n/// 预约日期按钮\nprivate lazy var dateBtn: UIButton = {\n    let btn = UIButton()\n    btn.setTitle(\"预约日期\", for: .normal)\n    btn.titleFont = .pingFangMedium(size: 16)\n    btn.setTitleColor(UIColor.lightGray, for: .normal)\n    btn.setTitleColor(UIColor.black, for: .selected)\n    btn.addTarget(self, action: #selector(actionForChooseDate), for: .touchUpInside)\n    btn.isSelected = true\n    return btn\n}()\n\n/// 预约时间按钮\nprivate lazy var timeBtn: UIButton = {\n    let btn = UIButton()\n    btn.setTitle(\"预约时间\", for: .normal)\n    btn.titleFont = .pingFangMedium(size: 16)\n    btn.setTitleColor(UIColor.lightGray, for: .normal)\n    btn.setTitleColor(UIColor.black, for: .selected)\n    btn.addTarget(self, action: #selector(actionForChooseTime), for: .touchUpInside)\n    return btn\n}()\n\n/// 取消按钮\nprivate lazy var cancelBtn: UIButton = {\n    let btn = UIButton()\n    btn.setTitle(\"取消\", for: .normal)\n    btn.setTitleColor(UIColor.init(hex: \"#409EFF\"), for: .normal)\n    btn.titleFont = .pingFangRegular(size: 16)\n    btn.addTarget(self, action: #selector(actionForCancel), for: .touchUpInside)\n    return btn\n}()\n\n//日历工具条\nprivate lazy var dateToolView: UIView = {\n    let view = UIView()\n    return view\n}()\n\n//日历工具条显示当前月份标签\nprivate lazy var monthLb: UILabel = {\n    let lab = UILabel()\n    lab.font = .pingFangMedium(size: 16)\n    lab.textColor = UIColor.init(hex: \"#3B4058\")\n    lab.text = \"\"\n    lab.textAlignment = .center\n    return lab\n}()\n\n//日历工具条左箭头\nprivate lazy var toolLeftBtn: UIButton = {\n    let btn = UIButton()\n    btn.setImage(UIImage.init(named: \"日历_左箭头\"), for: .normal)\n    btn.addTarget(self, action: #selector(actionForLeftEvent), for: .touchUpInside)\n    btn.isHidden = true\n    return btn\n}()\n\n//日历工具条右箭头\nprivate lazy var toolRightBtn: UIButton =  {\n    let btn = UIButton()\n    btn.setImage(UIImage.init(named: \"日历_右箭头\"), for: .normal)\n    btn.addTarget(self, action: #selector(actionForRightEvent), for: .touchUpInside)\n    return btn\n}()\n\n//星期X显示条\nprivate lazy var weeksView: UIView = {\n    let view = UIView()\n    view.backgroundColor = .white\n    view.layer.shadowColor = UIColor.init(hex: \"#7D7E80\").cgColor\n    view.layer.shadowOffset = CGSize.init(width: 0, height: 2)\n    view.layer.shadowRadius = 10\n    view.layer.shadowOpacity = 0.16\n    return view\n}()\n\n//滚动视图 左右滚动\nprivate lazy var scrollView: UIScrollView = {\n    let _scrollView = UIScrollView()\n    _scrollView.contentSize = CGSize.init(width: ScreenWidth*2, height: _scrollView.size.height)\n    _scrollView.bounces = false\n    _scrollView.isScrollEnabled = true\n    _scrollView.isPagingEnabled = true\n    _scrollView.showsVerticalScrollIndicator = false\n    _scrollView.showsHorizontalScrollIndicator = false\n    return _scrollView\n}()\n\n//月份水印背景\nprivate lazy var watermarkView: CalendarWatermark = {\n    let view = CalendarWatermark()\n    view.backgroundColor = .white\n    view.isHidden = true  //当前版本隐藏水印\n    return view\n}()\n\n//日历展示表\n    private lazy var collectionView: UICollectionView = {\n        let layout = UICollectionViewFlowLayout()\n        layout.scrollDirection = .vertical\n        let collection = UICollectionView(frame: CGRect.init(x: 0, y: 34+40, width: ScreenWidth, height: ScreenHeight*0.57*0.57), collectionViewLayout: layout)\n        collection.backgroundColor = .clear\n        collection.delegate = self\n        collection.dataSource = self\n        collection.isPagingEnabled = true\n        collection.showsHorizontalScrollIndicator = false\n        collection.bounces = false\n        collection.register(CalendarCell.self, forCellWithReuseIdentifier: CalendarCell.identifier)\n        return collection\n}()\n\n//时间选择器 x轴以 屏幕宽度为起点，刚好在第二屏了\nprivate lazy var pickerView: UIPickerView = {\n    let picker = UIPickerView.init(frame: CGRect.init(x: ScreenWidth, y: 0, width: ScreenWidth, height: ScreenHeight*0.57*0.57+34+40))\n    picker.delegate = self\n    picker.dataSource = self\n    return picker\n}()\n```\n\n这些需要用代理和数据源的都设置self，后面再具体实现。\n\n这里可以认为是我们搭建房子用到的一些素材。先写好，后期再拼接下。\n\n### 3.3 生命周期函数\n\n初始化看下，应该要先设置一个蒙层。\n```Swift\noverride init(frame: CGRect){\n        super.init(frame: frame)\n        /// 这里应该是蒙层\n        self.backgroundColor = UIColor.init(r: 100, g: 1, b: 1, a: 0.3)\n        self.alpha = 0\n        \n        let lastDyaDate = YSDateTool.lastDay()\n        let com = YSDateTool.currentDateCom(date: lastDyaDate)\n        watermarkView.monthStr = \"\\(com.month!)\"\n    }\n    \n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n```\n确实如此，这里就只加了个颜色。\n\n### 3.4 定义方法，展示和隐藏选择器\n\n```Swift\nextension CalendarView{\n    /// 显示弹窗\n    public func showAlertView() {\n        let str = \"\\(timeModel.startTime)\\(CalendarView.range)\\(timeModel.endTime)\"\n        selectIndex = timeArr.firstIndex(of:str) ?? 0\n        let timeStr = \"\\(timeModel.year)-\\(timeModel.month)-\\(timeModel.day)\"\n        let date = YSDateTool.dateStringToDate(timeStr)\n        self.setDate(date: date)\n        self.setUI()\n        pickerView.selectRow(selectIndex, inComponent: 0, animated: false)\n        UIView.animate(withDuration: 0.25) {\n            self.alpha = 1\n        }\n    }\n\n    /// 隐藏弹窗\n    public func dismissAlertView() {\n        self.animate(duration: 0.25) {\n            self.alpha = 0\n        } completion: { finish in\n            self.removeFromSuperview()\n        }\n    }\n}\n```\n这个方法很重要，主要提供给外部使用，这里帮助外部设置数据，因为外部调用者可能不知道内部细节，所以我们最好在这个类里面实现展示弹框的方法。\n\n### 3.5 设置初始化日期\n\n外部可能有选择好的日期，所以我们必须提供一个方法，设置数据。\n```Swift\nextension CalendarView{\n    /// 按照这个date获取这个月的数据\n    func setDate(date: Date = Date()){\n        modelArr.removeAll()\n        let count = YSDateTool.countOfDaysInCurrentMonth(date: date)    //当月天数\n        for i in 0..<count{\n            let model = self.initializeModel(date: date, day: i+1)\n            modelArr.append(model)\n        }\n        let firstWeekDay = YSDateTool.firstWeekDayInCurrentMonth(date: date)    //当月第一天周几\n        \n        //头部空缺数据填充 插入一个空的model\n        if firstWeekDay != 7 {\n            for _ in 0 ..< firstWeekDay{\n                let model = self.initializeModel(date: date, day: 0)\n                modelArr.insert(model, at: 0)\n            }\n        }\n        //尾部空缺数据填充,插入一个空的model\n        if modelArr.count < 35{\n            for _ in modelArr.count ..< 35{\n                let model = self.initializeModel(date: date, day: 0)\n                modelArr.append(model)\n            }\n        }\n        \n        collectionView.reloadData()\n    }\n    \n    /// 初始化数据，返回\n    func initializeModel(date: Date, day: Int)->TimeModel{\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        let model = TimeModel()\n        model.year = com.year!\n        model.month = com.month!\n        model.day = day\n        \n        // model指代当前时间\n        let monthStr = com.month! < 10 ? \"0\\(model.month)\" : \"\\(model.month)\"\n        let dayStr = com.day! < 10 ? \"0\\(model.day)\" : \"\\(model.day)\"\n        model.dateStr = \"\\(com.year!)-\\(monthStr)-\\(dayStr)\"\n        return model\n    }\n}\n```\n这里也搞了2个扩展函数，会根据目标日期，获取到该日期的一个月的数据，然后会填充第一天非星期天的情况的数据，也会填最后几天空白区域的数据。\n\n### 3.6 设置UI\n\n有了日期就可以设置UI了，所以我们看下如何填充视图的。\n\n```Swift\nextension CalendarView {\n    func setUI() {\n        \n        //日历顶部按钮布局\n        self.addSubview(acView)\n        acView.snp.makeConstraints{make in\n            make.leading.trailing.bottom.equalTo(0)\n            make.height.equalTo(ScreenHeight*0.57)\n        }\n        \n        // 加顶部横线 左上角默认位置\n        acView.addSubview(lineView)\n        self.lineViewLayout()\n        \n        // 加预约日期\n        acView.addSubview(dateBtn)\n        dateBtn.snp.makeConstraints{make in\n            make.top.equalTo(11)\n            make.leading.equalTo(28)\n            make.width.equalTo(66)\n            make.height.equalTo(22)\n        }\n        \n        // 预约时间\n        acView.addSubview(timeBtn)\n        timeBtn.snp.makeConstraints{make in\n            make.top.equalTo(11)\n            make.centerX.equalToSuperview()\n            make.width.equalTo(66)\n            make.height.equalTo(22)\n        }\n        \n        // 加取消按钮\n        acView.addSubview(cancelBtn)\n        cancelBtn.snp.makeConstraints{make in\n            make.top.equalTo(11)\n            make.trailing.equalTo(-16)\n            make.width.equalTo(66)\n            make.height.equalTo(22)\n        }\n        \n        \n        // 继续加滚动视图\n        acView.addSubview(scrollView)\n        scrollView.snp.makeConstraints{make in\n            make.top.equalTo(dateBtn.snp.bottom).offset(10)\n            make.leading.trailing.equalToSuperview()\n            make.bottom.equalToSuperview()\n        }\n        \n        // acView添加完毕，现在到内部ScrollView层级了--------------\n    \n        // 加个集合View 集合View因为初始化确定了y轴高度，这里无需重复布局\n        scrollView.addSubview(collectionView)\n        \n        // 再加个pickerView 时间滚轮，这里直接加到ScrollView里面了，也无需布局，直接覆盖到上层的\n        scrollView.addSubview(pickerView)\n        \n        // 先加工具栏\n        scrollView.addSubview(dateToolView)\n        dateToolView.snp.makeConstraints{make in\n            make.top.leading.equalTo(0)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(40)\n        }\n        \n        // 滚动视图再加星期视图\n        scrollView.addSubview(weeksView)\n        weeksView.snp.makeConstraints{make in\n            make.top.equalTo(dateToolView.snp.bottom).offset(4)\n            make.leading.equalTo(0)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(30)\n        }\n        \n        \n        // 处理下工具栏内部布局\n        dateToolView.addSubview(monthLb)\n        monthLb.snp.makeConstraints{make in\n            make.centerY.equalToSuperview()\n            make.centerX.equalToSuperview()\n            make.width.equalTo(100)\n            make.height.equalTo(20)\n        }\n        \n        // 日历工具条加左按钮\n        dateToolView.addSubview(toolLeftBtn)\n        toolLeftBtn.snp.makeConstraints{make in\n            make.centerY.equalToSuperview()\n            make.width.height.equalTo(40)\n            make.leading.equalTo(16)\n        }\n\n        // 日历工具条加右侧箭头\n        dateToolView.addSubview(toolRightBtn)\n        toolRightBtn.snp.makeConstraints{make in\n            make.centerY.equalToSuperview()\n            make.width.height.equalTo(40)\n            make.trailing.equalTo(-16)\n        }\n        \n        // 设置星期几内部布局\n        setWeekUiInner()\n        \n        // 地址底部按钮\n        addBottomUI()\n    \n    }\n```\n中规中矩，老老实实从上到下，从左到右布局。\n\n内部星期几看下如何布局的：\n```Swift\nfunc setWeekUiInner() {\n        let arr = [\"日\",\"一\",\"二\",\"三\",\"四\",\"五\",\"六\"]\n\n        for i in 0 ..< arr.count {\n            let width = ScreenWidth/7\n            let lab = UILabel()\n            lab.text = arr[i]\n            lab.textColor = UIColor.init(hex: \"#323233\")\n            lab.font = .pingFangRegular(size: 12)\n            lab.textAlignment = .center\n            weeksView.addSubview(lab)\n            lab.snp.makeConstraints{make in\n                make.leading.equalTo(width*CGFloat(i))\n                make.centerY.equalToSuperview()\n                make.width.equalTo(width)\n                make.height.equalTo(20)\n            }\n        }\n    }\n```\n\n还有底部的下一步和完成：\n```Swift\nfunc addBottomUI() {\n        let nextBtn: UIButton = UIButton.init(type: .custom)\n        nextBtn.frame = CGRect.init(x: 16, y: ScreenHeight*0.57*0.57+8+34+40, width: (ScreenWidth-32), height: 44)\n        nextBtn.titleFont = .pingFangMedium(size: 16)\n        nextBtn.setTitleColor(.white, for: .normal)\n        nextBtn.backgroundColor = UIColor.init(hex: \"#409EFF\")\n        nextBtn.setTitle(\"下一步\", for: .normal)\n        nextBtn.layer.cornerRadius = 22\n        nextBtn.addTarget(self, action: #selector(actionForNext), for: .touchUpInside)\n        scrollView.addSubview(nextBtn)\n        \n        let doneBtn: UIButton = UIButton.init(type: .custom)\n        doneBtn.frame = CGRect.init(x: ScreenWidth+16, y: ScreenHeight*0.57*0.57+8+34+40, width: (ScreenWidth-32), height: 44)\n        doneBtn.titleFont = .pingFangMedium(size: 16)\n        doneBtn.setTitleColor(.white, for: .normal)\n        doneBtn.backgroundColor = UIColor.init(hex: \"#409EFF\")\n        doneBtn.setTitle(\"完成\", for: .normal)\n        doneBtn.layer.cornerRadius = 22\n        doneBtn.addTarget(self, action: #selector(actionForDone), for: .touchUpInside)\n        scrollView.addSubview(doneBtn)\n    }\n```\n\n### 3.7 填充数据\n\n这里先看下日历数据如何使用代理和数据源的：\n```Swift\nextension CalendarView: UICollectionViewDelegate,UICollectionViewDataSource,UICollectionViewDelegateFlowLayout{\n    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {\n        return modelArr.count\n    }\n    \n    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: CalendarCell.identifier, for: indexPath) as! CalendarCell\n        cell.model = modelArr[indexPath.item]\n        cell.selectedModel = timeModel\n        return cell\n    }\n\n    // 定义每个Cell的大小\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {\n        let width = ScreenWidth/7\n        let height = modelArr.count > 35 ? (ScreenHeight*0.57*0.57)/6 : (ScreenHeight*0.57*0.57)/5\n        return CGSize(width: width-2, height: height-1)\n    }\n    \n    // 定义每个Section的四边间距\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -> UIEdgeInsets {\n        return UIEdgeInsets(top: 0, left: 3.5, bottom: 0, right: 0)\n    }\n    \n    // 这个是两行cell之间的间距（上下行cell的间距）\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -> CGFloat {\n        return 1.0\n    }\n    \n    // 两个cell之间的间距（同一行的cell的间距）\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Int) -> CGFloat {\n        return 1.0\n    }\n    \n    // 选中某个ietm\n    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {\n        let model = modelArr[indexPath.item]\n        let com = YSDateTool.currentDateCom()\n        if com.year == model.year && com.month == model.month && model.day <= com.day! || model.day == 0{\n            return\n        }\n\n        timeModel.year = model.year\n        timeModel.month = model.month\n        timeModel.day = model.day\n        collectionView.reloadData()\n    }\n}\n```\n主要逻辑委托给Cell来实现了。后面再看下。\n\n### 3.8 UIPickerView数据填充\n\n然后看下预约时间如何填充数据的。\n```Swift\nextension CalendarView:UIPickerViewDelegate,UIPickerViewDataSource {\n\n    func numberOfComponents(in pickerView: UIPickerView) -> Int {\n        return 1\n    }\n    \n    func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -> Int {\n        return timeArr.count\n    }\n\n    func pickerView(_ pickerView: UIPickerView, widthForComponent component: Int) -> CGFloat {\n        return ScreenWidth\n    }\n    \n    func pickerView(_ pickerView: UIPickerView, rowHeightForComponent component: Int) -> CGFloat {\n        44\n    }\n    \n    func pickerView(_ pickerView: UIPickerView, viewForRow row: Int, forComponent component: Int, reusing view: UIView?) -> UIView {\n        \n        //设置分割线 pickerView的subvews的第二个一般用来做分割线 subviews会有2个view\n        for view in pickerView.subviews {\n            print(\"view.height=\\(view.size.height) 长度为：\\(pickerView.subviews.count)\")\n            if view.size.height <= 50 {\n                view.backgroundColor = .clear\n                //自定义分割线\n                let toplayer = CALayer()\n                toplayer.frame = CGRect.init(x: 0, y: 0, width: ScreenWidth, height: 1)\n                toplayer.backgroundColor = UIColor.init(hex: \"#EBEDF0\").cgColor\n                view.layer.addSublayer(toplayer)\n\n                let bottomlayer = CALayer()\n                bottomlayer.frame = CGRect.init(x: 0, y: 44-1, width: ScreenWidth, height: 1)\n                bottomlayer.backgroundColor = UIColor.init(hex: \"#EBEDF0\").cgColor\n                view.layer.addSublayer(bottomlayer)\n               \n            }else{\n                view.backgroundColor = .clear\n            }\n        }\n        \n        //设置内容样式\n        var label = view as? UILabel\n        if label == nil {\n            label = UILabel.init()\n            label?.backgroundColor = .clear\n            label?.frame = CGRect.init(x: 0, y: 0, width:ScreenWidth, height:44)\n        }\n        if row == selectIndex {\n            label?.textColor = UIColor.init(hex: \"#409EFF\")\n        }else{\n            label?.textColor = UIColor.init(hex: \"#3B4058\")\n        }\n        label?.textAlignment = .center\n        label?.font = .pingFangRegular(size: 16)\n        //label?.minimumScaleFactor = 0.5\n        //label?.adjustsFontSizeToFitWidth = true\n        label?.text = timeArr[row]\n        return label!\n    }\n    \n    func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) {\n        selectIndex = row\n        pickerView.reloadAllComponents()\n    }\n}\n```\n主要逻辑是viewForRow覆写的方法里面。\n交代了如何绘制分割线和选中高亮显示。\n这里有个点要注意，这个分割线用到了 UIPickerView的subViews，这里通常设置分割线都要用到这个东西，具体细节我不是很清楚，预测这个subViews第二个就是居中的item。第一个item很长，不能用来分割线。\n\n然后就是didSelectRow用来响应用户点击事件，需要刷新下components。\n\n### 3.9 交互事件\n\n这里交互事件统一用一个扩展类来实现。\n```Swift\nextension CalendarView {\n    \n    @objc func actionForChooseDate(){\n        self.lineViewLayout()\n        self.scrollDate()\n    }\n    \n    @objc func actionForChooseTime(){\n        self.lineViewLayout(leading: 1)\n        self.scrollTime()\n    }\n    \n    @objc func actionForCancel(){\n        self.dismissAlertView()\n    }\n    \n    @objc func actionForLeftEvent(){\n        dynamicDate = YSDateTool.lastMonth(date: dynamicDate)\n        self.isRefrenshMonth()\n    }\n    \n    @objc func actionForRightEvent(){\n        dynamicDate = YSDateTool.nextMonth(date: dynamicDate)\n        self.isRefrenshMonth()\n    }\n    \n    @objc func actionForNext(){\n        self.lineViewLayout(leading: 1)\n        self.scrollTime()\n    }\n    \n    @objc func actionForDone(){\n        if doneHandle != nil {\n            let str = timeArr[selectIndex]\n            let arr = str.components(separatedBy: CalendarView.range)\n            timeModel.startTime = arr[0]\n            timeModel.endTime = arr[1]\n            \n            let monthStr = timeModel.month < 10 ? \"0\\(timeModel.month)\" : \"\\(timeModel.month)\"\n            let dayStr = timeModel.day < 10 ? \"0\\(timeModel.day)\" : \"\\(timeModel.day)\"\n            timeModel.dateStr = \"\\(timeModel.year)-\\(monthStr)-\\(dayStr)\"\n            \n            doneHandle(timeModel)\n        }\n        self.dismissAlertView()\n    }\n    \n    // 滑动到日期\n    func scrollDate(){\n        dateBtn.isSelected = true\n        timeBtn.isSelected = false\n        scrollView.setContentOffset(CGPoint.init(x: 0, y: 0), animated: true)\n    }\n    \n    // 滑动到时间\n    func scrollTime(){\n        dateBtn.isSelected = false\n        timeBtn.isSelected = true\n        scrollView.setContentOffset(CGPoint.init(x: ScreenWidth, y: 0), animated: true)\n    }\n    \n    func isRefrenshMonth(){\n        self.setDate(date: dynamicDate)\n        let com = YSDateTool.currentDateCom(date: dynamicDate)\n        monthLb.text = \"\\(com.year!)年\\(com.month!)月\"\n        watermarkView.monthStr = \"\\(com.month!)\"\n        \n        let currentCom = YSDateTool.currentDateCom()\n        if (com.year! == currentCom.year!  && com.month! > currentCom.month!) || (com.year! > currentCom.year!){\n            toolLeftBtn.isHidden = false\n        }else{\n            toolLeftBtn.isHidden = true\n        }\n    }\n    \n    func lineViewLayout(leading: Int = 0){\n        lineView.snp.remakeConstraints{make in\n            make.top.equalTo(0)\n            if leading == 0 {\n                make.leading.equalTo(leading)\n            }else{\n                make.centerX.equalToSuperview() // 居中了\n            }\n            make.width.equalTo(66+56) // 宽度\n            make.height.equalTo(2)  // 高度\n        }\n    }\n}\n```\n\n## 4 撸下时间工具\n\n这个只是个单纯工具，不必重复造轮子。\n```Swift\nclass YSDateTool {\n    // MARK: - 当前时间组件\n    static func currentDateCom(date: Date = Date()) -> DateComponents{\n        let calendar = Calendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com\n    }\n    // MARK: - 今年\n    static func currentYear(date: Date = Date()) -> Int {\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com.year!\n    }\n  \n    // MARK: - 今月\n    static func currentMonth(date: Date = Date()) -> Int {\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com.month!\n    }\n  \n    // MARK: - 今日\n    static func currentDay(date: Date = Date()) -> Int {\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com.day!\n    }\n    \n    // MARK: - 今天星期几\n    static func currentWeekDay(date: Date = Date()) -> Int {\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.weekday], from: date)\n        return com.weekday!\n    }\n    \n    // MARK: - 农历今年\n    static func currentChineseYear(date: Date = Date()) -> String {\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.year], from: date)\n        return numberToChina(yearNum: (com?.year)!) + \"年\"\n    }\n    \n    // MARK: - 农历今月\n    static func currentChineseMonth(date: Date = Date()) -> String {\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.month], from: date)\n        return numberToChina(monthNum: (com?.month)!)\n    }\n\n    // MARK: - 农历今日\n    static func currentChineseDay(date: Date = Date()) -> String {\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.day], from: date)\n        return numberToChina(dayNum: (com?.day)!)\n    }\n    \n    // MARK: - 农历今日\n    static func currentChineseDayInt(date: Date = Date()) -> Int {\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.day], from: date)\n        return (com?.day)!\n    }\n    \n    // MARK: - 农历星期\n    static func currentChineseWeekYear(date: Date = Date()) -> String {\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.weekday], from: date)\n        return numberToChina(weekNum: (com?.weekday)!)\n    }\n  \n    // MARK: - 下个月\n    static func nextMonth(date: Date = Date()) -> Date {\n        let calendar = NSCalendar.current\n        let nDate = calendar.date(byAdding: DateComponents(month: 1), to: date)\n        return nDate!\n    }\n    \n    // MARK: - 上个月\n    static func lastMonth(date: Date = Date()) -> Date {\n        let calendar = NSCalendar.current\n        let lDate = calendar.date(byAdding: DateComponents(month: -1), to: date)\n        return lDate!\n    }\n    \n    // MARK: - 下一天\n    static func lastDay(date: Date = Date()) -> Date{\n        let calendar = NSCalendar.current\n        let lDate = calendar.date(byAdding: DateComponents(day: 1), to: date)\n        return lDate!\n    }\n  \n    // MARK: - 本月天数\n    static func countOfDaysInCurrentMonth(date: Date = Date()) -> Int {\n        let calendar = Calendar(identifier: Calendar.Identifier.gregorian)\n        let range = (calendar as NSCalendar?)?.range(of: NSCalendar.Unit.day, in: NSCalendar.Unit.month, for: date)\n        return (range?.length)!\n    }\n \n    // MARK: - 当月第一天是星期几\n    static func firstWeekDayInCurrentMonth(date: Date = Date()) -> Int {\n        // 星期和数字一一对应 星期日：7\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = \"yyyy-MM\"\n        let date = dateFormatter.date(from: String(date.xj.year)+\"-\"+String(date.xj.month))\n        let calender = Calendar(identifier: Calendar.Identifier.gregorian)\n        let comps = (calender as NSCalendar?)?.components(NSCalendar.Unit.weekday, from: date!)\n        var week = comps?.weekday\n        if week == 1 {\n            week = 8\n        }\n        return week! - 1\n    }\n\n    // MARK: - - 获取指定日期各种值\n    // 根据年月得到某月天数\n    static func getCountOfDaysInMonth(year: Int, month: Int) -> Int{\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = \"yyyy-MM\"\n        let date = dateFormatter.date(from: String(year)+\"-\"+String(month))\n        let calendar = Calendar(identifier: Calendar.Identifier.gregorian)\n        let range = (calendar as NSCalendar?)?.range(of: NSCalendar.Unit.day, in: NSCalendar.Unit.month, for: date!)\n        return (range?.length)!\n    }\n    \n    // MARK: - 根据年月得到某月第一天是周几\n    static func getfirstWeekDayInMonth(year: Int, month: Int) -> Int{\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = \"yyyy-MM\"\n        let date = dateFormatter.date(from: String(year)+\"-\"+String(month))\n        let calendar = Calendar(identifier: Calendar.Identifier.gregorian)\n        let comps = (calendar as NSCalendar?)?.components(NSCalendar.Unit.weekday, from: date!)\n        let week = comps?.weekday\n        return week! - 1\n    }\n\n    // MARK: - date转日期字符串\n    static func dateToDateString(_ date: Date, dateFormat: String) -> String {\n        let timeZone = NSTimeZone.default\n        let formatter = DateFormatter()\n        formatter.timeZone = timeZone\n        formatter.dateFormat = dateFormat\n        let date = formatter.string(from: date)\n        return date\n    }\n\n    // MARK: - 日期字符串转date\n    static func dateStringToDate(_ dateStr: String) -> Date {\n        let dateFormatter = DateFormatter()\n        dateFormatter.timeZone = TimeZone(abbreviation: \"UTC+8\")\n        dateFormatter.dateFormat = \"yyyy-MM-dd\"\n        let date = dateFormatter.date(from: dateStr)\n        return date!\n    }\n    \n    // MARK: - 时间字符串转date\n    static func timeStringToDate(_ dateStr: String) -> Date {\n        let dateFormatter = DateFormatter()\n        dateFormatter.timeZone = TimeZone(abbreviation: \"UTC+8\")\n        dateFormatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n        let date = dateFormatter.date(from: dateStr)\n        return date!\n    }\n\n    // MARK: - 计算天数差\n    static func dateDifference(_ dateA: Date, from dateB: Date) -> Double {\n        let interval = dateA.timeIntervalSince(dateB)\n        return interval/86400\n    }\n\n    // MARK: - 比较时间先后\n    static func compareOneDay(oneDay: Date, withAnotherDay anotherDay: Date) -> Int {\n        let dateFormatter: DateFormatter = DateFormatter()\n        dateFormatter.dateFormat = \"yyyy-MM-dd\"\n        let oneDayStr: String = dateFormatter.string(from: oneDay)\n        let anotherDayStr: String = dateFormatter.string(from: anotherDay)\n        let dateA = dateFormatter.date(from: oneDayStr)\n        let dateB = dateFormatter.date(from: anotherDayStr)\n        let result: ComparisonResult = (dateA?.compare(dateB!))!\n        // Date1 is in the future\n        if(result == ComparisonResult.orderedDescending ) {\n            return 1\n        }\n        // Date1 is in the past\n        else if(result == ComparisonResult.orderedAscending) {\n            return 2\n        }\n            // Both dates are the same\n        else {\n            return 0\n        }\n    }\n\n    // MARK: - 时间与时间戳之间的转化\n    // 将时间转换为时间戳\n    static func stringToTimeStamp(_ stringTime: String) -> Int {\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat = \"yyyy-MM-dd HH: mm: ss\"\n        dfmatter.locale = Locale.current\n        let date = dfmatter.date(from: stringTime)\n        let dateStamp: TimeInterval = date!.timeIntervalSince1970\n        let dateSt: Int = Int(dateStamp)\n        return dateSt\n    }\n    \n    // 将时间戳转换为年月日\n    static func timeStampToString(_ timeStamp: String) -> String {\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=\"yyyy年MM月dd日\"\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    }\n    \n    // 将时间戳转换为具体时间\n    static func timeStampToStringDetail(_ timeStamp: String) -> String {\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=\"yyyy年MM月dd日HH: mm: ss\"\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    }\n    \n    // 将时间戳转换为时分秒\n    static func timeStampToHHMMSS(_ timeStamp: String) -> String {\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=\"HH: mm: ss\"\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    }\n    \n    // 将时间戳转换为时分\n    static func timeStampToHHMM(_ timeStamp: String) -> String {\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=\"HH: mm\"\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    }\n    \n    // 获取系统的当前时间戳\n    static func getStamp(date: Date = Date()) -> Int{\n        // 获取当前时间戳\n        let timeInterval: Int = Int(date.timeIntervalSince1970)\n        return timeInterval\n    }\n    \n    // 日数字转汉字\n    static func numberToChina(yearNum: Int) -> String {\n        // 以一个天干和一个地支相配，排列起来，天干在前，地支在后，天干由甲起，地支由子起，阳干对阳支，阴干对阴支（阳干不配阴支，阴干不配阳支）\n        // 就会得到六十年一周期的甲子回圈，一般称为“六十甲子”或“花甲子”\n        // 十天干： 甲（jiǎ）、乙（yǐ）、丙（bǐng）、丁（dīng）、戊（wù）、己（jǐ）、庚（gēng）、辛（xīn）、壬（rén）、癸（guǐ）\n        // 十二地支： 子（zǐ）、丑（chǒu）、寅（yín）、卯（mǎo）、辰（chén）、巳（sì）、午（wǔ）、未（wèi）、申（shēn）、酉（yǒu）、戌（xū）、亥（hài）\n        let ChinaArray = [ \"甲子\", \"乙丑\", \"丙寅\", \"丁卯\", \"戊辰\", \"己巳\", \"庚午\", \"辛未\", \"壬申\", \"癸酉\",\n                         \"甲戌\", \"乙亥\", \"丙子\", \"丁丑\", \"戊寅\", \"己卯\", \"庚辰\", \"辛己\", \"壬午\", \"癸未\",\n                         \"甲申\", \"乙酉\", \"丙戌\", \"丁亥\", \"戊子\", \"己丑\", \"庚寅\", \"辛卯\", \"壬辰\", \"癸巳\",\n                         \"甲午\", \"乙未\", \"丙申\", \"丁酉\", \"戊戌\", \"己亥\", \"庚子\", \"辛丑\", \"壬寅\", \"癸丑\",\n                         \"甲辰\", \"乙巳\", \"丙午\", \"丁未\", \"戊申\", \"己酉\", \"庚戌\", \"辛亥\", \"壬子\", \"癸丑\",\n                         \"甲寅\", \"乙卯\", \"丙辰\", \"丁巳\", \"戊午\", \"己未\", \"庚申\", \"辛酉\", \"壬戌\", \"癸亥\"]\n        let ChinaStr: String = ChinaArray[yearNum - 1]\n        return ChinaStr\n    }\n    \n    // 月份数字转汉字\n    static func numberToChina(monthNum: Int) -> String {\n        let ChinaArray = [\"一月\", \"二月\", \"三月\", \"四月\", \"五月\", \"六月\", \"七月\", \"八月\", \"九月\", \"十月\", \"十一月\", \"十二月\"]\n        let ChinaStr: String = ChinaArray[monthNum - 1]\n        return ChinaStr\n    }\n    \n    // 日数字转汉字\n    static func numberToChina(dayNum: Int) -> String {\n        let ChinaArray = [ \"初一\", \"初二\", \"初三\", \"初四\", \"初五\", \"初六\", \"初七\", \"初八\", \"初九\", \"初十\",\n                         \"十一\", \"十二\", \"十三\", \"十四\", \"十五\", \"十六\", \"十七\", \"十八\", \"十九\", \"二十\",\n                         \"廿一\", \"廿二\", \"廿三\", \"廿四\", \"廿五\", \"廿六\", \"廿七\", \"廿八\", \"廿九\", \"三十\"]\n        let ChinaStr: String = ChinaArray[dayNum - 1]\n        return ChinaStr\n    }\n      \n    // 星期数字转汉字\n    static func numberToChina(weekNum: Int) -> String {\n        let ChinaArray = [\"一月\", \"二月\", \"三月\", \"四月\", \"五月\", \"六月\", \"七月\", \"八月\", \"九月\", \"十月\", \"十一月\", \"十二月\"]\n        let ChinaStr: String = ChinaArray[weekNum - 1]\n        return ChinaStr\n    }\n    \n    // MARK: - 数字前补0\n    static func add0BeforeNumber(_ number: Int) -> String {\n        if number >= 10 {\n            return String(number)\n        }else{\n            return \"0\" + String(number)\n        }\n    }\n    \n    static func getCurrentSystemDate() -> Date{\n        let date = Date() // 获得时间对象\n        let zone = NSTimeZone.system // 获得系统的时区\n        let time = zone.secondsFromGMT(for: date)// 以秒为单位返回当前时间与系统格林尼治时间的差\n        return date.addingTimeInterval(TimeInterval(time))// 然后把差的时间加上,就是当前系统准确的时间\n    }\n    \n    static func date(_ date: String?, dateFormat: String = \"yyyy-MM-dd\") -> Date? {\n        guard let date = date else {\n            return nil\n        }\n        let dateformatter = DateFormatter()\n        dateformatter.timeZone = TimeZone.init(secondsFromGMT: 0)\n        dateformatter.dateFormat = dateFormat\n        return dateformatter.date(from: date)\n    }\n\n    // MARK: - 将时间显示为（几分钟前，几小时前，几天前）\n    static func compareCurrentTime(str: String) -> String {\n        //let currentDateStr = dateToDateString(Date(), dateFormat: \"yyyy-MM-dd hh:mm:ss\")\n        let currentDate = getCurrentSystemDate()\n        let sendTimeDate = date(str,dateFormat: \"yyyy-MM-dd HH:mm:ss\")!//self.timeStringToDate(str)\n        let sendTimeInterval = Double(getStamp(date: sendTimeDate))\n        let timeInterval = currentDate.timeIntervalSince(sendTimeDate)\n\n        var todayStr = dateToDateString(Date(), dateFormat: \"yyyy-MM-dd\")\n        todayStr = todayStr+\" 00:00\"\n        let todayTimeInterval = Double(Date().stringToSecondTimeStamp(todayStr)) ?? 0\n        let yestDayTimeInterval = Double(todayTimeInterval - 86400)\n        let nextDayTimeInterval = Double(todayTimeInterval + 86400)\n\n        var temp: Double = 0\n        var result: String = \"\"\n        if timeInterval/60 < 1 {\n            result = \"刚刚\"\n        }else if (timeInterval/60) < 60{\n            temp = timeInterval/60\n            result = \"\\(Int(temp))分钟前\"\n        }else if sendTimeInterval > todayTimeInterval && sendTimeInterval < nextDayTimeInterval{\n\n            //let interval = nextDayTimeInterval - sendTimeInterval\n            temp = timeInterval/60/60\n            result = \"\\(Int(temp))小时前\"\n        }else if sendTimeInterval > yestDayTimeInterval && sendTimeInterval < todayTimeInterval{\n            //let str = timeStampToHHMM(String.init(format: \"%d\", sendTimeInterval))\n            let timeStr = str.components(separatedBy: \" \").last ?? \"\"\n            let str = timeStr.prefix(5)\n            result = \"昨天\\(str)\"\n        }else{\n            let timeStr = str.components(separatedBy: \" \").first ?? \"\"\n            let timeArr = timeStr.components(separatedBy: \"-\")\n            if !timeArr.isEmpty {\n                result = \"\\(timeArr[0])年\\(timeArr[1])月\\(timeArr[2])日\"\n            }\n            //result = timeStampToString(String.init(format: \"%d\", sendTimeInterval))\n        }\n        \n//        else if timeInterval/(30 * 24 * 60 * 60) < 12 {\n//            temp = timeInterval/(30 * 24 * 60 * 60)\n//            result = \"\\(Int(temp))个月前\"\n//        }else{\n//            temp = timeInterval/(12 * 30 * 24 * 60 * 60)\n//            result = \"\\(Int(temp))年前\"\n//        }\n        return result\n    }\n}\n\n```\n\n## 5 撸下最后的日历Cell\n\n这个就是日历里面的item，还是相当简单的。\n\n### 5.1 全局变量\n```Swift\nclass CalendarCell: UICollectionViewCell {\n    \n    static var identifier = \"UICollectionViewCell\"\n    \n    var isGreaterThan: Bool = false     //是否取大于今天的值\n    \n    var isShowPassTime: Int = 0         //是否设定禁选\n    \n    var model:TimeModel?{\n        didSet{\n            guard let _model = model else {return}\n            if _model.day != 0 {\n                titleLab.text = \"\\(_model.day)\"\n            }else{\n                titleLab.text = \"\" // 为0，啥也不显示\n            }\n            \n            let com = YSDateTool.currentDateCom()\n            \n            // 是否是选中的日子\n            if com.year == _model.year && com.month == _model.month && com.day == _model.day {\n                titleLab.textColor = UIColor.init(hex: \"#409EFF\")\n            }else{\n                titleLab.textColor = UIColor.init(hex: \"#323233\")\n            }\n            \n            // 禁用还是可用\n            if isShowPassTime == 0 {\n                if isGreaterThan {\n                    if (com.year == _model.year && com.month == _model.month && _model.day > com.day!) || (_model.year == com.year! && _model.month > com.month!) || (_model.year > com.year!){\n                        titleLab.textColor = UIColor.init(hex: \"#C8C9CC\")\n                    }\n                }else{\n                    // 如果要大于今天，那么前面的时间就的置灰了 前一个月的点不过去，不考虑了\n                    if com.year == _model.year && com.month == _model.month && _model.day < com.day!{\n                        titleLab.textColor = UIColor.init(hex: \"#C8C9CC\")\n                    }\n                }\n            }\n        }\n    }\n    \n    // 选中的item，背景颜色高亮\n    var selectedModel: TimeModel?{\n        didSet{\n            guard let _model = selectedModel else{return}\n            if _model.year == model?.year && _model.month == model?.month && _model.day == model?.day{\n                titleLab.backgroundColor = UIColor.init(hex: \"#409EFF\")\n                titleLab.textColor = UIColor.white\n            }else{\n                titleLab.backgroundColor = UIColor.clear\n            }\n        }\n    }\n```\n比较重要的是model，表示当前时间实体类。这里监听变量改变，利用didSet实现动态改变文案效果。\n\n另外一个是selectedModel，这个是当前选中的item，会比对item是否为选中，选中样式会有所不同。\n\n### 5.2 UI子View\n\n这里只用到一个子View。\n```Swift\nvar titleLab: UILabel = {\n        let lan = UILabel()\n        lan.font = .pingFangRegular(size: 16)\n        lan.textAlignment = .center\n        lan.textColor = UIColor.init(hex: \"#323233\")\n        \n        lan.layer.cornerRadius = 4\n        lan.layer.masksToBounds = true\n        return lan\n    }()\n```\n\n### 5.3 生命周期函数\n\n```Swift\noverride init(frame: CGRect) {\n        super.init(frame: frame)\n        contentView.backgroundColor = .clear\n        contentView.addSubview(titleLab)\n        titleLab.snp.makeConstraints{make in\n            make.top.bottom.leading.trailing.equalToSuperview()\n        }\n    }\n    \n    required init?(coder aDecoder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n```\n把那个子View添加到Cell里面去了。\n\n大概就是这样子。\n\n## 6 总结\n\n* 如果UI图有那种Tab页，就可以考虑使用多种方案来实现，iOS直接用简单的Button也是可以实现的，分割线也是可以用最简单的UIView来实现，不一定要用封装好的框架，谁用挖掘机来搬小石头呢，大材小用了。\n\n* 分页效果可以使用UIScrollView来实现，把它宽度设置为屏幕的n倍，这样最有滑动可以很好控制的，不要动画也可以设置的，办法总是就很多的。\n\n* 日历效果可以用UICollectionView来实现，看着很复杂，其实很简单，主要逻辑也不复杂，控制好数据刷新就好了。UICollectionView可以实现类似网格的效果，我们只需要在Cell里面绘制一个一个Cell，空的部分，我们啥不展示就好了。\n\n* 系统的UIPickerView设置分割线很简单，利用UIPickerView下有一个subViews，这里寻找高度为item高度大小的，然后给view设置一个Layer即可。","slug":"iOS-swift-自定义View之时间选择器","published":1,"updated":"2023-02-01T07:12:26.066Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlc01jh0013jhv73teadvee","content":"<h2 id=\"1-需求分析\"><a href=\"#1-需求分析\" class=\"headerlink\" title=\"1 需求分析\"></a>1 需求分析</h2><p>当我们选择购买一个东西时，有时需要预约发货，这时候需要用户手动选择某一天某一个时间，ui给的方案是这样的：<br>预约日期：<br><img src=%E9%A2%84%E7%BA%A6%E6%97%A5%E6%9C%9F.png></p>\n<p>预约时间：<br><img src=%E9%A2%84%E7%BA%A6%E6%97%B6%E9%97%B4.png><br>这里是间隔了2个小时一个时间。</p>\n<p>可以看到这个日期是以日历形式展现，可以选择未来某个日期；时间是以滚轮的方式展现，可以上下滑动到目标时间点。</p>\n<p>对于这个需求，我们要如何实现呢？‘</p>\n<p>答案当然是自定义View了。</p>\n<h2 id=\"2-结构分析\"><a href=\"#2-结构分析\" class=\"headerlink\" title=\"2 结构分析\"></a>2 结构分析</h2><p>显而易见，这个因为设计到分页，我们可以考虑分页区域使用一个UIScrollView，水平滑动，宽度设置为屏幕的2倍，一半用来展示日历，一半用来展示预约时间的UIPickerView。</p>\n<p>所以需要我们自定义一个UIView，这里面先绘制顶部分割线，再绘制标题，“预约日期”和“预约时间”和“取消”的文案。</p>\n<p>然后是一个显示日历操作栏，包括左右箭头和中间的月份显示，这个要放到UIScrollView的左半边，包括星期视图和日历的UICollectionView的集合View，这里日历我们采用这个集合View很容易实现的。</p>\n<p>然后右侧就是一个UIPickerView,这个系统封装好了，使用很方便，我们主要负责填充数据。</p>\n<p>那这个结构大体出来了，一个是整个自定义View，暂且把它叫做CalenderView，还有一个就是日历内部的Cell，暂且叫做CalenderCell。</p>\n<h2 id=\"3-撸下CalenderView\"><a href=\"#3-撸下CalenderView\" class=\"headerlink\" title=\"3 撸下CalenderView\"></a>3 撸下CalenderView</h2><h3 id=\"3-1-全局变量\"><a href=\"#3-1-全局变量\" class=\"headerlink\" title=\"3.1 全局变量\"></a>3.1 全局变量</h3><pre><code class=\"line-numbers language-Swift\">class CalendarView: UIView &#123;\n    \n    /// 传出去给调用者\n    typealias DoneBlock = (TimeModel)-&gt;()\n    var doneHandle: DoneBlock!\n    \n    // 当月日期Model\n    var modelArr: [TimeModel] = []\n    \n    // 动态调整上下月的时间变量\n    var dynamicDate = Date()\n    \n    //默认选中的日期\n    var timeModel: TimeModel = TimeModel()\n    \n    //时间时短数据\n    static let range: String = &quot;                      &quot;\n    private var timeArr: [String] = [&quot;08:00\\(range)10:00&quot;,\n                                   &quot;10:00\\(range)12:00&quot;,\n                                   &quot;12:00\\(range)14:00&quot;,\n                                   &quot;14:00\\(range)16:00&quot;,\n                                   &quot;16:00\\(range)18:00&quot;,\n                                   &quot;18:00\\(range)20:00&quot;,\n                                   &quot;20:00\\(range)22:00&quot;]\n    private var selectIndex = 0\n    \n</code></pre>\n<p>这里定义了一个闭包返回，主要是用户选择后，回调给外部。</p>\n<p>然后有一个TimeModel的数组， 也就是填充我们的日历视图。</p>\n<p>timeModel是我们选择的日期，会高亮显示。</p>\n<p>timeArr是我们右侧使用的UIPickerView要用的数据。</p>\n<h3 id=\"3-2-UI定义\"><a href=\"#3-2-UI定义\" class=\"headerlink\" title=\"3.2 UI定义\"></a>3.2 UI定义</h3><p>这里我们大致会用到这些视图。</p>\n<pre><code class=\"line-numbers language-Swift\">//白色背景底 整个半屏的视图\nprivate lazy var acView: UIView = &#123;\n    let view = UIView()\n    view.backgroundColor = .white\n    return view\n&#125;()\n\n//选中条\nprivate lazy var lineView: UIView = &#123;\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n    return view\n&#125;()\n\n/// 预约日期按钮\nprivate lazy var dateBtn: UIButton = &#123;\n    let btn = UIButton()\n    btn.setTitle(&quot;预约日期&quot;, for: .normal)\n    btn.titleFont = .pingFangMedium(size: 16)\n    btn.setTitleColor(UIColor.lightGray, for: .normal)\n    btn.setTitleColor(UIColor.black, for: .selected)\n    btn.addTarget(self, action: #selector(actionForChooseDate), for: .touchUpInside)\n    btn.isSelected = true\n    return btn\n&#125;()\n\n/// 预约时间按钮\nprivate lazy var timeBtn: UIButton = &#123;\n    let btn = UIButton()\n    btn.setTitle(&quot;预约时间&quot;, for: .normal)\n    btn.titleFont = .pingFangMedium(size: 16)\n    btn.setTitleColor(UIColor.lightGray, for: .normal)\n    btn.setTitleColor(UIColor.black, for: .selected)\n    btn.addTarget(self, action: #selector(actionForChooseTime), for: .touchUpInside)\n    return btn\n&#125;()\n\n/// 取消按钮\nprivate lazy var cancelBtn: UIButton = &#123;\n    let btn = UIButton()\n    btn.setTitle(&quot;取消&quot;, for: .normal)\n    btn.setTitleColor(UIColor.init(hex: &quot;#409EFF&quot;), for: .normal)\n    btn.titleFont = .pingFangRegular(size: 16)\n    btn.addTarget(self, action: #selector(actionForCancel), for: .touchUpInside)\n    return btn\n&#125;()\n\n//日历工具条\nprivate lazy var dateToolView: UIView = &#123;\n    let view = UIView()\n    return view\n&#125;()\n\n//日历工具条显示当前月份标签\nprivate lazy var monthLb: UILabel = &#123;\n    let lab = UILabel()\n    lab.font = .pingFangMedium(size: 16)\n    lab.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n    lab.text = &quot;&quot;\n    lab.textAlignment = .center\n    return lab\n&#125;()\n\n//日历工具条左箭头\nprivate lazy var toolLeftBtn: UIButton = &#123;\n    let btn = UIButton()\n    btn.setImage(UIImage.init(named: &quot;日历_左箭头&quot;), for: .normal)\n    btn.addTarget(self, action: #selector(actionForLeftEvent), for: .touchUpInside)\n    btn.isHidden = true\n    return btn\n&#125;()\n\n//日历工具条右箭头\nprivate lazy var toolRightBtn: UIButton =  &#123;\n    let btn = UIButton()\n    btn.setImage(UIImage.init(named: &quot;日历_右箭头&quot;), for: .normal)\n    btn.addTarget(self, action: #selector(actionForRightEvent), for: .touchUpInside)\n    return btn\n&#125;()\n\n//星期X显示条\nprivate lazy var weeksView: UIView = &#123;\n    let view = UIView()\n    view.backgroundColor = .white\n    view.layer.shadowColor = UIColor.init(hex: &quot;#7D7E80&quot;).cgColor\n    view.layer.shadowOffset = CGSize.init(width: 0, height: 2)\n    view.layer.shadowRadius = 10\n    view.layer.shadowOpacity = 0.16\n    return view\n&#125;()\n\n//滚动视图 左右滚动\nprivate lazy var scrollView: UIScrollView = &#123;\n    let _scrollView = UIScrollView()\n    _scrollView.contentSize = CGSize.init(width: ScreenWidth*2, height: _scrollView.size.height)\n    _scrollView.bounces = false\n    _scrollView.isScrollEnabled = true\n    _scrollView.isPagingEnabled = true\n    _scrollView.showsVerticalScrollIndicator = false\n    _scrollView.showsHorizontalScrollIndicator = false\n    return _scrollView\n&#125;()\n\n//月份水印背景\nprivate lazy var watermarkView: CalendarWatermark = &#123;\n    let view = CalendarWatermark()\n    view.backgroundColor = .white\n    view.isHidden = true  //当前版本隐藏水印\n    return view\n&#125;()\n\n//日历展示表\n    private lazy var collectionView: UICollectionView = &#123;\n        let layout = UICollectionViewFlowLayout()\n        layout.scrollDirection = .vertical\n        let collection = UICollectionView(frame: CGRect.init(x: 0, y: 34+40, width: ScreenWidth, height: ScreenHeight*0.57*0.57), collectionViewLayout: layout)\n        collection.backgroundColor = .clear\n        collection.delegate = self\n        collection.dataSource = self\n        collection.isPagingEnabled = true\n        collection.showsHorizontalScrollIndicator = false\n        collection.bounces = false\n        collection.register(CalendarCell.self, forCellWithReuseIdentifier: CalendarCell.identifier)\n        return collection\n&#125;()\n\n//时间选择器 x轴以 屏幕宽度为起点，刚好在第二屏了\nprivate lazy var pickerView: UIPickerView = &#123;\n    let picker = UIPickerView.init(frame: CGRect.init(x: ScreenWidth, y: 0, width: ScreenWidth, height: ScreenHeight*0.57*0.57+34+40))\n    picker.delegate = self\n    picker.dataSource = self\n    return picker\n&#125;()\n</code></pre>\n<p>这些需要用代理和数据源的都设置self，后面再具体实现。</p>\n<p>这里可以认为是我们搭建房子用到的一些素材。先写好，后期再拼接下。</p>\n<h3 id=\"3-3-生命周期函数\"><a href=\"#3-3-生命周期函数\" class=\"headerlink\" title=\"3.3 生命周期函数\"></a>3.3 生命周期函数</h3><p>初始化看下，应该要先设置一个蒙层。</p>\n<pre><code class=\"line-numbers language-Swift\">override init(frame: CGRect)&#123;\n        super.init(frame: frame)\n        /// 这里应该是蒙层\n        self.backgroundColor = UIColor.init(r: 100, g: 1, b: 1, a: 0.3)\n        self.alpha = 0\n        \n        let lastDyaDate = YSDateTool.lastDay()\n        let com = YSDateTool.currentDateCom(date: lastDyaDate)\n        watermarkView.monthStr = &quot;\\(com.month!)&quot;\n    &#125;\n    \n    required init?(coder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n</code></pre>\n<p>确实如此，这里就只加了个颜色。</p>\n<h3 id=\"3-4-定义方法，展示和隐藏选择器\"><a href=\"#3-4-定义方法，展示和隐藏选择器\" class=\"headerlink\" title=\"3.4 定义方法，展示和隐藏选择器\"></a>3.4 定义方法，展示和隐藏选择器</h3><pre><code class=\"line-numbers language-Swift\">extension CalendarView&#123;\n    /// 显示弹窗\n    public func showAlertView() &#123;\n        let str = &quot;\\(timeModel.startTime)\\(CalendarView.range)\\(timeModel.endTime)&quot;\n        selectIndex = timeArr.firstIndex(of:str) ?? 0\n        let timeStr = &quot;\\(timeModel.year)-\\(timeModel.month)-\\(timeModel.day)&quot;\n        let date = YSDateTool.dateStringToDate(timeStr)\n        self.setDate(date: date)\n        self.setUI()\n        pickerView.selectRow(selectIndex, inComponent: 0, animated: false)\n        UIView.animate(withDuration: 0.25) &#123;\n            self.alpha = 1\n        &#125;\n    &#125;\n\n    /// 隐藏弹窗\n    public func dismissAlertView() &#123;\n        self.animate(duration: 0.25) &#123;\n            self.alpha = 0\n        &#125; completion: &#123; finish in\n            self.removeFromSuperview()\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这个方法很重要，主要提供给外部使用，这里帮助外部设置数据，因为外部调用者可能不知道内部细节，所以我们最好在这个类里面实现展示弹框的方法。</p>\n<h3 id=\"3-5-设置初始化日期\"><a href=\"#3-5-设置初始化日期\" class=\"headerlink\" title=\"3.5 设置初始化日期\"></a>3.5 设置初始化日期</h3><p>外部可能有选择好的日期，所以我们必须提供一个方法，设置数据。</p>\n<pre><code class=\"line-numbers language-Swift\">extension CalendarView&#123;\n    /// 按照这个date获取这个月的数据\n    func setDate(date: Date = Date())&#123;\n        modelArr.removeAll()\n        let count = YSDateTool.countOfDaysInCurrentMonth(date: date)    //当月天数\n        for i in 0..&lt;count&#123;\n            let model = self.initializeModel(date: date, day: i+1)\n            modelArr.append(model)\n        &#125;\n        let firstWeekDay = YSDateTool.firstWeekDayInCurrentMonth(date: date)    //当月第一天周几\n        \n        //头部空缺数据填充 插入一个空的model\n        if firstWeekDay != 7 &#123;\n            for _ in 0 ..&lt; firstWeekDay&#123;\n                let model = self.initializeModel(date: date, day: 0)\n                modelArr.insert(model, at: 0)\n            &#125;\n        &#125;\n        //尾部空缺数据填充,插入一个空的model\n        if modelArr.count &lt; 35&#123;\n            for _ in modelArr.count ..&lt; 35&#123;\n                let model = self.initializeModel(date: date, day: 0)\n                modelArr.append(model)\n            &#125;\n        &#125;\n        \n        collectionView.reloadData()\n    &#125;\n    \n    /// 初始化数据，返回\n    func initializeModel(date: Date, day: Int)-&gt;TimeModel&#123;\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        let model = TimeModel()\n        model.year = com.year!\n        model.month = com.month!\n        model.day = day\n        \n        // model指代当前时间\n        let monthStr = com.month! &lt; 10 ? &quot;0\\(model.month)&quot; : &quot;\\(model.month)&quot;\n        let dayStr = com.day! &lt; 10 ? &quot;0\\(model.day)&quot; : &quot;\\(model.day)&quot;\n        model.dateStr = &quot;\\(com.year!)-\\(monthStr)-\\(dayStr)&quot;\n        return model\n    &#125;\n&#125;\n</code></pre>\n<p>这里也搞了2个扩展函数，会根据目标日期，获取到该日期的一个月的数据，然后会填充第一天非星期天的情况的数据，也会填最后几天空白区域的数据。</p>\n<h3 id=\"3-6-设置UI\"><a href=\"#3-6-设置UI\" class=\"headerlink\" title=\"3.6 设置UI\"></a>3.6 设置UI</h3><p>有了日期就可以设置UI了，所以我们看下如何填充视图的。</p>\n<pre><code class=\"line-numbers language-Swift\">extension CalendarView &#123;\n    func setUI() &#123;\n        \n        //日历顶部按钮布局\n        self.addSubview(acView)\n        acView.snp.makeConstraints&#123;make in\n            make.leading.trailing.bottom.equalTo(0)\n            make.height.equalTo(ScreenHeight*0.57)\n        &#125;\n        \n        // 加顶部横线 左上角默认位置\n        acView.addSubview(lineView)\n        self.lineViewLayout()\n        \n        // 加预约日期\n        acView.addSubview(dateBtn)\n        dateBtn.snp.makeConstraints&#123;make in\n            make.top.equalTo(11)\n            make.leading.equalTo(28)\n            make.width.equalTo(66)\n            make.height.equalTo(22)\n        &#125;\n        \n        // 预约时间\n        acView.addSubview(timeBtn)\n        timeBtn.snp.makeConstraints&#123;make in\n            make.top.equalTo(11)\n            make.centerX.equalToSuperview()\n            make.width.equalTo(66)\n            make.height.equalTo(22)\n        &#125;\n        \n        // 加取消按钮\n        acView.addSubview(cancelBtn)\n        cancelBtn.snp.makeConstraints&#123;make in\n            make.top.equalTo(11)\n            make.trailing.equalTo(-16)\n            make.width.equalTo(66)\n            make.height.equalTo(22)\n        &#125;\n        \n        \n        // 继续加滚动视图\n        acView.addSubview(scrollView)\n        scrollView.snp.makeConstraints&#123;make in\n            make.top.equalTo(dateBtn.snp.bottom).offset(10)\n            make.leading.trailing.equalToSuperview()\n            make.bottom.equalToSuperview()\n        &#125;\n        \n        // acView添加完毕，现在到内部ScrollView层级了--------------\n    \n        // 加个集合View 集合View因为初始化确定了y轴高度，这里无需重复布局\n        scrollView.addSubview(collectionView)\n        \n        // 再加个pickerView 时间滚轮，这里直接加到ScrollView里面了，也无需布局，直接覆盖到上层的\n        scrollView.addSubview(pickerView)\n        \n        // 先加工具栏\n        scrollView.addSubview(dateToolView)\n        dateToolView.snp.makeConstraints&#123;make in\n            make.top.leading.equalTo(0)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(40)\n        &#125;\n        \n        // 滚动视图再加星期视图\n        scrollView.addSubview(weeksView)\n        weeksView.snp.makeConstraints&#123;make in\n            make.top.equalTo(dateToolView.snp.bottom).offset(4)\n            make.leading.equalTo(0)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(30)\n        &#125;\n        \n        \n        // 处理下工具栏内部布局\n        dateToolView.addSubview(monthLb)\n        monthLb.snp.makeConstraints&#123;make in\n            make.centerY.equalToSuperview()\n            make.centerX.equalToSuperview()\n            make.width.equalTo(100)\n            make.height.equalTo(20)\n        &#125;\n        \n        // 日历工具条加左按钮\n        dateToolView.addSubview(toolLeftBtn)\n        toolLeftBtn.snp.makeConstraints&#123;make in\n            make.centerY.equalToSuperview()\n            make.width.height.equalTo(40)\n            make.leading.equalTo(16)\n        &#125;\n\n        // 日历工具条加右侧箭头\n        dateToolView.addSubview(toolRightBtn)\n        toolRightBtn.snp.makeConstraints&#123;make in\n            make.centerY.equalToSuperview()\n            make.width.height.equalTo(40)\n            make.trailing.equalTo(-16)\n        &#125;\n        \n        // 设置星期几内部布局\n        setWeekUiInner()\n        \n        // 地址底部按钮\n        addBottomUI()\n    \n    &#125;\n</code></pre>\n<p>中规中矩，老老实实从上到下，从左到右布局。</p>\n<p>内部星期几看下如何布局的：</p>\n<pre><code class=\"line-numbers language-Swift\">func setWeekUiInner() &#123;\n        let arr = [&quot;日&quot;,&quot;一&quot;,&quot;二&quot;,&quot;三&quot;,&quot;四&quot;,&quot;五&quot;,&quot;六&quot;]\n\n        for i in 0 ..&lt; arr.count &#123;\n            let width = ScreenWidth/7\n            let lab = UILabel()\n            lab.text = arr[i]\n            lab.textColor = UIColor.init(hex: &quot;#323233&quot;)\n            lab.font = .pingFangRegular(size: 12)\n            lab.textAlignment = .center\n            weeksView.addSubview(lab)\n            lab.snp.makeConstraints&#123;make in\n                make.leading.equalTo(width*CGFloat(i))\n                make.centerY.equalToSuperview()\n                make.width.equalTo(width)\n                make.height.equalTo(20)\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>还有底部的下一步和完成：</p>\n<pre><code class=\"line-numbers language-Swift\">func addBottomUI() &#123;\n        let nextBtn: UIButton = UIButton.init(type: .custom)\n        nextBtn.frame = CGRect.init(x: 16, y: ScreenHeight*0.57*0.57+8+34+40, width: (ScreenWidth-32), height: 44)\n        nextBtn.titleFont = .pingFangMedium(size: 16)\n        nextBtn.setTitleColor(.white, for: .normal)\n        nextBtn.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n        nextBtn.setTitle(&quot;下一步&quot;, for: .normal)\n        nextBtn.layer.cornerRadius = 22\n        nextBtn.addTarget(self, action: #selector(actionForNext), for: .touchUpInside)\n        scrollView.addSubview(nextBtn)\n        \n        let doneBtn: UIButton = UIButton.init(type: .custom)\n        doneBtn.frame = CGRect.init(x: ScreenWidth+16, y: ScreenHeight*0.57*0.57+8+34+40, width: (ScreenWidth-32), height: 44)\n        doneBtn.titleFont = .pingFangMedium(size: 16)\n        doneBtn.setTitleColor(.white, for: .normal)\n        doneBtn.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n        doneBtn.setTitle(&quot;完成&quot;, for: .normal)\n        doneBtn.layer.cornerRadius = 22\n        doneBtn.addTarget(self, action: #selector(actionForDone), for: .touchUpInside)\n        scrollView.addSubview(doneBtn)\n    &#125;\n</code></pre>\n<h3 id=\"3-7-填充数据\"><a href=\"#3-7-填充数据\" class=\"headerlink\" title=\"3.7 填充数据\"></a>3.7 填充数据</h3><p>这里先看下日历数据如何使用代理和数据源的：</p>\n<pre><code class=\"line-numbers language-Swift\">extension CalendarView: UICollectionViewDelegate,UICollectionViewDataSource,UICollectionViewDelegateFlowLayout&#123;\n    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123;\n        return modelArr.count\n    &#125;\n    \n    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123;\n        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: CalendarCell.identifier, for: indexPath) as! CalendarCell\n        cell.model = modelArr[indexPath.item]\n        cell.selectedModel = timeModel\n        return cell\n    &#125;\n\n    // 定义每个Cell的大小\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -&gt; CGSize &#123;\n        let width = ScreenWidth/7\n        let height = modelArr.count &gt; 35 ? (ScreenHeight*0.57*0.57)/6 : (ScreenHeight*0.57*0.57)/5\n        return CGSize(width: width-2, height: height-1)\n    &#125;\n    \n    // 定义每个Section的四边间距\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -&gt; UIEdgeInsets &#123;\n        return UIEdgeInsets(top: 0, left: 3.5, bottom: 0, right: 0)\n    &#125;\n    \n    // 这个是两行cell之间的间距（上下行cell的间距）\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -&gt; CGFloat &#123;\n        return 1.0\n    &#125;\n    \n    // 两个cell之间的间距（同一行的cell的间距）\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Int) -&gt; CGFloat &#123;\n        return 1.0\n    &#125;\n    \n    // 选中某个ietm\n    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) &#123;\n        let model = modelArr[indexPath.item]\n        let com = YSDateTool.currentDateCom()\n        if com.year == model.year &amp;&amp; com.month == model.month &amp;&amp; model.day &lt;= com.day! || model.day == 0&#123;\n            return\n        &#125;\n\n        timeModel.year = model.year\n        timeModel.month = model.month\n        timeModel.day = model.day\n        collectionView.reloadData()\n    &#125;\n&#125;\n</code></pre>\n<p>主要逻辑委托给Cell来实现了。后面再看下。</p>\n<h3 id=\"3-8-UIPickerView数据填充\"><a href=\"#3-8-UIPickerView数据填充\" class=\"headerlink\" title=\"3.8 UIPickerView数据填充\"></a>3.8 UIPickerView数据填充</h3><p>然后看下预约时间如何填充数据的。</p>\n<pre><code class=\"line-numbers language-Swift\">extension CalendarView:UIPickerViewDelegate,UIPickerViewDataSource &#123;\n\n    func numberOfComponents(in pickerView: UIPickerView) -&gt; Int &#123;\n        return 1\n    &#125;\n    \n    func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -&gt; Int &#123;\n        return timeArr.count\n    &#125;\n\n    func pickerView(_ pickerView: UIPickerView, widthForComponent component: Int) -&gt; CGFloat &#123;\n        return ScreenWidth\n    &#125;\n    \n    func pickerView(_ pickerView: UIPickerView, rowHeightForComponent component: Int) -&gt; CGFloat &#123;\n        44\n    &#125;\n    \n    func pickerView(_ pickerView: UIPickerView, viewForRow row: Int, forComponent component: Int, reusing view: UIView?) -&gt; UIView &#123;\n        \n        //设置分割线 pickerView的subvews的第二个一般用来做分割线 subviews会有2个view\n        for view in pickerView.subviews &#123;\n            print(&quot;view.height=\\(view.size.height) 长度为：\\(pickerView.subviews.count)&quot;)\n            if view.size.height &lt;= 50 &#123;\n                view.backgroundColor = .clear\n                //自定义分割线\n                let toplayer = CALayer()\n                toplayer.frame = CGRect.init(x: 0, y: 0, width: ScreenWidth, height: 1)\n                toplayer.backgroundColor = UIColor.init(hex: &quot;#EBEDF0&quot;).cgColor\n                view.layer.addSublayer(toplayer)\n\n                let bottomlayer = CALayer()\n                bottomlayer.frame = CGRect.init(x: 0, y: 44-1, width: ScreenWidth, height: 1)\n                bottomlayer.backgroundColor = UIColor.init(hex: &quot;#EBEDF0&quot;).cgColor\n                view.layer.addSublayer(bottomlayer)\n               \n            &#125;else&#123;\n                view.backgroundColor = .clear\n            &#125;\n        &#125;\n        \n        //设置内容样式\n        var label = view as? UILabel\n        if label == nil &#123;\n            label = UILabel.init()\n            label?.backgroundColor = .clear\n            label?.frame = CGRect.init(x: 0, y: 0, width:ScreenWidth, height:44)\n        &#125;\n        if row == selectIndex &#123;\n            label?.textColor = UIColor.init(hex: &quot;#409EFF&quot;)\n        &#125;else&#123;\n            label?.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n        &#125;\n        label?.textAlignment = .center\n        label?.font = .pingFangRegular(size: 16)\n        //label?.minimumScaleFactor = 0.5\n        //label?.adjustsFontSizeToFitWidth = true\n        label?.text = timeArr[row]\n        return label!\n    &#125;\n    \n    func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) &#123;\n        selectIndex = row\n        pickerView.reloadAllComponents()\n    &#125;\n&#125;\n</code></pre>\n<p>主要逻辑是viewForRow覆写的方法里面。<br>交代了如何绘制分割线和选中高亮显示。<br>这里有个点要注意，这个分割线用到了 UIPickerView的subViews，这里通常设置分割线都要用到这个东西，具体细节我不是很清楚，预测这个subViews第二个就是居中的item。第一个item很长，不能用来分割线。</p>\n<p>然后就是didSelectRow用来响应用户点击事件，需要刷新下components。</p>\n<h3 id=\"3-9-交互事件\"><a href=\"#3-9-交互事件\" class=\"headerlink\" title=\"3.9 交互事件\"></a>3.9 交互事件</h3><p>这里交互事件统一用一个扩展类来实现。</p>\n<pre><code class=\"line-numbers language-Swift\">extension CalendarView &#123;\n    \n    @objc func actionForChooseDate()&#123;\n        self.lineViewLayout()\n        self.scrollDate()\n    &#125;\n    \n    @objc func actionForChooseTime()&#123;\n        self.lineViewLayout(leading: 1)\n        self.scrollTime()\n    &#125;\n    \n    @objc func actionForCancel()&#123;\n        self.dismissAlertView()\n    &#125;\n    \n    @objc func actionForLeftEvent()&#123;\n        dynamicDate = YSDateTool.lastMonth(date: dynamicDate)\n        self.isRefrenshMonth()\n    &#125;\n    \n    @objc func actionForRightEvent()&#123;\n        dynamicDate = YSDateTool.nextMonth(date: dynamicDate)\n        self.isRefrenshMonth()\n    &#125;\n    \n    @objc func actionForNext()&#123;\n        self.lineViewLayout(leading: 1)\n        self.scrollTime()\n    &#125;\n    \n    @objc func actionForDone()&#123;\n        if doneHandle != nil &#123;\n            let str = timeArr[selectIndex]\n            let arr = str.components(separatedBy: CalendarView.range)\n            timeModel.startTime = arr[0]\n            timeModel.endTime = arr[1]\n            \n            let monthStr = timeModel.month &lt; 10 ? &quot;0\\(timeModel.month)&quot; : &quot;\\(timeModel.month)&quot;\n            let dayStr = timeModel.day &lt; 10 ? &quot;0\\(timeModel.day)&quot; : &quot;\\(timeModel.day)&quot;\n            timeModel.dateStr = &quot;\\(timeModel.year)-\\(monthStr)-\\(dayStr)&quot;\n            \n            doneHandle(timeModel)\n        &#125;\n        self.dismissAlertView()\n    &#125;\n    \n    // 滑动到日期\n    func scrollDate()&#123;\n        dateBtn.isSelected = true\n        timeBtn.isSelected = false\n        scrollView.setContentOffset(CGPoint.init(x: 0, y: 0), animated: true)\n    &#125;\n    \n    // 滑动到时间\n    func scrollTime()&#123;\n        dateBtn.isSelected = false\n        timeBtn.isSelected = true\n        scrollView.setContentOffset(CGPoint.init(x: ScreenWidth, y: 0), animated: true)\n    &#125;\n    \n    func isRefrenshMonth()&#123;\n        self.setDate(date: dynamicDate)\n        let com = YSDateTool.currentDateCom(date: dynamicDate)\n        monthLb.text = &quot;\\(com.year!)年\\(com.month!)月&quot;\n        watermarkView.monthStr = &quot;\\(com.month!)&quot;\n        \n        let currentCom = YSDateTool.currentDateCom()\n        if (com.year! == currentCom.year!  &amp;&amp; com.month! &gt; currentCom.month!) || (com.year! &gt; currentCom.year!)&#123;\n            toolLeftBtn.isHidden = false\n        &#125;else&#123;\n            toolLeftBtn.isHidden = true\n        &#125;\n    &#125;\n    \n    func lineViewLayout(leading: Int = 0)&#123;\n        lineView.snp.remakeConstraints&#123;make in\n            make.top.equalTo(0)\n            if leading == 0 &#123;\n                make.leading.equalTo(leading)\n            &#125;else&#123;\n                make.centerX.equalToSuperview() // 居中了\n            &#125;\n            make.width.equalTo(66+56) // 宽度\n            make.height.equalTo(2)  // 高度\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"4-撸下时间工具\"><a href=\"#4-撸下时间工具\" class=\"headerlink\" title=\"4 撸下时间工具\"></a>4 撸下时间工具</h2><p>这个只是个单纯工具，不必重复造轮子。</p>\n<pre><code class=\"line-numbers language-Swift\">class YSDateTool &#123;\n    // MARK: - 当前时间组件\n    static func currentDateCom(date: Date = Date()) -&gt; DateComponents&#123;\n        let calendar = Calendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com\n    &#125;\n    // MARK: - 今年\n    static func currentYear(date: Date = Date()) -&gt; Int &#123;\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com.year!\n    &#125;\n  \n    // MARK: - 今月\n    static func currentMonth(date: Date = Date()) -&gt; Int &#123;\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com.month!\n    &#125;\n  \n    // MARK: - 今日\n    static func currentDay(date: Date = Date()) -&gt; Int &#123;\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com.day!\n    &#125;\n    \n    // MARK: - 今天星期几\n    static func currentWeekDay(date: Date = Date()) -&gt; Int &#123;\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.weekday], from: date)\n        return com.weekday!\n    &#125;\n    \n    // MARK: - 农历今年\n    static func currentChineseYear(date: Date = Date()) -&gt; String &#123;\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.year], from: date)\n        return numberToChina(yearNum: (com?.year)!) + &quot;年&quot;\n    &#125;\n    \n    // MARK: - 农历今月\n    static func currentChineseMonth(date: Date = Date()) -&gt; String &#123;\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.month], from: date)\n        return numberToChina(monthNum: (com?.month)!)\n    &#125;\n\n    // MARK: - 农历今日\n    static func currentChineseDay(date: Date = Date()) -&gt; String &#123;\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.day], from: date)\n        return numberToChina(dayNum: (com?.day)!)\n    &#125;\n    \n    // MARK: - 农历今日\n    static func currentChineseDayInt(date: Date = Date()) -&gt; Int &#123;\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.day], from: date)\n        return (com?.day)!\n    &#125;\n    \n    // MARK: - 农历星期\n    static func currentChineseWeekYear(date: Date = Date()) -&gt; String &#123;\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.weekday], from: date)\n        return numberToChina(weekNum: (com?.weekday)!)\n    &#125;\n  \n    // MARK: - 下个月\n    static func nextMonth(date: Date = Date()) -&gt; Date &#123;\n        let calendar = NSCalendar.current\n        let nDate = calendar.date(byAdding: DateComponents(month: 1), to: date)\n        return nDate!\n    &#125;\n    \n    // MARK: - 上个月\n    static func lastMonth(date: Date = Date()) -&gt; Date &#123;\n        let calendar = NSCalendar.current\n        let lDate = calendar.date(byAdding: DateComponents(month: -1), to: date)\n        return lDate!\n    &#125;\n    \n    // MARK: - 下一天\n    static func lastDay(date: Date = Date()) -&gt; Date&#123;\n        let calendar = NSCalendar.current\n        let lDate = calendar.date(byAdding: DateComponents(day: 1), to: date)\n        return lDate!\n    &#125;\n  \n    // MARK: - 本月天数\n    static func countOfDaysInCurrentMonth(date: Date = Date()) -&gt; Int &#123;\n        let calendar = Calendar(identifier: Calendar.Identifier.gregorian)\n        let range = (calendar as NSCalendar?)?.range(of: NSCalendar.Unit.day, in: NSCalendar.Unit.month, for: date)\n        return (range?.length)!\n    &#125;\n \n    // MARK: - 当月第一天是星期几\n    static func firstWeekDayInCurrentMonth(date: Date = Date()) -&gt; Int &#123;\n        // 星期和数字一一对应 星期日：7\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = &quot;yyyy-MM&quot;\n        let date = dateFormatter.date(from: String(date.xj.year)+&quot;-&quot;+String(date.xj.month))\n        let calender = Calendar(identifier: Calendar.Identifier.gregorian)\n        let comps = (calender as NSCalendar?)?.components(NSCalendar.Unit.weekday, from: date!)\n        var week = comps?.weekday\n        if week == 1 &#123;\n            week = 8\n        &#125;\n        return week! - 1\n    &#125;\n\n    // MARK: - - 获取指定日期各种值\n    // 根据年月得到某月天数\n    static func getCountOfDaysInMonth(year: Int, month: Int) -&gt; Int&#123;\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = &quot;yyyy-MM&quot;\n        let date = dateFormatter.date(from: String(year)+&quot;-&quot;+String(month))\n        let calendar = Calendar(identifier: Calendar.Identifier.gregorian)\n        let range = (calendar as NSCalendar?)?.range(of: NSCalendar.Unit.day, in: NSCalendar.Unit.month, for: date!)\n        return (range?.length)!\n    &#125;\n    \n    // MARK: - 根据年月得到某月第一天是周几\n    static func getfirstWeekDayInMonth(year: Int, month: Int) -&gt; Int&#123;\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = &quot;yyyy-MM&quot;\n        let date = dateFormatter.date(from: String(year)+&quot;-&quot;+String(month))\n        let calendar = Calendar(identifier: Calendar.Identifier.gregorian)\n        let comps = (calendar as NSCalendar?)?.components(NSCalendar.Unit.weekday, from: date!)\n        let week = comps?.weekday\n        return week! - 1\n    &#125;\n\n    // MARK: - date转日期字符串\n    static func dateToDateString(_ date: Date, dateFormat: String) -&gt; String &#123;\n        let timeZone = NSTimeZone.default\n        let formatter = DateFormatter()\n        formatter.timeZone = timeZone\n        formatter.dateFormat = dateFormat\n        let date = formatter.string(from: date)\n        return date\n    &#125;\n\n    // MARK: - 日期字符串转date\n    static func dateStringToDate(_ dateStr: String) -&gt; Date &#123;\n        let dateFormatter = DateFormatter()\n        dateFormatter.timeZone = TimeZone(abbreviation: &quot;UTC+8&quot;)\n        dateFormatter.dateFormat = &quot;yyyy-MM-dd&quot;\n        let date = dateFormatter.date(from: dateStr)\n        return date!\n    &#125;\n    \n    // MARK: - 时间字符串转date\n    static func timeStringToDate(_ dateStr: String) -&gt; Date &#123;\n        let dateFormatter = DateFormatter()\n        dateFormatter.timeZone = TimeZone(abbreviation: &quot;UTC+8&quot;)\n        dateFormatter.dateFormat = &quot;yyyy-MM-dd HH:mm:ss&quot;\n        let date = dateFormatter.date(from: dateStr)\n        return date!\n    &#125;\n\n    // MARK: - 计算天数差\n    static func dateDifference(_ dateA: Date, from dateB: Date) -&gt; Double &#123;\n        let interval = dateA.timeIntervalSince(dateB)\n        return interval/86400\n    &#125;\n\n    // MARK: - 比较时间先后\n    static func compareOneDay(oneDay: Date, withAnotherDay anotherDay: Date) -&gt; Int &#123;\n        let dateFormatter: DateFormatter = DateFormatter()\n        dateFormatter.dateFormat = &quot;yyyy-MM-dd&quot;\n        let oneDayStr: String = dateFormatter.string(from: oneDay)\n        let anotherDayStr: String = dateFormatter.string(from: anotherDay)\n        let dateA = dateFormatter.date(from: oneDayStr)\n        let dateB = dateFormatter.date(from: anotherDayStr)\n        let result: ComparisonResult = (dateA?.compare(dateB!))!\n        // Date1 is in the future\n        if(result == ComparisonResult.orderedDescending ) &#123;\n            return 1\n        &#125;\n        // Date1 is in the past\n        else if(result == ComparisonResult.orderedAscending) &#123;\n            return 2\n        &#125;\n            // Both dates are the same\n        else &#123;\n            return 0\n        &#125;\n    &#125;\n\n    // MARK: - 时间与时间戳之间的转化\n    // 将时间转换为时间戳\n    static func stringToTimeStamp(_ stringTime: String) -&gt; Int &#123;\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat = &quot;yyyy-MM-dd HH: mm: ss&quot;\n        dfmatter.locale = Locale.current\n        let date = dfmatter.date(from: stringTime)\n        let dateStamp: TimeInterval = date!.timeIntervalSince1970\n        let dateSt: Int = Int(dateStamp)\n        return dateSt\n    &#125;\n    \n    // 将时间戳转换为年月日\n    static func timeStampToString(_ timeStamp: String) -&gt; String &#123;\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=&quot;yyyy年MM月dd日&quot;\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    &#125;\n    \n    // 将时间戳转换为具体时间\n    static func timeStampToStringDetail(_ timeStamp: String) -&gt; String &#123;\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=&quot;yyyy年MM月dd日HH: mm: ss&quot;\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    &#125;\n    \n    // 将时间戳转换为时分秒\n    static func timeStampToHHMMSS(_ timeStamp: String) -&gt; String &#123;\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=&quot;HH: mm: ss&quot;\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    &#125;\n    \n    // 将时间戳转换为时分\n    static func timeStampToHHMM(_ timeStamp: String) -&gt; String &#123;\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=&quot;HH: mm&quot;\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    &#125;\n    \n    // 获取系统的当前时间戳\n    static func getStamp(date: Date = Date()) -&gt; Int&#123;\n        // 获取当前时间戳\n        let timeInterval: Int = Int(date.timeIntervalSince1970)\n        return timeInterval\n    &#125;\n    \n    // 日数字转汉字\n    static func numberToChina(yearNum: Int) -&gt; String &#123;\n        // 以一个天干和一个地支相配，排列起来，天干在前，地支在后，天干由甲起，地支由子起，阳干对阳支，阴干对阴支（阳干不配阴支，阴干不配阳支）\n        // 就会得到六十年一周期的甲子回圈，一般称为“六十甲子”或“花甲子”\n        // 十天干： 甲（jiǎ）、乙（yǐ）、丙（bǐng）、丁（dīng）、戊（wù）、己（jǐ）、庚（gēng）、辛（xīn）、壬（rén）、癸（guǐ）\n        // 十二地支： 子（zǐ）、丑（chǒu）、寅（yín）、卯（mǎo）、辰（chén）、巳（sì）、午（wǔ）、未（wèi）、申（shēn）、酉（yǒu）、戌（xū）、亥（hài）\n        let ChinaArray = [ &quot;甲子&quot;, &quot;乙丑&quot;, &quot;丙寅&quot;, &quot;丁卯&quot;, &quot;戊辰&quot;, &quot;己巳&quot;, &quot;庚午&quot;, &quot;辛未&quot;, &quot;壬申&quot;, &quot;癸酉&quot;,\n                         &quot;甲戌&quot;, &quot;乙亥&quot;, &quot;丙子&quot;, &quot;丁丑&quot;, &quot;戊寅&quot;, &quot;己卯&quot;, &quot;庚辰&quot;, &quot;辛己&quot;, &quot;壬午&quot;, &quot;癸未&quot;,\n                         &quot;甲申&quot;, &quot;乙酉&quot;, &quot;丙戌&quot;, &quot;丁亥&quot;, &quot;戊子&quot;, &quot;己丑&quot;, &quot;庚寅&quot;, &quot;辛卯&quot;, &quot;壬辰&quot;, &quot;癸巳&quot;,\n                         &quot;甲午&quot;, &quot;乙未&quot;, &quot;丙申&quot;, &quot;丁酉&quot;, &quot;戊戌&quot;, &quot;己亥&quot;, &quot;庚子&quot;, &quot;辛丑&quot;, &quot;壬寅&quot;, &quot;癸丑&quot;,\n                         &quot;甲辰&quot;, &quot;乙巳&quot;, &quot;丙午&quot;, &quot;丁未&quot;, &quot;戊申&quot;, &quot;己酉&quot;, &quot;庚戌&quot;, &quot;辛亥&quot;, &quot;壬子&quot;, &quot;癸丑&quot;,\n                         &quot;甲寅&quot;, &quot;乙卯&quot;, &quot;丙辰&quot;, &quot;丁巳&quot;, &quot;戊午&quot;, &quot;己未&quot;, &quot;庚申&quot;, &quot;辛酉&quot;, &quot;壬戌&quot;, &quot;癸亥&quot;]\n        let ChinaStr: String = ChinaArray[yearNum - 1]\n        return ChinaStr\n    &#125;\n    \n    // 月份数字转汉字\n    static func numberToChina(monthNum: Int) -&gt; String &#123;\n        let ChinaArray = [&quot;一月&quot;, &quot;二月&quot;, &quot;三月&quot;, &quot;四月&quot;, &quot;五月&quot;, &quot;六月&quot;, &quot;七月&quot;, &quot;八月&quot;, &quot;九月&quot;, &quot;十月&quot;, &quot;十一月&quot;, &quot;十二月&quot;]\n        let ChinaStr: String = ChinaArray[monthNum - 1]\n        return ChinaStr\n    &#125;\n    \n    // 日数字转汉字\n    static func numberToChina(dayNum: Int) -&gt; String &#123;\n        let ChinaArray = [ &quot;初一&quot;, &quot;初二&quot;, &quot;初三&quot;, &quot;初四&quot;, &quot;初五&quot;, &quot;初六&quot;, &quot;初七&quot;, &quot;初八&quot;, &quot;初九&quot;, &quot;初十&quot;,\n                         &quot;十一&quot;, &quot;十二&quot;, &quot;十三&quot;, &quot;十四&quot;, &quot;十五&quot;, &quot;十六&quot;, &quot;十七&quot;, &quot;十八&quot;, &quot;十九&quot;, &quot;二十&quot;,\n                         &quot;廿一&quot;, &quot;廿二&quot;, &quot;廿三&quot;, &quot;廿四&quot;, &quot;廿五&quot;, &quot;廿六&quot;, &quot;廿七&quot;, &quot;廿八&quot;, &quot;廿九&quot;, &quot;三十&quot;]\n        let ChinaStr: String = ChinaArray[dayNum - 1]\n        return ChinaStr\n    &#125;\n      \n    // 星期数字转汉字\n    static func numberToChina(weekNum: Int) -&gt; String &#123;\n        let ChinaArray = [&quot;一月&quot;, &quot;二月&quot;, &quot;三月&quot;, &quot;四月&quot;, &quot;五月&quot;, &quot;六月&quot;, &quot;七月&quot;, &quot;八月&quot;, &quot;九月&quot;, &quot;十月&quot;, &quot;十一月&quot;, &quot;十二月&quot;]\n        let ChinaStr: String = ChinaArray[weekNum - 1]\n        return ChinaStr\n    &#125;\n    \n    // MARK: - 数字前补0\n    static func add0BeforeNumber(_ number: Int) -&gt; String &#123;\n        if number &gt;= 10 &#123;\n            return String(number)\n        &#125;else&#123;\n            return &quot;0&quot; + String(number)\n        &#125;\n    &#125;\n    \n    static func getCurrentSystemDate() -&gt; Date&#123;\n        let date = Date() // 获得时间对象\n        let zone = NSTimeZone.system // 获得系统的时区\n        let time = zone.secondsFromGMT(for: date)// 以秒为单位返回当前时间与系统格林尼治时间的差\n        return date.addingTimeInterval(TimeInterval(time))// 然后把差的时间加上,就是当前系统准确的时间\n    &#125;\n    \n    static func date(_ date: String?, dateFormat: String = &quot;yyyy-MM-dd&quot;) -&gt; Date? &#123;\n        guard let date = date else &#123;\n            return nil\n        &#125;\n        let dateformatter = DateFormatter()\n        dateformatter.timeZone = TimeZone.init(secondsFromGMT: 0)\n        dateformatter.dateFormat = dateFormat\n        return dateformatter.date(from: date)\n    &#125;\n\n    // MARK: - 将时间显示为（几分钟前，几小时前，几天前）\n    static func compareCurrentTime(str: String) -&gt; String &#123;\n        //let currentDateStr = dateToDateString(Date(), dateFormat: &quot;yyyy-MM-dd hh:mm:ss&quot;)\n        let currentDate = getCurrentSystemDate()\n        let sendTimeDate = date(str,dateFormat: &quot;yyyy-MM-dd HH:mm:ss&quot;)!//self.timeStringToDate(str)\n        let sendTimeInterval = Double(getStamp(date: sendTimeDate))\n        let timeInterval = currentDate.timeIntervalSince(sendTimeDate)\n\n        var todayStr = dateToDateString(Date(), dateFormat: &quot;yyyy-MM-dd&quot;)\n        todayStr = todayStr+&quot; 00:00&quot;\n        let todayTimeInterval = Double(Date().stringToSecondTimeStamp(todayStr)) ?? 0\n        let yestDayTimeInterval = Double(todayTimeInterval - 86400)\n        let nextDayTimeInterval = Double(todayTimeInterval + 86400)\n\n        var temp: Double = 0\n        var result: String = &quot;&quot;\n        if timeInterval/60 &lt; 1 &#123;\n            result = &quot;刚刚&quot;\n        &#125;else if (timeInterval/60) &lt; 60&#123;\n            temp = timeInterval/60\n            result = &quot;\\(Int(temp))分钟前&quot;\n        &#125;else if sendTimeInterval &gt; todayTimeInterval &amp;&amp; sendTimeInterval &lt; nextDayTimeInterval&#123;\n\n            //let interval = nextDayTimeInterval - sendTimeInterval\n            temp = timeInterval/60/60\n            result = &quot;\\(Int(temp))小时前&quot;\n        &#125;else if sendTimeInterval &gt; yestDayTimeInterval &amp;&amp; sendTimeInterval &lt; todayTimeInterval&#123;\n            //let str = timeStampToHHMM(String.init(format: &quot;%d&quot;, sendTimeInterval))\n            let timeStr = str.components(separatedBy: &quot; &quot;).last ?? &quot;&quot;\n            let str = timeStr.prefix(5)\n            result = &quot;昨天\\(str)&quot;\n        &#125;else&#123;\n            let timeStr = str.components(separatedBy: &quot; &quot;).first ?? &quot;&quot;\n            let timeArr = timeStr.components(separatedBy: &quot;-&quot;)\n            if !timeArr.isEmpty &#123;\n                result = &quot;\\(timeArr[0])年\\(timeArr[1])月\\(timeArr[2])日&quot;\n            &#125;\n            //result = timeStampToString(String.init(format: &quot;%d&quot;, sendTimeInterval))\n        &#125;\n        \n//        else if timeInterval/(30 * 24 * 60 * 60) &lt; 12 &#123;\n//            temp = timeInterval/(30 * 24 * 60 * 60)\n//            result = &quot;\\(Int(temp))个月前&quot;\n//        &#125;else&#123;\n//            temp = timeInterval/(12 * 30 * 24 * 60 * 60)\n//            result = &quot;\\(Int(temp))年前&quot;\n//        &#125;\n        return result\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"5-撸下最后的日历Cell\"><a href=\"#5-撸下最后的日历Cell\" class=\"headerlink\" title=\"5 撸下最后的日历Cell\"></a>5 撸下最后的日历Cell</h2><p>这个就是日历里面的item，还是相当简单的。</p>\n<h3 id=\"5-1-全局变量\"><a href=\"#5-1-全局变量\" class=\"headerlink\" title=\"5.1 全局变量\"></a>5.1 全局变量</h3><pre><code class=\"line-numbers language-Swift\">class CalendarCell: UICollectionViewCell &#123;\n    \n    static var identifier = &quot;UICollectionViewCell&quot;\n    \n    var isGreaterThan: Bool = false     //是否取大于今天的值\n    \n    var isShowPassTime: Int = 0         //是否设定禁选\n    \n    var model:TimeModel?&#123;\n        didSet&#123;\n            guard let _model = model else &#123;return&#125;\n            if _model.day != 0 &#123;\n                titleLab.text = &quot;\\(_model.day)&quot;\n            &#125;else&#123;\n                titleLab.text = &quot;&quot; // 为0，啥也不显示\n            &#125;\n            \n            let com = YSDateTool.currentDateCom()\n            \n            // 是否是选中的日子\n            if com.year == _model.year &amp;&amp; com.month == _model.month &amp;&amp; com.day == _model.day &#123;\n                titleLab.textColor = UIColor.init(hex: &quot;#409EFF&quot;)\n            &#125;else&#123;\n                titleLab.textColor = UIColor.init(hex: &quot;#323233&quot;)\n            &#125;\n            \n            // 禁用还是可用\n            if isShowPassTime == 0 &#123;\n                if isGreaterThan &#123;\n                    if (com.year == _model.year &amp;&amp; com.month == _model.month &amp;&amp; _model.day &gt; com.day!) || (_model.year == com.year! &amp;&amp; _model.month &gt; com.month!) || (_model.year &gt; com.year!)&#123;\n                        titleLab.textColor = UIColor.init(hex: &quot;#C8C9CC&quot;)\n                    &#125;\n                &#125;else&#123;\n                    // 如果要大于今天，那么前面的时间就的置灰了 前一个月的点不过去，不考虑了\n                    if com.year == _model.year &amp;&amp; com.month == _model.month &amp;&amp; _model.day &lt; com.day!&#123;\n                        titleLab.textColor = UIColor.init(hex: &quot;#C8C9CC&quot;)\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    \n    // 选中的item，背景颜色高亮\n    var selectedModel: TimeModel?&#123;\n        didSet&#123;\n            guard let _model = selectedModel else&#123;return&#125;\n            if _model.year == model?.year &amp;&amp; _model.month == model?.month &amp;&amp; _model.day == model?.day&#123;\n                titleLab.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n                titleLab.textColor = UIColor.white\n            &#125;else&#123;\n                titleLab.backgroundColor = UIColor.clear\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>比较重要的是model，表示当前时间实体类。这里监听变量改变，利用didSet实现动态改变文案效果。</p>\n<p>另外一个是selectedModel，这个是当前选中的item，会比对item是否为选中，选中样式会有所不同。</p>\n<h3 id=\"5-2-UI子View\"><a href=\"#5-2-UI子View\" class=\"headerlink\" title=\"5.2 UI子View\"></a>5.2 UI子View</h3><p>这里只用到一个子View。</p>\n<pre><code class=\"line-numbers language-Swift\">var titleLab: UILabel = &#123;\n        let lan = UILabel()\n        lan.font = .pingFangRegular(size: 16)\n        lan.textAlignment = .center\n        lan.textColor = UIColor.init(hex: &quot;#323233&quot;)\n        \n        lan.layer.cornerRadius = 4\n        lan.layer.masksToBounds = true\n        return lan\n    &#125;()\n</code></pre>\n<h3 id=\"5-3-生命周期函数\"><a href=\"#5-3-生命周期函数\" class=\"headerlink\" title=\"5.3 生命周期函数\"></a>5.3 生命周期函数</h3><pre><code class=\"line-numbers language-Swift\">override init(frame: CGRect) &#123;\n        super.init(frame: frame)\n        contentView.backgroundColor = .clear\n        contentView.addSubview(titleLab)\n        titleLab.snp.makeConstraints&#123;make in\n            make.top.bottom.leading.trailing.equalToSuperview()\n        &#125;\n    &#125;\n    \n    required init?(coder aDecoder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n</code></pre>\n<p>把那个子View添加到Cell里面去了。</p>\n<p>大概就是这样子。</p>\n<h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6 总结\"></a>6 总结</h2><ul>\n<li><p>如果UI图有那种Tab页，就可以考虑使用多种方案来实现，iOS直接用简单的Button也是可以实现的，分割线也是可以用最简单的UIView来实现，不一定要用封装好的框架，谁用挖掘机来搬小石头呢，大材小用了。</p>\n</li>\n<li><p>分页效果可以使用UIScrollView来实现，把它宽度设置为屏幕的n倍，这样最有滑动可以很好控制的，不要动画也可以设置的，办法总是就很多的。</p>\n</li>\n<li><p>日历效果可以用UICollectionView来实现，看着很复杂，其实很简单，主要逻辑也不复杂，控制好数据刷新就好了。UICollectionView可以实现类似网格的效果，我们只需要在Cell里面绘制一个一个Cell，空的部分，我们啥不展示就好了。</p>\n</li>\n<li><p>系统的UIPickerView设置分割线很简单，利用UIPickerView下有一个subViews，这里寻找高度为item高度大小的，然后给view设置一个Layer即可。</p>\n</li>\n</ul>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-需求分析\"><a href=\"#1-需求分析\" class=\"headerlink\" title=\"1 需求分析\"></a>1 需求分析</h2><p>当我们选择购买一个东西时，有时需要预约发货，这时候需要用户手动选择某一天某一个时间，ui给的方案是这样的：<br>预约日期：<br><img src=%E9%A2%84%E7%BA%A6%E6%97%A5%E6%9C%9F.png></p>\n<p>预约时间：<br><img src=%E9%A2%84%E7%BA%A6%E6%97%B6%E9%97%B4.png><br>这里是间隔了2个小时一个时间。</p>\n<p>可以看到这个日期是以日历形式展现，可以选择未来某个日期；时间是以滚轮的方式展现，可以上下滑动到目标时间点。</p>\n<p>对于这个需求，我们要如何实现呢？‘</p>\n<p>答案当然是自定义View了。</p>\n<h2 id=\"2-结构分析\"><a href=\"#2-结构分析\" class=\"headerlink\" title=\"2 结构分析\"></a>2 结构分析</h2><p>显而易见，这个因为设计到分页，我们可以考虑分页区域使用一个UIScrollView，水平滑动，宽度设置为屏幕的2倍，一半用来展示日历，一半用来展示预约时间的UIPickerView。</p>\n<p>所以需要我们自定义一个UIView，这里面先绘制顶部分割线，再绘制标题，“预约日期”和“预约时间”和“取消”的文案。</p>\n<p>然后是一个显示日历操作栏，包括左右箭头和中间的月份显示，这个要放到UIScrollView的左半边，包括星期视图和日历的UICollectionView的集合View，这里日历我们采用这个集合View很容易实现的。</p>\n<p>然后右侧就是一个UIPickerView,这个系统封装好了，使用很方便，我们主要负责填充数据。</p>\n<p>那这个结构大体出来了，一个是整个自定义View，暂且把它叫做CalenderView，还有一个就是日历内部的Cell，暂且叫做CalenderCell。</p>\n<h2 id=\"3-撸下CalenderView\"><a href=\"#3-撸下CalenderView\" class=\"headerlink\" title=\"3 撸下CalenderView\"></a>3 撸下CalenderView</h2><h3 id=\"3-1-全局变量\"><a href=\"#3-1-全局变量\" class=\"headerlink\" title=\"3.1 全局变量\"></a>3.1 全局变量</h3><pre><code class=\"line-numbers language-Swift\">class CalendarView: UIView &#123;\n    \n    /// 传出去给调用者\n    typealias DoneBlock = (TimeModel)-&gt;()\n    var doneHandle: DoneBlock!\n    \n    // 当月日期Model\n    var modelArr: [TimeModel] = []\n    \n    // 动态调整上下月的时间变量\n    var dynamicDate = Date()\n    \n    //默认选中的日期\n    var timeModel: TimeModel = TimeModel()\n    \n    //时间时短数据\n    static let range: String = &quot;                      &quot;\n    private var timeArr: [String] = [&quot;08:00\\(range)10:00&quot;,\n                                   &quot;10:00\\(range)12:00&quot;,\n                                   &quot;12:00\\(range)14:00&quot;,\n                                   &quot;14:00\\(range)16:00&quot;,\n                                   &quot;16:00\\(range)18:00&quot;,\n                                   &quot;18:00\\(range)20:00&quot;,\n                                   &quot;20:00\\(range)22:00&quot;]\n    private var selectIndex = 0\n    \n</code></pre>\n<p>这里定义了一个闭包返回，主要是用户选择后，回调给外部。</p>\n<p>然后有一个TimeModel的数组， 也就是填充我们的日历视图。</p>\n<p>timeModel是我们选择的日期，会高亮显示。</p>\n<p>timeArr是我们右侧使用的UIPickerView要用的数据。</p>\n<h3 id=\"3-2-UI定义\"><a href=\"#3-2-UI定义\" class=\"headerlink\" title=\"3.2 UI定义\"></a>3.2 UI定义</h3><p>这里我们大致会用到这些视图。</p>\n<pre><code class=\"line-numbers language-Swift\">//白色背景底 整个半屏的视图\nprivate lazy var acView: UIView = &#123;\n    let view = UIView()\n    view.backgroundColor = .white\n    return view\n&#125;()\n\n//选中条\nprivate lazy var lineView: UIView = &#123;\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n    return view\n&#125;()\n\n/// 预约日期按钮\nprivate lazy var dateBtn: UIButton = &#123;\n    let btn = UIButton()\n    btn.setTitle(&quot;预约日期&quot;, for: .normal)\n    btn.titleFont = .pingFangMedium(size: 16)\n    btn.setTitleColor(UIColor.lightGray, for: .normal)\n    btn.setTitleColor(UIColor.black, for: .selected)\n    btn.addTarget(self, action: #selector(actionForChooseDate), for: .touchUpInside)\n    btn.isSelected = true\n    return btn\n&#125;()\n\n/// 预约时间按钮\nprivate lazy var timeBtn: UIButton = &#123;\n    let btn = UIButton()\n    btn.setTitle(&quot;预约时间&quot;, for: .normal)\n    btn.titleFont = .pingFangMedium(size: 16)\n    btn.setTitleColor(UIColor.lightGray, for: .normal)\n    btn.setTitleColor(UIColor.black, for: .selected)\n    btn.addTarget(self, action: #selector(actionForChooseTime), for: .touchUpInside)\n    return btn\n&#125;()\n\n/// 取消按钮\nprivate lazy var cancelBtn: UIButton = &#123;\n    let btn = UIButton()\n    btn.setTitle(&quot;取消&quot;, for: .normal)\n    btn.setTitleColor(UIColor.init(hex: &quot;#409EFF&quot;), for: .normal)\n    btn.titleFont = .pingFangRegular(size: 16)\n    btn.addTarget(self, action: #selector(actionForCancel), for: .touchUpInside)\n    return btn\n&#125;()\n\n//日历工具条\nprivate lazy var dateToolView: UIView = &#123;\n    let view = UIView()\n    return view\n&#125;()\n\n//日历工具条显示当前月份标签\nprivate lazy var monthLb: UILabel = &#123;\n    let lab = UILabel()\n    lab.font = .pingFangMedium(size: 16)\n    lab.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n    lab.text = &quot;&quot;\n    lab.textAlignment = .center\n    return lab\n&#125;()\n\n//日历工具条左箭头\nprivate lazy var toolLeftBtn: UIButton = &#123;\n    let btn = UIButton()\n    btn.setImage(UIImage.init(named: &quot;日历_左箭头&quot;), for: .normal)\n    btn.addTarget(self, action: #selector(actionForLeftEvent), for: .touchUpInside)\n    btn.isHidden = true\n    return btn\n&#125;()\n\n//日历工具条右箭头\nprivate lazy var toolRightBtn: UIButton =  &#123;\n    let btn = UIButton()\n    btn.setImage(UIImage.init(named: &quot;日历_右箭头&quot;), for: .normal)\n    btn.addTarget(self, action: #selector(actionForRightEvent), for: .touchUpInside)\n    return btn\n&#125;()\n\n//星期X显示条\nprivate lazy var weeksView: UIView = &#123;\n    let view = UIView()\n    view.backgroundColor = .white\n    view.layer.shadowColor = UIColor.init(hex: &quot;#7D7E80&quot;).cgColor\n    view.layer.shadowOffset = CGSize.init(width: 0, height: 2)\n    view.layer.shadowRadius = 10\n    view.layer.shadowOpacity = 0.16\n    return view\n&#125;()\n\n//滚动视图 左右滚动\nprivate lazy var scrollView: UIScrollView = &#123;\n    let _scrollView = UIScrollView()\n    _scrollView.contentSize = CGSize.init(width: ScreenWidth*2, height: _scrollView.size.height)\n    _scrollView.bounces = false\n    _scrollView.isScrollEnabled = true\n    _scrollView.isPagingEnabled = true\n    _scrollView.showsVerticalScrollIndicator = false\n    _scrollView.showsHorizontalScrollIndicator = false\n    return _scrollView\n&#125;()\n\n//月份水印背景\nprivate lazy var watermarkView: CalendarWatermark = &#123;\n    let view = CalendarWatermark()\n    view.backgroundColor = .white\n    view.isHidden = true  //当前版本隐藏水印\n    return view\n&#125;()\n\n//日历展示表\n    private lazy var collectionView: UICollectionView = &#123;\n        let layout = UICollectionViewFlowLayout()\n        layout.scrollDirection = .vertical\n        let collection = UICollectionView(frame: CGRect.init(x: 0, y: 34+40, width: ScreenWidth, height: ScreenHeight*0.57*0.57), collectionViewLayout: layout)\n        collection.backgroundColor = .clear\n        collection.delegate = self\n        collection.dataSource = self\n        collection.isPagingEnabled = true\n        collection.showsHorizontalScrollIndicator = false\n        collection.bounces = false\n        collection.register(CalendarCell.self, forCellWithReuseIdentifier: CalendarCell.identifier)\n        return collection\n&#125;()\n\n//时间选择器 x轴以 屏幕宽度为起点，刚好在第二屏了\nprivate lazy var pickerView: UIPickerView = &#123;\n    let picker = UIPickerView.init(frame: CGRect.init(x: ScreenWidth, y: 0, width: ScreenWidth, height: ScreenHeight*0.57*0.57+34+40))\n    picker.delegate = self\n    picker.dataSource = self\n    return picker\n&#125;()\n</code></pre>\n<p>这些需要用代理和数据源的都设置self，后面再具体实现。</p>\n<p>这里可以认为是我们搭建房子用到的一些素材。先写好，后期再拼接下。</p>\n<h3 id=\"3-3-生命周期函数\"><a href=\"#3-3-生命周期函数\" class=\"headerlink\" title=\"3.3 生命周期函数\"></a>3.3 生命周期函数</h3><p>初始化看下，应该要先设置一个蒙层。</p>\n<pre><code class=\"line-numbers language-Swift\">override init(frame: CGRect)&#123;\n        super.init(frame: frame)\n        /// 这里应该是蒙层\n        self.backgroundColor = UIColor.init(r: 100, g: 1, b: 1, a: 0.3)\n        self.alpha = 0\n        \n        let lastDyaDate = YSDateTool.lastDay()\n        let com = YSDateTool.currentDateCom(date: lastDyaDate)\n        watermarkView.monthStr = &quot;\\(com.month!)&quot;\n    &#125;\n    \n    required init?(coder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n</code></pre>\n<p>确实如此，这里就只加了个颜色。</p>\n<h3 id=\"3-4-定义方法，展示和隐藏选择器\"><a href=\"#3-4-定义方法，展示和隐藏选择器\" class=\"headerlink\" title=\"3.4 定义方法，展示和隐藏选择器\"></a>3.4 定义方法，展示和隐藏选择器</h3><pre><code class=\"line-numbers language-Swift\">extension CalendarView&#123;\n    /// 显示弹窗\n    public func showAlertView() &#123;\n        let str = &quot;\\(timeModel.startTime)\\(CalendarView.range)\\(timeModel.endTime)&quot;\n        selectIndex = timeArr.firstIndex(of:str) ?? 0\n        let timeStr = &quot;\\(timeModel.year)-\\(timeModel.month)-\\(timeModel.day)&quot;\n        let date = YSDateTool.dateStringToDate(timeStr)\n        self.setDate(date: date)\n        self.setUI()\n        pickerView.selectRow(selectIndex, inComponent: 0, animated: false)\n        UIView.animate(withDuration: 0.25) &#123;\n            self.alpha = 1\n        &#125;\n    &#125;\n\n    /// 隐藏弹窗\n    public func dismissAlertView() &#123;\n        self.animate(duration: 0.25) &#123;\n            self.alpha = 0\n        &#125; completion: &#123; finish in\n            self.removeFromSuperview()\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这个方法很重要，主要提供给外部使用，这里帮助外部设置数据，因为外部调用者可能不知道内部细节，所以我们最好在这个类里面实现展示弹框的方法。</p>\n<h3 id=\"3-5-设置初始化日期\"><a href=\"#3-5-设置初始化日期\" class=\"headerlink\" title=\"3.5 设置初始化日期\"></a>3.5 设置初始化日期</h3><p>外部可能有选择好的日期，所以我们必须提供一个方法，设置数据。</p>\n<pre><code class=\"line-numbers language-Swift\">extension CalendarView&#123;\n    /// 按照这个date获取这个月的数据\n    func setDate(date: Date = Date())&#123;\n        modelArr.removeAll()\n        let count = YSDateTool.countOfDaysInCurrentMonth(date: date)    //当月天数\n        for i in 0..&lt;count&#123;\n            let model = self.initializeModel(date: date, day: i+1)\n            modelArr.append(model)\n        &#125;\n        let firstWeekDay = YSDateTool.firstWeekDayInCurrentMonth(date: date)    //当月第一天周几\n        \n        //头部空缺数据填充 插入一个空的model\n        if firstWeekDay != 7 &#123;\n            for _ in 0 ..&lt; firstWeekDay&#123;\n                let model = self.initializeModel(date: date, day: 0)\n                modelArr.insert(model, at: 0)\n            &#125;\n        &#125;\n        //尾部空缺数据填充,插入一个空的model\n        if modelArr.count &lt; 35&#123;\n            for _ in modelArr.count ..&lt; 35&#123;\n                let model = self.initializeModel(date: date, day: 0)\n                modelArr.append(model)\n            &#125;\n        &#125;\n        \n        collectionView.reloadData()\n    &#125;\n    \n    /// 初始化数据，返回\n    func initializeModel(date: Date, day: Int)-&gt;TimeModel&#123;\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        let model = TimeModel()\n        model.year = com.year!\n        model.month = com.month!\n        model.day = day\n        \n        // model指代当前时间\n        let monthStr = com.month! &lt; 10 ? &quot;0\\(model.month)&quot; : &quot;\\(model.month)&quot;\n        let dayStr = com.day! &lt; 10 ? &quot;0\\(model.day)&quot; : &quot;\\(model.day)&quot;\n        model.dateStr = &quot;\\(com.year!)-\\(monthStr)-\\(dayStr)&quot;\n        return model\n    &#125;\n&#125;\n</code></pre>\n<p>这里也搞了2个扩展函数，会根据目标日期，获取到该日期的一个月的数据，然后会填充第一天非星期天的情况的数据，也会填最后几天空白区域的数据。</p>\n<h3 id=\"3-6-设置UI\"><a href=\"#3-6-设置UI\" class=\"headerlink\" title=\"3.6 设置UI\"></a>3.6 设置UI</h3><p>有了日期就可以设置UI了，所以我们看下如何填充视图的。</p>\n<pre><code class=\"line-numbers language-Swift\">extension CalendarView &#123;\n    func setUI() &#123;\n        \n        //日历顶部按钮布局\n        self.addSubview(acView)\n        acView.snp.makeConstraints&#123;make in\n            make.leading.trailing.bottom.equalTo(0)\n            make.height.equalTo(ScreenHeight*0.57)\n        &#125;\n        \n        // 加顶部横线 左上角默认位置\n        acView.addSubview(lineView)\n        self.lineViewLayout()\n        \n        // 加预约日期\n        acView.addSubview(dateBtn)\n        dateBtn.snp.makeConstraints&#123;make in\n            make.top.equalTo(11)\n            make.leading.equalTo(28)\n            make.width.equalTo(66)\n            make.height.equalTo(22)\n        &#125;\n        \n        // 预约时间\n        acView.addSubview(timeBtn)\n        timeBtn.snp.makeConstraints&#123;make in\n            make.top.equalTo(11)\n            make.centerX.equalToSuperview()\n            make.width.equalTo(66)\n            make.height.equalTo(22)\n        &#125;\n        \n        // 加取消按钮\n        acView.addSubview(cancelBtn)\n        cancelBtn.snp.makeConstraints&#123;make in\n            make.top.equalTo(11)\n            make.trailing.equalTo(-16)\n            make.width.equalTo(66)\n            make.height.equalTo(22)\n        &#125;\n        \n        \n        // 继续加滚动视图\n        acView.addSubview(scrollView)\n        scrollView.snp.makeConstraints&#123;make in\n            make.top.equalTo(dateBtn.snp.bottom).offset(10)\n            make.leading.trailing.equalToSuperview()\n            make.bottom.equalToSuperview()\n        &#125;\n        \n        // acView添加完毕，现在到内部ScrollView层级了--------------\n    \n        // 加个集合View 集合View因为初始化确定了y轴高度，这里无需重复布局\n        scrollView.addSubview(collectionView)\n        \n        // 再加个pickerView 时间滚轮，这里直接加到ScrollView里面了，也无需布局，直接覆盖到上层的\n        scrollView.addSubview(pickerView)\n        \n        // 先加工具栏\n        scrollView.addSubview(dateToolView)\n        dateToolView.snp.makeConstraints&#123;make in\n            make.top.leading.equalTo(0)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(40)\n        &#125;\n        \n        // 滚动视图再加星期视图\n        scrollView.addSubview(weeksView)\n        weeksView.snp.makeConstraints&#123;make in\n            make.top.equalTo(dateToolView.snp.bottom).offset(4)\n            make.leading.equalTo(0)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(30)\n        &#125;\n        \n        \n        // 处理下工具栏内部布局\n        dateToolView.addSubview(monthLb)\n        monthLb.snp.makeConstraints&#123;make in\n            make.centerY.equalToSuperview()\n            make.centerX.equalToSuperview()\n            make.width.equalTo(100)\n            make.height.equalTo(20)\n        &#125;\n        \n        // 日历工具条加左按钮\n        dateToolView.addSubview(toolLeftBtn)\n        toolLeftBtn.snp.makeConstraints&#123;make in\n            make.centerY.equalToSuperview()\n            make.width.height.equalTo(40)\n            make.leading.equalTo(16)\n        &#125;\n\n        // 日历工具条加右侧箭头\n        dateToolView.addSubview(toolRightBtn)\n        toolRightBtn.snp.makeConstraints&#123;make in\n            make.centerY.equalToSuperview()\n            make.width.height.equalTo(40)\n            make.trailing.equalTo(-16)\n        &#125;\n        \n        // 设置星期几内部布局\n        setWeekUiInner()\n        \n        // 地址底部按钮\n        addBottomUI()\n    \n    &#125;\n</code></pre>\n<p>中规中矩，老老实实从上到下，从左到右布局。</p>\n<p>内部星期几看下如何布局的：</p>\n<pre><code class=\"line-numbers language-Swift\">func setWeekUiInner() &#123;\n        let arr = [&quot;日&quot;,&quot;一&quot;,&quot;二&quot;,&quot;三&quot;,&quot;四&quot;,&quot;五&quot;,&quot;六&quot;]\n\n        for i in 0 ..&lt; arr.count &#123;\n            let width = ScreenWidth/7\n            let lab = UILabel()\n            lab.text = arr[i]\n            lab.textColor = UIColor.init(hex: &quot;#323233&quot;)\n            lab.font = .pingFangRegular(size: 12)\n            lab.textAlignment = .center\n            weeksView.addSubview(lab)\n            lab.snp.makeConstraints&#123;make in\n                make.leading.equalTo(width*CGFloat(i))\n                make.centerY.equalToSuperview()\n                make.width.equalTo(width)\n                make.height.equalTo(20)\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>还有底部的下一步和完成：</p>\n<pre><code class=\"line-numbers language-Swift\">func addBottomUI() &#123;\n        let nextBtn: UIButton = UIButton.init(type: .custom)\n        nextBtn.frame = CGRect.init(x: 16, y: ScreenHeight*0.57*0.57+8+34+40, width: (ScreenWidth-32), height: 44)\n        nextBtn.titleFont = .pingFangMedium(size: 16)\n        nextBtn.setTitleColor(.white, for: .normal)\n        nextBtn.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n        nextBtn.setTitle(&quot;下一步&quot;, for: .normal)\n        nextBtn.layer.cornerRadius = 22\n        nextBtn.addTarget(self, action: #selector(actionForNext), for: .touchUpInside)\n        scrollView.addSubview(nextBtn)\n        \n        let doneBtn: UIButton = UIButton.init(type: .custom)\n        doneBtn.frame = CGRect.init(x: ScreenWidth+16, y: ScreenHeight*0.57*0.57+8+34+40, width: (ScreenWidth-32), height: 44)\n        doneBtn.titleFont = .pingFangMedium(size: 16)\n        doneBtn.setTitleColor(.white, for: .normal)\n        doneBtn.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n        doneBtn.setTitle(&quot;完成&quot;, for: .normal)\n        doneBtn.layer.cornerRadius = 22\n        doneBtn.addTarget(self, action: #selector(actionForDone), for: .touchUpInside)\n        scrollView.addSubview(doneBtn)\n    &#125;\n</code></pre>\n<h3 id=\"3-7-填充数据\"><a href=\"#3-7-填充数据\" class=\"headerlink\" title=\"3.7 填充数据\"></a>3.7 填充数据</h3><p>这里先看下日历数据如何使用代理和数据源的：</p>\n<pre><code class=\"line-numbers language-Swift\">extension CalendarView: UICollectionViewDelegate,UICollectionViewDataSource,UICollectionViewDelegateFlowLayout&#123;\n    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123;\n        return modelArr.count\n    &#125;\n    \n    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123;\n        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: CalendarCell.identifier, for: indexPath) as! CalendarCell\n        cell.model = modelArr[indexPath.item]\n        cell.selectedModel = timeModel\n        return cell\n    &#125;\n\n    // 定义每个Cell的大小\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -&gt; CGSize &#123;\n        let width = ScreenWidth/7\n        let height = modelArr.count &gt; 35 ? (ScreenHeight*0.57*0.57)/6 : (ScreenHeight*0.57*0.57)/5\n        return CGSize(width: width-2, height: height-1)\n    &#125;\n    \n    // 定义每个Section的四边间距\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -&gt; UIEdgeInsets &#123;\n        return UIEdgeInsets(top: 0, left: 3.5, bottom: 0, right: 0)\n    &#125;\n    \n    // 这个是两行cell之间的间距（上下行cell的间距）\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -&gt; CGFloat &#123;\n        return 1.0\n    &#125;\n    \n    // 两个cell之间的间距（同一行的cell的间距）\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Int) -&gt; CGFloat &#123;\n        return 1.0\n    &#125;\n    \n    // 选中某个ietm\n    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) &#123;\n        let model = modelArr[indexPath.item]\n        let com = YSDateTool.currentDateCom()\n        if com.year == model.year &amp;&amp; com.month == model.month &amp;&amp; model.day &lt;= com.day! || model.day == 0&#123;\n            return\n        &#125;\n\n        timeModel.year = model.year\n        timeModel.month = model.month\n        timeModel.day = model.day\n        collectionView.reloadData()\n    &#125;\n&#125;\n</code></pre>\n<p>主要逻辑委托给Cell来实现了。后面再看下。</p>\n<h3 id=\"3-8-UIPickerView数据填充\"><a href=\"#3-8-UIPickerView数据填充\" class=\"headerlink\" title=\"3.8 UIPickerView数据填充\"></a>3.8 UIPickerView数据填充</h3><p>然后看下预约时间如何填充数据的。</p>\n<pre><code class=\"line-numbers language-Swift\">extension CalendarView:UIPickerViewDelegate,UIPickerViewDataSource &#123;\n\n    func numberOfComponents(in pickerView: UIPickerView) -&gt; Int &#123;\n        return 1\n    &#125;\n    \n    func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -&gt; Int &#123;\n        return timeArr.count\n    &#125;\n\n    func pickerView(_ pickerView: UIPickerView, widthForComponent component: Int) -&gt; CGFloat &#123;\n        return ScreenWidth\n    &#125;\n    \n    func pickerView(_ pickerView: UIPickerView, rowHeightForComponent component: Int) -&gt; CGFloat &#123;\n        44\n    &#125;\n    \n    func pickerView(_ pickerView: UIPickerView, viewForRow row: Int, forComponent component: Int, reusing view: UIView?) -&gt; UIView &#123;\n        \n        //设置分割线 pickerView的subvews的第二个一般用来做分割线 subviews会有2个view\n        for view in pickerView.subviews &#123;\n            print(&quot;view.height=\\(view.size.height) 长度为：\\(pickerView.subviews.count)&quot;)\n            if view.size.height &lt;= 50 &#123;\n                view.backgroundColor = .clear\n                //自定义分割线\n                let toplayer = CALayer()\n                toplayer.frame = CGRect.init(x: 0, y: 0, width: ScreenWidth, height: 1)\n                toplayer.backgroundColor = UIColor.init(hex: &quot;#EBEDF0&quot;).cgColor\n                view.layer.addSublayer(toplayer)\n\n                let bottomlayer = CALayer()\n                bottomlayer.frame = CGRect.init(x: 0, y: 44-1, width: ScreenWidth, height: 1)\n                bottomlayer.backgroundColor = UIColor.init(hex: &quot;#EBEDF0&quot;).cgColor\n                view.layer.addSublayer(bottomlayer)\n               \n            &#125;else&#123;\n                view.backgroundColor = .clear\n            &#125;\n        &#125;\n        \n        //设置内容样式\n        var label = view as? UILabel\n        if label == nil &#123;\n            label = UILabel.init()\n            label?.backgroundColor = .clear\n            label?.frame = CGRect.init(x: 0, y: 0, width:ScreenWidth, height:44)\n        &#125;\n        if row == selectIndex &#123;\n            label?.textColor = UIColor.init(hex: &quot;#409EFF&quot;)\n        &#125;else&#123;\n            label?.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n        &#125;\n        label?.textAlignment = .center\n        label?.font = .pingFangRegular(size: 16)\n        //label?.minimumScaleFactor = 0.5\n        //label?.adjustsFontSizeToFitWidth = true\n        label?.text = timeArr[row]\n        return label!\n    &#125;\n    \n    func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) &#123;\n        selectIndex = row\n        pickerView.reloadAllComponents()\n    &#125;\n&#125;\n</code></pre>\n<p>主要逻辑是viewForRow覆写的方法里面。<br>交代了如何绘制分割线和选中高亮显示。<br>这里有个点要注意，这个分割线用到了 UIPickerView的subViews，这里通常设置分割线都要用到这个东西，具体细节我不是很清楚，预测这个subViews第二个就是居中的item。第一个item很长，不能用来分割线。</p>\n<p>然后就是didSelectRow用来响应用户点击事件，需要刷新下components。</p>\n<h3 id=\"3-9-交互事件\"><a href=\"#3-9-交互事件\" class=\"headerlink\" title=\"3.9 交互事件\"></a>3.9 交互事件</h3><p>这里交互事件统一用一个扩展类来实现。</p>\n<pre><code class=\"line-numbers language-Swift\">extension CalendarView &#123;\n    \n    @objc func actionForChooseDate()&#123;\n        self.lineViewLayout()\n        self.scrollDate()\n    &#125;\n    \n    @objc func actionForChooseTime()&#123;\n        self.lineViewLayout(leading: 1)\n        self.scrollTime()\n    &#125;\n    \n    @objc func actionForCancel()&#123;\n        self.dismissAlertView()\n    &#125;\n    \n    @objc func actionForLeftEvent()&#123;\n        dynamicDate = YSDateTool.lastMonth(date: dynamicDate)\n        self.isRefrenshMonth()\n    &#125;\n    \n    @objc func actionForRightEvent()&#123;\n        dynamicDate = YSDateTool.nextMonth(date: dynamicDate)\n        self.isRefrenshMonth()\n    &#125;\n    \n    @objc func actionForNext()&#123;\n        self.lineViewLayout(leading: 1)\n        self.scrollTime()\n    &#125;\n    \n    @objc func actionForDone()&#123;\n        if doneHandle != nil &#123;\n            let str = timeArr[selectIndex]\n            let arr = str.components(separatedBy: CalendarView.range)\n            timeModel.startTime = arr[0]\n            timeModel.endTime = arr[1]\n            \n            let monthStr = timeModel.month &lt; 10 ? &quot;0\\(timeModel.month)&quot; : &quot;\\(timeModel.month)&quot;\n            let dayStr = timeModel.day &lt; 10 ? &quot;0\\(timeModel.day)&quot; : &quot;\\(timeModel.day)&quot;\n            timeModel.dateStr = &quot;\\(timeModel.year)-\\(monthStr)-\\(dayStr)&quot;\n            \n            doneHandle(timeModel)\n        &#125;\n        self.dismissAlertView()\n    &#125;\n    \n    // 滑动到日期\n    func scrollDate()&#123;\n        dateBtn.isSelected = true\n        timeBtn.isSelected = false\n        scrollView.setContentOffset(CGPoint.init(x: 0, y: 0), animated: true)\n    &#125;\n    \n    // 滑动到时间\n    func scrollTime()&#123;\n        dateBtn.isSelected = false\n        timeBtn.isSelected = true\n        scrollView.setContentOffset(CGPoint.init(x: ScreenWidth, y: 0), animated: true)\n    &#125;\n    \n    func isRefrenshMonth()&#123;\n        self.setDate(date: dynamicDate)\n        let com = YSDateTool.currentDateCom(date: dynamicDate)\n        monthLb.text = &quot;\\(com.year!)年\\(com.month!)月&quot;\n        watermarkView.monthStr = &quot;\\(com.month!)&quot;\n        \n        let currentCom = YSDateTool.currentDateCom()\n        if (com.year! == currentCom.year!  &amp;&amp; com.month! &gt; currentCom.month!) || (com.year! &gt; currentCom.year!)&#123;\n            toolLeftBtn.isHidden = false\n        &#125;else&#123;\n            toolLeftBtn.isHidden = true\n        &#125;\n    &#125;\n    \n    func lineViewLayout(leading: Int = 0)&#123;\n        lineView.snp.remakeConstraints&#123;make in\n            make.top.equalTo(0)\n            if leading == 0 &#123;\n                make.leading.equalTo(leading)\n            &#125;else&#123;\n                make.centerX.equalToSuperview() // 居中了\n            &#125;\n            make.width.equalTo(66+56) // 宽度\n            make.height.equalTo(2)  // 高度\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"4-撸下时间工具\"><a href=\"#4-撸下时间工具\" class=\"headerlink\" title=\"4 撸下时间工具\"></a>4 撸下时间工具</h2><p>这个只是个单纯工具，不必重复造轮子。</p>\n<pre><code class=\"line-numbers language-Swift\">class YSDateTool &#123;\n    // MARK: - 当前时间组件\n    static func currentDateCom(date: Date = Date()) -&gt; DateComponents&#123;\n        let calendar = Calendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com\n    &#125;\n    // MARK: - 今年\n    static func currentYear(date: Date = Date()) -&gt; Int &#123;\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com.year!\n    &#125;\n  \n    // MARK: - 今月\n    static func currentMonth(date: Date = Date()) -&gt; Int &#123;\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com.month!\n    &#125;\n  \n    // MARK: - 今日\n    static func currentDay(date: Date = Date()) -&gt; Int &#123;\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com.day!\n    &#125;\n    \n    // MARK: - 今天星期几\n    static func currentWeekDay(date: Date = Date()) -&gt; Int &#123;\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.weekday], from: date)\n        return com.weekday!\n    &#125;\n    \n    // MARK: - 农历今年\n    static func currentChineseYear(date: Date = Date()) -&gt; String &#123;\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.year], from: date)\n        return numberToChina(yearNum: (com?.year)!) + &quot;年&quot;\n    &#125;\n    \n    // MARK: - 农历今月\n    static func currentChineseMonth(date: Date = Date()) -&gt; String &#123;\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.month], from: date)\n        return numberToChina(monthNum: (com?.month)!)\n    &#125;\n\n    // MARK: - 农历今日\n    static func currentChineseDay(date: Date = Date()) -&gt; String &#123;\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.day], from: date)\n        return numberToChina(dayNum: (com?.day)!)\n    &#125;\n    \n    // MARK: - 农历今日\n    static func currentChineseDayInt(date: Date = Date()) -&gt; Int &#123;\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.day], from: date)\n        return (com?.day)!\n    &#125;\n    \n    // MARK: - 农历星期\n    static func currentChineseWeekYear(date: Date = Date()) -&gt; String &#123;\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.weekday], from: date)\n        return numberToChina(weekNum: (com?.weekday)!)\n    &#125;\n  \n    // MARK: - 下个月\n    static func nextMonth(date: Date = Date()) -&gt; Date &#123;\n        let calendar = NSCalendar.current\n        let nDate = calendar.date(byAdding: DateComponents(month: 1), to: date)\n        return nDate!\n    &#125;\n    \n    // MARK: - 上个月\n    static func lastMonth(date: Date = Date()) -&gt; Date &#123;\n        let calendar = NSCalendar.current\n        let lDate = calendar.date(byAdding: DateComponents(month: -1), to: date)\n        return lDate!\n    &#125;\n    \n    // MARK: - 下一天\n    static func lastDay(date: Date = Date()) -&gt; Date&#123;\n        let calendar = NSCalendar.current\n        let lDate = calendar.date(byAdding: DateComponents(day: 1), to: date)\n        return lDate!\n    &#125;\n  \n    // MARK: - 本月天数\n    static func countOfDaysInCurrentMonth(date: Date = Date()) -&gt; Int &#123;\n        let calendar = Calendar(identifier: Calendar.Identifier.gregorian)\n        let range = (calendar as NSCalendar?)?.range(of: NSCalendar.Unit.day, in: NSCalendar.Unit.month, for: date)\n        return (range?.length)!\n    &#125;\n \n    // MARK: - 当月第一天是星期几\n    static func firstWeekDayInCurrentMonth(date: Date = Date()) -&gt; Int &#123;\n        // 星期和数字一一对应 星期日：7\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = &quot;yyyy-MM&quot;\n        let date = dateFormatter.date(from: String(date.xj.year)+&quot;-&quot;+String(date.xj.month))\n        let calender = Calendar(identifier: Calendar.Identifier.gregorian)\n        let comps = (calender as NSCalendar?)?.components(NSCalendar.Unit.weekday, from: date!)\n        var week = comps?.weekday\n        if week == 1 &#123;\n            week = 8\n        &#125;\n        return week! - 1\n    &#125;\n\n    // MARK: - - 获取指定日期各种值\n    // 根据年月得到某月天数\n    static func getCountOfDaysInMonth(year: Int, month: Int) -&gt; Int&#123;\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = &quot;yyyy-MM&quot;\n        let date = dateFormatter.date(from: String(year)+&quot;-&quot;+String(month))\n        let calendar = Calendar(identifier: Calendar.Identifier.gregorian)\n        let range = (calendar as NSCalendar?)?.range(of: NSCalendar.Unit.day, in: NSCalendar.Unit.month, for: date!)\n        return (range?.length)!\n    &#125;\n    \n    // MARK: - 根据年月得到某月第一天是周几\n    static func getfirstWeekDayInMonth(year: Int, month: Int) -&gt; Int&#123;\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = &quot;yyyy-MM&quot;\n        let date = dateFormatter.date(from: String(year)+&quot;-&quot;+String(month))\n        let calendar = Calendar(identifier: Calendar.Identifier.gregorian)\n        let comps = (calendar as NSCalendar?)?.components(NSCalendar.Unit.weekday, from: date!)\n        let week = comps?.weekday\n        return week! - 1\n    &#125;\n\n    // MARK: - date转日期字符串\n    static func dateToDateString(_ date: Date, dateFormat: String) -&gt; String &#123;\n        let timeZone = NSTimeZone.default\n        let formatter = DateFormatter()\n        formatter.timeZone = timeZone\n        formatter.dateFormat = dateFormat\n        let date = formatter.string(from: date)\n        return date\n    &#125;\n\n    // MARK: - 日期字符串转date\n    static func dateStringToDate(_ dateStr: String) -&gt; Date &#123;\n        let dateFormatter = DateFormatter()\n        dateFormatter.timeZone = TimeZone(abbreviation: &quot;UTC+8&quot;)\n        dateFormatter.dateFormat = &quot;yyyy-MM-dd&quot;\n        let date = dateFormatter.date(from: dateStr)\n        return date!\n    &#125;\n    \n    // MARK: - 时间字符串转date\n    static func timeStringToDate(_ dateStr: String) -&gt; Date &#123;\n        let dateFormatter = DateFormatter()\n        dateFormatter.timeZone = TimeZone(abbreviation: &quot;UTC+8&quot;)\n        dateFormatter.dateFormat = &quot;yyyy-MM-dd HH:mm:ss&quot;\n        let date = dateFormatter.date(from: dateStr)\n        return date!\n    &#125;\n\n    // MARK: - 计算天数差\n    static func dateDifference(_ dateA: Date, from dateB: Date) -&gt; Double &#123;\n        let interval = dateA.timeIntervalSince(dateB)\n        return interval/86400\n    &#125;\n\n    // MARK: - 比较时间先后\n    static func compareOneDay(oneDay: Date, withAnotherDay anotherDay: Date) -&gt; Int &#123;\n        let dateFormatter: DateFormatter = DateFormatter()\n        dateFormatter.dateFormat = &quot;yyyy-MM-dd&quot;\n        let oneDayStr: String = dateFormatter.string(from: oneDay)\n        let anotherDayStr: String = dateFormatter.string(from: anotherDay)\n        let dateA = dateFormatter.date(from: oneDayStr)\n        let dateB = dateFormatter.date(from: anotherDayStr)\n        let result: ComparisonResult = (dateA?.compare(dateB!))!\n        // Date1 is in the future\n        if(result == ComparisonResult.orderedDescending ) &#123;\n            return 1\n        &#125;\n        // Date1 is in the past\n        else if(result == ComparisonResult.orderedAscending) &#123;\n            return 2\n        &#125;\n            // Both dates are the same\n        else &#123;\n            return 0\n        &#125;\n    &#125;\n\n    // MARK: - 时间与时间戳之间的转化\n    // 将时间转换为时间戳\n    static func stringToTimeStamp(_ stringTime: String) -&gt; Int &#123;\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat = &quot;yyyy-MM-dd HH: mm: ss&quot;\n        dfmatter.locale = Locale.current\n        let date = dfmatter.date(from: stringTime)\n        let dateStamp: TimeInterval = date!.timeIntervalSince1970\n        let dateSt: Int = Int(dateStamp)\n        return dateSt\n    &#125;\n    \n    // 将时间戳转换为年月日\n    static func timeStampToString(_ timeStamp: String) -&gt; String &#123;\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=&quot;yyyy年MM月dd日&quot;\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    &#125;\n    \n    // 将时间戳转换为具体时间\n    static func timeStampToStringDetail(_ timeStamp: String) -&gt; String &#123;\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=&quot;yyyy年MM月dd日HH: mm: ss&quot;\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    &#125;\n    \n    // 将时间戳转换为时分秒\n    static func timeStampToHHMMSS(_ timeStamp: String) -&gt; String &#123;\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=&quot;HH: mm: ss&quot;\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    &#125;\n    \n    // 将时间戳转换为时分\n    static func timeStampToHHMM(_ timeStamp: String) -&gt; String &#123;\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=&quot;HH: mm&quot;\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    &#125;\n    \n    // 获取系统的当前时间戳\n    static func getStamp(date: Date = Date()) -&gt; Int&#123;\n        // 获取当前时间戳\n        let timeInterval: Int = Int(date.timeIntervalSince1970)\n        return timeInterval\n    &#125;\n    \n    // 日数字转汉字\n    static func numberToChina(yearNum: Int) -&gt; String &#123;\n        // 以一个天干和一个地支相配，排列起来，天干在前，地支在后，天干由甲起，地支由子起，阳干对阳支，阴干对阴支（阳干不配阴支，阴干不配阳支）\n        // 就会得到六十年一周期的甲子回圈，一般称为“六十甲子”或“花甲子”\n        // 十天干： 甲（jiǎ）、乙（yǐ）、丙（bǐng）、丁（dīng）、戊（wù）、己（jǐ）、庚（gēng）、辛（xīn）、壬（rén）、癸（guǐ）\n        // 十二地支： 子（zǐ）、丑（chǒu）、寅（yín）、卯（mǎo）、辰（chén）、巳（sì）、午（wǔ）、未（wèi）、申（shēn）、酉（yǒu）、戌（xū）、亥（hài）\n        let ChinaArray = [ &quot;甲子&quot;, &quot;乙丑&quot;, &quot;丙寅&quot;, &quot;丁卯&quot;, &quot;戊辰&quot;, &quot;己巳&quot;, &quot;庚午&quot;, &quot;辛未&quot;, &quot;壬申&quot;, &quot;癸酉&quot;,\n                         &quot;甲戌&quot;, &quot;乙亥&quot;, &quot;丙子&quot;, &quot;丁丑&quot;, &quot;戊寅&quot;, &quot;己卯&quot;, &quot;庚辰&quot;, &quot;辛己&quot;, &quot;壬午&quot;, &quot;癸未&quot;,\n                         &quot;甲申&quot;, &quot;乙酉&quot;, &quot;丙戌&quot;, &quot;丁亥&quot;, &quot;戊子&quot;, &quot;己丑&quot;, &quot;庚寅&quot;, &quot;辛卯&quot;, &quot;壬辰&quot;, &quot;癸巳&quot;,\n                         &quot;甲午&quot;, &quot;乙未&quot;, &quot;丙申&quot;, &quot;丁酉&quot;, &quot;戊戌&quot;, &quot;己亥&quot;, &quot;庚子&quot;, &quot;辛丑&quot;, &quot;壬寅&quot;, &quot;癸丑&quot;,\n                         &quot;甲辰&quot;, &quot;乙巳&quot;, &quot;丙午&quot;, &quot;丁未&quot;, &quot;戊申&quot;, &quot;己酉&quot;, &quot;庚戌&quot;, &quot;辛亥&quot;, &quot;壬子&quot;, &quot;癸丑&quot;,\n                         &quot;甲寅&quot;, &quot;乙卯&quot;, &quot;丙辰&quot;, &quot;丁巳&quot;, &quot;戊午&quot;, &quot;己未&quot;, &quot;庚申&quot;, &quot;辛酉&quot;, &quot;壬戌&quot;, &quot;癸亥&quot;]\n        let ChinaStr: String = ChinaArray[yearNum - 1]\n        return ChinaStr\n    &#125;\n    \n    // 月份数字转汉字\n    static func numberToChina(monthNum: Int) -&gt; String &#123;\n        let ChinaArray = [&quot;一月&quot;, &quot;二月&quot;, &quot;三月&quot;, &quot;四月&quot;, &quot;五月&quot;, &quot;六月&quot;, &quot;七月&quot;, &quot;八月&quot;, &quot;九月&quot;, &quot;十月&quot;, &quot;十一月&quot;, &quot;十二月&quot;]\n        let ChinaStr: String = ChinaArray[monthNum - 1]\n        return ChinaStr\n    &#125;\n    \n    // 日数字转汉字\n    static func numberToChina(dayNum: Int) -&gt; String &#123;\n        let ChinaArray = [ &quot;初一&quot;, &quot;初二&quot;, &quot;初三&quot;, &quot;初四&quot;, &quot;初五&quot;, &quot;初六&quot;, &quot;初七&quot;, &quot;初八&quot;, &quot;初九&quot;, &quot;初十&quot;,\n                         &quot;十一&quot;, &quot;十二&quot;, &quot;十三&quot;, &quot;十四&quot;, &quot;十五&quot;, &quot;十六&quot;, &quot;十七&quot;, &quot;十八&quot;, &quot;十九&quot;, &quot;二十&quot;,\n                         &quot;廿一&quot;, &quot;廿二&quot;, &quot;廿三&quot;, &quot;廿四&quot;, &quot;廿五&quot;, &quot;廿六&quot;, &quot;廿七&quot;, &quot;廿八&quot;, &quot;廿九&quot;, &quot;三十&quot;]\n        let ChinaStr: String = ChinaArray[dayNum - 1]\n        return ChinaStr\n    &#125;\n      \n    // 星期数字转汉字\n    static func numberToChina(weekNum: Int) -&gt; String &#123;\n        let ChinaArray = [&quot;一月&quot;, &quot;二月&quot;, &quot;三月&quot;, &quot;四月&quot;, &quot;五月&quot;, &quot;六月&quot;, &quot;七月&quot;, &quot;八月&quot;, &quot;九月&quot;, &quot;十月&quot;, &quot;十一月&quot;, &quot;十二月&quot;]\n        let ChinaStr: String = ChinaArray[weekNum - 1]\n        return ChinaStr\n    &#125;\n    \n    // MARK: - 数字前补0\n    static func add0BeforeNumber(_ number: Int) -&gt; String &#123;\n        if number &gt;= 10 &#123;\n            return String(number)\n        &#125;else&#123;\n            return &quot;0&quot; + String(number)\n        &#125;\n    &#125;\n    \n    static func getCurrentSystemDate() -&gt; Date&#123;\n        let date = Date() // 获得时间对象\n        let zone = NSTimeZone.system // 获得系统的时区\n        let time = zone.secondsFromGMT(for: date)// 以秒为单位返回当前时间与系统格林尼治时间的差\n        return date.addingTimeInterval(TimeInterval(time))// 然后把差的时间加上,就是当前系统准确的时间\n    &#125;\n    \n    static func date(_ date: String?, dateFormat: String = &quot;yyyy-MM-dd&quot;) -&gt; Date? &#123;\n        guard let date = date else &#123;\n            return nil\n        &#125;\n        let dateformatter = DateFormatter()\n        dateformatter.timeZone = TimeZone.init(secondsFromGMT: 0)\n        dateformatter.dateFormat = dateFormat\n        return dateformatter.date(from: date)\n    &#125;\n\n    // MARK: - 将时间显示为（几分钟前，几小时前，几天前）\n    static func compareCurrentTime(str: String) -&gt; String &#123;\n        //let currentDateStr = dateToDateString(Date(), dateFormat: &quot;yyyy-MM-dd hh:mm:ss&quot;)\n        let currentDate = getCurrentSystemDate()\n        let sendTimeDate = date(str,dateFormat: &quot;yyyy-MM-dd HH:mm:ss&quot;)!//self.timeStringToDate(str)\n        let sendTimeInterval = Double(getStamp(date: sendTimeDate))\n        let timeInterval = currentDate.timeIntervalSince(sendTimeDate)\n\n        var todayStr = dateToDateString(Date(), dateFormat: &quot;yyyy-MM-dd&quot;)\n        todayStr = todayStr+&quot; 00:00&quot;\n        let todayTimeInterval = Double(Date().stringToSecondTimeStamp(todayStr)) ?? 0\n        let yestDayTimeInterval = Double(todayTimeInterval - 86400)\n        let nextDayTimeInterval = Double(todayTimeInterval + 86400)\n\n        var temp: Double = 0\n        var result: String = &quot;&quot;\n        if timeInterval/60 &lt; 1 &#123;\n            result = &quot;刚刚&quot;\n        &#125;else if (timeInterval/60) &lt; 60&#123;\n            temp = timeInterval/60\n            result = &quot;\\(Int(temp))分钟前&quot;\n        &#125;else if sendTimeInterval &gt; todayTimeInterval &amp;&amp; sendTimeInterval &lt; nextDayTimeInterval&#123;\n\n            //let interval = nextDayTimeInterval - sendTimeInterval\n            temp = timeInterval/60/60\n            result = &quot;\\(Int(temp))小时前&quot;\n        &#125;else if sendTimeInterval &gt; yestDayTimeInterval &amp;&amp; sendTimeInterval &lt; todayTimeInterval&#123;\n            //let str = timeStampToHHMM(String.init(format: &quot;%d&quot;, sendTimeInterval))\n            let timeStr = str.components(separatedBy: &quot; &quot;).last ?? &quot;&quot;\n            let str = timeStr.prefix(5)\n            result = &quot;昨天\\(str)&quot;\n        &#125;else&#123;\n            let timeStr = str.components(separatedBy: &quot; &quot;).first ?? &quot;&quot;\n            let timeArr = timeStr.components(separatedBy: &quot;-&quot;)\n            if !timeArr.isEmpty &#123;\n                result = &quot;\\(timeArr[0])年\\(timeArr[1])月\\(timeArr[2])日&quot;\n            &#125;\n            //result = timeStampToString(String.init(format: &quot;%d&quot;, sendTimeInterval))\n        &#125;\n        \n//        else if timeInterval/(30 * 24 * 60 * 60) &lt; 12 &#123;\n//            temp = timeInterval/(30 * 24 * 60 * 60)\n//            result = &quot;\\(Int(temp))个月前&quot;\n//        &#125;else&#123;\n//            temp = timeInterval/(12 * 30 * 24 * 60 * 60)\n//            result = &quot;\\(Int(temp))年前&quot;\n//        &#125;\n        return result\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"5-撸下最后的日历Cell\"><a href=\"#5-撸下最后的日历Cell\" class=\"headerlink\" title=\"5 撸下最后的日历Cell\"></a>5 撸下最后的日历Cell</h2><p>这个就是日历里面的item，还是相当简单的。</p>\n<h3 id=\"5-1-全局变量\"><a href=\"#5-1-全局变量\" class=\"headerlink\" title=\"5.1 全局变量\"></a>5.1 全局变量</h3><pre><code class=\"line-numbers language-Swift\">class CalendarCell: UICollectionViewCell &#123;\n    \n    static var identifier = &quot;UICollectionViewCell&quot;\n    \n    var isGreaterThan: Bool = false     //是否取大于今天的值\n    \n    var isShowPassTime: Int = 0         //是否设定禁选\n    \n    var model:TimeModel?&#123;\n        didSet&#123;\n            guard let _model = model else &#123;return&#125;\n            if _model.day != 0 &#123;\n                titleLab.text = &quot;\\(_model.day)&quot;\n            &#125;else&#123;\n                titleLab.text = &quot;&quot; // 为0，啥也不显示\n            &#125;\n            \n            let com = YSDateTool.currentDateCom()\n            \n            // 是否是选中的日子\n            if com.year == _model.year &amp;&amp; com.month == _model.month &amp;&amp; com.day == _model.day &#123;\n                titleLab.textColor = UIColor.init(hex: &quot;#409EFF&quot;)\n            &#125;else&#123;\n                titleLab.textColor = UIColor.init(hex: &quot;#323233&quot;)\n            &#125;\n            \n            // 禁用还是可用\n            if isShowPassTime == 0 &#123;\n                if isGreaterThan &#123;\n                    if (com.year == _model.year &amp;&amp; com.month == _model.month &amp;&amp; _model.day &gt; com.day!) || (_model.year == com.year! &amp;&amp; _model.month &gt; com.month!) || (_model.year &gt; com.year!)&#123;\n                        titleLab.textColor = UIColor.init(hex: &quot;#C8C9CC&quot;)\n                    &#125;\n                &#125;else&#123;\n                    // 如果要大于今天，那么前面的时间就的置灰了 前一个月的点不过去，不考虑了\n                    if com.year == _model.year &amp;&amp; com.month == _model.month &amp;&amp; _model.day &lt; com.day!&#123;\n                        titleLab.textColor = UIColor.init(hex: &quot;#C8C9CC&quot;)\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    \n    // 选中的item，背景颜色高亮\n    var selectedModel: TimeModel?&#123;\n        didSet&#123;\n            guard let _model = selectedModel else&#123;return&#125;\n            if _model.year == model?.year &amp;&amp; _model.month == model?.month &amp;&amp; _model.day == model?.day&#123;\n                titleLab.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n                titleLab.textColor = UIColor.white\n            &#125;else&#123;\n                titleLab.backgroundColor = UIColor.clear\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>比较重要的是model，表示当前时间实体类。这里监听变量改变，利用didSet实现动态改变文案效果。</p>\n<p>另外一个是selectedModel，这个是当前选中的item，会比对item是否为选中，选中样式会有所不同。</p>\n<h3 id=\"5-2-UI子View\"><a href=\"#5-2-UI子View\" class=\"headerlink\" title=\"5.2 UI子View\"></a>5.2 UI子View</h3><p>这里只用到一个子View。</p>\n<pre><code class=\"line-numbers language-Swift\">var titleLab: UILabel = &#123;\n        let lan = UILabel()\n        lan.font = .pingFangRegular(size: 16)\n        lan.textAlignment = .center\n        lan.textColor = UIColor.init(hex: &quot;#323233&quot;)\n        \n        lan.layer.cornerRadius = 4\n        lan.layer.masksToBounds = true\n        return lan\n    &#125;()\n</code></pre>\n<h3 id=\"5-3-生命周期函数\"><a href=\"#5-3-生命周期函数\" class=\"headerlink\" title=\"5.3 生命周期函数\"></a>5.3 生命周期函数</h3><pre><code class=\"line-numbers language-Swift\">override init(frame: CGRect) &#123;\n        super.init(frame: frame)\n        contentView.backgroundColor = .clear\n        contentView.addSubview(titleLab)\n        titleLab.snp.makeConstraints&#123;make in\n            make.top.bottom.leading.trailing.equalToSuperview()\n        &#125;\n    &#125;\n    \n    required init?(coder aDecoder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n</code></pre>\n<p>把那个子View添加到Cell里面去了。</p>\n<p>大概就是这样子。</p>\n<h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6 总结\"></a>6 总结</h2><ul>\n<li><p>如果UI图有那种Tab页，就可以考虑使用多种方案来实现，iOS直接用简单的Button也是可以实现的，分割线也是可以用最简单的UIView来实现，不一定要用封装好的框架，谁用挖掘机来搬小石头呢，大材小用了。</p>\n</li>\n<li><p>分页效果可以使用UIScrollView来实现，把它宽度设置为屏幕的n倍，这样最有滑动可以很好控制的，不要动画也可以设置的，办法总是就很多的。</p>\n</li>\n<li><p>日历效果可以用UICollectionView来实现，看着很复杂，其实很简单，主要逻辑也不复杂，控制好数据刷新就好了。UICollectionView可以实现类似网格的效果，我们只需要在Cell里面绘制一个一个Cell，空的部分，我们啥不展示就好了。</p>\n</li>\n<li><p>系统的UIPickerView设置分割线很简单，利用UIPickerView下有一个subViews，这里寻找高度为item高度大小的，然后给view设置一个Layer即可。</p>\n</li>\n</ul>\n"},{"title":"玩Android Compose版本 项目分析","date":"2023-01-17T03:23:20.000Z","top":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n> 玩Android(compose版本)项目地址：[https://github.com/yellowhai/PlayAndroid](https://github.com/yellowhai/PlayAndroid)\n\n### 1.项目settings.gradle\n\n```groovy\ndependencyResolutionManagement {\n    /**\n     * 原文中说默认情况下，项目中的存储库会覆盖设置中的存储库 ，可以通过设置模式来更改这种行为\n     设置存储库的方法：\n     repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n     存储库模式：\n     PREFER_PROJECT(true)--首选项目存储库\n     PREFER_SETTINGS(false)--首选设置存储库\n     FAIL_ON_PROJECT_REPOS(false)--强制设置存储库\n     */\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories {\n        google()\n        mavenCentral()\n        maven { url \"https://jitpack.io\" }\n        maven {\n            url 'https://maven.aliyun.com/repository/public/'\n        }\n        maven { url 'https://maven.aliyun.com/repository/public' }\n        maven { url 'https://maven.aliyun.com/repository/central' }\n        maven { url 'https://maven.aliyun.com/repository/google' }\n        maven { url 'https://maven.aliyun.com/repository/public' }\n        maven { url 'https://maven.aliyun.com/repository/gradle-plugin' }\n    }\n}\nrootProject.name = \"PlayAndroid\"\ninclude ':app'\ninclude ':common'\ninclude ':h_mine'\ninclude ':toolkit'\n```\n\n还是很容易理解的，repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)这个是新增的，简单看下就行。\n引入了app模块(主模块)，common模块（通用模块，用于通用组件相关）,h_mine模块（我的模块，可以单独编译）。\n\n### 2.config.gradle\n这个文件相信大家都有用过的，配置远程依赖的一个文件，统一管理。\n```groovy\next{\n    isRelease = true\n\n    //android构建配置\n    android_models = [\n            compileSdk : 32,\n            minSdk : 23,\n            targetSdk : 32,\n            versionCode : 1,\n            versionName : \"1.0\"\n    ]\n    \n    app_id = [\n            mine      : 'com.hh.mine',\n    ]\n\n    core_ktx_version = '1.7.0'\n    appcompat_version = '1.4.0'\n    lifecycle_version = '2.4.0'\n    material_version = '1.4.0'\n    work_version = '2.7.1'\n    gson_version = '2.8.9'\n    litepal_version = '3.2.3'\n    landscapist_version = '1.4.5'\n    retrofit_version = '2.9.0'\n    okhttp_version = '4.9.3'\n    startup_version = '1.1.0'\n    XXPermissions_version = '13.2'\n    datastore_version = '1.0.0'\n    materialDialog_version = '0.6.2'\n    accompanist_version = '0.25.0'\n\n\n    jetpack_compose = [\n            material : \"androidx.compose.material:material:$compose_version\",\n            activity : \"androidx.activity:activity-compose:$appcompat_version\",\n    ]\n\n    commonApi = [\n            ktx_core        : \"androidx.core:core-ktx:$core_ktx_version\",\n            lifecycle       : \"androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version\",\n            appcompat       : \"androidx.appcompat:appcompat:$appcompat_version\",\n            material        : \"com.google.android.material:material:$material_version\",\n            //数据存储\n            datastore       : \"androidx.datastore:datastore-preferences:$datastore_version\",\n            //权限处理\n            XXPermissions   : \"com.github.getActivity:XXPermissions:$XXPermissions_version\",\n    ]\n\n    net = [\n            retrofit    : \"com.squareup.retrofit2:retrofit:$retrofit_version\",\n            converter   : \"com.squareup.retrofit2:converter-gson:$retrofit_version\",\n            okhttp      : \"com.squareup.okhttp3:logging-interceptor:$okhttp_version\",\n            gson        : \"com.google.code.gson:gson:$gson_version\"\n    ]\n\n    accompanist_ui = [\n            insets_ui    : \"com.google.accompanist:accompanist-insets-ui:$accompanist_version\",\n            navigation   : \"com.google.accompanist:accompanist-navigation-animation:$accompanist_version\",\n            pager        : \"com.google.accompanist:accompanist-pager:$accompanist_version\",\n            swiperefresh : \"com.google.accompanist:accompanist-swiperefresh:$accompanist_version\",\n            flowlayout   : \"com.google.accompanist:accompanist-flowlayout:$accompanist_version\",\n            systemUi     : \"com.google.accompanist:accompanist-systemuicontroller:$accompanist_version\",\n            webview      : \"com.google.accompanist:accompanist-webview:$accompanist_version\"\n    ]\n\n    database =[\n            litepal :  \"org.litepal.guolindev:core:$litepal_version\"\n    ]\n\n    skydoves_coil = [\n            landscapist_coil :  \"com.github.skydoves:landscapist-coil:$landscapist_version\"\n    ]\n\n    workManager = [\n            // Kotlin + coroutines\n            work = \"androidx.work:work-runtime-ktx:$work_version\"\n    ]\n\n    material_dialog = [\n            color : \"io.github.vanpra.compose-material-dialogs:color:$materialDialog_version\",\n            core  : \"io.github.vanpra.compose-material-dialogs:core:$materialDialog_version\",\n            datetime  : \"io.github.vanpra.compose-material-dialogs:datetime:$materialDialog_version\"\n    ]\n\n    paging = \"androidx.paging:paging-compose:1.0.0-alpha14\"\n\n    jetpackComposeLibs = jetpack_compose.values()\n    commonApiLibs = commonApi.values()\n    netLibs = net.values()\n    materialDialogLibs = material_dialog.values()\n}\n```\n层次还是比较清晰，对于同一组单独建立数组存储，模块中只需要引入一个就将这组全部引入进去了。\n\n### 3.app模块下的build.gradle\n\n显示引入com.android.application+kotlin-android的插件。\n下面配置android闭包，很简单。\n\n其它关于compose的也需要配置下：\n```groovy\n compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n    buildFeatures {\n        compose true\n    }\n    composeOptions {\n        kotlinCompilerExtensionVersion compose_version\n        kotlinCompilerVersion kotlin_version\n    }\n```\n\n然后是远程依赖：\n```groovy\ndependencies {\n    // 如果是release模式，就把我的模块加进来\n    if(isRelease){\n        implementation project(':h_mine')\n    }\n\n    // 初始化组件\n    implementation \"androidx.startup:startup-runtime:$startup_version\"\n    implementation project(':common')\n\n    // 测试相关\n    testImplementation 'junit:junit:4.13.2'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.3'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'\n    androidTestImplementation \"androidx.compose.ui:ui-test-junit4:$compose_version\"\n    androidTestImplementation \"androidx.compose.ui:ui-test-junit4:$compose_version\"\n    debugImplementation \"androidx.compose.ui:ui-tooling:$compose_version\"\n\n}\n```\n\nisRelease定义在 config.gradle的顶部。如果是集成编译就为true，单独编译为false。\n\n### 4.app模块的AndroidManifest.xml\n* 配置Application\n* 配置主页\n* 配置provider，用于初始化sdk\n    ```xml\n      <!--  用provider初始化sdk-->\n        <provider\n            android:name=\"androidx.startup.InitializationProvider\"\n            android:authorities=\"${applicationId}.androidx-startup\"\n            android:exported=\"false\"\n            tools:node=\"merge\">\n            <meta-data\n                android:name=\"com.hh.playandroid.base.BaseInitializer\"\n                android:value=\"androidx.startup\" />\n        </provider>\n    ```\n\n### 5.自定义Application\n ```\n class HhfApp : YshhApplication()\n ```   \n 依赖common模块：\n ```Kotlin\n open class YshhApplication : Application() {\n\n    lateinit var okbuilder: OkHttpClient\n\n    companion object {\n        /**\n         * application context.\n         */\n        @SuppressLint(\"StaticFieldLeak\")\n        lateinit var context: Context\n\n        @SuppressLint(\"StaticFieldLeak\")\n        lateinit var instance: YshhApplication\n\n        /**\n         * application级别的协程\n         * 有时我们需要在协程上下文中定义多个元素，组合协程上下文中的元素，使用 + 操作符来创建 CoroutineScope .\n         */\n        val applicationScope = CoroutineScope(SupervisorJob() + Dispatchers.Main)\n    }\n ```\n 这里懒加载OkHttpClient\n 定义了全局的协程，静态变量。\n\n ```Kotlin\n   override fun onCreate() {\n        super.onCreate()\n        context = applicationContext\n        instance = this\n        initRetrofit()\n    }\n ```\n 初始化Retrofit：\n ```Kotlin\n  /**\n     * 初始化Retrofit\n     */\n    private fun initRetrofit(token : String = \"\"): OkHttpClient {\n        //请求头\n        val headerInterceptor = Interceptor { chain: Interceptor.Chain ->\n            val orignaRequest = chain.request()\n            val request = orignaRequest.newBuilder()\n                .header(\"Authorization\", \"Bearer $token\")\n                .method(orignaRequest.method, orignaRequest.body)\n                .build()\n            chain.proceed(request)\n        }\n        val logInterceptor = LogInterceptor {\n//            it.logE()\n        }\n        // 日志类别\n        logInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);\n        // 缓存相关\n        val cacheFile =\n            File(getExternalFilesDir(Environment.DIRECTORY_PICTURES).toString() + \"http_cache\")\n        val cache = Cache(cacheFile, 104857600L) // 指定缓存大小100Mb\n        val builder = OkHttpClient.Builder()\n        //        builder.addInterceptor(addQueryParameterInterceptor);\n        builder.addInterceptor(headerInterceptor)\n        builder.cache(cache)\n        builder.addNetworkInterceptor(logInterceptor)\n        builder.cookieJar(cookieJar)\n        builder.readTimeout(60000, TimeUnit.MILLISECONDS)\n        //全局的写入超时时间60s\n        builder.writeTimeout(60000, TimeUnit.MILLISECONDS)\n        //全局的连接超时时间30s\n        builder.connectTimeout(30000, TimeUnit.MILLISECONDS)\n        okbuilder = builder.build()\n        return builder.build()\n    }\n\n    private val cookieJar: PersistentCookieJar by lazy {\n        PersistentCookieJar(SetCookieCache(), SharedPrefsCookiePersistor(context))\n    }\n    \n    fun getOkBuilder(): OkHttpClient {\n        return okbuilder\n    }\n ```\n\n ### 6.首页 MainActivity\n 继承BaseActivity:\n ```Kotlin\n\n/**\n * 基类Activity 设置非沉浸式，因为要设置导航栏和状态栏颜色\n */\nabstract class BaseActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        WindowCompat.setDecorFitsSystemWindows(window, false)\n    }\n\n}\n ```\n\nonCreate生命周期：\n```Kotlin\n @Suppress(\"DEPRECATED_IDENTITY_EQUALS\")\n    @OptIn(ExperimentalAnimationApi::class)\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        // 动画渐变\n        overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out)\n        // 设置内容\n        setContent {\n            Log.e(\"TEST##\", \"开始setContent了\")\n            // 顶层为自定义主题\n            HhfTheme(\n                // 是否暗色或亮色，跟随系统，如果用户主动设置，跟随用户\n                theme = if (isSystemInDarkTheme() || isNight) HhfTheme.Theme.Dark else HhfTheme.Theme.Light,\n                // 用户自行设置的颜色主题\n                colorTheme = appTheme\n            ) {\n                // 创建一个MainViewModel\n                val viewModel : MainViewModel = viewModel()\n\n                // 如果isSplash为true,就展示SplashView 启动页\n                if (viewModel.isSplash) {\n                    Log.e(\"TEST##\", \"加载闪屏了\")\n                    SplashView { viewModel.isSplash = false }\n                } else {\n                    Log.e(\"TEST##\", \"加载首页了\")\n                    // 全局静态变量存 底部控制器\n                    CpNavigation.navHostController = rememberAnimatedNavController()\n                    // 主页面\n                    HhfNavigation()\n                    // 进度条\n                    DialogProgress()\n                }\n                // 是否纪念日，将App置灰\n                if(isMourningDay()){\n                    Canvas(modifier = Modifier.fillMaxSize()){\n                        drawRect(color = Color.White,blendMode = BlendMode.Saturation)\n                    }\n                }\n            }\n        }\n        addCallback()\n    }\n```\n因为这个app就一个Activity，setContent中的内容就是展现给用户可以看到的所有东西了。\n顶层是一个自定义主题：\n```Kotlin\n@Composable\nfun HhfTheme(\n    theme: HhfTheme.Theme = HhfTheme.Theme.Light,\n    colorTheme: Color? = null,\n    content: @Composable () -> Unit\n) {\n    val targetColors = if (theme == HhfTheme.Theme.Dark) {\n        colorTheme?.let {\n            rememberSystemUiController().setNavigationBarColor(colorTheme)\n            DarkColorPalette.apply {\n                themeColor = it\n            }\n        }?:DarkColorPalette\n    } else {\n        colorTheme?.let {\n            rememberSystemUiController().setNavigationBarColor(colorTheme)\n            LightColorPalette.apply {\n                themeColor = it\n            }\n        }?:LightColorPalette\n    }\n    val themeColor = animateColorAsState(targetColors.themeColor, TweenSpec(600))\n    val textColor = animateColorAsState(targetColors.textColor, TweenSpec(600))\n    val background = animateColorAsState(targetColors.background,TweenSpec(600))\n    val listItem =  animateColorAsState(targetColors.listItem,TweenSpec(600))\n    val bottomBar =  animateColorAsState(targetColors.bottomBar,TweenSpec(600))\n    val divider =  animateColorAsState(targetColors.divider,TweenSpec(600))\n    val textFieldBackground =  animateColorAsState(targetColors.textFieldBackground,TweenSpec(600))\n    val colors = HhfColors(themeColor.value,\n        textColor.value,\n        background = background.value,\n        listItem = listItem.value,\n        bottomBar = bottomBar.value,\n        divider = divider.value,\n        textFieldBackground = textFieldBackground.value,\n        )\n    CompositionLocalProvider(LocalHhfColors provides colors) {\n        MaterialTheme(\n            shapes = Shapes,\n            typography = typography\n        ) {\n            content.invoke()\n        }\n    }\n}\n```\n这里用到了一个 CompositionLocalProvider，具体用法可以参考 [https://juejin.cn/post/7097890697721675813](https://juejin.cn/post/7097890697721675813)\n\n在Compose函数里，如果要用到函数外提供的值，一般都要通过函数定义好参数，外部调用时传入进去。\n这种方法表面看没啥问题，但在一些场景下就不是很方便。比如一个函数A嵌套一个函数B，函数B嵌套函数C，并且这A、B、C的函数都用到这个参数，那对三个函数来说都需要定义这个参数，就不是那么方便。\n那用个全局变量不就可以解决需要重复定义参数，确实可以。但全局变量有个副作用就是影响的范围比较大。本身我们定义的参数只会影响到函数内部。这个时候我们就可以使用CompositionLocal：它具有穿透函数功能的局部变量\nCompositionLocal适用场景：用来提供上下文数据，不扩大影响范围。\n\n然后最终主题呈现是用了 MaterialTheme这个类展现。\n\n回到首页，内容区：\n* 闪屏页展示逻辑\n    通过一个变量：`  var isSplash by mutableStateOf(true)` 实现控制是否显示\n*  加载首页\n    先 展示主页面，覆盖一层 进度条\n* 是否纪念日\n    app置灰处理    \n* 添加二次点击返回退出app逻辑\n\n首页逻辑基本就这么多了。\n\n### 7.闪屏ui -> SplashView\n看下效果先：\n<img src=%E9%97%AA%E5%B1%8F%E9%A1%B5.gif width = 50%>\n\n可以看到进入app后有个启动页面，中间是logo。\n那这个页面有个渐变动画，淡入淡出效果。\n\n具体ui是这样的：\n```Kotlin\n@Composable\nfun SplashView(startMain: () -> Unit) {\n    /**\n     * 辅助文字颜色变化 建立的一个mutableState包装的变量，实际上就是bool值\n     */\n    var enabled by remember { mutableStateOf(false) }\n\n    /**\n     * 背景颜色，从0.3alpha主题色变为纯主题色，2s的时间\n     */\n    val bgColor: Color by animateColorAsState(\n        if (enabled) HhfTheme.colors.themeColor\n        else HhfTheme.colors.themeColor.copy(alpha = 0.3f),\n        animationSpec = tween(durationMillis = 2000)\n    )\n\n    /**\n     * 中间文字颜色动画，如果enable为false，0.3alpha的颜色 到纯白色 2s的时间\n     */\n    val textColor: Color by animateColorAsState(\n        if (enabled) Color.White\n        else Color.White.copy(alpha = 0.3f),\n        animationSpec = tween(durationMillis = 2000)\n    )\n\n    // 外层一个Box+中间一个Text\n    Box(\n        Modifier\n            .fillMaxSize()\n            .background(bgColor),\n        contentAlignment = Alignment.Center\n    ) {\n        Text(text = \"PlayAndroid\", color = textColor,style = MaterialTheme.typography.h5)\n    }\n\n    // 开启协程 可以看出Compose里面开启协程的方法\n    LaunchedEffect(Unit) {\n        enabled = true\n        delay(2000)\n        // 2s后，设置 mutableStateOf 包装的bool变量 为false 会通知首页重新走setContent方法\n        startMain.invoke()\n    }\n}\n```\n\n这里需要理解 animateColorAsState 是官方提供的一个动画，支持颜色变化的一个composable方法。\n\n然后这里开启了2s延迟，怎么开延迟的，调用LaunchedEffect方法里面的delay，可以实现延迟效果。然后执行startMain回调。\n\n这个回调很简单：viewModel.isSplash = false\n\n虽然很简单，但实际上走了很多流程的。\n\n```Kotlin\nclass MainViewModel : ViewModel() {\n    var isSplash by mutableStateOf(true)\n}\n```\n这里使用mutableStateOf包装了一个布尔值。 上面触发这改变时，会刷新composable注解声明的方法体。这里应该就是刷新MainActivity整个内容区了。\n\n\n### 8.主页面外部架构\n```Kotlin\n@ExperimentalAnimationApi\n@OptIn(ExperimentalPagerApi::class)\n@Composable\nfun HhfNavigation() {\n    AnimatedNavHost(navController = CpNavigation.navHostController,\n        /**\n         * 首页默认页面\n         */\n        startDestination = ModelPath.Main.route,\n        enterTransition = { fadeIn(animationSpec = tween(700), initialAlpha = 0f) },\n        exitTransition = { fadeOut(animationSpec = tween(700), targetAlpha = 0f) }) {\n\n        /**\n         * 定义接收到 main 路由消息后->展示MainContent视图\n         */\n        composable(ModelPath.Main.route) {\n            MainContent()\n        }\n\n        /**\n         * 接收到 setting 路由消息后 -> 设置页面\n         */\n        composable(ModelPath.Setting.route) {\n            CpSetting(Modifier.fillMaxSize())\n        }\n        ...\n```\n\n这里使用了一个AnimatedNavHost，这个类是官方提供的。\n这个类里面定义了所有我们需要跳转的页面和初始页。\n然后这个 需要传一个参数，也就是控制器：\n` CpNavigation.navHostController = rememberAnimatedNavController()`\n这里也是官方提供的remember包装的一个控制器。\n\n这里的初始页为：`  startDestination = ModelPath.Main.route,`\n本质上就是一个string，首页的路由。\n\n这样会默认展示首页，怎么展示首页呢？\n```Kotlin\ncomposable(ModelPath.Main.route) {\n            MainContent()\n        }\n```\n那么这个MainContent就是我们的首页。\n\n其它composable里面都是首页可能去哪些页面的路由定义。\n\n那这个比如跳转到设置页面，怎么处理呢？\n* 首先在这个AnimatedNavHost里面定义一个composable闭包\n```Kotlin\n composable(ModelPath.Setting.route) {\n            CpSetting(Modifier.fillMaxSize())\n        }\n```\n\n* 然后再需要跳转的地方调用\n`navHostController.navigate(“setting”)`\n这个navHostController就是我们之前定义的那个控制器，setting就是路由名称。\n这样子就可以跳转到设置页面了。\n\n### 9.主页内部架构框\n首先看下主页效果图\n<img src=%E9%A6%96%E9%A1%B5.jpeg width=50%>\n轮播图+中间列表+底部bar\n轮播图+中间列表可以看成一个整体，那就是内容区+底部bar\n\n架构怎么搭建呢？\n```Kotlin\n   Scaffold(bottomBar = {\n        AnimatedVisibility(\n            visible = bottomSwitch,\n            enter = expandVertically() + fadeIn(), // 操作符重载了，第一个为空，就用第二个\n            exit = shrinkVertically() + fadeOut()  // 操作符重载了，第一个为空，就用第二个\n        ) {\n            // 实际的底部bar 高度使用 固有特性测量 可以参考：https://juejin.cn/post/7068164264363556872\n            MainBottomBar(\n                Modifier\n                    .fillMaxWidth()\n                    .height(IntrinsicSize.Max),pagerState = pagerState) {\n                pagerState.reenableScrolling(coroutineScope, it)\n            }\n        }\n    }) {\n        内容区...\n```\n最外层一个Scafffold脚手架包裹，有点像Flutter了啊。\n然后是一个AnimatedVisibility，这个控制显示隐藏的动画组件。重点看里面的MainBottomBar，就找到了我们的底部bar了。\n\n这个看起来像自定义的，具体怎么实现的呢？\n```Kotlin\n/**\n * App底部bar\n */\n@OptIn(ExperimentalPagerApi::class)\n@Composable\nprivate fun MainBottomBar(\n    modifier: Modifier = Modifier,\n    pagerState: PagerState,\n    currentChanged: (Int) -> Unit\n) {\n    /**\n     * 这个BottomAppBar是官方的\n     */\n    BottomAppBar(\n        modifier.navigationBarsPadding(),\n        cutoutShape = CircleShape,\n        backgroundColor = HhfTheme.colors.bottomBar,\n        elevation = 5.dp\n    ) {\n        // 遍历4个tab\n        bottomList.forEachIndexed { index, item ->\n            // item单独设置 官方组件\n            BottomNavigationItem(\n                selected = pagerState.currentPage == index, onClick = {\n                    /**\n                     * item点击事件回调给上层\n                     */\n                    currentChanged(index)\n                }, icon = {\n                    /**\n                     * icon为官方组件\n                     */\n                    Icon(\n                        item.dashboardState.icon,\n                        contentDescription = item.name,\n                        tint = if (pagerState.currentPage == index) {\n                            HhfTheme.colors.themeColor\n                        } else {\n                            LocalContentColor.current.copy(alpha = LocalContentAlpha.current)\n                        }, modifier = Modifier.size(24.dp)\n                    )\n                }, label = {\n                    Text(\n                        text = item.name,\n                        color = if (pagerState.currentPage == index) {\n                            HhfTheme.colors.themeColor\n                        } else {\n                            LocalContentColor.current.copy(alpha = LocalContentAlpha.current)\n                        },\n                        fontSize = 12.sp\n                    )\n                },\n                unselectedContentColor = LocalContentColor.current.copy(alpha = LocalContentAlpha.current),\n                selectedContentColor = HhfTheme.colors.themeColor,\n                alwaysShowLabel = true\n\n            )\n        }\n    }\n}\n```\n这里看出底部bar就是用了官方的BottomAppBar。\n里面具体内容是我们开发者自行设定的，这里遍历了bottomList，这个集合就是我们自己定义的一个集合：\n```Kotlin\n/**\n * 底部List集合 这里定义了4块\n * 首页，项目，公众号，我的\n */\nval bottomList = listOf(\n    BottomBean(\n        DashboardState.Home,\n        YshhApplication.context.stringResource(R.string.main_title_home)\n    ),\n    BottomBean(\n        DashboardState.Project,\n        YshhApplication.context.stringResource(R.string.main_title_project)\n    ),\n    BottomBean(\n        DashboardState.PubAccount,\n        YshhApplication.context.stringResource(R.string.main_title_account)\n    ),\n    BottomBean(\n        DashboardState.Mine,\n        YshhApplication.context.stringResource(R.string.main_title_mine)\n    )\n)\n```\n就这几个模块。\n\n底部bar的item就是 BottomNavigationitem里面的了，可以看到是一个icon+label构成。有个onClick的参数就是点击事件回调了，这里调用了 回调函数，传递给上层了，传出去的参数就一个int，表示第几页。\n\n回调到哪里呢？\n```Kotlin\n // 实际的底部bar 高度使用 固有特性测量 可以参考：https://juejin.cn/post/7068164264363556872\n            MainBottomBar(\n                Modifier\n                    .fillMaxWidth()\n                    .height(IntrinsicSize.Max),pagerState = pagerState) {\n                pagerState.reenableScrolling(coroutineScope, it)\n            }\n```\n这里通过调用rememberPagerState这个对象的`  pagerState.reenableScrolling(coroutineScope, it)`这个方法实现滚动到目标tab下。也就实现了页面切换。\n最为关键的就是这个pagerState，同步页面数据和底部bar。\n\n等下分析内容区也会用到。\n\n```Kotlin\n // 水平分页\n            HorizontalPager(\n                count = bottomList.size,\n                modifier.weight(1f), pagerState, userScrollEnabled = true\n            ) { page ->\n                when (page) {\n                    // 首页tab\n                    0 -> HomeView(\n                        Modifier\n                            .fillMaxSize()\n                            .background(HhfTheme.colors.background)\n                            .align(Alignment.CenterHorizontally)\n                    )\n                    // 项目tab\n                    1 -> ProjectView(\n                        Modifier\n                            .fillMaxSize()\n                            .align(Alignment.CenterHorizontally)\n                    )\n                    // 公众号tab\n                    2 -> AccountView(\n                        Modifier\n                            .fillMaxSize()\n                            .background(HhfTheme.colors.background)\n                            .align(Alignment.CenterHorizontally)\n                    )\n                    // 我的tab\n                    3 -> {\n//                        if (isLogin) {\n                            Mine(\n                                Modifier\n                                    .fillMaxSize()\n                                    .background(HhfTheme.colors.background)\n                                    .align(Alignment.CenterHorizontally)\n                            )\n//                        } else {\n//                            ErrorBox(\n//                                Modifier.fillMaxSize(),\n//                                title = stringResource(id = R.string.sign_in)\n//                            )\n//                            { CpNavigation.to(ModelPath.Login) }\n//                        }\n                    }\n                }\n            }\n```\n这里是中间内容区。通过使用水平分页得以实现。可以看到传入了一个参数，也就是上面底部bar用到的一个pagerState，定义了不同索引下，中间内容区展示的内容。\n\n* 首页Tab 对应 HomeView\n* 项目Tab 对应 ProjectView\n* 公众号Tab 对应 AccountView\n* 我的Tab 对应 Mine\n\n### 10.首页Tab-HomeView\n首页效果图就是上面的那个效果。\n这里再拆分下，就是轮播图+列表。\n对应 HomeView。\n\n```Kotlin\n@CompoKotlinsable\nfun HomeView(modifier: Modifier = Modifier) {\n    val viewModel: HomeViewModel = viewModel()\n    ColumnTopBarMain(modifier\n        .background(HhfTheme.colors.background),\n        stringResource(R.string.app_name)) {\n        // 内容区域，传入HomeViewModel对象\n        HomeContent(viewModel = viewModel)\n    }\n}\n```\n最外层是由顶部bar+内容区构成。\n\nColumnTabBarMain是自定义通用的一个App的组件，用于上面展示toolbar，中间区域自定义。\n```Kotlin\n@Composable\nfun ColumnTopBarMain(\n    modifier: Modifier = Modifier,\n    title: String,\n    content: @Composable ColumnScope.() -> Unit\n) {\n    Column(\n        modifier.navigationBarsPadding(),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        CpTopBar(\n            Modifier.fillMaxWidth(),\n            HhfTheme.colors.themeColor,\n            title = title,\n            actions = {\n                IconButton(onClick = {\n                    CpNavigation.to(ModelPath.Search)\n                }) {\n                    Icon(Icons.Filled.Search, contentDescription = \"search\", tint = Color.White)\n                }\n            },\n        )\n        content.invoke(this)\n    }\n}\n```\n这里具体是一个Column+CpTopBar构成\n\nCpTopBar是这样的：\n```Kotlin\n\n@Composable\nfun CpTopBar(\n    modifier: Modifier = Modifier,\n    backgroundColor: Color = Color.Transparent,\n    title: String,\n    actions: @Composable RowScope.() -> Unit = {},\n    back: (() -> Unit)? = null\n) {\n    HhTopAppBar(\n        {\n            Text(title, color = Color.White)\n        },\n        modifier = modifier,\n        backgroundColor = backgroundColor,\n        contentPadding = WindowInsets.statusBars.only(WindowInsetsSides.Horizontal + WindowInsetsSides.Top).asPaddingValues(),\n        navigationIcon = back?.run {\n            {\n                IconButton(\n                    onClick = {\n                        invoke()\n                    }\n                ) {\n                    Icon(Icons.Filled.ArrowBack, contentDescription = \"back\", tint = Color.White)\n                }\n            }\n        },\n        actions = actions,\n        elevation = 2.dp,\n    )\n}\n```\n\n里面还有自定义的HhTopAppBar\n```Kotlin\n\n@Composable\nfun HhTopAppBar(\n    title: @Composable () -> Unit,\n    modifier: Modifier = Modifier,\n    contentPadding: PaddingValues = PaddingValues(0.dp),\n    navigationIcon: @Composable (() -> Unit)? = null,\n    actions: @Composable RowScope.() -> Unit = {},\n    backgroundColor: Color = MaterialTheme.colors.primarySurface,\n    contentColor: Color = contentColorFor(backgroundColor),\n    elevation: Dp = AppBarDefaults.TopAppBarElevation,\n) {\n    TopAppBarSurface(\n        modifier = modifier,\n        backgroundColor = backgroundColor,\n        contentColor = contentColor,\n        elevation = elevation\n    ) {\n        TopAppBarContent(\n            title = title,\n            navigationIcon = navigationIcon,\n            actions = actions,\n            modifier = Modifier.padding(contentPadding)\n        )\n    }\n}\n```\n\n竟然还有自定义层：Surface是官方提供的了\n```Kotlin\n@Composable\nfun TopAppBarSurface(\n    modifier: Modifier = Modifier,\n    backgroundColor: Color = MaterialTheme.colors.primarySurface,\n    contentColor: Color = contentColorFor(backgroundColor),\n    elevation: Dp = AppBarDefaults.TopAppBarElevation,\n    content: @Composable () -> Unit,\n) {\n    Surface(\n        color = backgroundColor,\n        contentColor = contentColor,\n        elevation = elevation,\n        modifier = modifier,\n        content = content\n    )\n}\n```\n还有标题栏内容区： 这个TopAppBar是官方提供的了\n```Kotlin\n@Composable\nfun TopAppBarContent(\n    title: @Composable () -> Unit,\n    modifier: Modifier = Modifier,\n    navigationIcon: @Composable (() -> Unit)? = null,\n    actions: @Composable RowScope.() -> Unit = {},\n) {\n    TopAppBar(\n        title = title,\n        navigationIcon = navigationIcon,\n        actions = actions,\n        backgroundColor = Color.Transparent,\n        elevation = 0.dp,\n        modifier = modifier\n    )\n}\n```\n\n标题栏看完了，那就到内容区了。\n\n```Kotlin\n\n/**\n * 首页内容区\n */\n@Composable\nfun HomeContent(modifier: Modifier = Modifier, viewModel: HomeViewModel) {\n\n    /**\n     * list 为首页文章 列表数据；系统会对所有列表项进行组合和布局，无论它们是否可见，\n     * 因此如果您需要显示大量列表项（或长度未知的列表），则使用 Column 等布局可能会导致性能问题。\n     * Compose 提供了一组组件，这些组件只会对在组件视口中可见的列表项进行组合和布局。\n     */\n    val list = viewModel.viewStates.homeList.collectAsLazyPagingItems()\n\n    /**\n     * 下拉刷新组件\n     */\n    SwipeRefresh(\n        /**\n         * 状态，是否正在刷新\n         */\n        state = rememberSwipeRefreshState(viewModel.viewStates.isRefresh),\n        /**\n         * 下拉刷新回调，需要更新轮播+列表\n         */\n        onRefresh = {\n            viewModel.dispatch(HomeAction.GetBanner)\n            list.refresh()\n        }) {\n        // 内容区 使用LazyItem包裹\n        PagingItem(modifier, list = list,\n            errorBlock = {},\n            successBlock = {},\n            errorAndSuccessClick = {\n                /**\n                 * 错误后点击回调\n                 */\n                list.refresh()\n            }) {\n            /**\n             * 仅组成和放置 当前可见项 的竖直滚动列表。它允许您放置不同类型的子级内容。\n             * 例如，您可以使用LazyListScope.item添加单个项目，然后使用LazyListScope.items或者LazyListScope.itemsIndexed添加项目列表，后者有当前列表项的索引值。\n             */\n            LazyColumn{\n                /**\n                 * 单个item\n                 */\n                item {\n                    BannerPager(Modifier.height(160.dp), viewModel = viewModel)\n                }\n                /**\n                 * items集合\n                 */\n                items(it) { homeBean ->\n                    homeBean?.apply {\n                        /**\n                         * 首页文字item\n                         */\n                        HomeListItem(homeBean = this) {\n                            /**\n                             * 处理点击收藏图标 触发viewModel层调用接口\n                             */\n                            if(CacheUtils.isLogin){\n                                viewModel.dispatch(HomeAction.Collect(homeBean.id, it))\n                            }\n                            else{\n                                CpNavigation.to(ModelPath.Login)\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```\nlist 是专门用于懒加载列表，这个是存放可视区的列表。\n\n数据来源是ViewModel层的viewStates实例。\n\n```Kotlin\n/**\n * 首页状态，包装首页需要的数据\n */\ndata class HomeState(\n    /**\n     * 是否正在刷新\n     */\n    val isRefresh : Boolean = false,\n\n    /**\n     * 轮播列表，数据源\n     */\n    val bannerList: List<BannerResponse> = listOf(),\n\n    /**\n     * 首页数据\n     */\n    val homeList: Flow<PagingData<ArticleBean>> = Pager(\n        PagingConfig(PAGE_SIZE),\n        pagingSourceFactory = { HomeSource() }).flow,\n)\n```\n这个是存放到ViewModel层的首页动态数据。\n\n```Kotlin\n // 首页数据监听 通过 mutableStateOf包装 HomeState\n    var viewStates by mutableStateOf(\n        HomeState(\n            homeList = Pager(\n                PagingConfig(PAGE_SIZE),\n                pagingSourceFactory = { HomeSource() }).flow.cachedIn(viewModelScope)))\n        private set\n```\n这里用一个mutableStateof包装下。\n\n\n下面继续回到首页内容区：\n然后是一个SwipeRefresh组件,官方提供的。\n```Kotlin\n    SwipeRefresh(\n        /**\n         * 状态，是否正在刷新\n         */\n        state = rememberSwipeRefreshState(viewModel.viewStates.isRefresh),\n        /**\n         * 下拉刷新回调，需要更新轮播+列表\n         */\n        onRefresh = {\n            viewModel.dispatch(HomeAction.GetBanner)\n            list.refresh()\n        }) {\n```\n定义好下拉刷新触发事件。\n注意这个list，实际上走的是LazyPagingItems里面的一个refresh方法。\n我们在HomeState中定义的homeList是一个Flow包装列表集合。通过调用Flow中扩展的一个collectAsLazyPagingItems函数，就变成LazyPagingItems对象了。\n\n这个list我们放在PagingItem里面。\n\n然后首页内容区里面用了一个 LazyColumn，应该也是配合懒加载和复用官方实现的一个类。\n然后里面第一个item就是我们的轮播图了。\n\n```Kotlin\n/**\n * 顶部轮播图\n */\n@OptIn(ExperimentalPagerApi::class)\n@Composable\nfun BannerPager(modifier: Modifier = Modifier, viewModel: HomeViewModel) {\n    val pagerState = rememberPagerState()\n\n    /**\n     * 开启协程 内部的闭包是协程 目的是获取轮播图数据\n     */\n    LaunchedEffect(viewModel){\n        viewModel.dispatch(HomeAction.GetBanner)\n    }\n\n    /**\n     * 如需了解来自父项的约束条件并相应地设计布局，您可以使用 BoxWithConstraints。\n     * 就是外部传过来的modifier 决定子View 空间\n     */\n    BoxWithConstraints(modifier) {\n\n        /**\n         * 水平分页\n         */\n        HorizontalPager(\n            count = viewModel.viewStates.bannerList.size, // 轮播总数\n            state = pagerState // 轮播状态\n        ) { page ->\n            //  页面索引\n            when (page) {\n                viewModel.viewStates.bannerList[page].id -> {\n                    /**\n                     * 轮播图item\n                     */\n                    BannerItem(\n                        Modifier\n                            .height(maxHeight)\n                            .fillMaxWidth(), viewModel.viewStates.bannerList[page]\n                    )\n                }\n            }\n        }\n\n        /**\n         * 轮播指示器\n         */\n        if (viewModel.viewStates.bannerList.isNotEmpty()) {\n            BannerIndicator(\n                Modifier\n                    .align(Alignment.BottomCenter)\n                    .fillMaxWidth()\n                    .background(Color.Black.copy(0.2f))\n                    .padding(8.dp),viewModel, pagerState )\n        }\n\n\n    }\n}\n```\n这个轮播图里面开了个协程去获取轮播图数据，只会走一次。\n然后一个水平分页里面存放所有轮播图，轮播item为BannerItem,这个是自定义的\n```Kotlin\n@Composable\nfun BannerItem(modifier: Modifier = Modifier, data: BannerResponse) {\n    data.apply {\n        Box(modifier.clickable {\n            /**\n             * 点击图片，触发跳转WebView，通过bundle传递数据\n             */\n            CpNavigation.toBundle(ModelPath.WebView, Bundle().apply {\n                putString(webTitle, data.title)\n                putString(webUrl, data.url)\n                putBoolean(webIsCollect, false)\n                putInt(webCollectId, data.id)\n                putInt(webCollectType, 1)\n            })\n        }) {\n            /**\n             * 自定义网络图片\n             */\n            NetworkImage(\n                imagePath,\n                Modifier.fillMaxWidth(),\n                contentScale = ContentScale.FillBounds,\n                defaultImg = R.mipmap.ic_default_round\n            )\n        }\n    }\n}\n```\n\n轮播完了，就是文章item了。\n主要是为了实现这种效果\n![](./%E7%8E%A9Android-Compose%E7%89%88%E6%9C%AC-%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90/home_item.jpeg)\n\n```Kotlin\n /**\n   * items集合\n   */\nitems(it) { homeBean ->\n    homeBean?.apply {\n        /**\n        * 首页文字item\n        */\n        HomeListItem(homeBean = this) {\n            /**\n            * 处理点击收藏图标 触发viewModel层调用接口\n            */\n            if(CacheUtils.isLogin){\n                viewModel.dispatch(HomeAction.Collect(homeBean.id, it))\n            }\n            else{\n                CpNavigation.to(ModelPath.Login)\n            }\n        }\n    }\n}\n```\n这里用了items，然后遍历了 list,每个item对应一个 HomeListItem\n这里定义了一个函数，说明了点击收藏图标后的逻辑。\n\n```Kotlin\n  /**\n     * 是否收藏了，用remember包装一下bool值\n     */\n    var isCollect by remember{ mutableStateOf(homeBean.collect)}\n\n    /**\n     * 卡片布局\n     */\n    Card(\n        modifier\n            .padding(8.dp) // 内padding 8个dp\n            .clickable {\n                /**\n                 * 卡片点击事件，触发跳转webView\n                 */\n                CpNavigation.toBundle(ModelPath.WebView, Bundle().apply {\n                    putString(webTitle, homeBean.title)\n                    putString(webUrl, homeBean.link)\n                    putBoolean(webIsCollect, isCollect)\n                    putInt(webCollectId, homeBean.id)\n                    putInt(webCollectType, 0)\n                })\n            },\n        backgroundColor = HhfTheme.colors.listItem,\n        elevation = 5.dp\n    ) {\n```\n这里外层是用了Card,定义了点击item的逻辑。\n\n里面是这样的：\n```Kotlin\n Column(Modifier.padding(8.dp)) {\n                /**\n                 * 第一行 水平布局\n                 */\n                Row(verticalAlignment = Alignment.CenterVertically) {\n                    /**\n                     * 分享者没名字\n                     */\n                    Text(\n                        text = if (author.isNotEmpty()) author else shareUser,\n                        fontSize = 13.sp,\n                        color = HhfTheme.colors.textColor\n                    )\n                    /**\n                     * 显示标签\n                     */\n                    if(isShowLabel){\n                        if (type == 1) {\n                            Box(\n                                Modifier\n                                    .padding(start = 6.dp)\n                                    .border(1.dp, Color.Red, RoundedCornerShape(5.dp))\n                                    .padding(4.dp)\n                            ) {\n                                Text(stringResource(id = R.string.istop), Modifier, Color.Red, 10.sp)\n                            }\n                        }\n                        if (fresh) {\n                            Box(\n                                Modifier\n                                    .padding(start = 6.dp)\n                                    .border(1.dp, Color.Red, RoundedCornerShape(5.dp))\n                                    .padding(4.dp)\n                            ) {\n                                Text(stringResource(id = R.string.neww), Modifier, Color.Red, 10.sp)\n                            }\n                        }\n                        if (tags.isNotEmpty()) {\n                            Box(\n                                Modifier\n                                    .padding(start = 6.dp)\n                                    .border(1.dp, Color(0xFF66BB6A), RoundedCornerShape(5.dp))\n                                    .padding(4.dp)\n                            ) {\n                                Text(tags[0].name, Modifier, Color(0xFF66BB6A), 10.sp)\n                            }\n                        }\n                    }\n                    /**\n                     * 发布日期\n                     */\n                    Text(\n                        niceDate,\n                        Modifier\n                            .weight(1f)\n                            .wrapContentWidth(\n                                Alignment.End\n                            )\n                            .align(Alignment.CenterVertically),\n                        HhfTheme.colors.textColor.copy(0.6f),\n                        fontSize = 13.sp,\n                    )\n                }\n                /**\n                 * 有没有封面图\n                 */\n                if (TextUtils.isEmpty(envelopePic)) {\n                    // 没有封面图\n                    Text(\n                        title.filterHtml(),\n                        Modifier.padding(top = 12.dp),\n                        HhfTheme.colors.textColor,\n                        fontSize = 14.sp,\n                        fontWeight = FontWeight.Bold\n                    )\n                } else {\n                    // 有封面图时，中间区域展示\n                    Row(Modifier.padding(top = 12.dp)) {\n                        // 网络图片\n                        NetworkImage(\n                            envelopePic,\n                            Modifier.size(100.dp),\n                            contentScale = ContentScale.Crop,\n                            defaultImg = R.mipmap.ic_default_round\n                        )\n                        // 垂直布局\n                        Column(Modifier.padding(start = 8.dp)) {\n                            // 标题\n                            Text(\n                                title.filterHtml(),\n                                color = HhfTheme.colors.textColor,\n                                fontSize = 14.sp,\n                                maxLines = 3,\n                                style = TextStyle(fontWeight = FontWeight.Bold)\n                            )\n                            // 摘要描述\n                            Text(\n                                desc,\n                                color = HhfTheme.colors.textInactiveColor,\n                                fontSize = 13.sp,\n                                maxLines = 3,\n                                overflow = TextOverflow.Ellipsis\n                            )\n                        }\n                    }\n                }\n                // 底部水平布局\n                Row {\n                    // 文本\n                    Text(\n                        \"$superChapterName / $chapterName\",\n                        Modifier.padding(top = 12.dp),\n                        HhfTheme.colors.textColor,\n                        fontSize = 13.sp\n                    )\n                    // 图标，是否收藏了\n                    Icon(\n                        if(isCollect) Icons.Filled.Favorite else Icons.Filled.FavoriteBorder, contentDescription = \"\",\n                        Modifier\n                            .wrapContentWidth(\n                                Alignment.End\n                            )\n                            .weight(1f)\n                            .clickable {\n                                /**\n                                 * 点击收藏，触发请求\n                                 */\n                                favoriteAction(isCollect)\n                                isCollect = !isCollect\n                            },\n                        tint = HhfTheme.colors.themeColor\n                    )\n                }\n            }\n```\n\n### 11.我的Tab-Mine\n因为项目和公众号和首页基本一样，这里就不重复分析了。\n看下我的页面的效果图：\n<img src=mine.jpeg width=50%>\n要实现这样的效果，怎么处理呢？\n\n首先开启一个协程，获取用户sp数据，转成UserInfo对象\n```Kotlin\n   /**\n     * 开启协程，只走一次\n     */\n    LaunchedEffect(CacheUtils.userInfo) {\n        if (CacheUtils.userInfo != \"\") {\n            /**\n             * 根据sp文件，生产一个UserInfo对象，设置给这个我的页面使用\n             */\n            mineViewModel.dispatch(\n                MineViewEvent.SetUserInfo(\n                    Gson().fromJson(\n                        CacheUtils.userInfo, // sp文件\n                        UserInfo::class.java\n                    )\n                )\n            )\n            /**\n             * 获取积分和排名\n             */\n            mineViewModel.dispatch(MineViewEvent.GetIntegral)\n        }\n    }\n```\n这里获取积分和排名是需要走接口的\n这里会走到ViewModel层这个函数：\n```Kotlin\n    private fun getIntegral() {\n        viewModelScope.launch {\n            flow {\n                emit(\n                    TaskApi.create(ApiService::class.java).getIntegral()\n                )\n            }.map {\n                if (it.errorCode == 0) {\n                    it.data\n                        ?: throw Exception(\"data null\")\n                } else {\n                    throw Exception(it.errorMsg)\n                }\n            }.onEach {\n                viewStates = viewStates.copy(integral = it)\n            }.catch {\n                viewStates = viewStates.copy(integral = null)\n            }.collect()\n        }\n    }\n```\n这个retrofit中是这样定义的：\n```Kotlin\ninterface ApiService {\n    /**\n     * 获取当前账户的个人积分\n     */\n    @GET(\"lg/coin/userinfo/json\")\n    suspend fun getIntegral(): ApiResponse<Integral>\n```\n这个就是一个suspend挂起函数。\n\n顶层为Column:\n```Kotlin\n    /**\n     * 顶层为列表视图\n     */\n    Column(modifier) {\n        /**\n         * 顶部👤\n         */\n        MineTopAvatar(\n            Modifier\n                .fillMaxWidth()\n                .height(320.dp)\n                .clip(QureytoImageShapes(160f)),\n            mineViewModel.viewStates.userInfo?.run {\n                nickname\n            } ?: \"avatar\"\n        ) {\n```\n\n头像区域，点击后可以弹pop，但是需要先获取权限，这样获取：\n```Kotlin\n// 图片点击事件 会去申请下权限\n            XXPermissions\n                .with(context)\n                .permission(Permission.CAMERA)\n                .permission(Permission.MANAGE_EXTERNAL_STORAGE)\n                .request(object : OnPermissionCallback {\n                    override fun onGranted(\n                        granted: List<String>,\n                        all: Boolean\n                    ) {\n                        if (all) {\n                            if(isLogin){\n                                mineViewModel.dispatch(MineViewEvent.ChangePopupState(true))\n                            }\n                            else{\n                                CpNavigation.to(ModelPath.Login)\n                            }\n                        }\n                    }\n\n                    override fun onDenied(\n                        denied: List<String>,\n                        never: Boolean\n                    ) {\n                        if (never) {\n                            context.showToast(context.stringResource(R.string.permissions_cm_error))\n                            XXPermissions.startPermissionActivity(\n                                context,\n                                denied\n                            )\n                        } else {\n                            context.showToast(context.stringResource(R.string.permissions_camera_error))\n                        }\n                    }\n                })\n```\n用了一个三方库实现。\n\n中间操作栏这样实现：\n```Kotlin\n  // 操作栏 有个外边框，包裹菜单项，底部有阴影\n        Surface(\n            Modifier\n                .padding(start = 20.dp, end = 20.dp)\n                .fillMaxWidth()\n                .background(HhfTheme.colors.background),\n            elevation = 2.dp,\n            shape = RoundedCornerShape(8.dp),\n            color = MaterialTheme.colors.surface, // color will be adjusted for elevation\n        ) {\n```\n\n具体的菜单项也是用懒加载实现：\n```Kotlin\nLazyColumn(Modifier.background(HhfTheme.colors.listItem)) {\n                itemsIndexed(list) { i, bean ->\n\n                    /**\n                     * 我的页面遍历菜单项\n                     */\n                    MineItem(\n                        Modifier\n                            .fillMaxWidth()\n                            .clickable {\n                                /**\n                                 * 分发开发者行为\n                                 */\n                                mineViewModel.dispatch(MineViewEvent.ToComposable(bean.id))\n                            }\n                            .height(45.dp), bean.name, HhfTheme.colors.themeColor,\n                        bean.icon)\n                    if (i < list.size - 1) {\n                        /**\n                         * 非最后一行显示分割线\n                         */\n                        Divider(\n                            modifier = Modifier\n                                .fillMaxWidth()\n                                .padding(start = 10.dp, end = 10.dp)\n                        )\n                    }\n                }\n            }\n```\n\n具体的菜单item,有图标+文字+右侧箭头实现：\n```Kotlin\n\n@Composable\nfun MineItem(\n    modifier: Modifier = Modifier, textName: String, iconColor: Color, icon: ImageVector\n) {\n    Row(\n        modifier,\n        verticalAlignment = Alignment.CenterVertically,\n    ) {\n        Icon(\n            icon, \"$textName icon\",\n            Modifier\n                .size(28.dp)\n                .padding(start = 10.dp), iconColor\n        )\n        Text(\n            textName,\n            Modifier.padding(start = 10.dp),\n            fontSize = 14.sp,\n            fontFamily = FontFamily.Serif,\n            color = HhfTheme.colors.textColor\n        )\n        Icon(\n            Icons.Filled.KeyboardArrowRight, textName,\n            Modifier\n                .weight(1f)\n                .padding(end = 10.dp)\n                .wrapContentWidth(Alignment.End),\n            tint = HhfTheme.colors.textColor\n        )\n    }\n}\n```\n\nUI搞定了，跳转逻辑怎么处理呢？\n答案是viewModel层实现。\n\n这里有个clickable点击闭包：\n` mineViewModel.dispatch(MineViewEvent.ToComposable(bean.id))`\n\n\n会委托给mineViewModel处理：\n```Kotlin\n    /**\n     * 分发开发者行为\n     */\n    fun dispatch(action: MineViewEvent) {\n        when (action) {\n            is MineViewEvent.Blur -> bitmapBlur(action.s)\n            /**\n             * 用户点击菜单项\n             */\n            is MineViewEvent.ToComposable -> toComposable(action.type)\n            is MineViewEvent.ChangePopupState -> {\n                Log.e(\"TEST##\", \"这里触发了viewStates中 isShowpopup 变更为：${action.flag}\")\n                viewStates = viewStates.copy(isShowPopup = action.flag)\n            }\n            is MineViewEvent.SetUserInfo -> viewStates = viewStates.copy(userInfo = action.userInfo)\n            is MineViewEvent.GetIntegral -> getIntegral()\n        }\n    }\n```\n这里分发开发者行为，其实更像用户行为，有可能不是用户触发，所以我这里称之为开发者行为。\n\n点击菜单项继续分发：\n```Kotlin\nprivate fun toComposable(type: Int) {\n        if(isLogin){\n            when (type) {\n                0 -> CpNavigation.to(ModelPath.Integral)\n                1 -> CpNavigation.to(ModelPath.Collect)\n                2 -> CpNavigation.to(ModelPath.Share)\n                3 -> CpNavigation.to(ModelPath.Todo)\n                4 -> CpNavigation.toBundle(ModelPath.WebView, Bundle().apply {\n                    putString(webTitle, \"PlayAndroid\")\n                    putString(webUrl, \"https://github.com/yellowhai/PlayAndroid\")\n                    putBoolean(webIsCollect, false)\n                    putInt(webCollectId, 998)\n                    putInt(webCollectType, 1)\n                })\n                5 -> CpNavigation.to(ModelPath.Setting)\n            }\n        }\n        else{\n            when (type) {\n                4 -> CpNavigation.toBundle(ModelPath.WebView, Bundle().apply {\n                    putString(webTitle, \"PlayAndroid\")\n                    putString(webUrl, \"https://github.com/yellowhai/PlayAndroid\")\n                    putBoolean(webIsCollect, false)\n                    putInt(webCollectId, 998)\n                    putInt(webCollectType, 1)\n                })\n                5 -> CpNavigation.to(ModelPath.Setting)\n                else -> CpNavigation.to(ModelPath.Login)\n            }\n        }\n    }\n```\n这里定义了跳转逻辑，这里有回到 第8点主页外部架构 中的导航定义了。\n实现跳转到其它页面了，这更像是在布局上叠加，不算是跳转吧。\n\n这个项目还有很多细节值得一探究竟，不过对于初始compose，也差不多了，了解到这个程度也算入门了吧。\n\n\n","source":"_posts/玩Android-Compose版本-项目分析.md","raw":"---\ntitle: 玩Android Compose版本 项目分析\ndate: 2023-01-17 11:23:20\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- Android\ncategories:\n- Android\n---\n\n> 玩Android(compose版本)项目地址：[https://github.com/yellowhai/PlayAndroid](https://github.com/yellowhai/PlayAndroid)\n\n### 1.项目settings.gradle\n\n```groovy\ndependencyResolutionManagement {\n    /**\n     * 原文中说默认情况下，项目中的存储库会覆盖设置中的存储库 ，可以通过设置模式来更改这种行为\n     设置存储库的方法：\n     repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n     存储库模式：\n     PREFER_PROJECT(true)--首选项目存储库\n     PREFER_SETTINGS(false)--首选设置存储库\n     FAIL_ON_PROJECT_REPOS(false)--强制设置存储库\n     */\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories {\n        google()\n        mavenCentral()\n        maven { url \"https://jitpack.io\" }\n        maven {\n            url 'https://maven.aliyun.com/repository/public/'\n        }\n        maven { url 'https://maven.aliyun.com/repository/public' }\n        maven { url 'https://maven.aliyun.com/repository/central' }\n        maven { url 'https://maven.aliyun.com/repository/google' }\n        maven { url 'https://maven.aliyun.com/repository/public' }\n        maven { url 'https://maven.aliyun.com/repository/gradle-plugin' }\n    }\n}\nrootProject.name = \"PlayAndroid\"\ninclude ':app'\ninclude ':common'\ninclude ':h_mine'\ninclude ':toolkit'\n```\n\n还是很容易理解的，repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)这个是新增的，简单看下就行。\n引入了app模块(主模块)，common模块（通用模块，用于通用组件相关）,h_mine模块（我的模块，可以单独编译）。\n\n### 2.config.gradle\n这个文件相信大家都有用过的，配置远程依赖的一个文件，统一管理。\n```groovy\next{\n    isRelease = true\n\n    //android构建配置\n    android_models = [\n            compileSdk : 32,\n            minSdk : 23,\n            targetSdk : 32,\n            versionCode : 1,\n            versionName : \"1.0\"\n    ]\n    \n    app_id = [\n            mine      : 'com.hh.mine',\n    ]\n\n    core_ktx_version = '1.7.0'\n    appcompat_version = '1.4.0'\n    lifecycle_version = '2.4.0'\n    material_version = '1.4.0'\n    work_version = '2.7.1'\n    gson_version = '2.8.9'\n    litepal_version = '3.2.3'\n    landscapist_version = '1.4.5'\n    retrofit_version = '2.9.0'\n    okhttp_version = '4.9.3'\n    startup_version = '1.1.0'\n    XXPermissions_version = '13.2'\n    datastore_version = '1.0.0'\n    materialDialog_version = '0.6.2'\n    accompanist_version = '0.25.0'\n\n\n    jetpack_compose = [\n            material : \"androidx.compose.material:material:$compose_version\",\n            activity : \"androidx.activity:activity-compose:$appcompat_version\",\n    ]\n\n    commonApi = [\n            ktx_core        : \"androidx.core:core-ktx:$core_ktx_version\",\n            lifecycle       : \"androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version\",\n            appcompat       : \"androidx.appcompat:appcompat:$appcompat_version\",\n            material        : \"com.google.android.material:material:$material_version\",\n            //数据存储\n            datastore       : \"androidx.datastore:datastore-preferences:$datastore_version\",\n            //权限处理\n            XXPermissions   : \"com.github.getActivity:XXPermissions:$XXPermissions_version\",\n    ]\n\n    net = [\n            retrofit    : \"com.squareup.retrofit2:retrofit:$retrofit_version\",\n            converter   : \"com.squareup.retrofit2:converter-gson:$retrofit_version\",\n            okhttp      : \"com.squareup.okhttp3:logging-interceptor:$okhttp_version\",\n            gson        : \"com.google.code.gson:gson:$gson_version\"\n    ]\n\n    accompanist_ui = [\n            insets_ui    : \"com.google.accompanist:accompanist-insets-ui:$accompanist_version\",\n            navigation   : \"com.google.accompanist:accompanist-navigation-animation:$accompanist_version\",\n            pager        : \"com.google.accompanist:accompanist-pager:$accompanist_version\",\n            swiperefresh : \"com.google.accompanist:accompanist-swiperefresh:$accompanist_version\",\n            flowlayout   : \"com.google.accompanist:accompanist-flowlayout:$accompanist_version\",\n            systemUi     : \"com.google.accompanist:accompanist-systemuicontroller:$accompanist_version\",\n            webview      : \"com.google.accompanist:accompanist-webview:$accompanist_version\"\n    ]\n\n    database =[\n            litepal :  \"org.litepal.guolindev:core:$litepal_version\"\n    ]\n\n    skydoves_coil = [\n            landscapist_coil :  \"com.github.skydoves:landscapist-coil:$landscapist_version\"\n    ]\n\n    workManager = [\n            // Kotlin + coroutines\n            work = \"androidx.work:work-runtime-ktx:$work_version\"\n    ]\n\n    material_dialog = [\n            color : \"io.github.vanpra.compose-material-dialogs:color:$materialDialog_version\",\n            core  : \"io.github.vanpra.compose-material-dialogs:core:$materialDialog_version\",\n            datetime  : \"io.github.vanpra.compose-material-dialogs:datetime:$materialDialog_version\"\n    ]\n\n    paging = \"androidx.paging:paging-compose:1.0.0-alpha14\"\n\n    jetpackComposeLibs = jetpack_compose.values()\n    commonApiLibs = commonApi.values()\n    netLibs = net.values()\n    materialDialogLibs = material_dialog.values()\n}\n```\n层次还是比较清晰，对于同一组单独建立数组存储，模块中只需要引入一个就将这组全部引入进去了。\n\n### 3.app模块下的build.gradle\n\n显示引入com.android.application+kotlin-android的插件。\n下面配置android闭包，很简单。\n\n其它关于compose的也需要配置下：\n```groovy\n compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n    buildFeatures {\n        compose true\n    }\n    composeOptions {\n        kotlinCompilerExtensionVersion compose_version\n        kotlinCompilerVersion kotlin_version\n    }\n```\n\n然后是远程依赖：\n```groovy\ndependencies {\n    // 如果是release模式，就把我的模块加进来\n    if(isRelease){\n        implementation project(':h_mine')\n    }\n\n    // 初始化组件\n    implementation \"androidx.startup:startup-runtime:$startup_version\"\n    implementation project(':common')\n\n    // 测试相关\n    testImplementation 'junit:junit:4.13.2'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.3'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'\n    androidTestImplementation \"androidx.compose.ui:ui-test-junit4:$compose_version\"\n    androidTestImplementation \"androidx.compose.ui:ui-test-junit4:$compose_version\"\n    debugImplementation \"androidx.compose.ui:ui-tooling:$compose_version\"\n\n}\n```\n\nisRelease定义在 config.gradle的顶部。如果是集成编译就为true，单独编译为false。\n\n### 4.app模块的AndroidManifest.xml\n* 配置Application\n* 配置主页\n* 配置provider，用于初始化sdk\n    ```xml\n      <!--  用provider初始化sdk-->\n        <provider\n            android:name=\"androidx.startup.InitializationProvider\"\n            android:authorities=\"${applicationId}.androidx-startup\"\n            android:exported=\"false\"\n            tools:node=\"merge\">\n            <meta-data\n                android:name=\"com.hh.playandroid.base.BaseInitializer\"\n                android:value=\"androidx.startup\" />\n        </provider>\n    ```\n\n### 5.自定义Application\n ```\n class HhfApp : YshhApplication()\n ```   \n 依赖common模块：\n ```Kotlin\n open class YshhApplication : Application() {\n\n    lateinit var okbuilder: OkHttpClient\n\n    companion object {\n        /**\n         * application context.\n         */\n        @SuppressLint(\"StaticFieldLeak\")\n        lateinit var context: Context\n\n        @SuppressLint(\"StaticFieldLeak\")\n        lateinit var instance: YshhApplication\n\n        /**\n         * application级别的协程\n         * 有时我们需要在协程上下文中定义多个元素，组合协程上下文中的元素，使用 + 操作符来创建 CoroutineScope .\n         */\n        val applicationScope = CoroutineScope(SupervisorJob() + Dispatchers.Main)\n    }\n ```\n 这里懒加载OkHttpClient\n 定义了全局的协程，静态变量。\n\n ```Kotlin\n   override fun onCreate() {\n        super.onCreate()\n        context = applicationContext\n        instance = this\n        initRetrofit()\n    }\n ```\n 初始化Retrofit：\n ```Kotlin\n  /**\n     * 初始化Retrofit\n     */\n    private fun initRetrofit(token : String = \"\"): OkHttpClient {\n        //请求头\n        val headerInterceptor = Interceptor { chain: Interceptor.Chain ->\n            val orignaRequest = chain.request()\n            val request = orignaRequest.newBuilder()\n                .header(\"Authorization\", \"Bearer $token\")\n                .method(orignaRequest.method, orignaRequest.body)\n                .build()\n            chain.proceed(request)\n        }\n        val logInterceptor = LogInterceptor {\n//            it.logE()\n        }\n        // 日志类别\n        logInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);\n        // 缓存相关\n        val cacheFile =\n            File(getExternalFilesDir(Environment.DIRECTORY_PICTURES).toString() + \"http_cache\")\n        val cache = Cache(cacheFile, 104857600L) // 指定缓存大小100Mb\n        val builder = OkHttpClient.Builder()\n        //        builder.addInterceptor(addQueryParameterInterceptor);\n        builder.addInterceptor(headerInterceptor)\n        builder.cache(cache)\n        builder.addNetworkInterceptor(logInterceptor)\n        builder.cookieJar(cookieJar)\n        builder.readTimeout(60000, TimeUnit.MILLISECONDS)\n        //全局的写入超时时间60s\n        builder.writeTimeout(60000, TimeUnit.MILLISECONDS)\n        //全局的连接超时时间30s\n        builder.connectTimeout(30000, TimeUnit.MILLISECONDS)\n        okbuilder = builder.build()\n        return builder.build()\n    }\n\n    private val cookieJar: PersistentCookieJar by lazy {\n        PersistentCookieJar(SetCookieCache(), SharedPrefsCookiePersistor(context))\n    }\n    \n    fun getOkBuilder(): OkHttpClient {\n        return okbuilder\n    }\n ```\n\n ### 6.首页 MainActivity\n 继承BaseActivity:\n ```Kotlin\n\n/**\n * 基类Activity 设置非沉浸式，因为要设置导航栏和状态栏颜色\n */\nabstract class BaseActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        WindowCompat.setDecorFitsSystemWindows(window, false)\n    }\n\n}\n ```\n\nonCreate生命周期：\n```Kotlin\n @Suppress(\"DEPRECATED_IDENTITY_EQUALS\")\n    @OptIn(ExperimentalAnimationApi::class)\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        // 动画渐变\n        overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out)\n        // 设置内容\n        setContent {\n            Log.e(\"TEST##\", \"开始setContent了\")\n            // 顶层为自定义主题\n            HhfTheme(\n                // 是否暗色或亮色，跟随系统，如果用户主动设置，跟随用户\n                theme = if (isSystemInDarkTheme() || isNight) HhfTheme.Theme.Dark else HhfTheme.Theme.Light,\n                // 用户自行设置的颜色主题\n                colorTheme = appTheme\n            ) {\n                // 创建一个MainViewModel\n                val viewModel : MainViewModel = viewModel()\n\n                // 如果isSplash为true,就展示SplashView 启动页\n                if (viewModel.isSplash) {\n                    Log.e(\"TEST##\", \"加载闪屏了\")\n                    SplashView { viewModel.isSplash = false }\n                } else {\n                    Log.e(\"TEST##\", \"加载首页了\")\n                    // 全局静态变量存 底部控制器\n                    CpNavigation.navHostController = rememberAnimatedNavController()\n                    // 主页面\n                    HhfNavigation()\n                    // 进度条\n                    DialogProgress()\n                }\n                // 是否纪念日，将App置灰\n                if(isMourningDay()){\n                    Canvas(modifier = Modifier.fillMaxSize()){\n                        drawRect(color = Color.White,blendMode = BlendMode.Saturation)\n                    }\n                }\n            }\n        }\n        addCallback()\n    }\n```\n因为这个app就一个Activity，setContent中的内容就是展现给用户可以看到的所有东西了。\n顶层是一个自定义主题：\n```Kotlin\n@Composable\nfun HhfTheme(\n    theme: HhfTheme.Theme = HhfTheme.Theme.Light,\n    colorTheme: Color? = null,\n    content: @Composable () -> Unit\n) {\n    val targetColors = if (theme == HhfTheme.Theme.Dark) {\n        colorTheme?.let {\n            rememberSystemUiController().setNavigationBarColor(colorTheme)\n            DarkColorPalette.apply {\n                themeColor = it\n            }\n        }?:DarkColorPalette\n    } else {\n        colorTheme?.let {\n            rememberSystemUiController().setNavigationBarColor(colorTheme)\n            LightColorPalette.apply {\n                themeColor = it\n            }\n        }?:LightColorPalette\n    }\n    val themeColor = animateColorAsState(targetColors.themeColor, TweenSpec(600))\n    val textColor = animateColorAsState(targetColors.textColor, TweenSpec(600))\n    val background = animateColorAsState(targetColors.background,TweenSpec(600))\n    val listItem =  animateColorAsState(targetColors.listItem,TweenSpec(600))\n    val bottomBar =  animateColorAsState(targetColors.bottomBar,TweenSpec(600))\n    val divider =  animateColorAsState(targetColors.divider,TweenSpec(600))\n    val textFieldBackground =  animateColorAsState(targetColors.textFieldBackground,TweenSpec(600))\n    val colors = HhfColors(themeColor.value,\n        textColor.value,\n        background = background.value,\n        listItem = listItem.value,\n        bottomBar = bottomBar.value,\n        divider = divider.value,\n        textFieldBackground = textFieldBackground.value,\n        )\n    CompositionLocalProvider(LocalHhfColors provides colors) {\n        MaterialTheme(\n            shapes = Shapes,\n            typography = typography\n        ) {\n            content.invoke()\n        }\n    }\n}\n```\n这里用到了一个 CompositionLocalProvider，具体用法可以参考 [https://juejin.cn/post/7097890697721675813](https://juejin.cn/post/7097890697721675813)\n\n在Compose函数里，如果要用到函数外提供的值，一般都要通过函数定义好参数，外部调用时传入进去。\n这种方法表面看没啥问题，但在一些场景下就不是很方便。比如一个函数A嵌套一个函数B，函数B嵌套函数C，并且这A、B、C的函数都用到这个参数，那对三个函数来说都需要定义这个参数，就不是那么方便。\n那用个全局变量不就可以解决需要重复定义参数，确实可以。但全局变量有个副作用就是影响的范围比较大。本身我们定义的参数只会影响到函数内部。这个时候我们就可以使用CompositionLocal：它具有穿透函数功能的局部变量\nCompositionLocal适用场景：用来提供上下文数据，不扩大影响范围。\n\n然后最终主题呈现是用了 MaterialTheme这个类展现。\n\n回到首页，内容区：\n* 闪屏页展示逻辑\n    通过一个变量：`  var isSplash by mutableStateOf(true)` 实现控制是否显示\n*  加载首页\n    先 展示主页面，覆盖一层 进度条\n* 是否纪念日\n    app置灰处理    \n* 添加二次点击返回退出app逻辑\n\n首页逻辑基本就这么多了。\n\n### 7.闪屏ui -> SplashView\n看下效果先：\n<img src=%E9%97%AA%E5%B1%8F%E9%A1%B5.gif width = 50%>\n\n可以看到进入app后有个启动页面，中间是logo。\n那这个页面有个渐变动画，淡入淡出效果。\n\n具体ui是这样的：\n```Kotlin\n@Composable\nfun SplashView(startMain: () -> Unit) {\n    /**\n     * 辅助文字颜色变化 建立的一个mutableState包装的变量，实际上就是bool值\n     */\n    var enabled by remember { mutableStateOf(false) }\n\n    /**\n     * 背景颜色，从0.3alpha主题色变为纯主题色，2s的时间\n     */\n    val bgColor: Color by animateColorAsState(\n        if (enabled) HhfTheme.colors.themeColor\n        else HhfTheme.colors.themeColor.copy(alpha = 0.3f),\n        animationSpec = tween(durationMillis = 2000)\n    )\n\n    /**\n     * 中间文字颜色动画，如果enable为false，0.3alpha的颜色 到纯白色 2s的时间\n     */\n    val textColor: Color by animateColorAsState(\n        if (enabled) Color.White\n        else Color.White.copy(alpha = 0.3f),\n        animationSpec = tween(durationMillis = 2000)\n    )\n\n    // 外层一个Box+中间一个Text\n    Box(\n        Modifier\n            .fillMaxSize()\n            .background(bgColor),\n        contentAlignment = Alignment.Center\n    ) {\n        Text(text = \"PlayAndroid\", color = textColor,style = MaterialTheme.typography.h5)\n    }\n\n    // 开启协程 可以看出Compose里面开启协程的方法\n    LaunchedEffect(Unit) {\n        enabled = true\n        delay(2000)\n        // 2s后，设置 mutableStateOf 包装的bool变量 为false 会通知首页重新走setContent方法\n        startMain.invoke()\n    }\n}\n```\n\n这里需要理解 animateColorAsState 是官方提供的一个动画，支持颜色变化的一个composable方法。\n\n然后这里开启了2s延迟，怎么开延迟的，调用LaunchedEffect方法里面的delay，可以实现延迟效果。然后执行startMain回调。\n\n这个回调很简单：viewModel.isSplash = false\n\n虽然很简单，但实际上走了很多流程的。\n\n```Kotlin\nclass MainViewModel : ViewModel() {\n    var isSplash by mutableStateOf(true)\n}\n```\n这里使用mutableStateOf包装了一个布尔值。 上面触发这改变时，会刷新composable注解声明的方法体。这里应该就是刷新MainActivity整个内容区了。\n\n\n### 8.主页面外部架构\n```Kotlin\n@ExperimentalAnimationApi\n@OptIn(ExperimentalPagerApi::class)\n@Composable\nfun HhfNavigation() {\n    AnimatedNavHost(navController = CpNavigation.navHostController,\n        /**\n         * 首页默认页面\n         */\n        startDestination = ModelPath.Main.route,\n        enterTransition = { fadeIn(animationSpec = tween(700), initialAlpha = 0f) },\n        exitTransition = { fadeOut(animationSpec = tween(700), targetAlpha = 0f) }) {\n\n        /**\n         * 定义接收到 main 路由消息后->展示MainContent视图\n         */\n        composable(ModelPath.Main.route) {\n            MainContent()\n        }\n\n        /**\n         * 接收到 setting 路由消息后 -> 设置页面\n         */\n        composable(ModelPath.Setting.route) {\n            CpSetting(Modifier.fillMaxSize())\n        }\n        ...\n```\n\n这里使用了一个AnimatedNavHost，这个类是官方提供的。\n这个类里面定义了所有我们需要跳转的页面和初始页。\n然后这个 需要传一个参数，也就是控制器：\n` CpNavigation.navHostController = rememberAnimatedNavController()`\n这里也是官方提供的remember包装的一个控制器。\n\n这里的初始页为：`  startDestination = ModelPath.Main.route,`\n本质上就是一个string，首页的路由。\n\n这样会默认展示首页，怎么展示首页呢？\n```Kotlin\ncomposable(ModelPath.Main.route) {\n            MainContent()\n        }\n```\n那么这个MainContent就是我们的首页。\n\n其它composable里面都是首页可能去哪些页面的路由定义。\n\n那这个比如跳转到设置页面，怎么处理呢？\n* 首先在这个AnimatedNavHost里面定义一个composable闭包\n```Kotlin\n composable(ModelPath.Setting.route) {\n            CpSetting(Modifier.fillMaxSize())\n        }\n```\n\n* 然后再需要跳转的地方调用\n`navHostController.navigate(“setting”)`\n这个navHostController就是我们之前定义的那个控制器，setting就是路由名称。\n这样子就可以跳转到设置页面了。\n\n### 9.主页内部架构框\n首先看下主页效果图\n<img src=%E9%A6%96%E9%A1%B5.jpeg width=50%>\n轮播图+中间列表+底部bar\n轮播图+中间列表可以看成一个整体，那就是内容区+底部bar\n\n架构怎么搭建呢？\n```Kotlin\n   Scaffold(bottomBar = {\n        AnimatedVisibility(\n            visible = bottomSwitch,\n            enter = expandVertically() + fadeIn(), // 操作符重载了，第一个为空，就用第二个\n            exit = shrinkVertically() + fadeOut()  // 操作符重载了，第一个为空，就用第二个\n        ) {\n            // 实际的底部bar 高度使用 固有特性测量 可以参考：https://juejin.cn/post/7068164264363556872\n            MainBottomBar(\n                Modifier\n                    .fillMaxWidth()\n                    .height(IntrinsicSize.Max),pagerState = pagerState) {\n                pagerState.reenableScrolling(coroutineScope, it)\n            }\n        }\n    }) {\n        内容区...\n```\n最外层一个Scafffold脚手架包裹，有点像Flutter了啊。\n然后是一个AnimatedVisibility，这个控制显示隐藏的动画组件。重点看里面的MainBottomBar，就找到了我们的底部bar了。\n\n这个看起来像自定义的，具体怎么实现的呢？\n```Kotlin\n/**\n * App底部bar\n */\n@OptIn(ExperimentalPagerApi::class)\n@Composable\nprivate fun MainBottomBar(\n    modifier: Modifier = Modifier,\n    pagerState: PagerState,\n    currentChanged: (Int) -> Unit\n) {\n    /**\n     * 这个BottomAppBar是官方的\n     */\n    BottomAppBar(\n        modifier.navigationBarsPadding(),\n        cutoutShape = CircleShape,\n        backgroundColor = HhfTheme.colors.bottomBar,\n        elevation = 5.dp\n    ) {\n        // 遍历4个tab\n        bottomList.forEachIndexed { index, item ->\n            // item单独设置 官方组件\n            BottomNavigationItem(\n                selected = pagerState.currentPage == index, onClick = {\n                    /**\n                     * item点击事件回调给上层\n                     */\n                    currentChanged(index)\n                }, icon = {\n                    /**\n                     * icon为官方组件\n                     */\n                    Icon(\n                        item.dashboardState.icon,\n                        contentDescription = item.name,\n                        tint = if (pagerState.currentPage == index) {\n                            HhfTheme.colors.themeColor\n                        } else {\n                            LocalContentColor.current.copy(alpha = LocalContentAlpha.current)\n                        }, modifier = Modifier.size(24.dp)\n                    )\n                }, label = {\n                    Text(\n                        text = item.name,\n                        color = if (pagerState.currentPage == index) {\n                            HhfTheme.colors.themeColor\n                        } else {\n                            LocalContentColor.current.copy(alpha = LocalContentAlpha.current)\n                        },\n                        fontSize = 12.sp\n                    )\n                },\n                unselectedContentColor = LocalContentColor.current.copy(alpha = LocalContentAlpha.current),\n                selectedContentColor = HhfTheme.colors.themeColor,\n                alwaysShowLabel = true\n\n            )\n        }\n    }\n}\n```\n这里看出底部bar就是用了官方的BottomAppBar。\n里面具体内容是我们开发者自行设定的，这里遍历了bottomList，这个集合就是我们自己定义的一个集合：\n```Kotlin\n/**\n * 底部List集合 这里定义了4块\n * 首页，项目，公众号，我的\n */\nval bottomList = listOf(\n    BottomBean(\n        DashboardState.Home,\n        YshhApplication.context.stringResource(R.string.main_title_home)\n    ),\n    BottomBean(\n        DashboardState.Project,\n        YshhApplication.context.stringResource(R.string.main_title_project)\n    ),\n    BottomBean(\n        DashboardState.PubAccount,\n        YshhApplication.context.stringResource(R.string.main_title_account)\n    ),\n    BottomBean(\n        DashboardState.Mine,\n        YshhApplication.context.stringResource(R.string.main_title_mine)\n    )\n)\n```\n就这几个模块。\n\n底部bar的item就是 BottomNavigationitem里面的了，可以看到是一个icon+label构成。有个onClick的参数就是点击事件回调了，这里调用了 回调函数，传递给上层了，传出去的参数就一个int，表示第几页。\n\n回调到哪里呢？\n```Kotlin\n // 实际的底部bar 高度使用 固有特性测量 可以参考：https://juejin.cn/post/7068164264363556872\n            MainBottomBar(\n                Modifier\n                    .fillMaxWidth()\n                    .height(IntrinsicSize.Max),pagerState = pagerState) {\n                pagerState.reenableScrolling(coroutineScope, it)\n            }\n```\n这里通过调用rememberPagerState这个对象的`  pagerState.reenableScrolling(coroutineScope, it)`这个方法实现滚动到目标tab下。也就实现了页面切换。\n最为关键的就是这个pagerState，同步页面数据和底部bar。\n\n等下分析内容区也会用到。\n\n```Kotlin\n // 水平分页\n            HorizontalPager(\n                count = bottomList.size,\n                modifier.weight(1f), pagerState, userScrollEnabled = true\n            ) { page ->\n                when (page) {\n                    // 首页tab\n                    0 -> HomeView(\n                        Modifier\n                            .fillMaxSize()\n                            .background(HhfTheme.colors.background)\n                            .align(Alignment.CenterHorizontally)\n                    )\n                    // 项目tab\n                    1 -> ProjectView(\n                        Modifier\n                            .fillMaxSize()\n                            .align(Alignment.CenterHorizontally)\n                    )\n                    // 公众号tab\n                    2 -> AccountView(\n                        Modifier\n                            .fillMaxSize()\n                            .background(HhfTheme.colors.background)\n                            .align(Alignment.CenterHorizontally)\n                    )\n                    // 我的tab\n                    3 -> {\n//                        if (isLogin) {\n                            Mine(\n                                Modifier\n                                    .fillMaxSize()\n                                    .background(HhfTheme.colors.background)\n                                    .align(Alignment.CenterHorizontally)\n                            )\n//                        } else {\n//                            ErrorBox(\n//                                Modifier.fillMaxSize(),\n//                                title = stringResource(id = R.string.sign_in)\n//                            )\n//                            { CpNavigation.to(ModelPath.Login) }\n//                        }\n                    }\n                }\n            }\n```\n这里是中间内容区。通过使用水平分页得以实现。可以看到传入了一个参数，也就是上面底部bar用到的一个pagerState，定义了不同索引下，中间内容区展示的内容。\n\n* 首页Tab 对应 HomeView\n* 项目Tab 对应 ProjectView\n* 公众号Tab 对应 AccountView\n* 我的Tab 对应 Mine\n\n### 10.首页Tab-HomeView\n首页效果图就是上面的那个效果。\n这里再拆分下，就是轮播图+列表。\n对应 HomeView。\n\n```Kotlin\n@CompoKotlinsable\nfun HomeView(modifier: Modifier = Modifier) {\n    val viewModel: HomeViewModel = viewModel()\n    ColumnTopBarMain(modifier\n        .background(HhfTheme.colors.background),\n        stringResource(R.string.app_name)) {\n        // 内容区域，传入HomeViewModel对象\n        HomeContent(viewModel = viewModel)\n    }\n}\n```\n最外层是由顶部bar+内容区构成。\n\nColumnTabBarMain是自定义通用的一个App的组件，用于上面展示toolbar，中间区域自定义。\n```Kotlin\n@Composable\nfun ColumnTopBarMain(\n    modifier: Modifier = Modifier,\n    title: String,\n    content: @Composable ColumnScope.() -> Unit\n) {\n    Column(\n        modifier.navigationBarsPadding(),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        CpTopBar(\n            Modifier.fillMaxWidth(),\n            HhfTheme.colors.themeColor,\n            title = title,\n            actions = {\n                IconButton(onClick = {\n                    CpNavigation.to(ModelPath.Search)\n                }) {\n                    Icon(Icons.Filled.Search, contentDescription = \"search\", tint = Color.White)\n                }\n            },\n        )\n        content.invoke(this)\n    }\n}\n```\n这里具体是一个Column+CpTopBar构成\n\nCpTopBar是这样的：\n```Kotlin\n\n@Composable\nfun CpTopBar(\n    modifier: Modifier = Modifier,\n    backgroundColor: Color = Color.Transparent,\n    title: String,\n    actions: @Composable RowScope.() -> Unit = {},\n    back: (() -> Unit)? = null\n) {\n    HhTopAppBar(\n        {\n            Text(title, color = Color.White)\n        },\n        modifier = modifier,\n        backgroundColor = backgroundColor,\n        contentPadding = WindowInsets.statusBars.only(WindowInsetsSides.Horizontal + WindowInsetsSides.Top).asPaddingValues(),\n        navigationIcon = back?.run {\n            {\n                IconButton(\n                    onClick = {\n                        invoke()\n                    }\n                ) {\n                    Icon(Icons.Filled.ArrowBack, contentDescription = \"back\", tint = Color.White)\n                }\n            }\n        },\n        actions = actions,\n        elevation = 2.dp,\n    )\n}\n```\n\n里面还有自定义的HhTopAppBar\n```Kotlin\n\n@Composable\nfun HhTopAppBar(\n    title: @Composable () -> Unit,\n    modifier: Modifier = Modifier,\n    contentPadding: PaddingValues = PaddingValues(0.dp),\n    navigationIcon: @Composable (() -> Unit)? = null,\n    actions: @Composable RowScope.() -> Unit = {},\n    backgroundColor: Color = MaterialTheme.colors.primarySurface,\n    contentColor: Color = contentColorFor(backgroundColor),\n    elevation: Dp = AppBarDefaults.TopAppBarElevation,\n) {\n    TopAppBarSurface(\n        modifier = modifier,\n        backgroundColor = backgroundColor,\n        contentColor = contentColor,\n        elevation = elevation\n    ) {\n        TopAppBarContent(\n            title = title,\n            navigationIcon = navigationIcon,\n            actions = actions,\n            modifier = Modifier.padding(contentPadding)\n        )\n    }\n}\n```\n\n竟然还有自定义层：Surface是官方提供的了\n```Kotlin\n@Composable\nfun TopAppBarSurface(\n    modifier: Modifier = Modifier,\n    backgroundColor: Color = MaterialTheme.colors.primarySurface,\n    contentColor: Color = contentColorFor(backgroundColor),\n    elevation: Dp = AppBarDefaults.TopAppBarElevation,\n    content: @Composable () -> Unit,\n) {\n    Surface(\n        color = backgroundColor,\n        contentColor = contentColor,\n        elevation = elevation,\n        modifier = modifier,\n        content = content\n    )\n}\n```\n还有标题栏内容区： 这个TopAppBar是官方提供的了\n```Kotlin\n@Composable\nfun TopAppBarContent(\n    title: @Composable () -> Unit,\n    modifier: Modifier = Modifier,\n    navigationIcon: @Composable (() -> Unit)? = null,\n    actions: @Composable RowScope.() -> Unit = {},\n) {\n    TopAppBar(\n        title = title,\n        navigationIcon = navigationIcon,\n        actions = actions,\n        backgroundColor = Color.Transparent,\n        elevation = 0.dp,\n        modifier = modifier\n    )\n}\n```\n\n标题栏看完了，那就到内容区了。\n\n```Kotlin\n\n/**\n * 首页内容区\n */\n@Composable\nfun HomeContent(modifier: Modifier = Modifier, viewModel: HomeViewModel) {\n\n    /**\n     * list 为首页文章 列表数据；系统会对所有列表项进行组合和布局，无论它们是否可见，\n     * 因此如果您需要显示大量列表项（或长度未知的列表），则使用 Column 等布局可能会导致性能问题。\n     * Compose 提供了一组组件，这些组件只会对在组件视口中可见的列表项进行组合和布局。\n     */\n    val list = viewModel.viewStates.homeList.collectAsLazyPagingItems()\n\n    /**\n     * 下拉刷新组件\n     */\n    SwipeRefresh(\n        /**\n         * 状态，是否正在刷新\n         */\n        state = rememberSwipeRefreshState(viewModel.viewStates.isRefresh),\n        /**\n         * 下拉刷新回调，需要更新轮播+列表\n         */\n        onRefresh = {\n            viewModel.dispatch(HomeAction.GetBanner)\n            list.refresh()\n        }) {\n        // 内容区 使用LazyItem包裹\n        PagingItem(modifier, list = list,\n            errorBlock = {},\n            successBlock = {},\n            errorAndSuccessClick = {\n                /**\n                 * 错误后点击回调\n                 */\n                list.refresh()\n            }) {\n            /**\n             * 仅组成和放置 当前可见项 的竖直滚动列表。它允许您放置不同类型的子级内容。\n             * 例如，您可以使用LazyListScope.item添加单个项目，然后使用LazyListScope.items或者LazyListScope.itemsIndexed添加项目列表，后者有当前列表项的索引值。\n             */\n            LazyColumn{\n                /**\n                 * 单个item\n                 */\n                item {\n                    BannerPager(Modifier.height(160.dp), viewModel = viewModel)\n                }\n                /**\n                 * items集合\n                 */\n                items(it) { homeBean ->\n                    homeBean?.apply {\n                        /**\n                         * 首页文字item\n                         */\n                        HomeListItem(homeBean = this) {\n                            /**\n                             * 处理点击收藏图标 触发viewModel层调用接口\n                             */\n                            if(CacheUtils.isLogin){\n                                viewModel.dispatch(HomeAction.Collect(homeBean.id, it))\n                            }\n                            else{\n                                CpNavigation.to(ModelPath.Login)\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```\nlist 是专门用于懒加载列表，这个是存放可视区的列表。\n\n数据来源是ViewModel层的viewStates实例。\n\n```Kotlin\n/**\n * 首页状态，包装首页需要的数据\n */\ndata class HomeState(\n    /**\n     * 是否正在刷新\n     */\n    val isRefresh : Boolean = false,\n\n    /**\n     * 轮播列表，数据源\n     */\n    val bannerList: List<BannerResponse> = listOf(),\n\n    /**\n     * 首页数据\n     */\n    val homeList: Flow<PagingData<ArticleBean>> = Pager(\n        PagingConfig(PAGE_SIZE),\n        pagingSourceFactory = { HomeSource() }).flow,\n)\n```\n这个是存放到ViewModel层的首页动态数据。\n\n```Kotlin\n // 首页数据监听 通过 mutableStateOf包装 HomeState\n    var viewStates by mutableStateOf(\n        HomeState(\n            homeList = Pager(\n                PagingConfig(PAGE_SIZE),\n                pagingSourceFactory = { HomeSource() }).flow.cachedIn(viewModelScope)))\n        private set\n```\n这里用一个mutableStateof包装下。\n\n\n下面继续回到首页内容区：\n然后是一个SwipeRefresh组件,官方提供的。\n```Kotlin\n    SwipeRefresh(\n        /**\n         * 状态，是否正在刷新\n         */\n        state = rememberSwipeRefreshState(viewModel.viewStates.isRefresh),\n        /**\n         * 下拉刷新回调，需要更新轮播+列表\n         */\n        onRefresh = {\n            viewModel.dispatch(HomeAction.GetBanner)\n            list.refresh()\n        }) {\n```\n定义好下拉刷新触发事件。\n注意这个list，实际上走的是LazyPagingItems里面的一个refresh方法。\n我们在HomeState中定义的homeList是一个Flow包装列表集合。通过调用Flow中扩展的一个collectAsLazyPagingItems函数，就变成LazyPagingItems对象了。\n\n这个list我们放在PagingItem里面。\n\n然后首页内容区里面用了一个 LazyColumn，应该也是配合懒加载和复用官方实现的一个类。\n然后里面第一个item就是我们的轮播图了。\n\n```Kotlin\n/**\n * 顶部轮播图\n */\n@OptIn(ExperimentalPagerApi::class)\n@Composable\nfun BannerPager(modifier: Modifier = Modifier, viewModel: HomeViewModel) {\n    val pagerState = rememberPagerState()\n\n    /**\n     * 开启协程 内部的闭包是协程 目的是获取轮播图数据\n     */\n    LaunchedEffect(viewModel){\n        viewModel.dispatch(HomeAction.GetBanner)\n    }\n\n    /**\n     * 如需了解来自父项的约束条件并相应地设计布局，您可以使用 BoxWithConstraints。\n     * 就是外部传过来的modifier 决定子View 空间\n     */\n    BoxWithConstraints(modifier) {\n\n        /**\n         * 水平分页\n         */\n        HorizontalPager(\n            count = viewModel.viewStates.bannerList.size, // 轮播总数\n            state = pagerState // 轮播状态\n        ) { page ->\n            //  页面索引\n            when (page) {\n                viewModel.viewStates.bannerList[page].id -> {\n                    /**\n                     * 轮播图item\n                     */\n                    BannerItem(\n                        Modifier\n                            .height(maxHeight)\n                            .fillMaxWidth(), viewModel.viewStates.bannerList[page]\n                    )\n                }\n            }\n        }\n\n        /**\n         * 轮播指示器\n         */\n        if (viewModel.viewStates.bannerList.isNotEmpty()) {\n            BannerIndicator(\n                Modifier\n                    .align(Alignment.BottomCenter)\n                    .fillMaxWidth()\n                    .background(Color.Black.copy(0.2f))\n                    .padding(8.dp),viewModel, pagerState )\n        }\n\n\n    }\n}\n```\n这个轮播图里面开了个协程去获取轮播图数据，只会走一次。\n然后一个水平分页里面存放所有轮播图，轮播item为BannerItem,这个是自定义的\n```Kotlin\n@Composable\nfun BannerItem(modifier: Modifier = Modifier, data: BannerResponse) {\n    data.apply {\n        Box(modifier.clickable {\n            /**\n             * 点击图片，触发跳转WebView，通过bundle传递数据\n             */\n            CpNavigation.toBundle(ModelPath.WebView, Bundle().apply {\n                putString(webTitle, data.title)\n                putString(webUrl, data.url)\n                putBoolean(webIsCollect, false)\n                putInt(webCollectId, data.id)\n                putInt(webCollectType, 1)\n            })\n        }) {\n            /**\n             * 自定义网络图片\n             */\n            NetworkImage(\n                imagePath,\n                Modifier.fillMaxWidth(),\n                contentScale = ContentScale.FillBounds,\n                defaultImg = R.mipmap.ic_default_round\n            )\n        }\n    }\n}\n```\n\n轮播完了，就是文章item了。\n主要是为了实现这种效果\n![](./%E7%8E%A9Android-Compose%E7%89%88%E6%9C%AC-%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90/home_item.jpeg)\n\n```Kotlin\n /**\n   * items集合\n   */\nitems(it) { homeBean ->\n    homeBean?.apply {\n        /**\n        * 首页文字item\n        */\n        HomeListItem(homeBean = this) {\n            /**\n            * 处理点击收藏图标 触发viewModel层调用接口\n            */\n            if(CacheUtils.isLogin){\n                viewModel.dispatch(HomeAction.Collect(homeBean.id, it))\n            }\n            else{\n                CpNavigation.to(ModelPath.Login)\n            }\n        }\n    }\n}\n```\n这里用了items，然后遍历了 list,每个item对应一个 HomeListItem\n这里定义了一个函数，说明了点击收藏图标后的逻辑。\n\n```Kotlin\n  /**\n     * 是否收藏了，用remember包装一下bool值\n     */\n    var isCollect by remember{ mutableStateOf(homeBean.collect)}\n\n    /**\n     * 卡片布局\n     */\n    Card(\n        modifier\n            .padding(8.dp) // 内padding 8个dp\n            .clickable {\n                /**\n                 * 卡片点击事件，触发跳转webView\n                 */\n                CpNavigation.toBundle(ModelPath.WebView, Bundle().apply {\n                    putString(webTitle, homeBean.title)\n                    putString(webUrl, homeBean.link)\n                    putBoolean(webIsCollect, isCollect)\n                    putInt(webCollectId, homeBean.id)\n                    putInt(webCollectType, 0)\n                })\n            },\n        backgroundColor = HhfTheme.colors.listItem,\n        elevation = 5.dp\n    ) {\n```\n这里外层是用了Card,定义了点击item的逻辑。\n\n里面是这样的：\n```Kotlin\n Column(Modifier.padding(8.dp)) {\n                /**\n                 * 第一行 水平布局\n                 */\n                Row(verticalAlignment = Alignment.CenterVertically) {\n                    /**\n                     * 分享者没名字\n                     */\n                    Text(\n                        text = if (author.isNotEmpty()) author else shareUser,\n                        fontSize = 13.sp,\n                        color = HhfTheme.colors.textColor\n                    )\n                    /**\n                     * 显示标签\n                     */\n                    if(isShowLabel){\n                        if (type == 1) {\n                            Box(\n                                Modifier\n                                    .padding(start = 6.dp)\n                                    .border(1.dp, Color.Red, RoundedCornerShape(5.dp))\n                                    .padding(4.dp)\n                            ) {\n                                Text(stringResource(id = R.string.istop), Modifier, Color.Red, 10.sp)\n                            }\n                        }\n                        if (fresh) {\n                            Box(\n                                Modifier\n                                    .padding(start = 6.dp)\n                                    .border(1.dp, Color.Red, RoundedCornerShape(5.dp))\n                                    .padding(4.dp)\n                            ) {\n                                Text(stringResource(id = R.string.neww), Modifier, Color.Red, 10.sp)\n                            }\n                        }\n                        if (tags.isNotEmpty()) {\n                            Box(\n                                Modifier\n                                    .padding(start = 6.dp)\n                                    .border(1.dp, Color(0xFF66BB6A), RoundedCornerShape(5.dp))\n                                    .padding(4.dp)\n                            ) {\n                                Text(tags[0].name, Modifier, Color(0xFF66BB6A), 10.sp)\n                            }\n                        }\n                    }\n                    /**\n                     * 发布日期\n                     */\n                    Text(\n                        niceDate,\n                        Modifier\n                            .weight(1f)\n                            .wrapContentWidth(\n                                Alignment.End\n                            )\n                            .align(Alignment.CenterVertically),\n                        HhfTheme.colors.textColor.copy(0.6f),\n                        fontSize = 13.sp,\n                    )\n                }\n                /**\n                 * 有没有封面图\n                 */\n                if (TextUtils.isEmpty(envelopePic)) {\n                    // 没有封面图\n                    Text(\n                        title.filterHtml(),\n                        Modifier.padding(top = 12.dp),\n                        HhfTheme.colors.textColor,\n                        fontSize = 14.sp,\n                        fontWeight = FontWeight.Bold\n                    )\n                } else {\n                    // 有封面图时，中间区域展示\n                    Row(Modifier.padding(top = 12.dp)) {\n                        // 网络图片\n                        NetworkImage(\n                            envelopePic,\n                            Modifier.size(100.dp),\n                            contentScale = ContentScale.Crop,\n                            defaultImg = R.mipmap.ic_default_round\n                        )\n                        // 垂直布局\n                        Column(Modifier.padding(start = 8.dp)) {\n                            // 标题\n                            Text(\n                                title.filterHtml(),\n                                color = HhfTheme.colors.textColor,\n                                fontSize = 14.sp,\n                                maxLines = 3,\n                                style = TextStyle(fontWeight = FontWeight.Bold)\n                            )\n                            // 摘要描述\n                            Text(\n                                desc,\n                                color = HhfTheme.colors.textInactiveColor,\n                                fontSize = 13.sp,\n                                maxLines = 3,\n                                overflow = TextOverflow.Ellipsis\n                            )\n                        }\n                    }\n                }\n                // 底部水平布局\n                Row {\n                    // 文本\n                    Text(\n                        \"$superChapterName / $chapterName\",\n                        Modifier.padding(top = 12.dp),\n                        HhfTheme.colors.textColor,\n                        fontSize = 13.sp\n                    )\n                    // 图标，是否收藏了\n                    Icon(\n                        if(isCollect) Icons.Filled.Favorite else Icons.Filled.FavoriteBorder, contentDescription = \"\",\n                        Modifier\n                            .wrapContentWidth(\n                                Alignment.End\n                            )\n                            .weight(1f)\n                            .clickable {\n                                /**\n                                 * 点击收藏，触发请求\n                                 */\n                                favoriteAction(isCollect)\n                                isCollect = !isCollect\n                            },\n                        tint = HhfTheme.colors.themeColor\n                    )\n                }\n            }\n```\n\n### 11.我的Tab-Mine\n因为项目和公众号和首页基本一样，这里就不重复分析了。\n看下我的页面的效果图：\n<img src=mine.jpeg width=50%>\n要实现这样的效果，怎么处理呢？\n\n首先开启一个协程，获取用户sp数据，转成UserInfo对象\n```Kotlin\n   /**\n     * 开启协程，只走一次\n     */\n    LaunchedEffect(CacheUtils.userInfo) {\n        if (CacheUtils.userInfo != \"\") {\n            /**\n             * 根据sp文件，生产一个UserInfo对象，设置给这个我的页面使用\n             */\n            mineViewModel.dispatch(\n                MineViewEvent.SetUserInfo(\n                    Gson().fromJson(\n                        CacheUtils.userInfo, // sp文件\n                        UserInfo::class.java\n                    )\n                )\n            )\n            /**\n             * 获取积分和排名\n             */\n            mineViewModel.dispatch(MineViewEvent.GetIntegral)\n        }\n    }\n```\n这里获取积分和排名是需要走接口的\n这里会走到ViewModel层这个函数：\n```Kotlin\n    private fun getIntegral() {\n        viewModelScope.launch {\n            flow {\n                emit(\n                    TaskApi.create(ApiService::class.java).getIntegral()\n                )\n            }.map {\n                if (it.errorCode == 0) {\n                    it.data\n                        ?: throw Exception(\"data null\")\n                } else {\n                    throw Exception(it.errorMsg)\n                }\n            }.onEach {\n                viewStates = viewStates.copy(integral = it)\n            }.catch {\n                viewStates = viewStates.copy(integral = null)\n            }.collect()\n        }\n    }\n```\n这个retrofit中是这样定义的：\n```Kotlin\ninterface ApiService {\n    /**\n     * 获取当前账户的个人积分\n     */\n    @GET(\"lg/coin/userinfo/json\")\n    suspend fun getIntegral(): ApiResponse<Integral>\n```\n这个就是一个suspend挂起函数。\n\n顶层为Column:\n```Kotlin\n    /**\n     * 顶层为列表视图\n     */\n    Column(modifier) {\n        /**\n         * 顶部👤\n         */\n        MineTopAvatar(\n            Modifier\n                .fillMaxWidth()\n                .height(320.dp)\n                .clip(QureytoImageShapes(160f)),\n            mineViewModel.viewStates.userInfo?.run {\n                nickname\n            } ?: \"avatar\"\n        ) {\n```\n\n头像区域，点击后可以弹pop，但是需要先获取权限，这样获取：\n```Kotlin\n// 图片点击事件 会去申请下权限\n            XXPermissions\n                .with(context)\n                .permission(Permission.CAMERA)\n                .permission(Permission.MANAGE_EXTERNAL_STORAGE)\n                .request(object : OnPermissionCallback {\n                    override fun onGranted(\n                        granted: List<String>,\n                        all: Boolean\n                    ) {\n                        if (all) {\n                            if(isLogin){\n                                mineViewModel.dispatch(MineViewEvent.ChangePopupState(true))\n                            }\n                            else{\n                                CpNavigation.to(ModelPath.Login)\n                            }\n                        }\n                    }\n\n                    override fun onDenied(\n                        denied: List<String>,\n                        never: Boolean\n                    ) {\n                        if (never) {\n                            context.showToast(context.stringResource(R.string.permissions_cm_error))\n                            XXPermissions.startPermissionActivity(\n                                context,\n                                denied\n                            )\n                        } else {\n                            context.showToast(context.stringResource(R.string.permissions_camera_error))\n                        }\n                    }\n                })\n```\n用了一个三方库实现。\n\n中间操作栏这样实现：\n```Kotlin\n  // 操作栏 有个外边框，包裹菜单项，底部有阴影\n        Surface(\n            Modifier\n                .padding(start = 20.dp, end = 20.dp)\n                .fillMaxWidth()\n                .background(HhfTheme.colors.background),\n            elevation = 2.dp,\n            shape = RoundedCornerShape(8.dp),\n            color = MaterialTheme.colors.surface, // color will be adjusted for elevation\n        ) {\n```\n\n具体的菜单项也是用懒加载实现：\n```Kotlin\nLazyColumn(Modifier.background(HhfTheme.colors.listItem)) {\n                itemsIndexed(list) { i, bean ->\n\n                    /**\n                     * 我的页面遍历菜单项\n                     */\n                    MineItem(\n                        Modifier\n                            .fillMaxWidth()\n                            .clickable {\n                                /**\n                                 * 分发开发者行为\n                                 */\n                                mineViewModel.dispatch(MineViewEvent.ToComposable(bean.id))\n                            }\n                            .height(45.dp), bean.name, HhfTheme.colors.themeColor,\n                        bean.icon)\n                    if (i < list.size - 1) {\n                        /**\n                         * 非最后一行显示分割线\n                         */\n                        Divider(\n                            modifier = Modifier\n                                .fillMaxWidth()\n                                .padding(start = 10.dp, end = 10.dp)\n                        )\n                    }\n                }\n            }\n```\n\n具体的菜单item,有图标+文字+右侧箭头实现：\n```Kotlin\n\n@Composable\nfun MineItem(\n    modifier: Modifier = Modifier, textName: String, iconColor: Color, icon: ImageVector\n) {\n    Row(\n        modifier,\n        verticalAlignment = Alignment.CenterVertically,\n    ) {\n        Icon(\n            icon, \"$textName icon\",\n            Modifier\n                .size(28.dp)\n                .padding(start = 10.dp), iconColor\n        )\n        Text(\n            textName,\n            Modifier.padding(start = 10.dp),\n            fontSize = 14.sp,\n            fontFamily = FontFamily.Serif,\n            color = HhfTheme.colors.textColor\n        )\n        Icon(\n            Icons.Filled.KeyboardArrowRight, textName,\n            Modifier\n                .weight(1f)\n                .padding(end = 10.dp)\n                .wrapContentWidth(Alignment.End),\n            tint = HhfTheme.colors.textColor\n        )\n    }\n}\n```\n\nUI搞定了，跳转逻辑怎么处理呢？\n答案是viewModel层实现。\n\n这里有个clickable点击闭包：\n` mineViewModel.dispatch(MineViewEvent.ToComposable(bean.id))`\n\n\n会委托给mineViewModel处理：\n```Kotlin\n    /**\n     * 分发开发者行为\n     */\n    fun dispatch(action: MineViewEvent) {\n        when (action) {\n            is MineViewEvent.Blur -> bitmapBlur(action.s)\n            /**\n             * 用户点击菜单项\n             */\n            is MineViewEvent.ToComposable -> toComposable(action.type)\n            is MineViewEvent.ChangePopupState -> {\n                Log.e(\"TEST##\", \"这里触发了viewStates中 isShowpopup 变更为：${action.flag}\")\n                viewStates = viewStates.copy(isShowPopup = action.flag)\n            }\n            is MineViewEvent.SetUserInfo -> viewStates = viewStates.copy(userInfo = action.userInfo)\n            is MineViewEvent.GetIntegral -> getIntegral()\n        }\n    }\n```\n这里分发开发者行为，其实更像用户行为，有可能不是用户触发，所以我这里称之为开发者行为。\n\n点击菜单项继续分发：\n```Kotlin\nprivate fun toComposable(type: Int) {\n        if(isLogin){\n            when (type) {\n                0 -> CpNavigation.to(ModelPath.Integral)\n                1 -> CpNavigation.to(ModelPath.Collect)\n                2 -> CpNavigation.to(ModelPath.Share)\n                3 -> CpNavigation.to(ModelPath.Todo)\n                4 -> CpNavigation.toBundle(ModelPath.WebView, Bundle().apply {\n                    putString(webTitle, \"PlayAndroid\")\n                    putString(webUrl, \"https://github.com/yellowhai/PlayAndroid\")\n                    putBoolean(webIsCollect, false)\n                    putInt(webCollectId, 998)\n                    putInt(webCollectType, 1)\n                })\n                5 -> CpNavigation.to(ModelPath.Setting)\n            }\n        }\n        else{\n            when (type) {\n                4 -> CpNavigation.toBundle(ModelPath.WebView, Bundle().apply {\n                    putString(webTitle, \"PlayAndroid\")\n                    putString(webUrl, \"https://github.com/yellowhai/PlayAndroid\")\n                    putBoolean(webIsCollect, false)\n                    putInt(webCollectId, 998)\n                    putInt(webCollectType, 1)\n                })\n                5 -> CpNavigation.to(ModelPath.Setting)\n                else -> CpNavigation.to(ModelPath.Login)\n            }\n        }\n    }\n```\n这里定义了跳转逻辑，这里有回到 第8点主页外部架构 中的导航定义了。\n实现跳转到其它页面了，这更像是在布局上叠加，不算是跳转吧。\n\n这个项目还有很多细节值得一探究竟，不过对于初始compose，也差不多了，了解到这个程度也算入门了吧。\n\n\n","slug":"玩Android-Compose版本-项目分析","published":1,"updated":"2023-02-01T07:12:19.274Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlc01jh0015jhv7627d3biq","content":"<blockquote>\n<p>玩Android(compose版本)项目地址：<a href=\"https://github.com/yellowhai/PlayAndroid\">https://github.com/yellowhai/PlayAndroid</a></p>\n</blockquote>\n<h3 id=\"1-项目settings-gradle\"><a href=\"#1-项目settings-gradle\" class=\"headerlink\" title=\"1.项目settings.gradle\"></a>1.项目settings.gradle</h3><pre><code class=\"line-numbers language-groovy\">dependencyResolutionManagement &#123;\n    /**\n     * 原文中说默认情况下，项目中的存储库会覆盖设置中的存储库 ，可以通过设置模式来更改这种行为\n     设置存储库的方法：\n     repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n     存储库模式：\n     PREFER_PROJECT(true)--首选项目存储库\n     PREFER_SETTINGS(false)--首选设置存储库\n     FAIL_ON_PROJECT_REPOS(false)--强制设置存储库\n     */\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories &#123;\n        google()\n        mavenCentral()\n        maven &#123; url &quot;https://jitpack.io&quot; &#125;\n        maven &#123;\n            url &#39;https://maven.aliyun.com/repository/public/&#39;\n        &#125;\n        maven &#123; url &#39;https://maven.aliyun.com/repository/public&#39; &#125;\n        maven &#123; url &#39;https://maven.aliyun.com/repository/central&#39; &#125;\n        maven &#123; url &#39;https://maven.aliyun.com/repository/google&#39; &#125;\n        maven &#123; url &#39;https://maven.aliyun.com/repository/public&#39; &#125;\n        maven &#123; url &#39;https://maven.aliyun.com/repository/gradle-plugin&#39; &#125;\n    &#125;\n&#125;\nrootProject.name = &quot;PlayAndroid&quot;\ninclude &#39;:app&#39;\ninclude &#39;:common&#39;\ninclude &#39;:h_mine&#39;\ninclude &#39;:toolkit&#39;\n</code></pre>\n<p>还是很容易理解的，repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)这个是新增的，简单看下就行。<br>引入了app模块(主模块)，common模块（通用模块，用于通用组件相关）,h_mine模块（我的模块，可以单独编译）。</p>\n<h3 id=\"2-config-gradle\"><a href=\"#2-config-gradle\" class=\"headerlink\" title=\"2.config.gradle\"></a>2.config.gradle</h3><p>这个文件相信大家都有用过的，配置远程依赖的一个文件，统一管理。</p>\n<pre><code class=\"line-numbers language-groovy\">ext&#123;\n    isRelease = true\n\n    //android构建配置\n    android_models = [\n            compileSdk : 32,\n            minSdk : 23,\n            targetSdk : 32,\n            versionCode : 1,\n            versionName : &quot;1.0&quot;\n    ]\n    \n    app_id = [\n            mine      : &#39;com.hh.mine&#39;,\n    ]\n\n    core_ktx_version = &#39;1.7.0&#39;\n    appcompat_version = &#39;1.4.0&#39;\n    lifecycle_version = &#39;2.4.0&#39;\n    material_version = &#39;1.4.0&#39;\n    work_version = &#39;2.7.1&#39;\n    gson_version = &#39;2.8.9&#39;\n    litepal_version = &#39;3.2.3&#39;\n    landscapist_version = &#39;1.4.5&#39;\n    retrofit_version = &#39;2.9.0&#39;\n    okhttp_version = &#39;4.9.3&#39;\n    startup_version = &#39;1.1.0&#39;\n    XXPermissions_version = &#39;13.2&#39;\n    datastore_version = &#39;1.0.0&#39;\n    materialDialog_version = &#39;0.6.2&#39;\n    accompanist_version = &#39;0.25.0&#39;\n\n\n    jetpack_compose = [\n            material : &quot;androidx.compose.material:material:$compose_version&quot;,\n            activity : &quot;androidx.activity:activity-compose:$appcompat_version&quot;,\n    ]\n\n    commonApi = [\n            ktx_core        : &quot;androidx.core:core-ktx:$core_ktx_version&quot;,\n            lifecycle       : &quot;androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version&quot;,\n            appcompat       : &quot;androidx.appcompat:appcompat:$appcompat_version&quot;,\n            material        : &quot;com.google.android.material:material:$material_version&quot;,\n            //数据存储\n            datastore       : &quot;androidx.datastore:datastore-preferences:$datastore_version&quot;,\n            //权限处理\n            XXPermissions   : &quot;com.github.getActivity:XXPermissions:$XXPermissions_version&quot;,\n    ]\n\n    net = [\n            retrofit    : &quot;com.squareup.retrofit2:retrofit:$retrofit_version&quot;,\n            converter   : &quot;com.squareup.retrofit2:converter-gson:$retrofit_version&quot;,\n            okhttp      : &quot;com.squareup.okhttp3:logging-interceptor:$okhttp_version&quot;,\n            gson        : &quot;com.google.code.gson:gson:$gson_version&quot;\n    ]\n\n    accompanist_ui = [\n            insets_ui    : &quot;com.google.accompanist:accompanist-insets-ui:$accompanist_version&quot;,\n            navigation   : &quot;com.google.accompanist:accompanist-navigation-animation:$accompanist_version&quot;,\n            pager        : &quot;com.google.accompanist:accompanist-pager:$accompanist_version&quot;,\n            swiperefresh : &quot;com.google.accompanist:accompanist-swiperefresh:$accompanist_version&quot;,\n            flowlayout   : &quot;com.google.accompanist:accompanist-flowlayout:$accompanist_version&quot;,\n            systemUi     : &quot;com.google.accompanist:accompanist-systemuicontroller:$accompanist_version&quot;,\n            webview      : &quot;com.google.accompanist:accompanist-webview:$accompanist_version&quot;\n    ]\n\n    database =[\n            litepal :  &quot;org.litepal.guolindev:core:$litepal_version&quot;\n    ]\n\n    skydoves_coil = [\n            landscapist_coil :  &quot;com.github.skydoves:landscapist-coil:$landscapist_version&quot;\n    ]\n\n    workManager = [\n            // Kotlin + coroutines\n            work = &quot;androidx.work:work-runtime-ktx:$work_version&quot;\n    ]\n\n    material_dialog = [\n            color : &quot;io.github.vanpra.compose-material-dialogs:color:$materialDialog_version&quot;,\n            core  : &quot;io.github.vanpra.compose-material-dialogs:core:$materialDialog_version&quot;,\n            datetime  : &quot;io.github.vanpra.compose-material-dialogs:datetime:$materialDialog_version&quot;\n    ]\n\n    paging = &quot;androidx.paging:paging-compose:1.0.0-alpha14&quot;\n\n    jetpackComposeLibs = jetpack_compose.values()\n    commonApiLibs = commonApi.values()\n    netLibs = net.values()\n    materialDialogLibs = material_dialog.values()\n&#125;\n</code></pre>\n<p>层次还是比较清晰，对于同一组单独建立数组存储，模块中只需要引入一个就将这组全部引入进去了。</p>\n<h3 id=\"3-app模块下的build-gradle\"><a href=\"#3-app模块下的build-gradle\" class=\"headerlink\" title=\"3.app模块下的build.gradle\"></a>3.app模块下的build.gradle</h3><p>显示引入com.android.application+kotlin-android的插件。<br>下面配置android闭包，很简单。</p>\n<p>其它关于compose的也需要配置下：</p>\n<pre><code class=\"line-numbers language-groovy\"> compileOptions &#123;\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    &#125;\n    buildFeatures &#123;\n        compose true\n    &#125;\n    composeOptions &#123;\n        kotlinCompilerExtensionVersion compose_version\n        kotlinCompilerVersion kotlin_version\n    &#125;\n</code></pre>\n<p>然后是远程依赖：</p>\n<pre><code class=\"line-numbers language-groovy\">dependencies &#123;\n    // 如果是release模式，就把我的模块加进来\n    if(isRelease)&#123;\n        implementation project(&#39;:h_mine&#39;)\n    &#125;\n\n    // 初始化组件\n    implementation &quot;androidx.startup:startup-runtime:$startup_version&quot;\n    implementation project(&#39;:common&#39;)\n\n    // 测试相关\n    testImplementation &#39;junit:junit:4.13.2&#39;\n    androidTestImplementation &#39;androidx.test.ext:junit:1.1.3&#39;\n    androidTestImplementation &#39;androidx.test.espresso:espresso-core:3.4.0&#39;\n    androidTestImplementation &quot;androidx.compose.ui:ui-test-junit4:$compose_version&quot;\n    androidTestImplementation &quot;androidx.compose.ui:ui-test-junit4:$compose_version&quot;\n    debugImplementation &quot;androidx.compose.ui:ui-tooling:$compose_version&quot;\n\n&#125;\n</code></pre>\n<p>isRelease定义在 config.gradle的顶部。如果是集成编译就为true，单独编译为false。</p>\n<h3 id=\"4-app模块的AndroidManifest-xml\"><a href=\"#4-app模块的AndroidManifest-xml\" class=\"headerlink\" title=\"4.app模块的AndroidManifest.xml\"></a>4.app模块的AndroidManifest.xml</h3><ul>\n<li>配置Application</li>\n<li>配置主页</li>\n<li>配置provider，用于初始化sdk<pre><code class=\"line-numbers language-xml\">  &lt;!--  用provider初始化sdk--&gt;\n    &lt;provider\n        android:name=&quot;androidx.startup.InitializationProvider&quot;\n        android:authorities=&quot;$&#123;applicationId&#125;.androidx-startup&quot;\n        android:exported=&quot;false&quot;\n        tools:node=&quot;merge&quot;&gt;\n        &lt;meta-data\n            android:name=&quot;com.hh.playandroid.base.BaseInitializer&quot;\n            android:value=&quot;androidx.startup&quot; /&gt;\n    &lt;/provider&gt;\n</code></pre>\n</li>\n</ul>\n<h3 id=\"5-自定义Application\"><a href=\"#5-自定义Application\" class=\"headerlink\" title=\"5.自定义Application\"></a>5.自定义Application</h3><pre><code>class HhfApp : YshhApplication()\n</code></pre>\n<p> 依赖common模块：</p>\n<pre><code class=\"line-numbers language-Kotlin\">open class YshhApplication : Application() &#123;\n\n   lateinit var okbuilder: OkHttpClient\n\n   companion object &#123;\n       /**\n        * application context.\n        */\n       @SuppressLint(&quot;StaticFieldLeak&quot;)\n       lateinit var context: Context\n\n       @SuppressLint(&quot;StaticFieldLeak&quot;)\n       lateinit var instance: YshhApplication\n\n       /**\n        * application级别的协程\n        * 有时我们需要在协程上下文中定义多个元素，组合协程上下文中的元素，使用 + 操作符来创建 CoroutineScope .\n        */\n       val applicationScope = CoroutineScope(SupervisorJob() + Dispatchers.Main)\n   &#125;\n</code></pre>\n<p> 这里懒加载OkHttpClient<br> 定义了全局的协程，静态变量。</p>\n<pre><code class=\"line-numbers language-Kotlin\">  override fun onCreate() &#123;\n       super.onCreate()\n       context = applicationContext\n       instance = this\n       initRetrofit()\n   &#125;\n</code></pre>\n<p> 初始化Retrofit：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n    * 初始化Retrofit\n    */\n   private fun initRetrofit(token : String = &quot;&quot;): OkHttpClient &#123;\n       //请求头\n       val headerInterceptor = Interceptor &#123; chain: Interceptor.Chain -&gt;\n           val orignaRequest = chain.request()\n           val request = orignaRequest.newBuilder()\n               .header(&quot;Authorization&quot;, &quot;Bearer $token&quot;)\n               .method(orignaRequest.method, orignaRequest.body)\n               .build()\n           chain.proceed(request)\n       &#125;\n       val logInterceptor = LogInterceptor &#123;\n//            it.logE()\n       &#125;\n       // 日志类别\n       logInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);\n       // 缓存相关\n       val cacheFile =\n           File(getExternalFilesDir(Environment.DIRECTORY_PICTURES).toString() + &quot;http_cache&quot;)\n       val cache = Cache(cacheFile, 104857600L) // 指定缓存大小100Mb\n       val builder = OkHttpClient.Builder()\n       //        builder.addInterceptor(addQueryParameterInterceptor);\n       builder.addInterceptor(headerInterceptor)\n       builder.cache(cache)\n       builder.addNetworkInterceptor(logInterceptor)\n       builder.cookieJar(cookieJar)\n       builder.readTimeout(60000, TimeUnit.MILLISECONDS)\n       //全局的写入超时时间60s\n       builder.writeTimeout(60000, TimeUnit.MILLISECONDS)\n       //全局的连接超时时间30s\n       builder.connectTimeout(30000, TimeUnit.MILLISECONDS)\n       okbuilder = builder.build()\n       return builder.build()\n   &#125;\n\n   private val cookieJar: PersistentCookieJar by lazy &#123;\n       PersistentCookieJar(SetCookieCache(), SharedPrefsCookiePersistor(context))\n   &#125;\n   \n   fun getOkBuilder(): OkHttpClient &#123;\n       return okbuilder\n   &#125;\n</code></pre>\n<h3 id=\"6-首页-MainActivity\"><a href=\"#6-首页-MainActivity\" class=\"headerlink\" title=\"6.首页 MainActivity\"></a>6.首页 MainActivity</h3><p> 继承BaseActivity:</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n/**\n* 基类Activity 设置非沉浸式，因为要设置导航栏和状态栏颜色\n*/\nabstract class BaseActivity : AppCompatActivity() &#123;\n\n   override fun onCreate(savedInstanceState: Bundle?) &#123;\n       super.onCreate(savedInstanceState)\n       WindowCompat.setDecorFitsSystemWindows(window, false)\n   &#125;\n\n&#125;\n</code></pre>\n<p>onCreate生命周期：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> @Suppress(&quot;DEPRECATED_IDENTITY_EQUALS&quot;)\n    @OptIn(ExperimentalAnimationApi::class)\n    override fun onCreate(savedInstanceState: Bundle?) &#123;\n        super.onCreate(savedInstanceState)\n        // 动画渐变\n        overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out)\n        // 设置内容\n        setContent &#123;\n            Log.e(&quot;TEST##&quot;, &quot;开始setContent了&quot;)\n            // 顶层为自定义主题\n            HhfTheme(\n                // 是否暗色或亮色，跟随系统，如果用户主动设置，跟随用户\n                theme = if (isSystemInDarkTheme() || isNight) HhfTheme.Theme.Dark else HhfTheme.Theme.Light,\n                // 用户自行设置的颜色主题\n                colorTheme = appTheme\n            ) &#123;\n                // 创建一个MainViewModel\n                val viewModel : MainViewModel = viewModel()\n\n                // 如果isSplash为true,就展示SplashView 启动页\n                if (viewModel.isSplash) &#123;\n                    Log.e(&quot;TEST##&quot;, &quot;加载闪屏了&quot;)\n                    SplashView &#123; viewModel.isSplash = false &#125;\n                &#125; else &#123;\n                    Log.e(&quot;TEST##&quot;, &quot;加载首页了&quot;)\n                    // 全局静态变量存 底部控制器\n                    CpNavigation.navHostController = rememberAnimatedNavController()\n                    // 主页面\n                    HhfNavigation()\n                    // 进度条\n                    DialogProgress()\n                &#125;\n                // 是否纪念日，将App置灰\n                if(isMourningDay())&#123;\n                    Canvas(modifier = Modifier.fillMaxSize())&#123;\n                        drawRect(color = Color.White,blendMode = BlendMode.Saturation)\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        addCallback()\n    &#125;\n</code></pre>\n<p>因为这个app就一个Activity，setContent中的内容就是展现给用户可以看到的所有东西了。<br>顶层是一个自定义主题：</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun HhfTheme(\n    theme: HhfTheme.Theme = HhfTheme.Theme.Light,\n    colorTheme: Color? = null,\n    content: @Composable () -&gt; Unit\n) &#123;\n    val targetColors = if (theme == HhfTheme.Theme.Dark) &#123;\n        colorTheme?.let &#123;\n            rememberSystemUiController().setNavigationBarColor(colorTheme)\n            DarkColorPalette.apply &#123;\n                themeColor = it\n            &#125;\n        &#125;?:DarkColorPalette\n    &#125; else &#123;\n        colorTheme?.let &#123;\n            rememberSystemUiController().setNavigationBarColor(colorTheme)\n            LightColorPalette.apply &#123;\n                themeColor = it\n            &#125;\n        &#125;?:LightColorPalette\n    &#125;\n    val themeColor = animateColorAsState(targetColors.themeColor, TweenSpec(600))\n    val textColor = animateColorAsState(targetColors.textColor, TweenSpec(600))\n    val background = animateColorAsState(targetColors.background,TweenSpec(600))\n    val listItem =  animateColorAsState(targetColors.listItem,TweenSpec(600))\n    val bottomBar =  animateColorAsState(targetColors.bottomBar,TweenSpec(600))\n    val divider =  animateColorAsState(targetColors.divider,TweenSpec(600))\n    val textFieldBackground =  animateColorAsState(targetColors.textFieldBackground,TweenSpec(600))\n    val colors = HhfColors(themeColor.value,\n        textColor.value,\n        background = background.value,\n        listItem = listItem.value,\n        bottomBar = bottomBar.value,\n        divider = divider.value,\n        textFieldBackground = textFieldBackground.value,\n        )\n    CompositionLocalProvider(LocalHhfColors provides colors) &#123;\n        MaterialTheme(\n            shapes = Shapes,\n            typography = typography\n        ) &#123;\n            content.invoke()\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里用到了一个 CompositionLocalProvider，具体用法可以参考 <a href=\"https://juejin.cn/post/7097890697721675813\">https://juejin.cn/post/7097890697721675813</a></p>\n<p>在Compose函数里，如果要用到函数外提供的值，一般都要通过函数定义好参数，外部调用时传入进去。<br>这种方法表面看没啥问题，但在一些场景下就不是很方便。比如一个函数A嵌套一个函数B，函数B嵌套函数C，并且这A、B、C的函数都用到这个参数，那对三个函数来说都需要定义这个参数，就不是那么方便。<br>那用个全局变量不就可以解决需要重复定义参数，确实可以。但全局变量有个副作用就是影响的范围比较大。本身我们定义的参数只会影响到函数内部。这个时候我们就可以使用CompositionLocal：它具有穿透函数功能的局部变量<br>CompositionLocal适用场景：用来提供上下文数据，不扩大影响范围。</p>\n<p>然后最终主题呈现是用了 MaterialTheme这个类展现。</p>\n<p>回到首页，内容区：</p>\n<ul>\n<li>闪屏页展示逻辑<br>  通过一个变量：<code>  var isSplash by mutableStateOf(true)</code> 实现控制是否显示</li>\n<li>加载首页<br> 先 展示主页面，覆盖一层 进度条</li>\n<li>是否纪念日<br>  app置灰处理    </li>\n<li>添加二次点击返回退出app逻辑</li>\n</ul>\n<p>首页逻辑基本就这么多了。</p>\n<h3 id=\"7-闪屏ui-gt-SplashView\"><a href=\"#7-闪屏ui-gt-SplashView\" class=\"headerlink\" title=\"7.闪屏ui -&gt; SplashView\"></a>7.闪屏ui -&gt; SplashView</h3><p>看下效果先：<br><img src=%E9%97%AA%E5%B1%8F%E9%A1%B5.gif width = 50%></p>\n<p>可以看到进入app后有个启动页面，中间是logo。<br>那这个页面有个渐变动画，淡入淡出效果。</p>\n<p>具体ui是这样的：</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun SplashView(startMain: () -&gt; Unit) &#123;\n    /**\n     * 辅助文字颜色变化 建立的一个mutableState包装的变量，实际上就是bool值\n     */\n    var enabled by remember &#123; mutableStateOf(false) &#125;\n\n    /**\n     * 背景颜色，从0.3alpha主题色变为纯主题色，2s的时间\n     */\n    val bgColor: Color by animateColorAsState(\n        if (enabled) HhfTheme.colors.themeColor\n        else HhfTheme.colors.themeColor.copy(alpha = 0.3f),\n        animationSpec = tween(durationMillis = 2000)\n    )\n\n    /**\n     * 中间文字颜色动画，如果enable为false，0.3alpha的颜色 到纯白色 2s的时间\n     */\n    val textColor: Color by animateColorAsState(\n        if (enabled) Color.White\n        else Color.White.copy(alpha = 0.3f),\n        animationSpec = tween(durationMillis = 2000)\n    )\n\n    // 外层一个Box+中间一个Text\n    Box(\n        Modifier\n            .fillMaxSize()\n            .background(bgColor),\n        contentAlignment = Alignment.Center\n    ) &#123;\n        Text(text = &quot;PlayAndroid&quot;, color = textColor,style = MaterialTheme.typography.h5)\n    &#125;\n\n    // 开启协程 可以看出Compose里面开启协程的方法\n    LaunchedEffect(Unit) &#123;\n        enabled = true\n        delay(2000)\n        // 2s后，设置 mutableStateOf 包装的bool变量 为false 会通知首页重新走setContent方法\n        startMain.invoke()\n    &#125;\n&#125;\n</code></pre>\n<p>这里需要理解 animateColorAsState 是官方提供的一个动画，支持颜色变化的一个composable方法。</p>\n<p>然后这里开启了2s延迟，怎么开延迟的，调用LaunchedEffect方法里面的delay，可以实现延迟效果。然后执行startMain回调。</p>\n<p>这个回调很简单：viewModel.isSplash &#x3D; false</p>\n<p>虽然很简单，但实际上走了很多流程的。</p>\n<pre><code class=\"line-numbers language-Kotlin\">class MainViewModel : ViewModel() &#123;\n    var isSplash by mutableStateOf(true)\n&#125;\n</code></pre>\n<p>这里使用mutableStateOf包装了一个布尔值。 上面触发这改变时，会刷新composable注解声明的方法体。这里应该就是刷新MainActivity整个内容区了。</p>\n<h3 id=\"8-主页面外部架构\"><a href=\"#8-主页面外部架构\" class=\"headerlink\" title=\"8.主页面外部架构\"></a>8.主页面外部架构</h3><pre><code class=\"line-numbers language-Kotlin\">@ExperimentalAnimationApi\n@OptIn(ExperimentalPagerApi::class)\n@Composable\nfun HhfNavigation() &#123;\n    AnimatedNavHost(navController = CpNavigation.navHostController,\n        /**\n         * 首页默认页面\n         */\n        startDestination = ModelPath.Main.route,\n        enterTransition = &#123; fadeIn(animationSpec = tween(700), initialAlpha = 0f) &#125;,\n        exitTransition = &#123; fadeOut(animationSpec = tween(700), targetAlpha = 0f) &#125;) &#123;\n\n        /**\n         * 定义接收到 main 路由消息后-&gt;展示MainContent视图\n         */\n        composable(ModelPath.Main.route) &#123;\n            MainContent()\n        &#125;\n\n        /**\n         * 接收到 setting 路由消息后 -&gt; 设置页面\n         */\n        composable(ModelPath.Setting.route) &#123;\n            CpSetting(Modifier.fillMaxSize())\n        &#125;\n        ...\n</code></pre>\n<p>这里使用了一个AnimatedNavHost，这个类是官方提供的。<br>这个类里面定义了所有我们需要跳转的页面和初始页。<br>然后这个 需要传一个参数，也就是控制器：<br><code> CpNavigation.navHostController = rememberAnimatedNavController()</code><br>这里也是官方提供的remember包装的一个控制器。</p>\n<p>这里的初始页为：<code>  startDestination = ModelPath.Main.route,</code><br>本质上就是一个string，首页的路由。</p>\n<p>这样会默认展示首页，怎么展示首页呢？</p>\n<pre><code class=\"line-numbers language-Kotlin\">composable(ModelPath.Main.route) &#123;\n            MainContent()\n        &#125;\n</code></pre>\n<p>那么这个MainContent就是我们的首页。</p>\n<p>其它composable里面都是首页可能去哪些页面的路由定义。</p>\n<p>那这个比如跳转到设置页面，怎么处理呢？</p>\n<ul>\n<li>首先在这个AnimatedNavHost里面定义一个composable闭包</li>\n</ul>\n<pre><code class=\"line-numbers language-Kotlin\"> composable(ModelPath.Setting.route) &#123;\n            CpSetting(Modifier.fillMaxSize())\n        &#125;\n</code></pre>\n<ul>\n<li>然后再需要跳转的地方调用<br><code>navHostController.navigate(“setting”)</code><br>这个navHostController就是我们之前定义的那个控制器，setting就是路由名称。<br>这样子就可以跳转到设置页面了。</li>\n</ul>\n<h3 id=\"9-主页内部架构框\"><a href=\"#9-主页内部架构框\" class=\"headerlink\" title=\"9.主页内部架构框\"></a>9.主页内部架构框</h3><p>首先看下主页效果图<br><img src=%E9%A6%96%E9%A1%B5.jpeg width=50%><br>轮播图+中间列表+底部bar<br>轮播图+中间列表可以看成一个整体，那就是内容区+底部bar</p>\n<p>架构怎么搭建呢？</p>\n<pre><code class=\"line-numbers language-Kotlin\">   Scaffold(bottomBar = &#123;\n        AnimatedVisibility(\n            visible = bottomSwitch,\n            enter = expandVertically() + fadeIn(), // 操作符重载了，第一个为空，就用第二个\n            exit = shrinkVertically() + fadeOut()  // 操作符重载了，第一个为空，就用第二个\n        ) &#123;\n            // 实际的底部bar 高度使用 固有特性测量 可以参考：https://juejin.cn/post/7068164264363556872\n            MainBottomBar(\n                Modifier\n                    .fillMaxWidth()\n                    .height(IntrinsicSize.Max),pagerState = pagerState) &#123;\n                pagerState.reenableScrolling(coroutineScope, it)\n            &#125;\n        &#125;\n    &#125;) &#123;\n        内容区...\n</code></pre>\n<p>最外层一个Scafffold脚手架包裹，有点像Flutter了啊。<br>然后是一个AnimatedVisibility，这个控制显示隐藏的动画组件。重点看里面的MainBottomBar，就找到了我们的底部bar了。</p>\n<p>这个看起来像自定义的，具体怎么实现的呢？</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * App底部bar\n */\n@OptIn(ExperimentalPagerApi::class)\n@Composable\nprivate fun MainBottomBar(\n    modifier: Modifier = Modifier,\n    pagerState: PagerState,\n    currentChanged: (Int) -&gt; Unit\n) &#123;\n    /**\n     * 这个BottomAppBar是官方的\n     */\n    BottomAppBar(\n        modifier.navigationBarsPadding(),\n        cutoutShape = CircleShape,\n        backgroundColor = HhfTheme.colors.bottomBar,\n        elevation = 5.dp\n    ) &#123;\n        // 遍历4个tab\n        bottomList.forEachIndexed &#123; index, item -&gt;\n            // item单独设置 官方组件\n            BottomNavigationItem(\n                selected = pagerState.currentPage == index, onClick = &#123;\n                    /**\n                     * item点击事件回调给上层\n                     */\n                    currentChanged(index)\n                &#125;, icon = &#123;\n                    /**\n                     * icon为官方组件\n                     */\n                    Icon(\n                        item.dashboardState.icon,\n                        contentDescription = item.name,\n                        tint = if (pagerState.currentPage == index) &#123;\n                            HhfTheme.colors.themeColor\n                        &#125; else &#123;\n                            LocalContentColor.current.copy(alpha = LocalContentAlpha.current)\n                        &#125;, modifier = Modifier.size(24.dp)\n                    )\n                &#125;, label = &#123;\n                    Text(\n                        text = item.name,\n                        color = if (pagerState.currentPage == index) &#123;\n                            HhfTheme.colors.themeColor\n                        &#125; else &#123;\n                            LocalContentColor.current.copy(alpha = LocalContentAlpha.current)\n                        &#125;,\n                        fontSize = 12.sp\n                    )\n                &#125;,\n                unselectedContentColor = LocalContentColor.current.copy(alpha = LocalContentAlpha.current),\n                selectedContentColor = HhfTheme.colors.themeColor,\n                alwaysShowLabel = true\n\n            )\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里看出底部bar就是用了官方的BottomAppBar。<br>里面具体内容是我们开发者自行设定的，这里遍历了bottomList，这个集合就是我们自己定义的一个集合：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * 底部List集合 这里定义了4块\n * 首页，项目，公众号，我的\n */\nval bottomList = listOf(\n    BottomBean(\n        DashboardState.Home,\n        YshhApplication.context.stringResource(R.string.main_title_home)\n    ),\n    BottomBean(\n        DashboardState.Project,\n        YshhApplication.context.stringResource(R.string.main_title_project)\n    ),\n    BottomBean(\n        DashboardState.PubAccount,\n        YshhApplication.context.stringResource(R.string.main_title_account)\n    ),\n    BottomBean(\n        DashboardState.Mine,\n        YshhApplication.context.stringResource(R.string.main_title_mine)\n    )\n)\n</code></pre>\n<p>就这几个模块。</p>\n<p>底部bar的item就是 BottomNavigationitem里面的了，可以看到是一个icon+label构成。有个onClick的参数就是点击事件回调了，这里调用了 回调函数，传递给上层了，传出去的参数就一个int，表示第几页。</p>\n<p>回调到哪里呢？</p>\n<pre><code class=\"line-numbers language-Kotlin\"> // 实际的底部bar 高度使用 固有特性测量 可以参考：https://juejin.cn/post/7068164264363556872\n            MainBottomBar(\n                Modifier\n                    .fillMaxWidth()\n                    .height(IntrinsicSize.Max),pagerState = pagerState) &#123;\n                pagerState.reenableScrolling(coroutineScope, it)\n            &#125;\n</code></pre>\n<p>这里通过调用rememberPagerState这个对象的<code>  pagerState.reenableScrolling(coroutineScope, it)</code>这个方法实现滚动到目标tab下。也就实现了页面切换。<br>最为关键的就是这个pagerState，同步页面数据和底部bar。</p>\n<p>等下分析内容区也会用到。</p>\n<pre><code class=\"line-numbers language-Kotlin\"> // 水平分页\n            HorizontalPager(\n                count = bottomList.size,\n                modifier.weight(1f), pagerState, userScrollEnabled = true\n            ) &#123; page -&gt;\n                when (page) &#123;\n                    // 首页tab\n                    0 -&gt; HomeView(\n                        Modifier\n                            .fillMaxSize()\n                            .background(HhfTheme.colors.background)\n                            .align(Alignment.CenterHorizontally)\n                    )\n                    // 项目tab\n                    1 -&gt; ProjectView(\n                        Modifier\n                            .fillMaxSize()\n                            .align(Alignment.CenterHorizontally)\n                    )\n                    // 公众号tab\n                    2 -&gt; AccountView(\n                        Modifier\n                            .fillMaxSize()\n                            .background(HhfTheme.colors.background)\n                            .align(Alignment.CenterHorizontally)\n                    )\n                    // 我的tab\n                    3 -&gt; &#123;\n//                        if (isLogin) &#123;\n                            Mine(\n                                Modifier\n                                    .fillMaxSize()\n                                    .background(HhfTheme.colors.background)\n                                    .align(Alignment.CenterHorizontally)\n                            )\n//                        &#125; else &#123;\n//                            ErrorBox(\n//                                Modifier.fillMaxSize(),\n//                                title = stringResource(id = R.string.sign_in)\n//                            )\n//                            &#123; CpNavigation.to(ModelPath.Login) &#125;\n//                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n</code></pre>\n<p>这里是中间内容区。通过使用水平分页得以实现。可以看到传入了一个参数，也就是上面底部bar用到的一个pagerState，定义了不同索引下，中间内容区展示的内容。</p>\n<ul>\n<li>首页Tab 对应 HomeView</li>\n<li>项目Tab 对应 ProjectView</li>\n<li>公众号Tab 对应 AccountView</li>\n<li>我的Tab 对应 Mine</li>\n</ul>\n<h3 id=\"10-首页Tab-HomeView\"><a href=\"#10-首页Tab-HomeView\" class=\"headerlink\" title=\"10.首页Tab-HomeView\"></a>10.首页Tab-HomeView</h3><p>首页效果图就是上面的那个效果。<br>这里再拆分下，就是轮播图+列表。<br>对应 HomeView。</p>\n<pre><code class=\"line-numbers language-Kotlin\">@CompoKotlinsable\nfun HomeView(modifier: Modifier = Modifier) &#123;\n    val viewModel: HomeViewModel = viewModel()\n    ColumnTopBarMain(modifier\n        .background(HhfTheme.colors.background),\n        stringResource(R.string.app_name)) &#123;\n        // 内容区域，传入HomeViewModel对象\n        HomeContent(viewModel = viewModel)\n    &#125;\n&#125;\n</code></pre>\n<p>最外层是由顶部bar+内容区构成。</p>\n<p>ColumnTabBarMain是自定义通用的一个App的组件，用于上面展示toolbar，中间区域自定义。</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun ColumnTopBarMain(\n    modifier: Modifier = Modifier,\n    title: String,\n    content: @Composable ColumnScope.() -&gt; Unit\n) &#123;\n    Column(\n        modifier.navigationBarsPadding(),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) &#123;\n        CpTopBar(\n            Modifier.fillMaxWidth(),\n            HhfTheme.colors.themeColor,\n            title = title,\n            actions = &#123;\n                IconButton(onClick = &#123;\n                    CpNavigation.to(ModelPath.Search)\n                &#125;) &#123;\n                    Icon(Icons.Filled.Search, contentDescription = &quot;search&quot;, tint = Color.White)\n                &#125;\n            &#125;,\n        )\n        content.invoke(this)\n    &#125;\n&#125;\n</code></pre>\n<p>这里具体是一个Column+CpTopBar构成</p>\n<p>CpTopBar是这样的：</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n@Composable\nfun CpTopBar(\n    modifier: Modifier = Modifier,\n    backgroundColor: Color = Color.Transparent,\n    title: String,\n    actions: @Composable RowScope.() -&gt; Unit = &#123;&#125;,\n    back: (() -&gt; Unit)? = null\n) &#123;\n    HhTopAppBar(\n        &#123;\n            Text(title, color = Color.White)\n        &#125;,\n        modifier = modifier,\n        backgroundColor = backgroundColor,\n        contentPadding = WindowInsets.statusBars.only(WindowInsetsSides.Horizontal + WindowInsetsSides.Top).asPaddingValues(),\n        navigationIcon = back?.run &#123;\n            &#123;\n                IconButton(\n                    onClick = &#123;\n                        invoke()\n                    &#125;\n                ) &#123;\n                    Icon(Icons.Filled.ArrowBack, contentDescription = &quot;back&quot;, tint = Color.White)\n                &#125;\n            &#125;\n        &#125;,\n        actions = actions,\n        elevation = 2.dp,\n    )\n&#125;\n</code></pre>\n<p>里面还有自定义的HhTopAppBar</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n@Composable\nfun HhTopAppBar(\n    title: @Composable () -&gt; Unit,\n    modifier: Modifier = Modifier,\n    contentPadding: PaddingValues = PaddingValues(0.dp),\n    navigationIcon: @Composable (() -&gt; Unit)? = null,\n    actions: @Composable RowScope.() -&gt; Unit = &#123;&#125;,\n    backgroundColor: Color = MaterialTheme.colors.primarySurface,\n    contentColor: Color = contentColorFor(backgroundColor),\n    elevation: Dp = AppBarDefaults.TopAppBarElevation,\n) &#123;\n    TopAppBarSurface(\n        modifier = modifier,\n        backgroundColor = backgroundColor,\n        contentColor = contentColor,\n        elevation = elevation\n    ) &#123;\n        TopAppBarContent(\n            title = title,\n            navigationIcon = navigationIcon,\n            actions = actions,\n            modifier = Modifier.padding(contentPadding)\n        )\n    &#125;\n&#125;\n</code></pre>\n<p>竟然还有自定义层：Surface是官方提供的了</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun TopAppBarSurface(\n    modifier: Modifier = Modifier,\n    backgroundColor: Color = MaterialTheme.colors.primarySurface,\n    contentColor: Color = contentColorFor(backgroundColor),\n    elevation: Dp = AppBarDefaults.TopAppBarElevation,\n    content: @Composable () -&gt; Unit,\n) &#123;\n    Surface(\n        color = backgroundColor,\n        contentColor = contentColor,\n        elevation = elevation,\n        modifier = modifier,\n        content = content\n    )\n&#125;\n</code></pre>\n<p>还有标题栏内容区： 这个TopAppBar是官方提供的了</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun TopAppBarContent(\n    title: @Composable () -&gt; Unit,\n    modifier: Modifier = Modifier,\n    navigationIcon: @Composable (() -&gt; Unit)? = null,\n    actions: @Composable RowScope.() -&gt; Unit = &#123;&#125;,\n) &#123;\n    TopAppBar(\n        title = title,\n        navigationIcon = navigationIcon,\n        actions = actions,\n        backgroundColor = Color.Transparent,\n        elevation = 0.dp,\n        modifier = modifier\n    )\n&#125;\n</code></pre>\n<p>标题栏看完了，那就到内容区了。</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n/**\n * 首页内容区\n */\n@Composable\nfun HomeContent(modifier: Modifier = Modifier, viewModel: HomeViewModel) &#123;\n\n    /**\n     * list 为首页文章 列表数据；系统会对所有列表项进行组合和布局，无论它们是否可见，\n     * 因此如果您需要显示大量列表项（或长度未知的列表），则使用 Column 等布局可能会导致性能问题。\n     * Compose 提供了一组组件，这些组件只会对在组件视口中可见的列表项进行组合和布局。\n     */\n    val list = viewModel.viewStates.homeList.collectAsLazyPagingItems()\n\n    /**\n     * 下拉刷新组件\n     */\n    SwipeRefresh(\n        /**\n         * 状态，是否正在刷新\n         */\n        state = rememberSwipeRefreshState(viewModel.viewStates.isRefresh),\n        /**\n         * 下拉刷新回调，需要更新轮播+列表\n         */\n        onRefresh = &#123;\n            viewModel.dispatch(HomeAction.GetBanner)\n            list.refresh()\n        &#125;) &#123;\n        // 内容区 使用LazyItem包裹\n        PagingItem(modifier, list = list,\n            errorBlock = &#123;&#125;,\n            successBlock = &#123;&#125;,\n            errorAndSuccessClick = &#123;\n                /**\n                 * 错误后点击回调\n                 */\n                list.refresh()\n            &#125;) &#123;\n            /**\n             * 仅组成和放置 当前可见项 的竖直滚动列表。它允许您放置不同类型的子级内容。\n             * 例如，您可以使用LazyListScope.item添加单个项目，然后使用LazyListScope.items或者LazyListScope.itemsIndexed添加项目列表，后者有当前列表项的索引值。\n             */\n            LazyColumn&#123;\n                /**\n                 * 单个item\n                 */\n                item &#123;\n                    BannerPager(Modifier.height(160.dp), viewModel = viewModel)\n                &#125;\n                /**\n                 * items集合\n                 */\n                items(it) &#123; homeBean -&gt;\n                    homeBean?.apply &#123;\n                        /**\n                         * 首页文字item\n                         */\n                        HomeListItem(homeBean = this) &#123;\n                            /**\n                             * 处理点击收藏图标 触发viewModel层调用接口\n                             */\n                            if(CacheUtils.isLogin)&#123;\n                                viewModel.dispatch(HomeAction.Collect(homeBean.id, it))\n                            &#125;\n                            else&#123;\n                                CpNavigation.to(ModelPath.Login)\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>list 是专门用于懒加载列表，这个是存放可视区的列表。</p>\n<p>数据来源是ViewModel层的viewStates实例。</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * 首页状态，包装首页需要的数据\n */\ndata class HomeState(\n    /**\n     * 是否正在刷新\n     */\n    val isRefresh : Boolean = false,\n\n    /**\n     * 轮播列表，数据源\n     */\n    val bannerList: List&lt;BannerResponse&gt; = listOf(),\n\n    /**\n     * 首页数据\n     */\n    val homeList: Flow&lt;PagingData&lt;ArticleBean&gt;&gt; = Pager(\n        PagingConfig(PAGE_SIZE),\n        pagingSourceFactory = &#123; HomeSource() &#125;).flow,\n)\n</code></pre>\n<p>这个是存放到ViewModel层的首页动态数据。</p>\n<pre><code class=\"line-numbers language-Kotlin\"> // 首页数据监听 通过 mutableStateOf包装 HomeState\n    var viewStates by mutableStateOf(\n        HomeState(\n            homeList = Pager(\n                PagingConfig(PAGE_SIZE),\n                pagingSourceFactory = &#123; HomeSource() &#125;).flow.cachedIn(viewModelScope)))\n        private set\n</code></pre>\n<p>这里用一个mutableStateof包装下。</p>\n<p>下面继续回到首页内容区：<br>然后是一个SwipeRefresh组件,官方提供的。</p>\n<pre><code class=\"line-numbers language-Kotlin\">    SwipeRefresh(\n        /**\n         * 状态，是否正在刷新\n         */\n        state = rememberSwipeRefreshState(viewModel.viewStates.isRefresh),\n        /**\n         * 下拉刷新回调，需要更新轮播+列表\n         */\n        onRefresh = &#123;\n            viewModel.dispatch(HomeAction.GetBanner)\n            list.refresh()\n        &#125;) &#123;\n</code></pre>\n<p>定义好下拉刷新触发事件。<br>注意这个list，实际上走的是LazyPagingItems里面的一个refresh方法。<br>我们在HomeState中定义的homeList是一个Flow包装列表集合。通过调用Flow中扩展的一个collectAsLazyPagingItems函数，就变成LazyPagingItems对象了。</p>\n<p>这个list我们放在PagingItem里面。</p>\n<p>然后首页内容区里面用了一个 LazyColumn，应该也是配合懒加载和复用官方实现的一个类。<br>然后里面第一个item就是我们的轮播图了。</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * 顶部轮播图\n */\n@OptIn(ExperimentalPagerApi::class)\n@Composable\nfun BannerPager(modifier: Modifier = Modifier, viewModel: HomeViewModel) &#123;\n    val pagerState = rememberPagerState()\n\n    /**\n     * 开启协程 内部的闭包是协程 目的是获取轮播图数据\n     */\n    LaunchedEffect(viewModel)&#123;\n        viewModel.dispatch(HomeAction.GetBanner)\n    &#125;\n\n    /**\n     * 如需了解来自父项的约束条件并相应地设计布局，您可以使用 BoxWithConstraints。\n     * 就是外部传过来的modifier 决定子View 空间\n     */\n    BoxWithConstraints(modifier) &#123;\n\n        /**\n         * 水平分页\n         */\n        HorizontalPager(\n            count = viewModel.viewStates.bannerList.size, // 轮播总数\n            state = pagerState // 轮播状态\n        ) &#123; page -&gt;\n            //  页面索引\n            when (page) &#123;\n                viewModel.viewStates.bannerList[page].id -&gt; &#123;\n                    /**\n                     * 轮播图item\n                     */\n                    BannerItem(\n                        Modifier\n                            .height(maxHeight)\n                            .fillMaxWidth(), viewModel.viewStates.bannerList[page]\n                    )\n                &#125;\n            &#125;\n        &#125;\n\n        /**\n         * 轮播指示器\n         */\n        if (viewModel.viewStates.bannerList.isNotEmpty()) &#123;\n            BannerIndicator(\n                Modifier\n                    .align(Alignment.BottomCenter)\n                    .fillMaxWidth()\n                    .background(Color.Black.copy(0.2f))\n                    .padding(8.dp),viewModel, pagerState )\n        &#125;\n\n\n    &#125;\n&#125;\n</code></pre>\n<p>这个轮播图里面开了个协程去获取轮播图数据，只会走一次。<br>然后一个水平分页里面存放所有轮播图，轮播item为BannerItem,这个是自定义的</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun BannerItem(modifier: Modifier = Modifier, data: BannerResponse) &#123;\n    data.apply &#123;\n        Box(modifier.clickable &#123;\n            /**\n             * 点击图片，触发跳转WebView，通过bundle传递数据\n             */\n            CpNavigation.toBundle(ModelPath.WebView, Bundle().apply &#123;\n                putString(webTitle, data.title)\n                putString(webUrl, data.url)\n                putBoolean(webIsCollect, false)\n                putInt(webCollectId, data.id)\n                putInt(webCollectType, 1)\n            &#125;)\n        &#125;) &#123;\n            /**\n             * 自定义网络图片\n             */\n            NetworkImage(\n                imagePath,\n                Modifier.fillMaxWidth(),\n                contentScale = ContentScale.FillBounds,\n                defaultImg = R.mipmap.ic_default_round\n            )\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>轮播完了，就是文章item了。<br>主要是为了实现这种效果<br><img src=\"/./%E7%8E%A9Android-Compose%E7%89%88%E6%9C%AC-%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90/home_item.jpeg\"></p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n   * items集合\n   */\nitems(it) &#123; homeBean -&gt;\n    homeBean?.apply &#123;\n        /**\n        * 首页文字item\n        */\n        HomeListItem(homeBean = this) &#123;\n            /**\n            * 处理点击收藏图标 触发viewModel层调用接口\n            */\n            if(CacheUtils.isLogin)&#123;\n                viewModel.dispatch(HomeAction.Collect(homeBean.id, it))\n            &#125;\n            else&#123;\n                CpNavigation.to(ModelPath.Login)\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里用了items，然后遍历了 list,每个item对应一个 HomeListItem<br>这里定义了一个函数，说明了点击收藏图标后的逻辑。</p>\n<pre><code class=\"line-numbers language-Kotlin\">  /**\n     * 是否收藏了，用remember包装一下bool值\n     */\n    var isCollect by remember&#123; mutableStateOf(homeBean.collect)&#125;\n\n    /**\n     * 卡片布局\n     */\n    Card(\n        modifier\n            .padding(8.dp) // 内padding 8个dp\n            .clickable &#123;\n                /**\n                 * 卡片点击事件，触发跳转webView\n                 */\n                CpNavigation.toBundle(ModelPath.WebView, Bundle().apply &#123;\n                    putString(webTitle, homeBean.title)\n                    putString(webUrl, homeBean.link)\n                    putBoolean(webIsCollect, isCollect)\n                    putInt(webCollectId, homeBean.id)\n                    putInt(webCollectType, 0)\n                &#125;)\n            &#125;,\n        backgroundColor = HhfTheme.colors.listItem,\n        elevation = 5.dp\n    ) &#123;\n</code></pre>\n<p>这里外层是用了Card,定义了点击item的逻辑。</p>\n<p>里面是这样的：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> Column(Modifier.padding(8.dp)) &#123;\n                /**\n                 * 第一行 水平布局\n                 */\n                Row(verticalAlignment = Alignment.CenterVertically) &#123;\n                    /**\n                     * 分享者没名字\n                     */\n                    Text(\n                        text = if (author.isNotEmpty()) author else shareUser,\n                        fontSize = 13.sp,\n                        color = HhfTheme.colors.textColor\n                    )\n                    /**\n                     * 显示标签\n                     */\n                    if(isShowLabel)&#123;\n                        if (type == 1) &#123;\n                            Box(\n                                Modifier\n                                    .padding(start = 6.dp)\n                                    .border(1.dp, Color.Red, RoundedCornerShape(5.dp))\n                                    .padding(4.dp)\n                            ) &#123;\n                                Text(stringResource(id = R.string.istop), Modifier, Color.Red, 10.sp)\n                            &#125;\n                        &#125;\n                        if (fresh) &#123;\n                            Box(\n                                Modifier\n                                    .padding(start = 6.dp)\n                                    .border(1.dp, Color.Red, RoundedCornerShape(5.dp))\n                                    .padding(4.dp)\n                            ) &#123;\n                                Text(stringResource(id = R.string.neww), Modifier, Color.Red, 10.sp)\n                            &#125;\n                        &#125;\n                        if (tags.isNotEmpty()) &#123;\n                            Box(\n                                Modifier\n                                    .padding(start = 6.dp)\n                                    .border(1.dp, Color(0xFF66BB6A), RoundedCornerShape(5.dp))\n                                    .padding(4.dp)\n                            ) &#123;\n                                Text(tags[0].name, Modifier, Color(0xFF66BB6A), 10.sp)\n                            &#125;\n                        &#125;\n                    &#125;\n                    /**\n                     * 发布日期\n                     */\n                    Text(\n                        niceDate,\n                        Modifier\n                            .weight(1f)\n                            .wrapContentWidth(\n                                Alignment.End\n                            )\n                            .align(Alignment.CenterVertically),\n                        HhfTheme.colors.textColor.copy(0.6f),\n                        fontSize = 13.sp,\n                    )\n                &#125;\n                /**\n                 * 有没有封面图\n                 */\n                if (TextUtils.isEmpty(envelopePic)) &#123;\n                    // 没有封面图\n                    Text(\n                        title.filterHtml(),\n                        Modifier.padding(top = 12.dp),\n                        HhfTheme.colors.textColor,\n                        fontSize = 14.sp,\n                        fontWeight = FontWeight.Bold\n                    )\n                &#125; else &#123;\n                    // 有封面图时，中间区域展示\n                    Row(Modifier.padding(top = 12.dp)) &#123;\n                        // 网络图片\n                        NetworkImage(\n                            envelopePic,\n                            Modifier.size(100.dp),\n                            contentScale = ContentScale.Crop,\n                            defaultImg = R.mipmap.ic_default_round\n                        )\n                        // 垂直布局\n                        Column(Modifier.padding(start = 8.dp)) &#123;\n                            // 标题\n                            Text(\n                                title.filterHtml(),\n                                color = HhfTheme.colors.textColor,\n                                fontSize = 14.sp,\n                                maxLines = 3,\n                                style = TextStyle(fontWeight = FontWeight.Bold)\n                            )\n                            // 摘要描述\n                            Text(\n                                desc,\n                                color = HhfTheme.colors.textInactiveColor,\n                                fontSize = 13.sp,\n                                maxLines = 3,\n                                overflow = TextOverflow.Ellipsis\n                            )\n                        &#125;\n                    &#125;\n                &#125;\n                // 底部水平布局\n                Row &#123;\n                    // 文本\n                    Text(\n                        &quot;$superChapterName / $chapterName&quot;,\n                        Modifier.padding(top = 12.dp),\n                        HhfTheme.colors.textColor,\n                        fontSize = 13.sp\n                    )\n                    // 图标，是否收藏了\n                    Icon(\n                        if(isCollect) Icons.Filled.Favorite else Icons.Filled.FavoriteBorder, contentDescription = &quot;&quot;,\n                        Modifier\n                            .wrapContentWidth(\n                                Alignment.End\n                            )\n                            .weight(1f)\n                            .clickable &#123;\n                                /**\n                                 * 点击收藏，触发请求\n                                 */\n                                favoriteAction(isCollect)\n                                isCollect = !isCollect\n                            &#125;,\n                        tint = HhfTheme.colors.themeColor\n                    )\n                &#125;\n            &#125;\n</code></pre>\n<h3 id=\"11-我的Tab-Mine\"><a href=\"#11-我的Tab-Mine\" class=\"headerlink\" title=\"11.我的Tab-Mine\"></a>11.我的Tab-Mine</h3><p>因为项目和公众号和首页基本一样，这里就不重复分析了。<br>看下我的页面的效果图：<br><img src=mine.jpeg width=50%><br>要实现这样的效果，怎么处理呢？</p>\n<p>首先开启一个协程，获取用户sp数据，转成UserInfo对象</p>\n<pre><code class=\"line-numbers language-Kotlin\">   /**\n     * 开启协程，只走一次\n     */\n    LaunchedEffect(CacheUtils.userInfo) &#123;\n        if (CacheUtils.userInfo != &quot;&quot;) &#123;\n            /**\n             * 根据sp文件，生产一个UserInfo对象，设置给这个我的页面使用\n             */\n            mineViewModel.dispatch(\n                MineViewEvent.SetUserInfo(\n                    Gson().fromJson(\n                        CacheUtils.userInfo, // sp文件\n                        UserInfo::class.java\n                    )\n                )\n            )\n            /**\n             * 获取积分和排名\n             */\n            mineViewModel.dispatch(MineViewEvent.GetIntegral)\n        &#125;\n    &#125;\n</code></pre>\n<p>这里获取积分和排名是需要走接口的<br>这里会走到ViewModel层这个函数：</p>\n<pre><code class=\"line-numbers language-Kotlin\">    private fun getIntegral() &#123;\n        viewModelScope.launch &#123;\n            flow &#123;\n                emit(\n                    TaskApi.create(ApiService::class.java).getIntegral()\n                )\n            &#125;.map &#123;\n                if (it.errorCode == 0) &#123;\n                    it.data\n                        ?: throw Exception(&quot;data null&quot;)\n                &#125; else &#123;\n                    throw Exception(it.errorMsg)\n                &#125;\n            &#125;.onEach &#123;\n                viewStates = viewStates.copy(integral = it)\n            &#125;.catch &#123;\n                viewStates = viewStates.copy(integral = null)\n            &#125;.collect()\n        &#125;\n    &#125;\n</code></pre>\n<p>这个retrofit中是这样定义的：</p>\n<pre><code class=\"line-numbers language-Kotlin\">interface ApiService &#123;\n    /**\n     * 获取当前账户的个人积分\n     */\n    @GET(&quot;lg/coin/userinfo/json&quot;)\n    suspend fun getIntegral(): ApiResponse&lt;Integral&gt;\n</code></pre>\n<p>这个就是一个suspend挂起函数。</p>\n<p>顶层为Column:</p>\n<pre><code class=\"line-numbers language-Kotlin\">    /**\n     * 顶层为列表视图\n     */\n    Column(modifier) &#123;\n        /**\n         * 顶部👤\n         */\n        MineTopAvatar(\n            Modifier\n                .fillMaxWidth()\n                .height(320.dp)\n                .clip(QureytoImageShapes(160f)),\n            mineViewModel.viewStates.userInfo?.run &#123;\n                nickname\n            &#125; ?: &quot;avatar&quot;\n        ) &#123;\n</code></pre>\n<p>头像区域，点击后可以弹pop，但是需要先获取权限，这样获取：</p>\n<pre><code class=\"line-numbers language-Kotlin\">// 图片点击事件 会去申请下权限\n            XXPermissions\n                .with(context)\n                .permission(Permission.CAMERA)\n                .permission(Permission.MANAGE_EXTERNAL_STORAGE)\n                .request(object : OnPermissionCallback &#123;\n                    override fun onGranted(\n                        granted: List&lt;String&gt;,\n                        all: Boolean\n                    ) &#123;\n                        if (all) &#123;\n                            if(isLogin)&#123;\n                                mineViewModel.dispatch(MineViewEvent.ChangePopupState(true))\n                            &#125;\n                            else&#123;\n                                CpNavigation.to(ModelPath.Login)\n                            &#125;\n                        &#125;\n                    &#125;\n\n                    override fun onDenied(\n                        denied: List&lt;String&gt;,\n                        never: Boolean\n                    ) &#123;\n                        if (never) &#123;\n                            context.showToast(context.stringResource(R.string.permissions_cm_error))\n                            XXPermissions.startPermissionActivity(\n                                context,\n                                denied\n                            )\n                        &#125; else &#123;\n                            context.showToast(context.stringResource(R.string.permissions_camera_error))\n                        &#125;\n                    &#125;\n                &#125;)\n</code></pre>\n<p>用了一个三方库实现。</p>\n<p>中间操作栏这样实现：</p>\n<pre><code class=\"line-numbers language-Kotlin\">  // 操作栏 有个外边框，包裹菜单项，底部有阴影\n        Surface(\n            Modifier\n                .padding(start = 20.dp, end = 20.dp)\n                .fillMaxWidth()\n                .background(HhfTheme.colors.background),\n            elevation = 2.dp,\n            shape = RoundedCornerShape(8.dp),\n            color = MaterialTheme.colors.surface, // color will be adjusted for elevation\n        ) &#123;\n</code></pre>\n<p>具体的菜单项也是用懒加载实现：</p>\n<pre><code class=\"line-numbers language-Kotlin\">LazyColumn(Modifier.background(HhfTheme.colors.listItem)) &#123;\n                itemsIndexed(list) &#123; i, bean -&gt;\n\n                    /**\n                     * 我的页面遍历菜单项\n                     */\n                    MineItem(\n                        Modifier\n                            .fillMaxWidth()\n                            .clickable &#123;\n                                /**\n                                 * 分发开发者行为\n                                 */\n                                mineViewModel.dispatch(MineViewEvent.ToComposable(bean.id))\n                            &#125;\n                            .height(45.dp), bean.name, HhfTheme.colors.themeColor,\n                        bean.icon)\n                    if (i &lt; list.size - 1) &#123;\n                        /**\n                         * 非最后一行显示分割线\n                         */\n                        Divider(\n                            modifier = Modifier\n                                .fillMaxWidth()\n                                .padding(start = 10.dp, end = 10.dp)\n                        )\n                    &#125;\n                &#125;\n            &#125;\n</code></pre>\n<p>具体的菜单item,有图标+文字+右侧箭头实现：</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n@Composable\nfun MineItem(\n    modifier: Modifier = Modifier, textName: String, iconColor: Color, icon: ImageVector\n) &#123;\n    Row(\n        modifier,\n        verticalAlignment = Alignment.CenterVertically,\n    ) &#123;\n        Icon(\n            icon, &quot;$textName icon&quot;,\n            Modifier\n                .size(28.dp)\n                .padding(start = 10.dp), iconColor\n        )\n        Text(\n            textName,\n            Modifier.padding(start = 10.dp),\n            fontSize = 14.sp,\n            fontFamily = FontFamily.Serif,\n            color = HhfTheme.colors.textColor\n        )\n        Icon(\n            Icons.Filled.KeyboardArrowRight, textName,\n            Modifier\n                .weight(1f)\n                .padding(end = 10.dp)\n                .wrapContentWidth(Alignment.End),\n            tint = HhfTheme.colors.textColor\n        )\n    &#125;\n&#125;\n</code></pre>\n<p>UI搞定了，跳转逻辑怎么处理呢？<br>答案是viewModel层实现。</p>\n<p>这里有个clickable点击闭包：<br><code> mineViewModel.dispatch(MineViewEvent.ToComposable(bean.id))</code></p>\n<p>会委托给mineViewModel处理：</p>\n<pre><code class=\"line-numbers language-Kotlin\">    /**\n     * 分发开发者行为\n     */\n    fun dispatch(action: MineViewEvent) &#123;\n        when (action) &#123;\n            is MineViewEvent.Blur -&gt; bitmapBlur(action.s)\n            /**\n             * 用户点击菜单项\n             */\n            is MineViewEvent.ToComposable -&gt; toComposable(action.type)\n            is MineViewEvent.ChangePopupState -&gt; &#123;\n                Log.e(&quot;TEST##&quot;, &quot;这里触发了viewStates中 isShowpopup 变更为：$&#123;action.flag&#125;&quot;)\n                viewStates = viewStates.copy(isShowPopup = action.flag)\n            &#125;\n            is MineViewEvent.SetUserInfo -&gt; viewStates = viewStates.copy(userInfo = action.userInfo)\n            is MineViewEvent.GetIntegral -&gt; getIntegral()\n        &#125;\n    &#125;\n</code></pre>\n<p>这里分发开发者行为，其实更像用户行为，有可能不是用户触发，所以我这里称之为开发者行为。</p>\n<p>点击菜单项继续分发：</p>\n<pre><code class=\"line-numbers language-Kotlin\">private fun toComposable(type: Int) &#123;\n        if(isLogin)&#123;\n            when (type) &#123;\n                0 -&gt; CpNavigation.to(ModelPath.Integral)\n                1 -&gt; CpNavigation.to(ModelPath.Collect)\n                2 -&gt; CpNavigation.to(ModelPath.Share)\n                3 -&gt; CpNavigation.to(ModelPath.Todo)\n                4 -&gt; CpNavigation.toBundle(ModelPath.WebView, Bundle().apply &#123;\n                    putString(webTitle, &quot;PlayAndroid&quot;)\n                    putString(webUrl, &quot;https://github.com/yellowhai/PlayAndroid&quot;)\n                    putBoolean(webIsCollect, false)\n                    putInt(webCollectId, 998)\n                    putInt(webCollectType, 1)\n                &#125;)\n                5 -&gt; CpNavigation.to(ModelPath.Setting)\n            &#125;\n        &#125;\n        else&#123;\n            when (type) &#123;\n                4 -&gt; CpNavigation.toBundle(ModelPath.WebView, Bundle().apply &#123;\n                    putString(webTitle, &quot;PlayAndroid&quot;)\n                    putString(webUrl, &quot;https://github.com/yellowhai/PlayAndroid&quot;)\n                    putBoolean(webIsCollect, false)\n                    putInt(webCollectId, 998)\n                    putInt(webCollectType, 1)\n                &#125;)\n                5 -&gt; CpNavigation.to(ModelPath.Setting)\n                else -&gt; CpNavigation.to(ModelPath.Login)\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>这里定义了跳转逻辑，这里有回到 第8点主页外部架构 中的导航定义了。<br>实现跳转到其它页面了，这更像是在布局上叠加，不算是跳转吧。</p>\n<p>这个项目还有很多细节值得一探究竟，不过对于初始compose，也差不多了，了解到这个程度也算入门了吧。</p>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<blockquote>\n<p>玩Android(compose版本)项目地址：<a href=\"https://github.com/yellowhai/PlayAndroid\">https://github.com/yellowhai/PlayAndroid</a></p>\n</blockquote>\n<h3 id=\"1-项目settings-gradle\"><a href=\"#1-项目settings-gradle\" class=\"headerlink\" title=\"1.项目settings.gradle\"></a>1.项目settings.gradle</h3><pre><code class=\"line-numbers language-groovy\">dependencyResolutionManagement &#123;\n    /**\n     * 原文中说默认情况下，项目中的存储库会覆盖设置中的存储库 ，可以通过设置模式来更改这种行为\n     设置存储库的方法：\n     repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n     存储库模式：\n     PREFER_PROJECT(true)--首选项目存储库\n     PREFER_SETTINGS(false)--首选设置存储库\n     FAIL_ON_PROJECT_REPOS(false)--强制设置存储库\n     */\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories &#123;\n        google()\n        mavenCentral()\n        maven &#123; url &quot;https://jitpack.io&quot; &#125;\n        maven &#123;\n            url &#39;https://maven.aliyun.com/repository/public/&#39;\n        &#125;\n        maven &#123; url &#39;https://maven.aliyun.com/repository/public&#39; &#125;\n        maven &#123; url &#39;https://maven.aliyun.com/repository/central&#39; &#125;\n        maven &#123; url &#39;https://maven.aliyun.com/repository/google&#39; &#125;\n        maven &#123; url &#39;https://maven.aliyun.com/repository/public&#39; &#125;\n        maven &#123; url &#39;https://maven.aliyun.com/repository/gradle-plugin&#39; &#125;\n    &#125;\n&#125;\nrootProject.name = &quot;PlayAndroid&quot;\ninclude &#39;:app&#39;\ninclude &#39;:common&#39;\ninclude &#39;:h_mine&#39;\ninclude &#39;:toolkit&#39;\n</code></pre>\n<p>还是很容易理解的，repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)这个是新增的，简单看下就行。<br>引入了app模块(主模块)，common模块（通用模块，用于通用组件相关）,h_mine模块（我的模块，可以单独编译）。</p>\n<h3 id=\"2-config-gradle\"><a href=\"#2-config-gradle\" class=\"headerlink\" title=\"2.config.gradle\"></a>2.config.gradle</h3><p>这个文件相信大家都有用过的，配置远程依赖的一个文件，统一管理。</p>\n<pre><code class=\"line-numbers language-groovy\">ext&#123;\n    isRelease = true\n\n    //android构建配置\n    android_models = [\n            compileSdk : 32,\n            minSdk : 23,\n            targetSdk : 32,\n            versionCode : 1,\n            versionName : &quot;1.0&quot;\n    ]\n    \n    app_id = [\n            mine      : &#39;com.hh.mine&#39;,\n    ]\n\n    core_ktx_version = &#39;1.7.0&#39;\n    appcompat_version = &#39;1.4.0&#39;\n    lifecycle_version = &#39;2.4.0&#39;\n    material_version = &#39;1.4.0&#39;\n    work_version = &#39;2.7.1&#39;\n    gson_version = &#39;2.8.9&#39;\n    litepal_version = &#39;3.2.3&#39;\n    landscapist_version = &#39;1.4.5&#39;\n    retrofit_version = &#39;2.9.0&#39;\n    okhttp_version = &#39;4.9.3&#39;\n    startup_version = &#39;1.1.0&#39;\n    XXPermissions_version = &#39;13.2&#39;\n    datastore_version = &#39;1.0.0&#39;\n    materialDialog_version = &#39;0.6.2&#39;\n    accompanist_version = &#39;0.25.0&#39;\n\n\n    jetpack_compose = [\n            material : &quot;androidx.compose.material:material:$compose_version&quot;,\n            activity : &quot;androidx.activity:activity-compose:$appcompat_version&quot;,\n    ]\n\n    commonApi = [\n            ktx_core        : &quot;androidx.core:core-ktx:$core_ktx_version&quot;,\n            lifecycle       : &quot;androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version&quot;,\n            appcompat       : &quot;androidx.appcompat:appcompat:$appcompat_version&quot;,\n            material        : &quot;com.google.android.material:material:$material_version&quot;,\n            //数据存储\n            datastore       : &quot;androidx.datastore:datastore-preferences:$datastore_version&quot;,\n            //权限处理\n            XXPermissions   : &quot;com.github.getActivity:XXPermissions:$XXPermissions_version&quot;,\n    ]\n\n    net = [\n            retrofit    : &quot;com.squareup.retrofit2:retrofit:$retrofit_version&quot;,\n            converter   : &quot;com.squareup.retrofit2:converter-gson:$retrofit_version&quot;,\n            okhttp      : &quot;com.squareup.okhttp3:logging-interceptor:$okhttp_version&quot;,\n            gson        : &quot;com.google.code.gson:gson:$gson_version&quot;\n    ]\n\n    accompanist_ui = [\n            insets_ui    : &quot;com.google.accompanist:accompanist-insets-ui:$accompanist_version&quot;,\n            navigation   : &quot;com.google.accompanist:accompanist-navigation-animation:$accompanist_version&quot;,\n            pager        : &quot;com.google.accompanist:accompanist-pager:$accompanist_version&quot;,\n            swiperefresh : &quot;com.google.accompanist:accompanist-swiperefresh:$accompanist_version&quot;,\n            flowlayout   : &quot;com.google.accompanist:accompanist-flowlayout:$accompanist_version&quot;,\n            systemUi     : &quot;com.google.accompanist:accompanist-systemuicontroller:$accompanist_version&quot;,\n            webview      : &quot;com.google.accompanist:accompanist-webview:$accompanist_version&quot;\n    ]\n\n    database =[\n            litepal :  &quot;org.litepal.guolindev:core:$litepal_version&quot;\n    ]\n\n    skydoves_coil = [\n            landscapist_coil :  &quot;com.github.skydoves:landscapist-coil:$landscapist_version&quot;\n    ]\n\n    workManager = [\n            // Kotlin + coroutines\n            work = &quot;androidx.work:work-runtime-ktx:$work_version&quot;\n    ]\n\n    material_dialog = [\n            color : &quot;io.github.vanpra.compose-material-dialogs:color:$materialDialog_version&quot;,\n            core  : &quot;io.github.vanpra.compose-material-dialogs:core:$materialDialog_version&quot;,\n            datetime  : &quot;io.github.vanpra.compose-material-dialogs:datetime:$materialDialog_version&quot;\n    ]\n\n    paging = &quot;androidx.paging:paging-compose:1.0.0-alpha14&quot;\n\n    jetpackComposeLibs = jetpack_compose.values()\n    commonApiLibs = commonApi.values()\n    netLibs = net.values()\n    materialDialogLibs = material_dialog.values()\n&#125;\n</code></pre>\n<p>层次还是比较清晰，对于同一组单独建立数组存储，模块中只需要引入一个就将这组全部引入进去了。</p>\n<h3 id=\"3-app模块下的build-gradle\"><a href=\"#3-app模块下的build-gradle\" class=\"headerlink\" title=\"3.app模块下的build.gradle\"></a>3.app模块下的build.gradle</h3><p>显示引入com.android.application+kotlin-android的插件。<br>下面配置android闭包，很简单。</p>\n<p>其它关于compose的也需要配置下：</p>\n<pre><code class=\"line-numbers language-groovy\"> compileOptions &#123;\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    &#125;\n    buildFeatures &#123;\n        compose true\n    &#125;\n    composeOptions &#123;\n        kotlinCompilerExtensionVersion compose_version\n        kotlinCompilerVersion kotlin_version\n    &#125;\n</code></pre>\n<p>然后是远程依赖：</p>\n<pre><code class=\"line-numbers language-groovy\">dependencies &#123;\n    // 如果是release模式，就把我的模块加进来\n    if(isRelease)&#123;\n        implementation project(&#39;:h_mine&#39;)\n    &#125;\n\n    // 初始化组件\n    implementation &quot;androidx.startup:startup-runtime:$startup_version&quot;\n    implementation project(&#39;:common&#39;)\n\n    // 测试相关\n    testImplementation &#39;junit:junit:4.13.2&#39;\n    androidTestImplementation &#39;androidx.test.ext:junit:1.1.3&#39;\n    androidTestImplementation &#39;androidx.test.espresso:espresso-core:3.4.0&#39;\n    androidTestImplementation &quot;androidx.compose.ui:ui-test-junit4:$compose_version&quot;\n    androidTestImplementation &quot;androidx.compose.ui:ui-test-junit4:$compose_version&quot;\n    debugImplementation &quot;androidx.compose.ui:ui-tooling:$compose_version&quot;\n\n&#125;\n</code></pre>\n<p>isRelease定义在 config.gradle的顶部。如果是集成编译就为true，单独编译为false。</p>\n<h3 id=\"4-app模块的AndroidManifest-xml\"><a href=\"#4-app模块的AndroidManifest-xml\" class=\"headerlink\" title=\"4.app模块的AndroidManifest.xml\"></a>4.app模块的AndroidManifest.xml</h3><ul>\n<li>配置Application</li>\n<li>配置主页</li>\n<li>配置provider，用于初始化sdk<pre><code class=\"line-numbers language-xml\">  &lt;!--  用provider初始化sdk--&gt;\n    &lt;provider\n        android:name=&quot;androidx.startup.InitializationProvider&quot;\n        android:authorities=&quot;$&#123;applicationId&#125;.androidx-startup&quot;\n        android:exported=&quot;false&quot;\n        tools:node=&quot;merge&quot;&gt;\n        &lt;meta-data\n            android:name=&quot;com.hh.playandroid.base.BaseInitializer&quot;\n            android:value=&quot;androidx.startup&quot; /&gt;\n    &lt;/provider&gt;\n</code></pre>\n</li>\n</ul>\n<h3 id=\"5-自定义Application\"><a href=\"#5-自定义Application\" class=\"headerlink\" title=\"5.自定义Application\"></a>5.自定义Application</h3><pre><code>class HhfApp : YshhApplication()\n</code></pre>\n<p> 依赖common模块：</p>\n<pre><code class=\"line-numbers language-Kotlin\">open class YshhApplication : Application() &#123;\n\n   lateinit var okbuilder: OkHttpClient\n\n   companion object &#123;\n       /**\n        * application context.\n        */\n       @SuppressLint(&quot;StaticFieldLeak&quot;)\n       lateinit var context: Context\n\n       @SuppressLint(&quot;StaticFieldLeak&quot;)\n       lateinit var instance: YshhApplication\n\n       /**\n        * application级别的协程\n        * 有时我们需要在协程上下文中定义多个元素，组合协程上下文中的元素，使用 + 操作符来创建 CoroutineScope .\n        */\n       val applicationScope = CoroutineScope(SupervisorJob() + Dispatchers.Main)\n   &#125;\n</code></pre>\n<p> 这里懒加载OkHttpClient<br> 定义了全局的协程，静态变量。</p>\n<pre><code class=\"line-numbers language-Kotlin\">  override fun onCreate() &#123;\n       super.onCreate()\n       context = applicationContext\n       instance = this\n       initRetrofit()\n   &#125;\n</code></pre>\n<p> 初始化Retrofit：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n    * 初始化Retrofit\n    */\n   private fun initRetrofit(token : String = &quot;&quot;): OkHttpClient &#123;\n       //请求头\n       val headerInterceptor = Interceptor &#123; chain: Interceptor.Chain -&gt;\n           val orignaRequest = chain.request()\n           val request = orignaRequest.newBuilder()\n               .header(&quot;Authorization&quot;, &quot;Bearer $token&quot;)\n               .method(orignaRequest.method, orignaRequest.body)\n               .build()\n           chain.proceed(request)\n       &#125;\n       val logInterceptor = LogInterceptor &#123;\n//            it.logE()\n       &#125;\n       // 日志类别\n       logInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);\n       // 缓存相关\n       val cacheFile =\n           File(getExternalFilesDir(Environment.DIRECTORY_PICTURES).toString() + &quot;http_cache&quot;)\n       val cache = Cache(cacheFile, 104857600L) // 指定缓存大小100Mb\n       val builder = OkHttpClient.Builder()\n       //        builder.addInterceptor(addQueryParameterInterceptor);\n       builder.addInterceptor(headerInterceptor)\n       builder.cache(cache)\n       builder.addNetworkInterceptor(logInterceptor)\n       builder.cookieJar(cookieJar)\n       builder.readTimeout(60000, TimeUnit.MILLISECONDS)\n       //全局的写入超时时间60s\n       builder.writeTimeout(60000, TimeUnit.MILLISECONDS)\n       //全局的连接超时时间30s\n       builder.connectTimeout(30000, TimeUnit.MILLISECONDS)\n       okbuilder = builder.build()\n       return builder.build()\n   &#125;\n\n   private val cookieJar: PersistentCookieJar by lazy &#123;\n       PersistentCookieJar(SetCookieCache(), SharedPrefsCookiePersistor(context))\n   &#125;\n   \n   fun getOkBuilder(): OkHttpClient &#123;\n       return okbuilder\n   &#125;\n</code></pre>\n<h3 id=\"6-首页-MainActivity\"><a href=\"#6-首页-MainActivity\" class=\"headerlink\" title=\"6.首页 MainActivity\"></a>6.首页 MainActivity</h3><p> 继承BaseActivity:</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n/**\n* 基类Activity 设置非沉浸式，因为要设置导航栏和状态栏颜色\n*/\nabstract class BaseActivity : AppCompatActivity() &#123;\n\n   override fun onCreate(savedInstanceState: Bundle?) &#123;\n       super.onCreate(savedInstanceState)\n       WindowCompat.setDecorFitsSystemWindows(window, false)\n   &#125;\n\n&#125;\n</code></pre>\n<p>onCreate生命周期：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> @Suppress(&quot;DEPRECATED_IDENTITY_EQUALS&quot;)\n    @OptIn(ExperimentalAnimationApi::class)\n    override fun onCreate(savedInstanceState: Bundle?) &#123;\n        super.onCreate(savedInstanceState)\n        // 动画渐变\n        overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out)\n        // 设置内容\n        setContent &#123;\n            Log.e(&quot;TEST##&quot;, &quot;开始setContent了&quot;)\n            // 顶层为自定义主题\n            HhfTheme(\n                // 是否暗色或亮色，跟随系统，如果用户主动设置，跟随用户\n                theme = if (isSystemInDarkTheme() || isNight) HhfTheme.Theme.Dark else HhfTheme.Theme.Light,\n                // 用户自行设置的颜色主题\n                colorTheme = appTheme\n            ) &#123;\n                // 创建一个MainViewModel\n                val viewModel : MainViewModel = viewModel()\n\n                // 如果isSplash为true,就展示SplashView 启动页\n                if (viewModel.isSplash) &#123;\n                    Log.e(&quot;TEST##&quot;, &quot;加载闪屏了&quot;)\n                    SplashView &#123; viewModel.isSplash = false &#125;\n                &#125; else &#123;\n                    Log.e(&quot;TEST##&quot;, &quot;加载首页了&quot;)\n                    // 全局静态变量存 底部控制器\n                    CpNavigation.navHostController = rememberAnimatedNavController()\n                    // 主页面\n                    HhfNavigation()\n                    // 进度条\n                    DialogProgress()\n                &#125;\n                // 是否纪念日，将App置灰\n                if(isMourningDay())&#123;\n                    Canvas(modifier = Modifier.fillMaxSize())&#123;\n                        drawRect(color = Color.White,blendMode = BlendMode.Saturation)\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        addCallback()\n    &#125;\n</code></pre>\n<p>因为这个app就一个Activity，setContent中的内容就是展现给用户可以看到的所有东西了。<br>顶层是一个自定义主题：</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun HhfTheme(\n    theme: HhfTheme.Theme = HhfTheme.Theme.Light,\n    colorTheme: Color? = null,\n    content: @Composable () -&gt; Unit\n) &#123;\n    val targetColors = if (theme == HhfTheme.Theme.Dark) &#123;\n        colorTheme?.let &#123;\n            rememberSystemUiController().setNavigationBarColor(colorTheme)\n            DarkColorPalette.apply &#123;\n                themeColor = it\n            &#125;\n        &#125;?:DarkColorPalette\n    &#125; else &#123;\n        colorTheme?.let &#123;\n            rememberSystemUiController().setNavigationBarColor(colorTheme)\n            LightColorPalette.apply &#123;\n                themeColor = it\n            &#125;\n        &#125;?:LightColorPalette\n    &#125;\n    val themeColor = animateColorAsState(targetColors.themeColor, TweenSpec(600))\n    val textColor = animateColorAsState(targetColors.textColor, TweenSpec(600))\n    val background = animateColorAsState(targetColors.background,TweenSpec(600))\n    val listItem =  animateColorAsState(targetColors.listItem,TweenSpec(600))\n    val bottomBar =  animateColorAsState(targetColors.bottomBar,TweenSpec(600))\n    val divider =  animateColorAsState(targetColors.divider,TweenSpec(600))\n    val textFieldBackground =  animateColorAsState(targetColors.textFieldBackground,TweenSpec(600))\n    val colors = HhfColors(themeColor.value,\n        textColor.value,\n        background = background.value,\n        listItem = listItem.value,\n        bottomBar = bottomBar.value,\n        divider = divider.value,\n        textFieldBackground = textFieldBackground.value,\n        )\n    CompositionLocalProvider(LocalHhfColors provides colors) &#123;\n        MaterialTheme(\n            shapes = Shapes,\n            typography = typography\n        ) &#123;\n            content.invoke()\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里用到了一个 CompositionLocalProvider，具体用法可以参考 <a href=\"https://juejin.cn/post/7097890697721675813\">https://juejin.cn/post/7097890697721675813</a></p>\n<p>在Compose函数里，如果要用到函数外提供的值，一般都要通过函数定义好参数，外部调用时传入进去。<br>这种方法表面看没啥问题，但在一些场景下就不是很方便。比如一个函数A嵌套一个函数B，函数B嵌套函数C，并且这A、B、C的函数都用到这个参数，那对三个函数来说都需要定义这个参数，就不是那么方便。<br>那用个全局变量不就可以解决需要重复定义参数，确实可以。但全局变量有个副作用就是影响的范围比较大。本身我们定义的参数只会影响到函数内部。这个时候我们就可以使用CompositionLocal：它具有穿透函数功能的局部变量<br>CompositionLocal适用场景：用来提供上下文数据，不扩大影响范围。</p>\n<p>然后最终主题呈现是用了 MaterialTheme这个类展现。</p>\n<p>回到首页，内容区：</p>\n<ul>\n<li>闪屏页展示逻辑<br>  通过一个变量：<code>  var isSplash by mutableStateOf(true)</code> 实现控制是否显示</li>\n<li>加载首页<br> 先 展示主页面，覆盖一层 进度条</li>\n<li>是否纪念日<br>  app置灰处理    </li>\n<li>添加二次点击返回退出app逻辑</li>\n</ul>\n<p>首页逻辑基本就这么多了。</p>\n<h3 id=\"7-闪屏ui-gt-SplashView\"><a href=\"#7-闪屏ui-gt-SplashView\" class=\"headerlink\" title=\"7.闪屏ui -&gt; SplashView\"></a>7.闪屏ui -&gt; SplashView</h3><p>看下效果先：<br><img src=%E9%97%AA%E5%B1%8F%E9%A1%B5.gif width = 50%></p>\n<p>可以看到进入app后有个启动页面，中间是logo。<br>那这个页面有个渐变动画，淡入淡出效果。</p>\n<p>具体ui是这样的：</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun SplashView(startMain: () -&gt; Unit) &#123;\n    /**\n     * 辅助文字颜色变化 建立的一个mutableState包装的变量，实际上就是bool值\n     */\n    var enabled by remember &#123; mutableStateOf(false) &#125;\n\n    /**\n     * 背景颜色，从0.3alpha主题色变为纯主题色，2s的时间\n     */\n    val bgColor: Color by animateColorAsState(\n        if (enabled) HhfTheme.colors.themeColor\n        else HhfTheme.colors.themeColor.copy(alpha = 0.3f),\n        animationSpec = tween(durationMillis = 2000)\n    )\n\n    /**\n     * 中间文字颜色动画，如果enable为false，0.3alpha的颜色 到纯白色 2s的时间\n     */\n    val textColor: Color by animateColorAsState(\n        if (enabled) Color.White\n        else Color.White.copy(alpha = 0.3f),\n        animationSpec = tween(durationMillis = 2000)\n    )\n\n    // 外层一个Box+中间一个Text\n    Box(\n        Modifier\n            .fillMaxSize()\n            .background(bgColor),\n        contentAlignment = Alignment.Center\n    ) &#123;\n        Text(text = &quot;PlayAndroid&quot;, color = textColor,style = MaterialTheme.typography.h5)\n    &#125;\n\n    // 开启协程 可以看出Compose里面开启协程的方法\n    LaunchedEffect(Unit) &#123;\n        enabled = true\n        delay(2000)\n        // 2s后，设置 mutableStateOf 包装的bool变量 为false 会通知首页重新走setContent方法\n        startMain.invoke()\n    &#125;\n&#125;\n</code></pre>\n<p>这里需要理解 animateColorAsState 是官方提供的一个动画，支持颜色变化的一个composable方法。</p>\n<p>然后这里开启了2s延迟，怎么开延迟的，调用LaunchedEffect方法里面的delay，可以实现延迟效果。然后执行startMain回调。</p>\n<p>这个回调很简单：viewModel.isSplash &#x3D; false</p>\n<p>虽然很简单，但实际上走了很多流程的。</p>\n<pre><code class=\"line-numbers language-Kotlin\">class MainViewModel : ViewModel() &#123;\n    var isSplash by mutableStateOf(true)\n&#125;\n</code></pre>\n<p>这里使用mutableStateOf包装了一个布尔值。 上面触发这改变时，会刷新composable注解声明的方法体。这里应该就是刷新MainActivity整个内容区了。</p>\n<h3 id=\"8-主页面外部架构\"><a href=\"#8-主页面外部架构\" class=\"headerlink\" title=\"8.主页面外部架构\"></a>8.主页面外部架构</h3><pre><code class=\"line-numbers language-Kotlin\">@ExperimentalAnimationApi\n@OptIn(ExperimentalPagerApi::class)\n@Composable\nfun HhfNavigation() &#123;\n    AnimatedNavHost(navController = CpNavigation.navHostController,\n        /**\n         * 首页默认页面\n         */\n        startDestination = ModelPath.Main.route,\n        enterTransition = &#123; fadeIn(animationSpec = tween(700), initialAlpha = 0f) &#125;,\n        exitTransition = &#123; fadeOut(animationSpec = tween(700), targetAlpha = 0f) &#125;) &#123;\n\n        /**\n         * 定义接收到 main 路由消息后-&gt;展示MainContent视图\n         */\n        composable(ModelPath.Main.route) &#123;\n            MainContent()\n        &#125;\n\n        /**\n         * 接收到 setting 路由消息后 -&gt; 设置页面\n         */\n        composable(ModelPath.Setting.route) &#123;\n            CpSetting(Modifier.fillMaxSize())\n        &#125;\n        ...\n</code></pre>\n<p>这里使用了一个AnimatedNavHost，这个类是官方提供的。<br>这个类里面定义了所有我们需要跳转的页面和初始页。<br>然后这个 需要传一个参数，也就是控制器：<br><code> CpNavigation.navHostController = rememberAnimatedNavController()</code><br>这里也是官方提供的remember包装的一个控制器。</p>\n<p>这里的初始页为：<code>  startDestination = ModelPath.Main.route,</code><br>本质上就是一个string，首页的路由。</p>\n<p>这样会默认展示首页，怎么展示首页呢？</p>\n<pre><code class=\"line-numbers language-Kotlin\">composable(ModelPath.Main.route) &#123;\n            MainContent()\n        &#125;\n</code></pre>\n<p>那么这个MainContent就是我们的首页。</p>\n<p>其它composable里面都是首页可能去哪些页面的路由定义。</p>\n<p>那这个比如跳转到设置页面，怎么处理呢？</p>\n<ul>\n<li>首先在这个AnimatedNavHost里面定义一个composable闭包</li>\n</ul>\n<pre><code class=\"line-numbers language-Kotlin\"> composable(ModelPath.Setting.route) &#123;\n            CpSetting(Modifier.fillMaxSize())\n        &#125;\n</code></pre>\n<ul>\n<li>然后再需要跳转的地方调用<br><code>navHostController.navigate(“setting”)</code><br>这个navHostController就是我们之前定义的那个控制器，setting就是路由名称。<br>这样子就可以跳转到设置页面了。</li>\n</ul>\n<h3 id=\"9-主页内部架构框\"><a href=\"#9-主页内部架构框\" class=\"headerlink\" title=\"9.主页内部架构框\"></a>9.主页内部架构框</h3><p>首先看下主页效果图<br><img src=%E9%A6%96%E9%A1%B5.jpeg width=50%><br>轮播图+中间列表+底部bar<br>轮播图+中间列表可以看成一个整体，那就是内容区+底部bar</p>\n<p>架构怎么搭建呢？</p>\n<pre><code class=\"line-numbers language-Kotlin\">   Scaffold(bottomBar = &#123;\n        AnimatedVisibility(\n            visible = bottomSwitch,\n            enter = expandVertically() + fadeIn(), // 操作符重载了，第一个为空，就用第二个\n            exit = shrinkVertically() + fadeOut()  // 操作符重载了，第一个为空，就用第二个\n        ) &#123;\n            // 实际的底部bar 高度使用 固有特性测量 可以参考：https://juejin.cn/post/7068164264363556872\n            MainBottomBar(\n                Modifier\n                    .fillMaxWidth()\n                    .height(IntrinsicSize.Max),pagerState = pagerState) &#123;\n                pagerState.reenableScrolling(coroutineScope, it)\n            &#125;\n        &#125;\n    &#125;) &#123;\n        内容区...\n</code></pre>\n<p>最外层一个Scafffold脚手架包裹，有点像Flutter了啊。<br>然后是一个AnimatedVisibility，这个控制显示隐藏的动画组件。重点看里面的MainBottomBar，就找到了我们的底部bar了。</p>\n<p>这个看起来像自定义的，具体怎么实现的呢？</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * App底部bar\n */\n@OptIn(ExperimentalPagerApi::class)\n@Composable\nprivate fun MainBottomBar(\n    modifier: Modifier = Modifier,\n    pagerState: PagerState,\n    currentChanged: (Int) -&gt; Unit\n) &#123;\n    /**\n     * 这个BottomAppBar是官方的\n     */\n    BottomAppBar(\n        modifier.navigationBarsPadding(),\n        cutoutShape = CircleShape,\n        backgroundColor = HhfTheme.colors.bottomBar,\n        elevation = 5.dp\n    ) &#123;\n        // 遍历4个tab\n        bottomList.forEachIndexed &#123; index, item -&gt;\n            // item单独设置 官方组件\n            BottomNavigationItem(\n                selected = pagerState.currentPage == index, onClick = &#123;\n                    /**\n                     * item点击事件回调给上层\n                     */\n                    currentChanged(index)\n                &#125;, icon = &#123;\n                    /**\n                     * icon为官方组件\n                     */\n                    Icon(\n                        item.dashboardState.icon,\n                        contentDescription = item.name,\n                        tint = if (pagerState.currentPage == index) &#123;\n                            HhfTheme.colors.themeColor\n                        &#125; else &#123;\n                            LocalContentColor.current.copy(alpha = LocalContentAlpha.current)\n                        &#125;, modifier = Modifier.size(24.dp)\n                    )\n                &#125;, label = &#123;\n                    Text(\n                        text = item.name,\n                        color = if (pagerState.currentPage == index) &#123;\n                            HhfTheme.colors.themeColor\n                        &#125; else &#123;\n                            LocalContentColor.current.copy(alpha = LocalContentAlpha.current)\n                        &#125;,\n                        fontSize = 12.sp\n                    )\n                &#125;,\n                unselectedContentColor = LocalContentColor.current.copy(alpha = LocalContentAlpha.current),\n                selectedContentColor = HhfTheme.colors.themeColor,\n                alwaysShowLabel = true\n\n            )\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里看出底部bar就是用了官方的BottomAppBar。<br>里面具体内容是我们开发者自行设定的，这里遍历了bottomList，这个集合就是我们自己定义的一个集合：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * 底部List集合 这里定义了4块\n * 首页，项目，公众号，我的\n */\nval bottomList = listOf(\n    BottomBean(\n        DashboardState.Home,\n        YshhApplication.context.stringResource(R.string.main_title_home)\n    ),\n    BottomBean(\n        DashboardState.Project,\n        YshhApplication.context.stringResource(R.string.main_title_project)\n    ),\n    BottomBean(\n        DashboardState.PubAccount,\n        YshhApplication.context.stringResource(R.string.main_title_account)\n    ),\n    BottomBean(\n        DashboardState.Mine,\n        YshhApplication.context.stringResource(R.string.main_title_mine)\n    )\n)\n</code></pre>\n<p>就这几个模块。</p>\n<p>底部bar的item就是 BottomNavigationitem里面的了，可以看到是一个icon+label构成。有个onClick的参数就是点击事件回调了，这里调用了 回调函数，传递给上层了，传出去的参数就一个int，表示第几页。</p>\n<p>回调到哪里呢？</p>\n<pre><code class=\"line-numbers language-Kotlin\"> // 实际的底部bar 高度使用 固有特性测量 可以参考：https://juejin.cn/post/7068164264363556872\n            MainBottomBar(\n                Modifier\n                    .fillMaxWidth()\n                    .height(IntrinsicSize.Max),pagerState = pagerState) &#123;\n                pagerState.reenableScrolling(coroutineScope, it)\n            &#125;\n</code></pre>\n<p>这里通过调用rememberPagerState这个对象的<code>  pagerState.reenableScrolling(coroutineScope, it)</code>这个方法实现滚动到目标tab下。也就实现了页面切换。<br>最为关键的就是这个pagerState，同步页面数据和底部bar。</p>\n<p>等下分析内容区也会用到。</p>\n<pre><code class=\"line-numbers language-Kotlin\"> // 水平分页\n            HorizontalPager(\n                count = bottomList.size,\n                modifier.weight(1f), pagerState, userScrollEnabled = true\n            ) &#123; page -&gt;\n                when (page) &#123;\n                    // 首页tab\n                    0 -&gt; HomeView(\n                        Modifier\n                            .fillMaxSize()\n                            .background(HhfTheme.colors.background)\n                            .align(Alignment.CenterHorizontally)\n                    )\n                    // 项目tab\n                    1 -&gt; ProjectView(\n                        Modifier\n                            .fillMaxSize()\n                            .align(Alignment.CenterHorizontally)\n                    )\n                    // 公众号tab\n                    2 -&gt; AccountView(\n                        Modifier\n                            .fillMaxSize()\n                            .background(HhfTheme.colors.background)\n                            .align(Alignment.CenterHorizontally)\n                    )\n                    // 我的tab\n                    3 -&gt; &#123;\n//                        if (isLogin) &#123;\n                            Mine(\n                                Modifier\n                                    .fillMaxSize()\n                                    .background(HhfTheme.colors.background)\n                                    .align(Alignment.CenterHorizontally)\n                            )\n//                        &#125; else &#123;\n//                            ErrorBox(\n//                                Modifier.fillMaxSize(),\n//                                title = stringResource(id = R.string.sign_in)\n//                            )\n//                            &#123; CpNavigation.to(ModelPath.Login) &#125;\n//                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n</code></pre>\n<p>这里是中间内容区。通过使用水平分页得以实现。可以看到传入了一个参数，也就是上面底部bar用到的一个pagerState，定义了不同索引下，中间内容区展示的内容。</p>\n<ul>\n<li>首页Tab 对应 HomeView</li>\n<li>项目Tab 对应 ProjectView</li>\n<li>公众号Tab 对应 AccountView</li>\n<li>我的Tab 对应 Mine</li>\n</ul>\n<h3 id=\"10-首页Tab-HomeView\"><a href=\"#10-首页Tab-HomeView\" class=\"headerlink\" title=\"10.首页Tab-HomeView\"></a>10.首页Tab-HomeView</h3><p>首页效果图就是上面的那个效果。<br>这里再拆分下，就是轮播图+列表。<br>对应 HomeView。</p>\n<pre><code class=\"line-numbers language-Kotlin\">@CompoKotlinsable\nfun HomeView(modifier: Modifier = Modifier) &#123;\n    val viewModel: HomeViewModel = viewModel()\n    ColumnTopBarMain(modifier\n        .background(HhfTheme.colors.background),\n        stringResource(R.string.app_name)) &#123;\n        // 内容区域，传入HomeViewModel对象\n        HomeContent(viewModel = viewModel)\n    &#125;\n&#125;\n</code></pre>\n<p>最外层是由顶部bar+内容区构成。</p>\n<p>ColumnTabBarMain是自定义通用的一个App的组件，用于上面展示toolbar，中间区域自定义。</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun ColumnTopBarMain(\n    modifier: Modifier = Modifier,\n    title: String,\n    content: @Composable ColumnScope.() -&gt; Unit\n) &#123;\n    Column(\n        modifier.navigationBarsPadding(),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) &#123;\n        CpTopBar(\n            Modifier.fillMaxWidth(),\n            HhfTheme.colors.themeColor,\n            title = title,\n            actions = &#123;\n                IconButton(onClick = &#123;\n                    CpNavigation.to(ModelPath.Search)\n                &#125;) &#123;\n                    Icon(Icons.Filled.Search, contentDescription = &quot;search&quot;, tint = Color.White)\n                &#125;\n            &#125;,\n        )\n        content.invoke(this)\n    &#125;\n&#125;\n</code></pre>\n<p>这里具体是一个Column+CpTopBar构成</p>\n<p>CpTopBar是这样的：</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n@Composable\nfun CpTopBar(\n    modifier: Modifier = Modifier,\n    backgroundColor: Color = Color.Transparent,\n    title: String,\n    actions: @Composable RowScope.() -&gt; Unit = &#123;&#125;,\n    back: (() -&gt; Unit)? = null\n) &#123;\n    HhTopAppBar(\n        &#123;\n            Text(title, color = Color.White)\n        &#125;,\n        modifier = modifier,\n        backgroundColor = backgroundColor,\n        contentPadding = WindowInsets.statusBars.only(WindowInsetsSides.Horizontal + WindowInsetsSides.Top).asPaddingValues(),\n        navigationIcon = back?.run &#123;\n            &#123;\n                IconButton(\n                    onClick = &#123;\n                        invoke()\n                    &#125;\n                ) &#123;\n                    Icon(Icons.Filled.ArrowBack, contentDescription = &quot;back&quot;, tint = Color.White)\n                &#125;\n            &#125;\n        &#125;,\n        actions = actions,\n        elevation = 2.dp,\n    )\n&#125;\n</code></pre>\n<p>里面还有自定义的HhTopAppBar</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n@Composable\nfun HhTopAppBar(\n    title: @Composable () -&gt; Unit,\n    modifier: Modifier = Modifier,\n    contentPadding: PaddingValues = PaddingValues(0.dp),\n    navigationIcon: @Composable (() -&gt; Unit)? = null,\n    actions: @Composable RowScope.() -&gt; Unit = &#123;&#125;,\n    backgroundColor: Color = MaterialTheme.colors.primarySurface,\n    contentColor: Color = contentColorFor(backgroundColor),\n    elevation: Dp = AppBarDefaults.TopAppBarElevation,\n) &#123;\n    TopAppBarSurface(\n        modifier = modifier,\n        backgroundColor = backgroundColor,\n        contentColor = contentColor,\n        elevation = elevation\n    ) &#123;\n        TopAppBarContent(\n            title = title,\n            navigationIcon = navigationIcon,\n            actions = actions,\n            modifier = Modifier.padding(contentPadding)\n        )\n    &#125;\n&#125;\n</code></pre>\n<p>竟然还有自定义层：Surface是官方提供的了</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun TopAppBarSurface(\n    modifier: Modifier = Modifier,\n    backgroundColor: Color = MaterialTheme.colors.primarySurface,\n    contentColor: Color = contentColorFor(backgroundColor),\n    elevation: Dp = AppBarDefaults.TopAppBarElevation,\n    content: @Composable () -&gt; Unit,\n) &#123;\n    Surface(\n        color = backgroundColor,\n        contentColor = contentColor,\n        elevation = elevation,\n        modifier = modifier,\n        content = content\n    )\n&#125;\n</code></pre>\n<p>还有标题栏内容区： 这个TopAppBar是官方提供的了</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun TopAppBarContent(\n    title: @Composable () -&gt; Unit,\n    modifier: Modifier = Modifier,\n    navigationIcon: @Composable (() -&gt; Unit)? = null,\n    actions: @Composable RowScope.() -&gt; Unit = &#123;&#125;,\n) &#123;\n    TopAppBar(\n        title = title,\n        navigationIcon = navigationIcon,\n        actions = actions,\n        backgroundColor = Color.Transparent,\n        elevation = 0.dp,\n        modifier = modifier\n    )\n&#125;\n</code></pre>\n<p>标题栏看完了，那就到内容区了。</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n/**\n * 首页内容区\n */\n@Composable\nfun HomeContent(modifier: Modifier = Modifier, viewModel: HomeViewModel) &#123;\n\n    /**\n     * list 为首页文章 列表数据；系统会对所有列表项进行组合和布局，无论它们是否可见，\n     * 因此如果您需要显示大量列表项（或长度未知的列表），则使用 Column 等布局可能会导致性能问题。\n     * Compose 提供了一组组件，这些组件只会对在组件视口中可见的列表项进行组合和布局。\n     */\n    val list = viewModel.viewStates.homeList.collectAsLazyPagingItems()\n\n    /**\n     * 下拉刷新组件\n     */\n    SwipeRefresh(\n        /**\n         * 状态，是否正在刷新\n         */\n        state = rememberSwipeRefreshState(viewModel.viewStates.isRefresh),\n        /**\n         * 下拉刷新回调，需要更新轮播+列表\n         */\n        onRefresh = &#123;\n            viewModel.dispatch(HomeAction.GetBanner)\n            list.refresh()\n        &#125;) &#123;\n        // 内容区 使用LazyItem包裹\n        PagingItem(modifier, list = list,\n            errorBlock = &#123;&#125;,\n            successBlock = &#123;&#125;,\n            errorAndSuccessClick = &#123;\n                /**\n                 * 错误后点击回调\n                 */\n                list.refresh()\n            &#125;) &#123;\n            /**\n             * 仅组成和放置 当前可见项 的竖直滚动列表。它允许您放置不同类型的子级内容。\n             * 例如，您可以使用LazyListScope.item添加单个项目，然后使用LazyListScope.items或者LazyListScope.itemsIndexed添加项目列表，后者有当前列表项的索引值。\n             */\n            LazyColumn&#123;\n                /**\n                 * 单个item\n                 */\n                item &#123;\n                    BannerPager(Modifier.height(160.dp), viewModel = viewModel)\n                &#125;\n                /**\n                 * items集合\n                 */\n                items(it) &#123; homeBean -&gt;\n                    homeBean?.apply &#123;\n                        /**\n                         * 首页文字item\n                         */\n                        HomeListItem(homeBean = this) &#123;\n                            /**\n                             * 处理点击收藏图标 触发viewModel层调用接口\n                             */\n                            if(CacheUtils.isLogin)&#123;\n                                viewModel.dispatch(HomeAction.Collect(homeBean.id, it))\n                            &#125;\n                            else&#123;\n                                CpNavigation.to(ModelPath.Login)\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>list 是专门用于懒加载列表，这个是存放可视区的列表。</p>\n<p>数据来源是ViewModel层的viewStates实例。</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * 首页状态，包装首页需要的数据\n */\ndata class HomeState(\n    /**\n     * 是否正在刷新\n     */\n    val isRefresh : Boolean = false,\n\n    /**\n     * 轮播列表，数据源\n     */\n    val bannerList: List&lt;BannerResponse&gt; = listOf(),\n\n    /**\n     * 首页数据\n     */\n    val homeList: Flow&lt;PagingData&lt;ArticleBean&gt;&gt; = Pager(\n        PagingConfig(PAGE_SIZE),\n        pagingSourceFactory = &#123; HomeSource() &#125;).flow,\n)\n</code></pre>\n<p>这个是存放到ViewModel层的首页动态数据。</p>\n<pre><code class=\"line-numbers language-Kotlin\"> // 首页数据监听 通过 mutableStateOf包装 HomeState\n    var viewStates by mutableStateOf(\n        HomeState(\n            homeList = Pager(\n                PagingConfig(PAGE_SIZE),\n                pagingSourceFactory = &#123; HomeSource() &#125;).flow.cachedIn(viewModelScope)))\n        private set\n</code></pre>\n<p>这里用一个mutableStateof包装下。</p>\n<p>下面继续回到首页内容区：<br>然后是一个SwipeRefresh组件,官方提供的。</p>\n<pre><code class=\"line-numbers language-Kotlin\">    SwipeRefresh(\n        /**\n         * 状态，是否正在刷新\n         */\n        state = rememberSwipeRefreshState(viewModel.viewStates.isRefresh),\n        /**\n         * 下拉刷新回调，需要更新轮播+列表\n         */\n        onRefresh = &#123;\n            viewModel.dispatch(HomeAction.GetBanner)\n            list.refresh()\n        &#125;) &#123;\n</code></pre>\n<p>定义好下拉刷新触发事件。<br>注意这个list，实际上走的是LazyPagingItems里面的一个refresh方法。<br>我们在HomeState中定义的homeList是一个Flow包装列表集合。通过调用Flow中扩展的一个collectAsLazyPagingItems函数，就变成LazyPagingItems对象了。</p>\n<p>这个list我们放在PagingItem里面。</p>\n<p>然后首页内容区里面用了一个 LazyColumn，应该也是配合懒加载和复用官方实现的一个类。<br>然后里面第一个item就是我们的轮播图了。</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * 顶部轮播图\n */\n@OptIn(ExperimentalPagerApi::class)\n@Composable\nfun BannerPager(modifier: Modifier = Modifier, viewModel: HomeViewModel) &#123;\n    val pagerState = rememberPagerState()\n\n    /**\n     * 开启协程 内部的闭包是协程 目的是获取轮播图数据\n     */\n    LaunchedEffect(viewModel)&#123;\n        viewModel.dispatch(HomeAction.GetBanner)\n    &#125;\n\n    /**\n     * 如需了解来自父项的约束条件并相应地设计布局，您可以使用 BoxWithConstraints。\n     * 就是外部传过来的modifier 决定子View 空间\n     */\n    BoxWithConstraints(modifier) &#123;\n\n        /**\n         * 水平分页\n         */\n        HorizontalPager(\n            count = viewModel.viewStates.bannerList.size, // 轮播总数\n            state = pagerState // 轮播状态\n        ) &#123; page -&gt;\n            //  页面索引\n            when (page) &#123;\n                viewModel.viewStates.bannerList[page].id -&gt; &#123;\n                    /**\n                     * 轮播图item\n                     */\n                    BannerItem(\n                        Modifier\n                            .height(maxHeight)\n                            .fillMaxWidth(), viewModel.viewStates.bannerList[page]\n                    )\n                &#125;\n            &#125;\n        &#125;\n\n        /**\n         * 轮播指示器\n         */\n        if (viewModel.viewStates.bannerList.isNotEmpty()) &#123;\n            BannerIndicator(\n                Modifier\n                    .align(Alignment.BottomCenter)\n                    .fillMaxWidth()\n                    .background(Color.Black.copy(0.2f))\n                    .padding(8.dp),viewModel, pagerState )\n        &#125;\n\n\n    &#125;\n&#125;\n</code></pre>\n<p>这个轮播图里面开了个协程去获取轮播图数据，只会走一次。<br>然后一个水平分页里面存放所有轮播图，轮播item为BannerItem,这个是自定义的</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun BannerItem(modifier: Modifier = Modifier, data: BannerResponse) &#123;\n    data.apply &#123;\n        Box(modifier.clickable &#123;\n            /**\n             * 点击图片，触发跳转WebView，通过bundle传递数据\n             */\n            CpNavigation.toBundle(ModelPath.WebView, Bundle().apply &#123;\n                putString(webTitle, data.title)\n                putString(webUrl, data.url)\n                putBoolean(webIsCollect, false)\n                putInt(webCollectId, data.id)\n                putInt(webCollectType, 1)\n            &#125;)\n        &#125;) &#123;\n            /**\n             * 自定义网络图片\n             */\n            NetworkImage(\n                imagePath,\n                Modifier.fillMaxWidth(),\n                contentScale = ContentScale.FillBounds,\n                defaultImg = R.mipmap.ic_default_round\n            )\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>轮播完了，就是文章item了。<br>主要是为了实现这种效果<br><img src=\"/./%E7%8E%A9Android-Compose%E7%89%88%E6%9C%AC-%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90/home_item.jpeg\"></p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n   * items集合\n   */\nitems(it) &#123; homeBean -&gt;\n    homeBean?.apply &#123;\n        /**\n        * 首页文字item\n        */\n        HomeListItem(homeBean = this) &#123;\n            /**\n            * 处理点击收藏图标 触发viewModel层调用接口\n            */\n            if(CacheUtils.isLogin)&#123;\n                viewModel.dispatch(HomeAction.Collect(homeBean.id, it))\n            &#125;\n            else&#123;\n                CpNavigation.to(ModelPath.Login)\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里用了items，然后遍历了 list,每个item对应一个 HomeListItem<br>这里定义了一个函数，说明了点击收藏图标后的逻辑。</p>\n<pre><code class=\"line-numbers language-Kotlin\">  /**\n     * 是否收藏了，用remember包装一下bool值\n     */\n    var isCollect by remember&#123; mutableStateOf(homeBean.collect)&#125;\n\n    /**\n     * 卡片布局\n     */\n    Card(\n        modifier\n            .padding(8.dp) // 内padding 8个dp\n            .clickable &#123;\n                /**\n                 * 卡片点击事件，触发跳转webView\n                 */\n                CpNavigation.toBundle(ModelPath.WebView, Bundle().apply &#123;\n                    putString(webTitle, homeBean.title)\n                    putString(webUrl, homeBean.link)\n                    putBoolean(webIsCollect, isCollect)\n                    putInt(webCollectId, homeBean.id)\n                    putInt(webCollectType, 0)\n                &#125;)\n            &#125;,\n        backgroundColor = HhfTheme.colors.listItem,\n        elevation = 5.dp\n    ) &#123;\n</code></pre>\n<p>这里外层是用了Card,定义了点击item的逻辑。</p>\n<p>里面是这样的：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> Column(Modifier.padding(8.dp)) &#123;\n                /**\n                 * 第一行 水平布局\n                 */\n                Row(verticalAlignment = Alignment.CenterVertically) &#123;\n                    /**\n                     * 分享者没名字\n                     */\n                    Text(\n                        text = if (author.isNotEmpty()) author else shareUser,\n                        fontSize = 13.sp,\n                        color = HhfTheme.colors.textColor\n                    )\n                    /**\n                     * 显示标签\n                     */\n                    if(isShowLabel)&#123;\n                        if (type == 1) &#123;\n                            Box(\n                                Modifier\n                                    .padding(start = 6.dp)\n                                    .border(1.dp, Color.Red, RoundedCornerShape(5.dp))\n                                    .padding(4.dp)\n                            ) &#123;\n                                Text(stringResource(id = R.string.istop), Modifier, Color.Red, 10.sp)\n                            &#125;\n                        &#125;\n                        if (fresh) &#123;\n                            Box(\n                                Modifier\n                                    .padding(start = 6.dp)\n                                    .border(1.dp, Color.Red, RoundedCornerShape(5.dp))\n                                    .padding(4.dp)\n                            ) &#123;\n                                Text(stringResource(id = R.string.neww), Modifier, Color.Red, 10.sp)\n                            &#125;\n                        &#125;\n                        if (tags.isNotEmpty()) &#123;\n                            Box(\n                                Modifier\n                                    .padding(start = 6.dp)\n                                    .border(1.dp, Color(0xFF66BB6A), RoundedCornerShape(5.dp))\n                                    .padding(4.dp)\n                            ) &#123;\n                                Text(tags[0].name, Modifier, Color(0xFF66BB6A), 10.sp)\n                            &#125;\n                        &#125;\n                    &#125;\n                    /**\n                     * 发布日期\n                     */\n                    Text(\n                        niceDate,\n                        Modifier\n                            .weight(1f)\n                            .wrapContentWidth(\n                                Alignment.End\n                            )\n                            .align(Alignment.CenterVertically),\n                        HhfTheme.colors.textColor.copy(0.6f),\n                        fontSize = 13.sp,\n                    )\n                &#125;\n                /**\n                 * 有没有封面图\n                 */\n                if (TextUtils.isEmpty(envelopePic)) &#123;\n                    // 没有封面图\n                    Text(\n                        title.filterHtml(),\n                        Modifier.padding(top = 12.dp),\n                        HhfTheme.colors.textColor,\n                        fontSize = 14.sp,\n                        fontWeight = FontWeight.Bold\n                    )\n                &#125; else &#123;\n                    // 有封面图时，中间区域展示\n                    Row(Modifier.padding(top = 12.dp)) &#123;\n                        // 网络图片\n                        NetworkImage(\n                            envelopePic,\n                            Modifier.size(100.dp),\n                            contentScale = ContentScale.Crop,\n                            defaultImg = R.mipmap.ic_default_round\n                        )\n                        // 垂直布局\n                        Column(Modifier.padding(start = 8.dp)) &#123;\n                            // 标题\n                            Text(\n                                title.filterHtml(),\n                                color = HhfTheme.colors.textColor,\n                                fontSize = 14.sp,\n                                maxLines = 3,\n                                style = TextStyle(fontWeight = FontWeight.Bold)\n                            )\n                            // 摘要描述\n                            Text(\n                                desc,\n                                color = HhfTheme.colors.textInactiveColor,\n                                fontSize = 13.sp,\n                                maxLines = 3,\n                                overflow = TextOverflow.Ellipsis\n                            )\n                        &#125;\n                    &#125;\n                &#125;\n                // 底部水平布局\n                Row &#123;\n                    // 文本\n                    Text(\n                        &quot;$superChapterName / $chapterName&quot;,\n                        Modifier.padding(top = 12.dp),\n                        HhfTheme.colors.textColor,\n                        fontSize = 13.sp\n                    )\n                    // 图标，是否收藏了\n                    Icon(\n                        if(isCollect) Icons.Filled.Favorite else Icons.Filled.FavoriteBorder, contentDescription = &quot;&quot;,\n                        Modifier\n                            .wrapContentWidth(\n                                Alignment.End\n                            )\n                            .weight(1f)\n                            .clickable &#123;\n                                /**\n                                 * 点击收藏，触发请求\n                                 */\n                                favoriteAction(isCollect)\n                                isCollect = !isCollect\n                            &#125;,\n                        tint = HhfTheme.colors.themeColor\n                    )\n                &#125;\n            &#125;\n</code></pre>\n<h3 id=\"11-我的Tab-Mine\"><a href=\"#11-我的Tab-Mine\" class=\"headerlink\" title=\"11.我的Tab-Mine\"></a>11.我的Tab-Mine</h3><p>因为项目和公众号和首页基本一样，这里就不重复分析了。<br>看下我的页面的效果图：<br><img src=mine.jpeg width=50%><br>要实现这样的效果，怎么处理呢？</p>\n<p>首先开启一个协程，获取用户sp数据，转成UserInfo对象</p>\n<pre><code class=\"line-numbers language-Kotlin\">   /**\n     * 开启协程，只走一次\n     */\n    LaunchedEffect(CacheUtils.userInfo) &#123;\n        if (CacheUtils.userInfo != &quot;&quot;) &#123;\n            /**\n             * 根据sp文件，生产一个UserInfo对象，设置给这个我的页面使用\n             */\n            mineViewModel.dispatch(\n                MineViewEvent.SetUserInfo(\n                    Gson().fromJson(\n                        CacheUtils.userInfo, // sp文件\n                        UserInfo::class.java\n                    )\n                )\n            )\n            /**\n             * 获取积分和排名\n             */\n            mineViewModel.dispatch(MineViewEvent.GetIntegral)\n        &#125;\n    &#125;\n</code></pre>\n<p>这里获取积分和排名是需要走接口的<br>这里会走到ViewModel层这个函数：</p>\n<pre><code class=\"line-numbers language-Kotlin\">    private fun getIntegral() &#123;\n        viewModelScope.launch &#123;\n            flow &#123;\n                emit(\n                    TaskApi.create(ApiService::class.java).getIntegral()\n                )\n            &#125;.map &#123;\n                if (it.errorCode == 0) &#123;\n                    it.data\n                        ?: throw Exception(&quot;data null&quot;)\n                &#125; else &#123;\n                    throw Exception(it.errorMsg)\n                &#125;\n            &#125;.onEach &#123;\n                viewStates = viewStates.copy(integral = it)\n            &#125;.catch &#123;\n                viewStates = viewStates.copy(integral = null)\n            &#125;.collect()\n        &#125;\n    &#125;\n</code></pre>\n<p>这个retrofit中是这样定义的：</p>\n<pre><code class=\"line-numbers language-Kotlin\">interface ApiService &#123;\n    /**\n     * 获取当前账户的个人积分\n     */\n    @GET(&quot;lg/coin/userinfo/json&quot;)\n    suspend fun getIntegral(): ApiResponse&lt;Integral&gt;\n</code></pre>\n<p>这个就是一个suspend挂起函数。</p>\n<p>顶层为Column:</p>\n<pre><code class=\"line-numbers language-Kotlin\">    /**\n     * 顶层为列表视图\n     */\n    Column(modifier) &#123;\n        /**\n         * 顶部👤\n         */\n        MineTopAvatar(\n            Modifier\n                .fillMaxWidth()\n                .height(320.dp)\n                .clip(QureytoImageShapes(160f)),\n            mineViewModel.viewStates.userInfo?.run &#123;\n                nickname\n            &#125; ?: &quot;avatar&quot;\n        ) &#123;\n</code></pre>\n<p>头像区域，点击后可以弹pop，但是需要先获取权限，这样获取：</p>\n<pre><code class=\"line-numbers language-Kotlin\">// 图片点击事件 会去申请下权限\n            XXPermissions\n                .with(context)\n                .permission(Permission.CAMERA)\n                .permission(Permission.MANAGE_EXTERNAL_STORAGE)\n                .request(object : OnPermissionCallback &#123;\n                    override fun onGranted(\n                        granted: List&lt;String&gt;,\n                        all: Boolean\n                    ) &#123;\n                        if (all) &#123;\n                            if(isLogin)&#123;\n                                mineViewModel.dispatch(MineViewEvent.ChangePopupState(true))\n                            &#125;\n                            else&#123;\n                                CpNavigation.to(ModelPath.Login)\n                            &#125;\n                        &#125;\n                    &#125;\n\n                    override fun onDenied(\n                        denied: List&lt;String&gt;,\n                        never: Boolean\n                    ) &#123;\n                        if (never) &#123;\n                            context.showToast(context.stringResource(R.string.permissions_cm_error))\n                            XXPermissions.startPermissionActivity(\n                                context,\n                                denied\n                            )\n                        &#125; else &#123;\n                            context.showToast(context.stringResource(R.string.permissions_camera_error))\n                        &#125;\n                    &#125;\n                &#125;)\n</code></pre>\n<p>用了一个三方库实现。</p>\n<p>中间操作栏这样实现：</p>\n<pre><code class=\"line-numbers language-Kotlin\">  // 操作栏 有个外边框，包裹菜单项，底部有阴影\n        Surface(\n            Modifier\n                .padding(start = 20.dp, end = 20.dp)\n                .fillMaxWidth()\n                .background(HhfTheme.colors.background),\n            elevation = 2.dp,\n            shape = RoundedCornerShape(8.dp),\n            color = MaterialTheme.colors.surface, // color will be adjusted for elevation\n        ) &#123;\n</code></pre>\n<p>具体的菜单项也是用懒加载实现：</p>\n<pre><code class=\"line-numbers language-Kotlin\">LazyColumn(Modifier.background(HhfTheme.colors.listItem)) &#123;\n                itemsIndexed(list) &#123; i, bean -&gt;\n\n                    /**\n                     * 我的页面遍历菜单项\n                     */\n                    MineItem(\n                        Modifier\n                            .fillMaxWidth()\n                            .clickable &#123;\n                                /**\n                                 * 分发开发者行为\n                                 */\n                                mineViewModel.dispatch(MineViewEvent.ToComposable(bean.id))\n                            &#125;\n                            .height(45.dp), bean.name, HhfTheme.colors.themeColor,\n                        bean.icon)\n                    if (i &lt; list.size - 1) &#123;\n                        /**\n                         * 非最后一行显示分割线\n                         */\n                        Divider(\n                            modifier = Modifier\n                                .fillMaxWidth()\n                                .padding(start = 10.dp, end = 10.dp)\n                        )\n                    &#125;\n                &#125;\n            &#125;\n</code></pre>\n<p>具体的菜单item,有图标+文字+右侧箭头实现：</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n@Composable\nfun MineItem(\n    modifier: Modifier = Modifier, textName: String, iconColor: Color, icon: ImageVector\n) &#123;\n    Row(\n        modifier,\n        verticalAlignment = Alignment.CenterVertically,\n    ) &#123;\n        Icon(\n            icon, &quot;$textName icon&quot;,\n            Modifier\n                .size(28.dp)\n                .padding(start = 10.dp), iconColor\n        )\n        Text(\n            textName,\n            Modifier.padding(start = 10.dp),\n            fontSize = 14.sp,\n            fontFamily = FontFamily.Serif,\n            color = HhfTheme.colors.textColor\n        )\n        Icon(\n            Icons.Filled.KeyboardArrowRight, textName,\n            Modifier\n                .weight(1f)\n                .padding(end = 10.dp)\n                .wrapContentWidth(Alignment.End),\n            tint = HhfTheme.colors.textColor\n        )\n    &#125;\n&#125;\n</code></pre>\n<p>UI搞定了，跳转逻辑怎么处理呢？<br>答案是viewModel层实现。</p>\n<p>这里有个clickable点击闭包：<br><code> mineViewModel.dispatch(MineViewEvent.ToComposable(bean.id))</code></p>\n<p>会委托给mineViewModel处理：</p>\n<pre><code class=\"line-numbers language-Kotlin\">    /**\n     * 分发开发者行为\n     */\n    fun dispatch(action: MineViewEvent) &#123;\n        when (action) &#123;\n            is MineViewEvent.Blur -&gt; bitmapBlur(action.s)\n            /**\n             * 用户点击菜单项\n             */\n            is MineViewEvent.ToComposable -&gt; toComposable(action.type)\n            is MineViewEvent.ChangePopupState -&gt; &#123;\n                Log.e(&quot;TEST##&quot;, &quot;这里触发了viewStates中 isShowpopup 变更为：$&#123;action.flag&#125;&quot;)\n                viewStates = viewStates.copy(isShowPopup = action.flag)\n            &#125;\n            is MineViewEvent.SetUserInfo -&gt; viewStates = viewStates.copy(userInfo = action.userInfo)\n            is MineViewEvent.GetIntegral -&gt; getIntegral()\n        &#125;\n    &#125;\n</code></pre>\n<p>这里分发开发者行为，其实更像用户行为，有可能不是用户触发，所以我这里称之为开发者行为。</p>\n<p>点击菜单项继续分发：</p>\n<pre><code class=\"line-numbers language-Kotlin\">private fun toComposable(type: Int) &#123;\n        if(isLogin)&#123;\n            when (type) &#123;\n                0 -&gt; CpNavigation.to(ModelPath.Integral)\n                1 -&gt; CpNavigation.to(ModelPath.Collect)\n                2 -&gt; CpNavigation.to(ModelPath.Share)\n                3 -&gt; CpNavigation.to(ModelPath.Todo)\n                4 -&gt; CpNavigation.toBundle(ModelPath.WebView, Bundle().apply &#123;\n                    putString(webTitle, &quot;PlayAndroid&quot;)\n                    putString(webUrl, &quot;https://github.com/yellowhai/PlayAndroid&quot;)\n                    putBoolean(webIsCollect, false)\n                    putInt(webCollectId, 998)\n                    putInt(webCollectType, 1)\n                &#125;)\n                5 -&gt; CpNavigation.to(ModelPath.Setting)\n            &#125;\n        &#125;\n        else&#123;\n            when (type) &#123;\n                4 -&gt; CpNavigation.toBundle(ModelPath.WebView, Bundle().apply &#123;\n                    putString(webTitle, &quot;PlayAndroid&quot;)\n                    putString(webUrl, &quot;https://github.com/yellowhai/PlayAndroid&quot;)\n                    putBoolean(webIsCollect, false)\n                    putInt(webCollectId, 998)\n                    putInt(webCollectType, 1)\n                &#125;)\n                5 -&gt; CpNavigation.to(ModelPath.Setting)\n                else -&gt; CpNavigation.to(ModelPath.Login)\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>这里定义了跳转逻辑，这里有回到 第8点主页外部架构 中的导航定义了。<br>实现跳转到其它页面了，这更像是在布局上叠加，不算是跳转吧。</p>\n<p>这个项目还有很多细节值得一探究竟，不过对于初始compose，也差不多了，了解到这个程度也算入门了吧。</p>\n"},{"title":"iOS 学习导航","date":"2023-01-22T23:38:41.000Z","top":true,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 知识体系\n\n### 1.1 Swift相关\n> [https://github.com/CocoaChina-editors/Welcome-to-Swift](https://github.com/CocoaChina-editors/Welcome-to-Swift)\n\n### 1.2 SwiftUI自学站点\n> [https://www.openswiftui.com/](https://www.openswiftui.com/)\n\n## 2 优秀站点\n\n### 2.1 国外世界级iOS讨论\n> [https://www.objc.io/](https://www.objc.io/)\n\n### 2.2 Nshipster示例代码\n> [https://nshipster.com/](https://nshipster.com/)\n\n### 2.3 iOS周报\n> [https://iosdevweekly.com/](https://iosdevweekly.com/)\n\n### 2.4 Appcode\n> [https://www.appcoda.com/](https://www.appcoda.com/)\n\n### 2.5 简书\n> [https://www.jianshu.com/c/3233d1a249ca](https://www.jianshu.com/c/3233d1a249ca)\n\n### 2.6 掘金\n> [https://juejin.cn/ios](https://juejin.cn/ios)\n\n### 2.7 CSDN\n> [https://blog.csdn.net/nav/mobile/ios](https://blog.csdn.net/nav/mobile/ios)\n\n### 2.8 Bbsmax\n> [https://www.bbsmax.com/search/IOS/](https://www.bbsmax.com/search/IOS/)\n\n### 2.9 github 上swift每周趋势\n> [https://github.com/trending/swift?since=daily](https://github.com/trending/swift?since=weekly)\n\n### 2.10 github 上iOS话题\n> [https://github.com/topics/ios](https://github.com/topics/ios)\n\n\n\n## 3 公众号\n\n### 3.1 iOS开发\n<img src=iOSkaifa.jpeg>\n\n[https://open.weixin.qq.com/qr/code?username=DS3589](https://open.weixin.qq.com/qr/code?username=DS3589)\n\n### 3.2 移动端Android和iOS开发技术分享\n<img src=mobile_tech_share.jpeg>\n\n[https://open.weixin.qq.com/qr/code?username=mobile_tech_share](https://open.weixin.qq.com/qr/code?username=mobile_tech_share)\n\n\n## 4 大神博客\n\n### 4.1 学良大哥\n> [https://ficowshen.com/](https://ficowshen.com/)\n\n\n## 5 优秀三方库\n\n### 5.1 常用三方库，插件，知名博客\n> [https://github.com/Tim9Liu9/TimLiu-iOS](https://github.com/Tim9Liu9/TimLiu-iOS)\n\n### 5.2 awesome-ios\n> 记录了很多关于iOS的三方库 [https://github.com/vsouza/awesome-ios](https://github.com/vsouza/awesome-ios)\n\n### 5.3 AFnetworking\n> [https://github.com/AFNetworking/AFNetworking](https://github.com/AFNetworking/AFNetworking)\n\n### 5.4 RxSwift\n> 参考博客《麻烦给我的爱人来一杯RxSwift》 [https://juejin.cn/post/6844904191161286670](https://juejin.cn/post/6844904191161286670)\n\n\n\n## 6 项目推荐\n\n### 6.1 NextCloud\n> [https://github.com/nextcloud/ios](https://github.com/nextcloud/ios)\n\n### 6.2 github 开源项目\n> [https://github.com/panbin/panbin-ios/blob/master/Swift.md](https://github.com/panbin/panbin-ios/blob/master/Swift.md)\n\n## 7 其它\n\n### 7.1 面试相关\n\n### 7.2 开发工具相关\n\n","source":"_posts/iOS-学习导航.md","raw":"---\ntitle: iOS 学习导航\ndate: 2023-01-23 07:38:41\ntop: true\ncover: false\ntoc: true\nmathjax: true\ntags:\n- iOS\ncategories:\n- iOS\n---\n\n## 1 知识体系\n\n### 1.1 Swift相关\n> [https://github.com/CocoaChina-editors/Welcome-to-Swift](https://github.com/CocoaChina-editors/Welcome-to-Swift)\n\n### 1.2 SwiftUI自学站点\n> [https://www.openswiftui.com/](https://www.openswiftui.com/)\n\n## 2 优秀站点\n\n### 2.1 国外世界级iOS讨论\n> [https://www.objc.io/](https://www.objc.io/)\n\n### 2.2 Nshipster示例代码\n> [https://nshipster.com/](https://nshipster.com/)\n\n### 2.3 iOS周报\n> [https://iosdevweekly.com/](https://iosdevweekly.com/)\n\n### 2.4 Appcode\n> [https://www.appcoda.com/](https://www.appcoda.com/)\n\n### 2.5 简书\n> [https://www.jianshu.com/c/3233d1a249ca](https://www.jianshu.com/c/3233d1a249ca)\n\n### 2.6 掘金\n> [https://juejin.cn/ios](https://juejin.cn/ios)\n\n### 2.7 CSDN\n> [https://blog.csdn.net/nav/mobile/ios](https://blog.csdn.net/nav/mobile/ios)\n\n### 2.8 Bbsmax\n> [https://www.bbsmax.com/search/IOS/](https://www.bbsmax.com/search/IOS/)\n\n### 2.9 github 上swift每周趋势\n> [https://github.com/trending/swift?since=daily](https://github.com/trending/swift?since=weekly)\n\n### 2.10 github 上iOS话题\n> [https://github.com/topics/ios](https://github.com/topics/ios)\n\n\n\n## 3 公众号\n\n### 3.1 iOS开发\n<img src=iOSkaifa.jpeg>\n\n[https://open.weixin.qq.com/qr/code?username=DS3589](https://open.weixin.qq.com/qr/code?username=DS3589)\n\n### 3.2 移动端Android和iOS开发技术分享\n<img src=mobile_tech_share.jpeg>\n\n[https://open.weixin.qq.com/qr/code?username=mobile_tech_share](https://open.weixin.qq.com/qr/code?username=mobile_tech_share)\n\n\n## 4 大神博客\n\n### 4.1 学良大哥\n> [https://ficowshen.com/](https://ficowshen.com/)\n\n\n## 5 优秀三方库\n\n### 5.1 常用三方库，插件，知名博客\n> [https://github.com/Tim9Liu9/TimLiu-iOS](https://github.com/Tim9Liu9/TimLiu-iOS)\n\n### 5.2 awesome-ios\n> 记录了很多关于iOS的三方库 [https://github.com/vsouza/awesome-ios](https://github.com/vsouza/awesome-ios)\n\n### 5.3 AFnetworking\n> [https://github.com/AFNetworking/AFNetworking](https://github.com/AFNetworking/AFNetworking)\n\n### 5.4 RxSwift\n> 参考博客《麻烦给我的爱人来一杯RxSwift》 [https://juejin.cn/post/6844904191161286670](https://juejin.cn/post/6844904191161286670)\n\n\n\n## 6 项目推荐\n\n### 6.1 NextCloud\n> [https://github.com/nextcloud/ios](https://github.com/nextcloud/ios)\n\n### 6.2 github 开源项目\n> [https://github.com/panbin/panbin-ios/blob/master/Swift.md](https://github.com/panbin/panbin-ios/blob/master/Swift.md)\n\n## 7 其它\n\n### 7.1 面试相关\n\n### 7.2 开发工具相关\n\n","slug":"iOS-学习导航","published":1,"updated":"2023-02-01T06:27:29.750Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlc01ji0019jhv77umsb56i","content":"<h2 id=\"1-知识体系\"><a href=\"#1-知识体系\" class=\"headerlink\" title=\"1 知识体系\"></a>1 知识体系</h2><h3 id=\"1-1-Swift相关\"><a href=\"#1-1-Swift相关\" class=\"headerlink\" title=\"1.1 Swift相关\"></a>1.1 Swift相关</h3><blockquote>\n<p><a href=\"https://github.com/CocoaChina-editors/Welcome-to-Swift\">https://github.com/CocoaChina-editors/Welcome-to-Swift</a></p>\n</blockquote>\n<h3 id=\"1-2-SwiftUI自学站点\"><a href=\"#1-2-SwiftUI自学站点\" class=\"headerlink\" title=\"1.2 SwiftUI自学站点\"></a>1.2 SwiftUI自学站点</h3><blockquote>\n<p><a href=\"https://www.openswiftui.com/\">https://www.openswiftui.com/</a></p>\n</blockquote>\n<h2 id=\"2-优秀站点\"><a href=\"#2-优秀站点\" class=\"headerlink\" title=\"2 优秀站点\"></a>2 优秀站点</h2><h3 id=\"2-1-国外世界级iOS讨论\"><a href=\"#2-1-国外世界级iOS讨论\" class=\"headerlink\" title=\"2.1 国外世界级iOS讨论\"></a>2.1 国外世界级iOS讨论</h3><blockquote>\n<p><a href=\"https://www.objc.io/\">https://www.objc.io/</a></p>\n</blockquote>\n<h3 id=\"2-2-Nshipster示例代码\"><a href=\"#2-2-Nshipster示例代码\" class=\"headerlink\" title=\"2.2 Nshipster示例代码\"></a>2.2 Nshipster示例代码</h3><blockquote>\n<p><a href=\"https://nshipster.com/\">https://nshipster.com/</a></p>\n</blockquote>\n<h3 id=\"2-3-iOS周报\"><a href=\"#2-3-iOS周报\" class=\"headerlink\" title=\"2.3 iOS周报\"></a>2.3 iOS周报</h3><blockquote>\n<p><a href=\"https://iosdevweekly.com/\">https://iosdevweekly.com/</a></p>\n</blockquote>\n<h3 id=\"2-4-Appcode\"><a href=\"#2-4-Appcode\" class=\"headerlink\" title=\"2.4 Appcode\"></a>2.4 Appcode</h3><blockquote>\n<p><a href=\"https://www.appcoda.com/\">https://www.appcoda.com/</a></p>\n</blockquote>\n<h3 id=\"2-5-简书\"><a href=\"#2-5-简书\" class=\"headerlink\" title=\"2.5 简书\"></a>2.5 简书</h3><blockquote>\n<p><a href=\"https://www.jianshu.com/c/3233d1a249ca\">https://www.jianshu.com/c/3233d1a249ca</a></p>\n</blockquote>\n<h3 id=\"2-6-掘金\"><a href=\"#2-6-掘金\" class=\"headerlink\" title=\"2.6 掘金\"></a>2.6 掘金</h3><blockquote>\n<p><a href=\"https://juejin.cn/ios\">https://juejin.cn/ios</a></p>\n</blockquote>\n<h3 id=\"2-7-CSDN\"><a href=\"#2-7-CSDN\" class=\"headerlink\" title=\"2.7 CSDN\"></a>2.7 CSDN</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/nav/mobile/ios\">https://blog.csdn.net/nav/mobile/ios</a></p>\n</blockquote>\n<h3 id=\"2-8-Bbsmax\"><a href=\"#2-8-Bbsmax\" class=\"headerlink\" title=\"2.8 Bbsmax\"></a>2.8 Bbsmax</h3><blockquote>\n<p><a href=\"https://www.bbsmax.com/search/IOS/\">https://www.bbsmax.com/search/IOS/</a></p>\n</blockquote>\n<h3 id=\"2-9-github-上swift每周趋势\"><a href=\"#2-9-github-上swift每周趋势\" class=\"headerlink\" title=\"2.9 github 上swift每周趋势\"></a>2.9 github 上swift每周趋势</h3><blockquote>\n<p><a href=\"https://github.com/trending/swift?since=weekly\">https://github.com/trending/swift?since=daily</a></p>\n</blockquote>\n<h3 id=\"2-10-github-上iOS话题\"><a href=\"#2-10-github-上iOS话题\" class=\"headerlink\" title=\"2.10 github 上iOS话题\"></a>2.10 github 上iOS话题</h3><blockquote>\n<p><a href=\"https://github.com/topics/ios\">https://github.com/topics/ios</a></p>\n</blockquote>\n<h2 id=\"3-公众号\"><a href=\"#3-公众号\" class=\"headerlink\" title=\"3 公众号\"></a>3 公众号</h2><h3 id=\"3-1-iOS开发\"><a href=\"#3-1-iOS开发\" class=\"headerlink\" title=\"3.1 iOS开发\"></a>3.1 iOS开发</h3><img src=iOSkaifa.jpeg>\n\n<p><a href=\"https://open.weixin.qq.com/qr/code?username=DS3589\">https://open.weixin.qq.com/qr/code?username=DS3589</a></p>\n<h3 id=\"3-2-移动端Android和iOS开发技术分享\"><a href=\"#3-2-移动端Android和iOS开发技术分享\" class=\"headerlink\" title=\"3.2 移动端Android和iOS开发技术分享\"></a>3.2 移动端Android和iOS开发技术分享</h3><img src=mobile_tech_share.jpeg>\n\n<p><a href=\"https://open.weixin.qq.com/qr/code?username=mobile_tech_share\">https://open.weixin.qq.com/qr/code?username=mobile_tech_share</a></p>\n<h2 id=\"4-大神博客\"><a href=\"#4-大神博客\" class=\"headerlink\" title=\"4 大神博客\"></a>4 大神博客</h2><h3 id=\"4-1-学良大哥\"><a href=\"#4-1-学良大哥\" class=\"headerlink\" title=\"4.1 学良大哥\"></a>4.1 学良大哥</h3><blockquote>\n<p><a href=\"https://ficowshen.com/\">https://ficowshen.com/</a></p>\n</blockquote>\n<h2 id=\"5-优秀三方库\"><a href=\"#5-优秀三方库\" class=\"headerlink\" title=\"5 优秀三方库\"></a>5 优秀三方库</h2><h3 id=\"5-1-常用三方库，插件，知名博客\"><a href=\"#5-1-常用三方库，插件，知名博客\" class=\"headerlink\" title=\"5.1 常用三方库，插件，知名博客\"></a>5.1 常用三方库，插件，知名博客</h3><blockquote>\n<p><a href=\"https://github.com/Tim9Liu9/TimLiu-iOS\">https://github.com/Tim9Liu9/TimLiu-iOS</a></p>\n</blockquote>\n<h3 id=\"5-2-awesome-ios\"><a href=\"#5-2-awesome-ios\" class=\"headerlink\" title=\"5.2 awesome-ios\"></a>5.2 awesome-ios</h3><blockquote>\n<p>记录了很多关于iOS的三方库 <a href=\"https://github.com/vsouza/awesome-ios\">https://github.com/vsouza/awesome-ios</a></p>\n</blockquote>\n<h3 id=\"5-3-AFnetworking\"><a href=\"#5-3-AFnetworking\" class=\"headerlink\" title=\"5.3 AFnetworking\"></a>5.3 AFnetworking</h3><blockquote>\n<p><a href=\"https://github.com/AFNetworking/AFNetworking\">https://github.com/AFNetworking/AFNetworking</a></p>\n</blockquote>\n<h3 id=\"5-4-RxSwift\"><a href=\"#5-4-RxSwift\" class=\"headerlink\" title=\"5.4 RxSwift\"></a>5.4 RxSwift</h3><blockquote>\n<p>参考博客《麻烦给我的爱人来一杯RxSwift》 <a href=\"https://juejin.cn/post/6844904191161286670\">https://juejin.cn/post/6844904191161286670</a></p>\n</blockquote>\n<h2 id=\"6-项目推荐\"><a href=\"#6-项目推荐\" class=\"headerlink\" title=\"6 项目推荐\"></a>6 项目推荐</h2><h3 id=\"6-1-NextCloud\"><a href=\"#6-1-NextCloud\" class=\"headerlink\" title=\"6.1 NextCloud\"></a>6.1 NextCloud</h3><blockquote>\n<p><a href=\"https://github.com/nextcloud/ios\">https://github.com/nextcloud/ios</a></p>\n</blockquote>\n<h3 id=\"6-2-github-开源项目\"><a href=\"#6-2-github-开源项目\" class=\"headerlink\" title=\"6.2 github 开源项目\"></a>6.2 github 开源项目</h3><blockquote>\n<p><a href=\"https://github.com/panbin/panbin-ios/blob/master/Swift.md\">https://github.com/panbin/panbin-ios/blob/master/Swift.md</a></p>\n</blockquote>\n<h2 id=\"7-其它\"><a href=\"#7-其它\" class=\"headerlink\" title=\"7 其它\"></a>7 其它</h2><h3 id=\"7-1-面试相关\"><a href=\"#7-1-面试相关\" class=\"headerlink\" title=\"7.1 面试相关\"></a>7.1 面试相关</h3><h3 id=\"7-2-开发工具相关\"><a href=\"#7-2-开发工具相关\" class=\"headerlink\" title=\"7.2 开发工具相关\"></a>7.2 开发工具相关</h3>","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-知识体系\"><a href=\"#1-知识体系\" class=\"headerlink\" title=\"1 知识体系\"></a>1 知识体系</h2><h3 id=\"1-1-Swift相关\"><a href=\"#1-1-Swift相关\" class=\"headerlink\" title=\"1.1 Swift相关\"></a>1.1 Swift相关</h3><blockquote>\n<p><a href=\"https://github.com/CocoaChina-editors/Welcome-to-Swift\">https://github.com/CocoaChina-editors/Welcome-to-Swift</a></p>\n</blockquote>\n<h3 id=\"1-2-SwiftUI自学站点\"><a href=\"#1-2-SwiftUI自学站点\" class=\"headerlink\" title=\"1.2 SwiftUI自学站点\"></a>1.2 SwiftUI自学站点</h3><blockquote>\n<p><a href=\"https://www.openswiftui.com/\">https://www.openswiftui.com/</a></p>\n</blockquote>\n<h2 id=\"2-优秀站点\"><a href=\"#2-优秀站点\" class=\"headerlink\" title=\"2 优秀站点\"></a>2 优秀站点</h2><h3 id=\"2-1-国外世界级iOS讨论\"><a href=\"#2-1-国外世界级iOS讨论\" class=\"headerlink\" title=\"2.1 国外世界级iOS讨论\"></a>2.1 国外世界级iOS讨论</h3><blockquote>\n<p><a href=\"https://www.objc.io/\">https://www.objc.io/</a></p>\n</blockquote>\n<h3 id=\"2-2-Nshipster示例代码\"><a href=\"#2-2-Nshipster示例代码\" class=\"headerlink\" title=\"2.2 Nshipster示例代码\"></a>2.2 Nshipster示例代码</h3><blockquote>\n<p><a href=\"https://nshipster.com/\">https://nshipster.com/</a></p>\n</blockquote>\n<h3 id=\"2-3-iOS周报\"><a href=\"#2-3-iOS周报\" class=\"headerlink\" title=\"2.3 iOS周报\"></a>2.3 iOS周报</h3><blockquote>\n<p><a href=\"https://iosdevweekly.com/\">https://iosdevweekly.com/</a></p>\n</blockquote>\n<h3 id=\"2-4-Appcode\"><a href=\"#2-4-Appcode\" class=\"headerlink\" title=\"2.4 Appcode\"></a>2.4 Appcode</h3><blockquote>\n<p><a href=\"https://www.appcoda.com/\">https://www.appcoda.com/</a></p>\n</blockquote>\n<h3 id=\"2-5-简书\"><a href=\"#2-5-简书\" class=\"headerlink\" title=\"2.5 简书\"></a>2.5 简书</h3><blockquote>\n<p><a href=\"https://www.jianshu.com/c/3233d1a249ca\">https://www.jianshu.com/c/3233d1a249ca</a></p>\n</blockquote>\n<h3 id=\"2-6-掘金\"><a href=\"#2-6-掘金\" class=\"headerlink\" title=\"2.6 掘金\"></a>2.6 掘金</h3><blockquote>\n<p><a href=\"https://juejin.cn/ios\">https://juejin.cn/ios</a></p>\n</blockquote>\n<h3 id=\"2-7-CSDN\"><a href=\"#2-7-CSDN\" class=\"headerlink\" title=\"2.7 CSDN\"></a>2.7 CSDN</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/nav/mobile/ios\">https://blog.csdn.net/nav/mobile/ios</a></p>\n</blockquote>\n<h3 id=\"2-8-Bbsmax\"><a href=\"#2-8-Bbsmax\" class=\"headerlink\" title=\"2.8 Bbsmax\"></a>2.8 Bbsmax</h3><blockquote>\n<p><a href=\"https://www.bbsmax.com/search/IOS/\">https://www.bbsmax.com/search/IOS/</a></p>\n</blockquote>\n<h3 id=\"2-9-github-上swift每周趋势\"><a href=\"#2-9-github-上swift每周趋势\" class=\"headerlink\" title=\"2.9 github 上swift每周趋势\"></a>2.9 github 上swift每周趋势</h3><blockquote>\n<p><a href=\"https://github.com/trending/swift?since=weekly\">https://github.com/trending/swift?since=daily</a></p>\n</blockquote>\n<h3 id=\"2-10-github-上iOS话题\"><a href=\"#2-10-github-上iOS话题\" class=\"headerlink\" title=\"2.10 github 上iOS话题\"></a>2.10 github 上iOS话题</h3><blockquote>\n<p><a href=\"https://github.com/topics/ios\">https://github.com/topics/ios</a></p>\n</blockquote>\n<h2 id=\"3-公众号\"><a href=\"#3-公众号\" class=\"headerlink\" title=\"3 公众号\"></a>3 公众号</h2><h3 id=\"3-1-iOS开发\"><a href=\"#3-1-iOS开发\" class=\"headerlink\" title=\"3.1 iOS开发\"></a>3.1 iOS开发</h3><img src=iOSkaifa.jpeg>\n\n<p><a href=\"https://open.weixin.qq.com/qr/code?username=DS3589\">https://open.weixin.qq.com/qr/code?username=DS3589</a></p>\n<h3 id=\"3-2-移动端Android和iOS开发技术分享\"><a href=\"#3-2-移动端Android和iOS开发技术分享\" class=\"headerlink\" title=\"3.2 移动端Android和iOS开发技术分享\"></a>3.2 移动端Android和iOS开发技术分享</h3><img src=mobile_tech_share.jpeg>\n\n<p><a href=\"https://open.weixin.qq.com/qr/code?username=mobile_tech_share\">https://open.weixin.qq.com/qr/code?username=mobile_tech_share</a></p>\n<h2 id=\"4-大神博客\"><a href=\"#4-大神博客\" class=\"headerlink\" title=\"4 大神博客\"></a>4 大神博客</h2><h3 id=\"4-1-学良大哥\"><a href=\"#4-1-学良大哥\" class=\"headerlink\" title=\"4.1 学良大哥\"></a>4.1 学良大哥</h3><blockquote>\n<p><a href=\"https://ficowshen.com/\">https://ficowshen.com/</a></p>\n</blockquote>\n<h2 id=\"5-优秀三方库\"><a href=\"#5-优秀三方库\" class=\"headerlink\" title=\"5 优秀三方库\"></a>5 优秀三方库</h2><h3 id=\"5-1-常用三方库，插件，知名博客\"><a href=\"#5-1-常用三方库，插件，知名博客\" class=\"headerlink\" title=\"5.1 常用三方库，插件，知名博客\"></a>5.1 常用三方库，插件，知名博客</h3><blockquote>\n<p><a href=\"https://github.com/Tim9Liu9/TimLiu-iOS\">https://github.com/Tim9Liu9/TimLiu-iOS</a></p>\n</blockquote>\n<h3 id=\"5-2-awesome-ios\"><a href=\"#5-2-awesome-ios\" class=\"headerlink\" title=\"5.2 awesome-ios\"></a>5.2 awesome-ios</h3><blockquote>\n<p>记录了很多关于iOS的三方库 <a href=\"https://github.com/vsouza/awesome-ios\">https://github.com/vsouza/awesome-ios</a></p>\n</blockquote>\n<h3 id=\"5-3-AFnetworking\"><a href=\"#5-3-AFnetworking\" class=\"headerlink\" title=\"5.3 AFnetworking\"></a>5.3 AFnetworking</h3><blockquote>\n<p><a href=\"https://github.com/AFNetworking/AFNetworking\">https://github.com/AFNetworking/AFNetworking</a></p>\n</blockquote>\n<h3 id=\"5-4-RxSwift\"><a href=\"#5-4-RxSwift\" class=\"headerlink\" title=\"5.4 RxSwift\"></a>5.4 RxSwift</h3><blockquote>\n<p>参考博客《麻烦给我的爱人来一杯RxSwift》 <a href=\"https://juejin.cn/post/6844904191161286670\">https://juejin.cn/post/6844904191161286670</a></p>\n</blockquote>\n<h2 id=\"6-项目推荐\"><a href=\"#6-项目推荐\" class=\"headerlink\" title=\"6 项目推荐\"></a>6 项目推荐</h2><h3 id=\"6-1-NextCloud\"><a href=\"#6-1-NextCloud\" class=\"headerlink\" title=\"6.1 NextCloud\"></a>6.1 NextCloud</h3><blockquote>\n<p><a href=\"https://github.com/nextcloud/ios\">https://github.com/nextcloud/ios</a></p>\n</blockquote>\n<h3 id=\"6-2-github-开源项目\"><a href=\"#6-2-github-开源项目\" class=\"headerlink\" title=\"6.2 github 开源项目\"></a>6.2 github 开源项目</h3><blockquote>\n<p><a href=\"https://github.com/panbin/panbin-ios/blob/master/Swift.md\">https://github.com/panbin/panbin-ios/blob/master/Swift.md</a></p>\n</blockquote>\n<h2 id=\"7-其它\"><a href=\"#7-其它\" class=\"headerlink\" title=\"7 其它\"></a>7 其它</h2><h3 id=\"7-1-面试相关\"><a href=\"#7-1-面试相关\" class=\"headerlink\" title=\"7.1 面试相关\"></a>7.1 面试相关</h3><h3 id=\"7-2-开发工具相关\"><a href=\"#7-2-开发工具相关\" class=\"headerlink\" title=\"7.2 开发工具相关\"></a>7.2 开发工具相关</h3>"},{"title":"iOS swift 打造TabLayout效果","date":"2023-02-02T08:15:27.000Z","op":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 需求定义\n\n在首页，我们需要实现一个多tab页，支持左右滑动，上滑吸顶的效果。\n比如这样：\n<img src=page1.gif width=50%>\n\n需要保证良好的用户体验效果，每个页面都是独立的，可以上滑吸顶，左右滑动页面切换，而且还需要支持未读数字提示。\n\n## 2 需求分析\n\n针对这些需求，github上面有一个成熟的框架。\n[JXsegementedView](https://github.com/pujiaxin33/JXSegmentedView)，github上面有2千多个stars，想必是深受大家喜欢，所以我们也可以考虑用起来。\n\n> 它的特点是：\nA powerful and easy to use segmented view (segmentedcontrol, pagingview, pagerview, pagecontrol, categoryview) (腾讯新闻、今日头条、QQ音乐、网易云音乐、京东、爱奇艺、腾讯视频、淘宝、天猫、简书、微博等所有主流APP分类切换滚动视图) \n与其他的同类三方库对比的优点：\n指示器逻辑面向协议编程(Protocol Oriented Programming)，可以为所欲为的扩展指示器效果；\n提供更加全面丰富效果，几乎支持所有主流APP效果；\n使用子类化管理cell样式，逻辑更清晰，扩展更简单；\n列表支持整个生命周期方法； \n\n另外一个与之协同的是 [JXPagingView](https://github.com/pujiaxin33/JXPagingView) ，注意这两个库不是替换的关系，而是互相协作的关系。\n> JXPagingView: 类似微博主页、简书主页、QQ联系人页面等效果。多页面嵌套，既可以上下滑动，也可以左右滑动切换页面。支持HeaderView悬浮、支持下拉刷新、上拉加载更多。\n\n\n\n## 3 使用步骤\n\n### 3.1 引用依赖\n\n这里其实可以远程依赖，但我们考虑到自身一些需求，直接拖进项目里面，将github上的source文件，拷贝到项目里面。\n\n![](./iOS-swift-%E6%89%93%E9%80%A0TabLayout%E6%95%88%E6%9E%9C/segment1.png)\n<src img=segment1.png>\n\n注意这个Personal文件夹里面主要放的是JXPagingView相关代码。\n\nok，这样项目中可以自由使用了。\n\n### 3.2 初始化视图相关\n\n```Swift\nextension JXPagingListContainerView: JXSegmentedViewListContainer {}\n```\n这里我们先扩展下这个协议，这个JXSegementedViewListContainer是框架里面的协议：\n```Swift\npublic protocol JXSegmentedViewListContainer {\n    var defaultSelectedIndex: Int { set get }\n    func contentScrollView() -> UIScrollView\n    func reloadData()\n    func didClickSelectedItem(at index: Int)\n}\n```\n协议可以理解为Android中的接口。\n\n然后我们定义了几个tab，枚举类，姑且叫做这个吧：\n```Swift\nenum WorkListCellItem {\n    /// 待收讫\n    case waitingBalance\n    /// 待开单\n    case waitingForBilling\n    /// 待送货\n    case waitingForDelivery\n    /// 待安装\n    case waitingForInstallation\n    /// 待出库\n    case outOfWarehouse\n    /// 待入库\n    case toBeWarehoused\n}\n```\n\n然后在控制器里面声明下全局变量：\n```Swift\n var pagingView: JXPagingView!\nvar userHeaderView: WorkHeadView!\nvar segmentedViewDataSource: JXSegmentedTitleDataSource!\nvar segmentedView: JXSegmentedView!\nvar JXheightForHeaderInSection: Int = 44\nvar JXTableHeaderViewHeight: Int = 182{\n    didSet{\n        self.pagingView.reloadData()\n    }\n}\n```\n这里简单说下这几个成员作用：\n* JXPagingView: 这个是最外层的容器，里面有一个mainTableView和listContainerView。\n* WorkHeadView: 这个是我们自定义的头部，无需关注。\n* JXSegemntedTitleDataSource: 这个主要是tab的数据。\n* JXheightForHeaderInSection: 标签栏高度定义。\n* JXTableHeaderViewHeight: 头部区域高度定义。\n\n然后看下如何初始化视图：\n```Swift\nfunc setUI() {\n\n        view.backgroundColor = UIColor(hex:\"#3E4D89\").withAlphaComponent(0.06)\n        view.gm_addSubview(navView) { make in\n            make.top.equalTo(0)\n            make.left.right.equalToSuperview()\n            make.height.equalTo(Height_NavBarAndStatusBar)\n        }\n        \n        /// 头部区域\n        userHeaderView = WorkHeadView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width, height: CGFloat(JXTableHeaderViewHeight)))\n        userHeaderView.eventClosure = { [unowned self] (event) in\n            self.workFunctionItemEventClick(event: event)\n        }\n        userHeaderView.clickMsgHandle = {[weak self] model in\n            self?.requestForClickMsg(model: model)\n        }\n        // 配置指示器\n        let indicator = JXSegmentedIndicatorLineView()\n        // 标签栏下划线\n        indicator.indicatorColor = UIColor(r: 64, g: 158, b: 255, alpha: 1)\n        indicator.indicatorWidthIncrement = -15 /// 作用于增大可触区域\n        /// 标签栏\n        segmentedView = JXSegmentedView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width, height: CGFloat(JXheightForHeaderInSection)))\n        segmentedView.backgroundColor = UIColor.white\n        segmentedView.dataSource = dataSource\n        segmentedView.isContentScrollViewClickTransitionAnimationEnabled = true\n        segmentedView.indicators = [indicator]\n\n        let lineWidth = 1/UIScreen.main.scale\n        let lineLayer = CALayer()\n        lineLayer.backgroundColor = UIColor.lightGray.cgColor\n        lineLayer.frame = CGRect(x: 0, y: segmentedView.bounds.height - lineWidth, width: segmentedView.bounds.width, height: lineWidth)\n        segmentedView.layer.addSublayer(lineLayer)\n\n        pagingView = JXPagingView(delegate: self)\n        let header = GMSAutoRefreshHeader()\n        header.setRefreshingTarget(self, refreshingAction: #selector(defaultTableHeaderRefresh))\n        pagingView.mainTableView.mj_header = header\n        if #available(iOS 15.0, *) {\n            pagingView.mainTableView.sectionHeaderTopPadding = 0\n        } else {\n            // Fallback on earlier ···versions\n        }\n        \n        self.view.addSubview(pagingView)\n\n        segmentedView.listContainer = pagingView.listContainerView\n        \n        self.view.gm_addSubview(stockInitializationTipsView) { make in\n            make.top.equalTo(Height_NavBarAndStatusBar)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(0)\n        }\n        pagingView.snp_makeConstraints { make in\n            make.top.equalTo(stockInitializationTipsView.snp_bottom).offset(0)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(ScreenHeight-Height_NavBarAndStatusBar-Height_TabBar)\n        }\n        \n        /// 待开单列表--取消订单闭包回调\n        self.waitingForBillingVC.cancelBlock = { [weak self] in\n            self?.waitingForBillingVC.requestIntendedOrder()\n        }\n        \n        self.setJXCountBolck()\n        \n        WatermarkView.showWindow()\n    }\n```\n这里JXSegmentView主要是标签栏。\n\nPageView是我们实现这效果的父布局。\n不出意外，这个PageView里面应该会关联到标签栏。\n这里有部分代码是这样的：\n`\nsegmentedView.listContainer = pagingView.listContainerView\n`\n这里应该就是建立联系了。\n\n### 3.3 配置代理和数据源\n\n前面将delegate设置为self了，所以我们需要看下如何配置的。\n先看下PageView设置的代理吧：\n```swfit\nextension NewWorkViewController: JXPagingViewDelegate {\n\n    /// tableHeaderView高度\n    func tableHeaderViewHeight(in pagingView: JXPagingView) -> Int {\n        return JXTableHeaderViewHeight\n    }\n\n    /// tableHeaderView\n    func tableHeaderView(in pagingView: JXPagingView) -> UIView {\n        return userHeaderView\n    }\n\n    /// 吸顶标签栏的高度\n    func heightForPinSectionHeader(in pagingView: JXPagingView) -> Int {\n        return JXheightForHeaderInSection\n    }\n\n    /// 吸顶标签栏\n    func viewForPinSectionHeader(in pagingView: JXPagingView) -> UIView {\n        return segmentedView\n    }\n    \n    /// 列表的数量\n    func numberOfLists(in pagingView: JXPagingView) -> Int {\n        return dataSource.attributedTitles.count\n    }\n\n    /// 列表\n    func pagingView(_ pagingView: JXPagingView, initListAtIndex index: Int) -> JXPagingViewListViewDelegate {\n        let flag: WorkListCellItem = self.listDataArray[index]\n        \n        if flag == .waitingBalance {\n            /// 待收讫VC\n            let list = waitingBalanceVC\n            return list\n        }else if flag == .waitingForBilling {\n            /// 待开单VC\n            let list = waitingForBillingVC\n            return list\n        }else if flag == .waitingForDelivery {\n            /// 待送货VC\n            let list = waitingForDeliveryVC\n            return list\n        }else if flag == .waitingForInstallation {\n            /// 待安装VC\n            let list = waitingForInstallationVC\n            return list\n        }else if flag == .outOfWarehouse {\n            /// 待出库VC\n            let list = outOfWarehouseVC\n            return list\n        }else {\n            /// 待入库VC\n            let list = toBeWarehousedVC\n            return list\n        }\n    }\n\n    func mainTableViewDidScroll(_ scrollView: UIScrollView) {\n//        userHeaderView?.scrollViewDidScroll(contentOffsetY: scrollView.contentOffset.y)\n    }\n}\n```\n这里配置了头部，高度等。\n主要的pagingView是需要我们自己实现的，这个就是Tab下方的列表展示了。\n不出意外这个应该需要继承框架里面的某个View吧。\n\n我们等下看下waitingForBillingVC吧。\n\n另外看下标签栏的数据源是怎么设置的：\n```Swift\n private lazy var dataSource : JXSegmentedTitleAttributeDataSource = {\n        let dataSource = JXSegmentedTitleAttributeDataSource()\n        /// 关闭标签栏等分宽度\n        dataSource.isItemSpacingAverageEnabled = false\n        dataSource.itemSpacing = 0\n        return dataSource\n    }()\n```\n这里只是定义了，还需要在需要的地方配置下数据：\n```Swift\n  dataSource.attributedTitles = dataTitles\n  dataSource.selectedAttributedTitles = dataSelectedTitles\n        \n```\n\n## 4 子列表\n\n外层框架搭好了，需要看下每个子列表是如何塞进去的。\n```Swift\n// MARK: - 工作台（待开单）\nclass WorkWaitingForBillingVC: AutomaticDimensionTableViewController, JXPagingViewListViewDelegate {\n```\n\n这里其实本质上是一个控制器哦，只是实现了它定义的代理方法即可。\n这里用了一个我们自己定义的自动高度的控制器，跟这个框架无关哈。\n```Swift\n/// 自动高度 TableView （避免 使用UITableView.automaticDimension 带来的弊端（某些时候 reloadData contentOffSet 会改变 导致闪跳））\n/// 只实现了UITableViewDelegate和高度相关的代理方法，tableview也没有创建，自行按需创建\nclass AutomaticDimensionTableViewController: GMBaseViewController {\n    private var rowHeights = [String: CGFloat]()\n    private var headerHeights = [String: CGFloat]()\n    private var footerHeights = [String: CGFloat]()\n    \n    /// 预估cell高度\n    var rowEstimatedHeight: CGFloat = UITableView.automaticDimension\n    /// 预估header高度\n    var headerEstimatedHeight: CGFloat = 200\n    /// 预估footer高度\n    var footerEstimatedHeight: CGFloat = 200\n\n}\nprivate extension AutomaticDimensionTableViewController {\n    func getRowKeyWithIndexPath(_ indexPath: IndexPath) -> String {\n        let section = indexPath.section\n        let row = indexPath.row\n        let key = \"\\(section)-\\(row)\"\n        return key\n    }\n}\nextension AutomaticDimensionTableViewController: UITableViewDelegate {\n    func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {\n        let key = getRowKeyWithIndexPath(indexPath)\n        let height = cell.frame.height\n        rowHeights[key] = height\n    }\n    func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -> CGFloat {\n        let key = getRowKeyWithIndexPath(indexPath)\n        guard let height = rowHeights[key] else { return rowEstimatedHeight }\n        return height\n    }\n    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n        return UITableView.automaticDimension\n    }\n    \n    \n    \n    func tableView(_ tableView: UITableView, willDisplayHeaderView view: UIView, forSection section: Int) {\n        let key = \"\\(section)\"\n        let height = view.frame.height\n        headerHeights[key] = height\n    }\n    func tableView(_ tableView: UITableView, estimatedHeightForHeaderInSection section: Int) -> CGFloat {\n        let key = \"\\(section)\"\n        guard let height = headerHeights[key] else { return headerEstimatedHeight }\n        return height\n    }\n    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {\n        return UITableView.automaticDimension\n    }\n    \n    \n    func tableView(_ tableView: UITableView, willDisplayFooterView view: UIView, forSection section: Int) {\n        let key = \"\\(section)\"\n        let height = view.frame.height\n        footerHeights[key] = height\n    }\n    func tableView(_ tableView: UITableView, estimatedHeightForFooterInSection section: Int) -> CGFloat {\n        let key = \"\\(section)\"\n        guard let height = footerHeights[key] else { return footerEstimatedHeight }\n        return height\n    }\n    func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -> CGFloat {\n        return UITableView.automaticDimension\n    }\n}\n```\n\n框架要求的协议需要看下：\n```Swift\n@objc\npublic protocol JXPagingViewListViewDelegate {\n    /// 如果列表是VC，就返回VC.view\n    /// 如果列表是View，就返回View自己\n    ///\n    /// - Returns: 返回列表视图\n    func listView() -> UIView\n    /// 返回listView内部持有的UIScrollView或UITableView或UICollectionView\n    /// 主要用于mainTableView已经显示了header，listView的contentOffset需要重置时，内部需要访问到外部传入进来的listView内的scrollView\n    ///\n    /// - Returns: listView内部持有的UIScrollView或UITableView或UICollectionView\n    func listScrollView() -> UIScrollView\n    /// 当listView内部持有的UIScrollView或UITableView或UICollectionView的代理方法`scrollViewDidScroll`回调时，需要调用该代理方法传入的callback\n    ///\n    /// - Parameter callback: `scrollViewDidScroll`回调时调用的callback\n    func listViewDidScrollCallback(callback: @escaping (UIScrollView)->())\n\n    /// 将要重置listScrollView的contentOffset\n    @objc optional func listScrollViewWillResetContentOffset()\n    /// 可选实现，列表将要显示的时候调用\n    @objc optional func listWillAppear()\n    /// 可选实现，列表显示的时候调用\n    @objc optional func listDidAppear()\n    /// 可选实现，列表将要消失的时候调用\n    @objc optional func listWillDisappear()\n    /// 可选实现，列表消失的时候调用\n    @objc optional func listDidDisappear()\n}\n```\n这里要求我们可以实现这些方法。\n\n```Swift\nvar listViewDidScrollCallback: ((UIScrollView) -> ())?\n    \n    deinit {\n        listViewDidScrollCallback = nil\n    }\n    \n    func listView() -> UIView {\n        return self.view\n    }\n    \n    func listScrollView() -> UIScrollView {\n        return self.mainTableView\n    }\n    \n    func listViewDidScrollCallback(callback: @escaping (UIScrollView) -> ()) {\n        self.listViewDidScrollCallback = callback\n    }\n\n    /// 主列表\n    lazy var mainTableView: UITableView = {\n        let tableView = UITableView(frame: UIScreen.main.bounds, style: .grouped)\n        if #available(iOS 15.0, *) {\n            tableView.sectionHeaderTopPadding = 0\n        } else {\n            // Fallback on earlier ···versions\n        }\n        tableView.separatorStyle = .none\n        tableView.delegate = self\n        tableView.dataSource = self\n        tableView.backgroundColor = .white\n        tableView.showsVerticalScrollIndicator = false\n        tableView.showsHorizontalScrollIndicator = false\n        tableView.tableFooterView = UIView()\n        \n        let footer = GMSAutoRefreshFooter()\n        footer.setRefreshingTarget(self, refreshingAction: #selector(defaultTableFooterRefresh))\n        tableView.mj_footer = footer\n       return tableView\n   }()\n```\n这里我们直接把控制的view给他了。\n这个滚动的视图就是我们自己定义的主列表。\n\n大致就是这样，使用起来还是简单的。\n后面有时间再详细看下源码才行。\n\n## 5 总结\n* 本文主要是针对多Tab页，吸顶效果和可分页可滑动的需求，利用一个三方框架完美解决。\n* 主要通过最外层的JPagingView本质上是UIView来的，设置代理，配置头部区域和中间列表区域显示。通过一个listContainer关联起了标签栏和列表区，这样实现双向交互。\n* 使用这个框架的工作就是创建这几个View，配置代理，实现代理，最后实现列表的控制器，控制器也需要实现它提供的代理，另外头部也需要我们按照ui要求自己编写即可。\n* 使用任何一个三方库一定要懂得它的原理，一旦出问题，我们可以游刃而解。\n\n","source":"_posts/iOS-swift-打造TabLayout效果.md","raw":"---\ntitle: iOS swift 打造TabLayout效果\ndate: 2023-02-02 16:15:27\nop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- TabLayout\ncategories:\n- iOS\n---\n\n## 1 需求定义\n\n在首页，我们需要实现一个多tab页，支持左右滑动，上滑吸顶的效果。\n比如这样：\n<img src=page1.gif width=50%>\n\n需要保证良好的用户体验效果，每个页面都是独立的，可以上滑吸顶，左右滑动页面切换，而且还需要支持未读数字提示。\n\n## 2 需求分析\n\n针对这些需求，github上面有一个成熟的框架。\n[JXsegementedView](https://github.com/pujiaxin33/JXSegmentedView)，github上面有2千多个stars，想必是深受大家喜欢，所以我们也可以考虑用起来。\n\n> 它的特点是：\nA powerful and easy to use segmented view (segmentedcontrol, pagingview, pagerview, pagecontrol, categoryview) (腾讯新闻、今日头条、QQ音乐、网易云音乐、京东、爱奇艺、腾讯视频、淘宝、天猫、简书、微博等所有主流APP分类切换滚动视图) \n与其他的同类三方库对比的优点：\n指示器逻辑面向协议编程(Protocol Oriented Programming)，可以为所欲为的扩展指示器效果；\n提供更加全面丰富效果，几乎支持所有主流APP效果；\n使用子类化管理cell样式，逻辑更清晰，扩展更简单；\n列表支持整个生命周期方法； \n\n另外一个与之协同的是 [JXPagingView](https://github.com/pujiaxin33/JXPagingView) ，注意这两个库不是替换的关系，而是互相协作的关系。\n> JXPagingView: 类似微博主页、简书主页、QQ联系人页面等效果。多页面嵌套，既可以上下滑动，也可以左右滑动切换页面。支持HeaderView悬浮、支持下拉刷新、上拉加载更多。\n\n\n\n## 3 使用步骤\n\n### 3.1 引用依赖\n\n这里其实可以远程依赖，但我们考虑到自身一些需求，直接拖进项目里面，将github上的source文件，拷贝到项目里面。\n\n![](./iOS-swift-%E6%89%93%E9%80%A0TabLayout%E6%95%88%E6%9E%9C/segment1.png)\n<src img=segment1.png>\n\n注意这个Personal文件夹里面主要放的是JXPagingView相关代码。\n\nok，这样项目中可以自由使用了。\n\n### 3.2 初始化视图相关\n\n```Swift\nextension JXPagingListContainerView: JXSegmentedViewListContainer {}\n```\n这里我们先扩展下这个协议，这个JXSegementedViewListContainer是框架里面的协议：\n```Swift\npublic protocol JXSegmentedViewListContainer {\n    var defaultSelectedIndex: Int { set get }\n    func contentScrollView() -> UIScrollView\n    func reloadData()\n    func didClickSelectedItem(at index: Int)\n}\n```\n协议可以理解为Android中的接口。\n\n然后我们定义了几个tab，枚举类，姑且叫做这个吧：\n```Swift\nenum WorkListCellItem {\n    /// 待收讫\n    case waitingBalance\n    /// 待开单\n    case waitingForBilling\n    /// 待送货\n    case waitingForDelivery\n    /// 待安装\n    case waitingForInstallation\n    /// 待出库\n    case outOfWarehouse\n    /// 待入库\n    case toBeWarehoused\n}\n```\n\n然后在控制器里面声明下全局变量：\n```Swift\n var pagingView: JXPagingView!\nvar userHeaderView: WorkHeadView!\nvar segmentedViewDataSource: JXSegmentedTitleDataSource!\nvar segmentedView: JXSegmentedView!\nvar JXheightForHeaderInSection: Int = 44\nvar JXTableHeaderViewHeight: Int = 182{\n    didSet{\n        self.pagingView.reloadData()\n    }\n}\n```\n这里简单说下这几个成员作用：\n* JXPagingView: 这个是最外层的容器，里面有一个mainTableView和listContainerView。\n* WorkHeadView: 这个是我们自定义的头部，无需关注。\n* JXSegemntedTitleDataSource: 这个主要是tab的数据。\n* JXheightForHeaderInSection: 标签栏高度定义。\n* JXTableHeaderViewHeight: 头部区域高度定义。\n\n然后看下如何初始化视图：\n```Swift\nfunc setUI() {\n\n        view.backgroundColor = UIColor(hex:\"#3E4D89\").withAlphaComponent(0.06)\n        view.gm_addSubview(navView) { make in\n            make.top.equalTo(0)\n            make.left.right.equalToSuperview()\n            make.height.equalTo(Height_NavBarAndStatusBar)\n        }\n        \n        /// 头部区域\n        userHeaderView = WorkHeadView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width, height: CGFloat(JXTableHeaderViewHeight)))\n        userHeaderView.eventClosure = { [unowned self] (event) in\n            self.workFunctionItemEventClick(event: event)\n        }\n        userHeaderView.clickMsgHandle = {[weak self] model in\n            self?.requestForClickMsg(model: model)\n        }\n        // 配置指示器\n        let indicator = JXSegmentedIndicatorLineView()\n        // 标签栏下划线\n        indicator.indicatorColor = UIColor(r: 64, g: 158, b: 255, alpha: 1)\n        indicator.indicatorWidthIncrement = -15 /// 作用于增大可触区域\n        /// 标签栏\n        segmentedView = JXSegmentedView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width, height: CGFloat(JXheightForHeaderInSection)))\n        segmentedView.backgroundColor = UIColor.white\n        segmentedView.dataSource = dataSource\n        segmentedView.isContentScrollViewClickTransitionAnimationEnabled = true\n        segmentedView.indicators = [indicator]\n\n        let lineWidth = 1/UIScreen.main.scale\n        let lineLayer = CALayer()\n        lineLayer.backgroundColor = UIColor.lightGray.cgColor\n        lineLayer.frame = CGRect(x: 0, y: segmentedView.bounds.height - lineWidth, width: segmentedView.bounds.width, height: lineWidth)\n        segmentedView.layer.addSublayer(lineLayer)\n\n        pagingView = JXPagingView(delegate: self)\n        let header = GMSAutoRefreshHeader()\n        header.setRefreshingTarget(self, refreshingAction: #selector(defaultTableHeaderRefresh))\n        pagingView.mainTableView.mj_header = header\n        if #available(iOS 15.0, *) {\n            pagingView.mainTableView.sectionHeaderTopPadding = 0\n        } else {\n            // Fallback on earlier ···versions\n        }\n        \n        self.view.addSubview(pagingView)\n\n        segmentedView.listContainer = pagingView.listContainerView\n        \n        self.view.gm_addSubview(stockInitializationTipsView) { make in\n            make.top.equalTo(Height_NavBarAndStatusBar)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(0)\n        }\n        pagingView.snp_makeConstraints { make in\n            make.top.equalTo(stockInitializationTipsView.snp_bottom).offset(0)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(ScreenHeight-Height_NavBarAndStatusBar-Height_TabBar)\n        }\n        \n        /// 待开单列表--取消订单闭包回调\n        self.waitingForBillingVC.cancelBlock = { [weak self] in\n            self?.waitingForBillingVC.requestIntendedOrder()\n        }\n        \n        self.setJXCountBolck()\n        \n        WatermarkView.showWindow()\n    }\n```\n这里JXSegmentView主要是标签栏。\n\nPageView是我们实现这效果的父布局。\n不出意外，这个PageView里面应该会关联到标签栏。\n这里有部分代码是这样的：\n`\nsegmentedView.listContainer = pagingView.listContainerView\n`\n这里应该就是建立联系了。\n\n### 3.3 配置代理和数据源\n\n前面将delegate设置为self了，所以我们需要看下如何配置的。\n先看下PageView设置的代理吧：\n```swfit\nextension NewWorkViewController: JXPagingViewDelegate {\n\n    /// tableHeaderView高度\n    func tableHeaderViewHeight(in pagingView: JXPagingView) -> Int {\n        return JXTableHeaderViewHeight\n    }\n\n    /// tableHeaderView\n    func tableHeaderView(in pagingView: JXPagingView) -> UIView {\n        return userHeaderView\n    }\n\n    /// 吸顶标签栏的高度\n    func heightForPinSectionHeader(in pagingView: JXPagingView) -> Int {\n        return JXheightForHeaderInSection\n    }\n\n    /// 吸顶标签栏\n    func viewForPinSectionHeader(in pagingView: JXPagingView) -> UIView {\n        return segmentedView\n    }\n    \n    /// 列表的数量\n    func numberOfLists(in pagingView: JXPagingView) -> Int {\n        return dataSource.attributedTitles.count\n    }\n\n    /// 列表\n    func pagingView(_ pagingView: JXPagingView, initListAtIndex index: Int) -> JXPagingViewListViewDelegate {\n        let flag: WorkListCellItem = self.listDataArray[index]\n        \n        if flag == .waitingBalance {\n            /// 待收讫VC\n            let list = waitingBalanceVC\n            return list\n        }else if flag == .waitingForBilling {\n            /// 待开单VC\n            let list = waitingForBillingVC\n            return list\n        }else if flag == .waitingForDelivery {\n            /// 待送货VC\n            let list = waitingForDeliveryVC\n            return list\n        }else if flag == .waitingForInstallation {\n            /// 待安装VC\n            let list = waitingForInstallationVC\n            return list\n        }else if flag == .outOfWarehouse {\n            /// 待出库VC\n            let list = outOfWarehouseVC\n            return list\n        }else {\n            /// 待入库VC\n            let list = toBeWarehousedVC\n            return list\n        }\n    }\n\n    func mainTableViewDidScroll(_ scrollView: UIScrollView) {\n//        userHeaderView?.scrollViewDidScroll(contentOffsetY: scrollView.contentOffset.y)\n    }\n}\n```\n这里配置了头部，高度等。\n主要的pagingView是需要我们自己实现的，这个就是Tab下方的列表展示了。\n不出意外这个应该需要继承框架里面的某个View吧。\n\n我们等下看下waitingForBillingVC吧。\n\n另外看下标签栏的数据源是怎么设置的：\n```Swift\n private lazy var dataSource : JXSegmentedTitleAttributeDataSource = {\n        let dataSource = JXSegmentedTitleAttributeDataSource()\n        /// 关闭标签栏等分宽度\n        dataSource.isItemSpacingAverageEnabled = false\n        dataSource.itemSpacing = 0\n        return dataSource\n    }()\n```\n这里只是定义了，还需要在需要的地方配置下数据：\n```Swift\n  dataSource.attributedTitles = dataTitles\n  dataSource.selectedAttributedTitles = dataSelectedTitles\n        \n```\n\n## 4 子列表\n\n外层框架搭好了，需要看下每个子列表是如何塞进去的。\n```Swift\n// MARK: - 工作台（待开单）\nclass WorkWaitingForBillingVC: AutomaticDimensionTableViewController, JXPagingViewListViewDelegate {\n```\n\n这里其实本质上是一个控制器哦，只是实现了它定义的代理方法即可。\n这里用了一个我们自己定义的自动高度的控制器，跟这个框架无关哈。\n```Swift\n/// 自动高度 TableView （避免 使用UITableView.automaticDimension 带来的弊端（某些时候 reloadData contentOffSet 会改变 导致闪跳））\n/// 只实现了UITableViewDelegate和高度相关的代理方法，tableview也没有创建，自行按需创建\nclass AutomaticDimensionTableViewController: GMBaseViewController {\n    private var rowHeights = [String: CGFloat]()\n    private var headerHeights = [String: CGFloat]()\n    private var footerHeights = [String: CGFloat]()\n    \n    /// 预估cell高度\n    var rowEstimatedHeight: CGFloat = UITableView.automaticDimension\n    /// 预估header高度\n    var headerEstimatedHeight: CGFloat = 200\n    /// 预估footer高度\n    var footerEstimatedHeight: CGFloat = 200\n\n}\nprivate extension AutomaticDimensionTableViewController {\n    func getRowKeyWithIndexPath(_ indexPath: IndexPath) -> String {\n        let section = indexPath.section\n        let row = indexPath.row\n        let key = \"\\(section)-\\(row)\"\n        return key\n    }\n}\nextension AutomaticDimensionTableViewController: UITableViewDelegate {\n    func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {\n        let key = getRowKeyWithIndexPath(indexPath)\n        let height = cell.frame.height\n        rowHeights[key] = height\n    }\n    func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -> CGFloat {\n        let key = getRowKeyWithIndexPath(indexPath)\n        guard let height = rowHeights[key] else { return rowEstimatedHeight }\n        return height\n    }\n    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n        return UITableView.automaticDimension\n    }\n    \n    \n    \n    func tableView(_ tableView: UITableView, willDisplayHeaderView view: UIView, forSection section: Int) {\n        let key = \"\\(section)\"\n        let height = view.frame.height\n        headerHeights[key] = height\n    }\n    func tableView(_ tableView: UITableView, estimatedHeightForHeaderInSection section: Int) -> CGFloat {\n        let key = \"\\(section)\"\n        guard let height = headerHeights[key] else { return headerEstimatedHeight }\n        return height\n    }\n    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {\n        return UITableView.automaticDimension\n    }\n    \n    \n    func tableView(_ tableView: UITableView, willDisplayFooterView view: UIView, forSection section: Int) {\n        let key = \"\\(section)\"\n        let height = view.frame.height\n        footerHeights[key] = height\n    }\n    func tableView(_ tableView: UITableView, estimatedHeightForFooterInSection section: Int) -> CGFloat {\n        let key = \"\\(section)\"\n        guard let height = footerHeights[key] else { return footerEstimatedHeight }\n        return height\n    }\n    func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -> CGFloat {\n        return UITableView.automaticDimension\n    }\n}\n```\n\n框架要求的协议需要看下：\n```Swift\n@objc\npublic protocol JXPagingViewListViewDelegate {\n    /// 如果列表是VC，就返回VC.view\n    /// 如果列表是View，就返回View自己\n    ///\n    /// - Returns: 返回列表视图\n    func listView() -> UIView\n    /// 返回listView内部持有的UIScrollView或UITableView或UICollectionView\n    /// 主要用于mainTableView已经显示了header，listView的contentOffset需要重置时，内部需要访问到外部传入进来的listView内的scrollView\n    ///\n    /// - Returns: listView内部持有的UIScrollView或UITableView或UICollectionView\n    func listScrollView() -> UIScrollView\n    /// 当listView内部持有的UIScrollView或UITableView或UICollectionView的代理方法`scrollViewDidScroll`回调时，需要调用该代理方法传入的callback\n    ///\n    /// - Parameter callback: `scrollViewDidScroll`回调时调用的callback\n    func listViewDidScrollCallback(callback: @escaping (UIScrollView)->())\n\n    /// 将要重置listScrollView的contentOffset\n    @objc optional func listScrollViewWillResetContentOffset()\n    /// 可选实现，列表将要显示的时候调用\n    @objc optional func listWillAppear()\n    /// 可选实现，列表显示的时候调用\n    @objc optional func listDidAppear()\n    /// 可选实现，列表将要消失的时候调用\n    @objc optional func listWillDisappear()\n    /// 可选实现，列表消失的时候调用\n    @objc optional func listDidDisappear()\n}\n```\n这里要求我们可以实现这些方法。\n\n```Swift\nvar listViewDidScrollCallback: ((UIScrollView) -> ())?\n    \n    deinit {\n        listViewDidScrollCallback = nil\n    }\n    \n    func listView() -> UIView {\n        return self.view\n    }\n    \n    func listScrollView() -> UIScrollView {\n        return self.mainTableView\n    }\n    \n    func listViewDidScrollCallback(callback: @escaping (UIScrollView) -> ()) {\n        self.listViewDidScrollCallback = callback\n    }\n\n    /// 主列表\n    lazy var mainTableView: UITableView = {\n        let tableView = UITableView(frame: UIScreen.main.bounds, style: .grouped)\n        if #available(iOS 15.0, *) {\n            tableView.sectionHeaderTopPadding = 0\n        } else {\n            // Fallback on earlier ···versions\n        }\n        tableView.separatorStyle = .none\n        tableView.delegate = self\n        tableView.dataSource = self\n        tableView.backgroundColor = .white\n        tableView.showsVerticalScrollIndicator = false\n        tableView.showsHorizontalScrollIndicator = false\n        tableView.tableFooterView = UIView()\n        \n        let footer = GMSAutoRefreshFooter()\n        footer.setRefreshingTarget(self, refreshingAction: #selector(defaultTableFooterRefresh))\n        tableView.mj_footer = footer\n       return tableView\n   }()\n```\n这里我们直接把控制的view给他了。\n这个滚动的视图就是我们自己定义的主列表。\n\n大致就是这样，使用起来还是简单的。\n后面有时间再详细看下源码才行。\n\n## 5 总结\n* 本文主要是针对多Tab页，吸顶效果和可分页可滑动的需求，利用一个三方框架完美解决。\n* 主要通过最外层的JPagingView本质上是UIView来的，设置代理，配置头部区域和中间列表区域显示。通过一个listContainer关联起了标签栏和列表区，这样实现双向交互。\n* 使用这个框架的工作就是创建这几个View，配置代理，实现代理，最后实现列表的控制器，控制器也需要实现它提供的代理，另外头部也需要我们按照ui要求自己编写即可。\n* 使用任何一个三方库一定要懂得它的原理，一旦出问题，我们可以游刃而解。\n\n","slug":"iOS-swift-打造TabLayout效果","published":1,"updated":"2023-02-01T09:31:00.499Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlgycqp0000u6v7bq7sbvuw","content":"<h2 id=\"1-需求定义\"><a href=\"#1-需求定义\" class=\"headerlink\" title=\"1 需求定义\"></a>1 需求定义</h2><p>在首页，我们需要实现一个多tab页，支持左右滑动，上滑吸顶的效果。<br>比如这样：<br><img src=page1.gif width=50%></p>\n<p>需要保证良好的用户体验效果，每个页面都是独立的，可以上滑吸顶，左右滑动页面切换，而且还需要支持未读数字提示。</p>\n<h2 id=\"2-需求分析\"><a href=\"#2-需求分析\" class=\"headerlink\" title=\"2 需求分析\"></a>2 需求分析</h2><p>针对这些需求，github上面有一个成熟的框架。<br><a href=\"https://github.com/pujiaxin33/JXSegmentedView\">JXsegementedView</a>，github上面有2千多个stars，想必是深受大家喜欢，所以我们也可以考虑用起来。</p>\n<blockquote>\n<p>它的特点是：<br>A powerful and easy to use segmented view (segmentedcontrol, pagingview, pagerview, pagecontrol, categoryview) (腾讯新闻、今日头条、QQ音乐、网易云音乐、京东、爱奇艺、腾讯视频、淘宝、天猫、简书、微博等所有主流APP分类切换滚动视图)<br>与其他的同类三方库对比的优点：<br>指示器逻辑面向协议编程(Protocol Oriented Programming)，可以为所欲为的扩展指示器效果；<br>提供更加全面丰富效果，几乎支持所有主流APP效果；<br>使用子类化管理cell样式，逻辑更清晰，扩展更简单；<br>列表支持整个生命周期方法； </p>\n</blockquote>\n<p>另外一个与之协同的是 <a href=\"https://github.com/pujiaxin33/JXPagingView\">JXPagingView</a> ，注意这两个库不是替换的关系，而是互相协作的关系。</p>\n<blockquote>\n<p>JXPagingView: 类似微博主页、简书主页、QQ联系人页面等效果。多页面嵌套，既可以上下滑动，也可以左右滑动切换页面。支持HeaderView悬浮、支持下拉刷新、上拉加载更多。</p>\n</blockquote>\n<h2 id=\"3-使用步骤\"><a href=\"#3-使用步骤\" class=\"headerlink\" title=\"3 使用步骤\"></a>3 使用步骤</h2><h3 id=\"3-1-引用依赖\"><a href=\"#3-1-引用依赖\" class=\"headerlink\" title=\"3.1 引用依赖\"></a>3.1 引用依赖</h3><p>这里其实可以远程依赖，但我们考虑到自身一些需求，直接拖进项目里面，将github上的source文件，拷贝到项目里面。</p>\n<p><img src=\"/./iOS-swift-%E6%89%93%E9%80%A0TabLayout%E6%95%88%E6%9E%9C/segment1.png\"><br><src img=segment1.png></p>\n<p>注意这个Personal文件夹里面主要放的是JXPagingView相关代码。</p>\n<p>ok，这样项目中可以自由使用了。</p>\n<h3 id=\"3-2-初始化视图相关\"><a href=\"#3-2-初始化视图相关\" class=\"headerlink\" title=\"3.2 初始化视图相关\"></a>3.2 初始化视图相关</h3><pre><code class=\"line-numbers language-Swift\">extension JXPagingListContainerView: JXSegmentedViewListContainer &#123;&#125;\n</code></pre>\n<p>这里我们先扩展下这个协议，这个JXSegementedViewListContainer是框架里面的协议：</p>\n<pre><code class=\"line-numbers language-Swift\">public protocol JXSegmentedViewListContainer &#123;\n    var defaultSelectedIndex: Int &#123; set get &#125;\n    func contentScrollView() -&gt; UIScrollView\n    func reloadData()\n    func didClickSelectedItem(at index: Int)\n&#125;\n</code></pre>\n<p>协议可以理解为Android中的接口。</p>\n<p>然后我们定义了几个tab，枚举类，姑且叫做这个吧：</p>\n<pre><code class=\"line-numbers language-Swift\">enum WorkListCellItem &#123;\n    /// 待收讫\n    case waitingBalance\n    /// 待开单\n    case waitingForBilling\n    /// 待送货\n    case waitingForDelivery\n    /// 待安装\n    case waitingForInstallation\n    /// 待出库\n    case outOfWarehouse\n    /// 待入库\n    case toBeWarehoused\n&#125;\n</code></pre>\n<p>然后在控制器里面声明下全局变量：</p>\n<pre><code class=\"line-numbers language-Swift\"> var pagingView: JXPagingView!\nvar userHeaderView: WorkHeadView!\nvar segmentedViewDataSource: JXSegmentedTitleDataSource!\nvar segmentedView: JXSegmentedView!\nvar JXheightForHeaderInSection: Int = 44\nvar JXTableHeaderViewHeight: Int = 182&#123;\n    didSet&#123;\n        self.pagingView.reloadData()\n    &#125;\n&#125;\n</code></pre>\n<p>这里简单说下这几个成员作用：</p>\n<ul>\n<li>JXPagingView: 这个是最外层的容器，里面有一个mainTableView和listContainerView。</li>\n<li>WorkHeadView: 这个是我们自定义的头部，无需关注。</li>\n<li>JXSegemntedTitleDataSource: 这个主要是tab的数据。</li>\n<li>JXheightForHeaderInSection: 标签栏高度定义。</li>\n<li>JXTableHeaderViewHeight: 头部区域高度定义。</li>\n</ul>\n<p>然后看下如何初始化视图：</p>\n<pre><code class=\"line-numbers language-Swift\">func setUI() &#123;\n\n        view.backgroundColor = UIColor(hex:&quot;#3E4D89&quot;).withAlphaComponent(0.06)\n        view.gm_addSubview(navView) &#123; make in\n            make.top.equalTo(0)\n            make.left.right.equalToSuperview()\n            make.height.equalTo(Height_NavBarAndStatusBar)\n        &#125;\n        \n        /// 头部区域\n        userHeaderView = WorkHeadView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width, height: CGFloat(JXTableHeaderViewHeight)))\n        userHeaderView.eventClosure = &#123; [unowned self] (event) in\n            self.workFunctionItemEventClick(event: event)\n        &#125;\n        userHeaderView.clickMsgHandle = &#123;[weak self] model in\n            self?.requestForClickMsg(model: model)\n        &#125;\n        // 配置指示器\n        let indicator = JXSegmentedIndicatorLineView()\n        // 标签栏下划线\n        indicator.indicatorColor = UIColor(r: 64, g: 158, b: 255, alpha: 1)\n        indicator.indicatorWidthIncrement = -15 /// 作用于增大可触区域\n        /// 标签栏\n        segmentedView = JXSegmentedView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width, height: CGFloat(JXheightForHeaderInSection)))\n        segmentedView.backgroundColor = UIColor.white\n        segmentedView.dataSource = dataSource\n        segmentedView.isContentScrollViewClickTransitionAnimationEnabled = true\n        segmentedView.indicators = [indicator]\n\n        let lineWidth = 1/UIScreen.main.scale\n        let lineLayer = CALayer()\n        lineLayer.backgroundColor = UIColor.lightGray.cgColor\n        lineLayer.frame = CGRect(x: 0, y: segmentedView.bounds.height - lineWidth, width: segmentedView.bounds.width, height: lineWidth)\n        segmentedView.layer.addSublayer(lineLayer)\n\n        pagingView = JXPagingView(delegate: self)\n        let header = GMSAutoRefreshHeader()\n        header.setRefreshingTarget(self, refreshingAction: #selector(defaultTableHeaderRefresh))\n        pagingView.mainTableView.mj_header = header\n        if #available(iOS 15.0, *) &#123;\n            pagingView.mainTableView.sectionHeaderTopPadding = 0\n        &#125; else &#123;\n            // Fallback on earlier ···versions\n        &#125;\n        \n        self.view.addSubview(pagingView)\n\n        segmentedView.listContainer = pagingView.listContainerView\n        \n        self.view.gm_addSubview(stockInitializationTipsView) &#123; make in\n            make.top.equalTo(Height_NavBarAndStatusBar)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(0)\n        &#125;\n        pagingView.snp_makeConstraints &#123; make in\n            make.top.equalTo(stockInitializationTipsView.snp_bottom).offset(0)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(ScreenHeight-Height_NavBarAndStatusBar-Height_TabBar)\n        &#125;\n        \n        /// 待开单列表--取消订单闭包回调\n        self.waitingForBillingVC.cancelBlock = &#123; [weak self] in\n            self?.waitingForBillingVC.requestIntendedOrder()\n        &#125;\n        \n        self.setJXCountBolck()\n        \n        WatermarkView.showWindow()\n    &#125;\n</code></pre>\n<p>这里JXSegmentView主要是标签栏。</p>\n<p>PageView是我们实现这效果的父布局。<br>不出意外，这个PageView里面应该会关联到标签栏。<br>这里有部分代码是这样的：<br><code>segmentedView.listContainer = pagingView.listContainerView</code><br>这里应该就是建立联系了。</p>\n<h3 id=\"3-3-配置代理和数据源\"><a href=\"#3-3-配置代理和数据源\" class=\"headerlink\" title=\"3.3 配置代理和数据源\"></a>3.3 配置代理和数据源</h3><p>前面将delegate设置为self了，所以我们需要看下如何配置的。<br>先看下PageView设置的代理吧：</p>\n<pre><code class=\"line-numbers language-swfit\">extension NewWorkViewController: JXPagingViewDelegate &#123;\n\n    /// tableHeaderView高度\n    func tableHeaderViewHeight(in pagingView: JXPagingView) -&gt; Int &#123;\n        return JXTableHeaderViewHeight\n    &#125;\n\n    /// tableHeaderView\n    func tableHeaderView(in pagingView: JXPagingView) -&gt; UIView &#123;\n        return userHeaderView\n    &#125;\n\n    /// 吸顶标签栏的高度\n    func heightForPinSectionHeader(in pagingView: JXPagingView) -&gt; Int &#123;\n        return JXheightForHeaderInSection\n    &#125;\n\n    /// 吸顶标签栏\n    func viewForPinSectionHeader(in pagingView: JXPagingView) -&gt; UIView &#123;\n        return segmentedView\n    &#125;\n    \n    /// 列表的数量\n    func numberOfLists(in pagingView: JXPagingView) -&gt; Int &#123;\n        return dataSource.attributedTitles.count\n    &#125;\n\n    /// 列表\n    func pagingView(_ pagingView: JXPagingView, initListAtIndex index: Int) -&gt; JXPagingViewListViewDelegate &#123;\n        let flag: WorkListCellItem = self.listDataArray[index]\n        \n        if flag == .waitingBalance &#123;\n            /// 待收讫VC\n            let list = waitingBalanceVC\n            return list\n        &#125;else if flag == .waitingForBilling &#123;\n            /// 待开单VC\n            let list = waitingForBillingVC\n            return list\n        &#125;else if flag == .waitingForDelivery &#123;\n            /// 待送货VC\n            let list = waitingForDeliveryVC\n            return list\n        &#125;else if flag == .waitingForInstallation &#123;\n            /// 待安装VC\n            let list = waitingForInstallationVC\n            return list\n        &#125;else if flag == .outOfWarehouse &#123;\n            /// 待出库VC\n            let list = outOfWarehouseVC\n            return list\n        &#125;else &#123;\n            /// 待入库VC\n            let list = toBeWarehousedVC\n            return list\n        &#125;\n    &#125;\n\n    func mainTableViewDidScroll(_ scrollView: UIScrollView) &#123;\n//        userHeaderView?.scrollViewDidScroll(contentOffsetY: scrollView.contentOffset.y)\n    &#125;\n&#125;\n</code></pre>\n<p>这里配置了头部，高度等。<br>主要的pagingView是需要我们自己实现的，这个就是Tab下方的列表展示了。<br>不出意外这个应该需要继承框架里面的某个View吧。</p>\n<p>我们等下看下waitingForBillingVC吧。</p>\n<p>另外看下标签栏的数据源是怎么设置的：</p>\n<pre><code class=\"line-numbers language-Swift\"> private lazy var dataSource : JXSegmentedTitleAttributeDataSource = &#123;\n        let dataSource = JXSegmentedTitleAttributeDataSource()\n        /// 关闭标签栏等分宽度\n        dataSource.isItemSpacingAverageEnabled = false\n        dataSource.itemSpacing = 0\n        return dataSource\n    &#125;()\n</code></pre>\n<p>这里只是定义了，还需要在需要的地方配置下数据：</p>\n<pre><code class=\"line-numbers language-Swift\">  dataSource.attributedTitles = dataTitles\n  dataSource.selectedAttributedTitles = dataSelectedTitles\n        \n</code></pre>\n<h2 id=\"4-子列表\"><a href=\"#4-子列表\" class=\"headerlink\" title=\"4 子列表\"></a>4 子列表</h2><p>外层框架搭好了，需要看下每个子列表是如何塞进去的。</p>\n<pre><code class=\"line-numbers language-Swift\">// MARK: - 工作台（待开单）\nclass WorkWaitingForBillingVC: AutomaticDimensionTableViewController, JXPagingViewListViewDelegate &#123;\n</code></pre>\n<p>这里其实本质上是一个控制器哦，只是实现了它定义的代理方法即可。<br>这里用了一个我们自己定义的自动高度的控制器，跟这个框架无关哈。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 自动高度 TableView （避免 使用UITableView.automaticDimension 带来的弊端（某些时候 reloadData contentOffSet 会改变 导致闪跳））\n/// 只实现了UITableViewDelegate和高度相关的代理方法，tableview也没有创建，自行按需创建\nclass AutomaticDimensionTableViewController: GMBaseViewController &#123;\n    private var rowHeights = [String: CGFloat]()\n    private var headerHeights = [String: CGFloat]()\n    private var footerHeights = [String: CGFloat]()\n    \n    /// 预估cell高度\n    var rowEstimatedHeight: CGFloat = UITableView.automaticDimension\n    /// 预估header高度\n    var headerEstimatedHeight: CGFloat = 200\n    /// 预估footer高度\n    var footerEstimatedHeight: CGFloat = 200\n\n&#125;\nprivate extension AutomaticDimensionTableViewController &#123;\n    func getRowKeyWithIndexPath(_ indexPath: IndexPath) -&gt; String &#123;\n        let section = indexPath.section\n        let row = indexPath.row\n        let key = &quot;\\(section)-\\(row)&quot;\n        return key\n    &#125;\n&#125;\nextension AutomaticDimensionTableViewController: UITableViewDelegate &#123;\n    func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) &#123;\n        let key = getRowKeyWithIndexPath(indexPath)\n        let height = cell.frame.height\n        rowHeights[key] = height\n    &#125;\n    func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n        let key = getRowKeyWithIndexPath(indexPath)\n        guard let height = rowHeights[key] else &#123; return rowEstimatedHeight &#125;\n        return height\n    &#125;\n    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n        return UITableView.automaticDimension\n    &#125;\n    \n    \n    \n    func tableView(_ tableView: UITableView, willDisplayHeaderView view: UIView, forSection section: Int) &#123;\n        let key = &quot;\\(section)&quot;\n        let height = view.frame.height\n        headerHeights[key] = height\n    &#125;\n    func tableView(_ tableView: UITableView, estimatedHeightForHeaderInSection section: Int) -&gt; CGFloat &#123;\n        let key = &quot;\\(section)&quot;\n        guard let height = headerHeights[key] else &#123; return headerEstimatedHeight &#125;\n        return height\n    &#125;\n    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat &#123;\n        return UITableView.automaticDimension\n    &#125;\n    \n    \n    func tableView(_ tableView: UITableView, willDisplayFooterView view: UIView, forSection section: Int) &#123;\n        let key = &quot;\\(section)&quot;\n        let height = view.frame.height\n        footerHeights[key] = height\n    &#125;\n    func tableView(_ tableView: UITableView, estimatedHeightForFooterInSection section: Int) -&gt; CGFloat &#123;\n        let key = &quot;\\(section)&quot;\n        guard let height = footerHeights[key] else &#123; return footerEstimatedHeight &#125;\n        return height\n    &#125;\n    func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -&gt; CGFloat &#123;\n        return UITableView.automaticDimension\n    &#125;\n&#125;\n</code></pre>\n<p>框架要求的协议需要看下：</p>\n<pre><code class=\"line-numbers language-Swift\">@objc\npublic protocol JXPagingViewListViewDelegate &#123;\n    /// 如果列表是VC，就返回VC.view\n    /// 如果列表是View，就返回View自己\n    ///\n    /// - Returns: 返回列表视图\n    func listView() -&gt; UIView\n    /// 返回listView内部持有的UIScrollView或UITableView或UICollectionView\n    /// 主要用于mainTableView已经显示了header，listView的contentOffset需要重置时，内部需要访问到外部传入进来的listView内的scrollView\n    ///\n    /// - Returns: listView内部持有的UIScrollView或UITableView或UICollectionView\n    func listScrollView() -&gt; UIScrollView\n    /// 当listView内部持有的UIScrollView或UITableView或UICollectionView的代理方法`scrollViewDidScroll`回调时，需要调用该代理方法传入的callback\n    ///\n    /// - Parameter callback: `scrollViewDidScroll`回调时调用的callback\n    func listViewDidScrollCallback(callback: @escaping (UIScrollView)-&gt;())\n\n    /// 将要重置listScrollView的contentOffset\n    @objc optional func listScrollViewWillResetContentOffset()\n    /// 可选实现，列表将要显示的时候调用\n    @objc optional func listWillAppear()\n    /// 可选实现，列表显示的时候调用\n    @objc optional func listDidAppear()\n    /// 可选实现，列表将要消失的时候调用\n    @objc optional func listWillDisappear()\n    /// 可选实现，列表消失的时候调用\n    @objc optional func listDidDisappear()\n&#125;\n</code></pre>\n<p>这里要求我们可以实现这些方法。</p>\n<pre><code class=\"line-numbers language-Swift\">var listViewDidScrollCallback: ((UIScrollView) -&gt; ())?\n    \n    deinit &#123;\n        listViewDidScrollCallback = nil\n    &#125;\n    \n    func listView() -&gt; UIView &#123;\n        return self.view\n    &#125;\n    \n    func listScrollView() -&gt; UIScrollView &#123;\n        return self.mainTableView\n    &#125;\n    \n    func listViewDidScrollCallback(callback: @escaping (UIScrollView) -&gt; ()) &#123;\n        self.listViewDidScrollCallback = callback\n    &#125;\n\n    /// 主列表\n    lazy var mainTableView: UITableView = &#123;\n        let tableView = UITableView(frame: UIScreen.main.bounds, style: .grouped)\n        if #available(iOS 15.0, *) &#123;\n            tableView.sectionHeaderTopPadding = 0\n        &#125; else &#123;\n            // Fallback on earlier ···versions\n        &#125;\n        tableView.separatorStyle = .none\n        tableView.delegate = self\n        tableView.dataSource = self\n        tableView.backgroundColor = .white\n        tableView.showsVerticalScrollIndicator = false\n        tableView.showsHorizontalScrollIndicator = false\n        tableView.tableFooterView = UIView()\n        \n        let footer = GMSAutoRefreshFooter()\n        footer.setRefreshingTarget(self, refreshingAction: #selector(defaultTableFooterRefresh))\n        tableView.mj_footer = footer\n       return tableView\n   &#125;()\n</code></pre>\n<p>这里我们直接把控制的view给他了。<br>这个滚动的视图就是我们自己定义的主列表。</p>\n<p>大致就是这样，使用起来还是简单的。<br>后面有时间再详细看下源码才行。</p>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5 总结\"></a>5 总结</h2><ul>\n<li>本文主要是针对多Tab页，吸顶效果和可分页可滑动的需求，利用一个三方框架完美解决。</li>\n<li>主要通过最外层的JPagingView本质上是UIView来的，设置代理，配置头部区域和中间列表区域显示。通过一个listContainer关联起了标签栏和列表区，这样实现双向交互。</li>\n<li>使用这个框架的工作就是创建这几个View，配置代理，实现代理，最后实现列表的控制器，控制器也需要实现它提供的代理，另外头部也需要我们按照ui要求自己编写即可。</li>\n<li>使用任何一个三方库一定要懂得它的原理，一旦出问题，我们可以游刃而解。</li>\n</ul>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-需求定义\"><a href=\"#1-需求定义\" class=\"headerlink\" title=\"1 需求定义\"></a>1 需求定义</h2><p>在首页，我们需要实现一个多tab页，支持左右滑动，上滑吸顶的效果。<br>比如这样：<br><img src=page1.gif width=50%></p>\n<p>需要保证良好的用户体验效果，每个页面都是独立的，可以上滑吸顶，左右滑动页面切换，而且还需要支持未读数字提示。</p>\n<h2 id=\"2-需求分析\"><a href=\"#2-需求分析\" class=\"headerlink\" title=\"2 需求分析\"></a>2 需求分析</h2><p>针对这些需求，github上面有一个成熟的框架。<br><a href=\"https://github.com/pujiaxin33/JXSegmentedView\">JXsegementedView</a>，github上面有2千多个stars，想必是深受大家喜欢，所以我们也可以考虑用起来。</p>\n<blockquote>\n<p>它的特点是：<br>A powerful and easy to use segmented view (segmentedcontrol, pagingview, pagerview, pagecontrol, categoryview) (腾讯新闻、今日头条、QQ音乐、网易云音乐、京东、爱奇艺、腾讯视频、淘宝、天猫、简书、微博等所有主流APP分类切换滚动视图)<br>与其他的同类三方库对比的优点：<br>指示器逻辑面向协议编程(Protocol Oriented Programming)，可以为所欲为的扩展指示器效果；<br>提供更加全面丰富效果，几乎支持所有主流APP效果；<br>使用子类化管理cell样式，逻辑更清晰，扩展更简单；<br>列表支持整个生命周期方法； </p>\n</blockquote>\n<p>另外一个与之协同的是 <a href=\"https://github.com/pujiaxin33/JXPagingView\">JXPagingView</a> ，注意这两个库不是替换的关系，而是互相协作的关系。</p>\n<blockquote>\n<p>JXPagingView: 类似微博主页、简书主页、QQ联系人页面等效果。多页面嵌套，既可以上下滑动，也可以左右滑动切换页面。支持HeaderView悬浮、支持下拉刷新、上拉加载更多。</p>\n</blockquote>\n<h2 id=\"3-使用步骤\"><a href=\"#3-使用步骤\" class=\"headerlink\" title=\"3 使用步骤\"></a>3 使用步骤</h2><h3 id=\"3-1-引用依赖\"><a href=\"#3-1-引用依赖\" class=\"headerlink\" title=\"3.1 引用依赖\"></a>3.1 引用依赖</h3><p>这里其实可以远程依赖，但我们考虑到自身一些需求，直接拖进项目里面，将github上的source文件，拷贝到项目里面。</p>\n<p><img src=\"/./iOS-swift-%E6%89%93%E9%80%A0TabLayout%E6%95%88%E6%9E%9C/segment1.png\"><br><src img=segment1.png></p>\n<p>注意这个Personal文件夹里面主要放的是JXPagingView相关代码。</p>\n<p>ok，这样项目中可以自由使用了。</p>\n<h3 id=\"3-2-初始化视图相关\"><a href=\"#3-2-初始化视图相关\" class=\"headerlink\" title=\"3.2 初始化视图相关\"></a>3.2 初始化视图相关</h3><pre><code class=\"line-numbers language-Swift\">extension JXPagingListContainerView: JXSegmentedViewListContainer &#123;&#125;\n</code></pre>\n<p>这里我们先扩展下这个协议，这个JXSegementedViewListContainer是框架里面的协议：</p>\n<pre><code class=\"line-numbers language-Swift\">public protocol JXSegmentedViewListContainer &#123;\n    var defaultSelectedIndex: Int &#123; set get &#125;\n    func contentScrollView() -&gt; UIScrollView\n    func reloadData()\n    func didClickSelectedItem(at index: Int)\n&#125;\n</code></pre>\n<p>协议可以理解为Android中的接口。</p>\n<p>然后我们定义了几个tab，枚举类，姑且叫做这个吧：</p>\n<pre><code class=\"line-numbers language-Swift\">enum WorkListCellItem &#123;\n    /// 待收讫\n    case waitingBalance\n    /// 待开单\n    case waitingForBilling\n    /// 待送货\n    case waitingForDelivery\n    /// 待安装\n    case waitingForInstallation\n    /// 待出库\n    case outOfWarehouse\n    /// 待入库\n    case toBeWarehoused\n&#125;\n</code></pre>\n<p>然后在控制器里面声明下全局变量：</p>\n<pre><code class=\"line-numbers language-Swift\"> var pagingView: JXPagingView!\nvar userHeaderView: WorkHeadView!\nvar segmentedViewDataSource: JXSegmentedTitleDataSource!\nvar segmentedView: JXSegmentedView!\nvar JXheightForHeaderInSection: Int = 44\nvar JXTableHeaderViewHeight: Int = 182&#123;\n    didSet&#123;\n        self.pagingView.reloadData()\n    &#125;\n&#125;\n</code></pre>\n<p>这里简单说下这几个成员作用：</p>\n<ul>\n<li>JXPagingView: 这个是最外层的容器，里面有一个mainTableView和listContainerView。</li>\n<li>WorkHeadView: 这个是我们自定义的头部，无需关注。</li>\n<li>JXSegemntedTitleDataSource: 这个主要是tab的数据。</li>\n<li>JXheightForHeaderInSection: 标签栏高度定义。</li>\n<li>JXTableHeaderViewHeight: 头部区域高度定义。</li>\n</ul>\n<p>然后看下如何初始化视图：</p>\n<pre><code class=\"line-numbers language-Swift\">func setUI() &#123;\n\n        view.backgroundColor = UIColor(hex:&quot;#3E4D89&quot;).withAlphaComponent(0.06)\n        view.gm_addSubview(navView) &#123; make in\n            make.top.equalTo(0)\n            make.left.right.equalToSuperview()\n            make.height.equalTo(Height_NavBarAndStatusBar)\n        &#125;\n        \n        /// 头部区域\n        userHeaderView = WorkHeadView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width, height: CGFloat(JXTableHeaderViewHeight)))\n        userHeaderView.eventClosure = &#123; [unowned self] (event) in\n            self.workFunctionItemEventClick(event: event)\n        &#125;\n        userHeaderView.clickMsgHandle = &#123;[weak self] model in\n            self?.requestForClickMsg(model: model)\n        &#125;\n        // 配置指示器\n        let indicator = JXSegmentedIndicatorLineView()\n        // 标签栏下划线\n        indicator.indicatorColor = UIColor(r: 64, g: 158, b: 255, alpha: 1)\n        indicator.indicatorWidthIncrement = -15 /// 作用于增大可触区域\n        /// 标签栏\n        segmentedView = JXSegmentedView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width, height: CGFloat(JXheightForHeaderInSection)))\n        segmentedView.backgroundColor = UIColor.white\n        segmentedView.dataSource = dataSource\n        segmentedView.isContentScrollViewClickTransitionAnimationEnabled = true\n        segmentedView.indicators = [indicator]\n\n        let lineWidth = 1/UIScreen.main.scale\n        let lineLayer = CALayer()\n        lineLayer.backgroundColor = UIColor.lightGray.cgColor\n        lineLayer.frame = CGRect(x: 0, y: segmentedView.bounds.height - lineWidth, width: segmentedView.bounds.width, height: lineWidth)\n        segmentedView.layer.addSublayer(lineLayer)\n\n        pagingView = JXPagingView(delegate: self)\n        let header = GMSAutoRefreshHeader()\n        header.setRefreshingTarget(self, refreshingAction: #selector(defaultTableHeaderRefresh))\n        pagingView.mainTableView.mj_header = header\n        if #available(iOS 15.0, *) &#123;\n            pagingView.mainTableView.sectionHeaderTopPadding = 0\n        &#125; else &#123;\n            // Fallback on earlier ···versions\n        &#125;\n        \n        self.view.addSubview(pagingView)\n\n        segmentedView.listContainer = pagingView.listContainerView\n        \n        self.view.gm_addSubview(stockInitializationTipsView) &#123; make in\n            make.top.equalTo(Height_NavBarAndStatusBar)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(0)\n        &#125;\n        pagingView.snp_makeConstraints &#123; make in\n            make.top.equalTo(stockInitializationTipsView.snp_bottom).offset(0)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(ScreenHeight-Height_NavBarAndStatusBar-Height_TabBar)\n        &#125;\n        \n        /// 待开单列表--取消订单闭包回调\n        self.waitingForBillingVC.cancelBlock = &#123; [weak self] in\n            self?.waitingForBillingVC.requestIntendedOrder()\n        &#125;\n        \n        self.setJXCountBolck()\n        \n        WatermarkView.showWindow()\n    &#125;\n</code></pre>\n<p>这里JXSegmentView主要是标签栏。</p>\n<p>PageView是我们实现这效果的父布局。<br>不出意外，这个PageView里面应该会关联到标签栏。<br>这里有部分代码是这样的：<br><code>segmentedView.listContainer = pagingView.listContainerView</code><br>这里应该就是建立联系了。</p>\n<h3 id=\"3-3-配置代理和数据源\"><a href=\"#3-3-配置代理和数据源\" class=\"headerlink\" title=\"3.3 配置代理和数据源\"></a>3.3 配置代理和数据源</h3><p>前面将delegate设置为self了，所以我们需要看下如何配置的。<br>先看下PageView设置的代理吧：</p>\n<pre><code class=\"line-numbers language-swfit\">extension NewWorkViewController: JXPagingViewDelegate &#123;\n\n    /// tableHeaderView高度\n    func tableHeaderViewHeight(in pagingView: JXPagingView) -&gt; Int &#123;\n        return JXTableHeaderViewHeight\n    &#125;\n\n    /// tableHeaderView\n    func tableHeaderView(in pagingView: JXPagingView) -&gt; UIView &#123;\n        return userHeaderView\n    &#125;\n\n    /// 吸顶标签栏的高度\n    func heightForPinSectionHeader(in pagingView: JXPagingView) -&gt; Int &#123;\n        return JXheightForHeaderInSection\n    &#125;\n\n    /// 吸顶标签栏\n    func viewForPinSectionHeader(in pagingView: JXPagingView) -&gt; UIView &#123;\n        return segmentedView\n    &#125;\n    \n    /// 列表的数量\n    func numberOfLists(in pagingView: JXPagingView) -&gt; Int &#123;\n        return dataSource.attributedTitles.count\n    &#125;\n\n    /// 列表\n    func pagingView(_ pagingView: JXPagingView, initListAtIndex index: Int) -&gt; JXPagingViewListViewDelegate &#123;\n        let flag: WorkListCellItem = self.listDataArray[index]\n        \n        if flag == .waitingBalance &#123;\n            /// 待收讫VC\n            let list = waitingBalanceVC\n            return list\n        &#125;else if flag == .waitingForBilling &#123;\n            /// 待开单VC\n            let list = waitingForBillingVC\n            return list\n        &#125;else if flag == .waitingForDelivery &#123;\n            /// 待送货VC\n            let list = waitingForDeliveryVC\n            return list\n        &#125;else if flag == .waitingForInstallation &#123;\n            /// 待安装VC\n            let list = waitingForInstallationVC\n            return list\n        &#125;else if flag == .outOfWarehouse &#123;\n            /// 待出库VC\n            let list = outOfWarehouseVC\n            return list\n        &#125;else &#123;\n            /// 待入库VC\n            let list = toBeWarehousedVC\n            return list\n        &#125;\n    &#125;\n\n    func mainTableViewDidScroll(_ scrollView: UIScrollView) &#123;\n//        userHeaderView?.scrollViewDidScroll(contentOffsetY: scrollView.contentOffset.y)\n    &#125;\n&#125;\n</code></pre>\n<p>这里配置了头部，高度等。<br>主要的pagingView是需要我们自己实现的，这个就是Tab下方的列表展示了。<br>不出意外这个应该需要继承框架里面的某个View吧。</p>\n<p>我们等下看下waitingForBillingVC吧。</p>\n<p>另外看下标签栏的数据源是怎么设置的：</p>\n<pre><code class=\"line-numbers language-Swift\"> private lazy var dataSource : JXSegmentedTitleAttributeDataSource = &#123;\n        let dataSource = JXSegmentedTitleAttributeDataSource()\n        /// 关闭标签栏等分宽度\n        dataSource.isItemSpacingAverageEnabled = false\n        dataSource.itemSpacing = 0\n        return dataSource\n    &#125;()\n</code></pre>\n<p>这里只是定义了，还需要在需要的地方配置下数据：</p>\n<pre><code class=\"line-numbers language-Swift\">  dataSource.attributedTitles = dataTitles\n  dataSource.selectedAttributedTitles = dataSelectedTitles\n        \n</code></pre>\n<h2 id=\"4-子列表\"><a href=\"#4-子列表\" class=\"headerlink\" title=\"4 子列表\"></a>4 子列表</h2><p>外层框架搭好了，需要看下每个子列表是如何塞进去的。</p>\n<pre><code class=\"line-numbers language-Swift\">// MARK: - 工作台（待开单）\nclass WorkWaitingForBillingVC: AutomaticDimensionTableViewController, JXPagingViewListViewDelegate &#123;\n</code></pre>\n<p>这里其实本质上是一个控制器哦，只是实现了它定义的代理方法即可。<br>这里用了一个我们自己定义的自动高度的控制器，跟这个框架无关哈。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 自动高度 TableView （避免 使用UITableView.automaticDimension 带来的弊端（某些时候 reloadData contentOffSet 会改变 导致闪跳））\n/// 只实现了UITableViewDelegate和高度相关的代理方法，tableview也没有创建，自行按需创建\nclass AutomaticDimensionTableViewController: GMBaseViewController &#123;\n    private var rowHeights = [String: CGFloat]()\n    private var headerHeights = [String: CGFloat]()\n    private var footerHeights = [String: CGFloat]()\n    \n    /// 预估cell高度\n    var rowEstimatedHeight: CGFloat = UITableView.automaticDimension\n    /// 预估header高度\n    var headerEstimatedHeight: CGFloat = 200\n    /// 预估footer高度\n    var footerEstimatedHeight: CGFloat = 200\n\n&#125;\nprivate extension AutomaticDimensionTableViewController &#123;\n    func getRowKeyWithIndexPath(_ indexPath: IndexPath) -&gt; String &#123;\n        let section = indexPath.section\n        let row = indexPath.row\n        let key = &quot;\\(section)-\\(row)&quot;\n        return key\n    &#125;\n&#125;\nextension AutomaticDimensionTableViewController: UITableViewDelegate &#123;\n    func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) &#123;\n        let key = getRowKeyWithIndexPath(indexPath)\n        let height = cell.frame.height\n        rowHeights[key] = height\n    &#125;\n    func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n        let key = getRowKeyWithIndexPath(indexPath)\n        guard let height = rowHeights[key] else &#123; return rowEstimatedHeight &#125;\n        return height\n    &#125;\n    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n        return UITableView.automaticDimension\n    &#125;\n    \n    \n    \n    func tableView(_ tableView: UITableView, willDisplayHeaderView view: UIView, forSection section: Int) &#123;\n        let key = &quot;\\(section)&quot;\n        let height = view.frame.height\n        headerHeights[key] = height\n    &#125;\n    func tableView(_ tableView: UITableView, estimatedHeightForHeaderInSection section: Int) -&gt; CGFloat &#123;\n        let key = &quot;\\(section)&quot;\n        guard let height = headerHeights[key] else &#123; return headerEstimatedHeight &#125;\n        return height\n    &#125;\n    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat &#123;\n        return UITableView.automaticDimension\n    &#125;\n    \n    \n    func tableView(_ tableView: UITableView, willDisplayFooterView view: UIView, forSection section: Int) &#123;\n        let key = &quot;\\(section)&quot;\n        let height = view.frame.height\n        footerHeights[key] = height\n    &#125;\n    func tableView(_ tableView: UITableView, estimatedHeightForFooterInSection section: Int) -&gt; CGFloat &#123;\n        let key = &quot;\\(section)&quot;\n        guard let height = footerHeights[key] else &#123; return footerEstimatedHeight &#125;\n        return height\n    &#125;\n    func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -&gt; CGFloat &#123;\n        return UITableView.automaticDimension\n    &#125;\n&#125;\n</code></pre>\n<p>框架要求的协议需要看下：</p>\n<pre><code class=\"line-numbers language-Swift\">@objc\npublic protocol JXPagingViewListViewDelegate &#123;\n    /// 如果列表是VC，就返回VC.view\n    /// 如果列表是View，就返回View自己\n    ///\n    /// - Returns: 返回列表视图\n    func listView() -&gt; UIView\n    /// 返回listView内部持有的UIScrollView或UITableView或UICollectionView\n    /// 主要用于mainTableView已经显示了header，listView的contentOffset需要重置时，内部需要访问到外部传入进来的listView内的scrollView\n    ///\n    /// - Returns: listView内部持有的UIScrollView或UITableView或UICollectionView\n    func listScrollView() -&gt; UIScrollView\n    /// 当listView内部持有的UIScrollView或UITableView或UICollectionView的代理方法`scrollViewDidScroll`回调时，需要调用该代理方法传入的callback\n    ///\n    /// - Parameter callback: `scrollViewDidScroll`回调时调用的callback\n    func listViewDidScrollCallback(callback: @escaping (UIScrollView)-&gt;())\n\n    /// 将要重置listScrollView的contentOffset\n    @objc optional func listScrollViewWillResetContentOffset()\n    /// 可选实现，列表将要显示的时候调用\n    @objc optional func listWillAppear()\n    /// 可选实现，列表显示的时候调用\n    @objc optional func listDidAppear()\n    /// 可选实现，列表将要消失的时候调用\n    @objc optional func listWillDisappear()\n    /// 可选实现，列表消失的时候调用\n    @objc optional func listDidDisappear()\n&#125;\n</code></pre>\n<p>这里要求我们可以实现这些方法。</p>\n<pre><code class=\"line-numbers language-Swift\">var listViewDidScrollCallback: ((UIScrollView) -&gt; ())?\n    \n    deinit &#123;\n        listViewDidScrollCallback = nil\n    &#125;\n    \n    func listView() -&gt; UIView &#123;\n        return self.view\n    &#125;\n    \n    func listScrollView() -&gt; UIScrollView &#123;\n        return self.mainTableView\n    &#125;\n    \n    func listViewDidScrollCallback(callback: @escaping (UIScrollView) -&gt; ()) &#123;\n        self.listViewDidScrollCallback = callback\n    &#125;\n\n    /// 主列表\n    lazy var mainTableView: UITableView = &#123;\n        let tableView = UITableView(frame: UIScreen.main.bounds, style: .grouped)\n        if #available(iOS 15.0, *) &#123;\n            tableView.sectionHeaderTopPadding = 0\n        &#125; else &#123;\n            // Fallback on earlier ···versions\n        &#125;\n        tableView.separatorStyle = .none\n        tableView.delegate = self\n        tableView.dataSource = self\n        tableView.backgroundColor = .white\n        tableView.showsVerticalScrollIndicator = false\n        tableView.showsHorizontalScrollIndicator = false\n        tableView.tableFooterView = UIView()\n        \n        let footer = GMSAutoRefreshFooter()\n        footer.setRefreshingTarget(self, refreshingAction: #selector(defaultTableFooterRefresh))\n        tableView.mj_footer = footer\n       return tableView\n   &#125;()\n</code></pre>\n<p>这里我们直接把控制的view给他了。<br>这个滚动的视图就是我们自己定义的主列表。</p>\n<p>大致就是这样，使用起来还是简单的。<br>后面有时间再详细看下源码才行。</p>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5 总结\"></a>5 总结</h2><ul>\n<li>本文主要是针对多Tab页，吸顶效果和可分页可滑动的需求，利用一个三方框架完美解决。</li>\n<li>主要通过最外层的JPagingView本质上是UIView来的，设置代理，配置头部区域和中间列表区域显示。通过一个listContainer关联起了标签栏和列表区，这样实现双向交互。</li>\n<li>使用这个框架的工作就是创建这几个View，配置代理，实现代理，最后实现列表的控制器，控制器也需要实现它提供的代理，另外头部也需要我们按照ui要求自己编写即可。</li>\n<li>使用任何一个三方库一定要懂得它的原理，一旦出问题，我们可以游刃而解。</li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_posts/Flutter-学习导航/FlutterDevs.jpeg","slug":"FlutterDevs.jpeg","post":"cldlc01jd000hjhv701s006dg","modified":0,"renderable":0},{"_id":"source/_posts/Flutter-学习导航/Study_Knowledge.jpeg","slug":"Study_Knowledge.jpeg","post":"cldlc01jd000hjhv701s006dg","modified":0,"renderable":0},{"_id":"source/_posts/Flutter-学习导航/blog_520lee_com.jpeg","slug":"blog_520lee_com.jpeg","post":"cldlc01jd000hjhv701s006dg","modified":0,"renderable":0},{"_id":"source/_posts/Android-学习导航/bianchengjingxuan.jpeg","slug":"bianchengjingxuan.jpeg","post":"cldlc01jc000djhv7cg5d54j1","modified":0,"renderable":0},{"_id":"source/_posts/Android-学习导航/carson.jpeg","slug":"carson.jpeg","post":"cldlc01jc000djhv7cg5d54j1","modified":0,"renderable":0},{"_id":"source/_posts/Android-学习导航/guolin.jpeg","slug":"guolin.jpeg","post":"cldlc01jc000djhv7cg5d54j1","modified":0,"renderable":0},{"_id":"source/_posts/Android-学习导航/hongyang.jpeg","slug":"hongyang.jpeg","post":"cldlc01jc000djhv7cg5d54j1","modified":0,"renderable":0},{"_id":"source/_posts/Android-学习导航/jishuquan.jpeg","slug":"jishuquan.jpeg","post":"cldlc01jc000djhv7cg5d54j1","modified":0,"renderable":0},{"_id":"source/_posts/Android-学习导航/jishuzhuanjia.jpeg","slug":"jishuzhuanjia.jpeg","post":"cldlc01jc000djhv7cg5d54j1","modified":0,"renderable":0},{"_id":"source/_posts/Android-学习导航/jsonchao.jpeg","slug":"jsonchao.jpeg","post":"cldlc01jc000djhv7cg5d54j1","modified":0,"renderable":0},{"_id":"source/_posts/Android-学习导航/qunyingzhuan.jpeg","slug":"qunyingzhuan.jpeg","post":"cldlc01jc000djhv7cg5d54j1","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-网络请求二次封装moya/moya1.png","slug":"moya1.png","post":"cldlc01jf000sjhv7afmadpfr","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-数据库realm实践/realm1.png","slug":"realm1.png","post":"cldlc01je000ojhv7367k55xj","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-数据库realm实践/realm2.png","slug":"realm2.png","post":"cldlc01je000ojhv7367k55xj","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-自定义View之步进器/stepper0.png","slug":"stepper0.png","post":"cldlc01jf000tjhv75g6weh8d","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-自定义View之步进器/stepper5.png","slug":"stepper5.png","post":"cldlc01jf000tjhv75g6weh8d","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-自定义View之四级地址/四级地址.gif","slug":"四级地址.gif","post":"cldlc01jg000xjhv7adrn5y1c","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-如何实现扫码功能/scan1.png","slug":"scan1.png","post":"cldlc01je000ljhv72peba6gg","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-如何实现扫码功能/scan2.png","slug":"scan2.png","post":"cldlc01je000ljhv72peba6gg","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-实现简易地图功能/map.png","slug":"map.png","post":"cldlc01jg000zjhv723ul7ueo","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-自定义View之时间选择器/预约日期.png","slug":"预约日期.png","post":"cldlc01jh0013jhv73teadvee","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-自定义View之时间选择器/预约时间.png","slug":"预约时间.png","post":"cldlc01jh0013jhv73teadvee","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-混编Flutter/fluttererror03.png","slug":"fluttererror03.png","post":"cldlc01je000njhv73c3fc29f","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-混编Flutter/fluttererror1.png","slug":"fluttererror1.png","post":"cldlc01je000njhv73c3fc29f","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-混编Flutter/fluttererror2.png","slug":"fluttererror2.png","post":"cldlc01je000njhv73c3fc29f","modified":0,"renderable":0},{"_id":"source/_posts/iOS-学习导航/iOSkaifa.jpeg","slug":"iOSkaifa.jpeg","post":"cldlc01ji0019jhv77umsb56i","modified":0,"renderable":0},{"_id":"source/_posts/iOS-学习导航/mobile_tech_share.jpeg","slug":"mobile_tech_share.jpeg","post":"cldlc01ji0019jhv77umsb56i","modified":0,"renderable":0},{"_id":"source/_posts/玩Android-Compose版本-项目分析/home_item.jpeg","slug":"home_item.jpeg","post":"cldlc01jh0015jhv7627d3biq","modified":0,"renderable":0},{"_id":"source/_posts/玩Android-Compose版本-项目分析/mine.jpeg","slug":"mine.jpeg","post":"cldlc01jh0015jhv7627d3biq","modified":0,"renderable":0},{"_id":"source/_posts/玩Android-Compose版本-项目分析/闪屏页.gif","slug":"闪屏页.gif","post":"cldlc01jh0015jhv7627d3biq","modified":0,"renderable":0},{"_id":"source/_posts/玩Android-Compose版本-项目分析/首页.jpeg","slug":"首页.jpeg","post":"cldlc01jh0015jhv7627d3biq","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-打造TabLayout效果/page1.gif","post":"cldlgycqp0000u6v7bq7sbvuw","slug":"page1.gif","modified":1,"renderable":1},{"_id":"source/_posts/iOS-swift-打造TabLayout效果/segment1.png","post":"cldlgycqp0000u6v7bq7sbvuw","slug":"segment1.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cldlc01j70001jhv7761c3czv","category_id":"cldlc01j90003jhv7c4753cp7","_id":"cldlc01jb000ajhv7ddpn8spt"},{"post_id":"cldlc01jc000bjhv74oll3b8j","category_id":"cldlc01j90003jhv7c4753cp7","_id":"cldlc01jd000ijhv7a0ow07jl"},{"post_id":"cldlc01jc000djhv7cg5d54j1","category_id":"cldlc01j90003jhv7c4753cp7","_id":"cldlc01je000mjhv7fdfifsuf"},{"post_id":"cldlc01jd000fjhv74oxuewn5","category_id":"cldlc01je000jjhv76y883mdh","_id":"cldlc01jf000ujhv742a1boak"},{"post_id":"cldlc01jd000hjhv701s006dg","category_id":"cldlc01jf000pjhv74mmxg8b3","_id":"cldlc01jg0010jhv75zo0d46b"},{"post_id":"cldlc01jg000xjhv7adrn5y1c","category_id":"cldlc01jf000vjhv703m36l4r","_id":"cldlc01jh0016jhv76x1vfcjj"},{"post_id":"cldlc01je000ljhv72peba6gg","category_id":"cldlc01jf000vjhv703m36l4r","_id":"cldlc01ji001ajhv74fxbcb6h"},{"post_id":"cldlc01jg000zjhv723ul7ueo","category_id":"cldlc01jf000vjhv703m36l4r","_id":"cldlc01ji001cjhv77nes7rvw"},{"post_id":"cldlc01jh0013jhv73teadvee","category_id":"cldlc01jf000vjhv703m36l4r","_id":"cldlc01ji001fjhv71z7l4nt9"},{"post_id":"cldlc01je000njhv73c3fc29f","category_id":"cldlc01jf000vjhv703m36l4r","_id":"cldlc01ji001ijhv7dr2i3x6j"},{"post_id":"cldlc01jh0015jhv7627d3biq","category_id":"cldlc01j90003jhv7c4753cp7","_id":"cldlc01jj001kjhv76519bdhk"},{"post_id":"cldlc01ji0019jhv77umsb56i","category_id":"cldlc01jf000vjhv703m36l4r","_id":"cldlc01jj001mjhv787vc5h2t"},{"post_id":"cldlc01je000ojhv7367k55xj","category_id":"cldlc01jf000vjhv703m36l4r","_id":"cldlc01jj001ojhv7fzcmaxr5"},{"post_id":"cldlc01jf000sjhv7afmadpfr","category_id":"cldlc01jf000vjhv703m36l4r","_id":"cldlc01jj001qjhv7gn3zhe3e"},{"post_id":"cldlc01jf000tjhv75g6weh8d","category_id":"cldlc01jf000vjhv703m36l4r","_id":"cldlc01jj001sjhv7fm31hs8g"},{"post_id":"cldlgycqp0000u6v7bq7sbvuw","category_id":"cldlc01jf000vjhv703m36l4r","_id":"cldlgycqt0002u6v73c33bk99"}],"PostTag":[{"post_id":"cldlc01j70001jhv7761c3czv","tag_id":"cldlc01ja0004jhv76ab970lr","_id":"cldlc01ja0008jhv77rvhh6n9"},{"post_id":"cldlc01jc000bjhv74oll3b8j","tag_id":"cldlc01ja0004jhv76ab970lr","_id":"cldlc01jd000ejhv72in93egs"},{"post_id":"cldlc01jc000djhv7cg5d54j1","tag_id":"cldlc01ja0004jhv76ab970lr","_id":"cldlc01jd000gjhv71xagfqkk"},{"post_id":"cldlc01jd000fjhv74oxuewn5","tag_id":"cldlc01je000kjhv7hiyx05uj","_id":"cldlc01jf000rjhv7gags2ult"},{"post_id":"cldlc01jd000hjhv701s006dg","tag_id":"cldlc01jf000qjhv7h2qm137b","_id":"cldlc01jg000yjhv774xoe4us"},{"post_id":"cldlc01je000ljhv72peba6gg","tag_id":"cldlc01jg000wjhv7aslldh8t","_id":"cldlc01jh0014jhv705y46kr2"},{"post_id":"cldlc01je000njhv73c3fc29f","tag_id":"cldlc01jg0012jhv72vjh8b84","_id":"cldlc01ji001bjhv70iqn4qcr"},{"post_id":"cldlc01jh0015jhv7627d3biq","tag_id":"cldlc01ja0004jhv76ab970lr","_id":"cldlc01ji001ejhv70id6ahqo"},{"post_id":"cldlc01je000ojhv7367k55xj","tag_id":"cldlc01ji0018jhv72r5e2z33","_id":"cldlc01ji001hjhv7ao98ajsc"},{"post_id":"cldlc01jf000sjhv7afmadpfr","tag_id":"cldlc01ji001gjhv7eekq3vhd","_id":"cldlc01jj001njhv70bpb2zkz"},{"post_id":"cldlc01jf000tjhv75g6weh8d","tag_id":"cldlc01jj001ljhv7hub18trj","_id":"cldlc01jj001rjhv77op58mbx"},{"post_id":"cldlc01jg000xjhv7adrn5y1c","tag_id":"cldlc01jj001ljhv7hub18trj","_id":"cldlc01jj001ujhv7a2fd9be6"},{"post_id":"cldlc01jg000zjhv723ul7ueo","tag_id":"cldlc01jj001tjhv73t1qhaq8","_id":"cldlc01jj001wjhv77zj51cfj"},{"post_id":"cldlc01jh0013jhv73teadvee","tag_id":"cldlc01jj001ljhv7hub18trj","_id":"cldlc01jj001yjhv7gkh79r59"},{"post_id":"cldlc01ji0019jhv77umsb56i","tag_id":"cldlc01jj001xjhv7fg8714at","_id":"cldlc01jj001zjhv73nufehh1"},{"post_id":"cldlgycqp0000u6v7bq7sbvuw","tag_id":"cldlgycqr0001u6v7476lar7o","_id":"cldlgycqt0003u6v7b440dmi4"}],"Tag":[{"name":"Android","_id":"cldlc01ja0004jhv76ab970lr"},{"name":"博客","_id":"cldlc01je000kjhv7hiyx05uj"},{"name":"Flutter","_id":"cldlc01jf000qjhv7h2qm137b"},{"name":"条形码识别 相机","_id":"cldlc01jg000wjhv7aslldh8t"},{"name":"混编Flutter","_id":"cldlc01jg0012jhv72vjh8b84"},{"name":"数据库 iOS","_id":"cldlc01ji0018jhv72r5e2z33"},{"name":"网络请求","_id":"cldlc01ji001gjhv7eekq3vhd"},{"name":"iOS 自定义View","_id":"cldlc01jj001ljhv7hub18trj"},{"name":"地图","_id":"cldlc01jj001tjhv73t1qhaq8"},{"name":"iOS","_id":"cldlc01jj001xjhv7fg8714at"},{"name":"TabLayout","_id":"cldlgycqr0001u6v7476lar7o"}]}}