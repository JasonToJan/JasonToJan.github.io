{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/matery/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/matery/source/css/gitment.css","path":"css/gitment.css","modified":0,"renderable":1},{"_id":"themes/matery/source/css/my.css","path":"css/my.css","modified":0,"renderable":1},{"_id":"themes/matery/source/css/prism.css","path":"css/prism.css","modified":0,"renderable":1},{"_id":"themes/matery/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":0,"renderable":1},{"_id":"themes/matery/source/js/matery.js","path":"js/matery.js","modified":0,"renderable":1},{"_id":"themes/matery/source/css/matery.css","path":"css/matery.css","modified":0,"renderable":1},{"_id":"themes/matery/source/js/prism.js","path":"js/prism.js","modified":0,"renderable":1},{"_id":"themes/matery/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/gzh.jpg","path":"medias/gzh.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/contact.jpg","path":"medias/contact.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/logo.png","path":"medias/logo.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/19.jpg","path":"medias/featureimages/19.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/24.jpg","path":"medias/featureimages/24.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/25.jpg","path":"medias/featureimages/25.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/26.jpg","path":"medias/featureimages/26.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/27.jpg","path":"medias/featureimages/27.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/28.jpg","path":"medias/featureimages/28.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/0xbird.png","path":"medias/avatars/0xbird.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/ajin.jpg","path":"medias/avatars/ajin.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/antnlp.ico","path":"medias/avatars/antnlp.ico","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/avatar.jpg","path":"medias/avatars/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/babyq.png","path":"medias/avatars/babyq.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/bytedtrans.png","path":"medias/avatars/bytedtrans.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/cww97.jpg","path":"medias/avatars/cww97.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/duyupei.jpg","path":"medias/avatars/duyupei.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/feibar.jpg","path":"medias/avatars/feibar.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/feibar.png","path":"medias/avatars/feibar.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/fun4go.png","path":"medias/avatars/fun4go.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/gsy.jpg","path":"medias/avatars/gsy.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/hael.jpg","path":"medias/avatars/hael.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/huaji.jpg","path":"medias/avatars/huaji.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/hzwer.jpg","path":"medias/avatars/hzwer.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/ids2.jpg","path":"medias/avatars/ids2.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/jiejie.jpg","path":"medias/avatars/jiejie.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/jingjing.jpg","path":"medias/avatars/jingjing.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/jitao.jpg","path":"medias/avatars/jitao.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/kewlgrl.jpg","path":"medias/avatars/kewlgrl.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/ldy.jpg","path":"medias/avatars/ldy.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/lijiaqian.png","path":"medias/avatars/lijiaqian.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/liyangzone.jpg","path":"medias/avatars/liyangzone.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/liyucheng.jpg","path":"medias/avatars/liyucheng.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/lyn-draw.jpg","path":"medias/avatars/lyn-draw.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/lzh.png","path":"medias/avatars/lzh.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mashiro.jpg","path":"medias/avatars/mashiro.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/masterx.jpg","path":"medias/avatars/masterx.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/michael.jpg","path":"medias/avatars/michael.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/milyyy.jpg","path":"medias/avatars/milyyy.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mouse.jpg","path":"medias/avatars/mouse.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mpy634.png","path":"medias/avatars/mpy634.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/myzhihu.png","path":"medias/avatars/myzhihu.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/qiandongwei.jpg","path":"medias/avatars/qiandongwei.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/qianqian.png","path":"medias/avatars/qianqian.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/qiqiang.jpg","path":"medias/avatars/qiqiang.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/spacesac.png","path":"medias/avatars/spacesac.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/sunchangzhi.jpg","path":"medias/avatars/sunchangzhi.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mizunashi.png","path":"medias/avatars/mizunashi.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/taowei.jpg","path":"medias/avatars/taowei.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/tawn.jpg","path":"medias/avatars/tawn.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/taotao.jpg","path":"medias/avatars/taotao.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/xuzhongyou.jpg","path":"medias/avatars/xuzhongyou.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/yezijie.png","path":"medias/avatars/yezijie.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/zhangting.jpg","path":"medias/avatars/zhangting.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/zhangyi.jpg","path":"medias/avatars/zhangyi.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/zhaokangzhe.jpg","path":"medias/avatars/zhaokangzhe.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/zzw.jpg","path":"medias/avatars/zzw.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/xiejiadong.jpg","path":"medias/avatars/xiejiadong.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/files/cv-en.pdf","path":"medias/files/cv-en.pdf","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/files/cv-zh.pdf","path":"medias/files/cv-zh.pdf","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/clipboard.min.js","path":"libs/codeBlock/clipboard.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeBlockFuction.js","path":"libs/codeBlock/codeBlockFuction.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeCopy.js","path":"libs/codeBlock/codeCopy.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeLang.js","path":"libs/codeBlock/codeLang.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeShrink.js","path":"libs/codeBlock/codeShrink.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/reward/alipay.png","path":"medias/reward/alipay.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/reward/wechat.png","path":"medias/reward/wechat.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","path":"libs/jquery/jquery-2.2.0.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/explosion.min.js","path":"libs/others/explosion.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/fireworks.js","path":"libs/others/fireworks.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/snow.js","path":"libs/others/snow.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/text.js","path":"libs/others/text.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/daoshu.jpg","path":"medias/music/avatars/daoshu.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/tiantangdemogui.jpg","path":"medias/music/avatars/tiantangdemogui.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/yequ.jpg","path":"medias/music/avatars/yequ.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/yiluxiangbei.jpg","path":"medias/music/avatars/yiluxiangbei.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","path":"libs/awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","path":"libs/awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","path":"libs/awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","path":"libs/awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","path":"libs/awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","path":"libs/awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","path":"libs/awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"5e8a7aad69a8e5e79479ea54733cb096611eec47","modified":1675231576183},{"_id":"source/404.md","hash":"d97f69ff63501de89cfd341c68e4d6ed5c8a5b3a","modified":1675231576183},{"_id":"source/.DS_Store","hash":"9244f4d58527a5d3f332cc052a9bdab6729e1ac4","modified":1675561268627},{"_id":"source/_data/musics.json","hash":"32bc061f34721b4ff55f880de1d0ec5787acd2f9","modified":1675231576183},{"_id":"source/_posts/.DS_Store","hash":"757d1c5786db86eec377784d5cdd82537a891243","modified":1675422851332},{"_id":"source/_data/friends.json","hash":"e4c6253b684af89a656c9ce5440ed5c405d6421d","modified":1675231576183},{"_id":"source/_posts/5w2h-godweiyang.md","hash":"39f3fdf4266cacc879de004c99fb06a0b3ed6966","modified":1675231576183},{"_id":"source/_posts/Android-学习导航.md","hash":"d24fb0d452cda604a6bdcf412e300042c6ee7ec5","modified":1675756034186},{"_id":"source/_posts/Android-google-samples-nowinandroid-app模块流程分析.md","hash":"32c010b182b4d4d8367e2d2be569d99a40302496","modified":1675235836379},{"_id":"source/_posts/Android-gradle相关-KTS脚本-项目配置改造.md","hash":"aefaf7855c49ebea6bedd9e2f553debc937a2b01","modified":1675235836380},{"_id":"source/_posts/iOS-swift-如何实现扫码功能.md","hash":"86e86c10c40a6d6d94df84991d53b0af280f332c","modified":1675235836380},{"_id":"source/_posts/Flutter-学习导航.md","hash":"affc9ef62d42fc21a16aebedff79004a428e410b","modified":1675232014855},{"_id":"source/_posts/iOS-swift-实现简易地图功能.md","hash":"a889276cd33e25df2c876a6269be5b1a210aac45","modified":1675235836380},{"_id":"source/_posts/iOS-swift-数据库realm实践.md","hash":"90d6f365c0f0546a22e61c6dc3998a025839bf2e","modified":1675235836381},{"_id":"source/_posts/iOS-swift-混编Flutter.md","hash":"0ab1b7b00aad9a3a3416549c68b698047463f58a","modified":1675235836381},{"_id":"source/_posts/iOS-swift-打造TabLayout效果.md","hash":"55bd936520baf196e4a50ca98a1fde52f4fa494b","modified":1675244670450},{"_id":"source/_posts/iOS-swift-网络请求二次封装moya.md","hash":"46af2af92e67d79a53596d54063c3fa3b6b766b6","modified":1675235836381},{"_id":"source/_posts/iOS-swift-自定义View之四级地址.md","hash":"b84cad50954f62a4e2db17212605b0a2fc703978","modified":1675235836382},{"_id":"source/_posts/iOS-swift-自定义View之时间选择器.md","hash":"eeb0134cdbe13a321ef3fdf65b5166f0d45893f9","modified":1675235836382},{"_id":"source/about/index.md","hash":"244c65942bf4533fefd227f28d7044e82ccb7091","modified":1675232014882},{"_id":"source/archives/index.md","hash":"4ac0f3011941b36c1edb8fc2fdb4738ea5da3fa0","modified":1675231576249},{"_id":"source/contact/index.md","hash":"6ebabb170c2cc0447ca6b153aea573ea436c595a","modified":1675231576249},{"_id":"source/_posts/玩Android-Compose版本-项目分析.md","hash":"b5dd8006cadb89d2e67f6d8fbb3b61221ef9b85d","modified":1675235836383},{"_id":"source/_posts/iOS-swift-自定义View之步进器.md","hash":"a192b25f128aeb263fa41ceeb81b5958922560a0","modified":1675235836383},{"_id":"source/friends/index.md","hash":"405a0f5a74a01af8c4447f5bf325492bd7606cb8","modified":1675231576250},{"_id":"source/categories/index.md","hash":"3e265a72178e02c03be39ec4d5751ad9d098dea2","modified":1675231576249},{"_id":"source/_posts/iOS-学习导航.md","hash":"bfa4ebe4c15c501598d96870076e887efcdd838b","modified":1675669085623},{"_id":"source/tags/index.md","hash":"bd116296d4685772c75cec439845019e95a4f836","modified":1675231576250},{"_id":"source/_posts/Android-学习导航/guolin.jpeg","hash":"637e479009efdec579986fbe8eb5eacc9e46932e","modified":1675232014853},{"_id":"source/_posts/Android-学习导航/hongyang.jpeg","hash":"6d414b2f8a29459ed52f4a7d1714441074d85f42","modified":1675232014853},{"_id":"source/_posts/Android-学习导航/jishuzhuanjia.jpeg","hash":"a9036689bffb0d31e44ca4c691a79b30893b97ac","modified":1675232014854},{"_id":"source/_posts/Android-学习导航/carson.jpeg","hash":"40635ad0a930abcc74b1e2eec760cb44cfc477f8","modified":1675232014853},{"_id":"source/_posts/Android-学习导航/jishuquan.jpeg","hash":"7597cde9db6040f80064ab5c397ad40394c2c068","modified":1675232014854},{"_id":"source/_posts/Flutter-学习导航/FlutterDevs.jpeg","hash":"f99339d77b2943ce258ccc86d1347d666b72920c","modified":1675232014855},{"_id":"source/_posts/Android-学习导航/jsonchao.jpeg","hash":"e476402b268490d72534f55cfa9d23b9be43f566","modified":1675232014854},{"_id":"source/_posts/Android-学习导航/bianchengjingxuan.jpeg","hash":"f6fb1d9014d3745473e188380216cef5bae7da92","modified":1675232014852},{"_id":"source/_posts/Flutter-学习导航/Study_Knowledge.jpeg","hash":"ed1d63d25a4136faca1b8a6d6c3da1ef3413720b","modified":1675232014856},{"_id":"source/_posts/Flutter-学习导航/blog_520lee_com.jpeg","hash":"55ca5b424bbe29efce36afdd29b702250d988875","modified":1675232014856},{"_id":"source/_posts/Android-学习导航/qunyingzhuan.jpeg","hash":"203453e7a2f5ec4b3ab6b9d643a1a8882ec528be","modified":1675232014855},{"_id":"source/_posts/iOS-swift-自定义View之步进器/stepper5.png","hash":"4f77bd25aaec9a33753d84c2205feb7642e40284","modified":1675232014881},{"_id":"source/_posts/iOS-学习导航/iOSkaifa.jpeg","hash":"a5478eb61474efe19ac6abc28a427d7096c749e8","modified":1675232014882},{"_id":"source/_posts/iOS-学习导航/mobile_tech_share.jpeg","hash":"90b55e26b096ae716f8074096ac48b2b1290c852","modified":1675232014882},{"_id":"source/_posts/玩Android-Compose版本-项目分析/home_item.jpeg","hash":"ee18c76cc19ffc9653309fb22c5db4be8abe6694","modified":1675231576225},{"_id":"source/_posts/iOS-swift-自定义View之步进器/stepper0.png","hash":"ebc88bb13e0f6168189228b613a0dd41f73882d2","modified":1675232014881},{"_id":"source/_posts/iOS-swift-自定义View之时间选择器/预约时间.png","hash":"062fd52e9f09f9a482ac57796c4bf8b347d7da86","modified":1675232014881},{"_id":"source/_posts/iOS-swift-打造TabLayout效果/segment1.png","hash":"f671c195de1774e1531ba0311e55c03592fef431","modified":1675244356989},{"_id":"source/_posts/iOS-swift-自定义View之时间选择器/预约日期.png","hash":"dedd941735c71b5f1bd3a1471e180c409b47ffe7","modified":1675232014880},{"_id":"source/_posts/iOS-swift-混编Flutter/fluttererror1.png","hash":"144e586ff60c31f455e3edd250f8e3fc4950b5d0","modified":1675232849748},{"_id":"themes/matery/README.md","hash":"7ef16198a2c5ff580f006582286354caf160c7fe","modified":1675231576250},{"_id":"themes/matery/LICENSE","hash":"b314c7ebb7d599944981908b7f3ed33a30e78f3a","modified":1675231576250},{"_id":"themes/matery/layout/404.ejs","hash":"f08a0f507b36f3652520a41381f71167488405c7","modified":1675231576250},{"_id":"themes/matery/.gitignore","hash":"eaa3d84cb77d92a21b111fd1e37f53edc1ff9de0","modified":1675231576250},{"_id":"themes/matery/layout/archive.ejs","hash":"1b5023571894404d75caffa28128fc9c49f9095d","modified":1675231576253},{"_id":"themes/matery/layout/about.ejs","hash":"e87752e59f021b5139b1155a264da11ab469a9aa","modified":1675231576253},{"_id":"themes/matery/layout/categories.ejs","hash":"c431e772d0f7700592228bbd9502793bdc28a893","modified":1675231576253},{"_id":"themes/matery/_config.yml","hash":"fbf93c989eba69ae89dd67a155cb589611345f71","modified":1675232014883},{"_id":"themes/matery/layout/category.ejs","hash":"2d421e10c3b8fd2c4f725e5eaa967c4a1429c707","modified":1675231576253},{"_id":"themes/matery/layout/index.ejs","hash":"7fc5a6c4f0229c0be43b7d1315524c468346fbb8","modified":1675231576253},{"_id":"themes/matery/layout/friends.ejs","hash":"895e40a864796680fbef581e4b09f252fbdd963a","modified":1675231576253},{"_id":"themes/matery/layout/post.ejs","hash":"f1a35f32e5901e167ae9a750e7cb3635549cea2e","modified":1675231576253},{"_id":"themes/matery/layout/tag.ejs","hash":"5cdf3a1d72f54285ee9cb826fd0e4a0449093215","modified":1675231576253},{"_id":"themes/matery/layout/layout.ejs","hash":"2ba4110dc596424b1220a259c8e594da774e7f59","modified":1675231576253},{"_id":"themes/matery/layout/tags.ejs","hash":"851c0ee599e91e7b1d657673859e8b6ff79cf50b","modified":1675231576253},{"_id":"themes/matery/layout/contact.ejs","hash":"1513c5a40b7cc0b6e5854cf8c3253958bcb486cb","modified":1675231576253},{"_id":"themes/matery/languages/zh-CN.yml","hash":"d92db4b986bb6f0d228e9a8249383103bf56342d","modified":1675231576250},{"_id":"themes/matery/languages/default.yml","hash":"527c795b8c41fe62bf35603ffebfa6d4a7929a2c","modified":1675231576250},{"_id":"themes/matery/README_CN.md","hash":"a94324950e0299bcfcbc106cf2ca65c93e1fe843","modified":1675231576250},{"_id":"themes/matery/layout/_partial/bg-cover-content.ejs","hash":"ab610754bf6aea844b5ae0802ed37c73b5f1dc9f","modified":1675231576251},{"_id":"themes/matery/layout/_partial/back-top.ejs","hash":"cb99dc352397ec5d0765794d7b8884972e61973b","modified":1675231576251},{"_id":"themes/matery/layout/_partial/disqus.ejs","hash":"42dda8e67f7f09d148347887e52f18aea546df26","modified":1675231576251},{"_id":"themes/matery/layout/_partial/gitalk.ejs","hash":"a3a140e6aeeb6f289e4b821a577ef548267f3de1","modified":1675231576251},{"_id":"themes/matery/layout/_partial/gitment.ejs","hash":"d8c40dbc8106b5bc53ceb727ad968c1d8f234261","modified":1675231576251},{"_id":"themes/matery/source/favicon.png","hash":"0f4145b9a712f9662e4fae1b0086ce74cf1f9fc4","modified":1675231576254},{"_id":"themes/matery/layout/_partial/header.ejs","hash":"821e1af65990521c9e0288178d8e5b18c73a9cab","modified":1675231576251},{"_id":"themes/matery/layout/_partial/github-link.ejs","hash":"fd4034bca2eb3987dcf113e6477260bee97eb1e7","modified":1675231576251},{"_id":"themes/matery/layout/_partial/head.ejs","hash":"fb572df037b5a6eb563912caa1f1967ca835a70a","modified":1675231576251},{"_id":"themes/matery/layout/_partial/livere.ejs","hash":"42728561c09589f79b698eb059ab4def53ed3642","modified":1675231576251},{"_id":"themes/matery/layout/_partial/mobile-nav.ejs","hash":"e761f0104fbf431671bbe6bebc91ca82f737f4d2","modified":1675231576251},{"_id":"themes/matery/layout/_partial/bg-cover.ejs","hash":"d5a7b9bb96e04c0a3485dd873748f19c50a6a04f","modified":1675231576251},{"_id":"themes/matery/layout/_partial/paging.ejs","hash":"dfdeea9c59d157acb851d4bf44bf95f81787523c","modified":1675231576251},{"_id":"themes/matery/layout/_partial/google-analytics.ejs","hash":"890c8f04c1f4905dfceb3ea9fd6efdd040d79c01","modified":1675231576251},{"_id":"themes/matery/layout/_partial/footer.ejs","hash":"bf685ae08a225b3dbf7acdfd0291a7c271ced985","modified":1675235836383},{"_id":"themes/matery/layout/_partial/index-cover.ejs","hash":"d4042e5521ceb5f3255cd4455ac7ccd227fee6df","modified":1675231576251},{"_id":"themes/matery/layout/_partial/post-cover.ejs","hash":"166c0b9753f3f913bd801e82ad5b268004be198d","modified":1675231576251},{"_id":"themes/matery/layout/_partial/post-detail.ejs","hash":"3f208f33e4e12becdb8323e6e64e20ad60c3fb2a","modified":1675231576252},{"_id":"themes/matery/layout/_partial/post-detail-toc.ejs","hash":"82cb8090cde663fa7ad67418a802997b3057e957","modified":1675231576252},{"_id":"themes/matery/layout/_partial/post-statis.ejs","hash":"3b42900247d5ea4ea5b68e2be44420a0d54785ad","modified":1675231576252},{"_id":"themes/matery/layout/_partial/prev-next.ejs","hash":"4e73f10eacb5d00a0681cb44fe5c039cd8ab03cd","modified":1675231576252},{"_id":"themes/matery/layout/_partial/reward.ejs","hash":"73624d9db81e87ff0c12310bb873fbd0b5221021","modified":1675231576252},{"_id":"themes/matery/layout/_partial/share.ejs","hash":"0f2e1e27d21492cf228e786daead985b1e1dcea4","modified":1675231576252},{"_id":"themes/matery/layout/_partial/navigation.ejs","hash":"3a82fcb6f31d69971cb564985842c14ac02cdca0","modified":1675231576251},{"_id":"themes/matery/layout/_partial/social-link.ejs","hash":"e2865b3003ec07892e9112692e7ec786ee926ae8","modified":1675231576252},{"_id":"themes/matery/layout/_partial/valine.ejs","hash":"c3039180ddb2eb17e724b8441e5f93e79859aef7","modified":1675231576252},{"_id":"themes/matery/layout/_widget/category-radar.ejs","hash":"5284712d84bbaa4f0d88026ac3ec5a8c13e00056","modified":1675231576252},{"_id":"themes/matery/layout/_widget/my-gallery.ejs","hash":"9ea672db65f1e5b8fad1ffafb1614f25adc97e63","modified":1675231576252},{"_id":"themes/matery/layout/_widget/dream.ejs","hash":"6ae58a57b83a5999d0b6a737ec868f084d208f89","modified":1675231576252},{"_id":"themes/matery/layout/_partial/search.ejs","hash":"e859fe6e0259e0c123cb7ceda6e4cac836318ffc","modified":1675231576252},{"_id":"themes/matery/layout/_partial/reprint-statement.ejs","hash":"f85a222ec3f9bc27eb7978015e63a16514b38791","modified":1675231576252},{"_id":"themes/matery/layout/_widget/my-skills.ejs","hash":"c6f713316ce75ad08ac5d1587bd8ce42e894e9ae","modified":1675231576252},{"_id":"themes/matery/layout/_widget/music.ejs","hash":"fc50cb4bbc1f4d0e4c9f5941f1c3c74bea742db7","modified":1675231576252},{"_id":"themes/matery/layout/_widget/category-cloud.ejs","hash":"b2b22d4fc4e46b051f67216c391f629f4ff552b5","modified":1675231576252},{"_id":"themes/matery/layout/_widget/my-projects.ejs","hash":"785cb588a31215876f6737213054ba0e8552fff0","modified":1675231576252},{"_id":"themes/matery/layout/_widget/post-calendar.ejs","hash":"4608af6151f0e32f668c89f09343748340021478","modified":1675231576253},{"_id":"themes/matery/layout/_widget/post-charts.ejs","hash":"0aaf0a111b9aa07ff37f6286eeac5506283f47f8","modified":1675231576253},{"_id":"themes/matery/layout/_widget/tag-cloud.ejs","hash":"6310903eb0e434d6f9a59ca669aab7fae38d4797","modified":1675231576253},{"_id":"themes/matery/source/css/gitment.css","hash":"d5ef623065d1fbc897119f7b70ccf7563e329917","modified":1675231576254},{"_id":"themes/matery/layout/_widget/recommend.ejs","hash":"d439d86818de179d64965d4f7f5fa56147fd9221","modified":1675231576253},{"_id":"themes/matery/source/css/my.css","hash":"37683a9f11c68903a53e2b8593ca8c095a721896","modified":1675231576254},{"_id":"themes/matery/layout/_widget/video.ejs","hash":"05f5e2acace5730cdf7bed650375ad88f6b5d1b7","modified":1675231576253},{"_id":"themes/matery/layout/_widget/tag-wordcloud.ejs","hash":"bf604fe9c435f0fb9a559cac9c35772579b590e8","modified":1675231576253},{"_id":"themes/matery/source/css/my-gitalk.css","hash":"4e3e855767ac5a48b13af1d6a42df13d8975e03f","modified":1675231576254},{"_id":"themes/matery/source/css/prism.css","hash":"163e7764ec6f65f1be8fac7b4a75088b79407ed2","modified":1675235836383},{"_id":"themes/matery/source/js/search.js","hash":"77ecae23dd3edd8ad962c5b12954652bb2f7a1b6","modified":1675231576255},{"_id":"themes/matery/source/js/prism.js","hash":"dd2c2a445f8fda202c69a1a8906e7563583a7a25","modified":1675235836384},{"_id":"themes/matery/source/js/matery.js","hash":"208b7806caa943c115aa0825c9c72a0781404775","modified":1675231576255},{"_id":"themes/matery/source/css/matery.css","hash":"0d345a72318fd7aadcb6fcaa6f3abac94b91001c","modified":1675231576254},{"_id":"themes/matery/source/medias/logo.png","hash":"ee16e748bc0961b84ed544a3c041aa9c19b95948","modified":1675231576353},{"_id":"themes/matery/source/medias/featureimages/0.jpg","hash":"1f8bbfbd625448b4b2a748b75636e456b826dcd3","modified":1675231576298},{"_id":"themes/matery/source/medias/featureimages/5.jpg","hash":"c4cc724f4572a9bcede7443a4f4c0393d3073868","modified":1675231576337},{"_id":"themes/matery/source/medias/avatars/ajin.jpg","hash":"76cb8e872472ff47a1b061c3bcff1c03f30c02b8","modified":1675231576273},{"_id":"themes/matery/source/medias/avatars/avatar.jpg","hash":"f92b165327d79aacc2fde2880745f80e4ca3d9e1","modified":1675231576274},{"_id":"themes/matery/source/medias/avatars/feibar.jpg","hash":"343f47cb5c83cd866a1c824cbe2a112d02516d06","modified":1675231576275},{"_id":"themes/matery/source/medias/avatars/babyq.png","hash":"be5432588003e5a52c02e690622eec72b5f7346c","modified":1675231576274},{"_id":"themes/matery/source/medias/avatars/cww97.jpg","hash":"6af987cafc55d8d031534dd5e0f722fff19f70ec","modified":1675231576274},{"_id":"themes/matery/source/medias/avatars/fun4go.png","hash":"0f4333973a972a629cfbabf601bc7c192b65376c","modified":1675231576277},{"_id":"themes/matery/source/medias/avatars/hzwer.jpg","hash":"53a66bb5e65d2abd5b7412edf094c1e0b1094492","modified":1675231576277},{"_id":"themes/matery/source/medias/avatars/hael.jpg","hash":"e66ccedab38bb2e8fc45fac024e234ab8e7b9d54","modified":1675231576277},{"_id":"themes/matery/source/medias/avatars/huaji.jpg","hash":"86be7eed2a491455ccfe3e7da46366ff477765ca","modified":1675231576277},{"_id":"themes/matery/source/medias/avatars/ldy.jpg","hash":"906ef214d1f2fe52a663738340ad5623f826bd82","modified":1675231576280},{"_id":"themes/matery/source/medias/avatars/kewlgrl.jpg","hash":"3af0fd1029a1511bb3c0e90871e41b35e714b01f","modified":1675231576279},{"_id":"themes/matery/source/medias/avatars/liyangzone.jpg","hash":"febab557e4c0d859ab4cc14b57d8106f5e3fccfb","modified":1675231576281},{"_id":"themes/matery/source/medias/avatars/lijiaqian.png","hash":"9d96b3838acfae9a23b6e290fcfafceff0419c63","modified":1675231576281},{"_id":"themes/matery/source/medias/avatars/liyucheng.jpg","hash":"12055a27fa667c87d2319475968056e1a8ad0f08","modified":1675231576281},{"_id":"themes/matery/source/medias/avatars/ids2.jpg","hash":"2c8d3ac6ab5ac6196bac83766fde975daca91c32","modified":1675231576278},{"_id":"themes/matery/source/medias/avatars/masterx.jpg","hash":"c9f7e83d895fa241cefd6e742f356106b35f1b89","modified":1675231576283},{"_id":"themes/matery/source/medias/avatars/michael.jpg","hash":"331a2ab20c299196f5a3089b8445fc8f55346cb6","modified":1675231576284},{"_id":"themes/matery/source/medias/avatars/mpy634.png","hash":"30f88e09c02b37c2dc684d4ee3237e327bb23f8b","modified":1675231576285},{"_id":"themes/matery/source/medias/avatars/mouse.jpg","hash":"2eae273885b9859150a1f98f74b3df12ca9a207c","modified":1675231576285},{"_id":"themes/matery/source/medias/avatars/qiqiang.jpg","hash":"081459866f922d9558a88cd4d7155d91fa730322","modified":1675231576286},{"_id":"themes/matery/source/medias/avatars/spacesac.png","hash":"ff1bdb058f1f0499312da1a082ba97d78590db1a","modified":1675231576287},{"_id":"themes/matery/source/medias/avatars/sunchangzhi.jpg","hash":"bbe2a15fd474ab62dbd14fea72deb1113a4fb005","modified":1675231576287},{"_id":"themes/matery/source/medias/avatars/taowei.jpg","hash":"e58b03b70656aa7a27238be38dac3896d9d16f10","modified":1675231576287},{"_id":"themes/matery/source/medias/avatars/tawn.jpg","hash":"68a1cbacbb2370912b000c9d8d2b16196c918a50","modified":1675231576287},{"_id":"themes/matery/source/medias/avatars/taotao.jpg","hash":"e668254375ddd40a684ff4669c3421851bebd36e","modified":1675231576287},{"_id":"themes/matery/source/medias/avatars/yezijie.png","hash":"8a53537eb69f749115e512b6da061e7f23cd04e5","modified":1675231576288},{"_id":"themes/matery/source/medias/avatars/zhaokangzhe.jpg","hash":"c8242bd13f08a9ddb97e26f216bc729b12ed9058","modified":1675231576290},{"_id":"themes/matery/source/medias/files/cv-en.pdf","hash":"2a62ab3797f8bc8e2e5e04c4950198525c635139","modified":1675231576351},{"_id":"themes/matery/source/libs/animate/animate.min.css","hash":"5dfcbcee866e9dc564916416281885f3e320871e","modified":1675231576255},{"_id":"themes/matery/source/libs/aos/aos.css","hash":"ded9739f803d114c9168d3351fded72b3b478b4c","modified":1675231576255},{"_id":"themes/matery/source/libs/codeBlock/codeCopy.js","hash":"b74a381adf6ef8404d6a0452c2b9f44b47219c80","modified":1675231576261},{"_id":"themes/matery/source/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1675231576261},{"_id":"themes/matery/source/libs/codeBlock/clipboard.min.js","hash":"9cd57c67fbd3e3067f80793ef8445f5ff7783563","modified":1675231576261},{"_id":"themes/matery/source/libs/codeBlock/codeShrink.js","hash":"215910dc8f63fd50b97957e5fcdc8480aa2728cb","modified":1675231576262},{"_id":"themes/matery/source/libs/codeBlock/codeLang.js","hash":"ea8b51e4d75e7b2cd63e4d5bcb8db2cf7f23f5db","modified":1675231576261},{"_id":"themes/matery/source/libs/aos/aos.js","hash":"5a8e6d07ffa55642418ab3fd4b263aa08284b77a","modified":1675231576255},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","hash":"33810b2b757fc4327bc1d3b83bb5e0d3dc1fec5b","modified":1675231576262},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","hash":"7f4f8913f2d46ade2def5134e2cc8684a4b87939","modified":1675231576255},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","hash":"70c0c4a9bf698747b7c058c21287ad617355e5dd","modified":1675231576256},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","hash":"5d52d3b34fceb9d7e11f1beaf7ed380b4249dec4","modified":1675231576262},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","hash":"a0625d8b432af8bdc820f8768d36cde439e7257c","modified":1675231576266},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","hash":"4e6538c8312aeeab845d361c37a8c1a0931241f0","modified":1675231576267},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"26849509f196a2d21bbfd15696e5d5153163b8f1","modified":1675231576267},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","hash":"021898a16279ac2ffe75af4f902fab2a0a39f11a","modified":1675231576266},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","hash":"f646f2bb75bcd1eb65b2788ac7bf15d4fd243ce9","modified":1675231576271},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","hash":"f81cd7bfcf7aa2d043bd3e6077df42656fc44b82","modified":1675231576269},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1675231576270},{"_id":"themes/matery/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1675231576270},{"_id":"themes/matery/source/libs/others/text.js","hash":"1791782cde0d1e4197f2ed58ecb7dd6aefddd169","modified":1675231576270},{"_id":"themes/matery/source/libs/others/explosion.min.js","hash":"417b68e2cf2c6de2119c57626f4412105a8457f5","modified":1675231576270},{"_id":"themes/matery/source/libs/others/snow.js","hash":"b393f069781eef788a0ae66b2681cece8fea2851","modified":1675231576270},{"_id":"themes/matery/source/libs/others/fireworks.js","hash":"53981959bc6def4a85bbbb41b07e4b1474a2124d","modified":1675231576270},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1675231576270},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1675231576271},{"_id":"themes/matery/source/medias/music/avatars/tiantangdemogui.jpg","hash":"f005578ddb4d3d731838db89a708f39f18d50e60","modified":1675231576354},{"_id":"themes/matery/source/medias/music/avatars/yequ.jpg","hash":"103beb9ab33434b434fa37a30aecdb29db633024","modified":1675231576355},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1675231576256},{"_id":"themes/matery/source/medias/music/avatars/yiluxiangbei.jpg","hash":"01b12e3aca7385a88412c12539e1a608a78896fa","modified":1675231576355},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1675231576267},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1675231576268},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","hash":"3480f00d284c812d623ed16a9e0ead3fb964c72e","modified":1675231576268},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1675231576268},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1675231576268},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1675231576268},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1675231576268},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1675231576267},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1675231576268},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"f8cd48e1fff82ecd54a7ce3e69de8dba7c92d113","modified":1675231576268},{"_id":"themes/matery/source/libs/share/css/share.min.css","hash":"7126de5cec8371e580b7b1f22512da0985cc39e5","modified":1675231576270},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1675231576270},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1675231576270},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1675231576270},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","hash":"4df722bafde2c5d8faaace0d1f894798385a8793","modified":1675231576271},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","hash":"337b4f156f6d8f4beb32c32a3db46fef361cff74","modified":1675231576270},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","hash":"16ce82901ca0e302cf47a35fb10f59009a5e7eb9","modified":1675231576271},{"_id":"source/_posts/iOS-swift-网络请求二次封装moya/moya1.png","hash":"b9eecb78564853a842883c98ca0b654dd7cd2661","modified":1675233130505},{"_id":"source/_posts/iOS-swift-混编Flutter/fluttererror03.png","hash":"c2092c7ac8a47f5145a4891d0e64cda207ffa626","modified":1675232849748},{"_id":"themes/matery/source/medias/gzh.jpg","hash":"c6f507fbe3c3719b81dcba46125568bf22e8d9b6","modified":1675231576353},{"_id":"themes/matery/source/medias/banner/1.jpg","hash":"309f484b6e69e877de6a7fb847d66497d22bbd65","modified":1675231576291},{"_id":"themes/matery/source/medias/avatars/antnlp.ico","hash":"29475f350b989331cebd702a315f020917d06ed8","modified":1675231576273},{"_id":"themes/matery/source/medias/avatars/gsy.jpg","hash":"6a175e2ba56a2280d40a2e654b559be41c3a0a48","modified":1675231576277},{"_id":"themes/matery/source/medias/avatars/duyupei.jpg","hash":"3c02ed4cf57dc37e4f4b8314bf5094833a854cb0","modified":1675231576275},{"_id":"themes/matery/source/medias/avatars/bytedtrans.png","hash":"ce59d69e5106f20548f4ec9b6429c8fcc787ea08","modified":1675231576274},{"_id":"themes/matery/source/medias/avatars/jiejie.jpg","hash":"a52476e25bec2391674e77a889a89341fbb29791","modified":1675231576278},{"_id":"themes/matery/source/medias/avatars/qiandongwei.jpg","hash":"6873551596a4513d01898ad866c4073c68270c57","modified":1675231576286},{"_id":"themes/matery/source/medias/avatars/milyyy.jpg","hash":"ac2826d9c28346efeb967df01465a2c74d9041fe","modified":1675231576284},{"_id":"themes/matery/source/medias/avatars/mizunashi.png","hash":"5fc300701d3b4250a307ed70e3a3aa0d5395c808","modified":1675231576285},{"_id":"themes/matery/source/medias/avatars/myzhihu.png","hash":"992e0d803160d2ae867be5eb0032d324d1cedffb","modified":1675231576286},{"_id":"themes/matery/source/medias/avatars/xuzhongyou.jpg","hash":"1db4dfaf23cf250f222a398326562d4170d3aaa1","modified":1675231576288},{"_id":"themes/matery/source/medias/avatars/zhangting.jpg","hash":"10ee25ae3531f046a8bd3696c1cc8a16f0f25e1b","modified":1675231576289},{"_id":"themes/matery/source/medias/avatars/zzw.jpg","hash":"5d385b5732644b07b937a4919abc83cb95e14513","modified":1675231576290},{"_id":"themes/matery/source/medias/avatars/xiejiadong.jpg","hash":"f1a31f89426bd4dccdaba2170f4fc701336702e1","modified":1675231576288},{"_id":"themes/matery/source/medias/files/cv-zh.pdf","hash":"4f58778031b0a0e669e036b16639741e44fc2375","modified":1675231576352},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","hash":"82276be41d2001e820020a219b90ad5b026302d1","modified":1675231576262},{"_id":"themes/matery/source/libs/gitment/gitment.js","hash":"5a13983930b019450e4fe01a407c64b3dd316be4","modified":1675231576267},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","hash":"7a551393b8360731104fdef1af36a6f3638f5855","modified":1675231576267},{"_id":"themes/matery/source/libs/valine/Valine.min.js","hash":"f1558f12d96a352e490166d543a8e821dd3bb2bc","modified":1675231576271},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1675231576261},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1675231576261},{"_id":"themes/matery/source/medias/banner/0.jpg","hash":"d4db93afdff4ce889dd8271bcf9e80eb3c0bf866","modified":1675231576291},{"_id":"themes/matery/source/medias/contact.jpg","hash":"e7bb4c4cc6807f32018c9ce7eadf4946e1976b64","modified":1675231576298},{"_id":"themes/matery/source/medias/banner/6.jpg","hash":"4fcbc9dd8ec0316e9dd5bfd0caf86f1520b10b3f","modified":1675231576297},{"_id":"themes/matery/source/medias/banner/2.jpg","hash":"280fa1c6493d7fdccfc18bd486446bacd9afe623","modified":1675231576292},{"_id":"themes/matery/source/medias/featureimages/14.jpg","hash":"1c1063c29f827cf52eeef7ca8dc2d7e4efa31a76","modified":1675231576306},{"_id":"themes/matery/source/medias/featureimages/22.jpg","hash":"02ec4566225102778c3837f08b24de02faf460a6","modified":1675231576322},{"_id":"themes/matery/source/medias/featureimages/13.jpg","hash":"d8cc7a730668943dcb0776cfa240a0cf76826363","modified":1675231576305},{"_id":"themes/matery/source/medias/avatars/0xbird.png","hash":"f9d597dfcb49e1e2be06138b24028291f5638610","modified":1675231576273},{"_id":"themes/matery/source/medias/avatars/lzh.png","hash":"8ffcbf19d6b38b891dbe408d9a4e9513b56f247e","modified":1675231576282},{"_id":"themes/matery/source/medias/avatars/mashiro.jpg","hash":"250e911c16eeb6acb1e6214ad3e6a3d762850a8e","modified":1675231576283},{"_id":"themes/matery/source/medias/avatars/lyn-draw.jpg","hash":"837d5d5df4dcb086d2da114d0d85084b4ec18768","modified":1675231576282},{"_id":"themes/matery/source/medias/avatars/qianqian.png","hash":"fed254c4e7eb58ee22d647acb83f1d08f4508f8f","modified":1675231576286},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","hash":"c843f0dc497314574c608ca28cc742bb041786d5","modified":1675231576269},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","hash":"2c27939768606603bee3b5e6c8a722596a667e60","modified":1675231576269},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","hash":"f63c7c489524ccb5d95e74fcd6618116c58fb305","modified":1675231576266},{"_id":"themes/matery/source/libs/valine/av-min.js","hash":"04c6b2782ce4610c429563110f6a20a47432fc4c","modified":1675231576272},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1675231576258},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1675231576257},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1675231576260},{"_id":"source/_posts/iOS-swift-混编Flutter/fluttererror2.png","hash":"19dc9ab0586378a2929bb69c318d6ec6db6d8de0","modified":1675232849750},{"_id":"themes/matery/source/medias/banner/4.jpg","hash":"a3cfdee2120195ab36b2fdd074d5558852e69297","modified":1675231576295},{"_id":"themes/matery/source/medias/featureimages/12.jpg","hash":"c2892770fd5617418fd33d6f834879e05b2cdafd","modified":1675231576305},{"_id":"themes/matery/source/medias/avatars/feibar.png","hash":"eceaefcbbca1bf49b582eaa649d311cf4fe69dd6","modified":1675231576276},{"_id":"themes/matery/source/medias/avatars/jitao.jpg","hash":"5934b9baccebccbc2be2ead5d84ad32dd41f9559","modified":1675231576279},{"_id":"themes/matery/source/medias/avatars/zhangyi.jpg","hash":"c9130036aac9a7ac8d62e33550a9d64896cdc364","modified":1675231576290},{"_id":"themes/matery/source/medias/music/avatars/daoshu.jpg","hash":"eee120fdf5ccbe86aa7d51826c4c773e76e6357f","modified":1675231576354},{"_id":"themes/matery/source/medias/banner/3.jpg","hash":"255aaa4375da855bd80b38cfcc253de892a9d4cf","modified":1675231576293},{"_id":"themes/matery/source/medias/featureimages/17.jpg","hash":"11a6de283124964370dbfaf0e74f2f1e9ac8394d","modified":1675231576311},{"_id":"themes/matery/source/medias/banner/5.jpg","hash":"6ddd1bcbb62a2d28c5be3b9acb7418849d60b2e7","modified":1675231576296},{"_id":"themes/matery/source/medias/featureimages/2.jpg","hash":"1d8863277d744e1a18a2778ac26041bda5b03a98","modified":1675231576316},{"_id":"themes/matery/source/medias/featureimages/23.jpg","hash":"ee598933707f8bb98ecbf36925f24e8a1c4bd2d6","modified":1675231576323},{"_id":"themes/matery/source/medias/featureimages/25.jpg","hash":"d0668539783fc615f14178644e486a6befb90c0c","modified":1675231576328},{"_id":"themes/matery/source/medias/featureimages/28.jpg","hash":"c73036359640a67a8b17db7ba0e968c088957ab8","modified":1675231576332},{"_id":"themes/matery/source/medias/featureimages/3.jpg","hash":"ceb8e0c195a7fe7420334efa114e98cd0e1c6523","modified":1675231576333},{"_id":"themes/matery/source/medias/avatars/jingjing.jpg","hash":"bfcab0139edb2509de984cb0a9b156879c355158","modified":1675231576279},{"_id":"source/_posts/iOS-swift-数据库realm实践/realm2.png","hash":"9a893b602da7960abac88cbd75a913107d9ad58d","modified":1675232014866},{"_id":"source/_posts/iOS-swift-数据库realm实践/realm1.png","hash":"8dea478526f67950e1d04d4f8ade74ab7cd64b2b","modified":1675232014864},{"_id":"source/_posts/玩Android-Compose版本-项目分析/mine.jpeg","hash":"1f86a74843aaae7e80f61155a58a17da1320a614","modified":1675231576227},{"_id":"themes/matery/source/medias/featureimages/10.jpg","hash":"66de48d963e7f221931e550b2442da0cd40cbaa8","modified":1675231576301},{"_id":"themes/matery/source/medias/featureimages/20.jpg","hash":"84ba9cf61045de789426eeb6333910266ce29b8c","modified":1675231576318},{"_id":"themes/matery/source/medias/featureimages/26.jpg","hash":"c66a4e7a2e670b63759a091f9428ee7f971d7b56","modified":1675231576329},{"_id":"themes/matery/source/medias/featureimages/27.jpg","hash":"7ea6f890cc59def8b1c9f393e4ae77cd16c79aad","modified":1675231576330},{"_id":"themes/matery/source/medias/featureimages/6.jpg","hash":"698fc46e97428d73c9d4e3d254e88b9b66fb38cd","modified":1675231576341},{"_id":"themes/matery/source/medias/featureimages/7.jpg","hash":"bd400da9123424afe7ba6c839be9ad7697c1245b","modified":1675231576343},{"_id":"source/_posts/iOS-swift-实现简易地图功能/map.png","hash":"93e267d80b97c93e48677b068f43c171ea851053","modified":1675232014861},{"_id":"themes/matery/source/medias/featureimages/11.jpg","hash":"2b30186c6d78ed76fa5f278be57290c1bd22c96a","modified":1675231576303},{"_id":"themes/matery/source/medias/featureimages/1.jpg","hash":"f1d720039d654d693c32150c06c78cfc3663b0b4","modified":1675231576299},{"_id":"themes/matery/source/medias/featureimages/18.jpg","hash":"c74ce6fa4eee122e147ec55532744f34a87ae2bf","modified":1675231576312},{"_id":"themes/matery/source/medias/featureimages/16.jpg","hash":"0801e96a2f4cbd14b2ad44547e5ffbb23822e751","modified":1675231576310},{"_id":"themes/matery/source/medias/featureimages/19.jpg","hash":"2a47d1123d9c4c6255b7b4817a582d2fa9aea808","modified":1675231576314},{"_id":"themes/matery/source/medias/featureimages/21.jpg","hash":"a77810cc2224446f5d4e1a857a8d480f21e81f83","modified":1675231576321},{"_id":"themes/matery/source/medias/featureimages/24.jpg","hash":"72bc68fb0673b84ab9f863d2979396cdc268a76c","modified":1675231576326},{"_id":"themes/matery/source/medias/reward/alipay.png","hash":"98faed5b838aa003f660213be764152ee348f451","modified":1675231576356},{"_id":"themes/matery/source/medias/reward/wechat.png","hash":"98faed5b838aa003f660213be764152ee348f451","modified":1675231576356},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1675231576259},{"_id":"source/_posts/玩Android-Compose版本-项目分析/首页.jpeg","hash":"c0541a828adb8491a51c67a7a11fe2d7ff057bad","modified":1675231576249},{"_id":"themes/matery/source/medias/featureimages/8.jpg","hash":"f81e97edf705ab45b989b2b15d6a13c005ccaa32","modified":1675231576346},{"_id":"source/_posts/iOS-swift-如何实现扫码功能/scan1.png","hash":"b06f374c408dd565191b743f0dcebfd4f6311100","modified":1675232014857},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","hash":"8789b5e4daf0029a6c88f238f10e54d01c4fce82","modified":1675231576265},{"_id":"source/_posts/iOS-swift-如何实现扫码功能/scan2.png","hash":"f77a75032260c4927cb3b674d190257fd558e208","modified":1675232014859},{"_id":"source/_posts/iOS-swift-自定义View之四级地址/四级地址.gif","hash":"586e0fcfc20a5c0d870a0e5cacb85a2ec52a304e","modified":1675232014876},{"_id":"themes/matery/source/medias/featureimages/15.jpg","hash":"aff885598033614639944c7559b4849f883e2b34","modified":1675231576309},{"_id":"themes/matery/source/medias/featureimages/9.jpg","hash":"cd54b116609f5741cc7db0f7f49bf56ac356ddfb","modified":1675231576350},{"_id":"themes/matery/source/medias/featureimages/4.jpg","hash":"e06afe32a867f7a6e861618e0b5ac9d93cd71d05","modified":1675231576337},{"_id":"source/_posts/iOS-swift-打造TabLayout效果/page1.gif","hash":"77268a4d9068e1cec74c463d8f48b766455fbbd4","modified":1675244356985},{"_id":"source/_posts/玩Android-Compose版本-项目分析/闪屏页.gif","hash":"a76a77cf58af915878c1141c48d7825ef9334fe9","modified":1675231576244},{"_id":"public/baidu_urls.txt","hash":"1df68466d0f3896d9bb0e019b104ec43a5ac403b","modified":1675766997437},{"_id":"public/about/index.html","hash":"60688e7dffe648d575d8f1062a7d7e2ac938f974","modified":1675766997437},{"_id":"public/404.html","hash":"39f13db637a9d0c007842e405afbb39d9fed98ab","modified":1675766997437},{"_id":"public/categories/index.html","hash":"f3c844d48c49e6707bfbaec795a4fe6b0a456ff1","modified":1675766997437},{"_id":"public/contact/index.html","hash":"e51b0c5f38d1c8e29bba93477a7d784d4875a6ad","modified":1675766997437},{"_id":"public/friends/index.html","hash":"99872f09136023701f2808cf3dd37913b80d637e","modified":1675766997437},{"_id":"public/2023/02/02/iOS-swift-打造TabLayout效果/index.html","hash":"26886750319f300f9ef445a23cbc5f0fd9abda5c","modified":1675766997437},{"_id":"public/tags/index.html","hash":"7f076e5ca6bb6f938202882571d385767b027750","modified":1675766997437},{"_id":"public/2023/02/01/iOS-swift-混编Flutter/index.html","hash":"fd8727e8ab545d8f35984fb01e3c86ea5ff57a65","modified":1675766997437},{"_id":"public/2023/02/01/iOS-swift-网络请求二次封装moya/index.html","hash":"073a1cdf952dddfd2c388bae1301663699b11115","modified":1675766997437},{"_id":"public/2023/01/31/iOS-swift-实现简易地图功能/index.html","hash":"46ced8a3dc2454cc4526ce97d1085d5989b73779","modified":1675766997437},{"_id":"public/2023/01/30/iOS-swift-数据库realm实践/index.html","hash":"3181e357273092640380816190ba3c316422487e","modified":1675766997437},{"_id":"public/2023/01/29/iOS-swift-如何实现扫码功能/index.html","hash":"6529a4b3f54a7d6cb6212ece57f698143e4ba82c","modified":1675766997437},{"_id":"public/2023/01/28/iOS-swift-自定义View之时间选择器/index.html","hash":"2570959e4cebfcf9976f34e312555add1f3676b4","modified":1675766997437},{"_id":"public/2023/01/27/iOS-swift-自定义View之四级地址/index.html","hash":"bcae0a9c75f87e6e0db640ae3762246da1101d1a","modified":1675766997437},{"_id":"public/2023/01/26/iOS-swift-自定义View之步进器/index.html","hash":"266f60eb884c2c03212747162f208ed6626d4187","modified":1675766997437},{"_id":"public/2023/01/23/iOS-学习导航/index.html","hash":"7c02cbf54521e478346bfe674d7cc01a093ce146","modified":1675766997437},{"_id":"public/archives/index.html","hash":"e1010d1c27c9c1e6b58d07b88adaf1720c83ac47","modified":1675766997437},{"_id":"public/2023/01/22/Flutter-学习导航/index.html","hash":"0ca5164ffc0cb6f1bdf135810c908c9baf6940e9","modified":1675766997437},{"_id":"public/2023/01/21/Android-学习导航/index.html","hash":"57eff857c0211fb221cd6f78e40bf18a152947b6","modified":1675766997437},{"_id":"public/2023/01/15/Android-google-samples-nowinandroid-app模块流程分析/index.html","hash":"d48312057e359ab87b73323104428ee44ac8b178","modified":1675766997437},{"_id":"public/2023/01/11/5w2h-godweiyang/index.html","hash":"79bf6835f8f9b95361aca6eaccbce08d589b698a","modified":1675766997437},{"_id":"public/archives/2023/index.html","hash":"6868bd2276e7428835f6ac5a11ed69f8008b611c","modified":1675766997437},{"_id":"public/archives/page/2/index.html","hash":"8ac4a8bcee23c6fda6fc540e0d2a390b061720d2","modified":1675766997437},{"_id":"public/2023/01/17/玩Android-Compose版本-项目分析/index.html","hash":"1736751771f349f8b84e919cdeae73bfd29af528","modified":1675766997437},{"_id":"public/archives/2023/01/index.html","hash":"c3d3149a7a6994a5df8c06c7f440c3dacca80d4d","modified":1675766997437},{"_id":"public/archives/2023/page/2/index.html","hash":"e991714260f0b9e25e4abcfcfa8fdfb91c18efc4","modified":1675766997437},{"_id":"public/archives/2023/01/page/2/index.html","hash":"4de34ea39b0c84e2b98b29e651604c90fe7d862c","modified":1675766997437},{"_id":"public/2023/01/13/Android-gradle相关-KTS脚本-项目配置改造/index.html","hash":"38ae30f1c3695f7411e80fc860004eb52412937f","modified":1675766997437},{"_id":"public/archives/2023/02/index.html","hash":"a48352d2b6216b1f6e9122683c6fc471bb8761b9","modified":1675766997437},{"_id":"public/tags/博客/index.html","hash":"ae004bf834aee9739e8e4dd5813e5ae235477b82","modified":1675766997437},{"_id":"public/tags/Android/index.html","hash":"ce8bb60fef33e27a900d6e12087441e12fd8ec2e","modified":1675766997437},{"_id":"public/tags/Flutter/index.html","hash":"c40469991a3f3809c54a176b43ba5ff436176185","modified":1675766997437},{"_id":"public/tags/条形码识别-相机/index.html","hash":"85843b41298087e00b85ae93827ab6629b913521","modified":1675766997437},{"_id":"public/tags/TabLayout/index.html","hash":"1c6d50b555032a449c8a04ba0b76a8d35b777207","modified":1675766997437},{"_id":"public/tags/数据库-iOS/index.html","hash":"37a59341464072a34682c9a5f39db96f2a4a13d0","modified":1675766997437},{"_id":"public/tags/混编Flutter/index.html","hash":"c5b0cd938d427b31f941a4f052e71f55e314dfe9","modified":1675766997437},{"_id":"public/tags/网络请求/index.html","hash":"13bda448d9d9198e252058f9ae60eb07102bcf06","modified":1675766997437},{"_id":"public/tags/iOS-自定义View/index.html","hash":"f90ad7e5b6b7d0034921b484c13d1bce6a5f2f31","modified":1675766997437},{"_id":"public/tags/iOS/index.html","hash":"3c97cbdb2abfe0edbd2424010fc74c1e8bc033c8","modified":1675766997437},{"_id":"public/tags/地图/index.html","hash":"49823b9ffdee70513c9720c01d61bceb3ff54ec7","modified":1675766997437},{"_id":"public/categories/随笔/index.html","hash":"8284d8722e9a98553ffdd0c3c7284f8e1e8ec7a0","modified":1675766997437},{"_id":"public/categories/Android/index.html","hash":"6e4c5bcf7af6091c47580483a5aa07a36cc4cfa3","modified":1675766997437},{"_id":"public/categories/iOS/index.html","hash":"643abf3c42695e836fc219a3e10e86e3e5da5173","modified":1675766997437},{"_id":"public/categories/Flutter/index.html","hash":"d68c6bea5f84561c6e9ffbea0d8506a45921febe","modified":1675766997437},{"_id":"public/page/2/index.html","hash":"85cb238b86457bdfc5071c630bab4539574a7dc1","modified":1675766997437},{"_id":"public/index.html","hash":"558f23127fe2d569758a8c87a00bbf6b3a80d399","modified":1675766997437},{"_id":"public/medias/logo.png","hash":"ee16e748bc0961b84ed544a3c041aa9c19b95948","modified":1675244682493},{"_id":"public/favicon.png","hash":"0f4145b9a712f9662e4fae1b0086ce74cf1f9fc4","modified":1675244682493},{"_id":"public/medias/featureimages/0.jpg","hash":"1f8bbfbd625448b4b2a748b75636e456b826dcd3","modified":1675244682493},{"_id":"public/medias/featureimages/5.jpg","hash":"c4cc724f4572a9bcede7443a4f4c0393d3073868","modified":1675244682493},{"_id":"public/medias/avatars/ajin.jpg","hash":"76cb8e872472ff47a1b061c3bcff1c03f30c02b8","modified":1675244682493},{"_id":"public/medias/avatars/avatar.jpg","hash":"f92b165327d79aacc2fde2880745f80e4ca3d9e1","modified":1675244682493},{"_id":"public/medias/avatars/babyq.png","hash":"be5432588003e5a52c02e690622eec72b5f7346c","modified":1675244682493},{"_id":"public/medias/avatars/cww97.jpg","hash":"6af987cafc55d8d031534dd5e0f722fff19f70ec","modified":1675244682493},{"_id":"public/medias/avatars/fun4go.png","hash":"0f4333973a972a629cfbabf601bc7c192b65376c","modified":1675244682493},{"_id":"public/medias/avatars/feibar.jpg","hash":"343f47cb5c83cd866a1c824cbe2a112d02516d06","modified":1675244682493},{"_id":"public/medias/avatars/hael.jpg","hash":"e66ccedab38bb2e8fc45fac024e234ab8e7b9d54","modified":1675244682493},{"_id":"public/medias/avatars/hzwer.jpg","hash":"53a66bb5e65d2abd5b7412edf094c1e0b1094492","modified":1675244682493},{"_id":"public/medias/avatars/huaji.jpg","hash":"86be7eed2a491455ccfe3e7da46366ff477765ca","modified":1675244682493},{"_id":"public/medias/avatars/ids2.jpg","hash":"2c8d3ac6ab5ac6196bac83766fde975daca91c32","modified":1675244682493},{"_id":"public/medias/avatars/kewlgrl.jpg","hash":"3af0fd1029a1511bb3c0e90871e41b35e714b01f","modified":1675244682493},{"_id":"public/medias/avatars/ldy.jpg","hash":"906ef214d1f2fe52a663738340ad5623f826bd82","modified":1675244682493},{"_id":"public/medias/avatars/liyucheng.jpg","hash":"12055a27fa667c87d2319475968056e1a8ad0f08","modified":1675244682493},{"_id":"public/medias/avatars/lijiaqian.png","hash":"9d96b3838acfae9a23b6e290fcfafceff0419c63","modified":1675244682493},{"_id":"public/medias/avatars/liyangzone.jpg","hash":"febab557e4c0d859ab4cc14b57d8106f5e3fccfb","modified":1675244682493},{"_id":"public/medias/avatars/masterx.jpg","hash":"c9f7e83d895fa241cefd6e742f356106b35f1b89","modified":1675244682493},{"_id":"public/medias/avatars/michael.jpg","hash":"331a2ab20c299196f5a3089b8445fc8f55346cb6","modified":1675244682493},{"_id":"public/medias/avatars/mouse.jpg","hash":"2eae273885b9859150a1f98f74b3df12ca9a207c","modified":1675244682493},{"_id":"public/medias/avatars/mpy634.png","hash":"30f88e09c02b37c2dc684d4ee3237e327bb23f8b","modified":1675244682493},{"_id":"public/medias/avatars/sunchangzhi.jpg","hash":"bbe2a15fd474ab62dbd14fea72deb1113a4fb005","modified":1675244682493},{"_id":"public/medias/avatars/qiqiang.jpg","hash":"081459866f922d9558a88cd4d7155d91fa730322","modified":1675244682493},{"_id":"public/medias/avatars/tawn.jpg","hash":"68a1cbacbb2370912b000c9d8d2b16196c918a50","modified":1675244682493},{"_id":"public/medias/avatars/taotao.jpg","hash":"e668254375ddd40a684ff4669c3421851bebd36e","modified":1675244682493},{"_id":"public/medias/avatars/taowei.jpg","hash":"e58b03b70656aa7a27238be38dac3896d9d16f10","modified":1675244682493},{"_id":"public/medias/avatars/spacesac.png","hash":"ff1bdb058f1f0499312da1a082ba97d78590db1a","modified":1675244682493},{"_id":"public/medias/files/cv-en.pdf","hash":"2a62ab3797f8bc8e2e5e04c4950198525c635139","modified":1675244682493},{"_id":"public/medias/avatars/zhaokangzhe.jpg","hash":"c8242bd13f08a9ddb97e26f216bc729b12ed9058","modified":1675244682493},{"_id":"public/medias/avatars/yezijie.png","hash":"8a53537eb69f749115e512b6da061e7f23cd04e5","modified":1675244682493},{"_id":"public/medias/music/avatars/tiantangdemogui.jpg","hash":"f005578ddb4d3d731838db89a708f39f18d50e60","modified":1675244682493},{"_id":"public/medias/music/avatars/yiluxiangbei.jpg","hash":"01b12e3aca7385a88412c12539e1a608a78896fa","modified":1675244682493},{"_id":"public/medias/music/avatars/yequ.jpg","hash":"103beb9ab33434b434fa37a30aecdb29db633024","modified":1675244682493},{"_id":"public/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1675244682493},{"_id":"public/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1675244682493},{"_id":"public/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1675244682493},{"_id":"public/libs/lightGallery/fonts/lg.svg","hash":"3480f00d284c812d623ed16a9e0ead3fb964c72e","modified":1675244682493},{"_id":"public/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1675244682493},{"_id":"public/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1675244682493},{"_id":"public/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1675244682493},{"_id":"public/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1675244682493},{"_id":"public/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1675244682493},{"_id":"public/libs/share/fonts/iconfont.svg","hash":"337b4f156f6d8f4beb32c32a3db46fef361cff74","modified":1675244682493},{"_id":"public/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1675244682493},{"_id":"public/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1675244682493},{"_id":"public/CNAME","hash":"5e8a7aad69a8e5e79479ea54733cb096611eec47","modified":1675244682493},{"_id":"public/2023/01/22/Flutter-学习导航/FlutterDevs.jpeg","hash":"f99339d77b2943ce258ccc86d1347d666b72920c","modified":1675244682493},{"_id":"public/2023/01/22/Flutter-学习导航/blog_520lee_com.jpeg","hash":"55ca5b424bbe29efce36afdd29b702250d988875","modified":1675244682493},{"_id":"public/2023/01/22/Flutter-学习导航/Study_Knowledge.jpeg","hash":"ed1d63d25a4136faca1b8a6d6c3da1ef3413720b","modified":1675244682493},{"_id":"public/2023/01/21/Android-学习导航/bianchengjingxuan.jpeg","hash":"f6fb1d9014d3745473e188380216cef5bae7da92","modified":1675244682493},{"_id":"public/2023/01/21/Android-学习导航/carson.jpeg","hash":"40635ad0a930abcc74b1e2eec760cb44cfc477f8","modified":1675244682493},{"_id":"public/2023/01/21/Android-学习导航/hongyang.jpeg","hash":"6d414b2f8a29459ed52f4a7d1714441074d85f42","modified":1675244682493},{"_id":"public/2023/01/21/Android-学习导航/jishuzhuanjia.jpeg","hash":"a9036689bffb0d31e44ca4c691a79b30893b97ac","modified":1675244682493},{"_id":"public/2023/01/21/Android-学习导航/jishuquan.jpeg","hash":"7597cde9db6040f80064ab5c397ad40394c2c068","modified":1675244682493},{"_id":"public/2023/01/21/Android-学习导航/guolin.jpeg","hash":"637e479009efdec579986fbe8eb5eacc9e46932e","modified":1675244682493},{"_id":"public/2023/01/26/iOS-swift-自定义View之步进器/stepper0.png","hash":"ebc88bb13e0f6168189228b613a0dd41f73882d2","modified":1675244682493},{"_id":"public/2023/01/26/iOS-swift-自定义View之步进器/stepper5.png","hash":"4f77bd25aaec9a33753d84c2205feb7642e40284","modified":1675244682493},{"_id":"public/2023/01/21/Android-学习导航/jsonchao.jpeg","hash":"e476402b268490d72534f55cfa9d23b9be43f566","modified":1675244682493},{"_id":"public/2023/01/23/iOS-学习导航/iOSkaifa.jpeg","hash":"a5478eb61474efe19ac6abc28a427d7096c749e8","modified":1675244682493},{"_id":"public/2023/01/21/Android-学习导航/qunyingzhuan.jpeg","hash":"203453e7a2f5ec4b3ab6b9d643a1a8882ec528be","modified":1675244682493},{"_id":"public/2023/01/23/iOS-学习导航/mobile_tech_share.jpeg","hash":"90b55e26b096ae716f8074096ac48b2b1290c852","modified":1675244682493},{"_id":"public/2023/01/17/玩Android-Compose版本-项目分析/home_item.jpeg","hash":"ee18c76cc19ffc9653309fb22c5db4be8abe6694","modified":1675244682493},{"_id":"public/medias/gzh.jpg","hash":"c6f507fbe3c3719b81dcba46125568bf22e8d9b6","modified":1675244682493},{"_id":"public/medias/banner/1.jpg","hash":"309f484b6e69e877de6a7fb847d66497d22bbd65","modified":1675244682493},{"_id":"public/medias/avatars/antnlp.ico","hash":"29475f350b989331cebd702a315f020917d06ed8","modified":1675244682493},{"_id":"public/medias/avatars/bytedtrans.png","hash":"ce59d69e5106f20548f4ec9b6429c8fcc787ea08","modified":1675244682493},{"_id":"public/medias/avatars/duyupei.jpg","hash":"3c02ed4cf57dc37e4f4b8314bf5094833a854cb0","modified":1675244682493},{"_id":"public/medias/avatars/jiejie.jpg","hash":"a52476e25bec2391674e77a889a89341fbb29791","modified":1675244682493},{"_id":"public/medias/avatars/gsy.jpg","hash":"6a175e2ba56a2280d40a2e654b559be41c3a0a48","modified":1675244682493},{"_id":"public/medias/avatars/milyyy.jpg","hash":"ac2826d9c28346efeb967df01465a2c74d9041fe","modified":1675244682493},{"_id":"public/medias/avatars/qiandongwei.jpg","hash":"6873551596a4513d01898ad866c4073c68270c57","modified":1675244682493},{"_id":"public/medias/avatars/myzhihu.png","hash":"992e0d803160d2ae867be5eb0032d324d1cedffb","modified":1675244682493},{"_id":"public/medias/avatars/mizunashi.png","hash":"5fc300701d3b4250a307ed70e3a3aa0d5395c808","modified":1675244682493},{"_id":"public/medias/avatars/zhangting.jpg","hash":"10ee25ae3531f046a8bd3696c1cc8a16f0f25e1b","modified":1675244682493},{"_id":"public/medias/avatars/xuzhongyou.jpg","hash":"1db4dfaf23cf250f222a398326562d4170d3aaa1","modified":1675244682493},{"_id":"public/medias/avatars/zzw.jpg","hash":"5d385b5732644b07b937a4919abc83cb95e14513","modified":1675244682493},{"_id":"public/medias/files/cv-zh.pdf","hash":"4f58778031b0a0e669e036b16639741e44fc2375","modified":1675244682493},{"_id":"public/medias/avatars/xiejiadong.jpg","hash":"f1a31f89426bd4dccdaba2170f4fc701336702e1","modified":1675244682493},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1675244682493},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1675244682493},{"_id":"public/2023/02/01/iOS-swift-混编Flutter/fluttererror1.png","hash":"144e586ff60c31f455e3edd250f8e3fc4950b5d0","modified":1675244682493},{"_id":"public/2023/02/02/iOS-swift-打造TabLayout效果/segment1.png","hash":"f671c195de1774e1531ba0311e55c03592fef431","modified":1675244682493},{"_id":"public/2023/01/28/iOS-swift-自定义View之时间选择器/预约时间.png","hash":"062fd52e9f09f9a482ac57796c4bf8b347d7da86","modified":1675244682493},{"_id":"public/2023/01/28/iOS-swift-自定义View之时间选择器/预约日期.png","hash":"dedd941735c71b5f1bd3a1471e180c409b47ffe7","modified":1675244682493},{"_id":"public/css/prism.css","hash":"163e7764ec6f65f1be8fac7b4a75088b79407ed2","modified":1675244682493},{"_id":"public/js/matery.js","hash":"92f07106944f5ef7cd72e84bb3534513d00eebe1","modified":1675244682493},{"_id":"public/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1675244682493},{"_id":"public/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1675244682493},{"_id":"public/css/my.css","hash":"497e50351f7838f8546cac76850a42e7e380a110","modified":1675244682493},{"_id":"public/js/search.js","hash":"499e11786efbb04815b54a1de317cc8606a37555","modified":1675244682493},{"_id":"public/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1675244682493},{"_id":"public/libs/codeBlock/codeLang.js","hash":"ea8b51e4d75e7b2cd63e4d5bcb8db2cf7f23f5db","modified":1675244682493},{"_id":"public/libs/codeBlock/codeCopy.js","hash":"b74a381adf6ef8404d6a0452c2b9f44b47219c80","modified":1675244682493},{"_id":"public/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1675244682493},{"_id":"public/libs/codeBlock/codeShrink.js","hash":"215910dc8f63fd50b97957e5fcdc8480aa2728cb","modified":1675244682493},{"_id":"public/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1675244682493},{"_id":"public/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1675244682493},{"_id":"public/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1675244682493},{"_id":"public/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1675244682493},{"_id":"public/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1675244682493},{"_id":"public/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1675244682493},{"_id":"public/libs/others/fireworks.js","hash":"53981959bc6def4a85bbbb41b07e4b1474a2124d","modified":1675244682493},{"_id":"public/libs/others/explosion.min.js","hash":"417b68e2cf2c6de2119c57626f4412105a8457f5","modified":1675244682493},{"_id":"public/libs/others/snow.js","hash":"7f3b1ad2f64d4473210a2c3218893649c73c980e","modified":1675244682493},{"_id":"public/libs/others/text.js","hash":"1791782cde0d1e4197f2ed58ecb7dd6aefddd169","modified":1675244682493},{"_id":"public/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1675244682493},{"_id":"public/libs/tocbot/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1675244682493},{"_id":"public/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1675244682493},{"_id":"public/css/matery.css","hash":"caa63c2c7908e45ebbbea0fbdc72d09b7b6d5b76","modified":1675244682493},{"_id":"public/js/prism.js","hash":"dd2c2a445f8fda202c69a1a8906e7563583a7a25","modified":1675244682493},{"_id":"public/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1675244682493},{"_id":"public/libs/codeBlock/clipboard.min.js","hash":"9cd57c67fbd3e3067f80793ef8445f5ff7783563","modified":1675244682493},{"_id":"public/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1675244682493},{"_id":"public/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1675244682493},{"_id":"public/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1675244682493},{"_id":"public/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1675244682493},{"_id":"public/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1675244682493},{"_id":"public/libs/jquery/jquery-2.2.0.min.js","hash":"5d7e5bbfa540f0e53bd599e4305e1a4e815b5dd1","modified":1675244682493},{"_id":"public/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1675244682493},{"_id":"public/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1675244682493},{"_id":"public/libs/gitalk/gitalk.css","hash":"3aac1db83b0135c521187254ff302d125cc30706","modified":1675244682493},{"_id":"public/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1675244682493},{"_id":"public/libs/materialize/materialize.min.css","hash":"4d46df5f22cbc24eefa76228c7ee308dc3585594","modified":1675244682493},{"_id":"public/libs/gitalk/gitalk.min.js","hash":"28bdb33c9eb609c2f30d431df1a4cf8ca70bf841","modified":1675244682493},{"_id":"public/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1675244682493},{"_id":"public/libs/awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1675244682493},{"_id":"public/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1675244682493},{"_id":"public/libs/valine/Valine.min.js","hash":"4e34802ccbb59f1daa58a62241ff57f923e50600","modified":1675244682493},{"_id":"public/libs/share/js/jquery.share.min.js","hash":"16ce82901ca0e302cf47a35fb10f59009a5e7eb9","modified":1675244682493},{"_id":"public/libs/share/js/social-share.min.js","hash":"4df722bafde2c5d8faaace0d1f894798385a8793","modified":1675244682493},{"_id":"public/libs/valine/av-min.js","hash":"2577e72b52b736d99649f9e95be8976d58563333","modified":1675244682493},{"_id":"public/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1675244682493},{"_id":"public/medias/contact.jpg","hash":"e7bb4c4cc6807f32018c9ce7eadf4946e1976b64","modified":1675244682493},{"_id":"public/medias/banner/0.jpg","hash":"d4db93afdff4ce889dd8271bcf9e80eb3c0bf866","modified":1675244682493},{"_id":"public/medias/banner/6.jpg","hash":"4fcbc9dd8ec0316e9dd5bfd0caf86f1520b10b3f","modified":1675244682493},{"_id":"public/medias/banner/2.jpg","hash":"280fa1c6493d7fdccfc18bd486446bacd9afe623","modified":1675244682493},{"_id":"public/medias/featureimages/13.jpg","hash":"d8cc7a730668943dcb0776cfa240a0cf76826363","modified":1675244682493},{"_id":"public/medias/featureimages/14.jpg","hash":"1c1063c29f827cf52eeef7ca8dc2d7e4efa31a76","modified":1675244682493},{"_id":"public/medias/featureimages/22.jpg","hash":"02ec4566225102778c3837f08b24de02faf460a6","modified":1675244682493},{"_id":"public/medias/avatars/0xbird.png","hash":"f9d597dfcb49e1e2be06138b24028291f5638610","modified":1675244682493},{"_id":"public/medias/avatars/lyn-draw.jpg","hash":"837d5d5df4dcb086d2da114d0d85084b4ec18768","modified":1675244682493},{"_id":"public/medias/avatars/lzh.png","hash":"8ffcbf19d6b38b891dbe408d9a4e9513b56f247e","modified":1675244682493},{"_id":"public/medias/avatars/mashiro.jpg","hash":"250e911c16eeb6acb1e6214ad3e6a3d762850a8e","modified":1675244682493},{"_id":"public/medias/avatars/qianqian.png","hash":"fed254c4e7eb58ee22d647acb83f1d08f4508f8f","modified":1675244682493},{"_id":"public/libs/awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1675244682493},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1675244682493},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1675244682493},{"_id":"public/2023/02/01/iOS-swift-混编Flutter/fluttererror03.png","hash":"c2092c7ac8a47f5145a4891d0e64cda207ffa626","modified":1675244682493},{"_id":"public/2023/02/01/iOS-swift-网络请求二次封装moya/moya1.png","hash":"b9eecb78564853a842883c98ca0b654dd7cd2661","modified":1675244682493},{"_id":"public/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1675244682493},{"_id":"public/medias/featureimages/12.jpg","hash":"c2892770fd5617418fd33d6f834879e05b2cdafd","modified":1675244682493},{"_id":"public/medias/banner/4.jpg","hash":"a3cfdee2120195ab36b2fdd074d5558852e69297","modified":1675244682493},{"_id":"public/medias/avatars/feibar.png","hash":"eceaefcbbca1bf49b582eaa649d311cf4fe69dd6","modified":1675244682493},{"_id":"public/medias/avatars/jitao.jpg","hash":"5934b9baccebccbc2be2ead5d84ad32dd41f9559","modified":1675244682493},{"_id":"public/medias/avatars/zhangyi.jpg","hash":"c9130036aac9a7ac8d62e33550a9d64896cdc364","modified":1675244682493},{"_id":"public/medias/music/avatars/daoshu.jpg","hash":"eee120fdf5ccbe86aa7d51826c4c773e76e6357f","modified":1675244682493},{"_id":"public/medias/banner/3.jpg","hash":"255aaa4375da855bd80b38cfcc253de892a9d4cf","modified":1675244682493},{"_id":"public/medias/banner/5.jpg","hash":"6ddd1bcbb62a2d28c5be3b9acb7418849d60b2e7","modified":1675244682493},{"_id":"public/medias/featureimages/17.jpg","hash":"11a6de283124964370dbfaf0e74f2f1e9ac8394d","modified":1675244682493},{"_id":"public/medias/featureimages/2.jpg","hash":"1d8863277d744e1a18a2778ac26041bda5b03a98","modified":1675244682493},{"_id":"public/medias/featureimages/23.jpg","hash":"ee598933707f8bb98ecbf36925f24e8a1c4bd2d6","modified":1675244682493},{"_id":"public/medias/featureimages/25.jpg","hash":"d0668539783fc615f14178644e486a6befb90c0c","modified":1675244682493},{"_id":"public/medias/featureimages/3.jpg","hash":"ceb8e0c195a7fe7420334efa114e98cd0e1c6523","modified":1675244682493},{"_id":"public/medias/featureimages/28.jpg","hash":"c73036359640a67a8b17db7ba0e968c088957ab8","modified":1675244682493},{"_id":"public/medias/avatars/jingjing.jpg","hash":"bfcab0139edb2509de984cb0a9b156879c355158","modified":1675244682493},{"_id":"public/2023/02/01/iOS-swift-混编Flutter/fluttererror2.png","hash":"19dc9ab0586378a2929bb69c318d6ec6db6d8de0","modified":1675244682493},{"_id":"public/medias/featureimages/10.jpg","hash":"66de48d963e7f221931e550b2442da0cd40cbaa8","modified":1675244682493},{"_id":"public/medias/featureimages/20.jpg","hash":"84ba9cf61045de789426eeb6333910266ce29b8c","modified":1675244682493},{"_id":"public/medias/featureimages/27.jpg","hash":"7ea6f890cc59def8b1c9f393e4ae77cd16c79aad","modified":1675244682493},{"_id":"public/medias/featureimages/26.jpg","hash":"c66a4e7a2e670b63759a091f9428ee7f971d7b56","modified":1675244682493},{"_id":"public/medias/featureimages/6.jpg","hash":"698fc46e97428d73c9d4e3d254e88b9b66fb38cd","modified":1675244682493},{"_id":"public/medias/featureimages/7.jpg","hash":"bd400da9123424afe7ba6c839be9ad7697c1245b","modified":1675244682493},{"_id":"public/medias/featureimages/1.jpg","hash":"f1d720039d654d693c32150c06c78cfc3663b0b4","modified":1675244682493},{"_id":"public/medias/featureimages/11.jpg","hash":"2b30186c6d78ed76fa5f278be57290c1bd22c96a","modified":1675244682493},{"_id":"public/medias/featureimages/18.jpg","hash":"c74ce6fa4eee122e147ec55532744f34a87ae2bf","modified":1675244682493},{"_id":"public/medias/featureimages/19.jpg","hash":"2a47d1123d9c4c6255b7b4817a582d2fa9aea808","modified":1675244682493},{"_id":"public/medias/featureimages/21.jpg","hash":"a77810cc2224446f5d4e1a857a8d480f21e81f83","modified":1675244682493},{"_id":"public/medias/featureimages/16.jpg","hash":"0801e96a2f4cbd14b2ad44547e5ffbb23822e751","modified":1675244682493},{"_id":"public/medias/featureimages/24.jpg","hash":"72bc68fb0673b84ab9f863d2979396cdc268a76c","modified":1675244682493},{"_id":"public/medias/reward/alipay.png","hash":"98faed5b838aa003f660213be764152ee348f451","modified":1675244682493},{"_id":"public/medias/reward/wechat.png","hash":"98faed5b838aa003f660213be764152ee348f451","modified":1675244682493},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1675244682493},{"_id":"public/2023/01/30/iOS-swift-数据库realm实践/realm1.png","hash":"8dea478526f67950e1d04d4f8ade74ab7cd64b2b","modified":1675244682493},{"_id":"public/2023/01/30/iOS-swift-数据库realm实践/realm2.png","hash":"9a893b602da7960abac88cbd75a913107d9ad58d","modified":1675244682493},{"_id":"public/2023/01/17/玩Android-Compose版本-项目分析/mine.jpeg","hash":"1f86a74843aaae7e80f61155a58a17da1320a614","modified":1675244682493},{"_id":"public/2023/01/31/iOS-swift-实现简易地图功能/map.png","hash":"93e267d80b97c93e48677b068f43c171ea851053","modified":1675244682493},{"_id":"public/medias/featureimages/8.jpg","hash":"f81e97edf705ab45b989b2b15d6a13c005ccaa32","modified":1675244682493},{"_id":"public/2023/01/17/玩Android-Compose版本-项目分析/首页.jpeg","hash":"c0541a828adb8491a51c67a7a11fe2d7ff057bad","modified":1675244682493},{"_id":"public/2023/01/29/iOS-swift-如何实现扫码功能/scan1.png","hash":"b06f374c408dd565191b743f0dcebfd4f6311100","modified":1675244682493},{"_id":"public/medias/featureimages/15.jpg","hash":"aff885598033614639944c7559b4849f883e2b34","modified":1675244682493},{"_id":"public/2023/01/29/iOS-swift-如何实现扫码功能/scan2.png","hash":"f77a75032260c4927cb3b674d190257fd558e208","modified":1675244682493},{"_id":"public/2023/01/27/iOS-swift-自定义View之四级地址/四级地址.gif","hash":"586e0fcfc20a5c0d870a0e5cacb85a2ec52a304e","modified":1675244682493},{"_id":"public/medias/featureimages/9.jpg","hash":"cd54b116609f5741cc7db0f7f49bf56ac356ddfb","modified":1675244682493},{"_id":"public/medias/featureimages/4.jpg","hash":"e06afe32a867f7a6e861618e0b5ac9d93cd71d05","modified":1675244682493},{"_id":"public/2023/02/02/iOS-swift-打造TabLayout效果/page1.gif","hash":"77268a4d9068e1cec74c463d8f48b766455fbbd4","modified":1675244682493},{"_id":"public/2023/01/17/玩Android-Compose版本-项目分析/闪屏页.gif","hash":"a76a77cf58af915878c1141c48d7825ef9334fe9","modified":1675244682493},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天.md","hash":"68b08de16d3c5e8718524501dc70d71e2d0b915f","modified":1675602756613},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/02_1.png","hash":"0bb5e52899e8525a4e99e6e0504fdceb2355c93d","modified":1675391991577},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/02_2.png","hash":"d2d2d179aa4d94274ec09c655c50fffa0a21eab1","modified":1675392230917},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/06_1.png","hash":"daa853b2ad02cbe13fb09cb672decfe622889f6d","modified":1675411443876},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/04_1.png","hash":"af70eec28a8b5f3d8d52e3c6f5d5193eb29c8234","modified":1675396189034},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/04_2.png","hash":"d8140afd36f15b86a75b2ee95fc8dbe8b0ff7cc8","modified":1675396299385},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/03_1.png","hash":"893e45b8182cb71957bed94d393f5bd8e21c4588","modified":1675395110051},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/01.gif","hash":"8e58cbca974df36eaeb6be958496cf962a66ce86","modified":1675389536167},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/1.2.png","hash":"e2cba370960f7db9e9dc3403c4796e3000a01393","modified":1675390328314},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/Customfont.gif","hash":"fe069f63ed300a1370dd26f57a561d2ea7ff737f","modified":1675391896108},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/5_1.png","hash":"772e91435298909bb6ea3390967967d9e770060b","modified":1675408450403},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/randomMusicColor.gif","hash":"3c270c33a91e3643ab73b62bc272a962de92d42c","modified":1675414482951},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/mylocation.gif","hash":"b873da38bdc483096dafac1a6be73ce403359f0e","modified":1675398552682},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/07.gif","hash":"1cc61f416ac9356e8efc7aefc18a8a1288565cab","modified":1675412874196},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/09.gif","hash":"c81dde760f1306c52320b2eda985b20eb4161313","modified":1675415570522},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/videobg.gif","hash":"e10661476fc51ebab41e3e1613582d11388f1d7e","modified":1675419718127},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/Carousel.gif","hash":"2a3abe3caac626316acdede1f424f133eedf0e6b","modified":1675398403350},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/snapchatmenu.gif","hash":"756c2e7f6ba7926489e59b7a5d12be81e073295b","modified":1675395610125},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/playvideo.gif","hash":"33526bedc243ba76e19b8ca2566f63e9dba1535c","modified":1675392944291},{"_id":"public/2023/02/03/iOS-swift-3天30个Swift项目之第一天/index.html","hash":"5f773bd234bc474df4d2ecb82d76070a12c17b77","modified":1675766997437},{"_id":"public/tags/30个Swift项目/index.html","hash":"26c036f37dfaac98e5fb991de0f0a2570a960db3","modified":1675766997437},{"_id":"public/2023/02/03/iOS-swift-3天30个Swift项目之第一天/02_1.png","hash":"0bb5e52899e8525a4e99e6e0504fdceb2355c93d","modified":1675422815574},{"_id":"public/2023/02/03/iOS-swift-3天30个Swift项目之第一天/02_2.png","hash":"d2d2d179aa4d94274ec09c655c50fffa0a21eab1","modified":1675422815574},{"_id":"public/2023/02/03/iOS-swift-3天30个Swift项目之第一天/06_1.png","hash":"daa853b2ad02cbe13fb09cb672decfe622889f6d","modified":1675422815574},{"_id":"public/2023/02/03/iOS-swift-3天30个Swift项目之第一天/04_1.png","hash":"af70eec28a8b5f3d8d52e3c6f5d5193eb29c8234","modified":1675422815574},{"_id":"public/2023/02/03/iOS-swift-3天30个Swift项目之第一天/04_2.png","hash":"d8140afd36f15b86a75b2ee95fc8dbe8b0ff7cc8","modified":1675422815574},{"_id":"public/2023/02/03/iOS-swift-3天30个Swift项目之第一天/03_1.png","hash":"893e45b8182cb71957bed94d393f5bd8e21c4588","modified":1675422815574},{"_id":"public/2023/02/03/iOS-swift-3天30个Swift项目之第一天/01.gif","hash":"8e58cbca974df36eaeb6be958496cf962a66ce86","modified":1675422815574},{"_id":"public/2023/02/03/iOS-swift-3天30个Swift项目之第一天/1.2.png","hash":"e2cba370960f7db9e9dc3403c4796e3000a01393","modified":1675422815574},{"_id":"public/2023/02/03/iOS-swift-3天30个Swift项目之第一天/Customfont.gif","hash":"fe069f63ed300a1370dd26f57a561d2ea7ff737f","modified":1675422815574},{"_id":"public/2023/02/03/iOS-swift-3天30个Swift项目之第一天/5_1.png","hash":"772e91435298909bb6ea3390967967d9e770060b","modified":1675422815574},{"_id":"public/2023/02/03/iOS-swift-3天30个Swift项目之第一天/randomMusicColor.gif","hash":"3c270c33a91e3643ab73b62bc272a962de92d42c","modified":1675422815574},{"_id":"public/2023/02/03/iOS-swift-3天30个Swift项目之第一天/mylocation.gif","hash":"b873da38bdc483096dafac1a6be73ce403359f0e","modified":1675422815574},{"_id":"public/2023/02/03/iOS-swift-3天30个Swift项目之第一天/07.gif","hash":"1cc61f416ac9356e8efc7aefc18a8a1288565cab","modified":1675422815574},{"_id":"public/2023/02/03/iOS-swift-3天30个Swift项目之第一天/09.gif","hash":"c81dde760f1306c52320b2eda985b20eb4161313","modified":1675422815574},{"_id":"public/2023/02/03/iOS-swift-3天30个Swift项目之第一天/videobg.gif","hash":"e10661476fc51ebab41e3e1613582d11388f1d7e","modified":1675422815574},{"_id":"public/2023/02/03/iOS-swift-3天30个Swift项目之第一天/Carousel.gif","hash":"2a3abe3caac626316acdede1f424f133eedf0e6b","modified":1675422815574},{"_id":"public/2023/02/03/iOS-swift-3天30个Swift项目之第一天/snapchatmenu.gif","hash":"756c2e7f6ba7926489e59b7a5d12be81e073295b","modified":1675422815574},{"_id":"public/2023/02/03/iOS-swift-3天30个Swift项目之第一天/playvideo.gif","hash":"33526bedc243ba76e19b8ca2566f63e9dba1535c","modified":1675422815574},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天.md","hash":"d55040d43124879d65c85ff991609911f7dd39c8","modified":1675507919690},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/25_1.png","hash":"e5a60791fc1243abc4a478a35ff5b75435eea46f","modified":1675482609161},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/18_1.png","hash":"1ac87f9053ff2ed5a29de68c9d657f9cb53044ac","modified":1675502412738},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/21_1.png","hash":"e152a1146f227e46b0e490ae4677d263abd68c3a","modified":1675477365714},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/simple login animation.gif","hash":"2857b2fa4d8e36b59e6d9d0abf25cb3b5df78d41","modified":1675476956848},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/CustomPullToRefresh.gif","hash":"9c5a13cb55babe86d3d5a9aea73413614c0e8b06","modified":1675502860649},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/TumblrMenu.gif","hash":"2162adff6efff8306db2ea9e2138d697b3fe9eff","modified":1675500745488},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/splash.gif","hash":"6ea78953a7b5fa57c238f8a439080dc31d33b45b","modified":1675482376009},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/Limit.gif","hash":"76fca7d15a5b6d73ceba0cf7df3fb1725f134b21","modified":1675502124697},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/emoji spin.gif","hash":"7d3dcc55860c4925d93b80fb340054bed5974a2b","modified":1675480416248},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/CollectionViewAnimation.gif","hash":"673c8342ad25452c9c410959f7e8b17e1f51924a","modified":1675504099419},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/cleartableviewcell.gif","hash":"4417b762ca4a0713c8880ac5b2909e1543793714","modified":1675476013491},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/AnimateTabel.gif","hash":"36e4cfc5338535fa961377ec2bdb5c30fc9dfbcc","modified":1675478784915},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/SlideMenu.gif","hash":"2cd8e2f4b7c50ed34f277dbb28ad0f7eb1c059ce","modified":1675483987157},{"_id":"public/2023/02/04/iOS-swift-3天30个swift项目之第二天/index.html","hash":"8c9c9c2e327017b450fda87cb86b918e04353951","modified":1675766997437},{"_id":"public/2023/02/04/iOS-swift-3天30个swift项目之第二天/25_1.png","hash":"e5a60791fc1243abc4a478a35ff5b75435eea46f","modified":1675507692066},{"_id":"public/2023/02/04/iOS-swift-3天30个swift项目之第二天/18_1.png","hash":"1ac87f9053ff2ed5a29de68c9d657f9cb53044ac","modified":1675507692066},{"_id":"public/2023/02/04/iOS-swift-3天30个swift项目之第二天/21_1.png","hash":"e152a1146f227e46b0e490ae4677d263abd68c3a","modified":1675507692066},{"_id":"public/2023/02/04/iOS-swift-3天30个swift项目之第二天/simple login animation.gif","hash":"2857b2fa4d8e36b59e6d9d0abf25cb3b5df78d41","modified":1675507692066},{"_id":"public/2023/02/04/iOS-swift-3天30个swift项目之第二天/CustomPullToRefresh.gif","hash":"9c5a13cb55babe86d3d5a9aea73413614c0e8b06","modified":1675507692066},{"_id":"public/2023/02/04/iOS-swift-3天30个swift项目之第二天/TumblrMenu.gif","hash":"2162adff6efff8306db2ea9e2138d697b3fe9eff","modified":1675507692066},{"_id":"public/2023/02/04/iOS-swift-3天30个swift项目之第二天/Limit.gif","hash":"76fca7d15a5b6d73ceba0cf7df3fb1725f134b21","modified":1675507692066},{"_id":"public/2023/02/04/iOS-swift-3天30个swift项目之第二天/splash.gif","hash":"6ea78953a7b5fa57c238f8a439080dc31d33b45b","modified":1675507692066},{"_id":"public/2023/02/04/iOS-swift-3天30个swift项目之第二天/emoji spin.gif","hash":"7d3dcc55860c4925d93b80fb340054bed5974a2b","modified":1675507692066},{"_id":"public/2023/02/04/iOS-swift-3天30个swift项目之第二天/CollectionViewAnimation.gif","hash":"673c8342ad25452c9c410959f7e8b17e1f51924a","modified":1675507692066},{"_id":"public/2023/02/04/iOS-swift-3天30个swift项目之第二天/cleartableviewcell.gif","hash":"4417b762ca4a0713c8880ac5b2909e1543793714","modified":1675507692066},{"_id":"public/2023/02/04/iOS-swift-3天30个swift项目之第二天/AnimateTabel.gif","hash":"36e4cfc5338535fa961377ec2bdb5c30fc9dfbcc","modified":1675507692066},{"_id":"public/2023/02/04/iOS-swift-3天30个swift项目之第二天/SlideMenu.gif","hash":"2cd8e2f4b7c50ed34f277dbb28ad0f7eb1c059ce","modified":1675507692066},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天.md","hash":"5c37aab7925bdb3c34a9eb0ba59806ddfa8ff5b6","modified":1675599197490},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/24_1.png","hash":"bb2b41aed16881794ca95b7719f28ef8d3fa04d2","modified":1675570975370},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/22.png","hash":"c34b010b9cec6e5ef4e3ff0001064bb1d2441592","modified":1675563584139},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/28_1.png","hash":"6edf1984387b98e73bbeccd2899946827a97b51b","modified":1675594108161},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/25_1.png","hash":"773bd14737e2db7db339c062d9da92290fda3dc9","modified":1675586748746},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/27_1.png","hash":"ea9e97eee69d90cdb1b490726e6db383862fd4f9","modified":1675591924094},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/23_1.png","hash":"b9fc8de9622adcad94ef5945dadf897278fa5c45","modified":1675568100839},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/25_3.png","hash":"5c1d6ce8ed889e852e1d5f42cace143f6da1737c","modified":1675587345518},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/25_2.png","hash":"2c3d029a77f7aed2aea99082509d07ac666f0433","modified":1675586961354},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/25_4.png","hash":"b2e98d6c23f6f96b9f7b468c2111a00f9ab5d7da","modified":1675587488039},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/SlideOutMenu.gif","hash":"67f04b72332ccd33618b06a1765d9db5ff3acd42","modified":1675564436057},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/Swipeable Cell.gif","hash":"edda660ecc0ac7a80451ebbb9b877956b05d1c70","modified":1675561045676},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/TapBarAnimation.gif","hash":"5fa3af6d7574027f043509c3710869cfdc95ed31","modified":1675591100133},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/CoreData.gif","hash":"b6ca53fc60b7dc879ad29f0a55f0ebba597721bf","modified":1675588296046},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/BasicAnimation.gif","hash":"4a84bc72a8b926ebbe5befa573a74fe60df1941a","modified":1675585940771},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/AvatarPicker.gif","hash":"fb9a6569ae7d4a454cd9753804b89f33c3c56f81","modified":1675595267453},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/Spotlight Search.gif","hash":"92fec9c44f4bef32f9a301cc525fda8cb8fd1b4c","modified":1675593436307},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/MosaicLayouts.gif","hash":"a46b606d28a08431d56137eaeca922ac5ac34c05","modified":1675570496443},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/wikiFace.gif","hash":"c4b1d044e92da271824606fec72368006b8a2dfb","modified":1675596283257},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/3DTouchQuickAction.gif","hash":"98ec74d9e78bb7443718f9e1befa5aeed0abacb8","modified":1675562501796},{"_id":"public/2023/02/05/iOS-swift-3天30个swift项目之第三天/index.html","hash":"bbe8d95df4570c48a9d48db7adce1a8fbf795c4d","modified":1675766997437},{"_id":"public/categories/iOS/page/2/index.html","hash":"e91a29da6b8719ca8160197c101c14dc8b152fdf","modified":1675766997437},{"_id":"public/2023/02/05/iOS-swift-3天30个swift项目之第三天/24_1.png","hash":"bb2b41aed16881794ca95b7719f28ef8d3fa04d2","modified":1675598447429},{"_id":"public/2023/02/05/iOS-swift-3天30个swift项目之第三天/22.png","hash":"c34b010b9cec6e5ef4e3ff0001064bb1d2441592","modified":1675598447429},{"_id":"public/2023/02/05/iOS-swift-3天30个swift项目之第三天/28_1.png","hash":"6edf1984387b98e73bbeccd2899946827a97b51b","modified":1675598447429},{"_id":"public/2023/02/05/iOS-swift-3天30个swift项目之第三天/25_1.png","hash":"773bd14737e2db7db339c062d9da92290fda3dc9","modified":1675598447429},{"_id":"public/2023/02/05/iOS-swift-3天30个swift项目之第三天/27_1.png","hash":"ea9e97eee69d90cdb1b490726e6db383862fd4f9","modified":1675598447429},{"_id":"public/2023/02/05/iOS-swift-3天30个swift项目之第三天/23_1.png","hash":"b9fc8de9622adcad94ef5945dadf897278fa5c45","modified":1675598447429},{"_id":"public/2023/02/05/iOS-swift-3天30个swift项目之第三天/25_3.png","hash":"5c1d6ce8ed889e852e1d5f42cace143f6da1737c","modified":1675598447429},{"_id":"public/2023/02/05/iOS-swift-3天30个swift项目之第三天/25_2.png","hash":"2c3d029a77f7aed2aea99082509d07ac666f0433","modified":1675598447429},{"_id":"public/2023/02/05/iOS-swift-3天30个swift项目之第三天/25_4.png","hash":"b2e98d6c23f6f96b9f7b468c2111a00f9ab5d7da","modified":1675598447429},{"_id":"public/2023/02/05/iOS-swift-3天30个swift项目之第三天/SlideOutMenu.gif","hash":"67f04b72332ccd33618b06a1765d9db5ff3acd42","modified":1675598447429},{"_id":"public/2023/02/05/iOS-swift-3天30个swift项目之第三天/Swipeable Cell.gif","hash":"edda660ecc0ac7a80451ebbb9b877956b05d1c70","modified":1675598447429},{"_id":"public/2023/02/05/iOS-swift-3天30个swift项目之第三天/TapBarAnimation.gif","hash":"5fa3af6d7574027f043509c3710869cfdc95ed31","modified":1675598447429},{"_id":"public/2023/02/05/iOS-swift-3天30个swift项目之第三天/CoreData.gif","hash":"b6ca53fc60b7dc879ad29f0a55f0ebba597721bf","modified":1675598447429},{"_id":"public/2023/02/05/iOS-swift-3天30个swift项目之第三天/BasicAnimation.gif","hash":"4a84bc72a8b926ebbe5befa573a74fe60df1941a","modified":1675598447429},{"_id":"public/2023/02/05/iOS-swift-3天30个swift项目之第三天/AvatarPicker.gif","hash":"fb9a6569ae7d4a454cd9753804b89f33c3c56f81","modified":1675598447429},{"_id":"public/2023/02/05/iOS-swift-3天30个swift项目之第三天/Spotlight Search.gif","hash":"92fec9c44f4bef32f9a301cc525fda8cb8fd1b4c","modified":1675598447429},{"_id":"public/2023/02/05/iOS-swift-3天30个swift项目之第三天/MosaicLayouts.gif","hash":"a46b606d28a08431d56137eaeca922ac5ac34c05","modified":1675598447429},{"_id":"public/2023/02/05/iOS-swift-3天30个swift项目之第三天/wikiFace.gif","hash":"c4b1d044e92da271824606fec72368006b8a2dfb","modified":1675598447429},{"_id":"public/2023/02/05/iOS-swift-3天30个swift项目之第三天/3DTouchQuickAction.gif","hash":"98ec74d9e78bb7443718f9e1befa5aeed0abacb8","modified":1675598447429},{"_id":"source/_posts/iOS-swift-Gitee客户端-完整项目分析之一.md","hash":"f8803904f917f927fd56043ff0ef27adcba8f002","modified":1675692964043},{"_id":"source/_posts/iOS-swift-Gitee客户端-完整项目分析之一/7.png","hash":"f5c6c3e4f9c6b0cfef559dfdf2bd22d8e6b26219","modified":1675666340569},{"_id":"source/_posts/iOS-swift-Gitee客户端-完整项目分析之一/4.png","hash":"6e23ccb82c08b3eeb51382c9f8f25948d7f8e579","modified":1675666340540},{"_id":"source/_posts/iOS-swift-Gitee客户端-完整项目分析之一/3.png","hash":"3ac252868370454d1d1dbfc9d52be89bd7a22abf","modified":1675666340534},{"_id":"source/_posts/iOS-swift-Gitee客户端-完整项目分析之一/1.png","hash":"2481a537bab85ad581ef1443bbb707a9586e8282","modified":1675666340511},{"_id":"source/_posts/iOS-swift-Gitee客户端-完整项目分析之一/6.png","hash":"e190c97b9d8c4a8e2d98ad8438f97de2b7f35504","modified":1675666340557},{"_id":"source/_posts/iOS-swift-Gitee客户端-完整项目分析之一/2.png","hash":"a2c1e1b55aee0974be4052256d6eebccc13ba03a","modified":1675666340522},{"_id":"source/_posts/iOS-swift-Gitee客户端-完整项目分析之一/5.png","hash":"967e038ab20f92db8b254ae9d570dc1943f19d0a","modified":1675666340551},{"_id":"public/2023/02/06/iOS-swift-Gitee客户端-完整项目分析之一/index.html","hash":"6182a3e8bb1b080ba278e57c6910f5e3fed0f2fa","modified":1675766997437},{"_id":"public/tags/完整项目-Gitee/index.html","hash":"58fcf05df0d52855106f428aec4f91c7d5c6c641","modified":1675666739735},{"_id":"public/2023/02/06/iOS-swift-Gitee客户端-完整项目分析之一/7.png","hash":"f5c6c3e4f9c6b0cfef559dfdf2bd22d8e6b26219","modified":1675666739735},{"_id":"public/2023/02/06/iOS-swift-Gitee客户端-完整项目分析之一/3.png","hash":"3ac252868370454d1d1dbfc9d52be89bd7a22abf","modified":1675666739735},{"_id":"public/2023/02/06/iOS-swift-Gitee客户端-完整项目分析之一/1.png","hash":"2481a537bab85ad581ef1443bbb707a9586e8282","modified":1675666739735},{"_id":"public/2023/02/06/iOS-swift-Gitee客户端-完整项目分析之一/4.png","hash":"6e23ccb82c08b3eeb51382c9f8f25948d7f8e579","modified":1675666739735},{"_id":"public/2023/02/06/iOS-swift-Gitee客户端-完整项目分析之一/6.png","hash":"e190c97b9d8c4a8e2d98ad8438f97de2b7f35504","modified":1675666739735},{"_id":"public/2023/02/06/iOS-swift-Gitee客户端-完整项目分析之一/5.png","hash":"967e038ab20f92db8b254ae9d570dc1943f19d0a","modified":1675666739735},{"_id":"public/2023/02/06/iOS-swift-Gitee客户端-完整项目分析之一/2.png","hash":"a2c1e1b55aee0974be4052256d6eebccc13ba03a","modified":1675666739735},{"_id":"source/_posts/iOS-swift-Gitee客户端-完整项目分析之一/tab1.png","hash":"871a947203d80289995d1c05a17ff50562f46b5b","modified":1675672485178},{"_id":"public/tags/完整项目-SwiftUI/index.html","hash":"9894efc4c0dc59655cdb2e08060b76f2fe3e6819","modified":1675766997437},{"_id":"public/2023/02/06/iOS-swift-Gitee客户端-完整项目分析之一/tab1.png","hash":"871a947203d80289995d1c05a17ff50562f46b5b","modified":1675692972410},{"_id":"source/_posts/Android-OpenGLES-demo-学习之一.md","hash":"c91ac596c4f595fb9737455860a94fd59dffcdd8","modified":1675766985477},{"_id":"source/_posts/Android-OpenGLES-demo-学习之一/01.png","hash":"cbf71b0730e9441eedc9d1eb67482c0a79a65012","modified":1675755222599},{"_id":"public/2023/02/07/Android-OpenGLES-demo-学习之一/index.html","hash":"63a13b9ffc25166f8f89197e9fe4f17fd2a00533","modified":1675766997437},{"_id":"public/tags/Android-OpenGLES/index.html","hash":"e1b3eee63a6f8c01e59718aeab6e1135b212dc11","modified":1675766997437},{"_id":"public/2023/02/07/Android-OpenGLES-demo-学习之一/01.png","hash":"cbf71b0730e9441eedc9d1eb67482c0a79a65012","modified":1675766997437}],"Category":[{"name":"随笔","_id":"cldlhfhym0004ivv78gp53aj0"},{"name":"Android","_id":"cldlhfhyp000civv7cmx1fhzv"},{"name":"Flutter","_id":"cldlhfhyr000pivv7d0n39ddm"},{"name":"iOS","_id":"cldlhfhys000uivv76gfi5fxl"}],"Data":[{"_id":"friends","data":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}]},{"_id":"musics","data":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}],"Page":[{"title":"about","date":"2023-01-11T08:41:10.000Z","type":"about","layout":"about","mathjax":true,"_content":"\n\n## CV\n<!-- [中文版](/medias/files/cv-zh.pdf)\n[English Version](/medias/files/cv-en.pdf) -->\n\n## 教育背景\n* <b>本科 广州大学 软件工程</b>\n2014/09 - 2018/06\n\n\n## 工作经历\n* <b>格力电子商务</b>\n2022/01 - 至今\n主要负责终端管理内部工具的开发，技术栈：Android,iOS,Flutter。\n\n* <b>魅族科技有限公司</b>\n2020/05 - 2022.1\n主要负责快应用相关开发，负责快应用引擎维护，封装快卡片sdk等。\n\n\n## 联系方式\n* <b>电子邮箱</b>\nJason211241203@gmail.com\n1211241203@qq.com\n\n\n<!-- ![](/medias/contact.jpg) -->","source":"about/index.md","raw":"---\ntitle: about\ndate: 2023-01-11 16:41:10\ntype: \"about\"\nlayout: \"about\"\nmathjax: true\n---\n\n\n## CV\n<!-- [中文版](/medias/files/cv-zh.pdf)\n[English Version](/medias/files/cv-en.pdf) -->\n\n## 教育背景\n* <b>本科 广州大学 软件工程</b>\n2014/09 - 2018/06\n\n\n## 工作经历\n* <b>格力电子商务</b>\n2022/01 - 至今\n主要负责终端管理内部工具的开发，技术栈：Android,iOS,Flutter。\n\n* <b>魅族科技有限公司</b>\n2020/05 - 2022.1\n主要负责快应用相关开发，负责快应用引擎维护，封装快卡片sdk等。\n\n\n## 联系方式\n* <b>电子邮箱</b>\nJason211241203@gmail.com\n1211241203@qq.com\n\n\n<!-- ![](/medias/contact.jpg) -->","updated":"2023-02-01T06:13:34.882Z","path":"about/index.html","comments":1,"_id":"cldlhfhyj0000ivv79n39ax8z","content":"<h2 id=\"CV\"><a href=\"#CV\" class=\"headerlink\" title=\"CV\"></a>CV</h2><!-- [中文版](/medias/files/cv-zh.pdf)\n[English Version](/medias/files/cv-en.pdf) -->\n\n<h2 id=\"教育背景\"><a href=\"#教育背景\" class=\"headerlink\" title=\"教育背景\"></a>教育背景</h2><ul>\n<li><b>本科 广州大学 软件工程</b><br>2014&#x2F;09 - 2018&#x2F;06</li>\n</ul>\n<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2><ul>\n<li><p><b>格力电子商务</b><br>2022&#x2F;01 - 至今<br>主要负责终端管理内部工具的开发，技术栈：Android,iOS,Flutter。</p>\n</li>\n<li><p><b>魅族科技有限公司</b><br>2020&#x2F;05 - 2022.1<br>主要负责快应用相关开发，负责快应用引擎维护，封装快卡片sdk等。</p>\n</li>\n</ul>\n<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><ul>\n<li><b>电子邮箱</b><br><a href=\"mailto:&#x4a;&#97;&#115;&#111;&#x6e;&#50;&#x31;&#49;&#50;&#x34;&#49;&#50;&#x30;&#51;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;\">&#x4a;&#97;&#115;&#111;&#x6e;&#50;&#x31;&#49;&#50;&#x34;&#49;&#50;&#x30;&#51;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;</a><br><a href=\"mailto:&#49;&#50;&#49;&#49;&#50;&#x34;&#49;&#50;&#x30;&#x33;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#x6d;\">&#49;&#50;&#49;&#49;&#50;&#x34;&#49;&#50;&#x30;&#x33;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#x6d;</a></li>\n</ul>\n<!-- ![](/medias/contact.jpg) -->","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"CV\"><a href=\"#CV\" class=\"headerlink\" title=\"CV\"></a>CV</h2><!-- [中文版](/medias/files/cv-zh.pdf)\n[English Version](/medias/files/cv-en.pdf) -->\n\n<h2 id=\"教育背景\"><a href=\"#教育背景\" class=\"headerlink\" title=\"教育背景\"></a>教育背景</h2><ul>\n<li><b>本科 广州大学 软件工程</b><br>2014&#x2F;09 - 2018&#x2F;06</li>\n</ul>\n<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2><ul>\n<li><p><b>格力电子商务</b><br>2022&#x2F;01 - 至今<br>主要负责终端管理内部工具的开发，技术栈：Android,iOS,Flutter。</p>\n</li>\n<li><p><b>魅族科技有限公司</b><br>2020&#x2F;05 - 2022.1<br>主要负责快应用相关开发，负责快应用引擎维护，封装快卡片sdk等。</p>\n</li>\n</ul>\n<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><ul>\n<li><b>电子邮箱</b><br><a href=\"mailto:&#x4a;&#97;&#115;&#111;&#x6e;&#50;&#x31;&#49;&#50;&#x34;&#49;&#50;&#x30;&#51;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;\">&#x4a;&#97;&#115;&#111;&#x6e;&#50;&#x31;&#49;&#50;&#x34;&#49;&#50;&#x30;&#51;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;</a><br><a href=\"mailto:&#49;&#50;&#49;&#49;&#50;&#x34;&#49;&#50;&#x30;&#x33;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#x6d;\">&#49;&#50;&#49;&#49;&#50;&#x34;&#49;&#50;&#x30;&#x33;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#x6d;</a></li>\n</ul>\n<!-- ![](/medias/contact.jpg) -->"},{"title":"404","date":"2019-07-19T08:41:10.000Z","type":"404","layout":"404","description":"你来到了没有知识的荒原 :(","_content":"","source":"404.md","raw":"---\ntitle: 404\ndate: 2019-07-19 16:41:10\ntype: \"404\"\nlayout: \"404\"\ndescription: \"你来到了没有知识的荒原 :(\"\n---\n","updated":"2023-02-01T06:06:16.183Z","path":"404.html","comments":1,"_id":"cldlhfhyl0002ivv7303o40p3","content":"","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":""},{"title":"archives","date":"2023-01-11T08:39:20.000Z","type":"archives","layout":"archives","_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2023-01-11 16:39:20\ntype: \"archives\"\nlayout: \"archives\"\n---","updated":"2023-02-01T06:06:16.249Z","path":"archives/index.html","comments":1,"_id":"cldlhfhyn0006ivv7grajc7v1","content":"","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":""},{"title":"contact","date":"2023-01-11T09:17:02.000Z","type":"contact","layout":"contact","_content":"\n# 欢迎留言\n大家有任何问题，都可以在评论区给我留言。\n\n我很忙啦，如果不是很麻烦的问题就直接在评论区留言啦。\n\n# 友链交换\n想要交换友链的小伙伴，欢迎在评论区留言，留言格式：\n* **名称：**你的博客名称\n* **地址：**你的博客地址\n* **简介：**一句话简介\n* **头像：**你的头像地址\n","source":"contact/index.md","raw":"---\ntitle: contact\ndate: 2023-01-11 17:17:02\ntype: \"contact\"\nlayout: \"contact\"\n---\n\n# 欢迎留言\n大家有任何问题，都可以在评论区给我留言。\n\n我很忙啦，如果不是很麻烦的问题就直接在评论区留言啦。\n\n# 友链交换\n想要交换友链的小伙伴，欢迎在评论区留言，留言格式：\n* **名称：**你的博客名称\n* **地址：**你的博客地址\n* **简介：**一句话简介\n* **头像：**你的头像地址\n","updated":"2023-02-01T06:06:16.249Z","path":"contact/index.html","comments":1,"_id":"cldlhfhyo0008ivv7df3t93vh","content":"<h1 id=\"欢迎留言\"><a href=\"#欢迎留言\" class=\"headerlink\" title=\"欢迎留言\"></a>欢迎留言</h1><p>大家有任何问题，都可以在评论区给我留言。</p>\n<p>我很忙啦，如果不是很麻烦的问题就直接在评论区留言啦。</p>\n<h1 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h1><p>想要交换友链的小伙伴，欢迎在评论区留言，留言格式：</p>\n<ul>\n<li><strong>名称：</strong>你的博客名称</li>\n<li><strong>地址：</strong>你的博客地址</li>\n<li><strong>简介：</strong>一句话简介</li>\n<li><strong>头像：</strong>你的头像地址</li>\n</ul>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h1 id=\"欢迎留言\"><a href=\"#欢迎留言\" class=\"headerlink\" title=\"欢迎留言\"></a>欢迎留言</h1><p>大家有任何问题，都可以在评论区给我留言。</p>\n<p>我很忙啦，如果不是很麻烦的问题就直接在评论区留言啦。</p>\n<h1 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h1><p>想要交换友链的小伙伴，欢迎在评论区留言，留言格式：</p>\n<ul>\n<li><strong>名称：</strong>你的博客名称</li>\n<li><strong>地址：</strong>你的博客地址</li>\n<li><strong>简介：</strong>一句话简介</li>\n<li><strong>头像：</strong>你的头像地址</li>\n</ul>\n"},{"title":"friends","date":"2023-01-11T08:42:10.000Z","type":"friends","layout":"friends","_content":"\n# 友链交换\n想要交换友链的小伙伴，欢迎在留言板留言，留言格式：\n* **名称：**你的博客名称\n* **地址：**你的博客地址\n* **简介：**一句话简介\n* **头像：**你的头像地址\n\n\n","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2023-01-11 16:42:10\ntype: \"friends\"\nlayout: \"friends\"\n---\n\n# 友链交换\n想要交换友链的小伙伴，欢迎在留言板留言，留言格式：\n* **名称：**你的博客名称\n* **地址：**你的博客地址\n* **简介：**一句话简介\n* **头像：**你的头像地址\n\n\n","updated":"2023-02-01T06:06:16.250Z","path":"friends/index.html","comments":1,"_id":"cldlhfhyo000aivv7a15x2erl","content":"<h1 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h1><p>想要交换友链的小伙伴，欢迎在留言板留言，留言格式：</p>\n<ul>\n<li><strong>名称：</strong>你的博客名称</li>\n<li><strong>地址：</strong>你的博客地址</li>\n<li><strong>简介：</strong>一句话简介</li>\n<li><strong>头像：</strong>你的头像地址</li>\n</ul>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h1 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h1><p>想要交换友链的小伙伴，欢迎在留言板留言，留言格式：</p>\n<ul>\n<li><strong>名称：</strong>你的博客名称</li>\n<li><strong>地址：</strong>你的博客地址</li>\n<li><strong>简介：</strong>一句话简介</li>\n<li><strong>头像：</strong>你的头像地址</li>\n</ul>\n"},{"title":"categories","date":"2023-01-11T08:39:20.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2023-01-11 16:39:20\ntype: \"categories\"\nlayout: \"categories\"\n---","updated":"2023-02-01T06:06:16.249Z","path":"categories/index.html","comments":1,"_id":"cldlhfhyp000fivv74jt517k6","content":"","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":""},{"title":"tags","date":"2023-01-11T08:40:27.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2023-01-11 16:40:27\ntype: \"tags\"\nlayout: \"tags\"\n---","updated":"2023-02-01T06:06:16.250Z","path":"tags/index.html","comments":1,"_id":"cldlhfhyp000hivv77eu8beaj","content":"","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":""}],"Post":[{"title":"第一篇博客","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-01-11T07:27:31.000Z","password":null,"summary":null,"_content":"\n> 既然选择了，便不顾风雨兼程！\n\n![](/medias/contact.jpg)\n\n## When？什么时候开始写的？\n记得第一次写博客是 2017 年了，在 博客园上面，当时因为在跟同学自主创业，自己从0开始撸一个App，团队规模很小，一个iOS，一个Android，我就负责Android，然后一个后端，一个跑业务，主体上就这个4个人。当时为了方便自己学习，经常写一些博客记录，也是一个老大哥推荐我去写写博客做记录。一直到工作前都经常写，但总觉得博客园编写起来很麻烦，风格也不是自己喜欢的样式，后来逐渐放弃。\n其实毕业设计前帮一个同学搞了一个个人博客，本来我想做毕业设计的，结果用自主创业做的App也可以当毕业设计，两全其美，可惜自主创业的想法不错，但没有坚持下去，资金问题，后面大家也找工作去了。\n\n工作后，又有一个老大哥，推荐使用印象笔记，我试了下还挺好用，这一用就是几年，但是自己写的东西没有跟别人分享始终觉得还是不够，知识本来就是互相分享的，知识需要一起讨论才能起火花。\n\n\n## Why？为什么会想起来写博客？\n一直都想写博客，特别是看到别人的文章如此有条理，思维如此清晰，膜拜大佬们。所以现在刚好github有这种部署的能力，完全可以实现个人博客。那就开始吧。\n\n\n\n","source":"_posts/5w2h-godweiyang.md","raw":"---\ntitle: 第一篇博客\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-01-11 15:27:31\npassword:\nsummary:\ntags:\n- 博客\ncategories:\n- 随笔\n---\n\n> 既然选择了，便不顾风雨兼程！\n\n![](/medias/contact.jpg)\n\n## When？什么时候开始写的？\n记得第一次写博客是 2017 年了，在 博客园上面，当时因为在跟同学自主创业，自己从0开始撸一个App，团队规模很小，一个iOS，一个Android，我就负责Android，然后一个后端，一个跑业务，主体上就这个4个人。当时为了方便自己学习，经常写一些博客记录，也是一个老大哥推荐我去写写博客做记录。一直到工作前都经常写，但总觉得博客园编写起来很麻烦，风格也不是自己喜欢的样式，后来逐渐放弃。\n其实毕业设计前帮一个同学搞了一个个人博客，本来我想做毕业设计的，结果用自主创业做的App也可以当毕业设计，两全其美，可惜自主创业的想法不错，但没有坚持下去，资金问题，后面大家也找工作去了。\n\n工作后，又有一个老大哥，推荐使用印象笔记，我试了下还挺好用，这一用就是几年，但是自己写的东西没有跟别人分享始终觉得还是不够，知识本来就是互相分享的，知识需要一起讨论才能起火花。\n\n\n## Why？为什么会想起来写博客？\n一直都想写博客，特别是看到别人的文章如此有条理，思维如此清晰，膜拜大佬们。所以现在刚好github有这种部署的能力，完全可以实现个人博客。那就开始吧。\n\n\n\n","slug":"5w2h-godweiyang","published":1,"updated":"2023-02-01T06:06:16.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlhfhyk0001ivv74audan6c","content":"<blockquote>\n<p>既然选择了，便不顾风雨兼程！</p>\n</blockquote>\n<p><img src=\"/medias/contact.jpg\"></p>\n<h2 id=\"When？什么时候开始写的？\"><a href=\"#When？什么时候开始写的？\" class=\"headerlink\" title=\"When？什么时候开始写的？\"></a>When？什么时候开始写的？</h2><p>记得第一次写博客是 2017 年了，在 博客园上面，当时因为在跟同学自主创业，自己从0开始撸一个App，团队规模很小，一个iOS，一个Android，我就负责Android，然后一个后端，一个跑业务，主体上就这个4个人。当时为了方便自己学习，经常写一些博客记录，也是一个老大哥推荐我去写写博客做记录。一直到工作前都经常写，但总觉得博客园编写起来很麻烦，风格也不是自己喜欢的样式，后来逐渐放弃。<br>其实毕业设计前帮一个同学搞了一个个人博客，本来我想做毕业设计的，结果用自主创业做的App也可以当毕业设计，两全其美，可惜自主创业的想法不错，但没有坚持下去，资金问题，后面大家也找工作去了。</p>\n<p>工作后，又有一个老大哥，推荐使用印象笔记，我试了下还挺好用，这一用就是几年，但是自己写的东西没有跟别人分享始终觉得还是不够，知识本来就是互相分享的，知识需要一起讨论才能起火花。</p>\n<h2 id=\"Why？为什么会想起来写博客？\"><a href=\"#Why？为什么会想起来写博客？\" class=\"headerlink\" title=\"Why？为什么会想起来写博客？\"></a>Why？为什么会想起来写博客？</h2><p>一直都想写博客，特别是看到别人的文章如此有条理，思维如此清晰，膜拜大佬们。所以现在刚好github有这种部署的能力，完全可以实现个人博客。那就开始吧。</p>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<blockquote>\n<p>既然选择了，便不顾风雨兼程！</p>\n</blockquote>\n<p><img src=\"/medias/contact.jpg\"></p>\n<h2 id=\"When？什么时候开始写的？\"><a href=\"#When？什么时候开始写的？\" class=\"headerlink\" title=\"When？什么时候开始写的？\"></a>When？什么时候开始写的？</h2><p>记得第一次写博客是 2017 年了，在 博客园上面，当时因为在跟同学自主创业，自己从0开始撸一个App，团队规模很小，一个iOS，一个Android，我就负责Android，然后一个后端，一个跑业务，主体上就这个4个人。当时为了方便自己学习，经常写一些博客记录，也是一个老大哥推荐我去写写博客做记录。一直到工作前都经常写，但总觉得博客园编写起来很麻烦，风格也不是自己喜欢的样式，后来逐渐放弃。<br>其实毕业设计前帮一个同学搞了一个个人博客，本来我想做毕业设计的，结果用自主创业做的App也可以当毕业设计，两全其美，可惜自主创业的想法不错，但没有坚持下去，资金问题，后面大家也找工作去了。</p>\n<p>工作后，又有一个老大哥，推荐使用印象笔记，我试了下还挺好用，这一用就是几年，但是自己写的东西没有跟别人分享始终觉得还是不够，知识本来就是互相分享的，知识需要一起讨论才能起火花。</p>\n<h2 id=\"Why？为什么会想起来写博客？\"><a href=\"#Why？为什么会想起来写博客？\" class=\"headerlink\" title=\"Why？为什么会想起来写博客？\"></a>Why？为什么会想起来写博客？</h2><p>一直都想写博客，特别是看到别人的文章如此有条理，思维如此清晰，膜拜大佬们。所以现在刚好github有这种部署的能力，完全可以实现个人博客。那就开始吧。</p>\n"},{"title":"Android google samples nowinandroid app模块流程分析","date":"2023-01-15T03:53:19.000Z","top":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n> googe samples之 nowinandroid项目地址：[https://github.com/android/nowinandroid](https://github.com/android/nowinandroid)\n\n### 1.app模块build.gradle文件配置\n```Groovy\nplugins {\n    id(\"nowinandroid.android.application\")\n    id(\"nowinandroid.android.application.compose\")\n    id(\"nowinandroid.android.application.jacoco\")\n    id(\"nowinandroid.android.hilt\")\n    id(\"jacoco\")\n    id(\"nowinandroid.firebase-perf\")\n}\n```\n引入了application插件，compose插件，jacoco插件，hilt插件，firebase插件\n\n依赖项：\n```Groovy\n    implementation(project(\":feature:interests\"))\n    implementation(project(\":feature:foryou\"))\n    implementation(project(\":feature:bookmarks\"))\n    implementation(project(\":feature:topic\"))\n    implementation(project(\":feature:settings\"))\n\n    implementation(project(\":core:common\"))\n    implementation(project(\":core:ui\"))\n    implementation(project(\":core:designsystem\"))\n    implementation(project(\":core:data\"))\n    implementation(project(\":core:model\"))\n\n    implementation(project(\":sync:work\"))\n```\nfeature文件夹下是app模块的界面上拆分组件。\n如feature_interests 就是兴趣tab\nfeature_foryou 就是第一个tab\nfeature_bookmarks 是书签模块\n等等\n\n下面的core就是核心模块了，有通用组件，ui组件，设计系统，数据区\n\n然后sync_work是一些工具module了。\n\n### 2.清单文件\n```xml\n    <application\n        android:name=\".NiaApplication\"\n        android:allowBackup=\"true\"\n        android:enableOnBackInvokedCallback=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Nia.Splash\">\n<!--        Profileable 是 Android 10 中引入的清单配置，可用于 CPU 和内存分析任务。使用 profileable 标志而不是 debuggable 标志具有降低性能开销的关键优势；-->\n        <profileable android:shell=\"true\" tools:targetApi=\"q\" />\n\n        <activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n\n```\n这里很简单，就一个Application自定义的，一个首页，说明这个App就一个Activity。\n这里引入了一个profileable标签，是Android10后引入的，可以用于CPU和内存分析任务。\n\n### 3.自定义Application\n这里App开始启动了。\n首先是用了一个HiltAndroidApp的注解。\n这个是类似Dragger的依赖注解框架，这里要求在Application用这个注解。\n关于Hilt用法可参考：[https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn](https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn)\n\n这里在Application里面初始化了一个东西：\n`Sync.initialize(context = this)`\n作用就是初始化Sync三方库。\n\n里面是这样走的：\n```Kotlin\n  AppInitializer.getInstance(context)\n            .initializeComponent(SyncInitializer::class.java)\n```\nAppInitializer是google的Jetpack下的startup中的类成员，关于这个用法可以参考下郭霖的博客：[https://blog.csdn.net/guolin_blog/article/details/108026357](https://blog.csdn.net/guolin_blog/article/details/108026357)\n\n为什么要引入这个同步的库呢？\n/**\n * Registers work to sync the data layer periodically on app startup.\n * 初始化三方库 这里是WorkManager，主要用于\n * Android出于设备电量的考虑，为开发者提供了WorkManager，旨在将一些不需要及时完成的任务交给它来完成。\n * 虽然WorkManager宣称，能够保证任务得到执行，但我在真实设备中，发现应用程序彻底退出与重启设备，任务都没有再次执行。\n * 查阅了相关资料，发现这应该与系统有关系。我们前面也提到了，WorkManager会根据系统的版本，\n * 决定采用JobScheduler或是AlarmManager+Broadcast Receivers来完成任务。\n * 但是这些API很可能会受到OEM系统的影响。比如，假设某个系统不允许AlarmManager自动唤起，那么WorkManager很可能就无法正常使用。\n */\n \n ### 4.MainActivity 参数定义\n Application走完，就到了Activity了。\n 首先是两个注解：\n\n1.  @OptIn(ExperimentalMaterial3WindowSizeClassApi::class)\n Opt-in 是 Kotlin 标准库中的一个方法，用于声明使用某些 API 需要明确的同意。\n  该功能可以让开发者告知 API 使用者使用某些 API 需要一些特定的条件，如果使用者已经知晓则需要明确声明依旧使用（Opt-in）才能继续使用该 API。\n  例如，某些 API 尚处于测试阶段，未来可能会发生变化；亦或是我前言中提到的场景，都非常适合使用该方法。\n  如果我们声明了某个方法（functiuon）或类(class)需要 Opt-in ，则IDE或编译器会发出警告，要求使用者明确标注需要使用（Opt-in）。\n  参考文档：[https://juejin.cn/post/7157950373250990093](https://juejin.cn/post/7157950373250990093)\n\n2. @AndroidEntryPoint\n在要使用依赖注入的类上方添加@AndroidEntryPoint注解\n参考文档：[https://www.jianshu.com/p/22a36660a656](https://www.jianshu.com/p/22a36660a656)\n\n然后声明了两个注入的变量：\n```Kotlin\n/**\n     * Lazily inject [JankStats], which is used to track jank throughout the app.\n     * JankStats 是首个专为在用户设备上检测及报告应用的性能问题而构建的 AndroidX 库。\n     * JankStats 是占用空间相对较小的 API，主要有三大目标: 捕获每帧的性能信息、在用户设备 (不仅是开发设备) 上运行、以及在应用出现性能问题时启用检测，并报告所发生的情况\n     *\n     * 在Dagger中Lazy可以将要注入的依赖项转变为懒加载模式，这样注入的依赖项，只有在需要使用时，\n     * 才会调用对应的依赖生成方法。懒加载的实现很简单，只需要在注入位置将依赖项的类型设置为Lazy接口的类型参数即可。\n     *\n     * 构造函数在di 文件夹下的 JankStatsModule 下\n     */\n    @Inject\n    lateinit var lazyStats: dagger.Lazy<JankStats>\n\n    /**\n     * 自定义网络监视器 这个是一个接口 应该也是测试用的\n     */\n    @Inject\n    lateinit var networkMonitor: NetworkMonitor\n\n```\n \n 关于lazyStats怎么初始化的？在项目di文件夹下有个JankStatsModule\n \n```Kotlin\n/**\n * 这里的目标是生产一个JankStats对象\n *\n * 怎么生产呢，需要2个构造参数\n * 1.JankStats.OnFrameListener\n * 2.Window\n *\n * window需要依赖activity，这里就需要 ActivityComponent了\n * 这个JankStats对象的生命周期设定为Activity级别\n */\n@Module\n@InstallIn(ActivityComponent::class)\nobject JankStatsModule {\n    @Provides\n    fun providesOnFrameListener(): JankStats.OnFrameListener {\n        return JankStats.OnFrameListener { frameData ->\n            // Make sure to only log janky frames.\n            if (frameData.isJank) {\n                // We're currently logging this but would better report it to a backend.\n                Log.v(\"NiA Jank\", frameData.toString())\n            }\n        }\n    }\n\n    @Provides\n    fun providesWindow(activity: Activity): Window {\n        return activity.window\n    }\n\n    @Provides\n    fun providesJankStats(\n        window: Window,\n        frameListener: JankStats.OnFrameListener\n    ): JankStats {\n        return JankStats.createAndTrack(window, frameListener)\n    }\n}\n```\n这里生产了  一个JankStats对象。\n\n关于网络监视器如何初始化的呢？\n这个网络监视器是一个接口来的：\n```Kotlin\n/**\n * Utility for reporting app connectivity status\n */\ninterface NetworkMonitor {\n    val isOnline: Flow<Boolean>\n}\n\n```\n一直没找到如何实例化的地方。\n不过再其它模块，core下的data.di文件夹下发现了另外一个DataModule下有如下代码：\n```Kotlin\n\n    @Binds\n    fun bindsNetworkMonitor(\n        networkMonitor: ConnectivityManagerNetworkMonitor\n    ): NetworkMonitor\n```\n这里貌似可以生产一个NetworkMonitor对象。\n但怎么关联起来的呢？\n\n这个我确实不清楚hilt的用法，而且这个DataModule理应需要在Application配置，但也没找到相关依赖，可能hilt对加上这种注解能全局自动生成依赖代码也说不定。反正这里的网络监视器应该就是这个ConnectivityManagerNetworkMonitor 主要逻辑也在这里。\n\n第三个变量是viewModel\n` val viewModel: MainActivityViewModel by viewModels()`\n这个用法类似：\n`ViewModelProvider(this).get(MainActivityViewModel::class.java)`\n\n\n### 5.首页生命周期-onCreate\n继续走，第一行是 适配闪屏页 installSplashScreen()\n关于闪屏页可参考文档：[https://blog.csdn.net/guolin_blog/article/details/120275319](https://blog.csdn.net/guolin_blog/article/details/120275319)（郭霖）\n\n然后这里监听了一个密封接口中的 Loading 状态，\n密封接口定义如下：\n```Kotlin\n/**\n * 首页ui 状态的密封类，有加载中和成功的状态\n * 密封接口 类似枚举类型，说明有Loading状态和成功状态\n * 表示受限制的类层次结构\n */\nsealed interface MainActivityUiState {\n    object Loading : MainActivityUiState\n    data class Success(val userData: UserData) : MainActivityUiState\n}\n```\n很明显这里Loading实现了这个接口，Success也实现了这个接口。\n\n在onCreate监听了这个Loading类：\n```Kotlin\n\n        /**\n         * mutableStateOf 表明某个变量是有状态的，对变量进行监听，当状态改变时，触发重绘。\n         * remember --- 记录变量的值，使得下次使用改变量时不进行初始化。\n         * 使用 remember 存储对象的可组合项会创建内部状态，使该可组合项有状态。\n         * remember 会为函数提供存储空间，将 remember 计算的值储存，当 remember 的键改变的时候会进行重新计算值并储存。\n         * rememberSaveable --- 在这里顺带提一下,rememberSaveable 可以在重组后保持状态,也可以在重新创建 activity 和进程后保持状态。\n         */\n        var uiState: MainActivityUiState by mutableStateOf(Loading)\n```\n\n然后开启一个携程，拿用户数据：\n```Kotlin\n // Activity生命周期内使用携程\n        lifecycleScope.launch {\n            // Lifecycle.State.STARTED: 表示只有在Activity处于Started状态的情况下，协程中的代码才会执行。\n            lifecycle.repeatOnLifecycle(Lifecycle.State.STARTED) {\n                viewModel.uiState\n                    .onEach {\n                        uiState = it\n                    }\n                    .collect() // 走collect方法才代表执行携程\n            }\n        }\n```\n拿到数据后，才回去更新uiState对象。\n\n就是说uiState会有上面密封接口定义的两种类型。\n\n当监听到uiState变化后会走：\n```Kotlin\n /**\n         * 如果网络请求正在请求loading状态，就还是显示闪屏，如果拿到数据了就不需要闪屏了\n         */\n        splashScreen.setKeepOnScreenCondition {\n            when (uiState) {\n                Loading -> true\n                is Success -> false\n            }\n        }\n```\n闪屏会去除掉。\n\n下面开启沉浸式状态栏：\n```Kotlin\n  /**\n         * 第二参数decorFitsSystemWindows表示是否沉浸，false 表示沉浸，true表示不沉浸\n         */\n        WindowCompat.setDecorFitsSystemWindows(window, false)\n```\n\n然后就是内容区，compose设置内容区了\n一个setContent的函数，太长了，就不全部贴图，挨个分析。\n\n1.首先获取一个systemUIController\n```Kotlin\n /**\n             * 开发者若想在 Compose 布局中控制 System UI，就必须获取 SystemUiController 对象。\n             * 通过该库提供 rememberSystemUiController 函数，开发者可以获取当前操作系统（目前仅支持 Android 系统）的  SystemUiController 对象。\n             */\n            val systemUiController = rememberSystemUiController()\n```\n\n2.是否使用深色主题，用户可以自己选\n```Kotlin\n /**\n             * 是否使用深色主题，入参当前ui状态\n             */\n            val darkTheme = shouldUseDarkTheme(uiState)\n            \n```\n\n内部实现：\n```Kotlin\n/**\n * Returns `true` if dark theme should be used, as a function of the [uiState] and the\n * current system context.\n * 调用@Composable 函数的函数必须用@Composable 注解标记\n */\n@Composable\nprivate fun shouldUseDarkTheme(\n    uiState: MainActivityUiState,\n): Boolean = when (uiState) {\n    /**\n     * isSystemInDarkTheme 根据系统来，加载中状态\n     */\n    Loading -> isSystemInDarkTheme()\n    is Success -> when (uiState.userData.darkThemeConfig) {\n        /**\n         * 成功状态下，根据用户配置的数据来展示，如果跟随系统那就跟随，如果用户主动设置了某一种，那就成功时选择\n         */\n        DarkThemeConfig.FOLLOW_SYSTEM -> isSystemInDarkTheme()\n        DarkThemeConfig.LIGHT -> false\n        DarkThemeConfig.DARK -> true\n    }\n}\n```\n\n然后开启一个DisposableEffect来关联上面这两个对象：\n```Kotlin\n  /**\n             * disposable，顾名思义，这就是一个自带清理作用的Effect\n             */\n            DisposableEffect(systemUiController, darkTheme) {\n                // 否与导航栏图标+内容是否“黑暗\"\n                systemUiController.systemBarsDarkContentEnabled = !darkTheme\n                onDispose {}\n            }\n```\n\n最后，开始设置App主题了：\n```Kotlin\n  /**\n             * 主题配置，是否暗色，判断用户是否有自己选择\n             * 是否用Android主题\n             * 下面这些代码才是内容区的布局，上面MainActivityUiState 这个只是拿用户的持久化数据，槽了\n             */\n            NiaTheme(\n                darkTheme = darkTheme,\n                androidTheme = shouldUseAndroidTheme(uiState)\n            ) {\n                // NiaApp是一个闭包，作为第三个参数\n                NiaApp(\n                    /**\n                     * 窗口大小类，获取一个WindowSizeClass 这个实例\n                     */\n                    windowSizeClass = calculateWindowSizeClass(this),\n                    /**\n                     * 网络监视器，前面注入的\n                     */\n                    networkMonitor = networkMonitor,\n                )\n            }\n```\n\n里面的闭包 NiaApp也就是开启了我们的App。\n\n### 6.首页其它生命周期\n```Kotlin\n  override fun onResume() {\n        super.onResume()\n        /**\n         * 跟踪性能\n         */\n        lazyStats.get().isTrackingEnabled = true\n    }\n\n    override fun onPause() {\n        super.onPause()\n        /**\n         * 去除跟踪\n         */\n        lazyStats.get().isTrackingEnabled = false\n    }\n```\n\nMainActivity内容就这么多了，非常指简洁。\n布局交给NiaApp类处理了。\n\n其它对象初始化交给hilt处理了。\n\n主要就只开了个协程获取用户数据，而且优化闪屏页和loading的显示。\n\n### 7.NiaTheme主题设置\n先是主题颜色：\n```Kotlin\n // 主题颜色\n    val colorScheme = when {\n        // 判断当前 android主题是暗色还是浅色\n        androidTheme -> if (darkTheme) DarkAndroidColorScheme else LightAndroidColorScheme\n        // 没有禁用动态主题并且支持动态主题\n        !disableDynamicTheming && supportsDynamicTheming() -> {\n            val context = LocalContext.current\n            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)\n        }\n        // 其它情况\n        else -> if (darkTheme) DarkDefaultColorScheme else LightDefaultColorScheme\n    }\n```\n\n渐变色:\n```Kotlin\n    // Gradient colors 渐变色\n    // 空渐变色\n    val emptyGradientColors = GradientColors(container = colorScheme.surfaceColorAtElevation(2.dp))\n    // 默认渐变色\n    val defaultGradientColors = GradientColors(\n        top = colorScheme.inverseOnSurface,\n        bottom = colorScheme.primaryContainer,\n        container = colorScheme.surface\n    )\n    // 渐变色\n    val gradientColors = when {\n        androidTheme -> if (darkTheme) DarkAndroidGradientColors else LightAndroidGradientColors\n        !disableDynamicTheming && supportsDynamicTheming() -> emptyGradientColors\n        else -> defaultGradientColors\n    }\n```\n\n最终设置到MaterialTheme里面：\n```Kotlin\n   // Composition locals\n    CompositionLocalProvider(\n        LocalGradientColors provides gradientColors,\n        LocalBackgroundTheme provides backgroundTheme\n    ) {\n        MaterialTheme(\n            colorScheme = colorScheme,\n            typography = NiaTypography,\n            content = content\n        )\n    }\n```\n\n### 8.NiaApp状态定义\n\n首先创建一个NiaApp实例。\n入参：窗口大小类，网络监视器\n```Kotlin\n NiaApp(\n                    /**\n                     * 窗口大小类，获取一个WindowSizeClass 这个实例\n                     */\n                    windowSizeClass = calculateWindowSizeClass(this),\n                    /**\n                     * 网络监视器，前面注入的\n                     */\n                    networkMonitor = networkMonitor,\n                )\n```\n\n这里是App首页ui样式。\n\n这里用到的状态作为第三个参数，作为app状态记录。\n\n函数定义如下：\n```Kotlin\n@OptIn(\n    ExperimentalMaterial3Api::class,\n    ExperimentalLayoutApi::class,\n    ExperimentalComposeUiApi::class,\n    ExperimentalLifecycleComposeApi::class\n)\n@Composable\nfun NiaApp(\n    windowSizeClass: WindowSizeClass,\n    networkMonitor: NetworkMonitor,\n    /**\n     * app状态记录\n     */\n    appState: NiaAppState = rememberNiaAppState(\n        networkMonitor = networkMonitor,\n        windowSizeClass = windowSizeClass\n    ),\n) \n```\n这里第三个参数已经默认实现了。\n\n就是用于app状态记录，调用了一个自定义的rememberNiaAppState方法。\n```Kotlin\n@Composable\nfun rememberNiaAppState(\n    windowSizeClass: WindowSizeClass,\n    networkMonitor: NetworkMonitor,\n    coroutineScope: CoroutineScope = rememberCoroutineScope(),\n    /**\n     * 导航控制器\n     */\n    navController: NavHostController = rememberNavController()\n): NiaAppState {\n    NavigationTrackingSideEffect(navController)\n    /**\n     * remember 里面参数可以任意，闭包里面的东西，就是remember返回的东西\n     */\n    return remember(navController, coroutineScope, windowSizeClass, networkMonitor) {\n        NiaAppState(navController, coroutineScope, windowSizeClass, networkMonitor)\n    }\n}\n```\n这里默认实现了协程作用域，导航控制器，需要返回一个NiaAppState变量。\n\n这里通过remember闭包来返回这个变量。\n\n这个NiaAppState定义如下：\n```Kotlin\n/**\n * 主要用于类似LiveData保存的数据\n * App状态记录，需要传入导航控制器，携程作用范围，window窗口大小\n */\n@Stable\nclass NiaAppState(\n    val navController: NavHostController,\n    val coroutineScope: CoroutineScope,\n    val windowSizeClass: WindowSizeClass,\n    networkMonitor: NetworkMonitor,\n) {\n```\n类似LiveData，保存了首页必要的一些数据。\n\n```Kotlin\n /**\n     * 当前在那个tab\n     */\n    val currentDestination: NavDestination?\n        @Composable get() = navController\n            .currentBackStackEntryAsState().value?.destination\n```\n\n```Kotlin\n /**\n     * 通过在哪个tab，决定用哪个枚举类， TopLevelDestination是自己定义的枚举类\n     */\n    val currentTopLevelDestination: TopLevelDestination?\n        @Composable get() = when (currentDestination?.route) {\n            forYouNavigationRoute -> FOR_YOU\n            bookmarksRoute -> BOOKMARKS\n            interestsRoute -> INTERESTS\n            else -> null\n        }\n```\n\n```Kotlin\n /**\n     * 是否展示设置弹框\n     */\n    var shouldShowSettingsDialog by mutableStateOf(false)\n        private set\n```\n\n```Kotlin\n /**\n     * 是否展示底部bar\n     */\n    val shouldShowBottomBar: Boolean\n        get() = windowSizeClass.widthSizeClass == WindowWidthSizeClass.Compact ||\n            windowSizeClass.heightSizeClass == WindowHeightSizeClass.Compact\n```\n\n```Kotlin\n  /**\n     * 是否展示水平左侧导航\n     */\n    val shouldShowNavRail: Boolean\n        get() = !shouldShowBottomBar\n```\n\n```Kotlin\n /**\n     * 监控网络，是否断网\n     */\n    val isOffline = networkMonitor.isOnline\n        .map(Boolean::not)\n        .stateIn(\n            scope = coroutineScope,\n            started = SharingStarted.WhileSubscribed(5_000),\n            initialValue = false\n        )\n\n```\n\n```Kotlin\n   /**\n     * 这里是一个枚举类，表示底部tab集合\n     * Map of top level destinations to be used in the TopBar, BottomBar and NavRail. The key is the\n     * route.\n     */\n    val topLevelDestinations: List<TopLevelDestination> = TopLevelDestination.values().asList()\n```\n\n```Kotlin\n /**\n     * 点击tab事件传递\n     *\n     * @param topLevelDestination: The destination the app needs to navigate to.\n     */\n    fun navigateToTopLevelDestination(topLevelDestination: TopLevelDestination) {\n        trace(\"Navigation: ${topLevelDestination.name}\") {\n            val topLevelNavOptions = navOptions {\n                // Pop up to the start destination of the graph to\n                // avoid building up a large stack of destinations\n                // on the back stack as users select items\n                popUpTo(navController.graph.findStartDestination().id) {\n                    saveState = true\n                }\n                // Avoid multiple copies of the same destination when\n                // reselecting the same item\n                launchSingleTop = true\n                // Restore state when reselecting a previously selected item\n                restoreState = true\n            }\n\n            when (topLevelDestination) {\n                FOR_YOU -> navController.navigateToForYou(topLevelNavOptions)\n                BOOKMARKS -> navController.navigateToBookmarks(topLevelNavOptions)\n                INTERESTS -> navController.navigateToInterestsGraph(topLevelNavOptions)\n            }\n        }\n    }\n\n```\n\n然后定义了一些方法：\n```Kotlin\n /**\n     * 返回点击\n     */\n    fun onBackClick() {\n        navController.popBackStack()\n    }\n\n    /**\n     * 改变设置弹框状态\n     */\n    fun setShowSettingsDialog(shouldShow: Boolean) {\n        shouldShowSettingsDialog = shouldShow\n    }\n```\n\n### 9.NiaApp内容区\n\nApp背景色\n```Kotlin\n@Composable\nfun NiaBackground(\n    modifier: Modifier = Modifier,\n    content: @Composable () -> Unit\n) {\n    val color = LocalBackgroundTheme.current.color\n    val tonalElevation = LocalBackgroundTheme.current.tonalElevation\n    Surface(\n        color = if (color == Color.Unspecified) Color.Transparent else color,\n        tonalElevation = if (tonalElevation == Dp.Unspecified) 0.dp else tonalElevation,\n        modifier = modifier.fillMaxSize(),\n    ) {\n        CompositionLocalProvider(LocalAbsoluteTonalElevation provides 0.dp) {\n            content()\n        }\n    }\n}\n```\n\n数据源使用 LocalBackgroundTheme.current.color\n\n内容区继续渐变背景：\n```Kotlin\n@Composable\nfun NiaGradientBackground(\n    modifier: Modifier = Modifier,\n    gradientColors: GradientColors = LocalGradientColors.current,\n    content: @Composable () -> Unit\n) {\n    val currentTopColor by rememberUpdatedState(gradientColors.top)\n    val currentBottomColor by rememberUpdatedState(gradientColors.bottom)\n    Surface(\n        color = if (gradientColors.container == Color.Unspecified) {\n            Color.Transparent\n        } else {\n            gradientColors.container\n        },\n        modifier = modifier.fillMaxSize()\n    ) {\n        Box(\n            Modifier\n                .fillMaxSize()\n                .drawWithCache {\n                    // Compute the start and end coordinates such that the gradients are angled 11.06\n                    // degrees off the vertical axis\n                    val offset = size.height * tan(\n                        Math\n                            .toRadians(11.06)\n                            .toFloat()\n                    )\n\n                    val start = Offset(size.width / 2 + offset / 2, 0f)\n                    val end = Offset(size.width / 2 - offset / 2, size.height)\n\n                    // Create the top gradient that fades out after the halfway point vertically\n                    val topGradient = Brush.linearGradient(\n                        0f to if (currentTopColor == Color.Unspecified) {\n                            Color.Transparent\n                        } else {\n                            currentTopColor\n                        },\n                        0.724f to Color.Transparent,\n                        start = start,\n                        end = end,\n                    )\n                    // Create the bottom gradient that fades in before the halfway point vertically\n                    val bottomGradient = Brush.linearGradient(\n                        0.2552f to Color.Transparent,\n                        1f to if (currentBottomColor == Color.Unspecified) {\n                            Color.Transparent\n                        } else {\n                            currentBottomColor\n                        },\n                        start = start,\n                        end = end,\n                    )\n\n                    onDrawBehind {\n                        // There is overlap here, so order is important\n                        drawRect(topGradient)\n                        drawRect(bottomGradient)\n                    }\n                }\n        ) {\n            content()\n        }\n    }\n}\n```\n这里在上面0到0.724区间设置了topGradient\n在0.2552f到1设置了 bottomGradient\n\n### 10.业务内容区\n\n```Kotlin\n   // 记录下snackbar状态，后续可能会刷新\n            val snackbarHostState = remember { SnackbarHostState() }\n```\n这个用于网络监听，如果没有网络，底部会常驻一个snackbar\n\n```Kotlin\n            // 是否离线\n            val isOffline by appState.isOffline.collectAsStateWithLifecycle()\n\n            // If user is not connected to the internet show a snack bar to inform them.\n            // 如果没有网络，底部展示Snackbar\n            val notConnectedMessage = stringResource(R.string.not_connected)\n            // 这个是Compose里面的launch，compose开启携程的方法\n            LaunchedEffect(isOffline) {\n                if (isOffline) snackbarHostState.showSnackbar(\n                    message = notConnectedMessage,\n                    duration = Indefinite\n                )\n            }\n```\n\nKotlin\n            // 是否应该展示设置弹框，当点击右上角设置后，会弹出设置弹框\n            if (appState.shouldShowSettingsDialog) {\n                SettingsDialog(\n                    onDismiss = { appState.setShowSettingsDialog(false) }\n                )\n            }\n```\n\n然后就是脚手架了：\nScaffold，这里可以配置底部bar\n```Kotlin\n  Scaffold(\n                modifier = Modifier.semantics {\n                    testTagsAsResourceId = true\n                },\n                containerColor = Color.Transparent,\n                contentColor = MaterialTheme.colorScheme.onBackground,\n                contentWindowInsets = WindowInsets(0, 0, 0, 0),\n                snackbarHost = { SnackbarHost(snackbarHostState) },\n                // 底部bar 设置destinations，就是底部tab数据\n                bottomBar = {\n                    if (appState.shouldShowBottomBar) {\n                        NiaBottomBar(\n                            destinations = appState.topLevelDestinations,\n                            onNavigateToDestination = appState::navigateToTopLevelDestination,\n                            currentDestination = appState.currentDestination,\n                            modifier = Modifier.testTag(\"NiaBottomBar\")\n                        )\n                    }\n                }\n            )\n```\n\n这里snackbarHost也是脚手架里面的内容。\n\n然后里面是一个Row，为什么是一个水平布局，因为考虑到兼容电视，平板，这里将导航页设置了一个水平的左侧导航。\n```Kotlin\n  // 平板 水平布局 左侧导航\n                    if (appState.shouldShowNavRail) {\n                        NiaNavRail(\n                            destinations = appState.topLevelDestinations,\n                            onNavigateToDestination = appState::navigateToTopLevelDestination,\n                            currentDestination = appState.currentDestination,\n                            modifier = Modifier\n                                .testTag(\"NiaNavRail\")\n                                .safeDrawingPadding()\n                        )\n                    }\n```\n\n然后就是实际内容区域了：\n设置+主页构成。\n```Kotlin\n// 垂直布局，状态栏+内容区\n                    /**\n                     * 以前，我们在布局中去设置一个控件的大小，间距，点击事件，宽高，背景等属性值。\n                     * 而在Compose中我们是通过Modifie去设置，Modifie相当于一个控件的属性配置的工具类。\n                     */\n                    Column(Modifier.fillMaxSize()) {\n                        // Show the top app bar on top level destinations.\n                        val destination = appState.currentTopLevelDestination\n                        if (destination != null) {\n                            NiaTopAppBar(\n                                titleRes = destination.titleTextId,\n                                actionIcon = NiaIcons.Settings,\n                                actionIconContentDescription = stringResource(\n                                    id = settingsR.string.top_app_bar_action_icon_description\n                                ),\n                                colors = TopAppBarDefaults.centerAlignedTopAppBarColors(\n                                    containerColor = Color.Transparent\n                                ),\n                                /**\n                                 * 设置点击事件触发appState中的 mutableStateOf变量发生更改\n                                 */\n                                onActionClick = { appState.setShowSettingsDialog(true) }\n                            )\n                        }\n\n                        // 主页面\n                        NiaNavHost(\n                            navController = appState.navController,\n                            onBackClick = appState::onBackClick\n                        )\n                    }\n```\n\nNiaTopAppBar是自定义顶部标题栏\nNiaNavHost是主页面\n\n主页面也是在App模块下的navigation文件夹中定义。\n\n```Kotlin\n@Composable\nfun NiaNavHost(\n    /**\n     * 导航控制器\n     */\n    navController: NavHostController,\n    /**\n     * 返回点击\n     */\n    onBackClick: () -> Unit,\n    /**\n     * 属性配置工具\n     */\n    modifier: Modifier = Modifier,\n    /**\n     * 开始路由设置\n     */\n    startDestination: String = forYouNavigationRoute\n) {\n    NavHost(\n        navController = navController,\n        startDestination = startDestination,\n        modifier = modifier,\n    ) {\n        forYouScreen()\n        bookmarksScreen()\n        interestsGraph(\n            navigateToTopic = { topicId ->\n                navController.navigateToTopic(topicId)\n            },\n            nestedGraphs = {\n                topicScreen(onBackClick)\n            }\n        )\n    }\n}\n```\n这里使用了一个NavHost 的compose官方组件。\n\ntab实现为：\nforYouScreen 你的模块\nbookmarksScreen 书签模块\ninterestsGraph 兴趣模块\n\n这几个tab都是依赖于其它module了。\napp自身module大致内容就这么多了。\n\n\n","source":"_posts/Android-google-samples-nowinandroid-app模块流程分析.md","raw":"---\ntitle: Android google samples nowinandroid app模块流程分析\ndate: 2023-01-15 11:53:19\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- Android\ncategories:\n- Android\n---\n\n> googe samples之 nowinandroid项目地址：[https://github.com/android/nowinandroid](https://github.com/android/nowinandroid)\n\n### 1.app模块build.gradle文件配置\n```Groovy\nplugins {\n    id(\"nowinandroid.android.application\")\n    id(\"nowinandroid.android.application.compose\")\n    id(\"nowinandroid.android.application.jacoco\")\n    id(\"nowinandroid.android.hilt\")\n    id(\"jacoco\")\n    id(\"nowinandroid.firebase-perf\")\n}\n```\n引入了application插件，compose插件，jacoco插件，hilt插件，firebase插件\n\n依赖项：\n```Groovy\n    implementation(project(\":feature:interests\"))\n    implementation(project(\":feature:foryou\"))\n    implementation(project(\":feature:bookmarks\"))\n    implementation(project(\":feature:topic\"))\n    implementation(project(\":feature:settings\"))\n\n    implementation(project(\":core:common\"))\n    implementation(project(\":core:ui\"))\n    implementation(project(\":core:designsystem\"))\n    implementation(project(\":core:data\"))\n    implementation(project(\":core:model\"))\n\n    implementation(project(\":sync:work\"))\n```\nfeature文件夹下是app模块的界面上拆分组件。\n如feature_interests 就是兴趣tab\nfeature_foryou 就是第一个tab\nfeature_bookmarks 是书签模块\n等等\n\n下面的core就是核心模块了，有通用组件，ui组件，设计系统，数据区\n\n然后sync_work是一些工具module了。\n\n### 2.清单文件\n```xml\n    <application\n        android:name=\".NiaApplication\"\n        android:allowBackup=\"true\"\n        android:enableOnBackInvokedCallback=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Nia.Splash\">\n<!--        Profileable 是 Android 10 中引入的清单配置，可用于 CPU 和内存分析任务。使用 profileable 标志而不是 debuggable 标志具有降低性能开销的关键优势；-->\n        <profileable android:shell=\"true\" tools:targetApi=\"q\" />\n\n        <activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n\n```\n这里很简单，就一个Application自定义的，一个首页，说明这个App就一个Activity。\n这里引入了一个profileable标签，是Android10后引入的，可以用于CPU和内存分析任务。\n\n### 3.自定义Application\n这里App开始启动了。\n首先是用了一个HiltAndroidApp的注解。\n这个是类似Dragger的依赖注解框架，这里要求在Application用这个注解。\n关于Hilt用法可参考：[https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn](https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn)\n\n这里在Application里面初始化了一个东西：\n`Sync.initialize(context = this)`\n作用就是初始化Sync三方库。\n\n里面是这样走的：\n```Kotlin\n  AppInitializer.getInstance(context)\n            .initializeComponent(SyncInitializer::class.java)\n```\nAppInitializer是google的Jetpack下的startup中的类成员，关于这个用法可以参考下郭霖的博客：[https://blog.csdn.net/guolin_blog/article/details/108026357](https://blog.csdn.net/guolin_blog/article/details/108026357)\n\n为什么要引入这个同步的库呢？\n/**\n * Registers work to sync the data layer periodically on app startup.\n * 初始化三方库 这里是WorkManager，主要用于\n * Android出于设备电量的考虑，为开发者提供了WorkManager，旨在将一些不需要及时完成的任务交给它来完成。\n * 虽然WorkManager宣称，能够保证任务得到执行，但我在真实设备中，发现应用程序彻底退出与重启设备，任务都没有再次执行。\n * 查阅了相关资料，发现这应该与系统有关系。我们前面也提到了，WorkManager会根据系统的版本，\n * 决定采用JobScheduler或是AlarmManager+Broadcast Receivers来完成任务。\n * 但是这些API很可能会受到OEM系统的影响。比如，假设某个系统不允许AlarmManager自动唤起，那么WorkManager很可能就无法正常使用。\n */\n \n ### 4.MainActivity 参数定义\n Application走完，就到了Activity了。\n 首先是两个注解：\n\n1.  @OptIn(ExperimentalMaterial3WindowSizeClassApi::class)\n Opt-in 是 Kotlin 标准库中的一个方法，用于声明使用某些 API 需要明确的同意。\n  该功能可以让开发者告知 API 使用者使用某些 API 需要一些特定的条件，如果使用者已经知晓则需要明确声明依旧使用（Opt-in）才能继续使用该 API。\n  例如，某些 API 尚处于测试阶段，未来可能会发生变化；亦或是我前言中提到的场景，都非常适合使用该方法。\n  如果我们声明了某个方法（functiuon）或类(class)需要 Opt-in ，则IDE或编译器会发出警告，要求使用者明确标注需要使用（Opt-in）。\n  参考文档：[https://juejin.cn/post/7157950373250990093](https://juejin.cn/post/7157950373250990093)\n\n2. @AndroidEntryPoint\n在要使用依赖注入的类上方添加@AndroidEntryPoint注解\n参考文档：[https://www.jianshu.com/p/22a36660a656](https://www.jianshu.com/p/22a36660a656)\n\n然后声明了两个注入的变量：\n```Kotlin\n/**\n     * Lazily inject [JankStats], which is used to track jank throughout the app.\n     * JankStats 是首个专为在用户设备上检测及报告应用的性能问题而构建的 AndroidX 库。\n     * JankStats 是占用空间相对较小的 API，主要有三大目标: 捕获每帧的性能信息、在用户设备 (不仅是开发设备) 上运行、以及在应用出现性能问题时启用检测，并报告所发生的情况\n     *\n     * 在Dagger中Lazy可以将要注入的依赖项转变为懒加载模式，这样注入的依赖项，只有在需要使用时，\n     * 才会调用对应的依赖生成方法。懒加载的实现很简单，只需要在注入位置将依赖项的类型设置为Lazy接口的类型参数即可。\n     *\n     * 构造函数在di 文件夹下的 JankStatsModule 下\n     */\n    @Inject\n    lateinit var lazyStats: dagger.Lazy<JankStats>\n\n    /**\n     * 自定义网络监视器 这个是一个接口 应该也是测试用的\n     */\n    @Inject\n    lateinit var networkMonitor: NetworkMonitor\n\n```\n \n 关于lazyStats怎么初始化的？在项目di文件夹下有个JankStatsModule\n \n```Kotlin\n/**\n * 这里的目标是生产一个JankStats对象\n *\n * 怎么生产呢，需要2个构造参数\n * 1.JankStats.OnFrameListener\n * 2.Window\n *\n * window需要依赖activity，这里就需要 ActivityComponent了\n * 这个JankStats对象的生命周期设定为Activity级别\n */\n@Module\n@InstallIn(ActivityComponent::class)\nobject JankStatsModule {\n    @Provides\n    fun providesOnFrameListener(): JankStats.OnFrameListener {\n        return JankStats.OnFrameListener { frameData ->\n            // Make sure to only log janky frames.\n            if (frameData.isJank) {\n                // We're currently logging this but would better report it to a backend.\n                Log.v(\"NiA Jank\", frameData.toString())\n            }\n        }\n    }\n\n    @Provides\n    fun providesWindow(activity: Activity): Window {\n        return activity.window\n    }\n\n    @Provides\n    fun providesJankStats(\n        window: Window,\n        frameListener: JankStats.OnFrameListener\n    ): JankStats {\n        return JankStats.createAndTrack(window, frameListener)\n    }\n}\n```\n这里生产了  一个JankStats对象。\n\n关于网络监视器如何初始化的呢？\n这个网络监视器是一个接口来的：\n```Kotlin\n/**\n * Utility for reporting app connectivity status\n */\ninterface NetworkMonitor {\n    val isOnline: Flow<Boolean>\n}\n\n```\n一直没找到如何实例化的地方。\n不过再其它模块，core下的data.di文件夹下发现了另外一个DataModule下有如下代码：\n```Kotlin\n\n    @Binds\n    fun bindsNetworkMonitor(\n        networkMonitor: ConnectivityManagerNetworkMonitor\n    ): NetworkMonitor\n```\n这里貌似可以生产一个NetworkMonitor对象。\n但怎么关联起来的呢？\n\n这个我确实不清楚hilt的用法，而且这个DataModule理应需要在Application配置，但也没找到相关依赖，可能hilt对加上这种注解能全局自动生成依赖代码也说不定。反正这里的网络监视器应该就是这个ConnectivityManagerNetworkMonitor 主要逻辑也在这里。\n\n第三个变量是viewModel\n` val viewModel: MainActivityViewModel by viewModels()`\n这个用法类似：\n`ViewModelProvider(this).get(MainActivityViewModel::class.java)`\n\n\n### 5.首页生命周期-onCreate\n继续走，第一行是 适配闪屏页 installSplashScreen()\n关于闪屏页可参考文档：[https://blog.csdn.net/guolin_blog/article/details/120275319](https://blog.csdn.net/guolin_blog/article/details/120275319)（郭霖）\n\n然后这里监听了一个密封接口中的 Loading 状态，\n密封接口定义如下：\n```Kotlin\n/**\n * 首页ui 状态的密封类，有加载中和成功的状态\n * 密封接口 类似枚举类型，说明有Loading状态和成功状态\n * 表示受限制的类层次结构\n */\nsealed interface MainActivityUiState {\n    object Loading : MainActivityUiState\n    data class Success(val userData: UserData) : MainActivityUiState\n}\n```\n很明显这里Loading实现了这个接口，Success也实现了这个接口。\n\n在onCreate监听了这个Loading类：\n```Kotlin\n\n        /**\n         * mutableStateOf 表明某个变量是有状态的，对变量进行监听，当状态改变时，触发重绘。\n         * remember --- 记录变量的值，使得下次使用改变量时不进行初始化。\n         * 使用 remember 存储对象的可组合项会创建内部状态，使该可组合项有状态。\n         * remember 会为函数提供存储空间，将 remember 计算的值储存，当 remember 的键改变的时候会进行重新计算值并储存。\n         * rememberSaveable --- 在这里顺带提一下,rememberSaveable 可以在重组后保持状态,也可以在重新创建 activity 和进程后保持状态。\n         */\n        var uiState: MainActivityUiState by mutableStateOf(Loading)\n```\n\n然后开启一个携程，拿用户数据：\n```Kotlin\n // Activity生命周期内使用携程\n        lifecycleScope.launch {\n            // Lifecycle.State.STARTED: 表示只有在Activity处于Started状态的情况下，协程中的代码才会执行。\n            lifecycle.repeatOnLifecycle(Lifecycle.State.STARTED) {\n                viewModel.uiState\n                    .onEach {\n                        uiState = it\n                    }\n                    .collect() // 走collect方法才代表执行携程\n            }\n        }\n```\n拿到数据后，才回去更新uiState对象。\n\n就是说uiState会有上面密封接口定义的两种类型。\n\n当监听到uiState变化后会走：\n```Kotlin\n /**\n         * 如果网络请求正在请求loading状态，就还是显示闪屏，如果拿到数据了就不需要闪屏了\n         */\n        splashScreen.setKeepOnScreenCondition {\n            when (uiState) {\n                Loading -> true\n                is Success -> false\n            }\n        }\n```\n闪屏会去除掉。\n\n下面开启沉浸式状态栏：\n```Kotlin\n  /**\n         * 第二参数decorFitsSystemWindows表示是否沉浸，false 表示沉浸，true表示不沉浸\n         */\n        WindowCompat.setDecorFitsSystemWindows(window, false)\n```\n\n然后就是内容区，compose设置内容区了\n一个setContent的函数，太长了，就不全部贴图，挨个分析。\n\n1.首先获取一个systemUIController\n```Kotlin\n /**\n             * 开发者若想在 Compose 布局中控制 System UI，就必须获取 SystemUiController 对象。\n             * 通过该库提供 rememberSystemUiController 函数，开发者可以获取当前操作系统（目前仅支持 Android 系统）的  SystemUiController 对象。\n             */\n            val systemUiController = rememberSystemUiController()\n```\n\n2.是否使用深色主题，用户可以自己选\n```Kotlin\n /**\n             * 是否使用深色主题，入参当前ui状态\n             */\n            val darkTheme = shouldUseDarkTheme(uiState)\n            \n```\n\n内部实现：\n```Kotlin\n/**\n * Returns `true` if dark theme should be used, as a function of the [uiState] and the\n * current system context.\n * 调用@Composable 函数的函数必须用@Composable 注解标记\n */\n@Composable\nprivate fun shouldUseDarkTheme(\n    uiState: MainActivityUiState,\n): Boolean = when (uiState) {\n    /**\n     * isSystemInDarkTheme 根据系统来，加载中状态\n     */\n    Loading -> isSystemInDarkTheme()\n    is Success -> when (uiState.userData.darkThemeConfig) {\n        /**\n         * 成功状态下，根据用户配置的数据来展示，如果跟随系统那就跟随，如果用户主动设置了某一种，那就成功时选择\n         */\n        DarkThemeConfig.FOLLOW_SYSTEM -> isSystemInDarkTheme()\n        DarkThemeConfig.LIGHT -> false\n        DarkThemeConfig.DARK -> true\n    }\n}\n```\n\n然后开启一个DisposableEffect来关联上面这两个对象：\n```Kotlin\n  /**\n             * disposable，顾名思义，这就是一个自带清理作用的Effect\n             */\n            DisposableEffect(systemUiController, darkTheme) {\n                // 否与导航栏图标+内容是否“黑暗\"\n                systemUiController.systemBarsDarkContentEnabled = !darkTheme\n                onDispose {}\n            }\n```\n\n最后，开始设置App主题了：\n```Kotlin\n  /**\n             * 主题配置，是否暗色，判断用户是否有自己选择\n             * 是否用Android主题\n             * 下面这些代码才是内容区的布局，上面MainActivityUiState 这个只是拿用户的持久化数据，槽了\n             */\n            NiaTheme(\n                darkTheme = darkTheme,\n                androidTheme = shouldUseAndroidTheme(uiState)\n            ) {\n                // NiaApp是一个闭包，作为第三个参数\n                NiaApp(\n                    /**\n                     * 窗口大小类，获取一个WindowSizeClass 这个实例\n                     */\n                    windowSizeClass = calculateWindowSizeClass(this),\n                    /**\n                     * 网络监视器，前面注入的\n                     */\n                    networkMonitor = networkMonitor,\n                )\n            }\n```\n\n里面的闭包 NiaApp也就是开启了我们的App。\n\n### 6.首页其它生命周期\n```Kotlin\n  override fun onResume() {\n        super.onResume()\n        /**\n         * 跟踪性能\n         */\n        lazyStats.get().isTrackingEnabled = true\n    }\n\n    override fun onPause() {\n        super.onPause()\n        /**\n         * 去除跟踪\n         */\n        lazyStats.get().isTrackingEnabled = false\n    }\n```\n\nMainActivity内容就这么多了，非常指简洁。\n布局交给NiaApp类处理了。\n\n其它对象初始化交给hilt处理了。\n\n主要就只开了个协程获取用户数据，而且优化闪屏页和loading的显示。\n\n### 7.NiaTheme主题设置\n先是主题颜色：\n```Kotlin\n // 主题颜色\n    val colorScheme = when {\n        // 判断当前 android主题是暗色还是浅色\n        androidTheme -> if (darkTheme) DarkAndroidColorScheme else LightAndroidColorScheme\n        // 没有禁用动态主题并且支持动态主题\n        !disableDynamicTheming && supportsDynamicTheming() -> {\n            val context = LocalContext.current\n            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)\n        }\n        // 其它情况\n        else -> if (darkTheme) DarkDefaultColorScheme else LightDefaultColorScheme\n    }\n```\n\n渐变色:\n```Kotlin\n    // Gradient colors 渐变色\n    // 空渐变色\n    val emptyGradientColors = GradientColors(container = colorScheme.surfaceColorAtElevation(2.dp))\n    // 默认渐变色\n    val defaultGradientColors = GradientColors(\n        top = colorScheme.inverseOnSurface,\n        bottom = colorScheme.primaryContainer,\n        container = colorScheme.surface\n    )\n    // 渐变色\n    val gradientColors = when {\n        androidTheme -> if (darkTheme) DarkAndroidGradientColors else LightAndroidGradientColors\n        !disableDynamicTheming && supportsDynamicTheming() -> emptyGradientColors\n        else -> defaultGradientColors\n    }\n```\n\n最终设置到MaterialTheme里面：\n```Kotlin\n   // Composition locals\n    CompositionLocalProvider(\n        LocalGradientColors provides gradientColors,\n        LocalBackgroundTheme provides backgroundTheme\n    ) {\n        MaterialTheme(\n            colorScheme = colorScheme,\n            typography = NiaTypography,\n            content = content\n        )\n    }\n```\n\n### 8.NiaApp状态定义\n\n首先创建一个NiaApp实例。\n入参：窗口大小类，网络监视器\n```Kotlin\n NiaApp(\n                    /**\n                     * 窗口大小类，获取一个WindowSizeClass 这个实例\n                     */\n                    windowSizeClass = calculateWindowSizeClass(this),\n                    /**\n                     * 网络监视器，前面注入的\n                     */\n                    networkMonitor = networkMonitor,\n                )\n```\n\n这里是App首页ui样式。\n\n这里用到的状态作为第三个参数，作为app状态记录。\n\n函数定义如下：\n```Kotlin\n@OptIn(\n    ExperimentalMaterial3Api::class,\n    ExperimentalLayoutApi::class,\n    ExperimentalComposeUiApi::class,\n    ExperimentalLifecycleComposeApi::class\n)\n@Composable\nfun NiaApp(\n    windowSizeClass: WindowSizeClass,\n    networkMonitor: NetworkMonitor,\n    /**\n     * app状态记录\n     */\n    appState: NiaAppState = rememberNiaAppState(\n        networkMonitor = networkMonitor,\n        windowSizeClass = windowSizeClass\n    ),\n) \n```\n这里第三个参数已经默认实现了。\n\n就是用于app状态记录，调用了一个自定义的rememberNiaAppState方法。\n```Kotlin\n@Composable\nfun rememberNiaAppState(\n    windowSizeClass: WindowSizeClass,\n    networkMonitor: NetworkMonitor,\n    coroutineScope: CoroutineScope = rememberCoroutineScope(),\n    /**\n     * 导航控制器\n     */\n    navController: NavHostController = rememberNavController()\n): NiaAppState {\n    NavigationTrackingSideEffect(navController)\n    /**\n     * remember 里面参数可以任意，闭包里面的东西，就是remember返回的东西\n     */\n    return remember(navController, coroutineScope, windowSizeClass, networkMonitor) {\n        NiaAppState(navController, coroutineScope, windowSizeClass, networkMonitor)\n    }\n}\n```\n这里默认实现了协程作用域，导航控制器，需要返回一个NiaAppState变量。\n\n这里通过remember闭包来返回这个变量。\n\n这个NiaAppState定义如下：\n```Kotlin\n/**\n * 主要用于类似LiveData保存的数据\n * App状态记录，需要传入导航控制器，携程作用范围，window窗口大小\n */\n@Stable\nclass NiaAppState(\n    val navController: NavHostController,\n    val coroutineScope: CoroutineScope,\n    val windowSizeClass: WindowSizeClass,\n    networkMonitor: NetworkMonitor,\n) {\n```\n类似LiveData，保存了首页必要的一些数据。\n\n```Kotlin\n /**\n     * 当前在那个tab\n     */\n    val currentDestination: NavDestination?\n        @Composable get() = navController\n            .currentBackStackEntryAsState().value?.destination\n```\n\n```Kotlin\n /**\n     * 通过在哪个tab，决定用哪个枚举类， TopLevelDestination是自己定义的枚举类\n     */\n    val currentTopLevelDestination: TopLevelDestination?\n        @Composable get() = when (currentDestination?.route) {\n            forYouNavigationRoute -> FOR_YOU\n            bookmarksRoute -> BOOKMARKS\n            interestsRoute -> INTERESTS\n            else -> null\n        }\n```\n\n```Kotlin\n /**\n     * 是否展示设置弹框\n     */\n    var shouldShowSettingsDialog by mutableStateOf(false)\n        private set\n```\n\n```Kotlin\n /**\n     * 是否展示底部bar\n     */\n    val shouldShowBottomBar: Boolean\n        get() = windowSizeClass.widthSizeClass == WindowWidthSizeClass.Compact ||\n            windowSizeClass.heightSizeClass == WindowHeightSizeClass.Compact\n```\n\n```Kotlin\n  /**\n     * 是否展示水平左侧导航\n     */\n    val shouldShowNavRail: Boolean\n        get() = !shouldShowBottomBar\n```\n\n```Kotlin\n /**\n     * 监控网络，是否断网\n     */\n    val isOffline = networkMonitor.isOnline\n        .map(Boolean::not)\n        .stateIn(\n            scope = coroutineScope,\n            started = SharingStarted.WhileSubscribed(5_000),\n            initialValue = false\n        )\n\n```\n\n```Kotlin\n   /**\n     * 这里是一个枚举类，表示底部tab集合\n     * Map of top level destinations to be used in the TopBar, BottomBar and NavRail. The key is the\n     * route.\n     */\n    val topLevelDestinations: List<TopLevelDestination> = TopLevelDestination.values().asList()\n```\n\n```Kotlin\n /**\n     * 点击tab事件传递\n     *\n     * @param topLevelDestination: The destination the app needs to navigate to.\n     */\n    fun navigateToTopLevelDestination(topLevelDestination: TopLevelDestination) {\n        trace(\"Navigation: ${topLevelDestination.name}\") {\n            val topLevelNavOptions = navOptions {\n                // Pop up to the start destination of the graph to\n                // avoid building up a large stack of destinations\n                // on the back stack as users select items\n                popUpTo(navController.graph.findStartDestination().id) {\n                    saveState = true\n                }\n                // Avoid multiple copies of the same destination when\n                // reselecting the same item\n                launchSingleTop = true\n                // Restore state when reselecting a previously selected item\n                restoreState = true\n            }\n\n            when (topLevelDestination) {\n                FOR_YOU -> navController.navigateToForYou(topLevelNavOptions)\n                BOOKMARKS -> navController.navigateToBookmarks(topLevelNavOptions)\n                INTERESTS -> navController.navigateToInterestsGraph(topLevelNavOptions)\n            }\n        }\n    }\n\n```\n\n然后定义了一些方法：\n```Kotlin\n /**\n     * 返回点击\n     */\n    fun onBackClick() {\n        navController.popBackStack()\n    }\n\n    /**\n     * 改变设置弹框状态\n     */\n    fun setShowSettingsDialog(shouldShow: Boolean) {\n        shouldShowSettingsDialog = shouldShow\n    }\n```\n\n### 9.NiaApp内容区\n\nApp背景色\n```Kotlin\n@Composable\nfun NiaBackground(\n    modifier: Modifier = Modifier,\n    content: @Composable () -> Unit\n) {\n    val color = LocalBackgroundTheme.current.color\n    val tonalElevation = LocalBackgroundTheme.current.tonalElevation\n    Surface(\n        color = if (color == Color.Unspecified) Color.Transparent else color,\n        tonalElevation = if (tonalElevation == Dp.Unspecified) 0.dp else tonalElevation,\n        modifier = modifier.fillMaxSize(),\n    ) {\n        CompositionLocalProvider(LocalAbsoluteTonalElevation provides 0.dp) {\n            content()\n        }\n    }\n}\n```\n\n数据源使用 LocalBackgroundTheme.current.color\n\n内容区继续渐变背景：\n```Kotlin\n@Composable\nfun NiaGradientBackground(\n    modifier: Modifier = Modifier,\n    gradientColors: GradientColors = LocalGradientColors.current,\n    content: @Composable () -> Unit\n) {\n    val currentTopColor by rememberUpdatedState(gradientColors.top)\n    val currentBottomColor by rememberUpdatedState(gradientColors.bottom)\n    Surface(\n        color = if (gradientColors.container == Color.Unspecified) {\n            Color.Transparent\n        } else {\n            gradientColors.container\n        },\n        modifier = modifier.fillMaxSize()\n    ) {\n        Box(\n            Modifier\n                .fillMaxSize()\n                .drawWithCache {\n                    // Compute the start and end coordinates such that the gradients are angled 11.06\n                    // degrees off the vertical axis\n                    val offset = size.height * tan(\n                        Math\n                            .toRadians(11.06)\n                            .toFloat()\n                    )\n\n                    val start = Offset(size.width / 2 + offset / 2, 0f)\n                    val end = Offset(size.width / 2 - offset / 2, size.height)\n\n                    // Create the top gradient that fades out after the halfway point vertically\n                    val topGradient = Brush.linearGradient(\n                        0f to if (currentTopColor == Color.Unspecified) {\n                            Color.Transparent\n                        } else {\n                            currentTopColor\n                        },\n                        0.724f to Color.Transparent,\n                        start = start,\n                        end = end,\n                    )\n                    // Create the bottom gradient that fades in before the halfway point vertically\n                    val bottomGradient = Brush.linearGradient(\n                        0.2552f to Color.Transparent,\n                        1f to if (currentBottomColor == Color.Unspecified) {\n                            Color.Transparent\n                        } else {\n                            currentBottomColor\n                        },\n                        start = start,\n                        end = end,\n                    )\n\n                    onDrawBehind {\n                        // There is overlap here, so order is important\n                        drawRect(topGradient)\n                        drawRect(bottomGradient)\n                    }\n                }\n        ) {\n            content()\n        }\n    }\n}\n```\n这里在上面0到0.724区间设置了topGradient\n在0.2552f到1设置了 bottomGradient\n\n### 10.业务内容区\n\n```Kotlin\n   // 记录下snackbar状态，后续可能会刷新\n            val snackbarHostState = remember { SnackbarHostState() }\n```\n这个用于网络监听，如果没有网络，底部会常驻一个snackbar\n\n```Kotlin\n            // 是否离线\n            val isOffline by appState.isOffline.collectAsStateWithLifecycle()\n\n            // If user is not connected to the internet show a snack bar to inform them.\n            // 如果没有网络，底部展示Snackbar\n            val notConnectedMessage = stringResource(R.string.not_connected)\n            // 这个是Compose里面的launch，compose开启携程的方法\n            LaunchedEffect(isOffline) {\n                if (isOffline) snackbarHostState.showSnackbar(\n                    message = notConnectedMessage,\n                    duration = Indefinite\n                )\n            }\n```\n\nKotlin\n            // 是否应该展示设置弹框，当点击右上角设置后，会弹出设置弹框\n            if (appState.shouldShowSettingsDialog) {\n                SettingsDialog(\n                    onDismiss = { appState.setShowSettingsDialog(false) }\n                )\n            }\n```\n\n然后就是脚手架了：\nScaffold，这里可以配置底部bar\n```Kotlin\n  Scaffold(\n                modifier = Modifier.semantics {\n                    testTagsAsResourceId = true\n                },\n                containerColor = Color.Transparent,\n                contentColor = MaterialTheme.colorScheme.onBackground,\n                contentWindowInsets = WindowInsets(0, 0, 0, 0),\n                snackbarHost = { SnackbarHost(snackbarHostState) },\n                // 底部bar 设置destinations，就是底部tab数据\n                bottomBar = {\n                    if (appState.shouldShowBottomBar) {\n                        NiaBottomBar(\n                            destinations = appState.topLevelDestinations,\n                            onNavigateToDestination = appState::navigateToTopLevelDestination,\n                            currentDestination = appState.currentDestination,\n                            modifier = Modifier.testTag(\"NiaBottomBar\")\n                        )\n                    }\n                }\n            )\n```\n\n这里snackbarHost也是脚手架里面的内容。\n\n然后里面是一个Row，为什么是一个水平布局，因为考虑到兼容电视，平板，这里将导航页设置了一个水平的左侧导航。\n```Kotlin\n  // 平板 水平布局 左侧导航\n                    if (appState.shouldShowNavRail) {\n                        NiaNavRail(\n                            destinations = appState.topLevelDestinations,\n                            onNavigateToDestination = appState::navigateToTopLevelDestination,\n                            currentDestination = appState.currentDestination,\n                            modifier = Modifier\n                                .testTag(\"NiaNavRail\")\n                                .safeDrawingPadding()\n                        )\n                    }\n```\n\n然后就是实际内容区域了：\n设置+主页构成。\n```Kotlin\n// 垂直布局，状态栏+内容区\n                    /**\n                     * 以前，我们在布局中去设置一个控件的大小，间距，点击事件，宽高，背景等属性值。\n                     * 而在Compose中我们是通过Modifie去设置，Modifie相当于一个控件的属性配置的工具类。\n                     */\n                    Column(Modifier.fillMaxSize()) {\n                        // Show the top app bar on top level destinations.\n                        val destination = appState.currentTopLevelDestination\n                        if (destination != null) {\n                            NiaTopAppBar(\n                                titleRes = destination.titleTextId,\n                                actionIcon = NiaIcons.Settings,\n                                actionIconContentDescription = stringResource(\n                                    id = settingsR.string.top_app_bar_action_icon_description\n                                ),\n                                colors = TopAppBarDefaults.centerAlignedTopAppBarColors(\n                                    containerColor = Color.Transparent\n                                ),\n                                /**\n                                 * 设置点击事件触发appState中的 mutableStateOf变量发生更改\n                                 */\n                                onActionClick = { appState.setShowSettingsDialog(true) }\n                            )\n                        }\n\n                        // 主页面\n                        NiaNavHost(\n                            navController = appState.navController,\n                            onBackClick = appState::onBackClick\n                        )\n                    }\n```\n\nNiaTopAppBar是自定义顶部标题栏\nNiaNavHost是主页面\n\n主页面也是在App模块下的navigation文件夹中定义。\n\n```Kotlin\n@Composable\nfun NiaNavHost(\n    /**\n     * 导航控制器\n     */\n    navController: NavHostController,\n    /**\n     * 返回点击\n     */\n    onBackClick: () -> Unit,\n    /**\n     * 属性配置工具\n     */\n    modifier: Modifier = Modifier,\n    /**\n     * 开始路由设置\n     */\n    startDestination: String = forYouNavigationRoute\n) {\n    NavHost(\n        navController = navController,\n        startDestination = startDestination,\n        modifier = modifier,\n    ) {\n        forYouScreen()\n        bookmarksScreen()\n        interestsGraph(\n            navigateToTopic = { topicId ->\n                navController.navigateToTopic(topicId)\n            },\n            nestedGraphs = {\n                topicScreen(onBackClick)\n            }\n        )\n    }\n}\n```\n这里使用了一个NavHost 的compose官方组件。\n\ntab实现为：\nforYouScreen 你的模块\nbookmarksScreen 书签模块\ninterestsGraph 兴趣模块\n\n这几个tab都是依赖于其它module了。\napp自身module大致内容就这么多了。\n\n\n","slug":"Android-google-samples-nowinandroid-app模块流程分析","published":1,"updated":"2023-02-01T07:17:16.379Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlhfhym0003ivv777j66hem","content":"<blockquote>\n<p>googe samples之 nowinandroid项目地址：<a href=\"https://github.com/android/nowinandroid\">https://github.com/android/nowinandroid</a></p>\n</blockquote>\n<h3 id=\"1-app模块build-gradle文件配置\"><a href=\"#1-app模块build-gradle文件配置\" class=\"headerlink\" title=\"1.app模块build.gradle文件配置\"></a>1.app模块build.gradle文件配置</h3><pre><code class=\"line-numbers language-Groovy\">plugins &#123;\n    id(&quot;nowinandroid.android.application&quot;)\n    id(&quot;nowinandroid.android.application.compose&quot;)\n    id(&quot;nowinandroid.android.application.jacoco&quot;)\n    id(&quot;nowinandroid.android.hilt&quot;)\n    id(&quot;jacoco&quot;)\n    id(&quot;nowinandroid.firebase-perf&quot;)\n&#125;\n</code></pre>\n<p>引入了application插件，compose插件，jacoco插件，hilt插件，firebase插件</p>\n<p>依赖项：</p>\n<pre><code class=\"line-numbers language-Groovy\">    implementation(project(&quot;:feature:interests&quot;))\n    implementation(project(&quot;:feature:foryou&quot;))\n    implementation(project(&quot;:feature:bookmarks&quot;))\n    implementation(project(&quot;:feature:topic&quot;))\n    implementation(project(&quot;:feature:settings&quot;))\n\n    implementation(project(&quot;:core:common&quot;))\n    implementation(project(&quot;:core:ui&quot;))\n    implementation(project(&quot;:core:designsystem&quot;))\n    implementation(project(&quot;:core:data&quot;))\n    implementation(project(&quot;:core:model&quot;))\n\n    implementation(project(&quot;:sync:work&quot;))\n</code></pre>\n<p>feature文件夹下是app模块的界面上拆分组件。<br>如feature_interests 就是兴趣tab<br>feature_foryou 就是第一个tab<br>feature_bookmarks 是书签模块<br>等等</p>\n<p>下面的core就是核心模块了，有通用组件，ui组件，设计系统，数据区</p>\n<p>然后sync_work是一些工具module了。</p>\n<h3 id=\"2-清单文件\"><a href=\"#2-清单文件\" class=\"headerlink\" title=\"2.清单文件\"></a>2.清单文件</h3><pre><code class=\"line-numbers language-xml\">    &lt;application\n        android:name=&quot;.NiaApplication&quot;\n        android:allowBackup=&quot;true&quot;\n        android:enableOnBackInvokedCallback=&quot;true&quot;\n        android:icon=&quot;@mipmap/ic_launcher&quot;\n        android:label=&quot;@string/app_name&quot;\n        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;\n        android:supportsRtl=&quot;true&quot;\n        android:theme=&quot;@style/Theme.Nia.Splash&quot;&gt;\n&lt;!--        Profileable 是 Android 10 中引入的清单配置，可用于 CPU 和内存分析任务。使用 profileable 标志而不是 debuggable 标志具有降低性能开销的关键优势；--&gt;\n        &lt;profileable android:shell=&quot;true&quot; tools:targetApi=&quot;q&quot; /&gt;\n\n        &lt;activity\n            android:name=&quot;.MainActivity&quot;\n            android:exported=&quot;true&quot;&gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;\n\n                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n    &lt;/application&gt;\n</code></pre>\n<p>这里很简单，就一个Application自定义的，一个首页，说明这个App就一个Activity。<br>这里引入了一个profileable标签，是Android10后引入的，可以用于CPU和内存分析任务。</p>\n<h3 id=\"3-自定义Application\"><a href=\"#3-自定义Application\" class=\"headerlink\" title=\"3.自定义Application\"></a>3.自定义Application</h3><p>这里App开始启动了。<br>首先是用了一个HiltAndroidApp的注解。<br>这个是类似Dragger的依赖注解框架，这里要求在Application用这个注解。<br>关于Hilt用法可参考：<a href=\"https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn\">https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn</a></p>\n<p>这里在Application里面初始化了一个东西：<br><code>Sync.initialize(context = this)</code><br>作用就是初始化Sync三方库。</p>\n<p>里面是这样走的：</p>\n<pre><code class=\"line-numbers language-Kotlin\">  AppInitializer.getInstance(context)\n            .initializeComponent(SyncInitializer::class.java)\n</code></pre>\n<p>AppInitializer是google的Jetpack下的startup中的类成员，关于这个用法可以参考下郭霖的博客：<a href=\"https://blog.csdn.net/guolin_blog/article/details/108026357\">https://blog.csdn.net/guolin_blog&#x2F;article&#x2F;details&#x2F;108026357</a></p>\n<p>为什么要引入这个同步的库呢？<br>&#x2F;**</p>\n<ul>\n<li>Registers work to sync the data layer periodically on app startup.</li>\n<li>初始化三方库 这里是WorkManager，主要用于</li>\n<li>Android出于设备电量的考虑，为开发者提供了WorkManager，旨在将一些不需要及时完成的任务交给它来完成。</li>\n<li>虽然WorkManager宣称，能够保证任务得到执行，但我在真实设备中，发现应用程序彻底退出与重启设备，任务都没有再次执行。</li>\n<li>查阅了相关资料，发现这应该与系统有关系。我们前面也提到了，WorkManager会根据系统的版本，</li>\n<li>决定采用JobScheduler或是AlarmManager+Broadcast Receivers来完成任务。</li>\n<li>但是这些API很可能会受到OEM系统的影响。比如，假设某个系统不允许AlarmManager自动唤起，那么WorkManager很可能就无法正常使用。<br> *&#x2F;</li>\n</ul>\n<h3 id=\"4-MainActivity-参数定义\"><a href=\"#4-MainActivity-参数定义\" class=\"headerlink\" title=\"4.MainActivity 参数定义\"></a>4.MainActivity 参数定义</h3><p> Application走完，就到了Activity了。<br> 首先是两个注解：</p>\n<ol>\n<li><p>@OptIn(ExperimentalMaterial3WindowSizeClassApi::class)<br> Opt-in 是 Kotlin 标准库中的一个方法，用于声明使用某些 API 需要明确的同意。<br>  该功能可以让开发者告知 API 使用者使用某些 API 需要一些特定的条件，如果使用者已经知晓则需要明确声明依旧使用（Opt-in）才能继续使用该 API。<br>  例如，某些 API 尚处于测试阶段，未来可能会发生变化；亦或是我前言中提到的场景，都非常适合使用该方法。<br>  如果我们声明了某个方法（functiuon）或类(class)需要 Opt-in ，则IDE或编译器会发出警告，要求使用者明确标注需要使用（Opt-in）。<br>  参考文档：<a href=\"https://juejin.cn/post/7157950373250990093\">https://juejin.cn/post/7157950373250990093</a></p>\n</li>\n<li><p>@AndroidEntryPoint<br>在要使用依赖注入的类上方添加@AndroidEntryPoint注解<br>参考文档：<a href=\"https://www.jianshu.com/p/22a36660a656\">https://www.jianshu.com/p/22a36660a656</a></p>\n</li>\n</ol>\n<p>然后声明了两个注入的变量：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n     * Lazily inject [JankStats], which is used to track jank throughout the app.\n     * JankStats 是首个专为在用户设备上检测及报告应用的性能问题而构建的 AndroidX 库。\n     * JankStats 是占用空间相对较小的 API，主要有三大目标: 捕获每帧的性能信息、在用户设备 (不仅是开发设备) 上运行、以及在应用出现性能问题时启用检测，并报告所发生的情况\n     *\n     * 在Dagger中Lazy可以将要注入的依赖项转变为懒加载模式，这样注入的依赖项，只有在需要使用时，\n     * 才会调用对应的依赖生成方法。懒加载的实现很简单，只需要在注入位置将依赖项的类型设置为Lazy接口的类型参数即可。\n     *\n     * 构造函数在di 文件夹下的 JankStatsModule 下\n     */\n    @Inject\n    lateinit var lazyStats: dagger.Lazy&lt;JankStats&gt;\n\n    /**\n     * 自定义网络监视器 这个是一个接口 应该也是测试用的\n     */\n    @Inject\n    lateinit var networkMonitor: NetworkMonitor\n</code></pre>\n<p> 关于lazyStats怎么初始化的？在项目di文件夹下有个JankStatsModule</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * 这里的目标是生产一个JankStats对象\n *\n * 怎么生产呢，需要2个构造参数\n * 1.JankStats.OnFrameListener\n * 2.Window\n *\n * window需要依赖activity，这里就需要 ActivityComponent了\n * 这个JankStats对象的生命周期设定为Activity级别\n */\n@Module\n@InstallIn(ActivityComponent::class)\nobject JankStatsModule &#123;\n    @Provides\n    fun providesOnFrameListener(): JankStats.OnFrameListener &#123;\n        return JankStats.OnFrameListener &#123; frameData -&gt;\n            // Make sure to only log janky frames.\n            if (frameData.isJank) &#123;\n                // We&#39;re currently logging this but would better report it to a backend.\n                Log.v(&quot;NiA Jank&quot;, frameData.toString())\n            &#125;\n        &#125;\n    &#125;\n\n    @Provides\n    fun providesWindow(activity: Activity): Window &#123;\n        return activity.window\n    &#125;\n\n    @Provides\n    fun providesJankStats(\n        window: Window,\n        frameListener: JankStats.OnFrameListener\n    ): JankStats &#123;\n        return JankStats.createAndTrack(window, frameListener)\n    &#125;\n&#125;\n</code></pre>\n<p>这里生产了  一个JankStats对象。</p>\n<p>关于网络监视器如何初始化的呢？<br>这个网络监视器是一个接口来的：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * Utility for reporting app connectivity status\n */\ninterface NetworkMonitor &#123;\n    val isOnline: Flow&lt;Boolean&gt;\n&#125;\n</code></pre>\n<p>一直没找到如何实例化的地方。<br>不过再其它模块，core下的data.di文件夹下发现了另外一个DataModule下有如下代码：</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n    @Binds\n    fun bindsNetworkMonitor(\n        networkMonitor: ConnectivityManagerNetworkMonitor\n    ): NetworkMonitor\n</code></pre>\n<p>这里貌似可以生产一个NetworkMonitor对象。<br>但怎么关联起来的呢？</p>\n<p>这个我确实不清楚hilt的用法，而且这个DataModule理应需要在Application配置，但也没找到相关依赖，可能hilt对加上这种注解能全局自动生成依赖代码也说不定。反正这里的网络监视器应该就是这个ConnectivityManagerNetworkMonitor 主要逻辑也在这里。</p>\n<p>第三个变量是viewModel<br><code> val viewModel: MainActivityViewModel by viewModels()</code><br>这个用法类似：<br><code>ViewModelProvider(this).get(MainActivityViewModel::class.java)</code></p>\n<h3 id=\"5-首页生命周期-onCreate\"><a href=\"#5-首页生命周期-onCreate\" class=\"headerlink\" title=\"5.首页生命周期-onCreate\"></a>5.首页生命周期-onCreate</h3><p>继续走，第一行是 适配闪屏页 installSplashScreen()<br>关于闪屏页可参考文档：<a href=\"https://blog.csdn.net/guolin_blog/article/details/120275319\">https://blog.csdn.net/guolin_blog&#x2F;article&#x2F;details&#x2F;120275319</a>（郭霖）</p>\n<p>然后这里监听了一个密封接口中的 Loading 状态，<br>密封接口定义如下：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * 首页ui 状态的密封类，有加载中和成功的状态\n * 密封接口 类似枚举类型，说明有Loading状态和成功状态\n * 表示受限制的类层次结构\n */\nsealed interface MainActivityUiState &#123;\n    object Loading : MainActivityUiState\n    data class Success(val userData: UserData) : MainActivityUiState\n&#125;\n</code></pre>\n<p>很明显这里Loading实现了这个接口，Success也实现了这个接口。</p>\n<p>在onCreate监听了这个Loading类：</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n        /**\n         * mutableStateOf 表明某个变量是有状态的，对变量进行监听，当状态改变时，触发重绘。\n         * remember --- 记录变量的值，使得下次使用改变量时不进行初始化。\n         * 使用 remember 存储对象的可组合项会创建内部状态，使该可组合项有状态。\n         * remember 会为函数提供存储空间，将 remember 计算的值储存，当 remember 的键改变的时候会进行重新计算值并储存。\n         * rememberSaveable --- 在这里顺带提一下,rememberSaveable 可以在重组后保持状态,也可以在重新创建 activity 和进程后保持状态。\n         */\n        var uiState: MainActivityUiState by mutableStateOf(Loading)\n</code></pre>\n<p>然后开启一个携程，拿用户数据：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> // Activity生命周期内使用携程\n        lifecycleScope.launch &#123;\n            // Lifecycle.State.STARTED: 表示只有在Activity处于Started状态的情况下，协程中的代码才会执行。\n            lifecycle.repeatOnLifecycle(Lifecycle.State.STARTED) &#123;\n                viewModel.uiState\n                    .onEach &#123;\n                        uiState = it\n                    &#125;\n                    .collect() // 走collect方法才代表执行携程\n            &#125;\n        &#125;\n</code></pre>\n<p>拿到数据后，才回去更新uiState对象。</p>\n<p>就是说uiState会有上面密封接口定义的两种类型。</p>\n<p>当监听到uiState变化后会走：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n         * 如果网络请求正在请求loading状态，就还是显示闪屏，如果拿到数据了就不需要闪屏了\n         */\n        splashScreen.setKeepOnScreenCondition &#123;\n            when (uiState) &#123;\n                Loading -&gt; true\n                is Success -&gt; false\n            &#125;\n        &#125;\n</code></pre>\n<p>闪屏会去除掉。</p>\n<p>下面开启沉浸式状态栏：</p>\n<pre><code class=\"line-numbers language-Kotlin\">  /**\n         * 第二参数decorFitsSystemWindows表示是否沉浸，false 表示沉浸，true表示不沉浸\n         */\n        WindowCompat.setDecorFitsSystemWindows(window, false)\n</code></pre>\n<p>然后就是内容区，compose设置内容区了<br>一个setContent的函数，太长了，就不全部贴图，挨个分析。</p>\n<p>1.首先获取一个systemUIController</p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n             * 开发者若想在 Compose 布局中控制 System UI，就必须获取 SystemUiController 对象。\n             * 通过该库提供 rememberSystemUiController 函数，开发者可以获取当前操作系统（目前仅支持 Android 系统）的  SystemUiController 对象。\n             */\n            val systemUiController = rememberSystemUiController()\n</code></pre>\n<p>2.是否使用深色主题，用户可以自己选</p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n             * 是否使用深色主题，入参当前ui状态\n             */\n            val darkTheme = shouldUseDarkTheme(uiState)\n            \n</code></pre>\n<p>内部实现：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * Returns `true` if dark theme should be used, as a function of the [uiState] and the\n * current system context.\n * 调用@Composable 函数的函数必须用@Composable 注解标记\n */\n@Composable\nprivate fun shouldUseDarkTheme(\n    uiState: MainActivityUiState,\n): Boolean = when (uiState) &#123;\n    /**\n     * isSystemInDarkTheme 根据系统来，加载中状态\n     */\n    Loading -&gt; isSystemInDarkTheme()\n    is Success -&gt; when (uiState.userData.darkThemeConfig) &#123;\n        /**\n         * 成功状态下，根据用户配置的数据来展示，如果跟随系统那就跟随，如果用户主动设置了某一种，那就成功时选择\n         */\n        DarkThemeConfig.FOLLOW_SYSTEM -&gt; isSystemInDarkTheme()\n        DarkThemeConfig.LIGHT -&gt; false\n        DarkThemeConfig.DARK -&gt; true\n    &#125;\n&#125;\n</code></pre>\n<p>然后开启一个DisposableEffect来关联上面这两个对象：</p>\n<pre><code class=\"line-numbers language-Kotlin\">  /**\n             * disposable，顾名思义，这就是一个自带清理作用的Effect\n             */\n            DisposableEffect(systemUiController, darkTheme) &#123;\n                // 否与导航栏图标+内容是否“黑暗&quot;\n                systemUiController.systemBarsDarkContentEnabled = !darkTheme\n                onDispose &#123;&#125;\n            &#125;\n</code></pre>\n<p>最后，开始设置App主题了：</p>\n<pre><code class=\"line-numbers language-Kotlin\">  /**\n             * 主题配置，是否暗色，判断用户是否有自己选择\n             * 是否用Android主题\n             * 下面这些代码才是内容区的布局，上面MainActivityUiState 这个只是拿用户的持久化数据，槽了\n             */\n            NiaTheme(\n                darkTheme = darkTheme,\n                androidTheme = shouldUseAndroidTheme(uiState)\n            ) &#123;\n                // NiaApp是一个闭包，作为第三个参数\n                NiaApp(\n                    /**\n                     * 窗口大小类，获取一个WindowSizeClass 这个实例\n                     */\n                    windowSizeClass = calculateWindowSizeClass(this),\n                    /**\n                     * 网络监视器，前面注入的\n                     */\n                    networkMonitor = networkMonitor,\n                )\n            &#125;\n</code></pre>\n<p>里面的闭包 NiaApp也就是开启了我们的App。</p>\n<h3 id=\"6-首页其它生命周期\"><a href=\"#6-首页其它生命周期\" class=\"headerlink\" title=\"6.首页其它生命周期\"></a>6.首页其它生命周期</h3><pre><code class=\"line-numbers language-Kotlin\">  override fun onResume() &#123;\n        super.onResume()\n        /**\n         * 跟踪性能\n         */\n        lazyStats.get().isTrackingEnabled = true\n    &#125;\n\n    override fun onPause() &#123;\n        super.onPause()\n        /**\n         * 去除跟踪\n         */\n        lazyStats.get().isTrackingEnabled = false\n    &#125;\n</code></pre>\n<p>MainActivity内容就这么多了，非常指简洁。<br>布局交给NiaApp类处理了。</p>\n<p>其它对象初始化交给hilt处理了。</p>\n<p>主要就只开了个协程获取用户数据，而且优化闪屏页和loading的显示。</p>\n<h3 id=\"7-NiaTheme主题设置\"><a href=\"#7-NiaTheme主题设置\" class=\"headerlink\" title=\"7.NiaTheme主题设置\"></a>7.NiaTheme主题设置</h3><p>先是主题颜色：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> // 主题颜色\n    val colorScheme = when &#123;\n        // 判断当前 android主题是暗色还是浅色\n        androidTheme -&gt; if (darkTheme) DarkAndroidColorScheme else LightAndroidColorScheme\n        // 没有禁用动态主题并且支持动态主题\n        !disableDynamicTheming &amp;&amp; supportsDynamicTheming() -&gt; &#123;\n            val context = LocalContext.current\n            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)\n        &#125;\n        // 其它情况\n        else -&gt; if (darkTheme) DarkDefaultColorScheme else LightDefaultColorScheme\n    &#125;\n</code></pre>\n<p>渐变色:</p>\n<pre><code class=\"line-numbers language-Kotlin\">    // Gradient colors 渐变色\n    // 空渐变色\n    val emptyGradientColors = GradientColors(container = colorScheme.surfaceColorAtElevation(2.dp))\n    // 默认渐变色\n    val defaultGradientColors = GradientColors(\n        top = colorScheme.inverseOnSurface,\n        bottom = colorScheme.primaryContainer,\n        container = colorScheme.surface\n    )\n    // 渐变色\n    val gradientColors = when &#123;\n        androidTheme -&gt; if (darkTheme) DarkAndroidGradientColors else LightAndroidGradientColors\n        !disableDynamicTheming &amp;&amp; supportsDynamicTheming() -&gt; emptyGradientColors\n        else -&gt; defaultGradientColors\n    &#125;\n</code></pre>\n<p>最终设置到MaterialTheme里面：</p>\n<pre><code class=\"line-numbers language-Kotlin\">   // Composition locals\n    CompositionLocalProvider(\n        LocalGradientColors provides gradientColors,\n        LocalBackgroundTheme provides backgroundTheme\n    ) &#123;\n        MaterialTheme(\n            colorScheme = colorScheme,\n            typography = NiaTypography,\n            content = content\n        )\n    &#125;\n</code></pre>\n<h3 id=\"8-NiaApp状态定义\"><a href=\"#8-NiaApp状态定义\" class=\"headerlink\" title=\"8.NiaApp状态定义\"></a>8.NiaApp状态定义</h3><p>首先创建一个NiaApp实例。<br>入参：窗口大小类，网络监视器</p>\n<pre><code class=\"line-numbers language-Kotlin\"> NiaApp(\n                    /**\n                     * 窗口大小类，获取一个WindowSizeClass 这个实例\n                     */\n                    windowSizeClass = calculateWindowSizeClass(this),\n                    /**\n                     * 网络监视器，前面注入的\n                     */\n                    networkMonitor = networkMonitor,\n                )\n</code></pre>\n<p>这里是App首页ui样式。</p>\n<p>这里用到的状态作为第三个参数，作为app状态记录。</p>\n<p>函数定义如下：</p>\n<pre><code class=\"line-numbers language-Kotlin\">@OptIn(\n    ExperimentalMaterial3Api::class,\n    ExperimentalLayoutApi::class,\n    ExperimentalComposeUiApi::class,\n    ExperimentalLifecycleComposeApi::class\n)\n@Composable\nfun NiaApp(\n    windowSizeClass: WindowSizeClass,\n    networkMonitor: NetworkMonitor,\n    /**\n     * app状态记录\n     */\n    appState: NiaAppState = rememberNiaAppState(\n        networkMonitor = networkMonitor,\n        windowSizeClass = windowSizeClass\n    ),\n) \n</code></pre>\n<p>这里第三个参数已经默认实现了。</p>\n<p>就是用于app状态记录，调用了一个自定义的rememberNiaAppState方法。</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun rememberNiaAppState(\n    windowSizeClass: WindowSizeClass,\n    networkMonitor: NetworkMonitor,\n    coroutineScope: CoroutineScope = rememberCoroutineScope(),\n    /**\n     * 导航控制器\n     */\n    navController: NavHostController = rememberNavController()\n): NiaAppState &#123;\n    NavigationTrackingSideEffect(navController)\n    /**\n     * remember 里面参数可以任意，闭包里面的东西，就是remember返回的东西\n     */\n    return remember(navController, coroutineScope, windowSizeClass, networkMonitor) &#123;\n        NiaAppState(navController, coroutineScope, windowSizeClass, networkMonitor)\n    &#125;\n&#125;\n</code></pre>\n<p>这里默认实现了协程作用域，导航控制器，需要返回一个NiaAppState变量。</p>\n<p>这里通过remember闭包来返回这个变量。</p>\n<p>这个NiaAppState定义如下：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * 主要用于类似LiveData保存的数据\n * App状态记录，需要传入导航控制器，携程作用范围，window窗口大小\n */\n@Stable\nclass NiaAppState(\n    val navController: NavHostController,\n    val coroutineScope: CoroutineScope,\n    val windowSizeClass: WindowSizeClass,\n    networkMonitor: NetworkMonitor,\n) &#123;\n</code></pre>\n<p>类似LiveData，保存了首页必要的一些数据。</p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 当前在那个tab\n     */\n    val currentDestination: NavDestination?\n        @Composable get() = navController\n            .currentBackStackEntryAsState().value?.destination\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 通过在哪个tab，决定用哪个枚举类， TopLevelDestination是自己定义的枚举类\n     */\n    val currentTopLevelDestination: TopLevelDestination?\n        @Composable get() = when (currentDestination?.route) &#123;\n            forYouNavigationRoute -&gt; FOR_YOU\n            bookmarksRoute -&gt; BOOKMARKS\n            interestsRoute -&gt; INTERESTS\n            else -&gt; null\n        &#125;\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 是否展示设置弹框\n     */\n    var shouldShowSettingsDialog by mutableStateOf(false)\n        private set\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 是否展示底部bar\n     */\n    val shouldShowBottomBar: Boolean\n        get() = windowSizeClass.widthSizeClass == WindowWidthSizeClass.Compact ||\n            windowSizeClass.heightSizeClass == WindowHeightSizeClass.Compact\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\">  /**\n     * 是否展示水平左侧导航\n     */\n    val shouldShowNavRail: Boolean\n        get() = !shouldShowBottomBar\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 监控网络，是否断网\n     */\n    val isOffline = networkMonitor.isOnline\n        .map(Boolean::not)\n        .stateIn(\n            scope = coroutineScope,\n            started = SharingStarted.WhileSubscribed(5_000),\n            initialValue = false\n        )\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\">   /**\n     * 这里是一个枚举类，表示底部tab集合\n     * Map of top level destinations to be used in the TopBar, BottomBar and NavRail. The key is the\n     * route.\n     */\n    val topLevelDestinations: List&lt;TopLevelDestination&gt; = TopLevelDestination.values().asList()\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 点击tab事件传递\n     *\n     * @param topLevelDestination: The destination the app needs to navigate to.\n     */\n    fun navigateToTopLevelDestination(topLevelDestination: TopLevelDestination) &#123;\n        trace(&quot;Navigation: $&#123;topLevelDestination.name&#125;&quot;) &#123;\n            val topLevelNavOptions = navOptions &#123;\n                // Pop up to the start destination of the graph to\n                // avoid building up a large stack of destinations\n                // on the back stack as users select items\n                popUpTo(navController.graph.findStartDestination().id) &#123;\n                    saveState = true\n                &#125;\n                // Avoid multiple copies of the same destination when\n                // reselecting the same item\n                launchSingleTop = true\n                // Restore state when reselecting a previously selected item\n                restoreState = true\n            &#125;\n\n            when (topLevelDestination) &#123;\n                FOR_YOU -&gt; navController.navigateToForYou(topLevelNavOptions)\n                BOOKMARKS -&gt; navController.navigateToBookmarks(topLevelNavOptions)\n                INTERESTS -&gt; navController.navigateToInterestsGraph(topLevelNavOptions)\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>然后定义了一些方法：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 返回点击\n     */\n    fun onBackClick() &#123;\n        navController.popBackStack()\n    &#125;\n\n    /**\n     * 改变设置弹框状态\n     */\n    fun setShowSettingsDialog(shouldShow: Boolean) &#123;\n        shouldShowSettingsDialog = shouldShow\n    &#125;\n</code></pre>\n<h3 id=\"9-NiaApp内容区\"><a href=\"#9-NiaApp内容区\" class=\"headerlink\" title=\"9.NiaApp内容区\"></a>9.NiaApp内容区</h3><p>App背景色</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun NiaBackground(\n    modifier: Modifier = Modifier,\n    content: @Composable () -&gt; Unit\n) &#123;\n    val color = LocalBackgroundTheme.current.color\n    val tonalElevation = LocalBackgroundTheme.current.tonalElevation\n    Surface(\n        color = if (color == Color.Unspecified) Color.Transparent else color,\n        tonalElevation = if (tonalElevation == Dp.Unspecified) 0.dp else tonalElevation,\n        modifier = modifier.fillMaxSize(),\n    ) &#123;\n        CompositionLocalProvider(LocalAbsoluteTonalElevation provides 0.dp) &#123;\n            content()\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>数据源使用 LocalBackgroundTheme.current.color</p>\n<p>内容区继续渐变背景：</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun NiaGradientBackground(\n    modifier: Modifier = Modifier,\n    gradientColors: GradientColors = LocalGradientColors.current,\n    content: @Composable () -&gt; Unit\n) &#123;\n    val currentTopColor by rememberUpdatedState(gradientColors.top)\n    val currentBottomColor by rememberUpdatedState(gradientColors.bottom)\n    Surface(\n        color = if (gradientColors.container == Color.Unspecified) &#123;\n            Color.Transparent\n        &#125; else &#123;\n            gradientColors.container\n        &#125;,\n        modifier = modifier.fillMaxSize()\n    ) &#123;\n        Box(\n            Modifier\n                .fillMaxSize()\n                .drawWithCache &#123;\n                    // Compute the start and end coordinates such that the gradients are angled 11.06\n                    // degrees off the vertical axis\n                    val offset = size.height * tan(\n                        Math\n                            .toRadians(11.06)\n                            .toFloat()\n                    )\n\n                    val start = Offset(size.width / 2 + offset / 2, 0f)\n                    val end = Offset(size.width / 2 - offset / 2, size.height)\n\n                    // Create the top gradient that fades out after the halfway point vertically\n                    val topGradient = Brush.linearGradient(\n                        0f to if (currentTopColor == Color.Unspecified) &#123;\n                            Color.Transparent\n                        &#125; else &#123;\n                            currentTopColor\n                        &#125;,\n                        0.724f to Color.Transparent,\n                        start = start,\n                        end = end,\n                    )\n                    // Create the bottom gradient that fades in before the halfway point vertically\n                    val bottomGradient = Brush.linearGradient(\n                        0.2552f to Color.Transparent,\n                        1f to if (currentBottomColor == Color.Unspecified) &#123;\n                            Color.Transparent\n                        &#125; else &#123;\n                            currentBottomColor\n                        &#125;,\n                        start = start,\n                        end = end,\n                    )\n\n                    onDrawBehind &#123;\n                        // There is overlap here, so order is important\n                        drawRect(topGradient)\n                        drawRect(bottomGradient)\n                    &#125;\n                &#125;\n        ) &#123;\n            content()\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里在上面0到0.724区间设置了topGradient<br>在0.2552f到1设置了 bottomGradient</p>\n<h3 id=\"10-业务内容区\"><a href=\"#10-业务内容区\" class=\"headerlink\" title=\"10.业务内容区\"></a>10.业务内容区</h3><pre><code class=\"line-numbers language-Kotlin\">   // 记录下snackbar状态，后续可能会刷新\n            val snackbarHostState = remember &#123; SnackbarHostState() &#125;\n</code></pre>\n<p>这个用于网络监听，如果没有网络，底部会常驻一个snackbar</p>\n<pre><code class=\"line-numbers language-Kotlin\">            // 是否离线\n            val isOffline by appState.isOffline.collectAsStateWithLifecycle()\n\n            // If user is not connected to the internet show a snack bar to inform them.\n            // 如果没有网络，底部展示Snackbar\n            val notConnectedMessage = stringResource(R.string.not_connected)\n            // 这个是Compose里面的launch，compose开启携程的方法\n            LaunchedEffect(isOffline) &#123;\n                if (isOffline) snackbarHostState.showSnackbar(\n                    message = notConnectedMessage,\n                    duration = Indefinite\n                )\n            &#125;\n</code></pre>\n<p>Kotlin<br>            &#x2F;&#x2F; 是否应该展示设置弹框，当点击右上角设置后，会弹出设置弹框<br>            if (appState.shouldShowSettingsDialog) {<br>                SettingsDialog(<br>                    onDismiss &#x3D; { appState.setShowSettingsDialog(false) }<br>                )<br>            }</p>\n<pre><code>\n然后就是脚手架了：\nScaffold，这里可以配置底部bar\n```Kotlin\n  Scaffold(\n                modifier = Modifier.semantics &#123;\n                    testTagsAsResourceId = true\n                &#125;,\n                containerColor = Color.Transparent,\n                contentColor = MaterialTheme.colorScheme.onBackground,\n                contentWindowInsets = WindowInsets(0, 0, 0, 0),\n                snackbarHost = &#123; SnackbarHost(snackbarHostState) &#125;,\n                // 底部bar 设置destinations，就是底部tab数据\n                bottomBar = &#123;\n                    if (appState.shouldShowBottomBar) &#123;\n                        NiaBottomBar(\n                            destinations = appState.topLevelDestinations,\n                            onNavigateToDestination = appState::navigateToTopLevelDestination,\n                            currentDestination = appState.currentDestination,\n                            modifier = Modifier.testTag(&quot;NiaBottomBar&quot;)\n                        )\n                    &#125;\n                &#125;\n            )\n</code></pre>\n<p>这里snackbarHost也是脚手架里面的内容。</p>\n<p>然后里面是一个Row，为什么是一个水平布局，因为考虑到兼容电视，平板，这里将导航页设置了一个水平的左侧导航。</p>\n<pre><code class=\"line-numbers language-Kotlin\">  // 平板 水平布局 左侧导航\n                    if (appState.shouldShowNavRail) &#123;\n                        NiaNavRail(\n                            destinations = appState.topLevelDestinations,\n                            onNavigateToDestination = appState::navigateToTopLevelDestination,\n                            currentDestination = appState.currentDestination,\n                            modifier = Modifier\n                                .testTag(&quot;NiaNavRail&quot;)\n                                .safeDrawingPadding()\n                        )\n                    &#125;\n</code></pre>\n<p>然后就是实际内容区域了：<br>设置+主页构成。</p>\n<pre><code class=\"line-numbers language-Kotlin\">// 垂直布局，状态栏+内容区\n                    /**\n                     * 以前，我们在布局中去设置一个控件的大小，间距，点击事件，宽高，背景等属性值。\n                     * 而在Compose中我们是通过Modifie去设置，Modifie相当于一个控件的属性配置的工具类。\n                     */\n                    Column(Modifier.fillMaxSize()) &#123;\n                        // Show the top app bar on top level destinations.\n                        val destination = appState.currentTopLevelDestination\n                        if (destination != null) &#123;\n                            NiaTopAppBar(\n                                titleRes = destination.titleTextId,\n                                actionIcon = NiaIcons.Settings,\n                                actionIconContentDescription = stringResource(\n                                    id = settingsR.string.top_app_bar_action_icon_description\n                                ),\n                                colors = TopAppBarDefaults.centerAlignedTopAppBarColors(\n                                    containerColor = Color.Transparent\n                                ),\n                                /**\n                                 * 设置点击事件触发appState中的 mutableStateOf变量发生更改\n                                 */\n                                onActionClick = &#123; appState.setShowSettingsDialog(true) &#125;\n                            )\n                        &#125;\n\n                        // 主页面\n                        NiaNavHost(\n                            navController = appState.navController,\n                            onBackClick = appState::onBackClick\n                        )\n                    &#125;\n</code></pre>\n<p>NiaTopAppBar是自定义顶部标题栏<br>NiaNavHost是主页面</p>\n<p>主页面也是在App模块下的navigation文件夹中定义。</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun NiaNavHost(\n    /**\n     * 导航控制器\n     */\n    navController: NavHostController,\n    /**\n     * 返回点击\n     */\n    onBackClick: () -&gt; Unit,\n    /**\n     * 属性配置工具\n     */\n    modifier: Modifier = Modifier,\n    /**\n     * 开始路由设置\n     */\n    startDestination: String = forYouNavigationRoute\n) &#123;\n    NavHost(\n        navController = navController,\n        startDestination = startDestination,\n        modifier = modifier,\n    ) &#123;\n        forYouScreen()\n        bookmarksScreen()\n        interestsGraph(\n            navigateToTopic = &#123; topicId -&gt;\n                navController.navigateToTopic(topicId)\n            &#125;,\n            nestedGraphs = &#123;\n                topicScreen(onBackClick)\n            &#125;\n        )\n    &#125;\n&#125;\n</code></pre>\n<p>这里使用了一个NavHost 的compose官方组件。</p>\n<p>tab实现为：<br>forYouScreen 你的模块<br>bookmarksScreen 书签模块<br>interestsGraph 兴趣模块</p>\n<p>这几个tab都是依赖于其它module了。<br>app自身module大致内容就这么多了。</p>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<blockquote>\n<p>googe samples之 nowinandroid项目地址：<a href=\"https://github.com/android/nowinandroid\">https://github.com/android/nowinandroid</a></p>\n</blockquote>\n<h3 id=\"1-app模块build-gradle文件配置\"><a href=\"#1-app模块build-gradle文件配置\" class=\"headerlink\" title=\"1.app模块build.gradle文件配置\"></a>1.app模块build.gradle文件配置</h3><pre><code class=\"line-numbers language-Groovy\">plugins &#123;\n    id(&quot;nowinandroid.android.application&quot;)\n    id(&quot;nowinandroid.android.application.compose&quot;)\n    id(&quot;nowinandroid.android.application.jacoco&quot;)\n    id(&quot;nowinandroid.android.hilt&quot;)\n    id(&quot;jacoco&quot;)\n    id(&quot;nowinandroid.firebase-perf&quot;)\n&#125;\n</code></pre>\n<p>引入了application插件，compose插件，jacoco插件，hilt插件，firebase插件</p>\n<p>依赖项：</p>\n<pre><code class=\"line-numbers language-Groovy\">    implementation(project(&quot;:feature:interests&quot;))\n    implementation(project(&quot;:feature:foryou&quot;))\n    implementation(project(&quot;:feature:bookmarks&quot;))\n    implementation(project(&quot;:feature:topic&quot;))\n    implementation(project(&quot;:feature:settings&quot;))\n\n    implementation(project(&quot;:core:common&quot;))\n    implementation(project(&quot;:core:ui&quot;))\n    implementation(project(&quot;:core:designsystem&quot;))\n    implementation(project(&quot;:core:data&quot;))\n    implementation(project(&quot;:core:model&quot;))\n\n    implementation(project(&quot;:sync:work&quot;))\n</code></pre>\n<p>feature文件夹下是app模块的界面上拆分组件。<br>如feature_interests 就是兴趣tab<br>feature_foryou 就是第一个tab<br>feature_bookmarks 是书签模块<br>等等</p>\n<p>下面的core就是核心模块了，有通用组件，ui组件，设计系统，数据区</p>\n<p>然后sync_work是一些工具module了。</p>\n<h3 id=\"2-清单文件\"><a href=\"#2-清单文件\" class=\"headerlink\" title=\"2.清单文件\"></a>2.清单文件</h3><pre><code class=\"line-numbers language-xml\">    &lt;application\n        android:name=&quot;.NiaApplication&quot;\n        android:allowBackup=&quot;true&quot;\n        android:enableOnBackInvokedCallback=&quot;true&quot;\n        android:icon=&quot;@mipmap/ic_launcher&quot;\n        android:label=&quot;@string/app_name&quot;\n        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;\n        android:supportsRtl=&quot;true&quot;\n        android:theme=&quot;@style/Theme.Nia.Splash&quot;&gt;\n&lt;!--        Profileable 是 Android 10 中引入的清单配置，可用于 CPU 和内存分析任务。使用 profileable 标志而不是 debuggable 标志具有降低性能开销的关键优势；--&gt;\n        &lt;profileable android:shell=&quot;true&quot; tools:targetApi=&quot;q&quot; /&gt;\n\n        &lt;activity\n            android:name=&quot;.MainActivity&quot;\n            android:exported=&quot;true&quot;&gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;\n\n                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n    &lt;/application&gt;\n</code></pre>\n<p>这里很简单，就一个Application自定义的，一个首页，说明这个App就一个Activity。<br>这里引入了一个profileable标签，是Android10后引入的，可以用于CPU和内存分析任务。</p>\n<h3 id=\"3-自定义Application\"><a href=\"#3-自定义Application\" class=\"headerlink\" title=\"3.自定义Application\"></a>3.自定义Application</h3><p>这里App开始启动了。<br>首先是用了一个HiltAndroidApp的注解。<br>这个是类似Dragger的依赖注解框架，这里要求在Application用这个注解。<br>关于Hilt用法可参考：<a href=\"https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn\">https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn</a></p>\n<p>这里在Application里面初始化了一个东西：<br><code>Sync.initialize(context = this)</code><br>作用就是初始化Sync三方库。</p>\n<p>里面是这样走的：</p>\n<pre><code class=\"line-numbers language-Kotlin\">  AppInitializer.getInstance(context)\n            .initializeComponent(SyncInitializer::class.java)\n</code></pre>\n<p>AppInitializer是google的Jetpack下的startup中的类成员，关于这个用法可以参考下郭霖的博客：<a href=\"https://blog.csdn.net/guolin_blog/article/details/108026357\">https://blog.csdn.net/guolin_blog&#x2F;article&#x2F;details&#x2F;108026357</a></p>\n<p>为什么要引入这个同步的库呢？<br>&#x2F;**</p>\n<ul>\n<li>Registers work to sync the data layer periodically on app startup.</li>\n<li>初始化三方库 这里是WorkManager，主要用于</li>\n<li>Android出于设备电量的考虑，为开发者提供了WorkManager，旨在将一些不需要及时完成的任务交给它来完成。</li>\n<li>虽然WorkManager宣称，能够保证任务得到执行，但我在真实设备中，发现应用程序彻底退出与重启设备，任务都没有再次执行。</li>\n<li>查阅了相关资料，发现这应该与系统有关系。我们前面也提到了，WorkManager会根据系统的版本，</li>\n<li>决定采用JobScheduler或是AlarmManager+Broadcast Receivers来完成任务。</li>\n<li>但是这些API很可能会受到OEM系统的影响。比如，假设某个系统不允许AlarmManager自动唤起，那么WorkManager很可能就无法正常使用。<br> *&#x2F;</li>\n</ul>\n<h3 id=\"4-MainActivity-参数定义\"><a href=\"#4-MainActivity-参数定义\" class=\"headerlink\" title=\"4.MainActivity 参数定义\"></a>4.MainActivity 参数定义</h3><p> Application走完，就到了Activity了。<br> 首先是两个注解：</p>\n<ol>\n<li><p>@OptIn(ExperimentalMaterial3WindowSizeClassApi::class)<br> Opt-in 是 Kotlin 标准库中的一个方法，用于声明使用某些 API 需要明确的同意。<br>  该功能可以让开发者告知 API 使用者使用某些 API 需要一些特定的条件，如果使用者已经知晓则需要明确声明依旧使用（Opt-in）才能继续使用该 API。<br>  例如，某些 API 尚处于测试阶段，未来可能会发生变化；亦或是我前言中提到的场景，都非常适合使用该方法。<br>  如果我们声明了某个方法（functiuon）或类(class)需要 Opt-in ，则IDE或编译器会发出警告，要求使用者明确标注需要使用（Opt-in）。<br>  参考文档：<a href=\"https://juejin.cn/post/7157950373250990093\">https://juejin.cn/post/7157950373250990093</a></p>\n</li>\n<li><p>@AndroidEntryPoint<br>在要使用依赖注入的类上方添加@AndroidEntryPoint注解<br>参考文档：<a href=\"https://www.jianshu.com/p/22a36660a656\">https://www.jianshu.com/p/22a36660a656</a></p>\n</li>\n</ol>\n<p>然后声明了两个注入的变量：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n     * Lazily inject [JankStats], which is used to track jank throughout the app.\n     * JankStats 是首个专为在用户设备上检测及报告应用的性能问题而构建的 AndroidX 库。\n     * JankStats 是占用空间相对较小的 API，主要有三大目标: 捕获每帧的性能信息、在用户设备 (不仅是开发设备) 上运行、以及在应用出现性能问题时启用检测，并报告所发生的情况\n     *\n     * 在Dagger中Lazy可以将要注入的依赖项转变为懒加载模式，这样注入的依赖项，只有在需要使用时，\n     * 才会调用对应的依赖生成方法。懒加载的实现很简单，只需要在注入位置将依赖项的类型设置为Lazy接口的类型参数即可。\n     *\n     * 构造函数在di 文件夹下的 JankStatsModule 下\n     */\n    @Inject\n    lateinit var lazyStats: dagger.Lazy&lt;JankStats&gt;\n\n    /**\n     * 自定义网络监视器 这个是一个接口 应该也是测试用的\n     */\n    @Inject\n    lateinit var networkMonitor: NetworkMonitor\n</code></pre>\n<p> 关于lazyStats怎么初始化的？在项目di文件夹下有个JankStatsModule</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * 这里的目标是生产一个JankStats对象\n *\n * 怎么生产呢，需要2个构造参数\n * 1.JankStats.OnFrameListener\n * 2.Window\n *\n * window需要依赖activity，这里就需要 ActivityComponent了\n * 这个JankStats对象的生命周期设定为Activity级别\n */\n@Module\n@InstallIn(ActivityComponent::class)\nobject JankStatsModule &#123;\n    @Provides\n    fun providesOnFrameListener(): JankStats.OnFrameListener &#123;\n        return JankStats.OnFrameListener &#123; frameData -&gt;\n            // Make sure to only log janky frames.\n            if (frameData.isJank) &#123;\n                // We&#39;re currently logging this but would better report it to a backend.\n                Log.v(&quot;NiA Jank&quot;, frameData.toString())\n            &#125;\n        &#125;\n    &#125;\n\n    @Provides\n    fun providesWindow(activity: Activity): Window &#123;\n        return activity.window\n    &#125;\n\n    @Provides\n    fun providesJankStats(\n        window: Window,\n        frameListener: JankStats.OnFrameListener\n    ): JankStats &#123;\n        return JankStats.createAndTrack(window, frameListener)\n    &#125;\n&#125;\n</code></pre>\n<p>这里生产了  一个JankStats对象。</p>\n<p>关于网络监视器如何初始化的呢？<br>这个网络监视器是一个接口来的：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * Utility for reporting app connectivity status\n */\ninterface NetworkMonitor &#123;\n    val isOnline: Flow&lt;Boolean&gt;\n&#125;\n</code></pre>\n<p>一直没找到如何实例化的地方。<br>不过再其它模块，core下的data.di文件夹下发现了另外一个DataModule下有如下代码：</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n    @Binds\n    fun bindsNetworkMonitor(\n        networkMonitor: ConnectivityManagerNetworkMonitor\n    ): NetworkMonitor\n</code></pre>\n<p>这里貌似可以生产一个NetworkMonitor对象。<br>但怎么关联起来的呢？</p>\n<p>这个我确实不清楚hilt的用法，而且这个DataModule理应需要在Application配置，但也没找到相关依赖，可能hilt对加上这种注解能全局自动生成依赖代码也说不定。反正这里的网络监视器应该就是这个ConnectivityManagerNetworkMonitor 主要逻辑也在这里。</p>\n<p>第三个变量是viewModel<br><code> val viewModel: MainActivityViewModel by viewModels()</code><br>这个用法类似：<br><code>ViewModelProvider(this).get(MainActivityViewModel::class.java)</code></p>\n<h3 id=\"5-首页生命周期-onCreate\"><a href=\"#5-首页生命周期-onCreate\" class=\"headerlink\" title=\"5.首页生命周期-onCreate\"></a>5.首页生命周期-onCreate</h3><p>继续走，第一行是 适配闪屏页 installSplashScreen()<br>关于闪屏页可参考文档：<a href=\"https://blog.csdn.net/guolin_blog/article/details/120275319\">https://blog.csdn.net/guolin_blog&#x2F;article&#x2F;details&#x2F;120275319</a>（郭霖）</p>\n<p>然后这里监听了一个密封接口中的 Loading 状态，<br>密封接口定义如下：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * 首页ui 状态的密封类，有加载中和成功的状态\n * 密封接口 类似枚举类型，说明有Loading状态和成功状态\n * 表示受限制的类层次结构\n */\nsealed interface MainActivityUiState &#123;\n    object Loading : MainActivityUiState\n    data class Success(val userData: UserData) : MainActivityUiState\n&#125;\n</code></pre>\n<p>很明显这里Loading实现了这个接口，Success也实现了这个接口。</p>\n<p>在onCreate监听了这个Loading类：</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n        /**\n         * mutableStateOf 表明某个变量是有状态的，对变量进行监听，当状态改变时，触发重绘。\n         * remember --- 记录变量的值，使得下次使用改变量时不进行初始化。\n         * 使用 remember 存储对象的可组合项会创建内部状态，使该可组合项有状态。\n         * remember 会为函数提供存储空间，将 remember 计算的值储存，当 remember 的键改变的时候会进行重新计算值并储存。\n         * rememberSaveable --- 在这里顺带提一下,rememberSaveable 可以在重组后保持状态,也可以在重新创建 activity 和进程后保持状态。\n         */\n        var uiState: MainActivityUiState by mutableStateOf(Loading)\n</code></pre>\n<p>然后开启一个携程，拿用户数据：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> // Activity生命周期内使用携程\n        lifecycleScope.launch &#123;\n            // Lifecycle.State.STARTED: 表示只有在Activity处于Started状态的情况下，协程中的代码才会执行。\n            lifecycle.repeatOnLifecycle(Lifecycle.State.STARTED) &#123;\n                viewModel.uiState\n                    .onEach &#123;\n                        uiState = it\n                    &#125;\n                    .collect() // 走collect方法才代表执行携程\n            &#125;\n        &#125;\n</code></pre>\n<p>拿到数据后，才回去更新uiState对象。</p>\n<p>就是说uiState会有上面密封接口定义的两种类型。</p>\n<p>当监听到uiState变化后会走：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n         * 如果网络请求正在请求loading状态，就还是显示闪屏，如果拿到数据了就不需要闪屏了\n         */\n        splashScreen.setKeepOnScreenCondition &#123;\n            when (uiState) &#123;\n                Loading -&gt; true\n                is Success -&gt; false\n            &#125;\n        &#125;\n</code></pre>\n<p>闪屏会去除掉。</p>\n<p>下面开启沉浸式状态栏：</p>\n<pre><code class=\"line-numbers language-Kotlin\">  /**\n         * 第二参数decorFitsSystemWindows表示是否沉浸，false 表示沉浸，true表示不沉浸\n         */\n        WindowCompat.setDecorFitsSystemWindows(window, false)\n</code></pre>\n<p>然后就是内容区，compose设置内容区了<br>一个setContent的函数，太长了，就不全部贴图，挨个分析。</p>\n<p>1.首先获取一个systemUIController</p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n             * 开发者若想在 Compose 布局中控制 System UI，就必须获取 SystemUiController 对象。\n             * 通过该库提供 rememberSystemUiController 函数，开发者可以获取当前操作系统（目前仅支持 Android 系统）的  SystemUiController 对象。\n             */\n            val systemUiController = rememberSystemUiController()\n</code></pre>\n<p>2.是否使用深色主题，用户可以自己选</p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n             * 是否使用深色主题，入参当前ui状态\n             */\n            val darkTheme = shouldUseDarkTheme(uiState)\n            \n</code></pre>\n<p>内部实现：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * Returns `true` if dark theme should be used, as a function of the [uiState] and the\n * current system context.\n * 调用@Composable 函数的函数必须用@Composable 注解标记\n */\n@Composable\nprivate fun shouldUseDarkTheme(\n    uiState: MainActivityUiState,\n): Boolean = when (uiState) &#123;\n    /**\n     * isSystemInDarkTheme 根据系统来，加载中状态\n     */\n    Loading -&gt; isSystemInDarkTheme()\n    is Success -&gt; when (uiState.userData.darkThemeConfig) &#123;\n        /**\n         * 成功状态下，根据用户配置的数据来展示，如果跟随系统那就跟随，如果用户主动设置了某一种，那就成功时选择\n         */\n        DarkThemeConfig.FOLLOW_SYSTEM -&gt; isSystemInDarkTheme()\n        DarkThemeConfig.LIGHT -&gt; false\n        DarkThemeConfig.DARK -&gt; true\n    &#125;\n&#125;\n</code></pre>\n<p>然后开启一个DisposableEffect来关联上面这两个对象：</p>\n<pre><code class=\"line-numbers language-Kotlin\">  /**\n             * disposable，顾名思义，这就是一个自带清理作用的Effect\n             */\n            DisposableEffect(systemUiController, darkTheme) &#123;\n                // 否与导航栏图标+内容是否“黑暗&quot;\n                systemUiController.systemBarsDarkContentEnabled = !darkTheme\n                onDispose &#123;&#125;\n            &#125;\n</code></pre>\n<p>最后，开始设置App主题了：</p>\n<pre><code class=\"line-numbers language-Kotlin\">  /**\n             * 主题配置，是否暗色，判断用户是否有自己选择\n             * 是否用Android主题\n             * 下面这些代码才是内容区的布局，上面MainActivityUiState 这个只是拿用户的持久化数据，槽了\n             */\n            NiaTheme(\n                darkTheme = darkTheme,\n                androidTheme = shouldUseAndroidTheme(uiState)\n            ) &#123;\n                // NiaApp是一个闭包，作为第三个参数\n                NiaApp(\n                    /**\n                     * 窗口大小类，获取一个WindowSizeClass 这个实例\n                     */\n                    windowSizeClass = calculateWindowSizeClass(this),\n                    /**\n                     * 网络监视器，前面注入的\n                     */\n                    networkMonitor = networkMonitor,\n                )\n            &#125;\n</code></pre>\n<p>里面的闭包 NiaApp也就是开启了我们的App。</p>\n<h3 id=\"6-首页其它生命周期\"><a href=\"#6-首页其它生命周期\" class=\"headerlink\" title=\"6.首页其它生命周期\"></a>6.首页其它生命周期</h3><pre><code class=\"line-numbers language-Kotlin\">  override fun onResume() &#123;\n        super.onResume()\n        /**\n         * 跟踪性能\n         */\n        lazyStats.get().isTrackingEnabled = true\n    &#125;\n\n    override fun onPause() &#123;\n        super.onPause()\n        /**\n         * 去除跟踪\n         */\n        lazyStats.get().isTrackingEnabled = false\n    &#125;\n</code></pre>\n<p>MainActivity内容就这么多了，非常指简洁。<br>布局交给NiaApp类处理了。</p>\n<p>其它对象初始化交给hilt处理了。</p>\n<p>主要就只开了个协程获取用户数据，而且优化闪屏页和loading的显示。</p>\n<h3 id=\"7-NiaTheme主题设置\"><a href=\"#7-NiaTheme主题设置\" class=\"headerlink\" title=\"7.NiaTheme主题设置\"></a>7.NiaTheme主题设置</h3><p>先是主题颜色：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> // 主题颜色\n    val colorScheme = when &#123;\n        // 判断当前 android主题是暗色还是浅色\n        androidTheme -&gt; if (darkTheme) DarkAndroidColorScheme else LightAndroidColorScheme\n        // 没有禁用动态主题并且支持动态主题\n        !disableDynamicTheming &amp;&amp; supportsDynamicTheming() -&gt; &#123;\n            val context = LocalContext.current\n            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)\n        &#125;\n        // 其它情况\n        else -&gt; if (darkTheme) DarkDefaultColorScheme else LightDefaultColorScheme\n    &#125;\n</code></pre>\n<p>渐变色:</p>\n<pre><code class=\"line-numbers language-Kotlin\">    // Gradient colors 渐变色\n    // 空渐变色\n    val emptyGradientColors = GradientColors(container = colorScheme.surfaceColorAtElevation(2.dp))\n    // 默认渐变色\n    val defaultGradientColors = GradientColors(\n        top = colorScheme.inverseOnSurface,\n        bottom = colorScheme.primaryContainer,\n        container = colorScheme.surface\n    )\n    // 渐变色\n    val gradientColors = when &#123;\n        androidTheme -&gt; if (darkTheme) DarkAndroidGradientColors else LightAndroidGradientColors\n        !disableDynamicTheming &amp;&amp; supportsDynamicTheming() -&gt; emptyGradientColors\n        else -&gt; defaultGradientColors\n    &#125;\n</code></pre>\n<p>最终设置到MaterialTheme里面：</p>\n<pre><code class=\"line-numbers language-Kotlin\">   // Composition locals\n    CompositionLocalProvider(\n        LocalGradientColors provides gradientColors,\n        LocalBackgroundTheme provides backgroundTheme\n    ) &#123;\n        MaterialTheme(\n            colorScheme = colorScheme,\n            typography = NiaTypography,\n            content = content\n        )\n    &#125;\n</code></pre>\n<h3 id=\"8-NiaApp状态定义\"><a href=\"#8-NiaApp状态定义\" class=\"headerlink\" title=\"8.NiaApp状态定义\"></a>8.NiaApp状态定义</h3><p>首先创建一个NiaApp实例。<br>入参：窗口大小类，网络监视器</p>\n<pre><code class=\"line-numbers language-Kotlin\"> NiaApp(\n                    /**\n                     * 窗口大小类，获取一个WindowSizeClass 这个实例\n                     */\n                    windowSizeClass = calculateWindowSizeClass(this),\n                    /**\n                     * 网络监视器，前面注入的\n                     */\n                    networkMonitor = networkMonitor,\n                )\n</code></pre>\n<p>这里是App首页ui样式。</p>\n<p>这里用到的状态作为第三个参数，作为app状态记录。</p>\n<p>函数定义如下：</p>\n<pre><code class=\"line-numbers language-Kotlin\">@OptIn(\n    ExperimentalMaterial3Api::class,\n    ExperimentalLayoutApi::class,\n    ExperimentalComposeUiApi::class,\n    ExperimentalLifecycleComposeApi::class\n)\n@Composable\nfun NiaApp(\n    windowSizeClass: WindowSizeClass,\n    networkMonitor: NetworkMonitor,\n    /**\n     * app状态记录\n     */\n    appState: NiaAppState = rememberNiaAppState(\n        networkMonitor = networkMonitor,\n        windowSizeClass = windowSizeClass\n    ),\n) \n</code></pre>\n<p>这里第三个参数已经默认实现了。</p>\n<p>就是用于app状态记录，调用了一个自定义的rememberNiaAppState方法。</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun rememberNiaAppState(\n    windowSizeClass: WindowSizeClass,\n    networkMonitor: NetworkMonitor,\n    coroutineScope: CoroutineScope = rememberCoroutineScope(),\n    /**\n     * 导航控制器\n     */\n    navController: NavHostController = rememberNavController()\n): NiaAppState &#123;\n    NavigationTrackingSideEffect(navController)\n    /**\n     * remember 里面参数可以任意，闭包里面的东西，就是remember返回的东西\n     */\n    return remember(navController, coroutineScope, windowSizeClass, networkMonitor) &#123;\n        NiaAppState(navController, coroutineScope, windowSizeClass, networkMonitor)\n    &#125;\n&#125;\n</code></pre>\n<p>这里默认实现了协程作用域，导航控制器，需要返回一个NiaAppState变量。</p>\n<p>这里通过remember闭包来返回这个变量。</p>\n<p>这个NiaAppState定义如下：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * 主要用于类似LiveData保存的数据\n * App状态记录，需要传入导航控制器，携程作用范围，window窗口大小\n */\n@Stable\nclass NiaAppState(\n    val navController: NavHostController,\n    val coroutineScope: CoroutineScope,\n    val windowSizeClass: WindowSizeClass,\n    networkMonitor: NetworkMonitor,\n) &#123;\n</code></pre>\n<p>类似LiveData，保存了首页必要的一些数据。</p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 当前在那个tab\n     */\n    val currentDestination: NavDestination?\n        @Composable get() = navController\n            .currentBackStackEntryAsState().value?.destination\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 通过在哪个tab，决定用哪个枚举类， TopLevelDestination是自己定义的枚举类\n     */\n    val currentTopLevelDestination: TopLevelDestination?\n        @Composable get() = when (currentDestination?.route) &#123;\n            forYouNavigationRoute -&gt; FOR_YOU\n            bookmarksRoute -&gt; BOOKMARKS\n            interestsRoute -&gt; INTERESTS\n            else -&gt; null\n        &#125;\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 是否展示设置弹框\n     */\n    var shouldShowSettingsDialog by mutableStateOf(false)\n        private set\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 是否展示底部bar\n     */\n    val shouldShowBottomBar: Boolean\n        get() = windowSizeClass.widthSizeClass == WindowWidthSizeClass.Compact ||\n            windowSizeClass.heightSizeClass == WindowHeightSizeClass.Compact\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\">  /**\n     * 是否展示水平左侧导航\n     */\n    val shouldShowNavRail: Boolean\n        get() = !shouldShowBottomBar\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 监控网络，是否断网\n     */\n    val isOffline = networkMonitor.isOnline\n        .map(Boolean::not)\n        .stateIn(\n            scope = coroutineScope,\n            started = SharingStarted.WhileSubscribed(5_000),\n            initialValue = false\n        )\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\">   /**\n     * 这里是一个枚举类，表示底部tab集合\n     * Map of top level destinations to be used in the TopBar, BottomBar and NavRail. The key is the\n     * route.\n     */\n    val topLevelDestinations: List&lt;TopLevelDestination&gt; = TopLevelDestination.values().asList()\n</code></pre>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 点击tab事件传递\n     *\n     * @param topLevelDestination: The destination the app needs to navigate to.\n     */\n    fun navigateToTopLevelDestination(topLevelDestination: TopLevelDestination) &#123;\n        trace(&quot;Navigation: $&#123;topLevelDestination.name&#125;&quot;) &#123;\n            val topLevelNavOptions = navOptions &#123;\n                // Pop up to the start destination of the graph to\n                // avoid building up a large stack of destinations\n                // on the back stack as users select items\n                popUpTo(navController.graph.findStartDestination().id) &#123;\n                    saveState = true\n                &#125;\n                // Avoid multiple copies of the same destination when\n                // reselecting the same item\n                launchSingleTop = true\n                // Restore state when reselecting a previously selected item\n                restoreState = true\n            &#125;\n\n            when (topLevelDestination) &#123;\n                FOR_YOU -&gt; navController.navigateToForYou(topLevelNavOptions)\n                BOOKMARKS -&gt; navController.navigateToBookmarks(topLevelNavOptions)\n                INTERESTS -&gt; navController.navigateToInterestsGraph(topLevelNavOptions)\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>然后定义了一些方法：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n     * 返回点击\n     */\n    fun onBackClick() &#123;\n        navController.popBackStack()\n    &#125;\n\n    /**\n     * 改变设置弹框状态\n     */\n    fun setShowSettingsDialog(shouldShow: Boolean) &#123;\n        shouldShowSettingsDialog = shouldShow\n    &#125;\n</code></pre>\n<h3 id=\"9-NiaApp内容区\"><a href=\"#9-NiaApp内容区\" class=\"headerlink\" title=\"9.NiaApp内容区\"></a>9.NiaApp内容区</h3><p>App背景色</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun NiaBackground(\n    modifier: Modifier = Modifier,\n    content: @Composable () -&gt; Unit\n) &#123;\n    val color = LocalBackgroundTheme.current.color\n    val tonalElevation = LocalBackgroundTheme.current.tonalElevation\n    Surface(\n        color = if (color == Color.Unspecified) Color.Transparent else color,\n        tonalElevation = if (tonalElevation == Dp.Unspecified) 0.dp else tonalElevation,\n        modifier = modifier.fillMaxSize(),\n    ) &#123;\n        CompositionLocalProvider(LocalAbsoluteTonalElevation provides 0.dp) &#123;\n            content()\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>数据源使用 LocalBackgroundTheme.current.color</p>\n<p>内容区继续渐变背景：</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun NiaGradientBackground(\n    modifier: Modifier = Modifier,\n    gradientColors: GradientColors = LocalGradientColors.current,\n    content: @Composable () -&gt; Unit\n) &#123;\n    val currentTopColor by rememberUpdatedState(gradientColors.top)\n    val currentBottomColor by rememberUpdatedState(gradientColors.bottom)\n    Surface(\n        color = if (gradientColors.container == Color.Unspecified) &#123;\n            Color.Transparent\n        &#125; else &#123;\n            gradientColors.container\n        &#125;,\n        modifier = modifier.fillMaxSize()\n    ) &#123;\n        Box(\n            Modifier\n                .fillMaxSize()\n                .drawWithCache &#123;\n                    // Compute the start and end coordinates such that the gradients are angled 11.06\n                    // degrees off the vertical axis\n                    val offset = size.height * tan(\n                        Math\n                            .toRadians(11.06)\n                            .toFloat()\n                    )\n\n                    val start = Offset(size.width / 2 + offset / 2, 0f)\n                    val end = Offset(size.width / 2 - offset / 2, size.height)\n\n                    // Create the top gradient that fades out after the halfway point vertically\n                    val topGradient = Brush.linearGradient(\n                        0f to if (currentTopColor == Color.Unspecified) &#123;\n                            Color.Transparent\n                        &#125; else &#123;\n                            currentTopColor\n                        &#125;,\n                        0.724f to Color.Transparent,\n                        start = start,\n                        end = end,\n                    )\n                    // Create the bottom gradient that fades in before the halfway point vertically\n                    val bottomGradient = Brush.linearGradient(\n                        0.2552f to Color.Transparent,\n                        1f to if (currentBottomColor == Color.Unspecified) &#123;\n                            Color.Transparent\n                        &#125; else &#123;\n                            currentBottomColor\n                        &#125;,\n                        start = start,\n                        end = end,\n                    )\n\n                    onDrawBehind &#123;\n                        // There is overlap here, so order is important\n                        drawRect(topGradient)\n                        drawRect(bottomGradient)\n                    &#125;\n                &#125;\n        ) &#123;\n            content()\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里在上面0到0.724区间设置了topGradient<br>在0.2552f到1设置了 bottomGradient</p>\n<h3 id=\"10-业务内容区\"><a href=\"#10-业务内容区\" class=\"headerlink\" title=\"10.业务内容区\"></a>10.业务内容区</h3><pre><code class=\"line-numbers language-Kotlin\">   // 记录下snackbar状态，后续可能会刷新\n            val snackbarHostState = remember &#123; SnackbarHostState() &#125;\n</code></pre>\n<p>这个用于网络监听，如果没有网络，底部会常驻一个snackbar</p>\n<pre><code class=\"line-numbers language-Kotlin\">            // 是否离线\n            val isOffline by appState.isOffline.collectAsStateWithLifecycle()\n\n            // If user is not connected to the internet show a snack bar to inform them.\n            // 如果没有网络，底部展示Snackbar\n            val notConnectedMessage = stringResource(R.string.not_connected)\n            // 这个是Compose里面的launch，compose开启携程的方法\n            LaunchedEffect(isOffline) &#123;\n                if (isOffline) snackbarHostState.showSnackbar(\n                    message = notConnectedMessage,\n                    duration = Indefinite\n                )\n            &#125;\n</code></pre>\n<p>Kotlin<br>            &#x2F;&#x2F; 是否应该展示设置弹框，当点击右上角设置后，会弹出设置弹框<br>            if (appState.shouldShowSettingsDialog) {<br>                SettingsDialog(<br>                    onDismiss &#x3D; { appState.setShowSettingsDialog(false) }<br>                )<br>            }</p>\n<pre><code>\n然后就是脚手架了：\nScaffold，这里可以配置底部bar\n```Kotlin\n  Scaffold(\n                modifier = Modifier.semantics &#123;\n                    testTagsAsResourceId = true\n                &#125;,\n                containerColor = Color.Transparent,\n                contentColor = MaterialTheme.colorScheme.onBackground,\n                contentWindowInsets = WindowInsets(0, 0, 0, 0),\n                snackbarHost = &#123; SnackbarHost(snackbarHostState) &#125;,\n                // 底部bar 设置destinations，就是底部tab数据\n                bottomBar = &#123;\n                    if (appState.shouldShowBottomBar) &#123;\n                        NiaBottomBar(\n                            destinations = appState.topLevelDestinations,\n                            onNavigateToDestination = appState::navigateToTopLevelDestination,\n                            currentDestination = appState.currentDestination,\n                            modifier = Modifier.testTag(&quot;NiaBottomBar&quot;)\n                        )\n                    &#125;\n                &#125;\n            )\n</code></pre>\n<p>这里snackbarHost也是脚手架里面的内容。</p>\n<p>然后里面是一个Row，为什么是一个水平布局，因为考虑到兼容电视，平板，这里将导航页设置了一个水平的左侧导航。</p>\n<pre><code class=\"line-numbers language-Kotlin\">  // 平板 水平布局 左侧导航\n                    if (appState.shouldShowNavRail) &#123;\n                        NiaNavRail(\n                            destinations = appState.topLevelDestinations,\n                            onNavigateToDestination = appState::navigateToTopLevelDestination,\n                            currentDestination = appState.currentDestination,\n                            modifier = Modifier\n                                .testTag(&quot;NiaNavRail&quot;)\n                                .safeDrawingPadding()\n                        )\n                    &#125;\n</code></pre>\n<p>然后就是实际内容区域了：<br>设置+主页构成。</p>\n<pre><code class=\"line-numbers language-Kotlin\">// 垂直布局，状态栏+内容区\n                    /**\n                     * 以前，我们在布局中去设置一个控件的大小，间距，点击事件，宽高，背景等属性值。\n                     * 而在Compose中我们是通过Modifie去设置，Modifie相当于一个控件的属性配置的工具类。\n                     */\n                    Column(Modifier.fillMaxSize()) &#123;\n                        // Show the top app bar on top level destinations.\n                        val destination = appState.currentTopLevelDestination\n                        if (destination != null) &#123;\n                            NiaTopAppBar(\n                                titleRes = destination.titleTextId,\n                                actionIcon = NiaIcons.Settings,\n                                actionIconContentDescription = stringResource(\n                                    id = settingsR.string.top_app_bar_action_icon_description\n                                ),\n                                colors = TopAppBarDefaults.centerAlignedTopAppBarColors(\n                                    containerColor = Color.Transparent\n                                ),\n                                /**\n                                 * 设置点击事件触发appState中的 mutableStateOf变量发生更改\n                                 */\n                                onActionClick = &#123; appState.setShowSettingsDialog(true) &#125;\n                            )\n                        &#125;\n\n                        // 主页面\n                        NiaNavHost(\n                            navController = appState.navController,\n                            onBackClick = appState::onBackClick\n                        )\n                    &#125;\n</code></pre>\n<p>NiaTopAppBar是自定义顶部标题栏<br>NiaNavHost是主页面</p>\n<p>主页面也是在App模块下的navigation文件夹中定义。</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun NiaNavHost(\n    /**\n     * 导航控制器\n     */\n    navController: NavHostController,\n    /**\n     * 返回点击\n     */\n    onBackClick: () -&gt; Unit,\n    /**\n     * 属性配置工具\n     */\n    modifier: Modifier = Modifier,\n    /**\n     * 开始路由设置\n     */\n    startDestination: String = forYouNavigationRoute\n) &#123;\n    NavHost(\n        navController = navController,\n        startDestination = startDestination,\n        modifier = modifier,\n    ) &#123;\n        forYouScreen()\n        bookmarksScreen()\n        interestsGraph(\n            navigateToTopic = &#123; topicId -&gt;\n                navController.navigateToTopic(topicId)\n            &#125;,\n            nestedGraphs = &#123;\n                topicScreen(onBackClick)\n            &#125;\n        )\n    &#125;\n&#125;\n</code></pre>\n<p>这里使用了一个NavHost 的compose官方组件。</p>\n<p>tab实现为：<br>forYouScreen 你的模块<br>bookmarksScreen 书签模块<br>interestsGraph 兴趣模块</p>\n<p>这几个tab都是依赖于其它module了。<br>app自身module大致内容就这么多了。</p>\n"},{"title":"Android gradle相关 KTS脚本 项目配置改造","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-01-13T05:39:50.000Z","_content":"\n> googe samples之 nowinandroid项目地址：[https://github.com/android/nowinandroid](https://github.com/android/nowinandroid)\n\n### 1.gradle.properties\n这里面配置了 android.useAndroidX等常用的配置，这里应该耳熟能详了，这里就不过多介绍。下面这里有一块不是特别熟悉：\n```groovy\n# Disable build features that are enabled by default,\n# https://developer.android.com/studio/releases/gradle-plugin#buildFeatures\nandroid.defaults.buildfeatures.buildconfig=false\nandroid.defaults.buildfeatures.aidl=false\nandroid.defaults.buildfeatures.renderscript=false\nandroid.defaults.buildfeatures.resvalues=false\nandroid.defaults.buildfeatures.shaders=false\n```\n\n通过关闭buildfeatures.buildconfig，来提升构建性能。有时候模块不需要生成buildconfig文件，那直接关闭即可。还有其它的aidl，renderscript，resvalues同理。\n\n\n### 2.项目settings.gradle.kts\n这里首先是一个pluginManagement闭包：\n```groovy\npluginManagement {\n    includeBuild(\"build-logic\") // 多模块共享模块\n    repositories {\n        google()\n        mavenCentral()\n        gradlePluginPortal()\n    }\n}\n```\n第一个问题是：pluginManagement是什么东西啊？没见过。\n简单来说：dependencyManagement用于在父项目中统一对子项目依赖管理。这样就可以对所有模块的版本进行管理。\n\n第二个问题是：includeBuild是什么？\n相信大部分人都有用过buildSrc吧。如果没有，那config.gradle总用过吧，总之就是把不同模块之前相同依赖抽出来，同时引用。 buildSrc的弊端就是每次依赖更新都将重新构建整个项目，导致编译时间很长，这里google官方推荐使用includeBuild来解决这个问题。\n\n然后gradlePluginProtal() 远程插件仓库，是google推荐的。\n\n第二块代码是这样的：\n```groovy\ndependencyResolutionManagement {\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories {\n        google()\n        mavenCentral()\n    }\n}\n```\n\n当您的依赖项不是本地库或文件树时，Gradle 会在 settings.gradle 文件的 dependencyResolutionManagement { repositories {...} } 代码块中指定的所有在线仓库中查找相关文件。 各个仓库的列出顺序决定了 Gradle 在这些仓库中搜索各个项目依赖项的顺序。例如，如果从仓库 A 和 B 均可获得某个依赖项，而您先列出了仓库 A，则 Gradle 会从仓库 A 下载该依赖项。说白了，就是有一个优先权，从上往下。\n\n然后这个文件其它内容没啥参考价值了，都是include多个模块。\n这个文件最重要也是最关键的地方就是 includeBuild(\"build-logic\")\n\n\n### 3.项目级build.gradle.kts\n首先是一个buildscript闭包：\n```groovy\nbuildscript {\n    repositories {\n        maven { url = uri(\"https://maven.aliyun.com/repository/public\") }\n        maven { url = uri(\"https://maven.aliyun.com/repository/gradle-plugin\") }\n        maven { url = uri(\"https://maven.aliyun.com/repository/central\") }\n        maven { url = uri(\"https://maven.aliyun.com/repository/google\") }\n\n        mavenCentral()\n        google()\n\n\n        // Android Build Server\n        maven { url = uri(\"../nowinandroid-prebuilts/m2repository\") }\n    }\n}\n```\n其实这里引发了另外一个问题：\n在项目根目录（root Project）下的build.gradle中：buildscript、allprojects、subprojects的repositories有什么区别？\n\n1. buildScript块的repositories主要是为了Gradle脚本自身的执行，获取脚本依赖插件。也就是说，buildScript是用来加载Gradle脚本自身需要使用的资源，可以声明的资源包括依赖项、第三方插件、maven仓库地址等。\n2. 根级别的repositories主要是为了当前项目提供所需依赖包，比如log4j、spring-core等依赖包可从mavenCentral仓库获得。\n3. allprojects块的repositories用于多项目构建，为所有项目提供共同的所需依赖包。而子项目可以配置自己的repositories以获取自己独需的依赖包。\n4. subprojects块的repositories用于配置这个项目的子项目。使用多模块项目时，不同模块之间有相同的配置，导致重复配置，可以将相同的部分抽取出来，使用配置注入的技术完成子项目的配置。根项目就像一个容器, subprojects 方法遍历这个容器的所有元素并且注入指定的配置。allprojects是对所有project的配置，包括Root Project。而subprojects是对所有Child Project的配置。\n\n这里说明buildScript里面的仓库主要用于Gradle脚本自身执行，因为这里一直超时，我把阿里云镜像加进去就没问题了，估计是下载Gradle脚本自身相关依赖导致超时了。\n\n然后下面还有一部分是plugins闭包：\n```groovy\nplugins {\n    alias(libs.plugins.android.application) apply false\n    alias(libs.plugins.kotlin.jvm) apply false\n    alias(libs.plugins.kotlin.serialization) apply false\n    alias(libs.plugins.hilt) apply false\n    alias(libs.plugins.secrets) apply false\n}\n```\n这里的libs就是在 前面的build-logic模块下的 versionCatalogs创建的一个名称。\n定义了后，这里就可以引用了。这里应该是引用插件，不过都是apply false，这里的作用个人还不是很清楚。\n\n### 4.app模块下的build.gradle.kts\n这里第一行是：\n`import com.google.samples.apps.nowinandroid.NiaBuildType`\n这里可以引用自己编写的类，\n这个类定义再build-logic模块中，是一个枚举类，看一下吧：\n```groovy\npackage com.google.samples.apps.nowinandroid\n\n/**\n * This is shared between :app and :benchmarks module to provide configurations type safety.\n */\n@Suppress(\"unused\")\nenum class NiaBuildType(val applicationIdSuffix: String? = null) {\n    DEBUG(\".debug\"),\n    RELEASE,\n    BENCHMARK(\".benchmark\")\n}\n\n```\n估计是代表编译模式，debug还是release，或者其它模式。\n\n然后继续回到build.gradle.kts文件下，\n这里引入插件了：\n```groovy\nplugins {\n    id(\"nowinandroid.android.application\")\n    id(\"nowinandroid.android.application.compose\")\n    id(\"nowinandroid.android.application.jacoco\")\n    id(\"nowinandroid.android.hilt\")\n    id(\"jacoco\")\n    id(\"nowinandroid.firebase-perf\")\n}\n```\n\n注意这几个有nowinandroid前缀的应该都是我们自己编写的插件。\n首先看下第一个：noewinandroid.android.application\n\n当然还是先全局搜索下，发现在build-logic模块下注册了：\n```groovy\ngradlePlugin {\n    plugins {\n        register(\"androidApplicationCompose\") {\n            id = \"nowinandroid.android.application.compose\"\n            implementationClass = \"AndroidApplicationComposeConventionPlugin\"\n        }\n        register(\"androidApplication\") {\n            id = \"nowinandroid.android.application\"\n            implementationClass = \"AndroidApplicationConventionPlugin\"\n        }\n```\n实现类为：AndroidApplicationConventionPlugin\n```groovy\nclass AndroidApplicationConventionPlugin : Plugin<Project> {\n    override fun apply(target: Project) {\n        with(target) {\n            with(pluginManager) {\n                apply(\"com.android.application\")\n                apply(\"org.jetbrains.kotlin.android\")\n            }\n\n            extensions.configure<ApplicationExtension> {\n                configureKotlinAndroid(this)\n                defaultConfig.targetSdk = 33\n                configureFlavors(this)\n            }\n            extensions.configure<ApplicationAndroidComponentsExtension> {\n                configurePrintApksTask(this)\n            }\n        }\n    }\n}\n```\n这里继承了Plugin<Project>，实现apply方法。\n利用插件管理器pluginManager来引入\"com.android.application\"插件和“org.jetbrains.kotlin.android”插件。\n\n可以看到这里面帮忙apply了com.android.application，这样就不用重复再build.gradle中引入了。\n\n重点来看下引入的compose，说实话我还没用过google的jetpack compose工具包。\n依然在build-logic下注册了这个插件：\n```groovy\ngradlePlugin {\n    plugins {\n        register(\"androidApplicationCompose\") {\n            id = \"nowinandroid.android.application.compose\"\n            implementationClass = \"AndroidApplicationComposeConventionPlugin\"\n        }\n```\n实现类：AndroidApplicationComposeConventionPlugin\n```groovy\nclass AndroidApplicationComposeConventionPlugin : Plugin<Project> {\n    override fun apply(target: Project) {\n        with(target) {\n            pluginManager.apply(\"com.android.application\")\n            val extension = extensions.getByType<ApplicationExtension>()\n            configureAndroidCompose(extension)\n        }\n    }\n\n}\n```\n非常简单，先apply了com.android.application\n然后调用了一个 configureAndroidCompose 方法，这是一个扩展方法，也是在build-logic下的一个kt文件中对Project进行了扩展。\n```groovy\n/**\n * Configure Compose-specific options\n */\ninternal fun Project.configureAndroidCompose(\n    commonExtension: CommonExtension<*, *, *, *>,\n) {\n    val libs = extensions.getByType<VersionCatalogsExtension>().named(\"libs\")\n\n    commonExtension.apply {\n        buildFeatures {\n            compose = true\n        }\n\n        composeOptions {\n            kotlinCompilerExtensionVersion = libs.findVersion(\"androidxComposeCompiler\").get().toString()\n        }\n\n        kotlinOptions {\n            freeCompilerArgs = freeCompilerArgs + buildComposeMetricsParameters()\n        }\n\n        dependencies {\n            val bom = libs.findLibrary(\"androidx-compose-bom\").get()\n            add(\"implementation\", platform(bom))\n            add(\"androidTestImplementation\", platform(bom))\n        }\n    }\n}\n```\n这里编写了compose相关的必要的配置。buildFeaturs，composeOptions,kotlinOptions,dependencies这些都加上了。\n\n再回到app模块下的build.gradle.kts文件，\n还有一个插件是：nowinandroid.android.application.jacoco\n这个是自定义的一个代码覆盖率的一个插件，基于jacoco的。\n```groovy\n register(\"androidApplicationJacoco\") {\n            id = \"nowinandroid.android.application.jacoco\"\n            implementationClass = \"AndroidApplicationJacocoConventionPlugin\"\n        }\n```\n先注册，再看下实现类：\n```groovy\n\nclass AndroidApplicationJacocoConventionPlugin : Plugin<Project> {\n    override fun apply(target: Project) {\n        with(target) {\n            with(pluginManager) {\n                apply(\"org.gradle.jacoco\")\n                apply(\"com.android.application\")\n            }\n            val extension = extensions.getByType<ApplicationAndroidComponentsExtension>()\n            configureJacoco(extension)\n        }\n    }\n\n}\n```\n这里引入了gradle的jacoco插件，然后调用了configureJacoco方法。\n具体插件使用方法可以这里看下：[https://www.w3cschool.cn/gradle/9pg71huj.html](https://www.w3cschool.cn/gradle/9pg71huj.html)\n\n这个配置起来确实很麻烦，如果全部代码加到app模块下，很难进行维护，这样以插件形式确实方便很多。\n\n这里继续看app模块引入的自定义插件：hilt\n这个想必大家都不陌生了，是一个依赖注入的插件，基于Dragger，但比Dragger简洁很多了。\n实现类为：\n```groovy\nclass AndroidHiltConventionPlugin : Plugin<Project> {\n    override fun apply(target: Project) {\n        with(target) {\n            with(pluginManager) {\n                apply(\"dagger.hilt.android.plugin\")\n                // KAPT must go last to avoid build warnings.\n                // See: https://stackoverflow.com/questions/70550883/warning-the-following-options-were-not-recognized-by-any-processor-dagger-f\n                apply(\"org.jetbrains.kotlin.kapt\")\n            }\n\n            val libs = extensions.getByType<VersionCatalogsExtension>().named(\"libs\")\n            dependencies {\n                \"implementation\"(libs.findLibrary(\"hilt.android\").get())\n                \"kapt\"(libs.findLibrary(\"hilt.compiler\").get())\n                \"kaptAndroidTest\"(libs.findLibrary(\"hilt.compiler\").get())\n            }\n\n        }\n    }\n}\n```\n这样就配置好了hilt。\n\n最后一个app模块引入的插件是firebase-perf\n这个是google出品的性能监控插件。\n具体用法参考：[https://blog.csdn.net/u010207898/article/details/125070024](https://blog.csdn.net/u010207898/article/details/125070024)\n\n\n* * *\n好的下面继续看app模块下的build.gradle.kts\nandroid层级下基本没啥大问题，配置applicationId版本号之类的。\n这里有个testInstrumentationRunner选择自定义了：\n`testInstrumentationRunner = \"com.google.samples.apps.nowinandroid.core.testing.NiaTestRunner\"`\n\n看下这里做了啥：\n可以看到这个路径下是在testing模块下的，那应该就是测试相关的了。这里主要是用于单元测试的。这个NiaTestRunner继承了AndroidJunitRunner，这里代码如下：\n```groovy\nclass NiaTestRunner : AndroidJUnitRunner() {\n    override fun newApplication(cl: ClassLoader?, name: String?, context: Context?): Application {\n        return super.newApplication(cl, HiltTestApplication::class.java.name, context)\n    }\n}\n```\n\n这个hilt居然还有做单元测试的注入，还是不错，收藏了。\n\n看下buildTypes里面的配置：\n```groovy\n   buildTypes {\n        val debug by getting {\n            applicationIdSuffix = NiaBuildType.DEBUG.applicationIdSuffix\n        }\n```\n这里val debug by gettting为啥这样写？\n这里其实分了2步：\n```groovy\nval release = getByName(\"release\")\n    release.apply {\n```\n\n等价于：\n` val release by getting`\n\n继续下面：\n```groovy\n   packagingOptions {\n        resources {\n            excludes.add(\"/META-INF/{AL2.0,LGPL2.1}\")\n        }\n    }\n```\n这个配置是什么呢：\n打包配置，需要移除这个文件。\n\n继续下面：\n```groovy\n  testOptions {\n        unitTests {\n            isIncludeAndroidResources = true\n        }\n        // TODO: Convert it as a convention plugin once Flamingo goes out (https://github.com/android/nowinandroid/issues/523)\n        managedDevices {\n            devices {\n                maybeCreate<com.android.build.api.dsl.ManagedVirtualDevice>(\"pixel4api30\").apply {\n                    device = \"Pixel 4\"\n                    apiLevel = 30\n                    // ATDs currently support only API level 30.\n                    systemImageSource = \"aosp-atd\"\n                }\n            }\n        }\n    }\n```\n这里是一个testOptions，主要用于配置测试设备的一些属性。\n\n这里关于其它配置可以参考这篇文档[https://blog.csdn.net/shulianghan/article/details/124919287](https://blog.csdn.net/shulianghan/article/details/124919287)\n\n继续看android闭包最后一个配置:\n`namespace = \"com.google.samples.apps.nowinandroid\"`\n\n每个 Android 模块都有一个命名空间，此命名空间用作其生成的 R 和 BuildConfig 类的 Java 或 Kotlin 软件包名称。命名空间由模块的 build.gradle 文件中的 namespace 属性定义，如以下代码段所示。namespace 最初会设为您在创建项目时选择的软件包名称。\n\n最下面就是我们熟悉的dependencies了，可以看到这里非常简练，没有任何版本号，全是通过lis引入的，看着很舒服。\n```groovy\n\ndependencies {\n    implementation(project(\":feature:interests\"))\n    implementation(project(\":feature:foryou\"))\n    implementation(project(\":feature:bookmarks\"))\n    implementation(project(\":feature:topic\"))\n    implementation(project(\":feature:settings\"))\n\n    implementation(project(\":core:common\"))\n    implementation(project(\":core:ui\"))\n    implementation(project(\":core:designsystem\"))\n    implementation(project(\":core:data\"))\n    implementation(project(\":core:model\"))\n\n    implementation(project(\":sync:work\"))\n\n    androidTestImplementation(project(\":core:testing\"))\n    androidTestImplementation(project(\":core:datastore-test\"))\n    androidTestImplementation(project(\":core:data-test\"))\n    androidTestImplementation(project(\":core:network\"))\n    androidTestImplementation(libs.androidx.navigation.testing)\n    androidTestImplementation(libs.accompanist.testharness)\n    androidTestImplementation(kotlin(\"test\"))\n    debugImplementation(libs.androidx.compose.ui.testManifest)\n    debugImplementation(project(\":ui-test-hilt-manifest\"))\n\n    implementation(libs.accompanist.systemuicontroller)\n    implementation(libs.androidx.activity.compose)\n    implementation(libs.androidx.appcompat)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.core.splashscreen)\n    implementation(libs.androidx.compose.runtime)\n    implementation(libs.androidx.lifecycle.runtimeCompose)\n    implementation(libs.androidx.compose.runtime.tracing)\n    implementation(libs.androidx.compose.material3.windowSizeClass)\n    implementation(libs.androidx.hilt.navigation.compose)\n    implementation(libs.androidx.navigation.compose)\n    implementation(libs.androidx.window.manager)\n    implementation(libs.androidx.profileinstaller)\n\n    implementation(libs.coil.kt)\n    implementation(libs.coil.kt.svg)\n}\n\n```\n\n最下面是强制使用某个依赖：\n```groovy\n// androidx.test is forcing JUnit, 4.12. This forces it to use 4.13\nconfigurations.configureEach {\n    resolutionStrategy {\n        force(libs.junit4)\n        // Temporary workaround for https://issuetracker.google.com/174733673\n        force(\"org.objenesis:objenesis:2.6\")\n    }\n}\n```\n\n### 5.build-logic 模块配置构建逻辑\n这里完全封装了自定义插件，定义依赖，配置相关的逻辑主要在这个模块，其实这个模块感觉可以复用，就是说换一个项目，这个模块基本上可以通用，改改具体版本号或者属性即可。哪些要用，哪些不用，在app模块下按需注册插件即可。\n\n首先看下这个模块的setttings.gradle.kts文件\n很简单：\n```groovy\ndependencyResolutionManagement {\n    repositories {\n        google()\n        mavenCentral()\n    }\n    versionCatalogs {\n        create(\"libs\") {\n            from(files(\"../gradle/libs.versions.toml\"))\n        }\n    }\n}\n\nrootProject.name = \"build-logic\"\ninclude(\":convention\")\n```\n\n这里最为关键的是用了一个 versionCatelogs，这里定义了我们所有三方依赖的地方。然后引入了这个模块下的convention的具体模块，这个模块就是编写自定义插件的地方。\n\n简单看下这个libs.version.toml文件吧，它放在项目级下的gradle文件夹中了：\n```groovy\n[versions]\naccompanist = \"0.28.0\"\nandroidDesugarJdkLibs = \"1.2.2\"\nandroidGradlePlugin = \"7.3.1\"\nandroidxActivity = \"1.6.1\"\nandroidxAppCompat = \"1.5.1\"\nandroidxBrowser = \"1.4.0\"\nandroidxComposeBom = \"2022.12.00\"\nandroidxComposeCompiler = \"1.4.0-alpha02\"\nandroidxComposeRuntimeTracing = \"1.0.0-alpha01\"\nandroidxCore = \"1.9.0\"\nandroidxCoreSplashscreen = \"1.0.0\"\nandroidxDataStore = \"1.0.0\"\nandroidxEspresso = \"3.5.0\"\nandroidxHiltNavigationCompose = \"1.0.0\"\nandroidxLifecycle = \"2.6.0-alpha03\"\nandroidxMacroBenchmark = \"1.1.1\"\nandroidxMetrics = \"1.0.0-alpha03\"\nandroidxNavigation = \"2.5.3\"\nandroidxProfileinstaller = \"1.2.1\"\n等等...\n```\n\n看下build-logic 模块下的build.gradle.kts文件：\n首先引入了 kotlin-dsl 插件：\n```groovy\nplugins {\n    `kotlin-dsl`\n}\n```\n这样就能写 java 闭包了，还有一些 compileOnly方法等。具体关于dsl使用方法可以参考这篇文章：[https://www.jianshu.com/p/461d4a249b71](https://www.jianshu.com/p/461d4a249b71)\n\n下面配置了执行build-logic需要依赖的一些东西：\n```groovy\njava {\n    sourceCompatibility = JavaVersion.VERSION_1_8\n    targetCompatibility = JavaVersion.VERSION_1_8\n}\n\ndependencies {\n    compileOnly(libs.android.gradlePlugin)\n    compileOnly(libs.kotlin.gradlePlugin)\n}\n\n```\n\n这里需要编译依赖一些三方库。\n\n然后下面是重点，gradlePlugin闭包下就是注册各种自定义插件了，并且实现类对应convention模块下的某个类，这个类继承了Plugin<Project>。\n\n\n\n### 6.总结\n1.单独抽出一个module作为封装自定义插件的module。在这个module里面添加自定义插件的逻辑，在这个module的settings.gradle.kts中创建一个versionCatelogs，指向所有依赖文件中。\n2.项目级别的settings.gradle.kts用includeBuild来引入上述module。\n3.gradle.properties文件可以配置编译时buildconfig，aidl等文件是否生成。\n4.app级别的build.gradle.kts按需配置自定义插件，testInstrumentationRunnner可以配置测试类。","source":"_posts/Android-gradle相关-KTS脚本-项目配置改造.md","raw":"---\ntitle: Android gradle相关 KTS脚本 项目配置改造\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-01-13 13:39:50\ntags:\n- Android\ncategories:\n- Android\n---\n\n> googe samples之 nowinandroid项目地址：[https://github.com/android/nowinandroid](https://github.com/android/nowinandroid)\n\n### 1.gradle.properties\n这里面配置了 android.useAndroidX等常用的配置，这里应该耳熟能详了，这里就不过多介绍。下面这里有一块不是特别熟悉：\n```groovy\n# Disable build features that are enabled by default,\n# https://developer.android.com/studio/releases/gradle-plugin#buildFeatures\nandroid.defaults.buildfeatures.buildconfig=false\nandroid.defaults.buildfeatures.aidl=false\nandroid.defaults.buildfeatures.renderscript=false\nandroid.defaults.buildfeatures.resvalues=false\nandroid.defaults.buildfeatures.shaders=false\n```\n\n通过关闭buildfeatures.buildconfig，来提升构建性能。有时候模块不需要生成buildconfig文件，那直接关闭即可。还有其它的aidl，renderscript，resvalues同理。\n\n\n### 2.项目settings.gradle.kts\n这里首先是一个pluginManagement闭包：\n```groovy\npluginManagement {\n    includeBuild(\"build-logic\") // 多模块共享模块\n    repositories {\n        google()\n        mavenCentral()\n        gradlePluginPortal()\n    }\n}\n```\n第一个问题是：pluginManagement是什么东西啊？没见过。\n简单来说：dependencyManagement用于在父项目中统一对子项目依赖管理。这样就可以对所有模块的版本进行管理。\n\n第二个问题是：includeBuild是什么？\n相信大部分人都有用过buildSrc吧。如果没有，那config.gradle总用过吧，总之就是把不同模块之前相同依赖抽出来，同时引用。 buildSrc的弊端就是每次依赖更新都将重新构建整个项目，导致编译时间很长，这里google官方推荐使用includeBuild来解决这个问题。\n\n然后gradlePluginProtal() 远程插件仓库，是google推荐的。\n\n第二块代码是这样的：\n```groovy\ndependencyResolutionManagement {\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories {\n        google()\n        mavenCentral()\n    }\n}\n```\n\n当您的依赖项不是本地库或文件树时，Gradle 会在 settings.gradle 文件的 dependencyResolutionManagement { repositories {...} } 代码块中指定的所有在线仓库中查找相关文件。 各个仓库的列出顺序决定了 Gradle 在这些仓库中搜索各个项目依赖项的顺序。例如，如果从仓库 A 和 B 均可获得某个依赖项，而您先列出了仓库 A，则 Gradle 会从仓库 A 下载该依赖项。说白了，就是有一个优先权，从上往下。\n\n然后这个文件其它内容没啥参考价值了，都是include多个模块。\n这个文件最重要也是最关键的地方就是 includeBuild(\"build-logic\")\n\n\n### 3.项目级build.gradle.kts\n首先是一个buildscript闭包：\n```groovy\nbuildscript {\n    repositories {\n        maven { url = uri(\"https://maven.aliyun.com/repository/public\") }\n        maven { url = uri(\"https://maven.aliyun.com/repository/gradle-plugin\") }\n        maven { url = uri(\"https://maven.aliyun.com/repository/central\") }\n        maven { url = uri(\"https://maven.aliyun.com/repository/google\") }\n\n        mavenCentral()\n        google()\n\n\n        // Android Build Server\n        maven { url = uri(\"../nowinandroid-prebuilts/m2repository\") }\n    }\n}\n```\n其实这里引发了另外一个问题：\n在项目根目录（root Project）下的build.gradle中：buildscript、allprojects、subprojects的repositories有什么区别？\n\n1. buildScript块的repositories主要是为了Gradle脚本自身的执行，获取脚本依赖插件。也就是说，buildScript是用来加载Gradle脚本自身需要使用的资源，可以声明的资源包括依赖项、第三方插件、maven仓库地址等。\n2. 根级别的repositories主要是为了当前项目提供所需依赖包，比如log4j、spring-core等依赖包可从mavenCentral仓库获得。\n3. allprojects块的repositories用于多项目构建，为所有项目提供共同的所需依赖包。而子项目可以配置自己的repositories以获取自己独需的依赖包。\n4. subprojects块的repositories用于配置这个项目的子项目。使用多模块项目时，不同模块之间有相同的配置，导致重复配置，可以将相同的部分抽取出来，使用配置注入的技术完成子项目的配置。根项目就像一个容器, subprojects 方法遍历这个容器的所有元素并且注入指定的配置。allprojects是对所有project的配置，包括Root Project。而subprojects是对所有Child Project的配置。\n\n这里说明buildScript里面的仓库主要用于Gradle脚本自身执行，因为这里一直超时，我把阿里云镜像加进去就没问题了，估计是下载Gradle脚本自身相关依赖导致超时了。\n\n然后下面还有一部分是plugins闭包：\n```groovy\nplugins {\n    alias(libs.plugins.android.application) apply false\n    alias(libs.plugins.kotlin.jvm) apply false\n    alias(libs.plugins.kotlin.serialization) apply false\n    alias(libs.plugins.hilt) apply false\n    alias(libs.plugins.secrets) apply false\n}\n```\n这里的libs就是在 前面的build-logic模块下的 versionCatalogs创建的一个名称。\n定义了后，这里就可以引用了。这里应该是引用插件，不过都是apply false，这里的作用个人还不是很清楚。\n\n### 4.app模块下的build.gradle.kts\n这里第一行是：\n`import com.google.samples.apps.nowinandroid.NiaBuildType`\n这里可以引用自己编写的类，\n这个类定义再build-logic模块中，是一个枚举类，看一下吧：\n```groovy\npackage com.google.samples.apps.nowinandroid\n\n/**\n * This is shared between :app and :benchmarks module to provide configurations type safety.\n */\n@Suppress(\"unused\")\nenum class NiaBuildType(val applicationIdSuffix: String? = null) {\n    DEBUG(\".debug\"),\n    RELEASE,\n    BENCHMARK(\".benchmark\")\n}\n\n```\n估计是代表编译模式，debug还是release，或者其它模式。\n\n然后继续回到build.gradle.kts文件下，\n这里引入插件了：\n```groovy\nplugins {\n    id(\"nowinandroid.android.application\")\n    id(\"nowinandroid.android.application.compose\")\n    id(\"nowinandroid.android.application.jacoco\")\n    id(\"nowinandroid.android.hilt\")\n    id(\"jacoco\")\n    id(\"nowinandroid.firebase-perf\")\n}\n```\n\n注意这几个有nowinandroid前缀的应该都是我们自己编写的插件。\n首先看下第一个：noewinandroid.android.application\n\n当然还是先全局搜索下，发现在build-logic模块下注册了：\n```groovy\ngradlePlugin {\n    plugins {\n        register(\"androidApplicationCompose\") {\n            id = \"nowinandroid.android.application.compose\"\n            implementationClass = \"AndroidApplicationComposeConventionPlugin\"\n        }\n        register(\"androidApplication\") {\n            id = \"nowinandroid.android.application\"\n            implementationClass = \"AndroidApplicationConventionPlugin\"\n        }\n```\n实现类为：AndroidApplicationConventionPlugin\n```groovy\nclass AndroidApplicationConventionPlugin : Plugin<Project> {\n    override fun apply(target: Project) {\n        with(target) {\n            with(pluginManager) {\n                apply(\"com.android.application\")\n                apply(\"org.jetbrains.kotlin.android\")\n            }\n\n            extensions.configure<ApplicationExtension> {\n                configureKotlinAndroid(this)\n                defaultConfig.targetSdk = 33\n                configureFlavors(this)\n            }\n            extensions.configure<ApplicationAndroidComponentsExtension> {\n                configurePrintApksTask(this)\n            }\n        }\n    }\n}\n```\n这里继承了Plugin<Project>，实现apply方法。\n利用插件管理器pluginManager来引入\"com.android.application\"插件和“org.jetbrains.kotlin.android”插件。\n\n可以看到这里面帮忙apply了com.android.application，这样就不用重复再build.gradle中引入了。\n\n重点来看下引入的compose，说实话我还没用过google的jetpack compose工具包。\n依然在build-logic下注册了这个插件：\n```groovy\ngradlePlugin {\n    plugins {\n        register(\"androidApplicationCompose\") {\n            id = \"nowinandroid.android.application.compose\"\n            implementationClass = \"AndroidApplicationComposeConventionPlugin\"\n        }\n```\n实现类：AndroidApplicationComposeConventionPlugin\n```groovy\nclass AndroidApplicationComposeConventionPlugin : Plugin<Project> {\n    override fun apply(target: Project) {\n        with(target) {\n            pluginManager.apply(\"com.android.application\")\n            val extension = extensions.getByType<ApplicationExtension>()\n            configureAndroidCompose(extension)\n        }\n    }\n\n}\n```\n非常简单，先apply了com.android.application\n然后调用了一个 configureAndroidCompose 方法，这是一个扩展方法，也是在build-logic下的一个kt文件中对Project进行了扩展。\n```groovy\n/**\n * Configure Compose-specific options\n */\ninternal fun Project.configureAndroidCompose(\n    commonExtension: CommonExtension<*, *, *, *>,\n) {\n    val libs = extensions.getByType<VersionCatalogsExtension>().named(\"libs\")\n\n    commonExtension.apply {\n        buildFeatures {\n            compose = true\n        }\n\n        composeOptions {\n            kotlinCompilerExtensionVersion = libs.findVersion(\"androidxComposeCompiler\").get().toString()\n        }\n\n        kotlinOptions {\n            freeCompilerArgs = freeCompilerArgs + buildComposeMetricsParameters()\n        }\n\n        dependencies {\n            val bom = libs.findLibrary(\"androidx-compose-bom\").get()\n            add(\"implementation\", platform(bom))\n            add(\"androidTestImplementation\", platform(bom))\n        }\n    }\n}\n```\n这里编写了compose相关的必要的配置。buildFeaturs，composeOptions,kotlinOptions,dependencies这些都加上了。\n\n再回到app模块下的build.gradle.kts文件，\n还有一个插件是：nowinandroid.android.application.jacoco\n这个是自定义的一个代码覆盖率的一个插件，基于jacoco的。\n```groovy\n register(\"androidApplicationJacoco\") {\n            id = \"nowinandroid.android.application.jacoco\"\n            implementationClass = \"AndroidApplicationJacocoConventionPlugin\"\n        }\n```\n先注册，再看下实现类：\n```groovy\n\nclass AndroidApplicationJacocoConventionPlugin : Plugin<Project> {\n    override fun apply(target: Project) {\n        with(target) {\n            with(pluginManager) {\n                apply(\"org.gradle.jacoco\")\n                apply(\"com.android.application\")\n            }\n            val extension = extensions.getByType<ApplicationAndroidComponentsExtension>()\n            configureJacoco(extension)\n        }\n    }\n\n}\n```\n这里引入了gradle的jacoco插件，然后调用了configureJacoco方法。\n具体插件使用方法可以这里看下：[https://www.w3cschool.cn/gradle/9pg71huj.html](https://www.w3cschool.cn/gradle/9pg71huj.html)\n\n这个配置起来确实很麻烦，如果全部代码加到app模块下，很难进行维护，这样以插件形式确实方便很多。\n\n这里继续看app模块引入的自定义插件：hilt\n这个想必大家都不陌生了，是一个依赖注入的插件，基于Dragger，但比Dragger简洁很多了。\n实现类为：\n```groovy\nclass AndroidHiltConventionPlugin : Plugin<Project> {\n    override fun apply(target: Project) {\n        with(target) {\n            with(pluginManager) {\n                apply(\"dagger.hilt.android.plugin\")\n                // KAPT must go last to avoid build warnings.\n                // See: https://stackoverflow.com/questions/70550883/warning-the-following-options-were-not-recognized-by-any-processor-dagger-f\n                apply(\"org.jetbrains.kotlin.kapt\")\n            }\n\n            val libs = extensions.getByType<VersionCatalogsExtension>().named(\"libs\")\n            dependencies {\n                \"implementation\"(libs.findLibrary(\"hilt.android\").get())\n                \"kapt\"(libs.findLibrary(\"hilt.compiler\").get())\n                \"kaptAndroidTest\"(libs.findLibrary(\"hilt.compiler\").get())\n            }\n\n        }\n    }\n}\n```\n这样就配置好了hilt。\n\n最后一个app模块引入的插件是firebase-perf\n这个是google出品的性能监控插件。\n具体用法参考：[https://blog.csdn.net/u010207898/article/details/125070024](https://blog.csdn.net/u010207898/article/details/125070024)\n\n\n* * *\n好的下面继续看app模块下的build.gradle.kts\nandroid层级下基本没啥大问题，配置applicationId版本号之类的。\n这里有个testInstrumentationRunner选择自定义了：\n`testInstrumentationRunner = \"com.google.samples.apps.nowinandroid.core.testing.NiaTestRunner\"`\n\n看下这里做了啥：\n可以看到这个路径下是在testing模块下的，那应该就是测试相关的了。这里主要是用于单元测试的。这个NiaTestRunner继承了AndroidJunitRunner，这里代码如下：\n```groovy\nclass NiaTestRunner : AndroidJUnitRunner() {\n    override fun newApplication(cl: ClassLoader?, name: String?, context: Context?): Application {\n        return super.newApplication(cl, HiltTestApplication::class.java.name, context)\n    }\n}\n```\n\n这个hilt居然还有做单元测试的注入，还是不错，收藏了。\n\n看下buildTypes里面的配置：\n```groovy\n   buildTypes {\n        val debug by getting {\n            applicationIdSuffix = NiaBuildType.DEBUG.applicationIdSuffix\n        }\n```\n这里val debug by gettting为啥这样写？\n这里其实分了2步：\n```groovy\nval release = getByName(\"release\")\n    release.apply {\n```\n\n等价于：\n` val release by getting`\n\n继续下面：\n```groovy\n   packagingOptions {\n        resources {\n            excludes.add(\"/META-INF/{AL2.0,LGPL2.1}\")\n        }\n    }\n```\n这个配置是什么呢：\n打包配置，需要移除这个文件。\n\n继续下面：\n```groovy\n  testOptions {\n        unitTests {\n            isIncludeAndroidResources = true\n        }\n        // TODO: Convert it as a convention plugin once Flamingo goes out (https://github.com/android/nowinandroid/issues/523)\n        managedDevices {\n            devices {\n                maybeCreate<com.android.build.api.dsl.ManagedVirtualDevice>(\"pixel4api30\").apply {\n                    device = \"Pixel 4\"\n                    apiLevel = 30\n                    // ATDs currently support only API level 30.\n                    systemImageSource = \"aosp-atd\"\n                }\n            }\n        }\n    }\n```\n这里是一个testOptions，主要用于配置测试设备的一些属性。\n\n这里关于其它配置可以参考这篇文档[https://blog.csdn.net/shulianghan/article/details/124919287](https://blog.csdn.net/shulianghan/article/details/124919287)\n\n继续看android闭包最后一个配置:\n`namespace = \"com.google.samples.apps.nowinandroid\"`\n\n每个 Android 模块都有一个命名空间，此命名空间用作其生成的 R 和 BuildConfig 类的 Java 或 Kotlin 软件包名称。命名空间由模块的 build.gradle 文件中的 namespace 属性定义，如以下代码段所示。namespace 最初会设为您在创建项目时选择的软件包名称。\n\n最下面就是我们熟悉的dependencies了，可以看到这里非常简练，没有任何版本号，全是通过lis引入的，看着很舒服。\n```groovy\n\ndependencies {\n    implementation(project(\":feature:interests\"))\n    implementation(project(\":feature:foryou\"))\n    implementation(project(\":feature:bookmarks\"))\n    implementation(project(\":feature:topic\"))\n    implementation(project(\":feature:settings\"))\n\n    implementation(project(\":core:common\"))\n    implementation(project(\":core:ui\"))\n    implementation(project(\":core:designsystem\"))\n    implementation(project(\":core:data\"))\n    implementation(project(\":core:model\"))\n\n    implementation(project(\":sync:work\"))\n\n    androidTestImplementation(project(\":core:testing\"))\n    androidTestImplementation(project(\":core:datastore-test\"))\n    androidTestImplementation(project(\":core:data-test\"))\n    androidTestImplementation(project(\":core:network\"))\n    androidTestImplementation(libs.androidx.navigation.testing)\n    androidTestImplementation(libs.accompanist.testharness)\n    androidTestImplementation(kotlin(\"test\"))\n    debugImplementation(libs.androidx.compose.ui.testManifest)\n    debugImplementation(project(\":ui-test-hilt-manifest\"))\n\n    implementation(libs.accompanist.systemuicontroller)\n    implementation(libs.androidx.activity.compose)\n    implementation(libs.androidx.appcompat)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.core.splashscreen)\n    implementation(libs.androidx.compose.runtime)\n    implementation(libs.androidx.lifecycle.runtimeCompose)\n    implementation(libs.androidx.compose.runtime.tracing)\n    implementation(libs.androidx.compose.material3.windowSizeClass)\n    implementation(libs.androidx.hilt.navigation.compose)\n    implementation(libs.androidx.navigation.compose)\n    implementation(libs.androidx.window.manager)\n    implementation(libs.androidx.profileinstaller)\n\n    implementation(libs.coil.kt)\n    implementation(libs.coil.kt.svg)\n}\n\n```\n\n最下面是强制使用某个依赖：\n```groovy\n// androidx.test is forcing JUnit, 4.12. This forces it to use 4.13\nconfigurations.configureEach {\n    resolutionStrategy {\n        force(libs.junit4)\n        // Temporary workaround for https://issuetracker.google.com/174733673\n        force(\"org.objenesis:objenesis:2.6\")\n    }\n}\n```\n\n### 5.build-logic 模块配置构建逻辑\n这里完全封装了自定义插件，定义依赖，配置相关的逻辑主要在这个模块，其实这个模块感觉可以复用，就是说换一个项目，这个模块基本上可以通用，改改具体版本号或者属性即可。哪些要用，哪些不用，在app模块下按需注册插件即可。\n\n首先看下这个模块的setttings.gradle.kts文件\n很简单：\n```groovy\ndependencyResolutionManagement {\n    repositories {\n        google()\n        mavenCentral()\n    }\n    versionCatalogs {\n        create(\"libs\") {\n            from(files(\"../gradle/libs.versions.toml\"))\n        }\n    }\n}\n\nrootProject.name = \"build-logic\"\ninclude(\":convention\")\n```\n\n这里最为关键的是用了一个 versionCatelogs，这里定义了我们所有三方依赖的地方。然后引入了这个模块下的convention的具体模块，这个模块就是编写自定义插件的地方。\n\n简单看下这个libs.version.toml文件吧，它放在项目级下的gradle文件夹中了：\n```groovy\n[versions]\naccompanist = \"0.28.0\"\nandroidDesugarJdkLibs = \"1.2.2\"\nandroidGradlePlugin = \"7.3.1\"\nandroidxActivity = \"1.6.1\"\nandroidxAppCompat = \"1.5.1\"\nandroidxBrowser = \"1.4.0\"\nandroidxComposeBom = \"2022.12.00\"\nandroidxComposeCompiler = \"1.4.0-alpha02\"\nandroidxComposeRuntimeTracing = \"1.0.0-alpha01\"\nandroidxCore = \"1.9.0\"\nandroidxCoreSplashscreen = \"1.0.0\"\nandroidxDataStore = \"1.0.0\"\nandroidxEspresso = \"3.5.0\"\nandroidxHiltNavigationCompose = \"1.0.0\"\nandroidxLifecycle = \"2.6.0-alpha03\"\nandroidxMacroBenchmark = \"1.1.1\"\nandroidxMetrics = \"1.0.0-alpha03\"\nandroidxNavigation = \"2.5.3\"\nandroidxProfileinstaller = \"1.2.1\"\n等等...\n```\n\n看下build-logic 模块下的build.gradle.kts文件：\n首先引入了 kotlin-dsl 插件：\n```groovy\nplugins {\n    `kotlin-dsl`\n}\n```\n这样就能写 java 闭包了，还有一些 compileOnly方法等。具体关于dsl使用方法可以参考这篇文章：[https://www.jianshu.com/p/461d4a249b71](https://www.jianshu.com/p/461d4a249b71)\n\n下面配置了执行build-logic需要依赖的一些东西：\n```groovy\njava {\n    sourceCompatibility = JavaVersion.VERSION_1_8\n    targetCompatibility = JavaVersion.VERSION_1_8\n}\n\ndependencies {\n    compileOnly(libs.android.gradlePlugin)\n    compileOnly(libs.kotlin.gradlePlugin)\n}\n\n```\n\n这里需要编译依赖一些三方库。\n\n然后下面是重点，gradlePlugin闭包下就是注册各种自定义插件了，并且实现类对应convention模块下的某个类，这个类继承了Plugin<Project>。\n\n\n\n### 6.总结\n1.单独抽出一个module作为封装自定义插件的module。在这个module里面添加自定义插件的逻辑，在这个module的settings.gradle.kts中创建一个versionCatelogs，指向所有依赖文件中。\n2.项目级别的settings.gradle.kts用includeBuild来引入上述module。\n3.gradle.properties文件可以配置编译时buildconfig，aidl等文件是否生成。\n4.app级别的build.gradle.kts按需配置自定义插件，testInstrumentationRunnner可以配置测试类。","slug":"Android-gradle相关-KTS脚本-项目配置改造","published":1,"updated":"2023-02-01T07:17:16.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlhfhyn0007ivv7b6m2ajhp","content":"<blockquote>\n<p>googe samples之 nowinandroid项目地址：<a href=\"https://github.com/android/nowinandroid\">https://github.com/android/nowinandroid</a></p>\n</blockquote>\n<h3 id=\"1-gradle-properties\"><a href=\"#1-gradle-properties\" class=\"headerlink\" title=\"1.gradle.properties\"></a>1.gradle.properties</h3><p>这里面配置了 android.useAndroidX等常用的配置，这里应该耳熟能详了，这里就不过多介绍。下面这里有一块不是特别熟悉：</p>\n<pre><code class=\"line-numbers language-groovy\"># Disable build features that are enabled by default,\n# https://developer.android.com/studio/releases/gradle-plugin#buildFeatures\nandroid.defaults.buildfeatures.buildconfig=false\nandroid.defaults.buildfeatures.aidl=false\nandroid.defaults.buildfeatures.renderscript=false\nandroid.defaults.buildfeatures.resvalues=false\nandroid.defaults.buildfeatures.shaders=false\n</code></pre>\n<p>通过关闭buildfeatures.buildconfig，来提升构建性能。有时候模块不需要生成buildconfig文件，那直接关闭即可。还有其它的aidl，renderscript，resvalues同理。</p>\n<h3 id=\"2-项目settings-gradle-kts\"><a href=\"#2-项目settings-gradle-kts\" class=\"headerlink\" title=\"2.项目settings.gradle.kts\"></a>2.项目settings.gradle.kts</h3><p>这里首先是一个pluginManagement闭包：</p>\n<pre><code class=\"line-numbers language-groovy\">pluginManagement &#123;\n    includeBuild(&quot;build-logic&quot;) // 多模块共享模块\n    repositories &#123;\n        google()\n        mavenCentral()\n        gradlePluginPortal()\n    &#125;\n&#125;\n</code></pre>\n<p>第一个问题是：pluginManagement是什么东西啊？没见过。<br>简单来说：dependencyManagement用于在父项目中统一对子项目依赖管理。这样就可以对所有模块的版本进行管理。</p>\n<p>第二个问题是：includeBuild是什么？<br>相信大部分人都有用过buildSrc吧。如果没有，那config.gradle总用过吧，总之就是把不同模块之前相同依赖抽出来，同时引用。 buildSrc的弊端就是每次依赖更新都将重新构建整个项目，导致编译时间很长，这里google官方推荐使用includeBuild来解决这个问题。</p>\n<p>然后gradlePluginProtal() 远程插件仓库，是google推荐的。</p>\n<p>第二块代码是这样的：</p>\n<pre><code class=\"line-numbers language-groovy\">dependencyResolutionManagement &#123;\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories &#123;\n        google()\n        mavenCentral()\n    &#125;\n&#125;\n</code></pre>\n<p>当您的依赖项不是本地库或文件树时，Gradle 会在 settings.gradle 文件的 dependencyResolutionManagement { repositories {…} } 代码块中指定的所有在线仓库中查找相关文件。 各个仓库的列出顺序决定了 Gradle 在这些仓库中搜索各个项目依赖项的顺序。例如，如果从仓库 A 和 B 均可获得某个依赖项，而您先列出了仓库 A，则 Gradle 会从仓库 A 下载该依赖项。说白了，就是有一个优先权，从上往下。</p>\n<p>然后这个文件其它内容没啥参考价值了，都是include多个模块。<br>这个文件最重要也是最关键的地方就是 includeBuild(“build-logic”)</p>\n<h3 id=\"3-项目级build-gradle-kts\"><a href=\"#3-项目级build-gradle-kts\" class=\"headerlink\" title=\"3.项目级build.gradle.kts\"></a>3.项目级build.gradle.kts</h3><p>首先是一个buildscript闭包：</p>\n<pre><code class=\"line-numbers language-groovy\">buildscript &#123;\n    repositories &#123;\n        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/public&quot;) &#125;\n        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/gradle-plugin&quot;) &#125;\n        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/central&quot;) &#125;\n        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/google&quot;) &#125;\n\n        mavenCentral()\n        google()\n\n\n        // Android Build Server\n        maven &#123; url = uri(&quot;../nowinandroid-prebuilts/m2repository&quot;) &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>其实这里引发了另外一个问题：<br>在项目根目录（root Project）下的build.gradle中：buildscript、allprojects、subprojects的repositories有什么区别？</p>\n<ol>\n<li>buildScript块的repositories主要是为了Gradle脚本自身的执行，获取脚本依赖插件。也就是说，buildScript是用来加载Gradle脚本自身需要使用的资源，可以声明的资源包括依赖项、第三方插件、maven仓库地址等。</li>\n<li>根级别的repositories主要是为了当前项目提供所需依赖包，比如log4j、spring-core等依赖包可从mavenCentral仓库获得。</li>\n<li>allprojects块的repositories用于多项目构建，为所有项目提供共同的所需依赖包。而子项目可以配置自己的repositories以获取自己独需的依赖包。</li>\n<li>subprojects块的repositories用于配置这个项目的子项目。使用多模块项目时，不同模块之间有相同的配置，导致重复配置，可以将相同的部分抽取出来，使用配置注入的技术完成子项目的配置。根项目就像一个容器, subprojects 方法遍历这个容器的所有元素并且注入指定的配置。allprojects是对所有project的配置，包括Root Project。而subprojects是对所有Child Project的配置。</li>\n</ol>\n<p>这里说明buildScript里面的仓库主要用于Gradle脚本自身执行，因为这里一直超时，我把阿里云镜像加进去就没问题了，估计是下载Gradle脚本自身相关依赖导致超时了。</p>\n<p>然后下面还有一部分是plugins闭包：</p>\n<pre><code class=\"line-numbers language-groovy\">plugins &#123;\n    alias(libs.plugins.android.application) apply false\n    alias(libs.plugins.kotlin.jvm) apply false\n    alias(libs.plugins.kotlin.serialization) apply false\n    alias(libs.plugins.hilt) apply false\n    alias(libs.plugins.secrets) apply false\n&#125;\n</code></pre>\n<p>这里的libs就是在 前面的build-logic模块下的 versionCatalogs创建的一个名称。<br>定义了后，这里就可以引用了。这里应该是引用插件，不过都是apply false，这里的作用个人还不是很清楚。</p>\n<h3 id=\"4-app模块下的build-gradle-kts\"><a href=\"#4-app模块下的build-gradle-kts\" class=\"headerlink\" title=\"4.app模块下的build.gradle.kts\"></a>4.app模块下的build.gradle.kts</h3><p>这里第一行是：<br><code>import com.google.samples.apps.nowinandroid.NiaBuildType</code><br>这里可以引用自己编写的类，<br>这个类定义再build-logic模块中，是一个枚举类，看一下吧：</p>\n<pre><code class=\"line-numbers language-groovy\">package com.google.samples.apps.nowinandroid\n\n/**\n * This is shared between :app and :benchmarks module to provide configurations type safety.\n */\n@Suppress(&quot;unused&quot;)\nenum class NiaBuildType(val applicationIdSuffix: String? = null) &#123;\n    DEBUG(&quot;.debug&quot;),\n    RELEASE,\n    BENCHMARK(&quot;.benchmark&quot;)\n&#125;\n</code></pre>\n<p>估计是代表编译模式，debug还是release，或者其它模式。</p>\n<p>然后继续回到build.gradle.kts文件下，<br>这里引入插件了：</p>\n<pre><code class=\"line-numbers language-groovy\">plugins &#123;\n    id(&quot;nowinandroid.android.application&quot;)\n    id(&quot;nowinandroid.android.application.compose&quot;)\n    id(&quot;nowinandroid.android.application.jacoco&quot;)\n    id(&quot;nowinandroid.android.hilt&quot;)\n    id(&quot;jacoco&quot;)\n    id(&quot;nowinandroid.firebase-perf&quot;)\n&#125;\n</code></pre>\n<p>注意这几个有nowinandroid前缀的应该都是我们自己编写的插件。<br>首先看下第一个：noewinandroid.android.application</p>\n<p>当然还是先全局搜索下，发现在build-logic模块下注册了：</p>\n<pre><code class=\"line-numbers language-groovy\">gradlePlugin &#123;\n    plugins &#123;\n        register(&quot;androidApplicationCompose&quot;) &#123;\n            id = &quot;nowinandroid.android.application.compose&quot;\n            implementationClass = &quot;AndroidApplicationComposeConventionPlugin&quot;\n        &#125;\n        register(&quot;androidApplication&quot;) &#123;\n            id = &quot;nowinandroid.android.application&quot;\n            implementationClass = &quot;AndroidApplicationConventionPlugin&quot;\n        &#125;\n</code></pre>\n<p>实现类为：AndroidApplicationConventionPlugin</p>\n<pre><code class=\"line-numbers language-groovy\">class AndroidApplicationConventionPlugin : Plugin&lt;Project&gt; &#123;\n    override fun apply(target: Project) &#123;\n        with(target) &#123;\n            with(pluginManager) &#123;\n                apply(&quot;com.android.application&quot;)\n                apply(&quot;org.jetbrains.kotlin.android&quot;)\n            &#125;\n\n            extensions.configure&lt;ApplicationExtension&gt; &#123;\n                configureKotlinAndroid(this)\n                defaultConfig.targetSdk = 33\n                configureFlavors(this)\n            &#125;\n            extensions.configure&lt;ApplicationAndroidComponentsExtension&gt; &#123;\n                configurePrintApksTask(this)\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里继承了Plugin<Project>，实现apply方法。<br>利用插件管理器pluginManager来引入”com.android.application”插件和“org.jetbrains.kotlin.android”插件。</p>\n<p>可以看到这里面帮忙apply了com.android.application，这样就不用重复再build.gradle中引入了。</p>\n<p>重点来看下引入的compose，说实话我还没用过google的jetpack compose工具包。<br>依然在build-logic下注册了这个插件：</p>\n<pre><code class=\"line-numbers language-groovy\">gradlePlugin &#123;\n    plugins &#123;\n        register(&quot;androidApplicationCompose&quot;) &#123;\n            id = &quot;nowinandroid.android.application.compose&quot;\n            implementationClass = &quot;AndroidApplicationComposeConventionPlugin&quot;\n        &#125;\n</code></pre>\n<p>实现类：AndroidApplicationComposeConventionPlugin</p>\n<pre><code class=\"line-numbers language-groovy\">class AndroidApplicationComposeConventionPlugin : Plugin&lt;Project&gt; &#123;\n    override fun apply(target: Project) &#123;\n        with(target) &#123;\n            pluginManager.apply(&quot;com.android.application&quot;)\n            val extension = extensions.getByType&lt;ApplicationExtension&gt;()\n            configureAndroidCompose(extension)\n        &#125;\n    &#125;\n\n&#125;\n</code></pre>\n<p>非常简单，先apply了com.android.application<br>然后调用了一个 configureAndroidCompose 方法，这是一个扩展方法，也是在build-logic下的一个kt文件中对Project进行了扩展。</p>\n<pre><code class=\"line-numbers language-groovy\">/**\n * Configure Compose-specific options\n */\ninternal fun Project.configureAndroidCompose(\n    commonExtension: CommonExtension&lt;*, *, *, *&gt;,\n) &#123;\n    val libs = extensions.getByType&lt;VersionCatalogsExtension&gt;().named(&quot;libs&quot;)\n\n    commonExtension.apply &#123;\n        buildFeatures &#123;\n            compose = true\n        &#125;\n\n        composeOptions &#123;\n            kotlinCompilerExtensionVersion = libs.findVersion(&quot;androidxComposeCompiler&quot;).get().toString()\n        &#125;\n\n        kotlinOptions &#123;\n            freeCompilerArgs = freeCompilerArgs + buildComposeMetricsParameters()\n        &#125;\n\n        dependencies &#123;\n            val bom = libs.findLibrary(&quot;androidx-compose-bom&quot;).get()\n            add(&quot;implementation&quot;, platform(bom))\n            add(&quot;androidTestImplementation&quot;, platform(bom))\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里编写了compose相关的必要的配置。buildFeaturs，composeOptions,kotlinOptions,dependencies这些都加上了。</p>\n<p>再回到app模块下的build.gradle.kts文件，<br>还有一个插件是：nowinandroid.android.application.jacoco<br>这个是自定义的一个代码覆盖率的一个插件，基于jacoco的。</p>\n<pre><code class=\"line-numbers language-groovy\"> register(&quot;androidApplicationJacoco&quot;) &#123;\n            id = &quot;nowinandroid.android.application.jacoco&quot;\n            implementationClass = &quot;AndroidApplicationJacocoConventionPlugin&quot;\n        &#125;\n</code></pre>\n<p>先注册，再看下实现类：</p>\n<pre><code class=\"line-numbers language-groovy\">\nclass AndroidApplicationJacocoConventionPlugin : Plugin&lt;Project&gt; &#123;\n    override fun apply(target: Project) &#123;\n        with(target) &#123;\n            with(pluginManager) &#123;\n                apply(&quot;org.gradle.jacoco&quot;)\n                apply(&quot;com.android.application&quot;)\n            &#125;\n            val extension = extensions.getByType&lt;ApplicationAndroidComponentsExtension&gt;()\n            configureJacoco(extension)\n        &#125;\n    &#125;\n\n&#125;\n</code></pre>\n<p>这里引入了gradle的jacoco插件，然后调用了configureJacoco方法。<br>具体插件使用方法可以这里看下：<a href=\"https://www.w3cschool.cn/gradle/9pg71huj.html\">https://www.w3cschool.cn/gradle/9pg71huj.html</a></p>\n<p>这个配置起来确实很麻烦，如果全部代码加到app模块下，很难进行维护，这样以插件形式确实方便很多。</p>\n<p>这里继续看app模块引入的自定义插件：hilt<br>这个想必大家都不陌生了，是一个依赖注入的插件，基于Dragger，但比Dragger简洁很多了。<br>实现类为：</p>\n<pre><code class=\"line-numbers language-groovy\">class AndroidHiltConventionPlugin : Plugin&lt;Project&gt; &#123;\n    override fun apply(target: Project) &#123;\n        with(target) &#123;\n            with(pluginManager) &#123;\n                apply(&quot;dagger.hilt.android.plugin&quot;)\n                // KAPT must go last to avoid build warnings.\n                // See: https://stackoverflow.com/questions/70550883/warning-the-following-options-were-not-recognized-by-any-processor-dagger-f\n                apply(&quot;org.jetbrains.kotlin.kapt&quot;)\n            &#125;\n\n            val libs = extensions.getByType&lt;VersionCatalogsExtension&gt;().named(&quot;libs&quot;)\n            dependencies &#123;\n                &quot;implementation&quot;(libs.findLibrary(&quot;hilt.android&quot;).get())\n                &quot;kapt&quot;(libs.findLibrary(&quot;hilt.compiler&quot;).get())\n                &quot;kaptAndroidTest&quot;(libs.findLibrary(&quot;hilt.compiler&quot;).get())\n            &#125;\n\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这样就配置好了hilt。</p>\n<p>最后一个app模块引入的插件是firebase-perf<br>这个是google出品的性能监控插件。<br>具体用法参考：<a href=\"https://blog.csdn.net/u010207898/article/details/125070024\">https://blog.csdn.net/u010207898/article/details/125070024</a></p>\n<hr>\n<p>好的下面继续看app模块下的build.gradle.kts<br>android层级下基本没啥大问题，配置applicationId版本号之类的。<br>这里有个testInstrumentationRunner选择自定义了：<br><code>testInstrumentationRunner = &quot;com.google.samples.apps.nowinandroid.core.testing.NiaTestRunner&quot;</code></p>\n<p>看下这里做了啥：<br>可以看到这个路径下是在testing模块下的，那应该就是测试相关的了。这里主要是用于单元测试的。这个NiaTestRunner继承了AndroidJunitRunner，这里代码如下：</p>\n<pre><code class=\"line-numbers language-groovy\">class NiaTestRunner : AndroidJUnitRunner() &#123;\n    override fun newApplication(cl: ClassLoader?, name: String?, context: Context?): Application &#123;\n        return super.newApplication(cl, HiltTestApplication::class.java.name, context)\n    &#125;\n&#125;\n</code></pre>\n<p>这个hilt居然还有做单元测试的注入，还是不错，收藏了。</p>\n<p>看下buildTypes里面的配置：</p>\n<pre><code class=\"line-numbers language-groovy\">   buildTypes &#123;\n        val debug by getting &#123;\n            applicationIdSuffix = NiaBuildType.DEBUG.applicationIdSuffix\n        &#125;\n</code></pre>\n<p>这里val debug by gettting为啥这样写？<br>这里其实分了2步：</p>\n<pre><code class=\"line-numbers language-groovy\">val release = getByName(&quot;release&quot;)\n    release.apply &#123;\n</code></pre>\n<p>等价于：<br><code> val release by getting</code></p>\n<p>继续下面：</p>\n<pre><code class=\"line-numbers language-groovy\">   packagingOptions &#123;\n        resources &#123;\n            excludes.add(&quot;/META-INF/&#123;AL2.0,LGPL2.1&#125;&quot;)\n        &#125;\n    &#125;\n</code></pre>\n<p>这个配置是什么呢：<br>打包配置，需要移除这个文件。</p>\n<p>继续下面：</p>\n<pre><code class=\"line-numbers language-groovy\">  testOptions &#123;\n        unitTests &#123;\n            isIncludeAndroidResources = true\n        &#125;\n        // TODO: Convert it as a convention plugin once Flamingo goes out (https://github.com/android/nowinandroid/issues/523)\n        managedDevices &#123;\n            devices &#123;\n                maybeCreate&lt;com.android.build.api.dsl.ManagedVirtualDevice&gt;(&quot;pixel4api30&quot;).apply &#123;\n                    device = &quot;Pixel 4&quot;\n                    apiLevel = 30\n                    // ATDs currently support only API level 30.\n                    systemImageSource = &quot;aosp-atd&quot;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>这里是一个testOptions，主要用于配置测试设备的一些属性。</p>\n<p>这里关于其它配置可以参考这篇文档<a href=\"https://blog.csdn.net/shulianghan/article/details/124919287\">https://blog.csdn.net/shulianghan/article/details/124919287</a></p>\n<p>继续看android闭包最后一个配置:<br><code>namespace = &quot;com.google.samples.apps.nowinandroid&quot;</code></p>\n<p>每个 Android 模块都有一个命名空间，此命名空间用作其生成的 R 和 BuildConfig 类的 Java 或 Kotlin 软件包名称。命名空间由模块的 build.gradle 文件中的 namespace 属性定义，如以下代码段所示。namespace 最初会设为您在创建项目时选择的软件包名称。</p>\n<p>最下面就是我们熟悉的dependencies了，可以看到这里非常简练，没有任何版本号，全是通过lis引入的，看着很舒服。</p>\n<pre><code class=\"line-numbers language-groovy\">\ndependencies &#123;\n    implementation(project(&quot;:feature:interests&quot;))\n    implementation(project(&quot;:feature:foryou&quot;))\n    implementation(project(&quot;:feature:bookmarks&quot;))\n    implementation(project(&quot;:feature:topic&quot;))\n    implementation(project(&quot;:feature:settings&quot;))\n\n    implementation(project(&quot;:core:common&quot;))\n    implementation(project(&quot;:core:ui&quot;))\n    implementation(project(&quot;:core:designsystem&quot;))\n    implementation(project(&quot;:core:data&quot;))\n    implementation(project(&quot;:core:model&quot;))\n\n    implementation(project(&quot;:sync:work&quot;))\n\n    androidTestImplementation(project(&quot;:core:testing&quot;))\n    androidTestImplementation(project(&quot;:core:datastore-test&quot;))\n    androidTestImplementation(project(&quot;:core:data-test&quot;))\n    androidTestImplementation(project(&quot;:core:network&quot;))\n    androidTestImplementation(libs.androidx.navigation.testing)\n    androidTestImplementation(libs.accompanist.testharness)\n    androidTestImplementation(kotlin(&quot;test&quot;))\n    debugImplementation(libs.androidx.compose.ui.testManifest)\n    debugImplementation(project(&quot;:ui-test-hilt-manifest&quot;))\n\n    implementation(libs.accompanist.systemuicontroller)\n    implementation(libs.androidx.activity.compose)\n    implementation(libs.androidx.appcompat)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.core.splashscreen)\n    implementation(libs.androidx.compose.runtime)\n    implementation(libs.androidx.lifecycle.runtimeCompose)\n    implementation(libs.androidx.compose.runtime.tracing)\n    implementation(libs.androidx.compose.material3.windowSizeClass)\n    implementation(libs.androidx.hilt.navigation.compose)\n    implementation(libs.androidx.navigation.compose)\n    implementation(libs.androidx.window.manager)\n    implementation(libs.androidx.profileinstaller)\n\n    implementation(libs.coil.kt)\n    implementation(libs.coil.kt.svg)\n&#125;\n</code></pre>\n<p>最下面是强制使用某个依赖：</p>\n<pre><code class=\"line-numbers language-groovy\">// androidx.test is forcing JUnit, 4.12. This forces it to use 4.13\nconfigurations.configureEach &#123;\n    resolutionStrategy &#123;\n        force(libs.junit4)\n        // Temporary workaround for https://issuetracker.google.com/174733673\n        force(&quot;org.objenesis:objenesis:2.6&quot;)\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"5-build-logic-模块配置构建逻辑\"><a href=\"#5-build-logic-模块配置构建逻辑\" class=\"headerlink\" title=\"5.build-logic 模块配置构建逻辑\"></a>5.build-logic 模块配置构建逻辑</h3><p>这里完全封装了自定义插件，定义依赖，配置相关的逻辑主要在这个模块，其实这个模块感觉可以复用，就是说换一个项目，这个模块基本上可以通用，改改具体版本号或者属性即可。哪些要用，哪些不用，在app模块下按需注册插件即可。</p>\n<p>首先看下这个模块的setttings.gradle.kts文件<br>很简单：</p>\n<pre><code class=\"line-numbers language-groovy\">dependencyResolutionManagement &#123;\n    repositories &#123;\n        google()\n        mavenCentral()\n    &#125;\n    versionCatalogs &#123;\n        create(&quot;libs&quot;) &#123;\n            from(files(&quot;../gradle/libs.versions.toml&quot;))\n        &#125;\n    &#125;\n&#125;\n\nrootProject.name = &quot;build-logic&quot;\ninclude(&quot;:convention&quot;)\n</code></pre>\n<p>这里最为关键的是用了一个 versionCatelogs，这里定义了我们所有三方依赖的地方。然后引入了这个模块下的convention的具体模块，这个模块就是编写自定义插件的地方。</p>\n<p>简单看下这个libs.version.toml文件吧，它放在项目级下的gradle文件夹中了：</p>\n<pre><code class=\"line-numbers language-groovy\">[versions]\naccompanist = &quot;0.28.0&quot;\nandroidDesugarJdkLibs = &quot;1.2.2&quot;\nandroidGradlePlugin = &quot;7.3.1&quot;\nandroidxActivity = &quot;1.6.1&quot;\nandroidxAppCompat = &quot;1.5.1&quot;\nandroidxBrowser = &quot;1.4.0&quot;\nandroidxComposeBom = &quot;2022.12.00&quot;\nandroidxComposeCompiler = &quot;1.4.0-alpha02&quot;\nandroidxComposeRuntimeTracing = &quot;1.0.0-alpha01&quot;\nandroidxCore = &quot;1.9.0&quot;\nandroidxCoreSplashscreen = &quot;1.0.0&quot;\nandroidxDataStore = &quot;1.0.0&quot;\nandroidxEspresso = &quot;3.5.0&quot;\nandroidxHiltNavigationCompose = &quot;1.0.0&quot;\nandroidxLifecycle = &quot;2.6.0-alpha03&quot;\nandroidxMacroBenchmark = &quot;1.1.1&quot;\nandroidxMetrics = &quot;1.0.0-alpha03&quot;\nandroidxNavigation = &quot;2.5.3&quot;\nandroidxProfileinstaller = &quot;1.2.1&quot;\n等等...\n</code></pre>\n<p>看下build-logic 模块下的build.gradle.kts文件：<br>首先引入了 kotlin-dsl 插件：</p>\n<pre><code class=\"line-numbers language-groovy\">plugins &#123;\n    `kotlin-dsl`\n&#125;\n</code></pre>\n<p>这样就能写 java 闭包了，还有一些 compileOnly方法等。具体关于dsl使用方法可以参考这篇文章：<a href=\"https://www.jianshu.com/p/461d4a249b71\">https://www.jianshu.com/p/461d4a249b71</a></p>\n<p>下面配置了执行build-logic需要依赖的一些东西：</p>\n<pre><code class=\"line-numbers language-groovy\">java &#123;\n    sourceCompatibility = JavaVersion.VERSION_1_8\n    targetCompatibility = JavaVersion.VERSION_1_8\n&#125;\n\ndependencies &#123;\n    compileOnly(libs.android.gradlePlugin)\n    compileOnly(libs.kotlin.gradlePlugin)\n&#125;\n</code></pre>\n<p>这里需要编译依赖一些三方库。</p>\n<p>然后下面是重点，gradlePlugin闭包下就是注册各种自定义插件了，并且实现类对应convention模块下的某个类，这个类继承了Plugin<Project>。</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6.总结\"></a>6.总结</h3><p>1.单独抽出一个module作为封装自定义插件的module。在这个module里面添加自定义插件的逻辑，在这个module的settings.gradle.kts中创建一个versionCatelogs，指向所有依赖文件中。<br>2.项目级别的settings.gradle.kts用includeBuild来引入上述module。<br>3.gradle.properties文件可以配置编译时buildconfig，aidl等文件是否生成。<br>4.app级别的build.gradle.kts按需配置自定义插件，testInstrumentationRunnner可以配置测试类。</p>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<blockquote>\n<p>googe samples之 nowinandroid项目地址：<a href=\"https://github.com/android/nowinandroid\">https://github.com/android/nowinandroid</a></p>\n</blockquote>\n<h3 id=\"1-gradle-properties\"><a href=\"#1-gradle-properties\" class=\"headerlink\" title=\"1.gradle.properties\"></a>1.gradle.properties</h3><p>这里面配置了 android.useAndroidX等常用的配置，这里应该耳熟能详了，这里就不过多介绍。下面这里有一块不是特别熟悉：</p>\n<pre><code class=\"line-numbers language-groovy\"># Disable build features that are enabled by default,\n# https://developer.android.com/studio/releases/gradle-plugin#buildFeatures\nandroid.defaults.buildfeatures.buildconfig=false\nandroid.defaults.buildfeatures.aidl=false\nandroid.defaults.buildfeatures.renderscript=false\nandroid.defaults.buildfeatures.resvalues=false\nandroid.defaults.buildfeatures.shaders=false\n</code></pre>\n<p>通过关闭buildfeatures.buildconfig，来提升构建性能。有时候模块不需要生成buildconfig文件，那直接关闭即可。还有其它的aidl，renderscript，resvalues同理。</p>\n<h3 id=\"2-项目settings-gradle-kts\"><a href=\"#2-项目settings-gradle-kts\" class=\"headerlink\" title=\"2.项目settings.gradle.kts\"></a>2.项目settings.gradle.kts</h3><p>这里首先是一个pluginManagement闭包：</p>\n<pre><code class=\"line-numbers language-groovy\">pluginManagement &#123;\n    includeBuild(&quot;build-logic&quot;) // 多模块共享模块\n    repositories &#123;\n        google()\n        mavenCentral()\n        gradlePluginPortal()\n    &#125;\n&#125;\n</code></pre>\n<p>第一个问题是：pluginManagement是什么东西啊？没见过。<br>简单来说：dependencyManagement用于在父项目中统一对子项目依赖管理。这样就可以对所有模块的版本进行管理。</p>\n<p>第二个问题是：includeBuild是什么？<br>相信大部分人都有用过buildSrc吧。如果没有，那config.gradle总用过吧，总之就是把不同模块之前相同依赖抽出来，同时引用。 buildSrc的弊端就是每次依赖更新都将重新构建整个项目，导致编译时间很长，这里google官方推荐使用includeBuild来解决这个问题。</p>\n<p>然后gradlePluginProtal() 远程插件仓库，是google推荐的。</p>\n<p>第二块代码是这样的：</p>\n<pre><code class=\"line-numbers language-groovy\">dependencyResolutionManagement &#123;\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories &#123;\n        google()\n        mavenCentral()\n    &#125;\n&#125;\n</code></pre>\n<p>当您的依赖项不是本地库或文件树时，Gradle 会在 settings.gradle 文件的 dependencyResolutionManagement { repositories {…} } 代码块中指定的所有在线仓库中查找相关文件。 各个仓库的列出顺序决定了 Gradle 在这些仓库中搜索各个项目依赖项的顺序。例如，如果从仓库 A 和 B 均可获得某个依赖项，而您先列出了仓库 A，则 Gradle 会从仓库 A 下载该依赖项。说白了，就是有一个优先权，从上往下。</p>\n<p>然后这个文件其它内容没啥参考价值了，都是include多个模块。<br>这个文件最重要也是最关键的地方就是 includeBuild(“build-logic”)</p>\n<h3 id=\"3-项目级build-gradle-kts\"><a href=\"#3-项目级build-gradle-kts\" class=\"headerlink\" title=\"3.项目级build.gradle.kts\"></a>3.项目级build.gradle.kts</h3><p>首先是一个buildscript闭包：</p>\n<pre><code class=\"line-numbers language-groovy\">buildscript &#123;\n    repositories &#123;\n        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/public&quot;) &#125;\n        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/gradle-plugin&quot;) &#125;\n        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/central&quot;) &#125;\n        maven &#123; url = uri(&quot;https://maven.aliyun.com/repository/google&quot;) &#125;\n\n        mavenCentral()\n        google()\n\n\n        // Android Build Server\n        maven &#123; url = uri(&quot;../nowinandroid-prebuilts/m2repository&quot;) &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>其实这里引发了另外一个问题：<br>在项目根目录（root Project）下的build.gradle中：buildscript、allprojects、subprojects的repositories有什么区别？</p>\n<ol>\n<li>buildScript块的repositories主要是为了Gradle脚本自身的执行，获取脚本依赖插件。也就是说，buildScript是用来加载Gradle脚本自身需要使用的资源，可以声明的资源包括依赖项、第三方插件、maven仓库地址等。</li>\n<li>根级别的repositories主要是为了当前项目提供所需依赖包，比如log4j、spring-core等依赖包可从mavenCentral仓库获得。</li>\n<li>allprojects块的repositories用于多项目构建，为所有项目提供共同的所需依赖包。而子项目可以配置自己的repositories以获取自己独需的依赖包。</li>\n<li>subprojects块的repositories用于配置这个项目的子项目。使用多模块项目时，不同模块之间有相同的配置，导致重复配置，可以将相同的部分抽取出来，使用配置注入的技术完成子项目的配置。根项目就像一个容器, subprojects 方法遍历这个容器的所有元素并且注入指定的配置。allprojects是对所有project的配置，包括Root Project。而subprojects是对所有Child Project的配置。</li>\n</ol>\n<p>这里说明buildScript里面的仓库主要用于Gradle脚本自身执行，因为这里一直超时，我把阿里云镜像加进去就没问题了，估计是下载Gradle脚本自身相关依赖导致超时了。</p>\n<p>然后下面还有一部分是plugins闭包：</p>\n<pre><code class=\"line-numbers language-groovy\">plugins &#123;\n    alias(libs.plugins.android.application) apply false\n    alias(libs.plugins.kotlin.jvm) apply false\n    alias(libs.plugins.kotlin.serialization) apply false\n    alias(libs.plugins.hilt) apply false\n    alias(libs.plugins.secrets) apply false\n&#125;\n</code></pre>\n<p>这里的libs就是在 前面的build-logic模块下的 versionCatalogs创建的一个名称。<br>定义了后，这里就可以引用了。这里应该是引用插件，不过都是apply false，这里的作用个人还不是很清楚。</p>\n<h3 id=\"4-app模块下的build-gradle-kts\"><a href=\"#4-app模块下的build-gradle-kts\" class=\"headerlink\" title=\"4.app模块下的build.gradle.kts\"></a>4.app模块下的build.gradle.kts</h3><p>这里第一行是：<br><code>import com.google.samples.apps.nowinandroid.NiaBuildType</code><br>这里可以引用自己编写的类，<br>这个类定义再build-logic模块中，是一个枚举类，看一下吧：</p>\n<pre><code class=\"line-numbers language-groovy\">package com.google.samples.apps.nowinandroid\n\n/**\n * This is shared between :app and :benchmarks module to provide configurations type safety.\n */\n@Suppress(&quot;unused&quot;)\nenum class NiaBuildType(val applicationIdSuffix: String? = null) &#123;\n    DEBUG(&quot;.debug&quot;),\n    RELEASE,\n    BENCHMARK(&quot;.benchmark&quot;)\n&#125;\n</code></pre>\n<p>估计是代表编译模式，debug还是release，或者其它模式。</p>\n<p>然后继续回到build.gradle.kts文件下，<br>这里引入插件了：</p>\n<pre><code class=\"line-numbers language-groovy\">plugins &#123;\n    id(&quot;nowinandroid.android.application&quot;)\n    id(&quot;nowinandroid.android.application.compose&quot;)\n    id(&quot;nowinandroid.android.application.jacoco&quot;)\n    id(&quot;nowinandroid.android.hilt&quot;)\n    id(&quot;jacoco&quot;)\n    id(&quot;nowinandroid.firebase-perf&quot;)\n&#125;\n</code></pre>\n<p>注意这几个有nowinandroid前缀的应该都是我们自己编写的插件。<br>首先看下第一个：noewinandroid.android.application</p>\n<p>当然还是先全局搜索下，发现在build-logic模块下注册了：</p>\n<pre><code class=\"line-numbers language-groovy\">gradlePlugin &#123;\n    plugins &#123;\n        register(&quot;androidApplicationCompose&quot;) &#123;\n            id = &quot;nowinandroid.android.application.compose&quot;\n            implementationClass = &quot;AndroidApplicationComposeConventionPlugin&quot;\n        &#125;\n        register(&quot;androidApplication&quot;) &#123;\n            id = &quot;nowinandroid.android.application&quot;\n            implementationClass = &quot;AndroidApplicationConventionPlugin&quot;\n        &#125;\n</code></pre>\n<p>实现类为：AndroidApplicationConventionPlugin</p>\n<pre><code class=\"line-numbers language-groovy\">class AndroidApplicationConventionPlugin : Plugin&lt;Project&gt; &#123;\n    override fun apply(target: Project) &#123;\n        with(target) &#123;\n            with(pluginManager) &#123;\n                apply(&quot;com.android.application&quot;)\n                apply(&quot;org.jetbrains.kotlin.android&quot;)\n            &#125;\n\n            extensions.configure&lt;ApplicationExtension&gt; &#123;\n                configureKotlinAndroid(this)\n                defaultConfig.targetSdk = 33\n                configureFlavors(this)\n            &#125;\n            extensions.configure&lt;ApplicationAndroidComponentsExtension&gt; &#123;\n                configurePrintApksTask(this)\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里继承了Plugin<Project>，实现apply方法。<br>利用插件管理器pluginManager来引入”com.android.application”插件和“org.jetbrains.kotlin.android”插件。</p>\n<p>可以看到这里面帮忙apply了com.android.application，这样就不用重复再build.gradle中引入了。</p>\n<p>重点来看下引入的compose，说实话我还没用过google的jetpack compose工具包。<br>依然在build-logic下注册了这个插件：</p>\n<pre><code class=\"line-numbers language-groovy\">gradlePlugin &#123;\n    plugins &#123;\n        register(&quot;androidApplicationCompose&quot;) &#123;\n            id = &quot;nowinandroid.android.application.compose&quot;\n            implementationClass = &quot;AndroidApplicationComposeConventionPlugin&quot;\n        &#125;\n</code></pre>\n<p>实现类：AndroidApplicationComposeConventionPlugin</p>\n<pre><code class=\"line-numbers language-groovy\">class AndroidApplicationComposeConventionPlugin : Plugin&lt;Project&gt; &#123;\n    override fun apply(target: Project) &#123;\n        with(target) &#123;\n            pluginManager.apply(&quot;com.android.application&quot;)\n            val extension = extensions.getByType&lt;ApplicationExtension&gt;()\n            configureAndroidCompose(extension)\n        &#125;\n    &#125;\n\n&#125;\n</code></pre>\n<p>非常简单，先apply了com.android.application<br>然后调用了一个 configureAndroidCompose 方法，这是一个扩展方法，也是在build-logic下的一个kt文件中对Project进行了扩展。</p>\n<pre><code class=\"line-numbers language-groovy\">/**\n * Configure Compose-specific options\n */\ninternal fun Project.configureAndroidCompose(\n    commonExtension: CommonExtension&lt;*, *, *, *&gt;,\n) &#123;\n    val libs = extensions.getByType&lt;VersionCatalogsExtension&gt;().named(&quot;libs&quot;)\n\n    commonExtension.apply &#123;\n        buildFeatures &#123;\n            compose = true\n        &#125;\n\n        composeOptions &#123;\n            kotlinCompilerExtensionVersion = libs.findVersion(&quot;androidxComposeCompiler&quot;).get().toString()\n        &#125;\n\n        kotlinOptions &#123;\n            freeCompilerArgs = freeCompilerArgs + buildComposeMetricsParameters()\n        &#125;\n\n        dependencies &#123;\n            val bom = libs.findLibrary(&quot;androidx-compose-bom&quot;).get()\n            add(&quot;implementation&quot;, platform(bom))\n            add(&quot;androidTestImplementation&quot;, platform(bom))\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里编写了compose相关的必要的配置。buildFeaturs，composeOptions,kotlinOptions,dependencies这些都加上了。</p>\n<p>再回到app模块下的build.gradle.kts文件，<br>还有一个插件是：nowinandroid.android.application.jacoco<br>这个是自定义的一个代码覆盖率的一个插件，基于jacoco的。</p>\n<pre><code class=\"line-numbers language-groovy\"> register(&quot;androidApplicationJacoco&quot;) &#123;\n            id = &quot;nowinandroid.android.application.jacoco&quot;\n            implementationClass = &quot;AndroidApplicationJacocoConventionPlugin&quot;\n        &#125;\n</code></pre>\n<p>先注册，再看下实现类：</p>\n<pre><code class=\"line-numbers language-groovy\">\nclass AndroidApplicationJacocoConventionPlugin : Plugin&lt;Project&gt; &#123;\n    override fun apply(target: Project) &#123;\n        with(target) &#123;\n            with(pluginManager) &#123;\n                apply(&quot;org.gradle.jacoco&quot;)\n                apply(&quot;com.android.application&quot;)\n            &#125;\n            val extension = extensions.getByType&lt;ApplicationAndroidComponentsExtension&gt;()\n            configureJacoco(extension)\n        &#125;\n    &#125;\n\n&#125;\n</code></pre>\n<p>这里引入了gradle的jacoco插件，然后调用了configureJacoco方法。<br>具体插件使用方法可以这里看下：<a href=\"https://www.w3cschool.cn/gradle/9pg71huj.html\">https://www.w3cschool.cn/gradle/9pg71huj.html</a></p>\n<p>这个配置起来确实很麻烦，如果全部代码加到app模块下，很难进行维护，这样以插件形式确实方便很多。</p>\n<p>这里继续看app模块引入的自定义插件：hilt<br>这个想必大家都不陌生了，是一个依赖注入的插件，基于Dragger，但比Dragger简洁很多了。<br>实现类为：</p>\n<pre><code class=\"line-numbers language-groovy\">class AndroidHiltConventionPlugin : Plugin&lt;Project&gt; &#123;\n    override fun apply(target: Project) &#123;\n        with(target) &#123;\n            with(pluginManager) &#123;\n                apply(&quot;dagger.hilt.android.plugin&quot;)\n                // KAPT must go last to avoid build warnings.\n                // See: https://stackoverflow.com/questions/70550883/warning-the-following-options-were-not-recognized-by-any-processor-dagger-f\n                apply(&quot;org.jetbrains.kotlin.kapt&quot;)\n            &#125;\n\n            val libs = extensions.getByType&lt;VersionCatalogsExtension&gt;().named(&quot;libs&quot;)\n            dependencies &#123;\n                &quot;implementation&quot;(libs.findLibrary(&quot;hilt.android&quot;).get())\n                &quot;kapt&quot;(libs.findLibrary(&quot;hilt.compiler&quot;).get())\n                &quot;kaptAndroidTest&quot;(libs.findLibrary(&quot;hilt.compiler&quot;).get())\n            &#125;\n\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这样就配置好了hilt。</p>\n<p>最后一个app模块引入的插件是firebase-perf<br>这个是google出品的性能监控插件。<br>具体用法参考：<a href=\"https://blog.csdn.net/u010207898/article/details/125070024\">https://blog.csdn.net/u010207898/article/details/125070024</a></p>\n<hr>\n<p>好的下面继续看app模块下的build.gradle.kts<br>android层级下基本没啥大问题，配置applicationId版本号之类的。<br>这里有个testInstrumentationRunner选择自定义了：<br><code>testInstrumentationRunner = &quot;com.google.samples.apps.nowinandroid.core.testing.NiaTestRunner&quot;</code></p>\n<p>看下这里做了啥：<br>可以看到这个路径下是在testing模块下的，那应该就是测试相关的了。这里主要是用于单元测试的。这个NiaTestRunner继承了AndroidJunitRunner，这里代码如下：</p>\n<pre><code class=\"line-numbers language-groovy\">class NiaTestRunner : AndroidJUnitRunner() &#123;\n    override fun newApplication(cl: ClassLoader?, name: String?, context: Context?): Application &#123;\n        return super.newApplication(cl, HiltTestApplication::class.java.name, context)\n    &#125;\n&#125;\n</code></pre>\n<p>这个hilt居然还有做单元测试的注入，还是不错，收藏了。</p>\n<p>看下buildTypes里面的配置：</p>\n<pre><code class=\"line-numbers language-groovy\">   buildTypes &#123;\n        val debug by getting &#123;\n            applicationIdSuffix = NiaBuildType.DEBUG.applicationIdSuffix\n        &#125;\n</code></pre>\n<p>这里val debug by gettting为啥这样写？<br>这里其实分了2步：</p>\n<pre><code class=\"line-numbers language-groovy\">val release = getByName(&quot;release&quot;)\n    release.apply &#123;\n</code></pre>\n<p>等价于：<br><code> val release by getting</code></p>\n<p>继续下面：</p>\n<pre><code class=\"line-numbers language-groovy\">   packagingOptions &#123;\n        resources &#123;\n            excludes.add(&quot;/META-INF/&#123;AL2.0,LGPL2.1&#125;&quot;)\n        &#125;\n    &#125;\n</code></pre>\n<p>这个配置是什么呢：<br>打包配置，需要移除这个文件。</p>\n<p>继续下面：</p>\n<pre><code class=\"line-numbers language-groovy\">  testOptions &#123;\n        unitTests &#123;\n            isIncludeAndroidResources = true\n        &#125;\n        // TODO: Convert it as a convention plugin once Flamingo goes out (https://github.com/android/nowinandroid/issues/523)\n        managedDevices &#123;\n            devices &#123;\n                maybeCreate&lt;com.android.build.api.dsl.ManagedVirtualDevice&gt;(&quot;pixel4api30&quot;).apply &#123;\n                    device = &quot;Pixel 4&quot;\n                    apiLevel = 30\n                    // ATDs currently support only API level 30.\n                    systemImageSource = &quot;aosp-atd&quot;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>这里是一个testOptions，主要用于配置测试设备的一些属性。</p>\n<p>这里关于其它配置可以参考这篇文档<a href=\"https://blog.csdn.net/shulianghan/article/details/124919287\">https://blog.csdn.net/shulianghan/article/details/124919287</a></p>\n<p>继续看android闭包最后一个配置:<br><code>namespace = &quot;com.google.samples.apps.nowinandroid&quot;</code></p>\n<p>每个 Android 模块都有一个命名空间，此命名空间用作其生成的 R 和 BuildConfig 类的 Java 或 Kotlin 软件包名称。命名空间由模块的 build.gradle 文件中的 namespace 属性定义，如以下代码段所示。namespace 最初会设为您在创建项目时选择的软件包名称。</p>\n<p>最下面就是我们熟悉的dependencies了，可以看到这里非常简练，没有任何版本号，全是通过lis引入的，看着很舒服。</p>\n<pre><code class=\"line-numbers language-groovy\">\ndependencies &#123;\n    implementation(project(&quot;:feature:interests&quot;))\n    implementation(project(&quot;:feature:foryou&quot;))\n    implementation(project(&quot;:feature:bookmarks&quot;))\n    implementation(project(&quot;:feature:topic&quot;))\n    implementation(project(&quot;:feature:settings&quot;))\n\n    implementation(project(&quot;:core:common&quot;))\n    implementation(project(&quot;:core:ui&quot;))\n    implementation(project(&quot;:core:designsystem&quot;))\n    implementation(project(&quot;:core:data&quot;))\n    implementation(project(&quot;:core:model&quot;))\n\n    implementation(project(&quot;:sync:work&quot;))\n\n    androidTestImplementation(project(&quot;:core:testing&quot;))\n    androidTestImplementation(project(&quot;:core:datastore-test&quot;))\n    androidTestImplementation(project(&quot;:core:data-test&quot;))\n    androidTestImplementation(project(&quot;:core:network&quot;))\n    androidTestImplementation(libs.androidx.navigation.testing)\n    androidTestImplementation(libs.accompanist.testharness)\n    androidTestImplementation(kotlin(&quot;test&quot;))\n    debugImplementation(libs.androidx.compose.ui.testManifest)\n    debugImplementation(project(&quot;:ui-test-hilt-manifest&quot;))\n\n    implementation(libs.accompanist.systemuicontroller)\n    implementation(libs.androidx.activity.compose)\n    implementation(libs.androidx.appcompat)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.core.splashscreen)\n    implementation(libs.androidx.compose.runtime)\n    implementation(libs.androidx.lifecycle.runtimeCompose)\n    implementation(libs.androidx.compose.runtime.tracing)\n    implementation(libs.androidx.compose.material3.windowSizeClass)\n    implementation(libs.androidx.hilt.navigation.compose)\n    implementation(libs.androidx.navigation.compose)\n    implementation(libs.androidx.window.manager)\n    implementation(libs.androidx.profileinstaller)\n\n    implementation(libs.coil.kt)\n    implementation(libs.coil.kt.svg)\n&#125;\n</code></pre>\n<p>最下面是强制使用某个依赖：</p>\n<pre><code class=\"line-numbers language-groovy\">// androidx.test is forcing JUnit, 4.12. This forces it to use 4.13\nconfigurations.configureEach &#123;\n    resolutionStrategy &#123;\n        force(libs.junit4)\n        // Temporary workaround for https://issuetracker.google.com/174733673\n        force(&quot;org.objenesis:objenesis:2.6&quot;)\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"5-build-logic-模块配置构建逻辑\"><a href=\"#5-build-logic-模块配置构建逻辑\" class=\"headerlink\" title=\"5.build-logic 模块配置构建逻辑\"></a>5.build-logic 模块配置构建逻辑</h3><p>这里完全封装了自定义插件，定义依赖，配置相关的逻辑主要在这个模块，其实这个模块感觉可以复用，就是说换一个项目，这个模块基本上可以通用，改改具体版本号或者属性即可。哪些要用，哪些不用，在app模块下按需注册插件即可。</p>\n<p>首先看下这个模块的setttings.gradle.kts文件<br>很简单：</p>\n<pre><code class=\"line-numbers language-groovy\">dependencyResolutionManagement &#123;\n    repositories &#123;\n        google()\n        mavenCentral()\n    &#125;\n    versionCatalogs &#123;\n        create(&quot;libs&quot;) &#123;\n            from(files(&quot;../gradle/libs.versions.toml&quot;))\n        &#125;\n    &#125;\n&#125;\n\nrootProject.name = &quot;build-logic&quot;\ninclude(&quot;:convention&quot;)\n</code></pre>\n<p>这里最为关键的是用了一个 versionCatelogs，这里定义了我们所有三方依赖的地方。然后引入了这个模块下的convention的具体模块，这个模块就是编写自定义插件的地方。</p>\n<p>简单看下这个libs.version.toml文件吧，它放在项目级下的gradle文件夹中了：</p>\n<pre><code class=\"line-numbers language-groovy\">[versions]\naccompanist = &quot;0.28.0&quot;\nandroidDesugarJdkLibs = &quot;1.2.2&quot;\nandroidGradlePlugin = &quot;7.3.1&quot;\nandroidxActivity = &quot;1.6.1&quot;\nandroidxAppCompat = &quot;1.5.1&quot;\nandroidxBrowser = &quot;1.4.0&quot;\nandroidxComposeBom = &quot;2022.12.00&quot;\nandroidxComposeCompiler = &quot;1.4.0-alpha02&quot;\nandroidxComposeRuntimeTracing = &quot;1.0.0-alpha01&quot;\nandroidxCore = &quot;1.9.0&quot;\nandroidxCoreSplashscreen = &quot;1.0.0&quot;\nandroidxDataStore = &quot;1.0.0&quot;\nandroidxEspresso = &quot;3.5.0&quot;\nandroidxHiltNavigationCompose = &quot;1.0.0&quot;\nandroidxLifecycle = &quot;2.6.0-alpha03&quot;\nandroidxMacroBenchmark = &quot;1.1.1&quot;\nandroidxMetrics = &quot;1.0.0-alpha03&quot;\nandroidxNavigation = &quot;2.5.3&quot;\nandroidxProfileinstaller = &quot;1.2.1&quot;\n等等...\n</code></pre>\n<p>看下build-logic 模块下的build.gradle.kts文件：<br>首先引入了 kotlin-dsl 插件：</p>\n<pre><code class=\"line-numbers language-groovy\">plugins &#123;\n    `kotlin-dsl`\n&#125;\n</code></pre>\n<p>这样就能写 java 闭包了，还有一些 compileOnly方法等。具体关于dsl使用方法可以参考这篇文章：<a href=\"https://www.jianshu.com/p/461d4a249b71\">https://www.jianshu.com/p/461d4a249b71</a></p>\n<p>下面配置了执行build-logic需要依赖的一些东西：</p>\n<pre><code class=\"line-numbers language-groovy\">java &#123;\n    sourceCompatibility = JavaVersion.VERSION_1_8\n    targetCompatibility = JavaVersion.VERSION_1_8\n&#125;\n\ndependencies &#123;\n    compileOnly(libs.android.gradlePlugin)\n    compileOnly(libs.kotlin.gradlePlugin)\n&#125;\n</code></pre>\n<p>这里需要编译依赖一些三方库。</p>\n<p>然后下面是重点，gradlePlugin闭包下就是注册各种自定义插件了，并且实现类对应convention模块下的某个类，这个类继承了Plugin<Project>。</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6.总结\"></a>6.总结</h3><p>1.单独抽出一个module作为封装自定义插件的module。在这个module里面添加自定义插件的逻辑，在这个module的settings.gradle.kts中创建一个versionCatelogs，指向所有依赖文件中。<br>2.项目级别的settings.gradle.kts用includeBuild来引入上述module。<br>3.gradle.properties文件可以配置编译时buildconfig，aidl等文件是否生成。<br>4.app级别的build.gradle.kts按需配置自定义插件，testInstrumentationRunnner可以配置测试类。</p>\n"},{"title":"Flutter-学习导航","date":"2023-01-21T23:38:21.000Z","top":true,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 知识体系\n\n## 2 优秀站点\n\n### 2.1 Flutter实战\n> [https://book.flutterchina.club/](https://book.flutterchina.club/)\n\n### 2.2 Flutter开发文档\n> [https://flutter.cn/docs](https://flutter.cn/docs)\n\n### 2.3 老孟Flutter\n> [http://laomengit.com/flutter/widgets/widgets_structure.html](http://laomengit.com/flutter/widgets/widgets_structure.html)\n\n\n## 3 公众号\n\n### 3.1 西江悦\n<img src=blog_520lee_com.jpeg>\n\n### 3.2 Flutter社区\n<img src=FlutterDevs.jpeg>\n\n### 3.3 Flutter开发精选\n<img src=Study_Knowledge.jpeg>\n\n## 4 大神博客\n\n### 4.1 crazyCodeBoy\n> [https://www.devio.org/](https://www.devio.org/)\n\n### 4.2 Welcome to Flutter\n> [https://www.didierboelens.com/](https://www.didierboelens.com/)\n\n## 5 优秀三方库\n\n### 5.1 官方仓库\n> [https://pub.flutter-io.cn/](https://pub.flutter-io.cn/)\n\n## 6 项目推荐\n\n### 6.1 Flutter中国开源\n> [https://github.com/flutterchina](https://github.com/flutterchina)\n\n### 6.2 郭树煜\n> [https://github.com/CarGuo/gsy_github_app_flutter](https://github.com/CarGuo/gsy_github_app_flutter)\n\n### 6.3 AwesomeFlutter\n> [https://github.com/Solido/awesome-flutter](https://github.com/Solido/awesome-flutter)\n\n### 6.4 高仿豆瓣\n> [https://github.com/kaina404/FlutterDouBan](https://github.com/kaina404/FlutterDouBan)\n\n### 6.5 书旗小说\n> [https://github.com/jayden320/flutter_shuqi](https://github.com/jayden320/flutter_shuqi)\n\n\n\n## 7 其它\n\n### 7.1 面试相关\n\n### 7.2 开发工具相关\n","source":"_posts/Flutter-学习导航.md","raw":"---\ntitle: Flutter-学习导航\ndate: 2023-01-22 07:38:21\ntop: true\ncover: false\ntoc: true\nmathjax: true\ntags:\n- Flutter\ncategories:\n- Flutter\n---\n\n## 1 知识体系\n\n## 2 优秀站点\n\n### 2.1 Flutter实战\n> [https://book.flutterchina.club/](https://book.flutterchina.club/)\n\n### 2.2 Flutter开发文档\n> [https://flutter.cn/docs](https://flutter.cn/docs)\n\n### 2.3 老孟Flutter\n> [http://laomengit.com/flutter/widgets/widgets_structure.html](http://laomengit.com/flutter/widgets/widgets_structure.html)\n\n\n## 3 公众号\n\n### 3.1 西江悦\n<img src=blog_520lee_com.jpeg>\n\n### 3.2 Flutter社区\n<img src=FlutterDevs.jpeg>\n\n### 3.3 Flutter开发精选\n<img src=Study_Knowledge.jpeg>\n\n## 4 大神博客\n\n### 4.1 crazyCodeBoy\n> [https://www.devio.org/](https://www.devio.org/)\n\n### 4.2 Welcome to Flutter\n> [https://www.didierboelens.com/](https://www.didierboelens.com/)\n\n## 5 优秀三方库\n\n### 5.1 官方仓库\n> [https://pub.flutter-io.cn/](https://pub.flutter-io.cn/)\n\n## 6 项目推荐\n\n### 6.1 Flutter中国开源\n> [https://github.com/flutterchina](https://github.com/flutterchina)\n\n### 6.2 郭树煜\n> [https://github.com/CarGuo/gsy_github_app_flutter](https://github.com/CarGuo/gsy_github_app_flutter)\n\n### 6.3 AwesomeFlutter\n> [https://github.com/Solido/awesome-flutter](https://github.com/Solido/awesome-flutter)\n\n### 6.4 高仿豆瓣\n> [https://github.com/kaina404/FlutterDouBan](https://github.com/kaina404/FlutterDouBan)\n\n### 6.5 书旗小说\n> [https://github.com/jayden320/flutter_shuqi](https://github.com/jayden320/flutter_shuqi)\n\n\n\n## 7 其它\n\n### 7.1 面试相关\n\n### 7.2 开发工具相关\n","slug":"Flutter-学习导航","published":1,"updated":"2023-02-01T06:13:34.855Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlhfhyo0009ivv79g398pik","content":"<h2 id=\"1-知识体系\"><a href=\"#1-知识体系\" class=\"headerlink\" title=\"1 知识体系\"></a>1 知识体系</h2><h2 id=\"2-优秀站点\"><a href=\"#2-优秀站点\" class=\"headerlink\" title=\"2 优秀站点\"></a>2 优秀站点</h2><h3 id=\"2-1-Flutter实战\"><a href=\"#2-1-Flutter实战\" class=\"headerlink\" title=\"2.1 Flutter实战\"></a>2.1 Flutter实战</h3><blockquote>\n<p><a href=\"https://book.flutterchina.club/\">https://book.flutterchina.club/</a></p>\n</blockquote>\n<h3 id=\"2-2-Flutter开发文档\"><a href=\"#2-2-Flutter开发文档\" class=\"headerlink\" title=\"2.2 Flutter开发文档\"></a>2.2 Flutter开发文档</h3><blockquote>\n<p><a href=\"https://flutter.cn/docs\">https://flutter.cn/docs</a></p>\n</blockquote>\n<h3 id=\"2-3-老孟Flutter\"><a href=\"#2-3-老孟Flutter\" class=\"headerlink\" title=\"2.3 老孟Flutter\"></a>2.3 老孟Flutter</h3><blockquote>\n<p><a href=\"http://laomengit.com/flutter/widgets/widgets_structure.html\">http://laomengit.com/flutter/widgets/widgets_structure.html</a></p>\n</blockquote>\n<h2 id=\"3-公众号\"><a href=\"#3-公众号\" class=\"headerlink\" title=\"3 公众号\"></a>3 公众号</h2><h3 id=\"3-1-西江悦\"><a href=\"#3-1-西江悦\" class=\"headerlink\" title=\"3.1 西江悦\"></a>3.1 西江悦</h3><img src=blog_520lee_com.jpeg>\n\n<h3 id=\"3-2-Flutter社区\"><a href=\"#3-2-Flutter社区\" class=\"headerlink\" title=\"3.2 Flutter社区\"></a>3.2 Flutter社区</h3><img src=FlutterDevs.jpeg>\n\n<h3 id=\"3-3-Flutter开发精选\"><a href=\"#3-3-Flutter开发精选\" class=\"headerlink\" title=\"3.3 Flutter开发精选\"></a>3.3 Flutter开发精选</h3><img src=Study_Knowledge.jpeg>\n\n<h2 id=\"4-大神博客\"><a href=\"#4-大神博客\" class=\"headerlink\" title=\"4 大神博客\"></a>4 大神博客</h2><h3 id=\"4-1-crazyCodeBoy\"><a href=\"#4-1-crazyCodeBoy\" class=\"headerlink\" title=\"4.1 crazyCodeBoy\"></a>4.1 crazyCodeBoy</h3><blockquote>\n<p><a href=\"https://www.devio.org/\">https://www.devio.org/</a></p>\n</blockquote>\n<h3 id=\"4-2-Welcome-to-Flutter\"><a href=\"#4-2-Welcome-to-Flutter\" class=\"headerlink\" title=\"4.2 Welcome to Flutter\"></a>4.2 Welcome to Flutter</h3><blockquote>\n<p><a href=\"https://www.didierboelens.com/\">https://www.didierboelens.com/</a></p>\n</blockquote>\n<h2 id=\"5-优秀三方库\"><a href=\"#5-优秀三方库\" class=\"headerlink\" title=\"5 优秀三方库\"></a>5 优秀三方库</h2><h3 id=\"5-1-官方仓库\"><a href=\"#5-1-官方仓库\" class=\"headerlink\" title=\"5.1 官方仓库\"></a>5.1 官方仓库</h3><blockquote>\n<p><a href=\"https://pub.flutter-io.cn/\">https://pub.flutter-io.cn/</a></p>\n</blockquote>\n<h2 id=\"6-项目推荐\"><a href=\"#6-项目推荐\" class=\"headerlink\" title=\"6 项目推荐\"></a>6 项目推荐</h2><h3 id=\"6-1-Flutter中国开源\"><a href=\"#6-1-Flutter中国开源\" class=\"headerlink\" title=\"6.1 Flutter中国开源\"></a>6.1 Flutter中国开源</h3><blockquote>\n<p><a href=\"https://github.com/flutterchina\">https://github.com/flutterchina</a></p>\n</blockquote>\n<h3 id=\"6-2-郭树煜\"><a href=\"#6-2-郭树煜\" class=\"headerlink\" title=\"6.2 郭树煜\"></a>6.2 郭树煜</h3><blockquote>\n<p><a href=\"https://github.com/CarGuo/gsy_github_app_flutter\">https://github.com/CarGuo/gsy_github_app_flutter</a></p>\n</blockquote>\n<h3 id=\"6-3-AwesomeFlutter\"><a href=\"#6-3-AwesomeFlutter\" class=\"headerlink\" title=\"6.3 AwesomeFlutter\"></a>6.3 AwesomeFlutter</h3><blockquote>\n<p><a href=\"https://github.com/Solido/awesome-flutter\">https://github.com/Solido/awesome-flutter</a></p>\n</blockquote>\n<h3 id=\"6-4-高仿豆瓣\"><a href=\"#6-4-高仿豆瓣\" class=\"headerlink\" title=\"6.4 高仿豆瓣\"></a>6.4 高仿豆瓣</h3><blockquote>\n<p><a href=\"https://github.com/kaina404/FlutterDouBan\">https://github.com/kaina404/FlutterDouBan</a></p>\n</blockquote>\n<h3 id=\"6-5-书旗小说\"><a href=\"#6-5-书旗小说\" class=\"headerlink\" title=\"6.5 书旗小说\"></a>6.5 书旗小说</h3><blockquote>\n<p><a href=\"https://github.com/jayden320/flutter_shuqi\">https://github.com/jayden320/flutter_shuqi</a></p>\n</blockquote>\n<h2 id=\"7-其它\"><a href=\"#7-其它\" class=\"headerlink\" title=\"7 其它\"></a>7 其它</h2><h3 id=\"7-1-面试相关\"><a href=\"#7-1-面试相关\" class=\"headerlink\" title=\"7.1 面试相关\"></a>7.1 面试相关</h3><h3 id=\"7-2-开发工具相关\"><a href=\"#7-2-开发工具相关\" class=\"headerlink\" title=\"7.2 开发工具相关\"></a>7.2 开发工具相关</h3>","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-知识体系\"><a href=\"#1-知识体系\" class=\"headerlink\" title=\"1 知识体系\"></a>1 知识体系</h2><h2 id=\"2-优秀站点\"><a href=\"#2-优秀站点\" class=\"headerlink\" title=\"2 优秀站点\"></a>2 优秀站点</h2><h3 id=\"2-1-Flutter实战\"><a href=\"#2-1-Flutter实战\" class=\"headerlink\" title=\"2.1 Flutter实战\"></a>2.1 Flutter实战</h3><blockquote>\n<p><a href=\"https://book.flutterchina.club/\">https://book.flutterchina.club/</a></p>\n</blockquote>\n<h3 id=\"2-2-Flutter开发文档\"><a href=\"#2-2-Flutter开发文档\" class=\"headerlink\" title=\"2.2 Flutter开发文档\"></a>2.2 Flutter开发文档</h3><blockquote>\n<p><a href=\"https://flutter.cn/docs\">https://flutter.cn/docs</a></p>\n</blockquote>\n<h3 id=\"2-3-老孟Flutter\"><a href=\"#2-3-老孟Flutter\" class=\"headerlink\" title=\"2.3 老孟Flutter\"></a>2.3 老孟Flutter</h3><blockquote>\n<p><a href=\"http://laomengit.com/flutter/widgets/widgets_structure.html\">http://laomengit.com/flutter/widgets/widgets_structure.html</a></p>\n</blockquote>\n<h2 id=\"3-公众号\"><a href=\"#3-公众号\" class=\"headerlink\" title=\"3 公众号\"></a>3 公众号</h2><h3 id=\"3-1-西江悦\"><a href=\"#3-1-西江悦\" class=\"headerlink\" title=\"3.1 西江悦\"></a>3.1 西江悦</h3><img src=blog_520lee_com.jpeg>\n\n<h3 id=\"3-2-Flutter社区\"><a href=\"#3-2-Flutter社区\" class=\"headerlink\" title=\"3.2 Flutter社区\"></a>3.2 Flutter社区</h3><img src=FlutterDevs.jpeg>\n\n<h3 id=\"3-3-Flutter开发精选\"><a href=\"#3-3-Flutter开发精选\" class=\"headerlink\" title=\"3.3 Flutter开发精选\"></a>3.3 Flutter开发精选</h3><img src=Study_Knowledge.jpeg>\n\n<h2 id=\"4-大神博客\"><a href=\"#4-大神博客\" class=\"headerlink\" title=\"4 大神博客\"></a>4 大神博客</h2><h3 id=\"4-1-crazyCodeBoy\"><a href=\"#4-1-crazyCodeBoy\" class=\"headerlink\" title=\"4.1 crazyCodeBoy\"></a>4.1 crazyCodeBoy</h3><blockquote>\n<p><a href=\"https://www.devio.org/\">https://www.devio.org/</a></p>\n</blockquote>\n<h3 id=\"4-2-Welcome-to-Flutter\"><a href=\"#4-2-Welcome-to-Flutter\" class=\"headerlink\" title=\"4.2 Welcome to Flutter\"></a>4.2 Welcome to Flutter</h3><blockquote>\n<p><a href=\"https://www.didierboelens.com/\">https://www.didierboelens.com/</a></p>\n</blockquote>\n<h2 id=\"5-优秀三方库\"><a href=\"#5-优秀三方库\" class=\"headerlink\" title=\"5 优秀三方库\"></a>5 优秀三方库</h2><h3 id=\"5-1-官方仓库\"><a href=\"#5-1-官方仓库\" class=\"headerlink\" title=\"5.1 官方仓库\"></a>5.1 官方仓库</h3><blockquote>\n<p><a href=\"https://pub.flutter-io.cn/\">https://pub.flutter-io.cn/</a></p>\n</blockquote>\n<h2 id=\"6-项目推荐\"><a href=\"#6-项目推荐\" class=\"headerlink\" title=\"6 项目推荐\"></a>6 项目推荐</h2><h3 id=\"6-1-Flutter中国开源\"><a href=\"#6-1-Flutter中国开源\" class=\"headerlink\" title=\"6.1 Flutter中国开源\"></a>6.1 Flutter中国开源</h3><blockquote>\n<p><a href=\"https://github.com/flutterchina\">https://github.com/flutterchina</a></p>\n</blockquote>\n<h3 id=\"6-2-郭树煜\"><a href=\"#6-2-郭树煜\" class=\"headerlink\" title=\"6.2 郭树煜\"></a>6.2 郭树煜</h3><blockquote>\n<p><a href=\"https://github.com/CarGuo/gsy_github_app_flutter\">https://github.com/CarGuo/gsy_github_app_flutter</a></p>\n</blockquote>\n<h3 id=\"6-3-AwesomeFlutter\"><a href=\"#6-3-AwesomeFlutter\" class=\"headerlink\" title=\"6.3 AwesomeFlutter\"></a>6.3 AwesomeFlutter</h3><blockquote>\n<p><a href=\"https://github.com/Solido/awesome-flutter\">https://github.com/Solido/awesome-flutter</a></p>\n</blockquote>\n<h3 id=\"6-4-高仿豆瓣\"><a href=\"#6-4-高仿豆瓣\" class=\"headerlink\" title=\"6.4 高仿豆瓣\"></a>6.4 高仿豆瓣</h3><blockquote>\n<p><a href=\"https://github.com/kaina404/FlutterDouBan\">https://github.com/kaina404/FlutterDouBan</a></p>\n</blockquote>\n<h3 id=\"6-5-书旗小说\"><a href=\"#6-5-书旗小说\" class=\"headerlink\" title=\"6.5 书旗小说\"></a>6.5 书旗小说</h3><blockquote>\n<p><a href=\"https://github.com/jayden320/flutter_shuqi\">https://github.com/jayden320/flutter_shuqi</a></p>\n</blockquote>\n<h2 id=\"7-其它\"><a href=\"#7-其它\" class=\"headerlink\" title=\"7 其它\"></a>7 其它</h2><h3 id=\"7-1-面试相关\"><a href=\"#7-1-面试相关\" class=\"headerlink\" title=\"7.1 面试相关\"></a>7.1 面试相关</h3><h3 id=\"7-2-开发工具相关\"><a href=\"#7-2-开发工具相关\" class=\"headerlink\" title=\"7.2 开发工具相关\"></a>7.2 开发工具相关</h3>"},{"title":"iOS swift 如何实现扫码功能","date":"2023-01-29T00:13:37.000Z","top":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 需求定义\n\n这里有个需求，就是继承扫码能力，可以识别到条形码里面的内容。\n首先我们需要下载一个离线库，这个库里面会包含很多条码Code，相机通过识别到条码跟离线库中的匹配，如果匹配上了，会提示用户。所以首先我们肯定要有一个识别能力，数据库先不管，后面会有专门的文章来写数据库相关的东西。\n\n本篇文章主要是从0搭建一个可以识别条形码能力的Controller。\n其它额外需求先忽略。\n\n目标就是完成这样的效果：\n<img src=scan1.png>\n<img src=scan2.png>\n\n## 2 分析需求\n\n要具备扫码功能，肯定离不开相机，调用相机会设计到权限。\n所以我们得考虑是否有相机权限。\n其次，得考虑如何来识别条形码。\n重复识别到的问题。\n页面退出，相机资源怎么处理。\n光线太暗了，是否需要打开手电筒。\n条码太小，是否需要放大。\n等等，这些事先都得考虑到。\n\n\n## 3 打造页面\n\n### 3.1 构建UI\n\n首先把材料上齐。\n```Swift\nlazy var squareImgView: UIImageView = {\n        let imgv = UIImageView()\n        imgv.isUserInteractionEnabled = false\n        imgv.image = UIImage(named: \"扫码框\")\n        return imgv\n    }()\n    \n    lazy var torchButton: UIButton = {\n        let temp = UIButton(type: .custom)\n        temp.setImage(UIImage(named: \"scan_torch\"), for: .normal)\n        temp.setTitle(\"轻触照亮\", for: .normal)\n        temp.isHidden = true\n        temp.titleLabel?.font = UIFont.regular(15)\n        temp.ddy_SetStyle(.imgDown, padding: 10)\n        temp.addTarget(self, action: #selector(torchButtonClick), for: .touchUpInside)\n        return temp\n    }()\n    \n    lazy var photoBtn: UIButton = {\n        let btn = UIButton(type: .custom)\n        btn.setImage(UIImage(named: \"PhotoAlbum\"), for: .normal)\n        btn.addTarget(self, action: #selector(actionForPhoto), for: .touchUpInside)\n        return btn\n    }()\n    \n    lazy var tipsLabel: UILabel = {\n        let temp = UILabel()\n        temp.text = \"扫一扫条形码\"\n        temp.textColor = .white\n        temp.font = UIFont.regular(13)\n        temp.sizeToFit()\n        return temp\n    }()\n    \n    lazy var commitButton: UIButton = {\n        let btn: UIButton = UIButton(type: .custom)\n        btn.backgroundColor = UIColor(hex: \"#242424\")\n        btn.clipsToBounds = true\n        btn.layer.cornerRadius = 22\n        btn.layer.borderWidth = 1\n        btn.layer.borderColor = UIColor.white.cgColor\n        btn.setTitle(\"扫描完成\", for: .normal)\n        btn.addTarget(self, action: #selector(commitButtonClick), for: .touchUpInside)\n        return btn\n    }()\n    \n    lazy var inputButton: UIButton = {\n        let btn: UIButton = UIButton(type: .custom)\n        btn.backgroundColor = UIColor(hex: \"#242424\")\n        btn.layer.borderColor = UIColor.white.cgColor\n        btn.setTitle(\"手动输入条形码\", for: .normal)\n        btn.addTarget(self, action: #selector(actionForPushManuallyInput), for: .touchUpInside)\n        return btn\n    }()\n\n    lazy var layerView: UIView = {\n        let view = UIView(frame: CGRect(x: 0,\n                                        y: STATUS_BAR_HEIGHT + 44,\n                                        width: ScreenWidth,\n                                        height: ScreenHeight - STATUS_BAR_HEIGHT - 44 - 162))\n        return view\n    }()\n```\n打开需要这几个View。\n\n### 3.2 全局变量声明\n\n想要具备扫码能力，有几个类是必须的。\n```Swift\n// AVC 相关  相机硬件接口相关\n    private var videoDataOutput: AVCaptureVideoDataOutput?\n    private var output: AVCaptureMetadataOutput?\n    private var session: AVCaptureSession?\n    private var videoPreviewLayer: AVCaptureVideoPreviewLayer?\n```\n\n其它成员不着急，后续需要再加上去。\n\n### 3.3 生命周期之loadView\n\nloadView执行时机为：访问视图控制器的view时候，如何view为nil，或者还没有加载完成就会调用loadView方法来创建view。可以理解成先于viewDidLoad，一般走一次，一般用于视图初始化。\n\n这里就负责 添加子View 的工作。\n```Swift\nprivate func setupUI() {\n        view.addSubview(layerView)\n        view.addSubview(squareImgView)\n        view.addSubview(torchButton)\n        view.addSubview(tipsLabel)\n        view.addSubview(commitButton)\n        view.addSubview(inputButton)\n        view.addSubview(photoBtn)\n\n        squareImgView.snp.makeConstraints { make in\n            make.size.equalTo(320)\n            make.centerX.equalToSuperview()\n            make.top.equalTo(STATUS_BAR_HEIGHT + 44 + 76)\n        }\n        \n        torchButton.snp.makeConstraints { make in\n            make.centerX.equalToSuperview()\n            make.bottom.equalTo(squareImgView.snp.bottom).offset(20)\n            make.width.equalTo(320)\n            make.height.equalTo(200)\n        }\n        \n        tipsLabel.snp.makeConstraints { make in\n            make.centerX.equalToSuperview()\n            make.top.equalTo(squareImgView.snp.bottom).offset(12)\n        }\n        \n        commitButton.snp.makeConstraints { make in\n            make.top.equalTo(layerView.snp.bottom).offset(42)\n            make.leading.equalTo(102)\n            make.trailing.equalTo(-102)\n            make.height.equalTo(44)\n        }\n        \n        inputButton.snp.makeConstraints{ make in\n            make.top.equalTo(commitButton.snp.bottom).offset(12)\n            make.left.equalTo(commitButton)\n            make.right.equalTo(commitButton)\n            make.height.equalTo(36)\n        }\n        \n        photoBtn.snp.makeConstraints{ make in\n            make.centerY.equalTo(commitButton)\n            make.leading.equalTo(16)\n            make.width.height.equalTo(44)\n        }\n    }\n```\n可以看到，这里把架子搭上去了。\n\n### 3.4 生命周期之 viewDidLoad\n\n看下这里做了什么：\n```Swift\n override func viewDidLoad() {\n        super.viewDidLoad()\n        // 标题文字大小\n        navigationController?.navigationBar.navBarBackGroundColor(.black, image: UIImage(), isOpaque: false)\n        navigationController?.navigationBar.titleTextAttributes = [NSAttributedString.Key.foregroundColor:UIColor.white, NSAttributedString.Key.font : UIFont.pingFangMedium(size: 18)]\n        \n        // 背景黑色\n        view.backgroundColor = UIColor(hex: \"#242424\")\n\n        // 添加手势，用来实现二指缩放效果\n        addGesture()\n        \n        // 监听全局通知\n        addNotification()\n        \n        // 自己定义的协议，去加载历史数据\n        delegate?.loadHistoryData()\n        \n        // 手动输入条码闭包回调\n        manuallyInputViewController.inputBlock = { [unowned self] (_, code) in\n            self.delegate?.manuallyInput(code.replaceFlag)\n        }\n    }\n```\n\n如何添加手势呢？\n```Swift\nprivate func addGesture() {\n        let prinGesture = UIPinchGestureRecognizer(target: self, action: #selector(pinch(gesture:)))\n        layerView.addGestureRecognizer(prinGesture)\n    }\n```\n\n操作后会触发：\n```Swift\n@objc func pinch(gesture: UIPinchGestureRecognizer) {\n        guard let device = AVCaptureDevice.default(for: AVMediaType.video) else {\n            print(\"get front video AVCaptureDeviceInput  failed!\")\n            return\n        }\n        var minZoomFactor = 1.0\n        var maxZoomFactor = device.activeFormat.videoMaxZoomFactor\n        \n        if #available(iOS 11.0,*) {\n            minZoomFactor = device.minAvailableVideoZoomFactor\n            maxZoomFactor = device.maxAvailableVideoZoomFactor\n        }\n        \n        if gesture.state == .began {\n            lastZoomFactor = device.videoZoomFactor\n            print(\"缩放比例  \\(device.videoZoomFactor)\")\n            \n        } else if gesture.state == .changed{\n            var zoomFactor: Float = Float(lastZoomFactor * gesture.scale);\n            zoomFactor = fmaxf(fminf(zoomFactor, Float(maxZoomFactor)), Float(minZoomFactor))\n            print(\"缩放比例  \\(zoomFactor)\")\n            try? device.lockForConfiguration()\n            device.videoZoomFactor = CGFloat(zoomFactor)\n            device.unlockForConfiguration()\n        } else if gesture.state == .ended {\n            print(\"最终缩放比例  \\(device.videoZoomFactor)\")\n        }\n    }\n```\n\n其它的没啥了。\n\n### 3.5 生命周期之viewWillAppear\n\n这个是将要显示，一般做轻量级操作。\n```Swift\noverride func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n        setupRealWhiteClickCallBack()\n        setupBlackNavWhiteTitleBarColor()\n        isHiddenNavBar(isHidden: false)\n    }\n```\n主要实现了状态栏和标题栏相关的。\n\n### 3.6 生命周期之viewDidAppear\n\n这里是已经显示了，这里可以做稍微重量级代码。\n```Swift\noverride func viewDidAppear(_ animated: Bool) {\n        super.viewDidAppear(animated)\n        if self.session == nil {\n            self.scanQRCodePermission()\n        } else {\n            self.startScan()\n        }\n        UIApplication.shared.isIdleTimerDisabled = true\n        setNeedsStatusBarAppearanceUpdate()\n    }\n```\n很明显这里判断了下session是否为null。\n\n如果session为nil，则先判断是否有相机权限：\n```Swift\nfunc scanQRCodePermission() {\n        // 判断摄像头是否可用\n        let available = UIImagePickerController.isSourceTypeAvailable(.camera)\n        if available {\n            \n            // 判断是否有相机权限\n            let authStatus: AVAuthorizationStatus = AVCaptureDevice.authorizationStatus(for: AVMediaType.video)\n            if authStatus == .restricted {\n                let alerVC: UIAlertController = .init(title: \"提示\", message: \"由于系统原因, 无法访问相机\", preferredStyle: UIAlertController.Style.alert)\n                alerVC.addAction(UIAlertAction.init(title: \"确定\", style: .destructive) { (action) in\n                    UIApplication.shared.open(NSURL(string: UIApplication.openSettingsURLString)! as URL, options: [:] ) { (success) in\n                    }\n                })\n                present(alerVC, animated: true, completion: nil)\n            } else if authStatus == .denied {\n                let dic = Bundle.main.infoDictionary\n                var appName = dic?[\"CFBundleDisplayName\"]\n                if appName == nil{\n                    appName = dic?[\"CFBundleName\"]\n                }\n                let str = String.localizedStringWithFormat(\"[前往：设置 - 隐私 - 相机 - %@] 允许应用访问\", appName as! String)\n                let alerVC = UIAlertController(title: \"提示\", message: str, preferredStyle: .alert)\n                alerVC.addAction(UIAlertAction(title: \"确定\", style: UIAlertAction.Style.destructive) { (action) in\n                    UIApplication.shared.open(NSURL(string: UIApplication.openSettingsURLString)! as URL, options: [:] ) { (success) in\n                    }\n                })\n                present(alerVC, animated: true, completion: nil)\n            } else if authStatus == .notDetermined {\n                //用户未作出选择，申请权限 AVC直接requestAccess\n                AVCaptureDevice.requestAccess(for: AVMediaType.video){\n                    granted in\n                    DispatchQueue.main.async {\n                        if granted {\n                            //初次授权成功\n                            self.initCaptureSession()\n                        } else {\n                            //拒绝授权\n                        }\n                    }\n                }\n            } else {\n                //已授权\n                self.initCaptureSession()\n            }\n        } else {\n            //摄像头可能已损坏\n        }\n    }\n```\n上面的代码讲述了如何申请权限，权限被拒绝如何跳转设置。\n\n如果有权限了会走 initCaptureSession 来初始化session:\n```Swift\nfunc initCaptureSession() {\n        //创建会话对象\n        let `session` = AVCaptureSession()\n        self.session = session\n        session.sessionPreset = .high\n        \n        //获取设想设备\n        guard let device = AVCaptureDevice.default(for: AVMediaType.video) else {\n            print(\"get front video AVCaptureDeviceInput  failed!\")\n            return\n        }\n        \n        //创建设想设备输入流\n        guard let input = try? AVCaptureDeviceInput(device: device) else {\n            print(\"get front video AVCaptureDeviceInput  failed!\")\n            return\n        }\n        \n        //添加设想设备输入流到会话对象 输入流让session来分析\n        if session.canAddInput(input) {\n            session.addInput(input)\n        }\n        \n        //创建元数据输出流\n        let `output` = AVCaptureMetadataOutput()\n        self.output = output\n        output.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)\n                \n        //添加元数据输出流到会话对象 给新建的一个Output对象添加到session,session等下会给output赋值\n        session.addOutput(output)\n        \n        //创建摄像数据输出流并将其添加到会话对象上----->用户识别光线强弱\n        let `videoDataOutput` = AVCaptureVideoDataOutput()\n        self.videoDataOutput = videoDataOutput\n        videoDataOutput.setSampleBufferDelegate(self, queue: DispatchQueue.main)\n        session.addOutput(videoDataOutput)\n        \n        //设置数据输出类型(如下设置为条形码和二维码兼容)，需要将数据输出添加到会话后，才能指定元数据类型，否则会报错\n        \n        /*\n         \n         android\n         \n         Barcode.FORMAT_CODE_128,   *\n         Barcode.FORMAT_CODE_39,    *\n         Barcode.FORMAT_CODE_93,    *\n         Barcode.FORMAT_CODABAR,    ios 15.4 +\n         Barcode.FORMAT_EAN_13,     *\n         Barcode.FORMAT_EAN_8,      *\n         Barcode.FORMAT_UPC_A,      x\n         Barcode.FORMAT_UPC_E,      *\n         Barcode.TYPE_ISBN          x\n         */\n        output.metadataObjectTypes = [.code39,\n                                      .code39Mod43,\n                                      .code93,\n                                      .code128,\n                                      .ean8,\n                                      .ean13,\n                                      .upce,\n                                      .pdf417] //itf14\n        //实例化预览图层, 用于显示会话对象 session放到这里面，然后通过layer插入sublayer可以实现预览效果\n        let `videoPreviewLayer` = AVCaptureVideoPreviewLayer(session: session)\n        self.videoPreviewLayer = videoPreviewLayer\n        videoPreviewLayer.videoGravity = .resizeAspectFill\n        videoPreviewLayer.frame = layerView.bounds\n        layerView.layer.insertSublayer(videoPreviewLayer, at: 0)\n        \n        // session开始run\n        startScan()\n    }\n```\n\n回到 生命周期 中，如果 session 不为空，会走上面的startScan 函数，这里就是让session继续工作的意思：\n```Swift\nfunc startScan() {\n        session?.startRunning()\n    }\n```\n\n在viewDidAppear中还做了什么呢？\n```Swift\nUIApplication.shared.isIdleTimerDisabled = true\nsetNeedsStatusBarAppearanceUpdate()\n```\n\n第一行：禁止该页面进入睡眠；\n第二行：如果在viewController已经显示在当前页面，你可能还要在当前页面不时的更改statusBar的前景色，那么，你首先需要调用下面的setNeedsStatusBarAppearanceUpdate方法(这个方法会通知系统去调用当前UIViewController的preferredStatusBarStyle方法)，从而改变statusBar的statusBarStyle。\n\n### 3.7 生命周期之viewDidDisappear\n\n```Swift\n override func viewDidDisappear(_ animated: Bool) {\n        super.viewDidDisappear(animated)\n        stopScan()\n        UIApplication.shared.isIdleTimerDisabled = false\n        setNeedsStatusBarAppearanceUpdate()\n    }\n```\n这里停止扫描，应该是停止session:\n```Swift\nfunc stopScan() {\n        session?.stopRunning()\n    }\n```\n\n其它上面讲过，不必多言了。\n\n### 3.8 设置output代理\n\n回到初始化session的部分代码中：\n```Swift\n//创建元数据输出流\nlet `output` = AVCaptureMetadataOutput()\nself.output = output\noutput.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)\n```\n这里设置了一个metadata的代理，所以这个controller必然扩展了这个代理。\n\n具体如下：\n```Swift\nextension GMBaseScanViewController: AVCaptureMetadataOutputObjectsDelegate {\n    func metadataOutput(_ output: AVCaptureMetadataOutput, didOutput metadataObjects: [AVMetadataObject], from connection: AVCaptureConnection) {\n        if isCanScan {\n            let isAchieve: Bool = metadataObjects.count == 1\n            if isAchieve {\n                // 扫到条码\n                guard let device = AVCaptureDevice.default(for: AVMediaType.video) else { return }\n                guard let codeObj = metadataObjects.last as? AVMetadataMachineReadableCodeObject else { return }\n                print(\"扫到了条码 codeObj  ：  \\(codeObj)\")\n                guard let str = codeObj.stringValue else { return }\n                self.isCanScan = false\n                print(\"扫到了条码 str：  \\(str)\")\n                DispatchQueue.main.asyncAfter(deadline: .now() + scanInterval) {\n                    try? device.lockForConfiguration()\n                    device.videoZoomFactor = 1\n                    device.unlockForConfiguration()\n                    self.isCanScan = true\n                }\n                let barCode = barcodeProcessing(str)\n                delegate?.scanBarcode(barCode)\n            } else {\n                MBProgressHUD.showTipsMessage(\"无法识别\")\n            }\n        }\n    }\n    \n    func barcodeProcessing(_ code: String) -> String {\n        var codeStr: String = code.mutableCopy() as! String\n        var newStr = code.uppercased()\n        var index = 0\n        newStr = newStr.replacingOccurrences(of: \" \", with: \"\", options: .literal, range: nil)\n        codeStr = codeStr.replacingOccurrences(of: \" \", with: \"\", options: .literal, range: nil)\n        if newStr.hasPrefix(\"GREE\") {\n            index = 3\n        } else if newStr.hasPrefix(\"KINGHOME\") {\n            index = 7\n        } else if newStr.hasPrefix(\"TOSOT\") {\n            index = 4\n        }\n        if index != 0 {\n            let start = codeStr.index(codeStr.startIndex, offsetBy: 0)\n            let end = codeStr.index(codeStr.startIndex, offsetBy: index)\n            codeStr.removeSubrange(start...end)\n        }\n        return codeStr\n    }\n}\n```\n这里覆写了这协议方法，表示识别到内容了。然后会回调metadateOutput，原因是前面session里面设置了Output的代理为self,也就是这里，这里就关联起来了。\n前面是这样的：\n```Swift\n let `output` = AVCaptureMetadataOutput()\n        self.output = output\n        output.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)\n                \n        //添加元数据输出流到会话对象 给新建的一个Output对象添加到session,session等下会给output赋值\n        session.addOutput(output)\n```\n就是因为这个self，当session开始running后，就会走协议的回调方法，在那里面我们间隔3.5才让它进行下次扫描，也是在这里面分析这个条码是否正常之类的。\n\n### 3.9 设置videoDataOuput代理\n\n这个代理，目的是为了识别光线强弱。\n```Swift\nextension GMBaseScanViewController: AVCaptureVideoDataOutputSampleBufferDelegate {\n    \n    func captureOutput(_ output: AVCaptureOutput, didOutput sampleBuffer: CMSampleBuffer, from connection: AVCaptureConnection) {\n        // 获取光照亮度\n        guard let metadataCFDict: CFDictionary = CMCopyDictionaryOfAttachments(allocator: nil, target: sampleBuffer, attachmentMode: 1) else { return }\n        guard let metadataDic: [String: AnyObject] = metadataCFDict as? [String: AnyObject] else { return }\n        guard let exifMetadata: [String: AnyObject] = metadataDic[kCGImagePropertyExifDictionary as String] as? [String : AnyObject] else { return }\n        guard let brightnessValue: CGFloat = exifMetadata[kCGImagePropertyExifBrightnessValue as String] as? CGFloat else { return }\n        // 根据光照亮度展示按钮\n        if brightnessValue < -1 {\n            torchButton.isHidden = false\n        } else {\n            guard let device = AVCaptureDevice.default(for: AVMediaType.video) else { return }\n            if device.hasTorch && device.isTorchAvailable {\n                try? device.lockForConfiguration()\n                torchButton.isHidden = !(device.torchMode == .on)\n                device.unlockForConfiguration()\n                \n            }\n        }\n        \n    }\n    \n    private func convert(cmage: CIImage) -> UIImage {\n         let context = CIContext(options: nil)\n         let cgImage = context.createCGImage(cmage, from: cmage.extent)!\n         let image = UIImage(cgImage: cgImage)\n         return image\n    }\n    \n}\n```\n在代理 captureOutput的回调方法中可以获取光线强弱信息。\n\n也是在初始化session的时候设置了这个代理。\n\n### 3.10 识别到后播放声音\n\n这里我们额外增加一个方法，主要给外面调用，因为我们会提供一个代理，如果识别到后，通过代理内部方法将识别的条码给外面。这时候外面要震动或声音效果，只需要调用我们内部的一个方法即可。\n\n```Swift\nfunc playAudio(success code: Int) {\n        if isPlay == false {\n            return\n        }\n        if code == 1 {\n            var soundID: SystemSoundID = 0\n            guard let path = Bundle.main.path(forResource: \"scanSuccess\", ofType: \"mp3\") else { return }\n            let url = URL(fileURLWithPath: path)\n            AudioServicesCreateSystemSoundID(url as CFURL, &soundID)\n            AudioServicesPlaySystemSound(soundID) //声音\n        } else {\n            var soundID: SystemSoundID = 0\n            guard let path = Bundle.main.path(forResource: \"scanFail\", ofType: \"mp3\") else { return }\n            let url = URL(fileURLWithPath: path)\n            AudioServicesCreateSystemSoundID(url as CFURL, &soundID)\n            AudioServicesPlayAlertSound(soundID) //震动+播放声音\n        }\n    }\n```\n也是非常简单，只需要先拿到声音路径，转换url，再通过AudioServicesCreateSystemSoundID包装一下，再通过AudioServicesPlaySystemSound来播放这个soundID即可。\n\n就这样，一个具有扫码能力的Controller就出来了哦。\n\n## 4 总结\n\n* 如果用到扫码，一定需要申请权限的，必须考虑到是否有权限，如果拒绝了权限，或其它原因导致没有权限，都需要考虑。\n\n* 扫码关键的几个类，AVCaptureSession控制数据流关键类；AVCaptureMetadataOutput接收流，代理方法来处理识别到条码后的逻辑；AVCaptureVideoDataOutput接收流，可以处理光线强弱；AVCaptureVideoPreviewLayer用来预览相机的视图层，可显示在UIView的layer上。\n\n* 一般扫码需要具备的二指缩放，光线太暗打开闪光灯，这些可以算作基本能能力，务必要实现，否则体验很不佳。\n\n* 合理控制识别到条码间隔时间，该停止session的时候务必停止，为了防止频繁识别到相同条码，可以设置间隔时间。\n\n* 可以先定义一个播放声音效果的方法，方便外部直接调用方法播放成功或者失败的声音。声音主要用到AudioServices相关方法。\n\n* 系统类大多都是提供了代理，暴露了一些方法主要都是定义好的方法，我们业务开发也只需要接收和处理这些定义好的类就可以了。\n","source":"_posts/iOS-swift-如何实现扫码功能.md","raw":"---\ntitle: iOS swift 如何实现扫码功能\ndate: 2023-01-29 08:13:37\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- 条形码识别 相机\ncategories:\n- iOS\n---\n\n## 1 需求定义\n\n这里有个需求，就是继承扫码能力，可以识别到条形码里面的内容。\n首先我们需要下载一个离线库，这个库里面会包含很多条码Code，相机通过识别到条码跟离线库中的匹配，如果匹配上了，会提示用户。所以首先我们肯定要有一个识别能力，数据库先不管，后面会有专门的文章来写数据库相关的东西。\n\n本篇文章主要是从0搭建一个可以识别条形码能力的Controller。\n其它额外需求先忽略。\n\n目标就是完成这样的效果：\n<img src=scan1.png>\n<img src=scan2.png>\n\n## 2 分析需求\n\n要具备扫码功能，肯定离不开相机，调用相机会设计到权限。\n所以我们得考虑是否有相机权限。\n其次，得考虑如何来识别条形码。\n重复识别到的问题。\n页面退出，相机资源怎么处理。\n光线太暗了，是否需要打开手电筒。\n条码太小，是否需要放大。\n等等，这些事先都得考虑到。\n\n\n## 3 打造页面\n\n### 3.1 构建UI\n\n首先把材料上齐。\n```Swift\nlazy var squareImgView: UIImageView = {\n        let imgv = UIImageView()\n        imgv.isUserInteractionEnabled = false\n        imgv.image = UIImage(named: \"扫码框\")\n        return imgv\n    }()\n    \n    lazy var torchButton: UIButton = {\n        let temp = UIButton(type: .custom)\n        temp.setImage(UIImage(named: \"scan_torch\"), for: .normal)\n        temp.setTitle(\"轻触照亮\", for: .normal)\n        temp.isHidden = true\n        temp.titleLabel?.font = UIFont.regular(15)\n        temp.ddy_SetStyle(.imgDown, padding: 10)\n        temp.addTarget(self, action: #selector(torchButtonClick), for: .touchUpInside)\n        return temp\n    }()\n    \n    lazy var photoBtn: UIButton = {\n        let btn = UIButton(type: .custom)\n        btn.setImage(UIImage(named: \"PhotoAlbum\"), for: .normal)\n        btn.addTarget(self, action: #selector(actionForPhoto), for: .touchUpInside)\n        return btn\n    }()\n    \n    lazy var tipsLabel: UILabel = {\n        let temp = UILabel()\n        temp.text = \"扫一扫条形码\"\n        temp.textColor = .white\n        temp.font = UIFont.regular(13)\n        temp.sizeToFit()\n        return temp\n    }()\n    \n    lazy var commitButton: UIButton = {\n        let btn: UIButton = UIButton(type: .custom)\n        btn.backgroundColor = UIColor(hex: \"#242424\")\n        btn.clipsToBounds = true\n        btn.layer.cornerRadius = 22\n        btn.layer.borderWidth = 1\n        btn.layer.borderColor = UIColor.white.cgColor\n        btn.setTitle(\"扫描完成\", for: .normal)\n        btn.addTarget(self, action: #selector(commitButtonClick), for: .touchUpInside)\n        return btn\n    }()\n    \n    lazy var inputButton: UIButton = {\n        let btn: UIButton = UIButton(type: .custom)\n        btn.backgroundColor = UIColor(hex: \"#242424\")\n        btn.layer.borderColor = UIColor.white.cgColor\n        btn.setTitle(\"手动输入条形码\", for: .normal)\n        btn.addTarget(self, action: #selector(actionForPushManuallyInput), for: .touchUpInside)\n        return btn\n    }()\n\n    lazy var layerView: UIView = {\n        let view = UIView(frame: CGRect(x: 0,\n                                        y: STATUS_BAR_HEIGHT + 44,\n                                        width: ScreenWidth,\n                                        height: ScreenHeight - STATUS_BAR_HEIGHT - 44 - 162))\n        return view\n    }()\n```\n打开需要这几个View。\n\n### 3.2 全局变量声明\n\n想要具备扫码能力，有几个类是必须的。\n```Swift\n// AVC 相关  相机硬件接口相关\n    private var videoDataOutput: AVCaptureVideoDataOutput?\n    private var output: AVCaptureMetadataOutput?\n    private var session: AVCaptureSession?\n    private var videoPreviewLayer: AVCaptureVideoPreviewLayer?\n```\n\n其它成员不着急，后续需要再加上去。\n\n### 3.3 生命周期之loadView\n\nloadView执行时机为：访问视图控制器的view时候，如何view为nil，或者还没有加载完成就会调用loadView方法来创建view。可以理解成先于viewDidLoad，一般走一次，一般用于视图初始化。\n\n这里就负责 添加子View 的工作。\n```Swift\nprivate func setupUI() {\n        view.addSubview(layerView)\n        view.addSubview(squareImgView)\n        view.addSubview(torchButton)\n        view.addSubview(tipsLabel)\n        view.addSubview(commitButton)\n        view.addSubview(inputButton)\n        view.addSubview(photoBtn)\n\n        squareImgView.snp.makeConstraints { make in\n            make.size.equalTo(320)\n            make.centerX.equalToSuperview()\n            make.top.equalTo(STATUS_BAR_HEIGHT + 44 + 76)\n        }\n        \n        torchButton.snp.makeConstraints { make in\n            make.centerX.equalToSuperview()\n            make.bottom.equalTo(squareImgView.snp.bottom).offset(20)\n            make.width.equalTo(320)\n            make.height.equalTo(200)\n        }\n        \n        tipsLabel.snp.makeConstraints { make in\n            make.centerX.equalToSuperview()\n            make.top.equalTo(squareImgView.snp.bottom).offset(12)\n        }\n        \n        commitButton.snp.makeConstraints { make in\n            make.top.equalTo(layerView.snp.bottom).offset(42)\n            make.leading.equalTo(102)\n            make.trailing.equalTo(-102)\n            make.height.equalTo(44)\n        }\n        \n        inputButton.snp.makeConstraints{ make in\n            make.top.equalTo(commitButton.snp.bottom).offset(12)\n            make.left.equalTo(commitButton)\n            make.right.equalTo(commitButton)\n            make.height.equalTo(36)\n        }\n        \n        photoBtn.snp.makeConstraints{ make in\n            make.centerY.equalTo(commitButton)\n            make.leading.equalTo(16)\n            make.width.height.equalTo(44)\n        }\n    }\n```\n可以看到，这里把架子搭上去了。\n\n### 3.4 生命周期之 viewDidLoad\n\n看下这里做了什么：\n```Swift\n override func viewDidLoad() {\n        super.viewDidLoad()\n        // 标题文字大小\n        navigationController?.navigationBar.navBarBackGroundColor(.black, image: UIImage(), isOpaque: false)\n        navigationController?.navigationBar.titleTextAttributes = [NSAttributedString.Key.foregroundColor:UIColor.white, NSAttributedString.Key.font : UIFont.pingFangMedium(size: 18)]\n        \n        // 背景黑色\n        view.backgroundColor = UIColor(hex: \"#242424\")\n\n        // 添加手势，用来实现二指缩放效果\n        addGesture()\n        \n        // 监听全局通知\n        addNotification()\n        \n        // 自己定义的协议，去加载历史数据\n        delegate?.loadHistoryData()\n        \n        // 手动输入条码闭包回调\n        manuallyInputViewController.inputBlock = { [unowned self] (_, code) in\n            self.delegate?.manuallyInput(code.replaceFlag)\n        }\n    }\n```\n\n如何添加手势呢？\n```Swift\nprivate func addGesture() {\n        let prinGesture = UIPinchGestureRecognizer(target: self, action: #selector(pinch(gesture:)))\n        layerView.addGestureRecognizer(prinGesture)\n    }\n```\n\n操作后会触发：\n```Swift\n@objc func pinch(gesture: UIPinchGestureRecognizer) {\n        guard let device = AVCaptureDevice.default(for: AVMediaType.video) else {\n            print(\"get front video AVCaptureDeviceInput  failed!\")\n            return\n        }\n        var minZoomFactor = 1.0\n        var maxZoomFactor = device.activeFormat.videoMaxZoomFactor\n        \n        if #available(iOS 11.0,*) {\n            minZoomFactor = device.minAvailableVideoZoomFactor\n            maxZoomFactor = device.maxAvailableVideoZoomFactor\n        }\n        \n        if gesture.state == .began {\n            lastZoomFactor = device.videoZoomFactor\n            print(\"缩放比例  \\(device.videoZoomFactor)\")\n            \n        } else if gesture.state == .changed{\n            var zoomFactor: Float = Float(lastZoomFactor * gesture.scale);\n            zoomFactor = fmaxf(fminf(zoomFactor, Float(maxZoomFactor)), Float(minZoomFactor))\n            print(\"缩放比例  \\(zoomFactor)\")\n            try? device.lockForConfiguration()\n            device.videoZoomFactor = CGFloat(zoomFactor)\n            device.unlockForConfiguration()\n        } else if gesture.state == .ended {\n            print(\"最终缩放比例  \\(device.videoZoomFactor)\")\n        }\n    }\n```\n\n其它的没啥了。\n\n### 3.5 生命周期之viewWillAppear\n\n这个是将要显示，一般做轻量级操作。\n```Swift\noverride func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n        setupRealWhiteClickCallBack()\n        setupBlackNavWhiteTitleBarColor()\n        isHiddenNavBar(isHidden: false)\n    }\n```\n主要实现了状态栏和标题栏相关的。\n\n### 3.6 生命周期之viewDidAppear\n\n这里是已经显示了，这里可以做稍微重量级代码。\n```Swift\noverride func viewDidAppear(_ animated: Bool) {\n        super.viewDidAppear(animated)\n        if self.session == nil {\n            self.scanQRCodePermission()\n        } else {\n            self.startScan()\n        }\n        UIApplication.shared.isIdleTimerDisabled = true\n        setNeedsStatusBarAppearanceUpdate()\n    }\n```\n很明显这里判断了下session是否为null。\n\n如果session为nil，则先判断是否有相机权限：\n```Swift\nfunc scanQRCodePermission() {\n        // 判断摄像头是否可用\n        let available = UIImagePickerController.isSourceTypeAvailable(.camera)\n        if available {\n            \n            // 判断是否有相机权限\n            let authStatus: AVAuthorizationStatus = AVCaptureDevice.authorizationStatus(for: AVMediaType.video)\n            if authStatus == .restricted {\n                let alerVC: UIAlertController = .init(title: \"提示\", message: \"由于系统原因, 无法访问相机\", preferredStyle: UIAlertController.Style.alert)\n                alerVC.addAction(UIAlertAction.init(title: \"确定\", style: .destructive) { (action) in\n                    UIApplication.shared.open(NSURL(string: UIApplication.openSettingsURLString)! as URL, options: [:] ) { (success) in\n                    }\n                })\n                present(alerVC, animated: true, completion: nil)\n            } else if authStatus == .denied {\n                let dic = Bundle.main.infoDictionary\n                var appName = dic?[\"CFBundleDisplayName\"]\n                if appName == nil{\n                    appName = dic?[\"CFBundleName\"]\n                }\n                let str = String.localizedStringWithFormat(\"[前往：设置 - 隐私 - 相机 - %@] 允许应用访问\", appName as! String)\n                let alerVC = UIAlertController(title: \"提示\", message: str, preferredStyle: .alert)\n                alerVC.addAction(UIAlertAction(title: \"确定\", style: UIAlertAction.Style.destructive) { (action) in\n                    UIApplication.shared.open(NSURL(string: UIApplication.openSettingsURLString)! as URL, options: [:] ) { (success) in\n                    }\n                })\n                present(alerVC, animated: true, completion: nil)\n            } else if authStatus == .notDetermined {\n                //用户未作出选择，申请权限 AVC直接requestAccess\n                AVCaptureDevice.requestAccess(for: AVMediaType.video){\n                    granted in\n                    DispatchQueue.main.async {\n                        if granted {\n                            //初次授权成功\n                            self.initCaptureSession()\n                        } else {\n                            //拒绝授权\n                        }\n                    }\n                }\n            } else {\n                //已授权\n                self.initCaptureSession()\n            }\n        } else {\n            //摄像头可能已损坏\n        }\n    }\n```\n上面的代码讲述了如何申请权限，权限被拒绝如何跳转设置。\n\n如果有权限了会走 initCaptureSession 来初始化session:\n```Swift\nfunc initCaptureSession() {\n        //创建会话对象\n        let `session` = AVCaptureSession()\n        self.session = session\n        session.sessionPreset = .high\n        \n        //获取设想设备\n        guard let device = AVCaptureDevice.default(for: AVMediaType.video) else {\n            print(\"get front video AVCaptureDeviceInput  failed!\")\n            return\n        }\n        \n        //创建设想设备输入流\n        guard let input = try? AVCaptureDeviceInput(device: device) else {\n            print(\"get front video AVCaptureDeviceInput  failed!\")\n            return\n        }\n        \n        //添加设想设备输入流到会话对象 输入流让session来分析\n        if session.canAddInput(input) {\n            session.addInput(input)\n        }\n        \n        //创建元数据输出流\n        let `output` = AVCaptureMetadataOutput()\n        self.output = output\n        output.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)\n                \n        //添加元数据输出流到会话对象 给新建的一个Output对象添加到session,session等下会给output赋值\n        session.addOutput(output)\n        \n        //创建摄像数据输出流并将其添加到会话对象上----->用户识别光线强弱\n        let `videoDataOutput` = AVCaptureVideoDataOutput()\n        self.videoDataOutput = videoDataOutput\n        videoDataOutput.setSampleBufferDelegate(self, queue: DispatchQueue.main)\n        session.addOutput(videoDataOutput)\n        \n        //设置数据输出类型(如下设置为条形码和二维码兼容)，需要将数据输出添加到会话后，才能指定元数据类型，否则会报错\n        \n        /*\n         \n         android\n         \n         Barcode.FORMAT_CODE_128,   *\n         Barcode.FORMAT_CODE_39,    *\n         Barcode.FORMAT_CODE_93,    *\n         Barcode.FORMAT_CODABAR,    ios 15.4 +\n         Barcode.FORMAT_EAN_13,     *\n         Barcode.FORMAT_EAN_8,      *\n         Barcode.FORMAT_UPC_A,      x\n         Barcode.FORMAT_UPC_E,      *\n         Barcode.TYPE_ISBN          x\n         */\n        output.metadataObjectTypes = [.code39,\n                                      .code39Mod43,\n                                      .code93,\n                                      .code128,\n                                      .ean8,\n                                      .ean13,\n                                      .upce,\n                                      .pdf417] //itf14\n        //实例化预览图层, 用于显示会话对象 session放到这里面，然后通过layer插入sublayer可以实现预览效果\n        let `videoPreviewLayer` = AVCaptureVideoPreviewLayer(session: session)\n        self.videoPreviewLayer = videoPreviewLayer\n        videoPreviewLayer.videoGravity = .resizeAspectFill\n        videoPreviewLayer.frame = layerView.bounds\n        layerView.layer.insertSublayer(videoPreviewLayer, at: 0)\n        \n        // session开始run\n        startScan()\n    }\n```\n\n回到 生命周期 中，如果 session 不为空，会走上面的startScan 函数，这里就是让session继续工作的意思：\n```Swift\nfunc startScan() {\n        session?.startRunning()\n    }\n```\n\n在viewDidAppear中还做了什么呢？\n```Swift\nUIApplication.shared.isIdleTimerDisabled = true\nsetNeedsStatusBarAppearanceUpdate()\n```\n\n第一行：禁止该页面进入睡眠；\n第二行：如果在viewController已经显示在当前页面，你可能还要在当前页面不时的更改statusBar的前景色，那么，你首先需要调用下面的setNeedsStatusBarAppearanceUpdate方法(这个方法会通知系统去调用当前UIViewController的preferredStatusBarStyle方法)，从而改变statusBar的statusBarStyle。\n\n### 3.7 生命周期之viewDidDisappear\n\n```Swift\n override func viewDidDisappear(_ animated: Bool) {\n        super.viewDidDisappear(animated)\n        stopScan()\n        UIApplication.shared.isIdleTimerDisabled = false\n        setNeedsStatusBarAppearanceUpdate()\n    }\n```\n这里停止扫描，应该是停止session:\n```Swift\nfunc stopScan() {\n        session?.stopRunning()\n    }\n```\n\n其它上面讲过，不必多言了。\n\n### 3.8 设置output代理\n\n回到初始化session的部分代码中：\n```Swift\n//创建元数据输出流\nlet `output` = AVCaptureMetadataOutput()\nself.output = output\noutput.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)\n```\n这里设置了一个metadata的代理，所以这个controller必然扩展了这个代理。\n\n具体如下：\n```Swift\nextension GMBaseScanViewController: AVCaptureMetadataOutputObjectsDelegate {\n    func metadataOutput(_ output: AVCaptureMetadataOutput, didOutput metadataObjects: [AVMetadataObject], from connection: AVCaptureConnection) {\n        if isCanScan {\n            let isAchieve: Bool = metadataObjects.count == 1\n            if isAchieve {\n                // 扫到条码\n                guard let device = AVCaptureDevice.default(for: AVMediaType.video) else { return }\n                guard let codeObj = metadataObjects.last as? AVMetadataMachineReadableCodeObject else { return }\n                print(\"扫到了条码 codeObj  ：  \\(codeObj)\")\n                guard let str = codeObj.stringValue else { return }\n                self.isCanScan = false\n                print(\"扫到了条码 str：  \\(str)\")\n                DispatchQueue.main.asyncAfter(deadline: .now() + scanInterval) {\n                    try? device.lockForConfiguration()\n                    device.videoZoomFactor = 1\n                    device.unlockForConfiguration()\n                    self.isCanScan = true\n                }\n                let barCode = barcodeProcessing(str)\n                delegate?.scanBarcode(barCode)\n            } else {\n                MBProgressHUD.showTipsMessage(\"无法识别\")\n            }\n        }\n    }\n    \n    func barcodeProcessing(_ code: String) -> String {\n        var codeStr: String = code.mutableCopy() as! String\n        var newStr = code.uppercased()\n        var index = 0\n        newStr = newStr.replacingOccurrences(of: \" \", with: \"\", options: .literal, range: nil)\n        codeStr = codeStr.replacingOccurrences(of: \" \", with: \"\", options: .literal, range: nil)\n        if newStr.hasPrefix(\"GREE\") {\n            index = 3\n        } else if newStr.hasPrefix(\"KINGHOME\") {\n            index = 7\n        } else if newStr.hasPrefix(\"TOSOT\") {\n            index = 4\n        }\n        if index != 0 {\n            let start = codeStr.index(codeStr.startIndex, offsetBy: 0)\n            let end = codeStr.index(codeStr.startIndex, offsetBy: index)\n            codeStr.removeSubrange(start...end)\n        }\n        return codeStr\n    }\n}\n```\n这里覆写了这协议方法，表示识别到内容了。然后会回调metadateOutput，原因是前面session里面设置了Output的代理为self,也就是这里，这里就关联起来了。\n前面是这样的：\n```Swift\n let `output` = AVCaptureMetadataOutput()\n        self.output = output\n        output.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)\n                \n        //添加元数据输出流到会话对象 给新建的一个Output对象添加到session,session等下会给output赋值\n        session.addOutput(output)\n```\n就是因为这个self，当session开始running后，就会走协议的回调方法，在那里面我们间隔3.5才让它进行下次扫描，也是在这里面分析这个条码是否正常之类的。\n\n### 3.9 设置videoDataOuput代理\n\n这个代理，目的是为了识别光线强弱。\n```Swift\nextension GMBaseScanViewController: AVCaptureVideoDataOutputSampleBufferDelegate {\n    \n    func captureOutput(_ output: AVCaptureOutput, didOutput sampleBuffer: CMSampleBuffer, from connection: AVCaptureConnection) {\n        // 获取光照亮度\n        guard let metadataCFDict: CFDictionary = CMCopyDictionaryOfAttachments(allocator: nil, target: sampleBuffer, attachmentMode: 1) else { return }\n        guard let metadataDic: [String: AnyObject] = metadataCFDict as? [String: AnyObject] else { return }\n        guard let exifMetadata: [String: AnyObject] = metadataDic[kCGImagePropertyExifDictionary as String] as? [String : AnyObject] else { return }\n        guard let brightnessValue: CGFloat = exifMetadata[kCGImagePropertyExifBrightnessValue as String] as? CGFloat else { return }\n        // 根据光照亮度展示按钮\n        if brightnessValue < -1 {\n            torchButton.isHidden = false\n        } else {\n            guard let device = AVCaptureDevice.default(for: AVMediaType.video) else { return }\n            if device.hasTorch && device.isTorchAvailable {\n                try? device.lockForConfiguration()\n                torchButton.isHidden = !(device.torchMode == .on)\n                device.unlockForConfiguration()\n                \n            }\n        }\n        \n    }\n    \n    private func convert(cmage: CIImage) -> UIImage {\n         let context = CIContext(options: nil)\n         let cgImage = context.createCGImage(cmage, from: cmage.extent)!\n         let image = UIImage(cgImage: cgImage)\n         return image\n    }\n    \n}\n```\n在代理 captureOutput的回调方法中可以获取光线强弱信息。\n\n也是在初始化session的时候设置了这个代理。\n\n### 3.10 识别到后播放声音\n\n这里我们额外增加一个方法，主要给外面调用，因为我们会提供一个代理，如果识别到后，通过代理内部方法将识别的条码给外面。这时候外面要震动或声音效果，只需要调用我们内部的一个方法即可。\n\n```Swift\nfunc playAudio(success code: Int) {\n        if isPlay == false {\n            return\n        }\n        if code == 1 {\n            var soundID: SystemSoundID = 0\n            guard let path = Bundle.main.path(forResource: \"scanSuccess\", ofType: \"mp3\") else { return }\n            let url = URL(fileURLWithPath: path)\n            AudioServicesCreateSystemSoundID(url as CFURL, &soundID)\n            AudioServicesPlaySystemSound(soundID) //声音\n        } else {\n            var soundID: SystemSoundID = 0\n            guard let path = Bundle.main.path(forResource: \"scanFail\", ofType: \"mp3\") else { return }\n            let url = URL(fileURLWithPath: path)\n            AudioServicesCreateSystemSoundID(url as CFURL, &soundID)\n            AudioServicesPlayAlertSound(soundID) //震动+播放声音\n        }\n    }\n```\n也是非常简单，只需要先拿到声音路径，转换url，再通过AudioServicesCreateSystemSoundID包装一下，再通过AudioServicesPlaySystemSound来播放这个soundID即可。\n\n就这样，一个具有扫码能力的Controller就出来了哦。\n\n## 4 总结\n\n* 如果用到扫码，一定需要申请权限的，必须考虑到是否有权限，如果拒绝了权限，或其它原因导致没有权限，都需要考虑。\n\n* 扫码关键的几个类，AVCaptureSession控制数据流关键类；AVCaptureMetadataOutput接收流，代理方法来处理识别到条码后的逻辑；AVCaptureVideoDataOutput接收流，可以处理光线强弱；AVCaptureVideoPreviewLayer用来预览相机的视图层，可显示在UIView的layer上。\n\n* 一般扫码需要具备的二指缩放，光线太暗打开闪光灯，这些可以算作基本能能力，务必要实现，否则体验很不佳。\n\n* 合理控制识别到条码间隔时间，该停止session的时候务必停止，为了防止频繁识别到相同条码，可以设置间隔时间。\n\n* 可以先定义一个播放声音效果的方法，方便外部直接调用方法播放成功或者失败的声音。声音主要用到AudioServices相关方法。\n\n* 系统类大多都是提供了代理，暴露了一些方法主要都是定义好的方法，我们业务开发也只需要接收和处理这些定义好的类就可以了。\n","slug":"iOS-swift-如何实现扫码功能","published":1,"updated":"2023-02-01T07:17:16.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlhfhyo000bivv72lpy3cfc","content":"<h2 id=\"1-需求定义\"><a href=\"#1-需求定义\" class=\"headerlink\" title=\"1 需求定义\"></a>1 需求定义</h2><p>这里有个需求，就是继承扫码能力，可以识别到条形码里面的内容。<br>首先我们需要下载一个离线库，这个库里面会包含很多条码Code，相机通过识别到条码跟离线库中的匹配，如果匹配上了，会提示用户。所以首先我们肯定要有一个识别能力，数据库先不管，后面会有专门的文章来写数据库相关的东西。</p>\n<p>本篇文章主要是从0搭建一个可以识别条形码能力的Controller。<br>其它额外需求先忽略。</p>\n<p>目标就是完成这样的效果：<br><img src=scan1.png><br><img src=scan2.png></p>\n<h2 id=\"2-分析需求\"><a href=\"#2-分析需求\" class=\"headerlink\" title=\"2 分析需求\"></a>2 分析需求</h2><p>要具备扫码功能，肯定离不开相机，调用相机会设计到权限。<br>所以我们得考虑是否有相机权限。<br>其次，得考虑如何来识别条形码。<br>重复识别到的问题。<br>页面退出，相机资源怎么处理。<br>光线太暗了，是否需要打开手电筒。<br>条码太小，是否需要放大。<br>等等，这些事先都得考虑到。</p>\n<h2 id=\"3-打造页面\"><a href=\"#3-打造页面\" class=\"headerlink\" title=\"3 打造页面\"></a>3 打造页面</h2><h3 id=\"3-1-构建UI\"><a href=\"#3-1-构建UI\" class=\"headerlink\" title=\"3.1 构建UI\"></a>3.1 构建UI</h3><p>首先把材料上齐。</p>\n<pre><code class=\"line-numbers language-Swift\">lazy var squareImgView: UIImageView = &#123;\n        let imgv = UIImageView()\n        imgv.isUserInteractionEnabled = false\n        imgv.image = UIImage(named: &quot;扫码框&quot;)\n        return imgv\n    &#125;()\n    \n    lazy var torchButton: UIButton = &#123;\n        let temp = UIButton(type: .custom)\n        temp.setImage(UIImage(named: &quot;scan_torch&quot;), for: .normal)\n        temp.setTitle(&quot;轻触照亮&quot;, for: .normal)\n        temp.isHidden = true\n        temp.titleLabel?.font = UIFont.regular(15)\n        temp.ddy_SetStyle(.imgDown, padding: 10)\n        temp.addTarget(self, action: #selector(torchButtonClick), for: .touchUpInside)\n        return temp\n    &#125;()\n    \n    lazy var photoBtn: UIButton = &#123;\n        let btn = UIButton(type: .custom)\n        btn.setImage(UIImage(named: &quot;PhotoAlbum&quot;), for: .normal)\n        btn.addTarget(self, action: #selector(actionForPhoto), for: .touchUpInside)\n        return btn\n    &#125;()\n    \n    lazy var tipsLabel: UILabel = &#123;\n        let temp = UILabel()\n        temp.text = &quot;扫一扫条形码&quot;\n        temp.textColor = .white\n        temp.font = UIFont.regular(13)\n        temp.sizeToFit()\n        return temp\n    &#125;()\n    \n    lazy var commitButton: UIButton = &#123;\n        let btn: UIButton = UIButton(type: .custom)\n        btn.backgroundColor = UIColor(hex: &quot;#242424&quot;)\n        btn.clipsToBounds = true\n        btn.layer.cornerRadius = 22\n        btn.layer.borderWidth = 1\n        btn.layer.borderColor = UIColor.white.cgColor\n        btn.setTitle(&quot;扫描完成&quot;, for: .normal)\n        btn.addTarget(self, action: #selector(commitButtonClick), for: .touchUpInside)\n        return btn\n    &#125;()\n    \n    lazy var inputButton: UIButton = &#123;\n        let btn: UIButton = UIButton(type: .custom)\n        btn.backgroundColor = UIColor(hex: &quot;#242424&quot;)\n        btn.layer.borderColor = UIColor.white.cgColor\n        btn.setTitle(&quot;手动输入条形码&quot;, for: .normal)\n        btn.addTarget(self, action: #selector(actionForPushManuallyInput), for: .touchUpInside)\n        return btn\n    &#125;()\n\n    lazy var layerView: UIView = &#123;\n        let view = UIView(frame: CGRect(x: 0,\n                                        y: STATUS_BAR_HEIGHT + 44,\n                                        width: ScreenWidth,\n                                        height: ScreenHeight - STATUS_BAR_HEIGHT - 44 - 162))\n        return view\n    &#125;()\n</code></pre>\n<p>打开需要这几个View。</p>\n<h3 id=\"3-2-全局变量声明\"><a href=\"#3-2-全局变量声明\" class=\"headerlink\" title=\"3.2 全局变量声明\"></a>3.2 全局变量声明</h3><p>想要具备扫码能力，有几个类是必须的。</p>\n<pre><code class=\"line-numbers language-Swift\">// AVC 相关  相机硬件接口相关\n    private var videoDataOutput: AVCaptureVideoDataOutput?\n    private var output: AVCaptureMetadataOutput?\n    private var session: AVCaptureSession?\n    private var videoPreviewLayer: AVCaptureVideoPreviewLayer?\n</code></pre>\n<p>其它成员不着急，后续需要再加上去。</p>\n<h3 id=\"3-3-生命周期之loadView\"><a href=\"#3-3-生命周期之loadView\" class=\"headerlink\" title=\"3.3 生命周期之loadView\"></a>3.3 生命周期之loadView</h3><p>loadView执行时机为：访问视图控制器的view时候，如何view为nil，或者还没有加载完成就会调用loadView方法来创建view。可以理解成先于viewDidLoad，一般走一次，一般用于视图初始化。</p>\n<p>这里就负责 添加子View 的工作。</p>\n<pre><code class=\"line-numbers language-Swift\">private func setupUI() &#123;\n        view.addSubview(layerView)\n        view.addSubview(squareImgView)\n        view.addSubview(torchButton)\n        view.addSubview(tipsLabel)\n        view.addSubview(commitButton)\n        view.addSubview(inputButton)\n        view.addSubview(photoBtn)\n\n        squareImgView.snp.makeConstraints &#123; make in\n            make.size.equalTo(320)\n            make.centerX.equalToSuperview()\n            make.top.equalTo(STATUS_BAR_HEIGHT + 44 + 76)\n        &#125;\n        \n        torchButton.snp.makeConstraints &#123; make in\n            make.centerX.equalToSuperview()\n            make.bottom.equalTo(squareImgView.snp.bottom).offset(20)\n            make.width.equalTo(320)\n            make.height.equalTo(200)\n        &#125;\n        \n        tipsLabel.snp.makeConstraints &#123; make in\n            make.centerX.equalToSuperview()\n            make.top.equalTo(squareImgView.snp.bottom).offset(12)\n        &#125;\n        \n        commitButton.snp.makeConstraints &#123; make in\n            make.top.equalTo(layerView.snp.bottom).offset(42)\n            make.leading.equalTo(102)\n            make.trailing.equalTo(-102)\n            make.height.equalTo(44)\n        &#125;\n        \n        inputButton.snp.makeConstraints&#123; make in\n            make.top.equalTo(commitButton.snp.bottom).offset(12)\n            make.left.equalTo(commitButton)\n            make.right.equalTo(commitButton)\n            make.height.equalTo(36)\n        &#125;\n        \n        photoBtn.snp.makeConstraints&#123; make in\n            make.centerY.equalTo(commitButton)\n            make.leading.equalTo(16)\n            make.width.height.equalTo(44)\n        &#125;\n    &#125;\n</code></pre>\n<p>可以看到，这里把架子搭上去了。</p>\n<h3 id=\"3-4-生命周期之-viewDidLoad\"><a href=\"#3-4-生命周期之-viewDidLoad\" class=\"headerlink\" title=\"3.4 生命周期之 viewDidLoad\"></a>3.4 生命周期之 viewDidLoad</h3><p>看下这里做了什么：</p>\n<pre><code class=\"line-numbers language-Swift\"> override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        // 标题文字大小\n        navigationController?.navigationBar.navBarBackGroundColor(.black, image: UIImage(), isOpaque: false)\n        navigationController?.navigationBar.titleTextAttributes = [NSAttributedString.Key.foregroundColor:UIColor.white, NSAttributedString.Key.font : UIFont.pingFangMedium(size: 18)]\n        \n        // 背景黑色\n        view.backgroundColor = UIColor(hex: &quot;#242424&quot;)\n\n        // 添加手势，用来实现二指缩放效果\n        addGesture()\n        \n        // 监听全局通知\n        addNotification()\n        \n        // 自己定义的协议，去加载历史数据\n        delegate?.loadHistoryData()\n        \n        // 手动输入条码闭包回调\n        manuallyInputViewController.inputBlock = &#123; [unowned self] (_, code) in\n            self.delegate?.manuallyInput(code.replaceFlag)\n        &#125;\n    &#125;\n</code></pre>\n<p>如何添加手势呢？</p>\n<pre><code class=\"line-numbers language-Swift\">private func addGesture() &#123;\n        let prinGesture = UIPinchGestureRecognizer(target: self, action: #selector(pinch(gesture:)))\n        layerView.addGestureRecognizer(prinGesture)\n    &#125;\n</code></pre>\n<p>操作后会触发：</p>\n<pre><code class=\"line-numbers language-Swift\">@objc func pinch(gesture: UIPinchGestureRecognizer) &#123;\n        guard let device = AVCaptureDevice.default(for: AVMediaType.video) else &#123;\n            print(&quot;get front video AVCaptureDeviceInput  failed!&quot;)\n            return\n        &#125;\n        var minZoomFactor = 1.0\n        var maxZoomFactor = device.activeFormat.videoMaxZoomFactor\n        \n        if #available(iOS 11.0,*) &#123;\n            minZoomFactor = device.minAvailableVideoZoomFactor\n            maxZoomFactor = device.maxAvailableVideoZoomFactor\n        &#125;\n        \n        if gesture.state == .began &#123;\n            lastZoomFactor = device.videoZoomFactor\n            print(&quot;缩放比例  \\(device.videoZoomFactor)&quot;)\n            \n        &#125; else if gesture.state == .changed&#123;\n            var zoomFactor: Float = Float(lastZoomFactor * gesture.scale);\n            zoomFactor = fmaxf(fminf(zoomFactor, Float(maxZoomFactor)), Float(minZoomFactor))\n            print(&quot;缩放比例  \\(zoomFactor)&quot;)\n            try? device.lockForConfiguration()\n            device.videoZoomFactor = CGFloat(zoomFactor)\n            device.unlockForConfiguration()\n        &#125; else if gesture.state == .ended &#123;\n            print(&quot;最终缩放比例  \\(device.videoZoomFactor)&quot;)\n        &#125;\n    &#125;\n</code></pre>\n<p>其它的没啥了。</p>\n<h3 id=\"3-5-生命周期之viewWillAppear\"><a href=\"#3-5-生命周期之viewWillAppear\" class=\"headerlink\" title=\"3.5 生命周期之viewWillAppear\"></a>3.5 生命周期之viewWillAppear</h3><p>这个是将要显示，一般做轻量级操作。</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewWillAppear(_ animated: Bool) &#123;\n        super.viewWillAppear(animated)\n        setupRealWhiteClickCallBack()\n        setupBlackNavWhiteTitleBarColor()\n        isHiddenNavBar(isHidden: false)\n    &#125;\n</code></pre>\n<p>主要实现了状态栏和标题栏相关的。</p>\n<h3 id=\"3-6-生命周期之viewDidAppear\"><a href=\"#3-6-生命周期之viewDidAppear\" class=\"headerlink\" title=\"3.6 生命周期之viewDidAppear\"></a>3.6 生命周期之viewDidAppear</h3><p>这里是已经显示了，这里可以做稍微重量级代码。</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidAppear(_ animated: Bool) &#123;\n        super.viewDidAppear(animated)\n        if self.session == nil &#123;\n            self.scanQRCodePermission()\n        &#125; else &#123;\n            self.startScan()\n        &#125;\n        UIApplication.shared.isIdleTimerDisabled = true\n        setNeedsStatusBarAppearanceUpdate()\n    &#125;\n</code></pre>\n<p>很明显这里判断了下session是否为null。</p>\n<p>如果session为nil，则先判断是否有相机权限：</p>\n<pre><code class=\"line-numbers language-Swift\">func scanQRCodePermission() &#123;\n        // 判断摄像头是否可用\n        let available = UIImagePickerController.isSourceTypeAvailable(.camera)\n        if available &#123;\n            \n            // 判断是否有相机权限\n            let authStatus: AVAuthorizationStatus = AVCaptureDevice.authorizationStatus(for: AVMediaType.video)\n            if authStatus == .restricted &#123;\n                let alerVC: UIAlertController = .init(title: &quot;提示&quot;, message: &quot;由于系统原因, 无法访问相机&quot;, preferredStyle: UIAlertController.Style.alert)\n                alerVC.addAction(UIAlertAction.init(title: &quot;确定&quot;, style: .destructive) &#123; (action) in\n                    UIApplication.shared.open(NSURL(string: UIApplication.openSettingsURLString)! as URL, options: [:] ) &#123; (success) in\n                    &#125;\n                &#125;)\n                present(alerVC, animated: true, completion: nil)\n            &#125; else if authStatus == .denied &#123;\n                let dic = Bundle.main.infoDictionary\n                var appName = dic?[&quot;CFBundleDisplayName&quot;]\n                if appName == nil&#123;\n                    appName = dic?[&quot;CFBundleName&quot;]\n                &#125;\n                let str = String.localizedStringWithFormat(&quot;[前往：设置 - 隐私 - 相机 - %@] 允许应用访问&quot;, appName as! String)\n                let alerVC = UIAlertController(title: &quot;提示&quot;, message: str, preferredStyle: .alert)\n                alerVC.addAction(UIAlertAction(title: &quot;确定&quot;, style: UIAlertAction.Style.destructive) &#123; (action) in\n                    UIApplication.shared.open(NSURL(string: UIApplication.openSettingsURLString)! as URL, options: [:] ) &#123; (success) in\n                    &#125;\n                &#125;)\n                present(alerVC, animated: true, completion: nil)\n            &#125; else if authStatus == .notDetermined &#123;\n                //用户未作出选择，申请权限 AVC直接requestAccess\n                AVCaptureDevice.requestAccess(for: AVMediaType.video)&#123;\n                    granted in\n                    DispatchQueue.main.async &#123;\n                        if granted &#123;\n                            //初次授权成功\n                            self.initCaptureSession()\n                        &#125; else &#123;\n                            //拒绝授权\n                        &#125;\n                    &#125;\n                &#125;\n            &#125; else &#123;\n                //已授权\n                self.initCaptureSession()\n            &#125;\n        &#125; else &#123;\n            //摄像头可能已损坏\n        &#125;\n    &#125;\n</code></pre>\n<p>上面的代码讲述了如何申请权限，权限被拒绝如何跳转设置。</p>\n<p>如果有权限了会走 initCaptureSession 来初始化session:</p>\n<pre><code class=\"line-numbers language-Swift\">func initCaptureSession() &#123;\n        //创建会话对象\n        let `session` = AVCaptureSession()\n        self.session = session\n        session.sessionPreset = .high\n        \n        //获取设想设备\n        guard let device = AVCaptureDevice.default(for: AVMediaType.video) else &#123;\n            print(&quot;get front video AVCaptureDeviceInput  failed!&quot;)\n            return\n        &#125;\n        \n        //创建设想设备输入流\n        guard let input = try? AVCaptureDeviceInput(device: device) else &#123;\n            print(&quot;get front video AVCaptureDeviceInput  failed!&quot;)\n            return\n        &#125;\n        \n        //添加设想设备输入流到会话对象 输入流让session来分析\n        if session.canAddInput(input) &#123;\n            session.addInput(input)\n        &#125;\n        \n        //创建元数据输出流\n        let `output` = AVCaptureMetadataOutput()\n        self.output = output\n        output.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)\n                \n        //添加元数据输出流到会话对象 给新建的一个Output对象添加到session,session等下会给output赋值\n        session.addOutput(output)\n        \n        //创建摄像数据输出流并将其添加到会话对象上-----&gt;用户识别光线强弱\n        let `videoDataOutput` = AVCaptureVideoDataOutput()\n        self.videoDataOutput = videoDataOutput\n        videoDataOutput.setSampleBufferDelegate(self, queue: DispatchQueue.main)\n        session.addOutput(videoDataOutput)\n        \n        //设置数据输出类型(如下设置为条形码和二维码兼容)，需要将数据输出添加到会话后，才能指定元数据类型，否则会报错\n        \n        /*\n         \n         android\n         \n         Barcode.FORMAT_CODE_128,   *\n         Barcode.FORMAT_CODE_39,    *\n         Barcode.FORMAT_CODE_93,    *\n         Barcode.FORMAT_CODABAR,    ios 15.4 +\n         Barcode.FORMAT_EAN_13,     *\n         Barcode.FORMAT_EAN_8,      *\n         Barcode.FORMAT_UPC_A,      x\n         Barcode.FORMAT_UPC_E,      *\n         Barcode.TYPE_ISBN          x\n         */\n        output.metadataObjectTypes = [.code39,\n                                      .code39Mod43,\n                                      .code93,\n                                      .code128,\n                                      .ean8,\n                                      .ean13,\n                                      .upce,\n                                      .pdf417] //itf14\n        //实例化预览图层, 用于显示会话对象 session放到这里面，然后通过layer插入sublayer可以实现预览效果\n        let `videoPreviewLayer` = AVCaptureVideoPreviewLayer(session: session)\n        self.videoPreviewLayer = videoPreviewLayer\n        videoPreviewLayer.videoGravity = .resizeAspectFill\n        videoPreviewLayer.frame = layerView.bounds\n        layerView.layer.insertSublayer(videoPreviewLayer, at: 0)\n        \n        // session开始run\n        startScan()\n    &#125;\n</code></pre>\n<p>回到 生命周期 中，如果 session 不为空，会走上面的startScan 函数，这里就是让session继续工作的意思：</p>\n<pre><code class=\"line-numbers language-Swift\">func startScan() &#123;\n        session?.startRunning()\n    &#125;\n</code></pre>\n<p>在viewDidAppear中还做了什么呢？</p>\n<pre><code class=\"line-numbers language-Swift\">UIApplication.shared.isIdleTimerDisabled = true\nsetNeedsStatusBarAppearanceUpdate()\n</code></pre>\n<p>第一行：禁止该页面进入睡眠；<br>第二行：如果在viewController已经显示在当前页面，你可能还要在当前页面不时的更改statusBar的前景色，那么，你首先需要调用下面的setNeedsStatusBarAppearanceUpdate方法(这个方法会通知系统去调用当前UIViewController的preferredStatusBarStyle方法)，从而改变statusBar的statusBarStyle。</p>\n<h3 id=\"3-7-生命周期之viewDidDisappear\"><a href=\"#3-7-生命周期之viewDidDisappear\" class=\"headerlink\" title=\"3.7 生命周期之viewDidDisappear\"></a>3.7 生命周期之viewDidDisappear</h3><pre><code class=\"line-numbers language-Swift\"> override func viewDidDisappear(_ animated: Bool) &#123;\n        super.viewDidDisappear(animated)\n        stopScan()\n        UIApplication.shared.isIdleTimerDisabled = false\n        setNeedsStatusBarAppearanceUpdate()\n    &#125;\n</code></pre>\n<p>这里停止扫描，应该是停止session:</p>\n<pre><code class=\"line-numbers language-Swift\">func stopScan() &#123;\n        session?.stopRunning()\n    &#125;\n</code></pre>\n<p>其它上面讲过，不必多言了。</p>\n<h3 id=\"3-8-设置output代理\"><a href=\"#3-8-设置output代理\" class=\"headerlink\" title=\"3.8 设置output代理\"></a>3.8 设置output代理</h3><p>回到初始化session的部分代码中：</p>\n<pre><code class=\"line-numbers language-Swift\">//创建元数据输出流\nlet `output` = AVCaptureMetadataOutput()\nself.output = output\noutput.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)\n</code></pre>\n<p>这里设置了一个metadata的代理，所以这个controller必然扩展了这个代理。</p>\n<p>具体如下：</p>\n<pre><code class=\"line-numbers language-Swift\">extension GMBaseScanViewController: AVCaptureMetadataOutputObjectsDelegate &#123;\n    func metadataOutput(_ output: AVCaptureMetadataOutput, didOutput metadataObjects: [AVMetadataObject], from connection: AVCaptureConnection) &#123;\n        if isCanScan &#123;\n            let isAchieve: Bool = metadataObjects.count == 1\n            if isAchieve &#123;\n                // 扫到条码\n                guard let device = AVCaptureDevice.default(for: AVMediaType.video) else &#123; return &#125;\n                guard let codeObj = metadataObjects.last as? AVMetadataMachineReadableCodeObject else &#123; return &#125;\n                print(&quot;扫到了条码 codeObj  ：  \\(codeObj)&quot;)\n                guard let str = codeObj.stringValue else &#123; return &#125;\n                self.isCanScan = false\n                print(&quot;扫到了条码 str：  \\(str)&quot;)\n                DispatchQueue.main.asyncAfter(deadline: .now() + scanInterval) &#123;\n                    try? device.lockForConfiguration()\n                    device.videoZoomFactor = 1\n                    device.unlockForConfiguration()\n                    self.isCanScan = true\n                &#125;\n                let barCode = barcodeProcessing(str)\n                delegate?.scanBarcode(barCode)\n            &#125; else &#123;\n                MBProgressHUD.showTipsMessage(&quot;无法识别&quot;)\n            &#125;\n        &#125;\n    &#125;\n    \n    func barcodeProcessing(_ code: String) -&gt; String &#123;\n        var codeStr: String = code.mutableCopy() as! String\n        var newStr = code.uppercased()\n        var index = 0\n        newStr = newStr.replacingOccurrences(of: &quot; &quot;, with: &quot;&quot;, options: .literal, range: nil)\n        codeStr = codeStr.replacingOccurrences(of: &quot; &quot;, with: &quot;&quot;, options: .literal, range: nil)\n        if newStr.hasPrefix(&quot;GREE&quot;) &#123;\n            index = 3\n        &#125; else if newStr.hasPrefix(&quot;KINGHOME&quot;) &#123;\n            index = 7\n        &#125; else if newStr.hasPrefix(&quot;TOSOT&quot;) &#123;\n            index = 4\n        &#125;\n        if index != 0 &#123;\n            let start = codeStr.index(codeStr.startIndex, offsetBy: 0)\n            let end = codeStr.index(codeStr.startIndex, offsetBy: index)\n            codeStr.removeSubrange(start...end)\n        &#125;\n        return codeStr\n    &#125;\n&#125;\n</code></pre>\n<p>这里覆写了这协议方法，表示识别到内容了。然后会回调metadateOutput，原因是前面session里面设置了Output的代理为self,也就是这里，这里就关联起来了。<br>前面是这样的：</p>\n<pre><code class=\"line-numbers language-Swift\"> let `output` = AVCaptureMetadataOutput()\n        self.output = output\n        output.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)\n                \n        //添加元数据输出流到会话对象 给新建的一个Output对象添加到session,session等下会给output赋值\n        session.addOutput(output)\n</code></pre>\n<p>就是因为这个self，当session开始running后，就会走协议的回调方法，在那里面我们间隔3.5才让它进行下次扫描，也是在这里面分析这个条码是否正常之类的。</p>\n<h3 id=\"3-9-设置videoDataOuput代理\"><a href=\"#3-9-设置videoDataOuput代理\" class=\"headerlink\" title=\"3.9 设置videoDataOuput代理\"></a>3.9 设置videoDataOuput代理</h3><p>这个代理，目的是为了识别光线强弱。</p>\n<pre><code class=\"line-numbers language-Swift\">extension GMBaseScanViewController: AVCaptureVideoDataOutputSampleBufferDelegate &#123;\n    \n    func captureOutput(_ output: AVCaptureOutput, didOutput sampleBuffer: CMSampleBuffer, from connection: AVCaptureConnection) &#123;\n        // 获取光照亮度\n        guard let metadataCFDict: CFDictionary = CMCopyDictionaryOfAttachments(allocator: nil, target: sampleBuffer, attachmentMode: 1) else &#123; return &#125;\n        guard let metadataDic: [String: AnyObject] = metadataCFDict as? [String: AnyObject] else &#123; return &#125;\n        guard let exifMetadata: [String: AnyObject] = metadataDic[kCGImagePropertyExifDictionary as String] as? [String : AnyObject] else &#123; return &#125;\n        guard let brightnessValue: CGFloat = exifMetadata[kCGImagePropertyExifBrightnessValue as String] as? CGFloat else &#123; return &#125;\n        // 根据光照亮度展示按钮\n        if brightnessValue &lt; -1 &#123;\n            torchButton.isHidden = false\n        &#125; else &#123;\n            guard let device = AVCaptureDevice.default(for: AVMediaType.video) else &#123; return &#125;\n            if device.hasTorch &amp;&amp; device.isTorchAvailable &#123;\n                try? device.lockForConfiguration()\n                torchButton.isHidden = !(device.torchMode == .on)\n                device.unlockForConfiguration()\n                \n            &#125;\n        &#125;\n        \n    &#125;\n    \n    private func convert(cmage: CIImage) -&gt; UIImage &#123;\n         let context = CIContext(options: nil)\n         let cgImage = context.createCGImage(cmage, from: cmage.extent)!\n         let image = UIImage(cgImage: cgImage)\n         return image\n    &#125;\n    \n&#125;\n</code></pre>\n<p>在代理 captureOutput的回调方法中可以获取光线强弱信息。</p>\n<p>也是在初始化session的时候设置了这个代理。</p>\n<h3 id=\"3-10-识别到后播放声音\"><a href=\"#3-10-识别到后播放声音\" class=\"headerlink\" title=\"3.10 识别到后播放声音\"></a>3.10 识别到后播放声音</h3><p>这里我们额外增加一个方法，主要给外面调用，因为我们会提供一个代理，如果识别到后，通过代理内部方法将识别的条码给外面。这时候外面要震动或声音效果，只需要调用我们内部的一个方法即可。</p>\n<pre><code class=\"line-numbers language-Swift\">func playAudio(success code: Int) &#123;\n        if isPlay == false &#123;\n            return\n        &#125;\n        if code == 1 &#123;\n            var soundID: SystemSoundID = 0\n            guard let path = Bundle.main.path(forResource: &quot;scanSuccess&quot;, ofType: &quot;mp3&quot;) else &#123; return &#125;\n            let url = URL(fileURLWithPath: path)\n            AudioServicesCreateSystemSoundID(url as CFURL, &amp;soundID)\n            AudioServicesPlaySystemSound(soundID) //声音\n        &#125; else &#123;\n            var soundID: SystemSoundID = 0\n            guard let path = Bundle.main.path(forResource: &quot;scanFail&quot;, ofType: &quot;mp3&quot;) else &#123; return &#125;\n            let url = URL(fileURLWithPath: path)\n            AudioServicesCreateSystemSoundID(url as CFURL, &amp;soundID)\n            AudioServicesPlayAlertSound(soundID) //震动+播放声音\n        &#125;\n    &#125;\n</code></pre>\n<p>也是非常简单，只需要先拿到声音路径，转换url，再通过AudioServicesCreateSystemSoundID包装一下，再通过AudioServicesPlaySystemSound来播放这个soundID即可。</p>\n<p>就这样，一个具有扫码能力的Controller就出来了哦。</p>\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4 总结\"></a>4 总结</h2><ul>\n<li><p>如果用到扫码，一定需要申请权限的，必须考虑到是否有权限，如果拒绝了权限，或其它原因导致没有权限，都需要考虑。</p>\n</li>\n<li><p>扫码关键的几个类，AVCaptureSession控制数据流关键类；AVCaptureMetadataOutput接收流，代理方法来处理识别到条码后的逻辑；AVCaptureVideoDataOutput接收流，可以处理光线强弱；AVCaptureVideoPreviewLayer用来预览相机的视图层，可显示在UIView的layer上。</p>\n</li>\n<li><p>一般扫码需要具备的二指缩放，光线太暗打开闪光灯，这些可以算作基本能能力，务必要实现，否则体验很不佳。</p>\n</li>\n<li><p>合理控制识别到条码间隔时间，该停止session的时候务必停止，为了防止频繁识别到相同条码，可以设置间隔时间。</p>\n</li>\n<li><p>可以先定义一个播放声音效果的方法，方便外部直接调用方法播放成功或者失败的声音。声音主要用到AudioServices相关方法。</p>\n</li>\n<li><p>系统类大多都是提供了代理，暴露了一些方法主要都是定义好的方法，我们业务开发也只需要接收和处理这些定义好的类就可以了。</p>\n</li>\n</ul>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-需求定义\"><a href=\"#1-需求定义\" class=\"headerlink\" title=\"1 需求定义\"></a>1 需求定义</h2><p>这里有个需求，就是继承扫码能力，可以识别到条形码里面的内容。<br>首先我们需要下载一个离线库，这个库里面会包含很多条码Code，相机通过识别到条码跟离线库中的匹配，如果匹配上了，会提示用户。所以首先我们肯定要有一个识别能力，数据库先不管，后面会有专门的文章来写数据库相关的东西。</p>\n<p>本篇文章主要是从0搭建一个可以识别条形码能力的Controller。<br>其它额外需求先忽略。</p>\n<p>目标就是完成这样的效果：<br><img src=scan1.png><br><img src=scan2.png></p>\n<h2 id=\"2-分析需求\"><a href=\"#2-分析需求\" class=\"headerlink\" title=\"2 分析需求\"></a>2 分析需求</h2><p>要具备扫码功能，肯定离不开相机，调用相机会设计到权限。<br>所以我们得考虑是否有相机权限。<br>其次，得考虑如何来识别条形码。<br>重复识别到的问题。<br>页面退出，相机资源怎么处理。<br>光线太暗了，是否需要打开手电筒。<br>条码太小，是否需要放大。<br>等等，这些事先都得考虑到。</p>\n<h2 id=\"3-打造页面\"><a href=\"#3-打造页面\" class=\"headerlink\" title=\"3 打造页面\"></a>3 打造页面</h2><h3 id=\"3-1-构建UI\"><a href=\"#3-1-构建UI\" class=\"headerlink\" title=\"3.1 构建UI\"></a>3.1 构建UI</h3><p>首先把材料上齐。</p>\n<pre><code class=\"line-numbers language-Swift\">lazy var squareImgView: UIImageView = &#123;\n        let imgv = UIImageView()\n        imgv.isUserInteractionEnabled = false\n        imgv.image = UIImage(named: &quot;扫码框&quot;)\n        return imgv\n    &#125;()\n    \n    lazy var torchButton: UIButton = &#123;\n        let temp = UIButton(type: .custom)\n        temp.setImage(UIImage(named: &quot;scan_torch&quot;), for: .normal)\n        temp.setTitle(&quot;轻触照亮&quot;, for: .normal)\n        temp.isHidden = true\n        temp.titleLabel?.font = UIFont.regular(15)\n        temp.ddy_SetStyle(.imgDown, padding: 10)\n        temp.addTarget(self, action: #selector(torchButtonClick), for: .touchUpInside)\n        return temp\n    &#125;()\n    \n    lazy var photoBtn: UIButton = &#123;\n        let btn = UIButton(type: .custom)\n        btn.setImage(UIImage(named: &quot;PhotoAlbum&quot;), for: .normal)\n        btn.addTarget(self, action: #selector(actionForPhoto), for: .touchUpInside)\n        return btn\n    &#125;()\n    \n    lazy var tipsLabel: UILabel = &#123;\n        let temp = UILabel()\n        temp.text = &quot;扫一扫条形码&quot;\n        temp.textColor = .white\n        temp.font = UIFont.regular(13)\n        temp.sizeToFit()\n        return temp\n    &#125;()\n    \n    lazy var commitButton: UIButton = &#123;\n        let btn: UIButton = UIButton(type: .custom)\n        btn.backgroundColor = UIColor(hex: &quot;#242424&quot;)\n        btn.clipsToBounds = true\n        btn.layer.cornerRadius = 22\n        btn.layer.borderWidth = 1\n        btn.layer.borderColor = UIColor.white.cgColor\n        btn.setTitle(&quot;扫描完成&quot;, for: .normal)\n        btn.addTarget(self, action: #selector(commitButtonClick), for: .touchUpInside)\n        return btn\n    &#125;()\n    \n    lazy var inputButton: UIButton = &#123;\n        let btn: UIButton = UIButton(type: .custom)\n        btn.backgroundColor = UIColor(hex: &quot;#242424&quot;)\n        btn.layer.borderColor = UIColor.white.cgColor\n        btn.setTitle(&quot;手动输入条形码&quot;, for: .normal)\n        btn.addTarget(self, action: #selector(actionForPushManuallyInput), for: .touchUpInside)\n        return btn\n    &#125;()\n\n    lazy var layerView: UIView = &#123;\n        let view = UIView(frame: CGRect(x: 0,\n                                        y: STATUS_BAR_HEIGHT + 44,\n                                        width: ScreenWidth,\n                                        height: ScreenHeight - STATUS_BAR_HEIGHT - 44 - 162))\n        return view\n    &#125;()\n</code></pre>\n<p>打开需要这几个View。</p>\n<h3 id=\"3-2-全局变量声明\"><a href=\"#3-2-全局变量声明\" class=\"headerlink\" title=\"3.2 全局变量声明\"></a>3.2 全局变量声明</h3><p>想要具备扫码能力，有几个类是必须的。</p>\n<pre><code class=\"line-numbers language-Swift\">// AVC 相关  相机硬件接口相关\n    private var videoDataOutput: AVCaptureVideoDataOutput?\n    private var output: AVCaptureMetadataOutput?\n    private var session: AVCaptureSession?\n    private var videoPreviewLayer: AVCaptureVideoPreviewLayer?\n</code></pre>\n<p>其它成员不着急，后续需要再加上去。</p>\n<h3 id=\"3-3-生命周期之loadView\"><a href=\"#3-3-生命周期之loadView\" class=\"headerlink\" title=\"3.3 生命周期之loadView\"></a>3.3 生命周期之loadView</h3><p>loadView执行时机为：访问视图控制器的view时候，如何view为nil，或者还没有加载完成就会调用loadView方法来创建view。可以理解成先于viewDidLoad，一般走一次，一般用于视图初始化。</p>\n<p>这里就负责 添加子View 的工作。</p>\n<pre><code class=\"line-numbers language-Swift\">private func setupUI() &#123;\n        view.addSubview(layerView)\n        view.addSubview(squareImgView)\n        view.addSubview(torchButton)\n        view.addSubview(tipsLabel)\n        view.addSubview(commitButton)\n        view.addSubview(inputButton)\n        view.addSubview(photoBtn)\n\n        squareImgView.snp.makeConstraints &#123; make in\n            make.size.equalTo(320)\n            make.centerX.equalToSuperview()\n            make.top.equalTo(STATUS_BAR_HEIGHT + 44 + 76)\n        &#125;\n        \n        torchButton.snp.makeConstraints &#123; make in\n            make.centerX.equalToSuperview()\n            make.bottom.equalTo(squareImgView.snp.bottom).offset(20)\n            make.width.equalTo(320)\n            make.height.equalTo(200)\n        &#125;\n        \n        tipsLabel.snp.makeConstraints &#123; make in\n            make.centerX.equalToSuperview()\n            make.top.equalTo(squareImgView.snp.bottom).offset(12)\n        &#125;\n        \n        commitButton.snp.makeConstraints &#123; make in\n            make.top.equalTo(layerView.snp.bottom).offset(42)\n            make.leading.equalTo(102)\n            make.trailing.equalTo(-102)\n            make.height.equalTo(44)\n        &#125;\n        \n        inputButton.snp.makeConstraints&#123; make in\n            make.top.equalTo(commitButton.snp.bottom).offset(12)\n            make.left.equalTo(commitButton)\n            make.right.equalTo(commitButton)\n            make.height.equalTo(36)\n        &#125;\n        \n        photoBtn.snp.makeConstraints&#123; make in\n            make.centerY.equalTo(commitButton)\n            make.leading.equalTo(16)\n            make.width.height.equalTo(44)\n        &#125;\n    &#125;\n</code></pre>\n<p>可以看到，这里把架子搭上去了。</p>\n<h3 id=\"3-4-生命周期之-viewDidLoad\"><a href=\"#3-4-生命周期之-viewDidLoad\" class=\"headerlink\" title=\"3.4 生命周期之 viewDidLoad\"></a>3.4 生命周期之 viewDidLoad</h3><p>看下这里做了什么：</p>\n<pre><code class=\"line-numbers language-Swift\"> override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        // 标题文字大小\n        navigationController?.navigationBar.navBarBackGroundColor(.black, image: UIImage(), isOpaque: false)\n        navigationController?.navigationBar.titleTextAttributes = [NSAttributedString.Key.foregroundColor:UIColor.white, NSAttributedString.Key.font : UIFont.pingFangMedium(size: 18)]\n        \n        // 背景黑色\n        view.backgroundColor = UIColor(hex: &quot;#242424&quot;)\n\n        // 添加手势，用来实现二指缩放效果\n        addGesture()\n        \n        // 监听全局通知\n        addNotification()\n        \n        // 自己定义的协议，去加载历史数据\n        delegate?.loadHistoryData()\n        \n        // 手动输入条码闭包回调\n        manuallyInputViewController.inputBlock = &#123; [unowned self] (_, code) in\n            self.delegate?.manuallyInput(code.replaceFlag)\n        &#125;\n    &#125;\n</code></pre>\n<p>如何添加手势呢？</p>\n<pre><code class=\"line-numbers language-Swift\">private func addGesture() &#123;\n        let prinGesture = UIPinchGestureRecognizer(target: self, action: #selector(pinch(gesture:)))\n        layerView.addGestureRecognizer(prinGesture)\n    &#125;\n</code></pre>\n<p>操作后会触发：</p>\n<pre><code class=\"line-numbers language-Swift\">@objc func pinch(gesture: UIPinchGestureRecognizer) &#123;\n        guard let device = AVCaptureDevice.default(for: AVMediaType.video) else &#123;\n            print(&quot;get front video AVCaptureDeviceInput  failed!&quot;)\n            return\n        &#125;\n        var minZoomFactor = 1.0\n        var maxZoomFactor = device.activeFormat.videoMaxZoomFactor\n        \n        if #available(iOS 11.0,*) &#123;\n            minZoomFactor = device.minAvailableVideoZoomFactor\n            maxZoomFactor = device.maxAvailableVideoZoomFactor\n        &#125;\n        \n        if gesture.state == .began &#123;\n            lastZoomFactor = device.videoZoomFactor\n            print(&quot;缩放比例  \\(device.videoZoomFactor)&quot;)\n            \n        &#125; else if gesture.state == .changed&#123;\n            var zoomFactor: Float = Float(lastZoomFactor * gesture.scale);\n            zoomFactor = fmaxf(fminf(zoomFactor, Float(maxZoomFactor)), Float(minZoomFactor))\n            print(&quot;缩放比例  \\(zoomFactor)&quot;)\n            try? device.lockForConfiguration()\n            device.videoZoomFactor = CGFloat(zoomFactor)\n            device.unlockForConfiguration()\n        &#125; else if gesture.state == .ended &#123;\n            print(&quot;最终缩放比例  \\(device.videoZoomFactor)&quot;)\n        &#125;\n    &#125;\n</code></pre>\n<p>其它的没啥了。</p>\n<h3 id=\"3-5-生命周期之viewWillAppear\"><a href=\"#3-5-生命周期之viewWillAppear\" class=\"headerlink\" title=\"3.5 生命周期之viewWillAppear\"></a>3.5 生命周期之viewWillAppear</h3><p>这个是将要显示，一般做轻量级操作。</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewWillAppear(_ animated: Bool) &#123;\n        super.viewWillAppear(animated)\n        setupRealWhiteClickCallBack()\n        setupBlackNavWhiteTitleBarColor()\n        isHiddenNavBar(isHidden: false)\n    &#125;\n</code></pre>\n<p>主要实现了状态栏和标题栏相关的。</p>\n<h3 id=\"3-6-生命周期之viewDidAppear\"><a href=\"#3-6-生命周期之viewDidAppear\" class=\"headerlink\" title=\"3.6 生命周期之viewDidAppear\"></a>3.6 生命周期之viewDidAppear</h3><p>这里是已经显示了，这里可以做稍微重量级代码。</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidAppear(_ animated: Bool) &#123;\n        super.viewDidAppear(animated)\n        if self.session == nil &#123;\n            self.scanQRCodePermission()\n        &#125; else &#123;\n            self.startScan()\n        &#125;\n        UIApplication.shared.isIdleTimerDisabled = true\n        setNeedsStatusBarAppearanceUpdate()\n    &#125;\n</code></pre>\n<p>很明显这里判断了下session是否为null。</p>\n<p>如果session为nil，则先判断是否有相机权限：</p>\n<pre><code class=\"line-numbers language-Swift\">func scanQRCodePermission() &#123;\n        // 判断摄像头是否可用\n        let available = UIImagePickerController.isSourceTypeAvailable(.camera)\n        if available &#123;\n            \n            // 判断是否有相机权限\n            let authStatus: AVAuthorizationStatus = AVCaptureDevice.authorizationStatus(for: AVMediaType.video)\n            if authStatus == .restricted &#123;\n                let alerVC: UIAlertController = .init(title: &quot;提示&quot;, message: &quot;由于系统原因, 无法访问相机&quot;, preferredStyle: UIAlertController.Style.alert)\n                alerVC.addAction(UIAlertAction.init(title: &quot;确定&quot;, style: .destructive) &#123; (action) in\n                    UIApplication.shared.open(NSURL(string: UIApplication.openSettingsURLString)! as URL, options: [:] ) &#123; (success) in\n                    &#125;\n                &#125;)\n                present(alerVC, animated: true, completion: nil)\n            &#125; else if authStatus == .denied &#123;\n                let dic = Bundle.main.infoDictionary\n                var appName = dic?[&quot;CFBundleDisplayName&quot;]\n                if appName == nil&#123;\n                    appName = dic?[&quot;CFBundleName&quot;]\n                &#125;\n                let str = String.localizedStringWithFormat(&quot;[前往：设置 - 隐私 - 相机 - %@] 允许应用访问&quot;, appName as! String)\n                let alerVC = UIAlertController(title: &quot;提示&quot;, message: str, preferredStyle: .alert)\n                alerVC.addAction(UIAlertAction(title: &quot;确定&quot;, style: UIAlertAction.Style.destructive) &#123; (action) in\n                    UIApplication.shared.open(NSURL(string: UIApplication.openSettingsURLString)! as URL, options: [:] ) &#123; (success) in\n                    &#125;\n                &#125;)\n                present(alerVC, animated: true, completion: nil)\n            &#125; else if authStatus == .notDetermined &#123;\n                //用户未作出选择，申请权限 AVC直接requestAccess\n                AVCaptureDevice.requestAccess(for: AVMediaType.video)&#123;\n                    granted in\n                    DispatchQueue.main.async &#123;\n                        if granted &#123;\n                            //初次授权成功\n                            self.initCaptureSession()\n                        &#125; else &#123;\n                            //拒绝授权\n                        &#125;\n                    &#125;\n                &#125;\n            &#125; else &#123;\n                //已授权\n                self.initCaptureSession()\n            &#125;\n        &#125; else &#123;\n            //摄像头可能已损坏\n        &#125;\n    &#125;\n</code></pre>\n<p>上面的代码讲述了如何申请权限，权限被拒绝如何跳转设置。</p>\n<p>如果有权限了会走 initCaptureSession 来初始化session:</p>\n<pre><code class=\"line-numbers language-Swift\">func initCaptureSession() &#123;\n        //创建会话对象\n        let `session` = AVCaptureSession()\n        self.session = session\n        session.sessionPreset = .high\n        \n        //获取设想设备\n        guard let device = AVCaptureDevice.default(for: AVMediaType.video) else &#123;\n            print(&quot;get front video AVCaptureDeviceInput  failed!&quot;)\n            return\n        &#125;\n        \n        //创建设想设备输入流\n        guard let input = try? AVCaptureDeviceInput(device: device) else &#123;\n            print(&quot;get front video AVCaptureDeviceInput  failed!&quot;)\n            return\n        &#125;\n        \n        //添加设想设备输入流到会话对象 输入流让session来分析\n        if session.canAddInput(input) &#123;\n            session.addInput(input)\n        &#125;\n        \n        //创建元数据输出流\n        let `output` = AVCaptureMetadataOutput()\n        self.output = output\n        output.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)\n                \n        //添加元数据输出流到会话对象 给新建的一个Output对象添加到session,session等下会给output赋值\n        session.addOutput(output)\n        \n        //创建摄像数据输出流并将其添加到会话对象上-----&gt;用户识别光线强弱\n        let `videoDataOutput` = AVCaptureVideoDataOutput()\n        self.videoDataOutput = videoDataOutput\n        videoDataOutput.setSampleBufferDelegate(self, queue: DispatchQueue.main)\n        session.addOutput(videoDataOutput)\n        \n        //设置数据输出类型(如下设置为条形码和二维码兼容)，需要将数据输出添加到会话后，才能指定元数据类型，否则会报错\n        \n        /*\n         \n         android\n         \n         Barcode.FORMAT_CODE_128,   *\n         Barcode.FORMAT_CODE_39,    *\n         Barcode.FORMAT_CODE_93,    *\n         Barcode.FORMAT_CODABAR,    ios 15.4 +\n         Barcode.FORMAT_EAN_13,     *\n         Barcode.FORMAT_EAN_8,      *\n         Barcode.FORMAT_UPC_A,      x\n         Barcode.FORMAT_UPC_E,      *\n         Barcode.TYPE_ISBN          x\n         */\n        output.metadataObjectTypes = [.code39,\n                                      .code39Mod43,\n                                      .code93,\n                                      .code128,\n                                      .ean8,\n                                      .ean13,\n                                      .upce,\n                                      .pdf417] //itf14\n        //实例化预览图层, 用于显示会话对象 session放到这里面，然后通过layer插入sublayer可以实现预览效果\n        let `videoPreviewLayer` = AVCaptureVideoPreviewLayer(session: session)\n        self.videoPreviewLayer = videoPreviewLayer\n        videoPreviewLayer.videoGravity = .resizeAspectFill\n        videoPreviewLayer.frame = layerView.bounds\n        layerView.layer.insertSublayer(videoPreviewLayer, at: 0)\n        \n        // session开始run\n        startScan()\n    &#125;\n</code></pre>\n<p>回到 生命周期 中，如果 session 不为空，会走上面的startScan 函数，这里就是让session继续工作的意思：</p>\n<pre><code class=\"line-numbers language-Swift\">func startScan() &#123;\n        session?.startRunning()\n    &#125;\n</code></pre>\n<p>在viewDidAppear中还做了什么呢？</p>\n<pre><code class=\"line-numbers language-Swift\">UIApplication.shared.isIdleTimerDisabled = true\nsetNeedsStatusBarAppearanceUpdate()\n</code></pre>\n<p>第一行：禁止该页面进入睡眠；<br>第二行：如果在viewController已经显示在当前页面，你可能还要在当前页面不时的更改statusBar的前景色，那么，你首先需要调用下面的setNeedsStatusBarAppearanceUpdate方法(这个方法会通知系统去调用当前UIViewController的preferredStatusBarStyle方法)，从而改变statusBar的statusBarStyle。</p>\n<h3 id=\"3-7-生命周期之viewDidDisappear\"><a href=\"#3-7-生命周期之viewDidDisappear\" class=\"headerlink\" title=\"3.7 生命周期之viewDidDisappear\"></a>3.7 生命周期之viewDidDisappear</h3><pre><code class=\"line-numbers language-Swift\"> override func viewDidDisappear(_ animated: Bool) &#123;\n        super.viewDidDisappear(animated)\n        stopScan()\n        UIApplication.shared.isIdleTimerDisabled = false\n        setNeedsStatusBarAppearanceUpdate()\n    &#125;\n</code></pre>\n<p>这里停止扫描，应该是停止session:</p>\n<pre><code class=\"line-numbers language-Swift\">func stopScan() &#123;\n        session?.stopRunning()\n    &#125;\n</code></pre>\n<p>其它上面讲过，不必多言了。</p>\n<h3 id=\"3-8-设置output代理\"><a href=\"#3-8-设置output代理\" class=\"headerlink\" title=\"3.8 设置output代理\"></a>3.8 设置output代理</h3><p>回到初始化session的部分代码中：</p>\n<pre><code class=\"line-numbers language-Swift\">//创建元数据输出流\nlet `output` = AVCaptureMetadataOutput()\nself.output = output\noutput.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)\n</code></pre>\n<p>这里设置了一个metadata的代理，所以这个controller必然扩展了这个代理。</p>\n<p>具体如下：</p>\n<pre><code class=\"line-numbers language-Swift\">extension GMBaseScanViewController: AVCaptureMetadataOutputObjectsDelegate &#123;\n    func metadataOutput(_ output: AVCaptureMetadataOutput, didOutput metadataObjects: [AVMetadataObject], from connection: AVCaptureConnection) &#123;\n        if isCanScan &#123;\n            let isAchieve: Bool = metadataObjects.count == 1\n            if isAchieve &#123;\n                // 扫到条码\n                guard let device = AVCaptureDevice.default(for: AVMediaType.video) else &#123; return &#125;\n                guard let codeObj = metadataObjects.last as? AVMetadataMachineReadableCodeObject else &#123; return &#125;\n                print(&quot;扫到了条码 codeObj  ：  \\(codeObj)&quot;)\n                guard let str = codeObj.stringValue else &#123; return &#125;\n                self.isCanScan = false\n                print(&quot;扫到了条码 str：  \\(str)&quot;)\n                DispatchQueue.main.asyncAfter(deadline: .now() + scanInterval) &#123;\n                    try? device.lockForConfiguration()\n                    device.videoZoomFactor = 1\n                    device.unlockForConfiguration()\n                    self.isCanScan = true\n                &#125;\n                let barCode = barcodeProcessing(str)\n                delegate?.scanBarcode(barCode)\n            &#125; else &#123;\n                MBProgressHUD.showTipsMessage(&quot;无法识别&quot;)\n            &#125;\n        &#125;\n    &#125;\n    \n    func barcodeProcessing(_ code: String) -&gt; String &#123;\n        var codeStr: String = code.mutableCopy() as! String\n        var newStr = code.uppercased()\n        var index = 0\n        newStr = newStr.replacingOccurrences(of: &quot; &quot;, with: &quot;&quot;, options: .literal, range: nil)\n        codeStr = codeStr.replacingOccurrences(of: &quot; &quot;, with: &quot;&quot;, options: .literal, range: nil)\n        if newStr.hasPrefix(&quot;GREE&quot;) &#123;\n            index = 3\n        &#125; else if newStr.hasPrefix(&quot;KINGHOME&quot;) &#123;\n            index = 7\n        &#125; else if newStr.hasPrefix(&quot;TOSOT&quot;) &#123;\n            index = 4\n        &#125;\n        if index != 0 &#123;\n            let start = codeStr.index(codeStr.startIndex, offsetBy: 0)\n            let end = codeStr.index(codeStr.startIndex, offsetBy: index)\n            codeStr.removeSubrange(start...end)\n        &#125;\n        return codeStr\n    &#125;\n&#125;\n</code></pre>\n<p>这里覆写了这协议方法，表示识别到内容了。然后会回调metadateOutput，原因是前面session里面设置了Output的代理为self,也就是这里，这里就关联起来了。<br>前面是这样的：</p>\n<pre><code class=\"line-numbers language-Swift\"> let `output` = AVCaptureMetadataOutput()\n        self.output = output\n        output.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)\n                \n        //添加元数据输出流到会话对象 给新建的一个Output对象添加到session,session等下会给output赋值\n        session.addOutput(output)\n</code></pre>\n<p>就是因为这个self，当session开始running后，就会走协议的回调方法，在那里面我们间隔3.5才让它进行下次扫描，也是在这里面分析这个条码是否正常之类的。</p>\n<h3 id=\"3-9-设置videoDataOuput代理\"><a href=\"#3-9-设置videoDataOuput代理\" class=\"headerlink\" title=\"3.9 设置videoDataOuput代理\"></a>3.9 设置videoDataOuput代理</h3><p>这个代理，目的是为了识别光线强弱。</p>\n<pre><code class=\"line-numbers language-Swift\">extension GMBaseScanViewController: AVCaptureVideoDataOutputSampleBufferDelegate &#123;\n    \n    func captureOutput(_ output: AVCaptureOutput, didOutput sampleBuffer: CMSampleBuffer, from connection: AVCaptureConnection) &#123;\n        // 获取光照亮度\n        guard let metadataCFDict: CFDictionary = CMCopyDictionaryOfAttachments(allocator: nil, target: sampleBuffer, attachmentMode: 1) else &#123; return &#125;\n        guard let metadataDic: [String: AnyObject] = metadataCFDict as? [String: AnyObject] else &#123; return &#125;\n        guard let exifMetadata: [String: AnyObject] = metadataDic[kCGImagePropertyExifDictionary as String] as? [String : AnyObject] else &#123; return &#125;\n        guard let brightnessValue: CGFloat = exifMetadata[kCGImagePropertyExifBrightnessValue as String] as? CGFloat else &#123; return &#125;\n        // 根据光照亮度展示按钮\n        if brightnessValue &lt; -1 &#123;\n            torchButton.isHidden = false\n        &#125; else &#123;\n            guard let device = AVCaptureDevice.default(for: AVMediaType.video) else &#123; return &#125;\n            if device.hasTorch &amp;&amp; device.isTorchAvailable &#123;\n                try? device.lockForConfiguration()\n                torchButton.isHidden = !(device.torchMode == .on)\n                device.unlockForConfiguration()\n                \n            &#125;\n        &#125;\n        \n    &#125;\n    \n    private func convert(cmage: CIImage) -&gt; UIImage &#123;\n         let context = CIContext(options: nil)\n         let cgImage = context.createCGImage(cmage, from: cmage.extent)!\n         let image = UIImage(cgImage: cgImage)\n         return image\n    &#125;\n    \n&#125;\n</code></pre>\n<p>在代理 captureOutput的回调方法中可以获取光线强弱信息。</p>\n<p>也是在初始化session的时候设置了这个代理。</p>\n<h3 id=\"3-10-识别到后播放声音\"><a href=\"#3-10-识别到后播放声音\" class=\"headerlink\" title=\"3.10 识别到后播放声音\"></a>3.10 识别到后播放声音</h3><p>这里我们额外增加一个方法，主要给外面调用，因为我们会提供一个代理，如果识别到后，通过代理内部方法将识别的条码给外面。这时候外面要震动或声音效果，只需要调用我们内部的一个方法即可。</p>\n<pre><code class=\"line-numbers language-Swift\">func playAudio(success code: Int) &#123;\n        if isPlay == false &#123;\n            return\n        &#125;\n        if code == 1 &#123;\n            var soundID: SystemSoundID = 0\n            guard let path = Bundle.main.path(forResource: &quot;scanSuccess&quot;, ofType: &quot;mp3&quot;) else &#123; return &#125;\n            let url = URL(fileURLWithPath: path)\n            AudioServicesCreateSystemSoundID(url as CFURL, &amp;soundID)\n            AudioServicesPlaySystemSound(soundID) //声音\n        &#125; else &#123;\n            var soundID: SystemSoundID = 0\n            guard let path = Bundle.main.path(forResource: &quot;scanFail&quot;, ofType: &quot;mp3&quot;) else &#123; return &#125;\n            let url = URL(fileURLWithPath: path)\n            AudioServicesCreateSystemSoundID(url as CFURL, &amp;soundID)\n            AudioServicesPlayAlertSound(soundID) //震动+播放声音\n        &#125;\n    &#125;\n</code></pre>\n<p>也是非常简单，只需要先拿到声音路径，转换url，再通过AudioServicesCreateSystemSoundID包装一下，再通过AudioServicesPlaySystemSound来播放这个soundID即可。</p>\n<p>就这样，一个具有扫码能力的Controller就出来了哦。</p>\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4 总结\"></a>4 总结</h2><ul>\n<li><p>如果用到扫码，一定需要申请权限的，必须考虑到是否有权限，如果拒绝了权限，或其它原因导致没有权限，都需要考虑。</p>\n</li>\n<li><p>扫码关键的几个类，AVCaptureSession控制数据流关键类；AVCaptureMetadataOutput接收流，代理方法来处理识别到条码后的逻辑；AVCaptureVideoDataOutput接收流，可以处理光线强弱；AVCaptureVideoPreviewLayer用来预览相机的视图层，可显示在UIView的layer上。</p>\n</li>\n<li><p>一般扫码需要具备的二指缩放，光线太暗打开闪光灯，这些可以算作基本能能力，务必要实现，否则体验很不佳。</p>\n</li>\n<li><p>合理控制识别到条码间隔时间，该停止session的时候务必停止，为了防止频繁识别到相同条码，可以设置间隔时间。</p>\n</li>\n<li><p>可以先定义一个播放声音效果的方法，方便外部直接调用方法播放成功或者失败的声音。声音主要用到AudioServices相关方法。</p>\n</li>\n<li><p>系统类大多都是提供了代理，暴露了一些方法主要都是定义好的方法，我们业务开发也只需要接收和处理这些定义好的类就可以了。</p>\n</li>\n</ul>\n"},{"title":"iOS swift 打造TabLayout效果","date":"2023-02-02T08:15:27.000Z","op":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 需求定义\n\n在首页，我们需要实现一个多tab页，支持左右滑动，上滑吸顶的效果。\n比如这样：\n<img src=page1.gif width=50%>\n\n需要保证良好的用户体验效果，每个页面都是独立的，可以上滑吸顶，左右滑动页面切换，而且还需要支持未读数字提示。\n\n## 2 需求分析\n\n针对这些需求，github上面有一个成熟的框架。\n[JXsegementedView](https://github.com/pujiaxin33/JXSegmentedView)，github上面有2千多个stars，想必是深受大家喜欢，所以我们也可以考虑用起来。\n\n> 它的特点是：\n腾讯新闻、今日头条、QQ音乐、网易云音乐、京东、爱奇艺、腾讯视频、淘宝、天猫、简书、微博等\n所有主流APP分类切换滚动视图\n与其他的同类三方库对比的优点：\n指示器逻辑面向协议编程，可以为所欲为的扩展指示器效果；\n提供更加全面丰富效果，几乎支持所有主流APP效果；\n使用子类化管理cell样式，逻辑更清晰，扩展更简单；\n列表支持整个生命周期方法； \n\n另外一个与之协同的是 [JXPagingView](https://github.com/pujiaxin33/JXPagingView) ，注意这两个库不是替换的关系，而是互相协作的关系。\n> JXPagingView: 类似微博主页、简书主页、QQ联系人页面等效果。多页面嵌套，既可以上下滑动，也可以左右滑动切换页面。支持HeaderView悬浮、支持下拉刷新、上拉加载更多。\n\n\n\n## 3 使用步骤\n\n### 3.1 引用依赖\n\n这里其实可以远程依赖，但我们考虑到自身一些需求，直接拖进项目里面，将github上的source文件，拷贝到项目里面。\n\n<img src=segment1.png>\n\n注意这个Personal文件夹里面主要放的是JXPagingView相关代码。\n\nok，这样项目中可以自由使用了。\n\n### 3.2 初始化视图相关\n\n```Swift\nextension JXPagingListContainerView: JXSegmentedViewListContainer {}\n```\n这里我们先扩展下这个协议，这个JXSegementedViewListContainer是框架里面的协议：\n```Swift\npublic protocol JXSegmentedViewListContainer {\n    var defaultSelectedIndex: Int { set get }\n    func contentScrollView() -> UIScrollView\n    func reloadData()\n    func didClickSelectedItem(at index: Int)\n}\n```\n协议可以理解为Android中的接口。\n\n然后我们定义了几个tab，枚举类，姑且叫做这个吧：\n```Swift\nenum WorkListCellItem {\n    /// 待收讫\n    case waitingBalance\n    /// 待开单\n    case waitingForBilling\n    /// 待送货\n    case waitingForDelivery\n    /// 待安装\n    case waitingForInstallation\n    /// 待出库\n    case outOfWarehouse\n    /// 待入库\n    case toBeWarehoused\n}\n```\n\n然后在控制器里面声明下全局变量：\n```Swift\n var pagingView: JXPagingView!\nvar userHeaderView: WorkHeadView!\nvar segmentedViewDataSource: JXSegmentedTitleDataSource!\nvar segmentedView: JXSegmentedView!\nvar JXheightForHeaderInSection: Int = 44\nvar JXTableHeaderViewHeight: Int = 182{\n    didSet{\n        self.pagingView.reloadData()\n    }\n}\n```\n这里简单说下这几个成员作用：\n* JXPagingView: 这个是最外层的容器，里面有一个mainTableView和listContainerView。\n* WorkHeadView: 这个是我们自定义的头部，无需关注。\n* JXSegemntedTitleDataSource: 这个主要是tab的数据。\n* JXheightForHeaderInSection: 标签栏高度定义。\n* JXTableHeaderViewHeight: 头部区域高度定义。\n\n然后看下如何初始化视图：\n```Swift\nfunc setUI() {\n\n        view.backgroundColor = UIColor(hex:\"#3E4D89\").withAlphaComponent(0.06)\n        view.gm_addSubview(navView) { make in\n            make.top.equalTo(0)\n            make.left.right.equalToSuperview()\n            make.height.equalTo(Height_NavBarAndStatusBar)\n        }\n        \n        /// 头部区域\n        userHeaderView = WorkHeadView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width, height: CGFloat(JXTableHeaderViewHeight)))\n        userHeaderView.eventClosure = { [unowned self] (event) in\n            self.workFunctionItemEventClick(event: event)\n        }\n        userHeaderView.clickMsgHandle = {[weak self] model in\n            self?.requestForClickMsg(model: model)\n        }\n        // 配置指示器\n        let indicator = JXSegmentedIndicatorLineView()\n        // 标签栏下划线\n        indicator.indicatorColor = UIColor(r: 64, g: 158, b: 255, alpha: 1)\n        indicator.indicatorWidthIncrement = -15 /// 作用于增大可触区域\n        /// 标签栏\n        segmentedView = JXSegmentedView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width, height: CGFloat(JXheightForHeaderInSection)))\n        segmentedView.backgroundColor = UIColor.white\n        segmentedView.dataSource = dataSource\n        segmentedView.isContentScrollViewClickTransitionAnimationEnabled = true\n        segmentedView.indicators = [indicator]\n\n        let lineWidth = 1/UIScreen.main.scale\n        let lineLayer = CALayer()\n        lineLayer.backgroundColor = UIColor.lightGray.cgColor\n        lineLayer.frame = CGRect(x: 0, y: segmentedView.bounds.height - lineWidth, width: segmentedView.bounds.width, height: lineWidth)\n        segmentedView.layer.addSublayer(lineLayer)\n\n        pagingView = JXPagingView(delegate: self)\n        let header = GMSAutoRefreshHeader()\n        header.setRefreshingTarget(self, refreshingAction: #selector(defaultTableHeaderRefresh))\n        pagingView.mainTableView.mj_header = header\n        if #available(iOS 15.0, *) {\n            pagingView.mainTableView.sectionHeaderTopPadding = 0\n        } else {\n            // Fallback on earlier ···versions\n        }\n        \n        self.view.addSubview(pagingView)\n\n        segmentedView.listContainer = pagingView.listContainerView\n        \n        self.view.gm_addSubview(stockInitializationTipsView) { make in\n            make.top.equalTo(Height_NavBarAndStatusBar)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(0)\n        }\n        pagingView.snp_makeConstraints { make in\n            make.top.equalTo(stockInitializationTipsView.snp_bottom).offset(0)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(ScreenHeight-Height_NavBarAndStatusBar-Height_TabBar)\n        }\n        \n        /// 待开单列表--取消订单闭包回调\n        self.waitingForBillingVC.cancelBlock = { [weak self] in\n            self?.waitingForBillingVC.requestIntendedOrder()\n        }\n        \n        self.setJXCountBolck()\n        \n        WatermarkView.showWindow()\n    }\n```\n这里JXSegmentView主要是标签栏。\n\nPageView是我们实现这效果的父布局。\n不出意外，这个PageView里面应该会关联到标签栏。\n这里有部分代码是这样的：\n`\nsegmentedView.listContainer = pagingView.listContainerView\n`\n这里应该就是建立联系了。\n\n### 3.3 配置代理和数据源\n\n前面将delegate设置为self了，所以我们需要看下如何配置的。\n先看下PageView设置的代理吧：\n```swfit\nextension NewWorkViewController: JXPagingViewDelegate {\n\n    /// tableHeaderView高度\n    func tableHeaderViewHeight(in pagingView: JXPagingView) -> Int {\n        return JXTableHeaderViewHeight\n    }\n\n    /// tableHeaderView\n    func tableHeaderView(in pagingView: JXPagingView) -> UIView {\n        return userHeaderView\n    }\n\n    /// 吸顶标签栏的高度\n    func heightForPinSectionHeader(in pagingView: JXPagingView) -> Int {\n        return JXheightForHeaderInSection\n    }\n\n    /// 吸顶标签栏\n    func viewForPinSectionHeader(in pagingView: JXPagingView) -> UIView {\n        return segmentedView\n    }\n    \n    /// 列表的数量\n    func numberOfLists(in pagingView: JXPagingView) -> Int {\n        return dataSource.attributedTitles.count\n    }\n\n    /// 列表\n    func pagingView(_ pagingView: JXPagingView, initListAtIndex index: Int) -> JXPagingViewListViewDelegate {\n        let flag: WorkListCellItem = self.listDataArray[index]\n        \n        if flag == .waitingBalance {\n            /// 待收讫VC\n            let list = waitingBalanceVC\n            return list\n        }else if flag == .waitingForBilling {\n            /// 待开单VC\n            let list = waitingForBillingVC\n            return list\n        }else if flag == .waitingForDelivery {\n            /// 待送货VC\n            let list = waitingForDeliveryVC\n            return list\n        }else if flag == .waitingForInstallation {\n            /// 待安装VC\n            let list = waitingForInstallationVC\n            return list\n        }else if flag == .outOfWarehouse {\n            /// 待出库VC\n            let list = outOfWarehouseVC\n            return list\n        }else {\n            /// 待入库VC\n            let list = toBeWarehousedVC\n            return list\n        }\n    }\n\n    func mainTableViewDidScroll(_ scrollView: UIScrollView) {\n//        userHeaderView?.scrollViewDidScroll(contentOffsetY: scrollView.contentOffset.y)\n    }\n}\n```\n这里配置了头部，高度等。\n主要的pagingView是需要我们自己实现的，这个就是Tab下方的列表展示了。\n不出意外这个应该需要继承框架里面的某个View吧。\n\n我们等下看下waitingForBillingVC吧。\n\n另外看下标签栏的数据源是怎么设置的：\n```Swift\n private lazy var dataSource : JXSegmentedTitleAttributeDataSource = {\n        let dataSource = JXSegmentedTitleAttributeDataSource()\n        /// 关闭标签栏等分宽度\n        dataSource.isItemSpacingAverageEnabled = false\n        dataSource.itemSpacing = 0\n        return dataSource\n    }()\n```\n这里只是定义了，还需要在需要的地方配置下数据：\n```Swift\n  dataSource.attributedTitles = dataTitles\n  dataSource.selectedAttributedTitles = dataSelectedTitles\n        \n```\n\n## 4 子列表\n\n外层框架搭好了，需要看下每个子列表是如何塞进去的。\n```Swift\n// MARK: - 工作台（待开单）\nclass WorkWaitingForBillingVC: AutomaticDimensionTableViewController, JXPagingViewListViewDelegate {\n```\n\n这里其实本质上是一个控制器哦，只是实现了它定义的代理方法即可。\n这里用了一个我们自己定义的自动高度的控制器，跟这个框架无关哈。\n```Swift\n/// 自动高度 TableView （避免 使用UITableView.automaticDimension 带来的弊端（某些时候 reloadData contentOffSet 会改变 导致闪跳））\n/// 只实现了UITableViewDelegate和高度相关的代理方法，tableview也没有创建，自行按需创建\nclass AutomaticDimensionTableViewController: GMBaseViewController {\n    private var rowHeights = [String: CGFloat]()\n    private var headerHeights = [String: CGFloat]()\n    private var footerHeights = [String: CGFloat]()\n    \n    /// 预估cell高度\n    var rowEstimatedHeight: CGFloat = UITableView.automaticDimension\n    /// 预估header高度\n    var headerEstimatedHeight: CGFloat = 200\n    /// 预估footer高度\n    var footerEstimatedHeight: CGFloat = 200\n\n}\nprivate extension AutomaticDimensionTableViewController {\n    func getRowKeyWithIndexPath(_ indexPath: IndexPath) -> String {\n        let section = indexPath.section\n        let row = indexPath.row\n        let key = \"\\(section)-\\(row)\"\n        return key\n    }\n}\nextension AutomaticDimensionTableViewController: UITableViewDelegate {\n    func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {\n        let key = getRowKeyWithIndexPath(indexPath)\n        let height = cell.frame.height\n        rowHeights[key] = height\n    }\n    func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -> CGFloat {\n        let key = getRowKeyWithIndexPath(indexPath)\n        guard let height = rowHeights[key] else { return rowEstimatedHeight }\n        return height\n    }\n    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n        return UITableView.automaticDimension\n    }\n    \n    \n    \n    func tableView(_ tableView: UITableView, willDisplayHeaderView view: UIView, forSection section: Int) {\n        let key = \"\\(section)\"\n        let height = view.frame.height\n        headerHeights[key] = height\n    }\n    func tableView(_ tableView: UITableView, estimatedHeightForHeaderInSection section: Int) -> CGFloat {\n        let key = \"\\(section)\"\n        guard let height = headerHeights[key] else { return headerEstimatedHeight }\n        return height\n    }\n    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {\n        return UITableView.automaticDimension\n    }\n    \n    \n    func tableView(_ tableView: UITableView, willDisplayFooterView view: UIView, forSection section: Int) {\n        let key = \"\\(section)\"\n        let height = view.frame.height\n        footerHeights[key] = height\n    }\n    func tableView(_ tableView: UITableView, estimatedHeightForFooterInSection section: Int) -> CGFloat {\n        let key = \"\\(section)\"\n        guard let height = footerHeights[key] else { return footerEstimatedHeight }\n        return height\n    }\n    func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -> CGFloat {\n        return UITableView.automaticDimension\n    }\n}\n```\n\n框架要求的协议需要看下：\n```Swift\n@objc\npublic protocol JXPagingViewListViewDelegate {\n    /// 如果列表是VC，就返回VC.view\n    /// 如果列表是View，就返回View自己\n    ///\n    /// - Returns: 返回列表视图\n    func listView() -> UIView\n    /// 返回listView内部持有的UIScrollView或UITableView或UICollectionView\n    /// 主要用于mainTableView已经显示了header，listView的contentOffset需要重置时，内部需要访问到外部传入进来的listView内的scrollView\n    ///\n    /// - Returns: listView内部持有的UIScrollView或UITableView或UICollectionView\n    func listScrollView() -> UIScrollView\n    /// 当listView内部持有的UIScrollView或UITableView或UICollectionView的代理方法`scrollViewDidScroll`回调时，需要调用该代理方法传入的callback\n    ///\n    /// - Parameter callback: `scrollViewDidScroll`回调时调用的callback\n    func listViewDidScrollCallback(callback: @escaping (UIScrollView)->())\n\n    /// 将要重置listScrollView的contentOffset\n    @objc optional func listScrollViewWillResetContentOffset()\n    /// 可选实现，列表将要显示的时候调用\n    @objc optional func listWillAppear()\n    /// 可选实现，列表显示的时候调用\n    @objc optional func listDidAppear()\n    /// 可选实现，列表将要消失的时候调用\n    @objc optional func listWillDisappear()\n    /// 可选实现，列表消失的时候调用\n    @objc optional func listDidDisappear()\n}\n```\n这里要求我们可以实现这些方法。\n\n```Swift\nvar listViewDidScrollCallback: ((UIScrollView) -> ())?\n    \n    deinit {\n        listViewDidScrollCallback = nil\n    }\n    \n    func listView() -> UIView {\n        return self.view\n    }\n    \n    func listScrollView() -> UIScrollView {\n        return self.mainTableView\n    }\n    \n    func listViewDidScrollCallback(callback: @escaping (UIScrollView) -> ()) {\n        self.listViewDidScrollCallback = callback\n    }\n\n    /// 主列表\n    lazy var mainTableView: UITableView = {\n        let tableView = UITableView(frame: UIScreen.main.bounds, style: .grouped)\n        if #available(iOS 15.0, *) {\n            tableView.sectionHeaderTopPadding = 0\n        } else {\n            // Fallback on earlier ···versions\n        }\n        tableView.separatorStyle = .none\n        tableView.delegate = self\n        tableView.dataSource = self\n        tableView.backgroundColor = .white\n        tableView.showsVerticalScrollIndicator = false\n        tableView.showsHorizontalScrollIndicator = false\n        tableView.tableFooterView = UIView()\n        \n        let footer = GMSAutoRefreshFooter()\n        footer.setRefreshingTarget(self, refreshingAction: #selector(defaultTableFooterRefresh))\n        tableView.mj_footer = footer\n       return tableView\n   }()\n```\n这里我们直接把控制的view给他了。\n这个滚动的视图就是我们自己定义的主列表。\n\n大致就是这样，使用起来还是简单的。\n后面有时间再详细看下源码才行。\n\n## 5 总结\n* 本文主要是针对多Tab页，吸顶效果和可分页可滑动的需求，利用一个三方框架完美解决。\n* 主要通过最外层的JPagingView本质上是UIView来的，设置代理，配置头部区域和中间列表区域显示。通过一个listContainer关联起了标签栏和列表区，这样实现双向交互。\n* 使用这个框架的工作就是创建这几个View，配置代理，实现代理，最后实现列表的控制器，控制器也需要实现它提供的代理，另外头部也需要我们按照ui要求自己编写即可。\n* 使用任何一个三方库一定要懂得它的原理，一旦出问题，我们可以游刃而解。\n\n","source":"_posts/iOS-swift-打造TabLayout效果.md","raw":"---\ntitle: iOS swift 打造TabLayout效果\ndate: 2023-02-02 16:15:27\nop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- TabLayout\ncategories:\n- iOS\n---\n\n## 1 需求定义\n\n在首页，我们需要实现一个多tab页，支持左右滑动，上滑吸顶的效果。\n比如这样：\n<img src=page1.gif width=50%>\n\n需要保证良好的用户体验效果，每个页面都是独立的，可以上滑吸顶，左右滑动页面切换，而且还需要支持未读数字提示。\n\n## 2 需求分析\n\n针对这些需求，github上面有一个成熟的框架。\n[JXsegementedView](https://github.com/pujiaxin33/JXSegmentedView)，github上面有2千多个stars，想必是深受大家喜欢，所以我们也可以考虑用起来。\n\n> 它的特点是：\n腾讯新闻、今日头条、QQ音乐、网易云音乐、京东、爱奇艺、腾讯视频、淘宝、天猫、简书、微博等\n所有主流APP分类切换滚动视图\n与其他的同类三方库对比的优点：\n指示器逻辑面向协议编程，可以为所欲为的扩展指示器效果；\n提供更加全面丰富效果，几乎支持所有主流APP效果；\n使用子类化管理cell样式，逻辑更清晰，扩展更简单；\n列表支持整个生命周期方法； \n\n另外一个与之协同的是 [JXPagingView](https://github.com/pujiaxin33/JXPagingView) ，注意这两个库不是替换的关系，而是互相协作的关系。\n> JXPagingView: 类似微博主页、简书主页、QQ联系人页面等效果。多页面嵌套，既可以上下滑动，也可以左右滑动切换页面。支持HeaderView悬浮、支持下拉刷新、上拉加载更多。\n\n\n\n## 3 使用步骤\n\n### 3.1 引用依赖\n\n这里其实可以远程依赖，但我们考虑到自身一些需求，直接拖进项目里面，将github上的source文件，拷贝到项目里面。\n\n<img src=segment1.png>\n\n注意这个Personal文件夹里面主要放的是JXPagingView相关代码。\n\nok，这样项目中可以自由使用了。\n\n### 3.2 初始化视图相关\n\n```Swift\nextension JXPagingListContainerView: JXSegmentedViewListContainer {}\n```\n这里我们先扩展下这个协议，这个JXSegementedViewListContainer是框架里面的协议：\n```Swift\npublic protocol JXSegmentedViewListContainer {\n    var defaultSelectedIndex: Int { set get }\n    func contentScrollView() -> UIScrollView\n    func reloadData()\n    func didClickSelectedItem(at index: Int)\n}\n```\n协议可以理解为Android中的接口。\n\n然后我们定义了几个tab，枚举类，姑且叫做这个吧：\n```Swift\nenum WorkListCellItem {\n    /// 待收讫\n    case waitingBalance\n    /// 待开单\n    case waitingForBilling\n    /// 待送货\n    case waitingForDelivery\n    /// 待安装\n    case waitingForInstallation\n    /// 待出库\n    case outOfWarehouse\n    /// 待入库\n    case toBeWarehoused\n}\n```\n\n然后在控制器里面声明下全局变量：\n```Swift\n var pagingView: JXPagingView!\nvar userHeaderView: WorkHeadView!\nvar segmentedViewDataSource: JXSegmentedTitleDataSource!\nvar segmentedView: JXSegmentedView!\nvar JXheightForHeaderInSection: Int = 44\nvar JXTableHeaderViewHeight: Int = 182{\n    didSet{\n        self.pagingView.reloadData()\n    }\n}\n```\n这里简单说下这几个成员作用：\n* JXPagingView: 这个是最外层的容器，里面有一个mainTableView和listContainerView。\n* WorkHeadView: 这个是我们自定义的头部，无需关注。\n* JXSegemntedTitleDataSource: 这个主要是tab的数据。\n* JXheightForHeaderInSection: 标签栏高度定义。\n* JXTableHeaderViewHeight: 头部区域高度定义。\n\n然后看下如何初始化视图：\n```Swift\nfunc setUI() {\n\n        view.backgroundColor = UIColor(hex:\"#3E4D89\").withAlphaComponent(0.06)\n        view.gm_addSubview(navView) { make in\n            make.top.equalTo(0)\n            make.left.right.equalToSuperview()\n            make.height.equalTo(Height_NavBarAndStatusBar)\n        }\n        \n        /// 头部区域\n        userHeaderView = WorkHeadView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width, height: CGFloat(JXTableHeaderViewHeight)))\n        userHeaderView.eventClosure = { [unowned self] (event) in\n            self.workFunctionItemEventClick(event: event)\n        }\n        userHeaderView.clickMsgHandle = {[weak self] model in\n            self?.requestForClickMsg(model: model)\n        }\n        // 配置指示器\n        let indicator = JXSegmentedIndicatorLineView()\n        // 标签栏下划线\n        indicator.indicatorColor = UIColor(r: 64, g: 158, b: 255, alpha: 1)\n        indicator.indicatorWidthIncrement = -15 /// 作用于增大可触区域\n        /// 标签栏\n        segmentedView = JXSegmentedView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width, height: CGFloat(JXheightForHeaderInSection)))\n        segmentedView.backgroundColor = UIColor.white\n        segmentedView.dataSource = dataSource\n        segmentedView.isContentScrollViewClickTransitionAnimationEnabled = true\n        segmentedView.indicators = [indicator]\n\n        let lineWidth = 1/UIScreen.main.scale\n        let lineLayer = CALayer()\n        lineLayer.backgroundColor = UIColor.lightGray.cgColor\n        lineLayer.frame = CGRect(x: 0, y: segmentedView.bounds.height - lineWidth, width: segmentedView.bounds.width, height: lineWidth)\n        segmentedView.layer.addSublayer(lineLayer)\n\n        pagingView = JXPagingView(delegate: self)\n        let header = GMSAutoRefreshHeader()\n        header.setRefreshingTarget(self, refreshingAction: #selector(defaultTableHeaderRefresh))\n        pagingView.mainTableView.mj_header = header\n        if #available(iOS 15.0, *) {\n            pagingView.mainTableView.sectionHeaderTopPadding = 0\n        } else {\n            // Fallback on earlier ···versions\n        }\n        \n        self.view.addSubview(pagingView)\n\n        segmentedView.listContainer = pagingView.listContainerView\n        \n        self.view.gm_addSubview(stockInitializationTipsView) { make in\n            make.top.equalTo(Height_NavBarAndStatusBar)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(0)\n        }\n        pagingView.snp_makeConstraints { make in\n            make.top.equalTo(stockInitializationTipsView.snp_bottom).offset(0)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(ScreenHeight-Height_NavBarAndStatusBar-Height_TabBar)\n        }\n        \n        /// 待开单列表--取消订单闭包回调\n        self.waitingForBillingVC.cancelBlock = { [weak self] in\n            self?.waitingForBillingVC.requestIntendedOrder()\n        }\n        \n        self.setJXCountBolck()\n        \n        WatermarkView.showWindow()\n    }\n```\n这里JXSegmentView主要是标签栏。\n\nPageView是我们实现这效果的父布局。\n不出意外，这个PageView里面应该会关联到标签栏。\n这里有部分代码是这样的：\n`\nsegmentedView.listContainer = pagingView.listContainerView\n`\n这里应该就是建立联系了。\n\n### 3.3 配置代理和数据源\n\n前面将delegate设置为self了，所以我们需要看下如何配置的。\n先看下PageView设置的代理吧：\n```swfit\nextension NewWorkViewController: JXPagingViewDelegate {\n\n    /// tableHeaderView高度\n    func tableHeaderViewHeight(in pagingView: JXPagingView) -> Int {\n        return JXTableHeaderViewHeight\n    }\n\n    /// tableHeaderView\n    func tableHeaderView(in pagingView: JXPagingView) -> UIView {\n        return userHeaderView\n    }\n\n    /// 吸顶标签栏的高度\n    func heightForPinSectionHeader(in pagingView: JXPagingView) -> Int {\n        return JXheightForHeaderInSection\n    }\n\n    /// 吸顶标签栏\n    func viewForPinSectionHeader(in pagingView: JXPagingView) -> UIView {\n        return segmentedView\n    }\n    \n    /// 列表的数量\n    func numberOfLists(in pagingView: JXPagingView) -> Int {\n        return dataSource.attributedTitles.count\n    }\n\n    /// 列表\n    func pagingView(_ pagingView: JXPagingView, initListAtIndex index: Int) -> JXPagingViewListViewDelegate {\n        let flag: WorkListCellItem = self.listDataArray[index]\n        \n        if flag == .waitingBalance {\n            /// 待收讫VC\n            let list = waitingBalanceVC\n            return list\n        }else if flag == .waitingForBilling {\n            /// 待开单VC\n            let list = waitingForBillingVC\n            return list\n        }else if flag == .waitingForDelivery {\n            /// 待送货VC\n            let list = waitingForDeliveryVC\n            return list\n        }else if flag == .waitingForInstallation {\n            /// 待安装VC\n            let list = waitingForInstallationVC\n            return list\n        }else if flag == .outOfWarehouse {\n            /// 待出库VC\n            let list = outOfWarehouseVC\n            return list\n        }else {\n            /// 待入库VC\n            let list = toBeWarehousedVC\n            return list\n        }\n    }\n\n    func mainTableViewDidScroll(_ scrollView: UIScrollView) {\n//        userHeaderView?.scrollViewDidScroll(contentOffsetY: scrollView.contentOffset.y)\n    }\n}\n```\n这里配置了头部，高度等。\n主要的pagingView是需要我们自己实现的，这个就是Tab下方的列表展示了。\n不出意外这个应该需要继承框架里面的某个View吧。\n\n我们等下看下waitingForBillingVC吧。\n\n另外看下标签栏的数据源是怎么设置的：\n```Swift\n private lazy var dataSource : JXSegmentedTitleAttributeDataSource = {\n        let dataSource = JXSegmentedTitleAttributeDataSource()\n        /// 关闭标签栏等分宽度\n        dataSource.isItemSpacingAverageEnabled = false\n        dataSource.itemSpacing = 0\n        return dataSource\n    }()\n```\n这里只是定义了，还需要在需要的地方配置下数据：\n```Swift\n  dataSource.attributedTitles = dataTitles\n  dataSource.selectedAttributedTitles = dataSelectedTitles\n        \n```\n\n## 4 子列表\n\n外层框架搭好了，需要看下每个子列表是如何塞进去的。\n```Swift\n// MARK: - 工作台（待开单）\nclass WorkWaitingForBillingVC: AutomaticDimensionTableViewController, JXPagingViewListViewDelegate {\n```\n\n这里其实本质上是一个控制器哦，只是实现了它定义的代理方法即可。\n这里用了一个我们自己定义的自动高度的控制器，跟这个框架无关哈。\n```Swift\n/// 自动高度 TableView （避免 使用UITableView.automaticDimension 带来的弊端（某些时候 reloadData contentOffSet 会改变 导致闪跳））\n/// 只实现了UITableViewDelegate和高度相关的代理方法，tableview也没有创建，自行按需创建\nclass AutomaticDimensionTableViewController: GMBaseViewController {\n    private var rowHeights = [String: CGFloat]()\n    private var headerHeights = [String: CGFloat]()\n    private var footerHeights = [String: CGFloat]()\n    \n    /// 预估cell高度\n    var rowEstimatedHeight: CGFloat = UITableView.automaticDimension\n    /// 预估header高度\n    var headerEstimatedHeight: CGFloat = 200\n    /// 预估footer高度\n    var footerEstimatedHeight: CGFloat = 200\n\n}\nprivate extension AutomaticDimensionTableViewController {\n    func getRowKeyWithIndexPath(_ indexPath: IndexPath) -> String {\n        let section = indexPath.section\n        let row = indexPath.row\n        let key = \"\\(section)-\\(row)\"\n        return key\n    }\n}\nextension AutomaticDimensionTableViewController: UITableViewDelegate {\n    func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {\n        let key = getRowKeyWithIndexPath(indexPath)\n        let height = cell.frame.height\n        rowHeights[key] = height\n    }\n    func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -> CGFloat {\n        let key = getRowKeyWithIndexPath(indexPath)\n        guard let height = rowHeights[key] else { return rowEstimatedHeight }\n        return height\n    }\n    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n        return UITableView.automaticDimension\n    }\n    \n    \n    \n    func tableView(_ tableView: UITableView, willDisplayHeaderView view: UIView, forSection section: Int) {\n        let key = \"\\(section)\"\n        let height = view.frame.height\n        headerHeights[key] = height\n    }\n    func tableView(_ tableView: UITableView, estimatedHeightForHeaderInSection section: Int) -> CGFloat {\n        let key = \"\\(section)\"\n        guard let height = headerHeights[key] else { return headerEstimatedHeight }\n        return height\n    }\n    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {\n        return UITableView.automaticDimension\n    }\n    \n    \n    func tableView(_ tableView: UITableView, willDisplayFooterView view: UIView, forSection section: Int) {\n        let key = \"\\(section)\"\n        let height = view.frame.height\n        footerHeights[key] = height\n    }\n    func tableView(_ tableView: UITableView, estimatedHeightForFooterInSection section: Int) -> CGFloat {\n        let key = \"\\(section)\"\n        guard let height = footerHeights[key] else { return footerEstimatedHeight }\n        return height\n    }\n    func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -> CGFloat {\n        return UITableView.automaticDimension\n    }\n}\n```\n\n框架要求的协议需要看下：\n```Swift\n@objc\npublic protocol JXPagingViewListViewDelegate {\n    /// 如果列表是VC，就返回VC.view\n    /// 如果列表是View，就返回View自己\n    ///\n    /// - Returns: 返回列表视图\n    func listView() -> UIView\n    /// 返回listView内部持有的UIScrollView或UITableView或UICollectionView\n    /// 主要用于mainTableView已经显示了header，listView的contentOffset需要重置时，内部需要访问到外部传入进来的listView内的scrollView\n    ///\n    /// - Returns: listView内部持有的UIScrollView或UITableView或UICollectionView\n    func listScrollView() -> UIScrollView\n    /// 当listView内部持有的UIScrollView或UITableView或UICollectionView的代理方法`scrollViewDidScroll`回调时，需要调用该代理方法传入的callback\n    ///\n    /// - Parameter callback: `scrollViewDidScroll`回调时调用的callback\n    func listViewDidScrollCallback(callback: @escaping (UIScrollView)->())\n\n    /// 将要重置listScrollView的contentOffset\n    @objc optional func listScrollViewWillResetContentOffset()\n    /// 可选实现，列表将要显示的时候调用\n    @objc optional func listWillAppear()\n    /// 可选实现，列表显示的时候调用\n    @objc optional func listDidAppear()\n    /// 可选实现，列表将要消失的时候调用\n    @objc optional func listWillDisappear()\n    /// 可选实现，列表消失的时候调用\n    @objc optional func listDidDisappear()\n}\n```\n这里要求我们可以实现这些方法。\n\n```Swift\nvar listViewDidScrollCallback: ((UIScrollView) -> ())?\n    \n    deinit {\n        listViewDidScrollCallback = nil\n    }\n    \n    func listView() -> UIView {\n        return self.view\n    }\n    \n    func listScrollView() -> UIScrollView {\n        return self.mainTableView\n    }\n    \n    func listViewDidScrollCallback(callback: @escaping (UIScrollView) -> ()) {\n        self.listViewDidScrollCallback = callback\n    }\n\n    /// 主列表\n    lazy var mainTableView: UITableView = {\n        let tableView = UITableView(frame: UIScreen.main.bounds, style: .grouped)\n        if #available(iOS 15.0, *) {\n            tableView.sectionHeaderTopPadding = 0\n        } else {\n            // Fallback on earlier ···versions\n        }\n        tableView.separatorStyle = .none\n        tableView.delegate = self\n        tableView.dataSource = self\n        tableView.backgroundColor = .white\n        tableView.showsVerticalScrollIndicator = false\n        tableView.showsHorizontalScrollIndicator = false\n        tableView.tableFooterView = UIView()\n        \n        let footer = GMSAutoRefreshFooter()\n        footer.setRefreshingTarget(self, refreshingAction: #selector(defaultTableFooterRefresh))\n        tableView.mj_footer = footer\n       return tableView\n   }()\n```\n这里我们直接把控制的view给他了。\n这个滚动的视图就是我们自己定义的主列表。\n\n大致就是这样，使用起来还是简单的。\n后面有时间再详细看下源码才行。\n\n## 5 总结\n* 本文主要是针对多Tab页，吸顶效果和可分页可滑动的需求，利用一个三方框架完美解决。\n* 主要通过最外层的JPagingView本质上是UIView来的，设置代理，配置头部区域和中间列表区域显示。通过一个listContainer关联起了标签栏和列表区，这样实现双向交互。\n* 使用这个框架的工作就是创建这几个View，配置代理，实现代理，最后实现列表的控制器，控制器也需要实现它提供的代理，另外头部也需要我们按照ui要求自己编写即可。\n* 使用任何一个三方库一定要懂得它的原理，一旦出问题，我们可以游刃而解。\n\n","slug":"iOS-swift-打造TabLayout效果","published":1,"updated":"2023-02-01T09:44:30.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlhfhyp000givv77rdm1fur","content":"<h2 id=\"1-需求定义\"><a href=\"#1-需求定义\" class=\"headerlink\" title=\"1 需求定义\"></a>1 需求定义</h2><p>在首页，我们需要实现一个多tab页，支持左右滑动，上滑吸顶的效果。<br>比如这样：<br><img src=page1.gif width=50%></p>\n<p>需要保证良好的用户体验效果，每个页面都是独立的，可以上滑吸顶，左右滑动页面切换，而且还需要支持未读数字提示。</p>\n<h2 id=\"2-需求分析\"><a href=\"#2-需求分析\" class=\"headerlink\" title=\"2 需求分析\"></a>2 需求分析</h2><p>针对这些需求，github上面有一个成熟的框架。<br><a href=\"https://github.com/pujiaxin33/JXSegmentedView\">JXsegementedView</a>，github上面有2千多个stars，想必是深受大家喜欢，所以我们也可以考虑用起来。</p>\n<blockquote>\n<p>它的特点是：<br>腾讯新闻、今日头条、QQ音乐、网易云音乐、京东、爱奇艺、腾讯视频、淘宝、天猫、简书、微博等<br>所有主流APP分类切换滚动视图<br>与其他的同类三方库对比的优点：<br>指示器逻辑面向协议编程，可以为所欲为的扩展指示器效果；<br>提供更加全面丰富效果，几乎支持所有主流APP效果；<br>使用子类化管理cell样式，逻辑更清晰，扩展更简单；<br>列表支持整个生命周期方法； </p>\n</blockquote>\n<p>另外一个与之协同的是 <a href=\"https://github.com/pujiaxin33/JXPagingView\">JXPagingView</a> ，注意这两个库不是替换的关系，而是互相协作的关系。</p>\n<blockquote>\n<p>JXPagingView: 类似微博主页、简书主页、QQ联系人页面等效果。多页面嵌套，既可以上下滑动，也可以左右滑动切换页面。支持HeaderView悬浮、支持下拉刷新、上拉加载更多。</p>\n</blockquote>\n<h2 id=\"3-使用步骤\"><a href=\"#3-使用步骤\" class=\"headerlink\" title=\"3 使用步骤\"></a>3 使用步骤</h2><h3 id=\"3-1-引用依赖\"><a href=\"#3-1-引用依赖\" class=\"headerlink\" title=\"3.1 引用依赖\"></a>3.1 引用依赖</h3><p>这里其实可以远程依赖，但我们考虑到自身一些需求，直接拖进项目里面，将github上的source文件，拷贝到项目里面。</p>\n<img src=segment1.png>\n\n<p>注意这个Personal文件夹里面主要放的是JXPagingView相关代码。</p>\n<p>ok，这样项目中可以自由使用了。</p>\n<h3 id=\"3-2-初始化视图相关\"><a href=\"#3-2-初始化视图相关\" class=\"headerlink\" title=\"3.2 初始化视图相关\"></a>3.2 初始化视图相关</h3><pre><code class=\"line-numbers language-Swift\">extension JXPagingListContainerView: JXSegmentedViewListContainer &#123;&#125;\n</code></pre>\n<p>这里我们先扩展下这个协议，这个JXSegementedViewListContainer是框架里面的协议：</p>\n<pre><code class=\"line-numbers language-Swift\">public protocol JXSegmentedViewListContainer &#123;\n    var defaultSelectedIndex: Int &#123; set get &#125;\n    func contentScrollView() -&gt; UIScrollView\n    func reloadData()\n    func didClickSelectedItem(at index: Int)\n&#125;\n</code></pre>\n<p>协议可以理解为Android中的接口。</p>\n<p>然后我们定义了几个tab，枚举类，姑且叫做这个吧：</p>\n<pre><code class=\"line-numbers language-Swift\">enum WorkListCellItem &#123;\n    /// 待收讫\n    case waitingBalance\n    /// 待开单\n    case waitingForBilling\n    /// 待送货\n    case waitingForDelivery\n    /// 待安装\n    case waitingForInstallation\n    /// 待出库\n    case outOfWarehouse\n    /// 待入库\n    case toBeWarehoused\n&#125;\n</code></pre>\n<p>然后在控制器里面声明下全局变量：</p>\n<pre><code class=\"line-numbers language-Swift\"> var pagingView: JXPagingView!\nvar userHeaderView: WorkHeadView!\nvar segmentedViewDataSource: JXSegmentedTitleDataSource!\nvar segmentedView: JXSegmentedView!\nvar JXheightForHeaderInSection: Int = 44\nvar JXTableHeaderViewHeight: Int = 182&#123;\n    didSet&#123;\n        self.pagingView.reloadData()\n    &#125;\n&#125;\n</code></pre>\n<p>这里简单说下这几个成员作用：</p>\n<ul>\n<li>JXPagingView: 这个是最外层的容器，里面有一个mainTableView和listContainerView。</li>\n<li>WorkHeadView: 这个是我们自定义的头部，无需关注。</li>\n<li>JXSegemntedTitleDataSource: 这个主要是tab的数据。</li>\n<li>JXheightForHeaderInSection: 标签栏高度定义。</li>\n<li>JXTableHeaderViewHeight: 头部区域高度定义。</li>\n</ul>\n<p>然后看下如何初始化视图：</p>\n<pre><code class=\"line-numbers language-Swift\">func setUI() &#123;\n\n        view.backgroundColor = UIColor(hex:&quot;#3E4D89&quot;).withAlphaComponent(0.06)\n        view.gm_addSubview(navView) &#123; make in\n            make.top.equalTo(0)\n            make.left.right.equalToSuperview()\n            make.height.equalTo(Height_NavBarAndStatusBar)\n        &#125;\n        \n        /// 头部区域\n        userHeaderView = WorkHeadView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width, height: CGFloat(JXTableHeaderViewHeight)))\n        userHeaderView.eventClosure = &#123; [unowned self] (event) in\n            self.workFunctionItemEventClick(event: event)\n        &#125;\n        userHeaderView.clickMsgHandle = &#123;[weak self] model in\n            self?.requestForClickMsg(model: model)\n        &#125;\n        // 配置指示器\n        let indicator = JXSegmentedIndicatorLineView()\n        // 标签栏下划线\n        indicator.indicatorColor = UIColor(r: 64, g: 158, b: 255, alpha: 1)\n        indicator.indicatorWidthIncrement = -15 /// 作用于增大可触区域\n        /// 标签栏\n        segmentedView = JXSegmentedView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width, height: CGFloat(JXheightForHeaderInSection)))\n        segmentedView.backgroundColor = UIColor.white\n        segmentedView.dataSource = dataSource\n        segmentedView.isContentScrollViewClickTransitionAnimationEnabled = true\n        segmentedView.indicators = [indicator]\n\n        let lineWidth = 1/UIScreen.main.scale\n        let lineLayer = CALayer()\n        lineLayer.backgroundColor = UIColor.lightGray.cgColor\n        lineLayer.frame = CGRect(x: 0, y: segmentedView.bounds.height - lineWidth, width: segmentedView.bounds.width, height: lineWidth)\n        segmentedView.layer.addSublayer(lineLayer)\n\n        pagingView = JXPagingView(delegate: self)\n        let header = GMSAutoRefreshHeader()\n        header.setRefreshingTarget(self, refreshingAction: #selector(defaultTableHeaderRefresh))\n        pagingView.mainTableView.mj_header = header\n        if #available(iOS 15.0, *) &#123;\n            pagingView.mainTableView.sectionHeaderTopPadding = 0\n        &#125; else &#123;\n            // Fallback on earlier ···versions\n        &#125;\n        \n        self.view.addSubview(pagingView)\n\n        segmentedView.listContainer = pagingView.listContainerView\n        \n        self.view.gm_addSubview(stockInitializationTipsView) &#123; make in\n            make.top.equalTo(Height_NavBarAndStatusBar)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(0)\n        &#125;\n        pagingView.snp_makeConstraints &#123; make in\n            make.top.equalTo(stockInitializationTipsView.snp_bottom).offset(0)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(ScreenHeight-Height_NavBarAndStatusBar-Height_TabBar)\n        &#125;\n        \n        /// 待开单列表--取消订单闭包回调\n        self.waitingForBillingVC.cancelBlock = &#123; [weak self] in\n            self?.waitingForBillingVC.requestIntendedOrder()\n        &#125;\n        \n        self.setJXCountBolck()\n        \n        WatermarkView.showWindow()\n    &#125;\n</code></pre>\n<p>这里JXSegmentView主要是标签栏。</p>\n<p>PageView是我们实现这效果的父布局。<br>不出意外，这个PageView里面应该会关联到标签栏。<br>这里有部分代码是这样的：<br><code>segmentedView.listContainer = pagingView.listContainerView</code><br>这里应该就是建立联系了。</p>\n<h3 id=\"3-3-配置代理和数据源\"><a href=\"#3-3-配置代理和数据源\" class=\"headerlink\" title=\"3.3 配置代理和数据源\"></a>3.3 配置代理和数据源</h3><p>前面将delegate设置为self了，所以我们需要看下如何配置的。<br>先看下PageView设置的代理吧：</p>\n<pre><code class=\"line-numbers language-swfit\">extension NewWorkViewController: JXPagingViewDelegate &#123;\n\n    /// tableHeaderView高度\n    func tableHeaderViewHeight(in pagingView: JXPagingView) -&gt; Int &#123;\n        return JXTableHeaderViewHeight\n    &#125;\n\n    /// tableHeaderView\n    func tableHeaderView(in pagingView: JXPagingView) -&gt; UIView &#123;\n        return userHeaderView\n    &#125;\n\n    /// 吸顶标签栏的高度\n    func heightForPinSectionHeader(in pagingView: JXPagingView) -&gt; Int &#123;\n        return JXheightForHeaderInSection\n    &#125;\n\n    /// 吸顶标签栏\n    func viewForPinSectionHeader(in pagingView: JXPagingView) -&gt; UIView &#123;\n        return segmentedView\n    &#125;\n    \n    /// 列表的数量\n    func numberOfLists(in pagingView: JXPagingView) -&gt; Int &#123;\n        return dataSource.attributedTitles.count\n    &#125;\n\n    /// 列表\n    func pagingView(_ pagingView: JXPagingView, initListAtIndex index: Int) -&gt; JXPagingViewListViewDelegate &#123;\n        let flag: WorkListCellItem = self.listDataArray[index]\n        \n        if flag == .waitingBalance &#123;\n            /// 待收讫VC\n            let list = waitingBalanceVC\n            return list\n        &#125;else if flag == .waitingForBilling &#123;\n            /// 待开单VC\n            let list = waitingForBillingVC\n            return list\n        &#125;else if flag == .waitingForDelivery &#123;\n            /// 待送货VC\n            let list = waitingForDeliveryVC\n            return list\n        &#125;else if flag == .waitingForInstallation &#123;\n            /// 待安装VC\n            let list = waitingForInstallationVC\n            return list\n        &#125;else if flag == .outOfWarehouse &#123;\n            /// 待出库VC\n            let list = outOfWarehouseVC\n            return list\n        &#125;else &#123;\n            /// 待入库VC\n            let list = toBeWarehousedVC\n            return list\n        &#125;\n    &#125;\n\n    func mainTableViewDidScroll(_ scrollView: UIScrollView) &#123;\n//        userHeaderView?.scrollViewDidScroll(contentOffsetY: scrollView.contentOffset.y)\n    &#125;\n&#125;\n</code></pre>\n<p>这里配置了头部，高度等。<br>主要的pagingView是需要我们自己实现的，这个就是Tab下方的列表展示了。<br>不出意外这个应该需要继承框架里面的某个View吧。</p>\n<p>我们等下看下waitingForBillingVC吧。</p>\n<p>另外看下标签栏的数据源是怎么设置的：</p>\n<pre><code class=\"line-numbers language-Swift\"> private lazy var dataSource : JXSegmentedTitleAttributeDataSource = &#123;\n        let dataSource = JXSegmentedTitleAttributeDataSource()\n        /// 关闭标签栏等分宽度\n        dataSource.isItemSpacingAverageEnabled = false\n        dataSource.itemSpacing = 0\n        return dataSource\n    &#125;()\n</code></pre>\n<p>这里只是定义了，还需要在需要的地方配置下数据：</p>\n<pre><code class=\"line-numbers language-Swift\">  dataSource.attributedTitles = dataTitles\n  dataSource.selectedAttributedTitles = dataSelectedTitles\n        \n</code></pre>\n<h2 id=\"4-子列表\"><a href=\"#4-子列表\" class=\"headerlink\" title=\"4 子列表\"></a>4 子列表</h2><p>外层框架搭好了，需要看下每个子列表是如何塞进去的。</p>\n<pre><code class=\"line-numbers language-Swift\">// MARK: - 工作台（待开单）\nclass WorkWaitingForBillingVC: AutomaticDimensionTableViewController, JXPagingViewListViewDelegate &#123;\n</code></pre>\n<p>这里其实本质上是一个控制器哦，只是实现了它定义的代理方法即可。<br>这里用了一个我们自己定义的自动高度的控制器，跟这个框架无关哈。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 自动高度 TableView （避免 使用UITableView.automaticDimension 带来的弊端（某些时候 reloadData contentOffSet 会改变 导致闪跳））\n/// 只实现了UITableViewDelegate和高度相关的代理方法，tableview也没有创建，自行按需创建\nclass AutomaticDimensionTableViewController: GMBaseViewController &#123;\n    private var rowHeights = [String: CGFloat]()\n    private var headerHeights = [String: CGFloat]()\n    private var footerHeights = [String: CGFloat]()\n    \n    /// 预估cell高度\n    var rowEstimatedHeight: CGFloat = UITableView.automaticDimension\n    /// 预估header高度\n    var headerEstimatedHeight: CGFloat = 200\n    /// 预估footer高度\n    var footerEstimatedHeight: CGFloat = 200\n\n&#125;\nprivate extension AutomaticDimensionTableViewController &#123;\n    func getRowKeyWithIndexPath(_ indexPath: IndexPath) -&gt; String &#123;\n        let section = indexPath.section\n        let row = indexPath.row\n        let key = &quot;\\(section)-\\(row)&quot;\n        return key\n    &#125;\n&#125;\nextension AutomaticDimensionTableViewController: UITableViewDelegate &#123;\n    func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) &#123;\n        let key = getRowKeyWithIndexPath(indexPath)\n        let height = cell.frame.height\n        rowHeights[key] = height\n    &#125;\n    func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n        let key = getRowKeyWithIndexPath(indexPath)\n        guard let height = rowHeights[key] else &#123; return rowEstimatedHeight &#125;\n        return height\n    &#125;\n    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n        return UITableView.automaticDimension\n    &#125;\n    \n    \n    \n    func tableView(_ tableView: UITableView, willDisplayHeaderView view: UIView, forSection section: Int) &#123;\n        let key = &quot;\\(section)&quot;\n        let height = view.frame.height\n        headerHeights[key] = height\n    &#125;\n    func tableView(_ tableView: UITableView, estimatedHeightForHeaderInSection section: Int) -&gt; CGFloat &#123;\n        let key = &quot;\\(section)&quot;\n        guard let height = headerHeights[key] else &#123; return headerEstimatedHeight &#125;\n        return height\n    &#125;\n    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat &#123;\n        return UITableView.automaticDimension\n    &#125;\n    \n    \n    func tableView(_ tableView: UITableView, willDisplayFooterView view: UIView, forSection section: Int) &#123;\n        let key = &quot;\\(section)&quot;\n        let height = view.frame.height\n        footerHeights[key] = height\n    &#125;\n    func tableView(_ tableView: UITableView, estimatedHeightForFooterInSection section: Int) -&gt; CGFloat &#123;\n        let key = &quot;\\(section)&quot;\n        guard let height = footerHeights[key] else &#123; return footerEstimatedHeight &#125;\n        return height\n    &#125;\n    func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -&gt; CGFloat &#123;\n        return UITableView.automaticDimension\n    &#125;\n&#125;\n</code></pre>\n<p>框架要求的协议需要看下：</p>\n<pre><code class=\"line-numbers language-Swift\">@objc\npublic protocol JXPagingViewListViewDelegate &#123;\n    /// 如果列表是VC，就返回VC.view\n    /// 如果列表是View，就返回View自己\n    ///\n    /// - Returns: 返回列表视图\n    func listView() -&gt; UIView\n    /// 返回listView内部持有的UIScrollView或UITableView或UICollectionView\n    /// 主要用于mainTableView已经显示了header，listView的contentOffset需要重置时，内部需要访问到外部传入进来的listView内的scrollView\n    ///\n    /// - Returns: listView内部持有的UIScrollView或UITableView或UICollectionView\n    func listScrollView() -&gt; UIScrollView\n    /// 当listView内部持有的UIScrollView或UITableView或UICollectionView的代理方法`scrollViewDidScroll`回调时，需要调用该代理方法传入的callback\n    ///\n    /// - Parameter callback: `scrollViewDidScroll`回调时调用的callback\n    func listViewDidScrollCallback(callback: @escaping (UIScrollView)-&gt;())\n\n    /// 将要重置listScrollView的contentOffset\n    @objc optional func listScrollViewWillResetContentOffset()\n    /// 可选实现，列表将要显示的时候调用\n    @objc optional func listWillAppear()\n    /// 可选实现，列表显示的时候调用\n    @objc optional func listDidAppear()\n    /// 可选实现，列表将要消失的时候调用\n    @objc optional func listWillDisappear()\n    /// 可选实现，列表消失的时候调用\n    @objc optional func listDidDisappear()\n&#125;\n</code></pre>\n<p>这里要求我们可以实现这些方法。</p>\n<pre><code class=\"line-numbers language-Swift\">var listViewDidScrollCallback: ((UIScrollView) -&gt; ())?\n    \n    deinit &#123;\n        listViewDidScrollCallback = nil\n    &#125;\n    \n    func listView() -&gt; UIView &#123;\n        return self.view\n    &#125;\n    \n    func listScrollView() -&gt; UIScrollView &#123;\n        return self.mainTableView\n    &#125;\n    \n    func listViewDidScrollCallback(callback: @escaping (UIScrollView) -&gt; ()) &#123;\n        self.listViewDidScrollCallback = callback\n    &#125;\n\n    /// 主列表\n    lazy var mainTableView: UITableView = &#123;\n        let tableView = UITableView(frame: UIScreen.main.bounds, style: .grouped)\n        if #available(iOS 15.0, *) &#123;\n            tableView.sectionHeaderTopPadding = 0\n        &#125; else &#123;\n            // Fallback on earlier ···versions\n        &#125;\n        tableView.separatorStyle = .none\n        tableView.delegate = self\n        tableView.dataSource = self\n        tableView.backgroundColor = .white\n        tableView.showsVerticalScrollIndicator = false\n        tableView.showsHorizontalScrollIndicator = false\n        tableView.tableFooterView = UIView()\n        \n        let footer = GMSAutoRefreshFooter()\n        footer.setRefreshingTarget(self, refreshingAction: #selector(defaultTableFooterRefresh))\n        tableView.mj_footer = footer\n       return tableView\n   &#125;()\n</code></pre>\n<p>这里我们直接把控制的view给他了。<br>这个滚动的视图就是我们自己定义的主列表。</p>\n<p>大致就是这样，使用起来还是简单的。<br>后面有时间再详细看下源码才行。</p>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5 总结\"></a>5 总结</h2><ul>\n<li>本文主要是针对多Tab页，吸顶效果和可分页可滑动的需求，利用一个三方框架完美解决。</li>\n<li>主要通过最外层的JPagingView本质上是UIView来的，设置代理，配置头部区域和中间列表区域显示。通过一个listContainer关联起了标签栏和列表区，这样实现双向交互。</li>\n<li>使用这个框架的工作就是创建这几个View，配置代理，实现代理，最后实现列表的控制器，控制器也需要实现它提供的代理，另外头部也需要我们按照ui要求自己编写即可。</li>\n<li>使用任何一个三方库一定要懂得它的原理，一旦出问题，我们可以游刃而解。</li>\n</ul>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-需求定义\"><a href=\"#1-需求定义\" class=\"headerlink\" title=\"1 需求定义\"></a>1 需求定义</h2><p>在首页，我们需要实现一个多tab页，支持左右滑动，上滑吸顶的效果。<br>比如这样：<br><img src=page1.gif width=50%></p>\n<p>需要保证良好的用户体验效果，每个页面都是独立的，可以上滑吸顶，左右滑动页面切换，而且还需要支持未读数字提示。</p>\n<h2 id=\"2-需求分析\"><a href=\"#2-需求分析\" class=\"headerlink\" title=\"2 需求分析\"></a>2 需求分析</h2><p>针对这些需求，github上面有一个成熟的框架。<br><a href=\"https://github.com/pujiaxin33/JXSegmentedView\">JXsegementedView</a>，github上面有2千多个stars，想必是深受大家喜欢，所以我们也可以考虑用起来。</p>\n<blockquote>\n<p>它的特点是：<br>腾讯新闻、今日头条、QQ音乐、网易云音乐、京东、爱奇艺、腾讯视频、淘宝、天猫、简书、微博等<br>所有主流APP分类切换滚动视图<br>与其他的同类三方库对比的优点：<br>指示器逻辑面向协议编程，可以为所欲为的扩展指示器效果；<br>提供更加全面丰富效果，几乎支持所有主流APP效果；<br>使用子类化管理cell样式，逻辑更清晰，扩展更简单；<br>列表支持整个生命周期方法； </p>\n</blockquote>\n<p>另外一个与之协同的是 <a href=\"https://github.com/pujiaxin33/JXPagingView\">JXPagingView</a> ，注意这两个库不是替换的关系，而是互相协作的关系。</p>\n<blockquote>\n<p>JXPagingView: 类似微博主页、简书主页、QQ联系人页面等效果。多页面嵌套，既可以上下滑动，也可以左右滑动切换页面。支持HeaderView悬浮、支持下拉刷新、上拉加载更多。</p>\n</blockquote>\n<h2 id=\"3-使用步骤\"><a href=\"#3-使用步骤\" class=\"headerlink\" title=\"3 使用步骤\"></a>3 使用步骤</h2><h3 id=\"3-1-引用依赖\"><a href=\"#3-1-引用依赖\" class=\"headerlink\" title=\"3.1 引用依赖\"></a>3.1 引用依赖</h3><p>这里其实可以远程依赖，但我们考虑到自身一些需求，直接拖进项目里面，将github上的source文件，拷贝到项目里面。</p>\n<img src=segment1.png>\n\n<p>注意这个Personal文件夹里面主要放的是JXPagingView相关代码。</p>\n<p>ok，这样项目中可以自由使用了。</p>\n<h3 id=\"3-2-初始化视图相关\"><a href=\"#3-2-初始化视图相关\" class=\"headerlink\" title=\"3.2 初始化视图相关\"></a>3.2 初始化视图相关</h3><pre><code class=\"line-numbers language-Swift\">extension JXPagingListContainerView: JXSegmentedViewListContainer &#123;&#125;\n</code></pre>\n<p>这里我们先扩展下这个协议，这个JXSegementedViewListContainer是框架里面的协议：</p>\n<pre><code class=\"line-numbers language-Swift\">public protocol JXSegmentedViewListContainer &#123;\n    var defaultSelectedIndex: Int &#123; set get &#125;\n    func contentScrollView() -&gt; UIScrollView\n    func reloadData()\n    func didClickSelectedItem(at index: Int)\n&#125;\n</code></pre>\n<p>协议可以理解为Android中的接口。</p>\n<p>然后我们定义了几个tab，枚举类，姑且叫做这个吧：</p>\n<pre><code class=\"line-numbers language-Swift\">enum WorkListCellItem &#123;\n    /// 待收讫\n    case waitingBalance\n    /// 待开单\n    case waitingForBilling\n    /// 待送货\n    case waitingForDelivery\n    /// 待安装\n    case waitingForInstallation\n    /// 待出库\n    case outOfWarehouse\n    /// 待入库\n    case toBeWarehoused\n&#125;\n</code></pre>\n<p>然后在控制器里面声明下全局变量：</p>\n<pre><code class=\"line-numbers language-Swift\"> var pagingView: JXPagingView!\nvar userHeaderView: WorkHeadView!\nvar segmentedViewDataSource: JXSegmentedTitleDataSource!\nvar segmentedView: JXSegmentedView!\nvar JXheightForHeaderInSection: Int = 44\nvar JXTableHeaderViewHeight: Int = 182&#123;\n    didSet&#123;\n        self.pagingView.reloadData()\n    &#125;\n&#125;\n</code></pre>\n<p>这里简单说下这几个成员作用：</p>\n<ul>\n<li>JXPagingView: 这个是最外层的容器，里面有一个mainTableView和listContainerView。</li>\n<li>WorkHeadView: 这个是我们自定义的头部，无需关注。</li>\n<li>JXSegemntedTitleDataSource: 这个主要是tab的数据。</li>\n<li>JXheightForHeaderInSection: 标签栏高度定义。</li>\n<li>JXTableHeaderViewHeight: 头部区域高度定义。</li>\n</ul>\n<p>然后看下如何初始化视图：</p>\n<pre><code class=\"line-numbers language-Swift\">func setUI() &#123;\n\n        view.backgroundColor = UIColor(hex:&quot;#3E4D89&quot;).withAlphaComponent(0.06)\n        view.gm_addSubview(navView) &#123; make in\n            make.top.equalTo(0)\n            make.left.right.equalToSuperview()\n            make.height.equalTo(Height_NavBarAndStatusBar)\n        &#125;\n        \n        /// 头部区域\n        userHeaderView = WorkHeadView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width, height: CGFloat(JXTableHeaderViewHeight)))\n        userHeaderView.eventClosure = &#123; [unowned self] (event) in\n            self.workFunctionItemEventClick(event: event)\n        &#125;\n        userHeaderView.clickMsgHandle = &#123;[weak self] model in\n            self?.requestForClickMsg(model: model)\n        &#125;\n        // 配置指示器\n        let indicator = JXSegmentedIndicatorLineView()\n        // 标签栏下划线\n        indicator.indicatorColor = UIColor(r: 64, g: 158, b: 255, alpha: 1)\n        indicator.indicatorWidthIncrement = -15 /// 作用于增大可触区域\n        /// 标签栏\n        segmentedView = JXSegmentedView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width, height: CGFloat(JXheightForHeaderInSection)))\n        segmentedView.backgroundColor = UIColor.white\n        segmentedView.dataSource = dataSource\n        segmentedView.isContentScrollViewClickTransitionAnimationEnabled = true\n        segmentedView.indicators = [indicator]\n\n        let lineWidth = 1/UIScreen.main.scale\n        let lineLayer = CALayer()\n        lineLayer.backgroundColor = UIColor.lightGray.cgColor\n        lineLayer.frame = CGRect(x: 0, y: segmentedView.bounds.height - lineWidth, width: segmentedView.bounds.width, height: lineWidth)\n        segmentedView.layer.addSublayer(lineLayer)\n\n        pagingView = JXPagingView(delegate: self)\n        let header = GMSAutoRefreshHeader()\n        header.setRefreshingTarget(self, refreshingAction: #selector(defaultTableHeaderRefresh))\n        pagingView.mainTableView.mj_header = header\n        if #available(iOS 15.0, *) &#123;\n            pagingView.mainTableView.sectionHeaderTopPadding = 0\n        &#125; else &#123;\n            // Fallback on earlier ···versions\n        &#125;\n        \n        self.view.addSubview(pagingView)\n\n        segmentedView.listContainer = pagingView.listContainerView\n        \n        self.view.gm_addSubview(stockInitializationTipsView) &#123; make in\n            make.top.equalTo(Height_NavBarAndStatusBar)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(0)\n        &#125;\n        pagingView.snp_makeConstraints &#123; make in\n            make.top.equalTo(stockInitializationTipsView.snp_bottom).offset(0)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(ScreenHeight-Height_NavBarAndStatusBar-Height_TabBar)\n        &#125;\n        \n        /// 待开单列表--取消订单闭包回调\n        self.waitingForBillingVC.cancelBlock = &#123; [weak self] in\n            self?.waitingForBillingVC.requestIntendedOrder()\n        &#125;\n        \n        self.setJXCountBolck()\n        \n        WatermarkView.showWindow()\n    &#125;\n</code></pre>\n<p>这里JXSegmentView主要是标签栏。</p>\n<p>PageView是我们实现这效果的父布局。<br>不出意外，这个PageView里面应该会关联到标签栏。<br>这里有部分代码是这样的：<br><code>segmentedView.listContainer = pagingView.listContainerView</code><br>这里应该就是建立联系了。</p>\n<h3 id=\"3-3-配置代理和数据源\"><a href=\"#3-3-配置代理和数据源\" class=\"headerlink\" title=\"3.3 配置代理和数据源\"></a>3.3 配置代理和数据源</h3><p>前面将delegate设置为self了，所以我们需要看下如何配置的。<br>先看下PageView设置的代理吧：</p>\n<pre><code class=\"line-numbers language-swfit\">extension NewWorkViewController: JXPagingViewDelegate &#123;\n\n    /// tableHeaderView高度\n    func tableHeaderViewHeight(in pagingView: JXPagingView) -&gt; Int &#123;\n        return JXTableHeaderViewHeight\n    &#125;\n\n    /// tableHeaderView\n    func tableHeaderView(in pagingView: JXPagingView) -&gt; UIView &#123;\n        return userHeaderView\n    &#125;\n\n    /// 吸顶标签栏的高度\n    func heightForPinSectionHeader(in pagingView: JXPagingView) -&gt; Int &#123;\n        return JXheightForHeaderInSection\n    &#125;\n\n    /// 吸顶标签栏\n    func viewForPinSectionHeader(in pagingView: JXPagingView) -&gt; UIView &#123;\n        return segmentedView\n    &#125;\n    \n    /// 列表的数量\n    func numberOfLists(in pagingView: JXPagingView) -&gt; Int &#123;\n        return dataSource.attributedTitles.count\n    &#125;\n\n    /// 列表\n    func pagingView(_ pagingView: JXPagingView, initListAtIndex index: Int) -&gt; JXPagingViewListViewDelegate &#123;\n        let flag: WorkListCellItem = self.listDataArray[index]\n        \n        if flag == .waitingBalance &#123;\n            /// 待收讫VC\n            let list = waitingBalanceVC\n            return list\n        &#125;else if flag == .waitingForBilling &#123;\n            /// 待开单VC\n            let list = waitingForBillingVC\n            return list\n        &#125;else if flag == .waitingForDelivery &#123;\n            /// 待送货VC\n            let list = waitingForDeliveryVC\n            return list\n        &#125;else if flag == .waitingForInstallation &#123;\n            /// 待安装VC\n            let list = waitingForInstallationVC\n            return list\n        &#125;else if flag == .outOfWarehouse &#123;\n            /// 待出库VC\n            let list = outOfWarehouseVC\n            return list\n        &#125;else &#123;\n            /// 待入库VC\n            let list = toBeWarehousedVC\n            return list\n        &#125;\n    &#125;\n\n    func mainTableViewDidScroll(_ scrollView: UIScrollView) &#123;\n//        userHeaderView?.scrollViewDidScroll(contentOffsetY: scrollView.contentOffset.y)\n    &#125;\n&#125;\n</code></pre>\n<p>这里配置了头部，高度等。<br>主要的pagingView是需要我们自己实现的，这个就是Tab下方的列表展示了。<br>不出意外这个应该需要继承框架里面的某个View吧。</p>\n<p>我们等下看下waitingForBillingVC吧。</p>\n<p>另外看下标签栏的数据源是怎么设置的：</p>\n<pre><code class=\"line-numbers language-Swift\"> private lazy var dataSource : JXSegmentedTitleAttributeDataSource = &#123;\n        let dataSource = JXSegmentedTitleAttributeDataSource()\n        /// 关闭标签栏等分宽度\n        dataSource.isItemSpacingAverageEnabled = false\n        dataSource.itemSpacing = 0\n        return dataSource\n    &#125;()\n</code></pre>\n<p>这里只是定义了，还需要在需要的地方配置下数据：</p>\n<pre><code class=\"line-numbers language-Swift\">  dataSource.attributedTitles = dataTitles\n  dataSource.selectedAttributedTitles = dataSelectedTitles\n        \n</code></pre>\n<h2 id=\"4-子列表\"><a href=\"#4-子列表\" class=\"headerlink\" title=\"4 子列表\"></a>4 子列表</h2><p>外层框架搭好了，需要看下每个子列表是如何塞进去的。</p>\n<pre><code class=\"line-numbers language-Swift\">// MARK: - 工作台（待开单）\nclass WorkWaitingForBillingVC: AutomaticDimensionTableViewController, JXPagingViewListViewDelegate &#123;\n</code></pre>\n<p>这里其实本质上是一个控制器哦，只是实现了它定义的代理方法即可。<br>这里用了一个我们自己定义的自动高度的控制器，跟这个框架无关哈。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 自动高度 TableView （避免 使用UITableView.automaticDimension 带来的弊端（某些时候 reloadData contentOffSet 会改变 导致闪跳））\n/// 只实现了UITableViewDelegate和高度相关的代理方法，tableview也没有创建，自行按需创建\nclass AutomaticDimensionTableViewController: GMBaseViewController &#123;\n    private var rowHeights = [String: CGFloat]()\n    private var headerHeights = [String: CGFloat]()\n    private var footerHeights = [String: CGFloat]()\n    \n    /// 预估cell高度\n    var rowEstimatedHeight: CGFloat = UITableView.automaticDimension\n    /// 预估header高度\n    var headerEstimatedHeight: CGFloat = 200\n    /// 预估footer高度\n    var footerEstimatedHeight: CGFloat = 200\n\n&#125;\nprivate extension AutomaticDimensionTableViewController &#123;\n    func getRowKeyWithIndexPath(_ indexPath: IndexPath) -&gt; String &#123;\n        let section = indexPath.section\n        let row = indexPath.row\n        let key = &quot;\\(section)-\\(row)&quot;\n        return key\n    &#125;\n&#125;\nextension AutomaticDimensionTableViewController: UITableViewDelegate &#123;\n    func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) &#123;\n        let key = getRowKeyWithIndexPath(indexPath)\n        let height = cell.frame.height\n        rowHeights[key] = height\n    &#125;\n    func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n        let key = getRowKeyWithIndexPath(indexPath)\n        guard let height = rowHeights[key] else &#123; return rowEstimatedHeight &#125;\n        return height\n    &#125;\n    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n        return UITableView.automaticDimension\n    &#125;\n    \n    \n    \n    func tableView(_ tableView: UITableView, willDisplayHeaderView view: UIView, forSection section: Int) &#123;\n        let key = &quot;\\(section)&quot;\n        let height = view.frame.height\n        headerHeights[key] = height\n    &#125;\n    func tableView(_ tableView: UITableView, estimatedHeightForHeaderInSection section: Int) -&gt; CGFloat &#123;\n        let key = &quot;\\(section)&quot;\n        guard let height = headerHeights[key] else &#123; return headerEstimatedHeight &#125;\n        return height\n    &#125;\n    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat &#123;\n        return UITableView.automaticDimension\n    &#125;\n    \n    \n    func tableView(_ tableView: UITableView, willDisplayFooterView view: UIView, forSection section: Int) &#123;\n        let key = &quot;\\(section)&quot;\n        let height = view.frame.height\n        footerHeights[key] = height\n    &#125;\n    func tableView(_ tableView: UITableView, estimatedHeightForFooterInSection section: Int) -&gt; CGFloat &#123;\n        let key = &quot;\\(section)&quot;\n        guard let height = footerHeights[key] else &#123; return footerEstimatedHeight &#125;\n        return height\n    &#125;\n    func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -&gt; CGFloat &#123;\n        return UITableView.automaticDimension\n    &#125;\n&#125;\n</code></pre>\n<p>框架要求的协议需要看下：</p>\n<pre><code class=\"line-numbers language-Swift\">@objc\npublic protocol JXPagingViewListViewDelegate &#123;\n    /// 如果列表是VC，就返回VC.view\n    /// 如果列表是View，就返回View自己\n    ///\n    /// - Returns: 返回列表视图\n    func listView() -&gt; UIView\n    /// 返回listView内部持有的UIScrollView或UITableView或UICollectionView\n    /// 主要用于mainTableView已经显示了header，listView的contentOffset需要重置时，内部需要访问到外部传入进来的listView内的scrollView\n    ///\n    /// - Returns: listView内部持有的UIScrollView或UITableView或UICollectionView\n    func listScrollView() -&gt; UIScrollView\n    /// 当listView内部持有的UIScrollView或UITableView或UICollectionView的代理方法`scrollViewDidScroll`回调时，需要调用该代理方法传入的callback\n    ///\n    /// - Parameter callback: `scrollViewDidScroll`回调时调用的callback\n    func listViewDidScrollCallback(callback: @escaping (UIScrollView)-&gt;())\n\n    /// 将要重置listScrollView的contentOffset\n    @objc optional func listScrollViewWillResetContentOffset()\n    /// 可选实现，列表将要显示的时候调用\n    @objc optional func listWillAppear()\n    /// 可选实现，列表显示的时候调用\n    @objc optional func listDidAppear()\n    /// 可选实现，列表将要消失的时候调用\n    @objc optional func listWillDisappear()\n    /// 可选实现，列表消失的时候调用\n    @objc optional func listDidDisappear()\n&#125;\n</code></pre>\n<p>这里要求我们可以实现这些方法。</p>\n<pre><code class=\"line-numbers language-Swift\">var listViewDidScrollCallback: ((UIScrollView) -&gt; ())?\n    \n    deinit &#123;\n        listViewDidScrollCallback = nil\n    &#125;\n    \n    func listView() -&gt; UIView &#123;\n        return self.view\n    &#125;\n    \n    func listScrollView() -&gt; UIScrollView &#123;\n        return self.mainTableView\n    &#125;\n    \n    func listViewDidScrollCallback(callback: @escaping (UIScrollView) -&gt; ()) &#123;\n        self.listViewDidScrollCallback = callback\n    &#125;\n\n    /// 主列表\n    lazy var mainTableView: UITableView = &#123;\n        let tableView = UITableView(frame: UIScreen.main.bounds, style: .grouped)\n        if #available(iOS 15.0, *) &#123;\n            tableView.sectionHeaderTopPadding = 0\n        &#125; else &#123;\n            // Fallback on earlier ···versions\n        &#125;\n        tableView.separatorStyle = .none\n        tableView.delegate = self\n        tableView.dataSource = self\n        tableView.backgroundColor = .white\n        tableView.showsVerticalScrollIndicator = false\n        tableView.showsHorizontalScrollIndicator = false\n        tableView.tableFooterView = UIView()\n        \n        let footer = GMSAutoRefreshFooter()\n        footer.setRefreshingTarget(self, refreshingAction: #selector(defaultTableFooterRefresh))\n        tableView.mj_footer = footer\n       return tableView\n   &#125;()\n</code></pre>\n<p>这里我们直接把控制的view给他了。<br>这个滚动的视图就是我们自己定义的主列表。</p>\n<p>大致就是这样，使用起来还是简单的。<br>后面有时间再详细看下源码才行。</p>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5 总结\"></a>5 总结</h2><ul>\n<li>本文主要是针对多Tab页，吸顶效果和可分页可滑动的需求，利用一个三方框架完美解决。</li>\n<li>主要通过最外层的JPagingView本质上是UIView来的，设置代理，配置头部区域和中间列表区域显示。通过一个listContainer关联起了标签栏和列表区，这样实现双向交互。</li>\n<li>使用这个框架的工作就是创建这几个View，配置代理，实现代理，最后实现列表的控制器，控制器也需要实现它提供的代理，另外头部也需要我们按照ui要求自己编写即可。</li>\n<li>使用任何一个三方库一定要懂得它的原理，一旦出问题，我们可以游刃而解。</li>\n</ul>\n"},{"title":"iOS swift 数据库realm实践","date":"2023-01-30T08:38:21.000Z","top":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 需求定义\n\n需要获取服务端的条码数据库，存放到本地数据库。\n\n背景：集成了扫码功能，扫到的条码头需要匹配数据库中的条码列表，可以认为这个是一个离线数据库。不会实时判断，因为条码很多，这里先获取所有的条码，存放到本地数据库。然后扫码就按照数据库中的关系表来匹配就好了。\n\n这里我们有两个表，一个商品库表，一个是关系表。为什么有2个表呢？因为我们有配套的关系，2个零件可以看做单个商品，他们组合了也可以看成单独商品哦，这种就是套机了。想必做个电商的人都懂这个道理。比如可以买一件上衣，一条裤子，它们都是独立商品，也可以配套组合一套商品，而且这一套也可以认为是一个商品。\n\n\n## 2 需求分析\n\n这里我们采用 realm数据库。\nrealm非常简介，效率也是不错的。\ngithub地址：[https://github.com/realm/realm-swift](https://github.com/realm/realm-swift)\n\n简单描述下realm吧：Realm 是一个跨平台的移动数据库引擎，其性能要优于 Core Data 和 FMDB - 移动端数据库性能比较, 我们可以在 Android 端 realm-java，iOS端:Realm-Cocoa，同时支持 OC 和 Swift两种语言开发。其使用简单，免费，性能优异，跨平台的特点广受关注。\n\n这里我们会用到2个表。\n\n因为这是个离线数据库，我们需要考虑数据库变更，与服务端同步问题。\n所以我们需要一个接口，判断有无新增或者变更的数据。\n\n需要考虑到增量更新，同时如果数据变更大于一个阙值，比如1000条数据，我们可以认为是全量更新。这时候全量更新的时间和增量插入数据时间几乎相同。\n\n另外如果第一次获取数据，数据量可能会很大，我们需要考虑压缩，与服务端商议，将json数据压缩，然后我们自行解析为实体类。\n\n另外增量更新的时候，要特别注意改数据是删除了还是新增的，还是变更的。\n如果商品删除了，关系表也是要删除的哦。这点很重要，不然后期会导致匹配异常。\n\n\n## 3 准备工作，会用Realm\n\n因为是从0开始，建议熟悉一下Realm使用方法。\n可以参考下这篇博客：[https://juejin.cn/post/6844904117442215944](https://juejin.cn/post/6844904117442215944),写得还是相当不错，有Demo，讲述得非常清晰易懂。\n\n这里就不讲解如何引用这个Realm了。\n\n这里需要会用一个工具：Realm Studio，\n下载地址：[https://www.mongodb.com/docs/realm/studio/install/](https://www.mongodb.com/docs/realm/studio/install/)\n这里按照自己电脑版本下载相应软件就好了，这个也是免费的。\n\n如何分析真机里面的realm数据库呢？\n可以参考下：[https://blog.csdn.net/asfasnjn/article/details/124714242](https://blog.csdn.net/asfasnjn/article/details/124714242) 很简单，打开XCode的window下的设备和模拟器，再 点击更多图标，再下载Container，然后下载后，查看包内容，就可以看到这个应用的realm文件了。然后可以右键，用我们下载好的Realm Studio来查看这个文件，文件以表格形式展示，清晰直观。\n\n## 4 初始化配置数据库\n\n这里需要在AppDelegate中配置下realm数据库。\n很简单的。\n不过我们没有在AppDelegate初始化，因为我们这个绑定了userId，等用户登录后才初始化，当然也是可以的。\n\n重点是初始化这个动作要先于使用就行了。\n```Swift\nfunc configRealm(userID: String?,\n                        keyWord: String? = nil,\n                        schemaVersion: UInt64 = 2, migrationBlock: MigrationBlock? = nil) {\n    // 加密串128位结果为：464e5774625e64306771702463336e316a4074487442325145766477335e21346b715169364c406c6a4976346d695958396245346e356f6a62256d2637566126\n    // let key: Data = \"FNWtb^d0gqp$c3n1j@tHtB2QEvdw3^!4kqQi6L@ljIv4miYX9bE4n5ojb%m&7Va&\".data(using: .utf8, allowLossyConversion: false)!\n    // 加密的key\n    // let key: Data = keyWord.data(using: .utf8, allowLossyConversion: false)!\n    // 打开加密文件\n    // (encryptionKey: key)\n    // 使用默认的目录，但是使用用户 ID 来替换默认的文件名\n    \n    //schemaVersion 数据库版本号从0开始\n    let manager = FileManager.default\n    let document = manager.urls(for: .documentDirectory, in: .userDomainMask)\n    let url = document[0] as URL\n    let urlStr = url.absoluteString\n    let path = urlStr + \"/\" + (\"\\(userID!).realm\")\n    let config = Realm.Configuration(fileURL: URL(string: path), schemaVersion: schemaVersion, migrationBlock: { (migration, oldSchemaVersion) in\n        // 目前我们还未进行数据迁移，因此 oldSchemaVersion == 0\n        if oldSchemaVersion < 100 {\n            // 什么都不要做！Realm 会自行检测新增和需要移除的属性，然后自动更新硬盘上的数据库架构\n            // 属性重命名  migration.renameProperty(onType: Person.className(), from: \"yearsSinceBirth\", to: \"age\")\n            print(oldSchemaVersion)\n            print(\"end\")\n        }\n        // 低版本的数据库迁移......\n        if migrationBlock != nil {\n            migrationBlock!(migration, oldSchemaVersion)\n        }\n    })\n    // 告诉 Realm 为默认的 Realm 数据库使用这个新的配置对象\n    Realm.Configuration.defaultConfiguration = config\n    guard let realm = try? Realm(configuration: config) else {\n        return\n    }\n    currentSchemaVersion = schemaVersion\n    currentRealm = realm\n    currentKeyWord = keyWord\n}\n```\n这个realm实际上以userId为名称了。\n这样就有个弊端了，切换用户后，需要重新下载数据库，特别是数据库特别大的情况下，这对用户体验不是特别好。\n\n\n## 5 走接口拿数据\n\n这里就是拿商品数据了，这里服务端提供的接口，返回的是加密后的字符串。\n类似这样：\n```Json\n{\n  \"message\" : \"请求成功\",\n  \"code\" : 1000,\n  \"data\" : \"H4sIAAAAAAAAAKtWSiwoCCjKTylNLglKzQnz98ksLlGyio7VQZJAFk3OzytJzQ\n  NyDA2NdJRKC1IS\\nS1JDMnNTlayUjAyMjHUNDHWNLBUMTaxMzaxMDJVqAQ0XaZphAAAA\"\n}\n```\n\n比如我们接口是这样请求的，这里我们先扩展了一个方法给控制器：\n```Swift\nextension GMBaseViewController {\n    \n    open func updateOfflinePackageData(tips: String = \"\", successful: @escaping Handler) {\n        MBProgressHUD.showMessage(tips)\n        OfflinePackageManager.update {\n            successful()\n            MBProgressHUD.hide()\n            MBProgressHUD.hide()\n        } failure: {\n            MBProgressHUD.hide()\n            MBProgressHUD.hide()\n            let alerVC = UIAlertController(\n                title: \"\",\n                message: \"检测到商品信息变动，系统为您自动更新商品信息失败，请在网络良好的环境下，手动更新商品信息\",\n                preferredStyle: .alert\n            )\n            alerVC.addAction(\n                UIAlertAction(\n                    title: \"下载商品信息\",\n                    style: .default\n                ) { (action) in\n                    self.updateOfflinePackageData(successful: successful)\n                }\n            )\n            self.present(alerVC, animated: true, completion:nil)\n        }\n        \n    }\n    \n}\n```\n这里我们的OfflinePackageManager就是我们封装好的专门去下载离线库的工具类。\n成功后走successful的逃逸闭包，失败弹一个弹框。\n\n继续走进去：\n```Swift\nclass OfflinePackageManager: NSObject {\n    \n    open class func update(\n        updateTime: String = Defaults[key: DefaultsKeys.updateTime] ?? \"\",\n        successful: @escaping Handler,\n        failure: @escaping Handler\n    ) {\n        let endTimeStr = Defaults[key: DefaultsKeys.updateTime]\n        let updateTimeStr = updateTime\n       \n        productProvider.requestJson(.getProductMetadataForAPP(updateTime: updateTimeStr)) { response in\n            let jsonString = JSON(rawValue: response).jsonString\n            let result = GMBaseRequestModel.deserialize(from: jsonString)\n            if result?.code == 1000 {\n                guard let data = result?.data?.gunzip?.data(using: .utf8) else { return }\n                \n                let file = \"zpi_offline_package_data.txt\"\n                let text = result?.data?.gunzip ?? \"\"\n                \n                if let dir = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first {\n                    let fileURL = dir.appendingPathComponent(file)\n                    do {\n                        try text.write(to: fileURL, atomically: false, encoding: .utf8)\n                    } catch {}\n                }\n                \n                guard let model = try? JSONDecoder().decode(StageOfflinePackageData.self, from: data) else { return }\n                \n                if endTimeStr != nil && (model.appProductVOList.count >= 1000 || model.appProductRelVOList.count >= 1000) {\n                    Defaults[key:DefaultsKeys.updateTime] = nil\n                    OfflinePackageManager.update(updateTime: \"\", successful: successful, failure: failure)\n                } else {\n                    if endTimeStr == nil {\n                        OfflinePackageManager.fullUpdate(model: model)\n                    } else {\n                        OfflinePackageManager.incrementalUpdate(model: model)\n                    }\n                    Defaults[key: DefaultsKeys.updateTime] = model.updateTime\n                    successful()\n                }\n            } else {\n                failure()\n            }\n        } failure: { _ in\n            failure()\n        }\n    }\n```\n\n## 6 解压缩字符串\n\n这里服务端返回的一段加密后的字符串：\n```Json\n{\n  \"message\" : \"请求成功\",\n  \"code\" : 1000,\n  \"data\" : \"H4sIAAAAAAAAAKtWSiwoCCjKTylNLglKzQnz98ksLlGyio7VQZJAFk3OzytJzQNyDA2NdJRKC1IS\\nS1JDMnNTlayUjAyMjHUNDHWNLBUMTaxMzaxMDJVqAQ0XaZphAAAA\"\n}\n```\n不过返回体还是json，我们先拿data里面的字符串。\n再去解压缩。\n\n字符串解压缩可以参考这篇文章：[https://www.cnblogs.com/strengthen/p/10844466.html](https://www.cnblogs.com/strengthen/p/10844466.html)\n\n这里我们用到了GzipSwift框架。\n\n这个框架地址为：[https://github.com/1024jp/GzipSwift](https://github.com/1024jp/GzipSwift) 还是有挺多人star的。\n\n具体细节就不讲解了。\n\n这里我们自己给String做了一个扩展，这样直接能拿到解压缩后的字符串：\n```Swift\nextension String {\n    var gunzip: String? {\n        if let data = Data(base64Encoded: self, options: .ignoreUnknownCharacters) {\n            if data.isGzipped {\n                if let gun = try? data.gunzipped() {\n                    return String(data: gun, encoding: String.Encoding.utf8)\n                }\n            }\n        }\n        return nil\n    }\n}\n```\n\n这里解析后的字符串为：\n```Json\n{\n    \"appProductRelVOList\":[],\n    \"appProductVOList\":[],\n    \"content\":112,\n    \"updateTime\":\"2023-01-29 14:56:41\"\n}\n```\n\n同样也是一个json数组哦。\n所以我们还是得用Json解析下：\n```Swift\nguard let model = try? JSONDecoder().decode(StageOfflinePackageData.self, from: data)\n                else { return }\n```\n\n这时候我们需要一个实体来接收下：\n```Swift\nclass StageOfflinePackageData:Codable{\n    \n    var appProductVOList: [StageGoodsPackgeModelData] = []\n    \n    var appProductRelVOList: [StageGoodsSuitPackgeModelData] = []\n    \n    var updateTime: String = \"\"\n    \n    \n    private enum Codingkeys: String, CodingKey{\n        case appProductVOList,appProductRelVOList,updateTime\n    }\n    \n    func encode(to encoder: Encoder) throws {}\n    \n    required init(from decoder: Decoder) throws {\n        let values = try decoder.container(keyedBy: Codingkeys.self)\n        appProductVOList = try values.decode(Array.self, forKey: .appProductVOList)\n        appProductRelVOList = try values.decode(Array.self, forKey: .appProductRelVOList)\n        updateTime = try values.decode(String.self, forKey: .updateTime)\n    }\n}\n```\n为啥要继承Codable呢？\nCodable 协议在 Swift4.0 开始被引入，目标是取代现有的 NSCoding 协议，它对结构体，枚举和类都支持。Codable 的引入简化了JSON 和 Swift 类型之间相互转换的难度，能够把 JSON 这种弱类型数据转换成代码中使用的强类型数据。具体可以看这篇文章：[https://juejin.cn/post/6971997599725256734](https://juejin.cn/post/6971997599725256734)。\n\n\n解析后就拿到服务端的数据了，可能是增量数据，可能是全量数据。后面我们具体分析下。\n\n\n## 7 数据处理\n\n解析完毕后，我们有一段逻辑是这样的：\n```Swift\nif endTimeStr != nil && (model.appProductVOList.count >= 1000 || model.appProductRelVOList.count >= 1000) {\n                    Defaults[key:DefaultsKeys.updateTime] = nil\n                    OfflinePackageManager.update(updateTime: \"\", successful: successful, failure: failure)\n                } else {\n                    if endTimeStr == nil {\n                        OfflinePackageManager.fullUpdate(model: model)\n                    } else {\n                        OfflinePackageManager.incrementalUpdate(model: model)\n                    }\n                    Defaults[key: DefaultsKeys.updateTime] = model.updateTime\n                    successful()\n                }\n```\n\n这里如果数据大于1000条，我们重新走全量更新接口。\n如果上次更新时间为空，我们默认为全量更新，将所有数据插入数据库。\n如果上次更新时间不为空，而且小于1000条，我们就走增量更新逻辑。\n\n### 7.1 Model层定义\n\n这里是定义的Realm的基础模型。\n\n我们需要定义两个实体，一个是商品模型，一个是关系模型。\n\n商品模型为：\n```Swift\n\nclass StageGoodsPackgeModelData: Object,Codable{\n    \n    @objc dynamic var barcode: String = \"\"\n    @objc dynamic var brand: String = \"\"\n    @objc dynamic var brandId: String = \"\"\n    @objc dynamic var category: String = \"\"\n    @objc dynamic var categoryId: Int = 0\n    @objc dynamic var createBy: String = \"\"\n    @objc dynamic var createTime: String = \"\"\n    @objc dynamic var delFlag: Int = 0\n    @objc dynamic var groupNum: Int = 1         //返回为\"\"时服务器需要传1\n    @objc dynamic var id: String = \"\"\n    @objc dynamic var isGreeProduct: Bool = false\n    @objc dynamic var isGroupedProduct: Bool = false\n    @objc dynamic var isSaleProduct: Bool = false\n    @objc dynamic var length: Double = 0.0\n    @objc dynamic var name: String = \"\"\n    @objc dynamic var orgId: String = \"\"\n    @objc dynamic var skuCode: String = \"\"\n    @objc dynamic var tall: Double = 0\n    @objc dynamic var unit: String = \"\"\n    @objc dynamic var updateBy: String = \"\"\n    @objc dynamic var updateTime: String = \"\"\n    @objc dynamic var volume: Double = 0.0\n    @objc dynamic var weight: Double = 0.0\n    @objc dynamic var wide: Double = 0.0\n    @objc dynamic var isMarketingProduct :Bool = false\n    \n    private enum Codingkeys: String, CodingKey{\n        case barcode\n        ,brand\n        ,brandId\n        ,category\n        ,categoryId\n        ,createBy\n        ,createTime\n        ,delFlag\n        ,groupNum\n        ,id\n        ,isGreeProduct\n        ,isGroupedProduct\n        ,isSaleProduct\n        ,length\n        ,name\n        ,orgId\n        ,skuCode\n        ,tall\n        ,unit\n        ,updateBy\n        ,updateTime\n        ,volume\n        ,weight\n        ,wide,\n        isMarketingProduct\n    }\n    \n    \n    required init(from decoder: Decoder) throws {\n        let values = try decoder.container(keyedBy: Codingkeys.self)\n        \n        do {\n            barcode = try values.decode(String.self, forKey: .barcode)\n        } catch {\n            barcode = \"\"\n        }\n        do {\n            brand = try values.decode(String.self, forKey: .brand)\n        } catch {\n            brand = \"\"\n        }\n        do {\n            brandId = try values.decode(String.self, forKey: .brandId)\n        } catch {\n            brandId = \"\"\n        }\n        do {\n            category = try values.decode(String.self, forKey: .category)\n        } catch {\n            category = \"\"\n        }\n        do {\n            categoryId = try values.decode(Int.self, forKey: .categoryId)\n        } catch {\n            categoryId = 0\n        }\n        do {\n            createBy = try values.decode(String.self, forKey: .createBy)\n        } catch {\n            createBy = \"\"\n        }\n        do {\n            createTime = try values.decode(String.self, forKey: .createTime)\n        } catch {\n            createTime = \"\"\n        }\n        do {\n            delFlag = try values.decode(Int.self, forKey: .delFlag)\n        } catch {\n            delFlag = 0\n        }\n        do {\n            groupNum = try values.decode(Int.self, forKey: .groupNum)\n        } catch {\n            groupNum = 1\n        }\n        do {\n            id = try values.decode(String.self, forKey: .id)\n        } catch {\n            id = \"\"\n        }\n        do {\n            isGreeProduct = try values.decode(Bool.self, forKey: .isGreeProduct)\n        } catch {\n            isGreeProduct = false\n        }\n        do {\n            isGroupedProduct = try values.decode(Bool.self, forKey: .isGroupedProduct)\n        } catch {\n            isGroupedProduct = false\n        }\n        do {\n            isSaleProduct = try values.decode(Bool.self, forKey: .isSaleProduct)\n        } catch {\n            isSaleProduct = false\n        }\n        do {\n            length = try values.decode(CGFloat.self, forKey: .length)\n        } catch {\n            length = 0.0\n        }\n        do {\n            name = try values.decode(String.self, forKey: .name)\n        } catch {\n            name = \"\"\n        }\n        do {\n            orgId = try values.decode(String.self, forKey: .orgId)\n        } catch {\n            orgId = \"\"\n        }\n        do {\n            skuCode = try values.decode(String.self, forKey: .skuCode)\n        } catch {\n            skuCode = \"\"\n        }\n        do {\n            tall = try values.decode(Double.self, forKey: .tall)\n        } catch {\n            tall = 0\n        }\n        do {\n            unit = try values.decode(String.self, forKey: .unit)\n        } catch {\n            unit = \"\"\n        }\n        do {\n            updateBy =  try values.decode(String.self, forKey: .updateBy)\n        } catch {\n            updateBy = \"\"\n        }\n        do {\n            updateTime = try values.decode(String.self, forKey: .updateTime)\n        } catch {\n            updateTime = \"\"\n        }\n        do {\n            volume = try values.decode(Double.self, forKey: .volume)\n        } catch {\n            volume = 0.0\n        }\n        do {\n            weight = try values.decode(Double.self, forKey: .weight)\n        } catch {\n            weight = 0.0\n        }\n        do {\n            wide = try values.decode(Double.self, forKey: .wide)\n        } catch {\n            wide = 0.0\n        }\n        do {\n            isMarketingProduct = try values.decode(Bool.self, forKey: .isMarketingProduct)\n        } catch {\n            isMarketingProduct = false\n        }\n    }\n    \n    func encode(to encoder: Encoder) throws {}\n    \n    override required init(){}\n}\n```\n\n另外一个为：\n```Swift\n\nclass StageGoodsSuitPackgeModelData: Object,Codable{\n\n    @objc dynamic var groupNum: Int = 0\n    @objc dynamic var id: String = \"\"\n    @objc dynamic var orgId: String = \"\"\n    @objc dynamic var productId: String = \"\"\n    @objc dynamic var subProductId: String = \"\"\n    \n    private enum Codingkeys: String, CodingKey {\n        case groupNum\n        case id\n        case orgId\n        case productId\n        case subProductId\n    }\n\n    required init(from decoder: Decoder) throws {\n        let values = try decoder.container(keyedBy: Codingkeys.self)\n        \n        do {\n            groupNum = try values.decode(Int.self, forKey: .groupNum)\n        } catch {\n            groupNum = 0\n        }\n        do {\n            id = try values.decode(String.self, forKey: .id)\n        } catch {\n            id = \"\"\n        }\n        do {\n            orgId = try values.decode(String.self, forKey: .orgId)\n        } catch {\n            orgId = \"\"\n        }\n        do {\n            productId = try values.decode(String.self, forKey: .productId)\n        } catch {\n            productId = \"\"\n        }\n        do {\n            subProductId = try values.decode(String.self, forKey: .subProductId)\n        } catch {\n            subProductId = \"\"\n        }\n    }\n\n    func encode(to encoder: Encoder) throws {}\n    \n    override required init(){}\n}\n```\n\n### 7.2 全量更新\n\n```Swift\nprivate class func fullUpdate(model: StageOfflinePackageData) {\n        let suitResult = objectWithAll(objct: StageGoodsPackgeModelData.self)\n        if suitResult.count != 0 {\n            deleteList(suitResult) {\n                print(\"StageGoodsPackgeModelData表数据清除成功\")\n            }\n        }\n        addList(model.appProductVOList) {\n            print(\"StageGoodsPackgeModelData 插入成功\")\n        }\n        \n        let relationResult = objectWithAll(objct: StageGoodsSuitPackgeModelData.self)\n        if relationResult.count != 0 {\n            deleteList(relationResult) {\n                print(\"StageGoodsSuitPackgeModelData表数据清除成功\")\n            }\n        }\n        addList(model.appProductRelVOList) {\n            print(\"StageGoodsSuitPackgeModelData 插入成功\")\n        }\n    }\n```\n如果是全量更新就比较简单了。\n先把之前的那两个删除掉，然后新增新的model就好了。\n\n### 7.3 增量更新\n\n先声明一下sql\n```Swift\n    private class func incrementalUpdate(model: StageOfflinePackageData) {\n        print(\"增量处理开始时间---->\", Date().currentTime(0))\n        var addGoodsArr: [StageGoodsPackgeModelData] = []\n        var addRelationsArr: [StageGoodsSuitPackgeModelData] = []\n        var relationidArr: [String] = []\n        \n        var goodsSql = \"\"\n        var relationSql = \"\"\n        var deleteGoodsSql = \"\"\n        var deleteRelationSql = \"\"\n```\n\n遍历下服务端返回的增量数据库：\n```Swift\nfor (_,suitModel) in model.appProductVOList.enumerated() {\n    // delFlag为0表示，不是删除哦，这里是新增商品\n    if suitModel.delFlag == 0 {\n        if goodsSql == \"\" {\n            let str1 = String(format:\"id = '%@'\", suitModel.id)\n            let str2 = String(format:\"productId = '%@'\", suitModel.id)\n            goodsSql.append(str1)\n            relationSql.append(str2)\n        } else {\n            let str1 = String(format:\"|| id = '%@'\", suitModel.id)\n            let str2 = String(format:\"|| productId = '%@'\", suitModel.id)\n            goodsSql.append(str1)\n            relationSql.append(str2)\n        }\n        addGoodsArr.append(suitModel)\n        relationidArr.append(suitModel.id)\n    } else {\n        // delFlag为1表示删除了商品\n        if deleteGoodsSql == \"\" {\n            let str1 = String(format:\"id = '%@'\", suitModel.id)\n            let str2 = String(format:\"productId = '%@'\", suitModel.id)\n            deleteGoodsSql.append(str1)\n            deleteRelationSql.append(str2)\n        } else {\n            let str1 = String(format:\"|| id = '%@'\", suitModel.id)\n            let str2 = String(format:\"|| productId = '%@'\", suitModel.id)\n            deleteGoodsSql.append(str1)\n            deleteRelationSql.append(str2)\n        }\n    }\n}\n```\n有个一个delFlag变量，就是表示是否删除的意思。\n如果是删除的话，将sql组合一下，就成为 id = '12' || id = '13' || id = '14' 这种。关系表就是 productId = '12' || productId = '14' 这种。\n\n\n这里就知道哪些商品要删除，哪些要加。哪些关系表要删除，哪些要加。\n\n这里先处理下新增的商品：\n```Swift\nif goodsSql != \"\" {\n    let predicate = NSPredicate(format:goodsSql)\n    let suitArr = objectsWithPredicate(object: StageGoodsPackgeModelData.self, predicate: predicate)\n    // 这里需要把可能之前存在相同的去掉\n    deleteList(suitArr){\n        print(\"删除商品成功\")\n    }\n    if addGoodsArr.count != 0 {\n        addList(addGoodsArr){\n            print(\"增量更新商品数据成功\")\n        }\n    }\n}\n```\n这里用了系统的NSPredicate类来组合sql语句。它其实是用来过滤数据的类。\n使用方法可以参考这篇文章：[https://juejin.cn/post/6844903540805074951](https://juejin.cn/post/6844903540805074951)。\n\n然后处理下要删除的商品：\n```Swift\n if deleteGoodsSql != \"\" {\n    // NSPredicate是swift 过滤数据的类，类似数据库中的where字段\n    let predicate = NSPredicate(format:deleteGoodsSql)\n    let suitArr = objectsWithPredicate(object: StageGoodsPackgeModelData.self, predicate: predicate)\n    deleteList(suitArr){\n        print(\"删除商品成功\")\n    }\n}\n```\n\n商品处理完成，剩下就是关系表了。\n\n这里先处理要新增的关系：\n```Swift\n// 这里是新增的关系表\nfor idStr in relationidArr {\n    for relationModel in model.appProductRelVOList{\n        if idStr == relationModel.productId {\n            addRelationsArr.append(relationModel)\n        }\n    }\n}\n\n// 新增的关系表\nif relationSql != \"\" {\n    let relationPredicate = NSPredicate(format:relationSql)\n    let relationArr = objectsWithPredicate(object: StageGoodsSuitPackgeModelData.self, predicate: relationPredicate)\n    deleteList(relationArr){\n        print(\"删除套机关系模型成功\")\n    }\n    if addRelationsArr.count != 0 {\n        addList(addRelationsArr){\n            print(\"增量更新套机关系模型成功\")\n        }\n    }\n}\n```\n\n然后处理下要删除的关系表：\n```Swift\n if deleteRelationSql != \"\" {\n    let relationPredicate = NSPredicate(format:deleteRelationSql)\n    let relationArr = objectsWithPredicate(object: StageGoodsSuitPackgeModelData.self, predicate: relationPredicate)\n    deleteList(relationArr){\n        print(\"删除套机关系模型成功\")\n    }\n}\n```\n\n这样增量数据就成功插入了。\n\n## 8 预览realm数据库\n\n插入数据成功后，我们可以用 Realm Studio 来预览数据。\n上面有讲解如何使用这个可视化工具。\n\n这里我们就看下最终的结果吧：\n<img src=realm1.png>\n<img src=realm2.png>\n\n## 9 总结\n\n* iOS数据库可以考虑使用realm数据库，这个是跨平台，Android也有相应的三方库，使用非常简洁，可以考虑。\n\n* 对于大量数据，我们务必要注意数据的修改，新增，最好采用增量更新的方式，而且如果全量，最好是先压缩下，减小对网络依赖。\n\n* realm数据库要注意数据库迁移的问题，升级的问题，使用前需要configRealm。\n\n* 真机预览realm数据库可以使用Realm Studio。\n\n* 增量更新一定要注意删除之前的记录，否则数据会很紊乱。\n","source":"_posts/iOS-swift-数据库realm实践.md","raw":"---\ntitle: iOS swift 数据库realm实践\ndate: 2023-01-30 16:38:21\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- 数据库 iOS\ncategories:\n- iOS\n---\n\n## 1 需求定义\n\n需要获取服务端的条码数据库，存放到本地数据库。\n\n背景：集成了扫码功能，扫到的条码头需要匹配数据库中的条码列表，可以认为这个是一个离线数据库。不会实时判断，因为条码很多，这里先获取所有的条码，存放到本地数据库。然后扫码就按照数据库中的关系表来匹配就好了。\n\n这里我们有两个表，一个商品库表，一个是关系表。为什么有2个表呢？因为我们有配套的关系，2个零件可以看做单个商品，他们组合了也可以看成单独商品哦，这种就是套机了。想必做个电商的人都懂这个道理。比如可以买一件上衣，一条裤子，它们都是独立商品，也可以配套组合一套商品，而且这一套也可以认为是一个商品。\n\n\n## 2 需求分析\n\n这里我们采用 realm数据库。\nrealm非常简介，效率也是不错的。\ngithub地址：[https://github.com/realm/realm-swift](https://github.com/realm/realm-swift)\n\n简单描述下realm吧：Realm 是一个跨平台的移动数据库引擎，其性能要优于 Core Data 和 FMDB - 移动端数据库性能比较, 我们可以在 Android 端 realm-java，iOS端:Realm-Cocoa，同时支持 OC 和 Swift两种语言开发。其使用简单，免费，性能优异，跨平台的特点广受关注。\n\n这里我们会用到2个表。\n\n因为这是个离线数据库，我们需要考虑数据库变更，与服务端同步问题。\n所以我们需要一个接口，判断有无新增或者变更的数据。\n\n需要考虑到增量更新，同时如果数据变更大于一个阙值，比如1000条数据，我们可以认为是全量更新。这时候全量更新的时间和增量插入数据时间几乎相同。\n\n另外如果第一次获取数据，数据量可能会很大，我们需要考虑压缩，与服务端商议，将json数据压缩，然后我们自行解析为实体类。\n\n另外增量更新的时候，要特别注意改数据是删除了还是新增的，还是变更的。\n如果商品删除了，关系表也是要删除的哦。这点很重要，不然后期会导致匹配异常。\n\n\n## 3 准备工作，会用Realm\n\n因为是从0开始，建议熟悉一下Realm使用方法。\n可以参考下这篇博客：[https://juejin.cn/post/6844904117442215944](https://juejin.cn/post/6844904117442215944),写得还是相当不错，有Demo，讲述得非常清晰易懂。\n\n这里就不讲解如何引用这个Realm了。\n\n这里需要会用一个工具：Realm Studio，\n下载地址：[https://www.mongodb.com/docs/realm/studio/install/](https://www.mongodb.com/docs/realm/studio/install/)\n这里按照自己电脑版本下载相应软件就好了，这个也是免费的。\n\n如何分析真机里面的realm数据库呢？\n可以参考下：[https://blog.csdn.net/asfasnjn/article/details/124714242](https://blog.csdn.net/asfasnjn/article/details/124714242) 很简单，打开XCode的window下的设备和模拟器，再 点击更多图标，再下载Container，然后下载后，查看包内容，就可以看到这个应用的realm文件了。然后可以右键，用我们下载好的Realm Studio来查看这个文件，文件以表格形式展示，清晰直观。\n\n## 4 初始化配置数据库\n\n这里需要在AppDelegate中配置下realm数据库。\n很简单的。\n不过我们没有在AppDelegate初始化，因为我们这个绑定了userId，等用户登录后才初始化，当然也是可以的。\n\n重点是初始化这个动作要先于使用就行了。\n```Swift\nfunc configRealm(userID: String?,\n                        keyWord: String? = nil,\n                        schemaVersion: UInt64 = 2, migrationBlock: MigrationBlock? = nil) {\n    // 加密串128位结果为：464e5774625e64306771702463336e316a4074487442325145766477335e21346b715169364c406c6a4976346d695958396245346e356f6a62256d2637566126\n    // let key: Data = \"FNWtb^d0gqp$c3n1j@tHtB2QEvdw3^!4kqQi6L@ljIv4miYX9bE4n5ojb%m&7Va&\".data(using: .utf8, allowLossyConversion: false)!\n    // 加密的key\n    // let key: Data = keyWord.data(using: .utf8, allowLossyConversion: false)!\n    // 打开加密文件\n    // (encryptionKey: key)\n    // 使用默认的目录，但是使用用户 ID 来替换默认的文件名\n    \n    //schemaVersion 数据库版本号从0开始\n    let manager = FileManager.default\n    let document = manager.urls(for: .documentDirectory, in: .userDomainMask)\n    let url = document[0] as URL\n    let urlStr = url.absoluteString\n    let path = urlStr + \"/\" + (\"\\(userID!).realm\")\n    let config = Realm.Configuration(fileURL: URL(string: path), schemaVersion: schemaVersion, migrationBlock: { (migration, oldSchemaVersion) in\n        // 目前我们还未进行数据迁移，因此 oldSchemaVersion == 0\n        if oldSchemaVersion < 100 {\n            // 什么都不要做！Realm 会自行检测新增和需要移除的属性，然后自动更新硬盘上的数据库架构\n            // 属性重命名  migration.renameProperty(onType: Person.className(), from: \"yearsSinceBirth\", to: \"age\")\n            print(oldSchemaVersion)\n            print(\"end\")\n        }\n        // 低版本的数据库迁移......\n        if migrationBlock != nil {\n            migrationBlock!(migration, oldSchemaVersion)\n        }\n    })\n    // 告诉 Realm 为默认的 Realm 数据库使用这个新的配置对象\n    Realm.Configuration.defaultConfiguration = config\n    guard let realm = try? Realm(configuration: config) else {\n        return\n    }\n    currentSchemaVersion = schemaVersion\n    currentRealm = realm\n    currentKeyWord = keyWord\n}\n```\n这个realm实际上以userId为名称了。\n这样就有个弊端了，切换用户后，需要重新下载数据库，特别是数据库特别大的情况下，这对用户体验不是特别好。\n\n\n## 5 走接口拿数据\n\n这里就是拿商品数据了，这里服务端提供的接口，返回的是加密后的字符串。\n类似这样：\n```Json\n{\n  \"message\" : \"请求成功\",\n  \"code\" : 1000,\n  \"data\" : \"H4sIAAAAAAAAAKtWSiwoCCjKTylNLglKzQnz98ksLlGyio7VQZJAFk3OzytJzQ\n  NyDA2NdJRKC1IS\\nS1JDMnNTlayUjAyMjHUNDHWNLBUMTaxMzaxMDJVqAQ0XaZphAAAA\"\n}\n```\n\n比如我们接口是这样请求的，这里我们先扩展了一个方法给控制器：\n```Swift\nextension GMBaseViewController {\n    \n    open func updateOfflinePackageData(tips: String = \"\", successful: @escaping Handler) {\n        MBProgressHUD.showMessage(tips)\n        OfflinePackageManager.update {\n            successful()\n            MBProgressHUD.hide()\n            MBProgressHUD.hide()\n        } failure: {\n            MBProgressHUD.hide()\n            MBProgressHUD.hide()\n            let alerVC = UIAlertController(\n                title: \"\",\n                message: \"检测到商品信息变动，系统为您自动更新商品信息失败，请在网络良好的环境下，手动更新商品信息\",\n                preferredStyle: .alert\n            )\n            alerVC.addAction(\n                UIAlertAction(\n                    title: \"下载商品信息\",\n                    style: .default\n                ) { (action) in\n                    self.updateOfflinePackageData(successful: successful)\n                }\n            )\n            self.present(alerVC, animated: true, completion:nil)\n        }\n        \n    }\n    \n}\n```\n这里我们的OfflinePackageManager就是我们封装好的专门去下载离线库的工具类。\n成功后走successful的逃逸闭包，失败弹一个弹框。\n\n继续走进去：\n```Swift\nclass OfflinePackageManager: NSObject {\n    \n    open class func update(\n        updateTime: String = Defaults[key: DefaultsKeys.updateTime] ?? \"\",\n        successful: @escaping Handler,\n        failure: @escaping Handler\n    ) {\n        let endTimeStr = Defaults[key: DefaultsKeys.updateTime]\n        let updateTimeStr = updateTime\n       \n        productProvider.requestJson(.getProductMetadataForAPP(updateTime: updateTimeStr)) { response in\n            let jsonString = JSON(rawValue: response).jsonString\n            let result = GMBaseRequestModel.deserialize(from: jsonString)\n            if result?.code == 1000 {\n                guard let data = result?.data?.gunzip?.data(using: .utf8) else { return }\n                \n                let file = \"zpi_offline_package_data.txt\"\n                let text = result?.data?.gunzip ?? \"\"\n                \n                if let dir = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first {\n                    let fileURL = dir.appendingPathComponent(file)\n                    do {\n                        try text.write(to: fileURL, atomically: false, encoding: .utf8)\n                    } catch {}\n                }\n                \n                guard let model = try? JSONDecoder().decode(StageOfflinePackageData.self, from: data) else { return }\n                \n                if endTimeStr != nil && (model.appProductVOList.count >= 1000 || model.appProductRelVOList.count >= 1000) {\n                    Defaults[key:DefaultsKeys.updateTime] = nil\n                    OfflinePackageManager.update(updateTime: \"\", successful: successful, failure: failure)\n                } else {\n                    if endTimeStr == nil {\n                        OfflinePackageManager.fullUpdate(model: model)\n                    } else {\n                        OfflinePackageManager.incrementalUpdate(model: model)\n                    }\n                    Defaults[key: DefaultsKeys.updateTime] = model.updateTime\n                    successful()\n                }\n            } else {\n                failure()\n            }\n        } failure: { _ in\n            failure()\n        }\n    }\n```\n\n## 6 解压缩字符串\n\n这里服务端返回的一段加密后的字符串：\n```Json\n{\n  \"message\" : \"请求成功\",\n  \"code\" : 1000,\n  \"data\" : \"H4sIAAAAAAAAAKtWSiwoCCjKTylNLglKzQnz98ksLlGyio7VQZJAFk3OzytJzQNyDA2NdJRKC1IS\\nS1JDMnNTlayUjAyMjHUNDHWNLBUMTaxMzaxMDJVqAQ0XaZphAAAA\"\n}\n```\n不过返回体还是json，我们先拿data里面的字符串。\n再去解压缩。\n\n字符串解压缩可以参考这篇文章：[https://www.cnblogs.com/strengthen/p/10844466.html](https://www.cnblogs.com/strengthen/p/10844466.html)\n\n这里我们用到了GzipSwift框架。\n\n这个框架地址为：[https://github.com/1024jp/GzipSwift](https://github.com/1024jp/GzipSwift) 还是有挺多人star的。\n\n具体细节就不讲解了。\n\n这里我们自己给String做了一个扩展，这样直接能拿到解压缩后的字符串：\n```Swift\nextension String {\n    var gunzip: String? {\n        if let data = Data(base64Encoded: self, options: .ignoreUnknownCharacters) {\n            if data.isGzipped {\n                if let gun = try? data.gunzipped() {\n                    return String(data: gun, encoding: String.Encoding.utf8)\n                }\n            }\n        }\n        return nil\n    }\n}\n```\n\n这里解析后的字符串为：\n```Json\n{\n    \"appProductRelVOList\":[],\n    \"appProductVOList\":[],\n    \"content\":112,\n    \"updateTime\":\"2023-01-29 14:56:41\"\n}\n```\n\n同样也是一个json数组哦。\n所以我们还是得用Json解析下：\n```Swift\nguard let model = try? JSONDecoder().decode(StageOfflinePackageData.self, from: data)\n                else { return }\n```\n\n这时候我们需要一个实体来接收下：\n```Swift\nclass StageOfflinePackageData:Codable{\n    \n    var appProductVOList: [StageGoodsPackgeModelData] = []\n    \n    var appProductRelVOList: [StageGoodsSuitPackgeModelData] = []\n    \n    var updateTime: String = \"\"\n    \n    \n    private enum Codingkeys: String, CodingKey{\n        case appProductVOList,appProductRelVOList,updateTime\n    }\n    \n    func encode(to encoder: Encoder) throws {}\n    \n    required init(from decoder: Decoder) throws {\n        let values = try decoder.container(keyedBy: Codingkeys.self)\n        appProductVOList = try values.decode(Array.self, forKey: .appProductVOList)\n        appProductRelVOList = try values.decode(Array.self, forKey: .appProductRelVOList)\n        updateTime = try values.decode(String.self, forKey: .updateTime)\n    }\n}\n```\n为啥要继承Codable呢？\nCodable 协议在 Swift4.0 开始被引入，目标是取代现有的 NSCoding 协议，它对结构体，枚举和类都支持。Codable 的引入简化了JSON 和 Swift 类型之间相互转换的难度，能够把 JSON 这种弱类型数据转换成代码中使用的强类型数据。具体可以看这篇文章：[https://juejin.cn/post/6971997599725256734](https://juejin.cn/post/6971997599725256734)。\n\n\n解析后就拿到服务端的数据了，可能是增量数据，可能是全量数据。后面我们具体分析下。\n\n\n## 7 数据处理\n\n解析完毕后，我们有一段逻辑是这样的：\n```Swift\nif endTimeStr != nil && (model.appProductVOList.count >= 1000 || model.appProductRelVOList.count >= 1000) {\n                    Defaults[key:DefaultsKeys.updateTime] = nil\n                    OfflinePackageManager.update(updateTime: \"\", successful: successful, failure: failure)\n                } else {\n                    if endTimeStr == nil {\n                        OfflinePackageManager.fullUpdate(model: model)\n                    } else {\n                        OfflinePackageManager.incrementalUpdate(model: model)\n                    }\n                    Defaults[key: DefaultsKeys.updateTime] = model.updateTime\n                    successful()\n                }\n```\n\n这里如果数据大于1000条，我们重新走全量更新接口。\n如果上次更新时间为空，我们默认为全量更新，将所有数据插入数据库。\n如果上次更新时间不为空，而且小于1000条，我们就走增量更新逻辑。\n\n### 7.1 Model层定义\n\n这里是定义的Realm的基础模型。\n\n我们需要定义两个实体，一个是商品模型，一个是关系模型。\n\n商品模型为：\n```Swift\n\nclass StageGoodsPackgeModelData: Object,Codable{\n    \n    @objc dynamic var barcode: String = \"\"\n    @objc dynamic var brand: String = \"\"\n    @objc dynamic var brandId: String = \"\"\n    @objc dynamic var category: String = \"\"\n    @objc dynamic var categoryId: Int = 0\n    @objc dynamic var createBy: String = \"\"\n    @objc dynamic var createTime: String = \"\"\n    @objc dynamic var delFlag: Int = 0\n    @objc dynamic var groupNum: Int = 1         //返回为\"\"时服务器需要传1\n    @objc dynamic var id: String = \"\"\n    @objc dynamic var isGreeProduct: Bool = false\n    @objc dynamic var isGroupedProduct: Bool = false\n    @objc dynamic var isSaleProduct: Bool = false\n    @objc dynamic var length: Double = 0.0\n    @objc dynamic var name: String = \"\"\n    @objc dynamic var orgId: String = \"\"\n    @objc dynamic var skuCode: String = \"\"\n    @objc dynamic var tall: Double = 0\n    @objc dynamic var unit: String = \"\"\n    @objc dynamic var updateBy: String = \"\"\n    @objc dynamic var updateTime: String = \"\"\n    @objc dynamic var volume: Double = 0.0\n    @objc dynamic var weight: Double = 0.0\n    @objc dynamic var wide: Double = 0.0\n    @objc dynamic var isMarketingProduct :Bool = false\n    \n    private enum Codingkeys: String, CodingKey{\n        case barcode\n        ,brand\n        ,brandId\n        ,category\n        ,categoryId\n        ,createBy\n        ,createTime\n        ,delFlag\n        ,groupNum\n        ,id\n        ,isGreeProduct\n        ,isGroupedProduct\n        ,isSaleProduct\n        ,length\n        ,name\n        ,orgId\n        ,skuCode\n        ,tall\n        ,unit\n        ,updateBy\n        ,updateTime\n        ,volume\n        ,weight\n        ,wide,\n        isMarketingProduct\n    }\n    \n    \n    required init(from decoder: Decoder) throws {\n        let values = try decoder.container(keyedBy: Codingkeys.self)\n        \n        do {\n            barcode = try values.decode(String.self, forKey: .barcode)\n        } catch {\n            barcode = \"\"\n        }\n        do {\n            brand = try values.decode(String.self, forKey: .brand)\n        } catch {\n            brand = \"\"\n        }\n        do {\n            brandId = try values.decode(String.self, forKey: .brandId)\n        } catch {\n            brandId = \"\"\n        }\n        do {\n            category = try values.decode(String.self, forKey: .category)\n        } catch {\n            category = \"\"\n        }\n        do {\n            categoryId = try values.decode(Int.self, forKey: .categoryId)\n        } catch {\n            categoryId = 0\n        }\n        do {\n            createBy = try values.decode(String.self, forKey: .createBy)\n        } catch {\n            createBy = \"\"\n        }\n        do {\n            createTime = try values.decode(String.self, forKey: .createTime)\n        } catch {\n            createTime = \"\"\n        }\n        do {\n            delFlag = try values.decode(Int.self, forKey: .delFlag)\n        } catch {\n            delFlag = 0\n        }\n        do {\n            groupNum = try values.decode(Int.self, forKey: .groupNum)\n        } catch {\n            groupNum = 1\n        }\n        do {\n            id = try values.decode(String.self, forKey: .id)\n        } catch {\n            id = \"\"\n        }\n        do {\n            isGreeProduct = try values.decode(Bool.self, forKey: .isGreeProduct)\n        } catch {\n            isGreeProduct = false\n        }\n        do {\n            isGroupedProduct = try values.decode(Bool.self, forKey: .isGroupedProduct)\n        } catch {\n            isGroupedProduct = false\n        }\n        do {\n            isSaleProduct = try values.decode(Bool.self, forKey: .isSaleProduct)\n        } catch {\n            isSaleProduct = false\n        }\n        do {\n            length = try values.decode(CGFloat.self, forKey: .length)\n        } catch {\n            length = 0.0\n        }\n        do {\n            name = try values.decode(String.self, forKey: .name)\n        } catch {\n            name = \"\"\n        }\n        do {\n            orgId = try values.decode(String.self, forKey: .orgId)\n        } catch {\n            orgId = \"\"\n        }\n        do {\n            skuCode = try values.decode(String.self, forKey: .skuCode)\n        } catch {\n            skuCode = \"\"\n        }\n        do {\n            tall = try values.decode(Double.self, forKey: .tall)\n        } catch {\n            tall = 0\n        }\n        do {\n            unit = try values.decode(String.self, forKey: .unit)\n        } catch {\n            unit = \"\"\n        }\n        do {\n            updateBy =  try values.decode(String.self, forKey: .updateBy)\n        } catch {\n            updateBy = \"\"\n        }\n        do {\n            updateTime = try values.decode(String.self, forKey: .updateTime)\n        } catch {\n            updateTime = \"\"\n        }\n        do {\n            volume = try values.decode(Double.self, forKey: .volume)\n        } catch {\n            volume = 0.0\n        }\n        do {\n            weight = try values.decode(Double.self, forKey: .weight)\n        } catch {\n            weight = 0.0\n        }\n        do {\n            wide = try values.decode(Double.self, forKey: .wide)\n        } catch {\n            wide = 0.0\n        }\n        do {\n            isMarketingProduct = try values.decode(Bool.self, forKey: .isMarketingProduct)\n        } catch {\n            isMarketingProduct = false\n        }\n    }\n    \n    func encode(to encoder: Encoder) throws {}\n    \n    override required init(){}\n}\n```\n\n另外一个为：\n```Swift\n\nclass StageGoodsSuitPackgeModelData: Object,Codable{\n\n    @objc dynamic var groupNum: Int = 0\n    @objc dynamic var id: String = \"\"\n    @objc dynamic var orgId: String = \"\"\n    @objc dynamic var productId: String = \"\"\n    @objc dynamic var subProductId: String = \"\"\n    \n    private enum Codingkeys: String, CodingKey {\n        case groupNum\n        case id\n        case orgId\n        case productId\n        case subProductId\n    }\n\n    required init(from decoder: Decoder) throws {\n        let values = try decoder.container(keyedBy: Codingkeys.self)\n        \n        do {\n            groupNum = try values.decode(Int.self, forKey: .groupNum)\n        } catch {\n            groupNum = 0\n        }\n        do {\n            id = try values.decode(String.self, forKey: .id)\n        } catch {\n            id = \"\"\n        }\n        do {\n            orgId = try values.decode(String.self, forKey: .orgId)\n        } catch {\n            orgId = \"\"\n        }\n        do {\n            productId = try values.decode(String.self, forKey: .productId)\n        } catch {\n            productId = \"\"\n        }\n        do {\n            subProductId = try values.decode(String.self, forKey: .subProductId)\n        } catch {\n            subProductId = \"\"\n        }\n    }\n\n    func encode(to encoder: Encoder) throws {}\n    \n    override required init(){}\n}\n```\n\n### 7.2 全量更新\n\n```Swift\nprivate class func fullUpdate(model: StageOfflinePackageData) {\n        let suitResult = objectWithAll(objct: StageGoodsPackgeModelData.self)\n        if suitResult.count != 0 {\n            deleteList(suitResult) {\n                print(\"StageGoodsPackgeModelData表数据清除成功\")\n            }\n        }\n        addList(model.appProductVOList) {\n            print(\"StageGoodsPackgeModelData 插入成功\")\n        }\n        \n        let relationResult = objectWithAll(objct: StageGoodsSuitPackgeModelData.self)\n        if relationResult.count != 0 {\n            deleteList(relationResult) {\n                print(\"StageGoodsSuitPackgeModelData表数据清除成功\")\n            }\n        }\n        addList(model.appProductRelVOList) {\n            print(\"StageGoodsSuitPackgeModelData 插入成功\")\n        }\n    }\n```\n如果是全量更新就比较简单了。\n先把之前的那两个删除掉，然后新增新的model就好了。\n\n### 7.3 增量更新\n\n先声明一下sql\n```Swift\n    private class func incrementalUpdate(model: StageOfflinePackageData) {\n        print(\"增量处理开始时间---->\", Date().currentTime(0))\n        var addGoodsArr: [StageGoodsPackgeModelData] = []\n        var addRelationsArr: [StageGoodsSuitPackgeModelData] = []\n        var relationidArr: [String] = []\n        \n        var goodsSql = \"\"\n        var relationSql = \"\"\n        var deleteGoodsSql = \"\"\n        var deleteRelationSql = \"\"\n```\n\n遍历下服务端返回的增量数据库：\n```Swift\nfor (_,suitModel) in model.appProductVOList.enumerated() {\n    // delFlag为0表示，不是删除哦，这里是新增商品\n    if suitModel.delFlag == 0 {\n        if goodsSql == \"\" {\n            let str1 = String(format:\"id = '%@'\", suitModel.id)\n            let str2 = String(format:\"productId = '%@'\", suitModel.id)\n            goodsSql.append(str1)\n            relationSql.append(str2)\n        } else {\n            let str1 = String(format:\"|| id = '%@'\", suitModel.id)\n            let str2 = String(format:\"|| productId = '%@'\", suitModel.id)\n            goodsSql.append(str1)\n            relationSql.append(str2)\n        }\n        addGoodsArr.append(suitModel)\n        relationidArr.append(suitModel.id)\n    } else {\n        // delFlag为1表示删除了商品\n        if deleteGoodsSql == \"\" {\n            let str1 = String(format:\"id = '%@'\", suitModel.id)\n            let str2 = String(format:\"productId = '%@'\", suitModel.id)\n            deleteGoodsSql.append(str1)\n            deleteRelationSql.append(str2)\n        } else {\n            let str1 = String(format:\"|| id = '%@'\", suitModel.id)\n            let str2 = String(format:\"|| productId = '%@'\", suitModel.id)\n            deleteGoodsSql.append(str1)\n            deleteRelationSql.append(str2)\n        }\n    }\n}\n```\n有个一个delFlag变量，就是表示是否删除的意思。\n如果是删除的话，将sql组合一下，就成为 id = '12' || id = '13' || id = '14' 这种。关系表就是 productId = '12' || productId = '14' 这种。\n\n\n这里就知道哪些商品要删除，哪些要加。哪些关系表要删除，哪些要加。\n\n这里先处理下新增的商品：\n```Swift\nif goodsSql != \"\" {\n    let predicate = NSPredicate(format:goodsSql)\n    let suitArr = objectsWithPredicate(object: StageGoodsPackgeModelData.self, predicate: predicate)\n    // 这里需要把可能之前存在相同的去掉\n    deleteList(suitArr){\n        print(\"删除商品成功\")\n    }\n    if addGoodsArr.count != 0 {\n        addList(addGoodsArr){\n            print(\"增量更新商品数据成功\")\n        }\n    }\n}\n```\n这里用了系统的NSPredicate类来组合sql语句。它其实是用来过滤数据的类。\n使用方法可以参考这篇文章：[https://juejin.cn/post/6844903540805074951](https://juejin.cn/post/6844903540805074951)。\n\n然后处理下要删除的商品：\n```Swift\n if deleteGoodsSql != \"\" {\n    // NSPredicate是swift 过滤数据的类，类似数据库中的where字段\n    let predicate = NSPredicate(format:deleteGoodsSql)\n    let suitArr = objectsWithPredicate(object: StageGoodsPackgeModelData.self, predicate: predicate)\n    deleteList(suitArr){\n        print(\"删除商品成功\")\n    }\n}\n```\n\n商品处理完成，剩下就是关系表了。\n\n这里先处理要新增的关系：\n```Swift\n// 这里是新增的关系表\nfor idStr in relationidArr {\n    for relationModel in model.appProductRelVOList{\n        if idStr == relationModel.productId {\n            addRelationsArr.append(relationModel)\n        }\n    }\n}\n\n// 新增的关系表\nif relationSql != \"\" {\n    let relationPredicate = NSPredicate(format:relationSql)\n    let relationArr = objectsWithPredicate(object: StageGoodsSuitPackgeModelData.self, predicate: relationPredicate)\n    deleteList(relationArr){\n        print(\"删除套机关系模型成功\")\n    }\n    if addRelationsArr.count != 0 {\n        addList(addRelationsArr){\n            print(\"增量更新套机关系模型成功\")\n        }\n    }\n}\n```\n\n然后处理下要删除的关系表：\n```Swift\n if deleteRelationSql != \"\" {\n    let relationPredicate = NSPredicate(format:deleteRelationSql)\n    let relationArr = objectsWithPredicate(object: StageGoodsSuitPackgeModelData.self, predicate: relationPredicate)\n    deleteList(relationArr){\n        print(\"删除套机关系模型成功\")\n    }\n}\n```\n\n这样增量数据就成功插入了。\n\n## 8 预览realm数据库\n\n插入数据成功后，我们可以用 Realm Studio 来预览数据。\n上面有讲解如何使用这个可视化工具。\n\n这里我们就看下最终的结果吧：\n<img src=realm1.png>\n<img src=realm2.png>\n\n## 9 总结\n\n* iOS数据库可以考虑使用realm数据库，这个是跨平台，Android也有相应的三方库，使用非常简洁，可以考虑。\n\n* 对于大量数据，我们务必要注意数据的修改，新增，最好采用增量更新的方式，而且如果全量，最好是先压缩下，减小对网络依赖。\n\n* realm数据库要注意数据库迁移的问题，升级的问题，使用前需要configRealm。\n\n* 真机预览realm数据库可以使用Realm Studio。\n\n* 增量更新一定要注意删除之前的记录，否则数据会很紊乱。\n","slug":"iOS-swift-数据库realm实践","published":1,"updated":"2023-02-01T07:17:16.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlhfhyq000iivv7dh55e7pk","content":"<h2 id=\"1-需求定义\"><a href=\"#1-需求定义\" class=\"headerlink\" title=\"1 需求定义\"></a>1 需求定义</h2><p>需要获取服务端的条码数据库，存放到本地数据库。</p>\n<p>背景：集成了扫码功能，扫到的条码头需要匹配数据库中的条码列表，可以认为这个是一个离线数据库。不会实时判断，因为条码很多，这里先获取所有的条码，存放到本地数据库。然后扫码就按照数据库中的关系表来匹配就好了。</p>\n<p>这里我们有两个表，一个商品库表，一个是关系表。为什么有2个表呢？因为我们有配套的关系，2个零件可以看做单个商品，他们组合了也可以看成单独商品哦，这种就是套机了。想必做个电商的人都懂这个道理。比如可以买一件上衣，一条裤子，它们都是独立商品，也可以配套组合一套商品，而且这一套也可以认为是一个商品。</p>\n<h2 id=\"2-需求分析\"><a href=\"#2-需求分析\" class=\"headerlink\" title=\"2 需求分析\"></a>2 需求分析</h2><p>这里我们采用 realm数据库。<br>realm非常简介，效率也是不错的。<br>github地址：<a href=\"https://github.com/realm/realm-swift\">https://github.com/realm/realm-swift</a></p>\n<p>简单描述下realm吧：Realm 是一个跨平台的移动数据库引擎，其性能要优于 Core Data 和 FMDB - 移动端数据库性能比较, 我们可以在 Android 端 realm-java，iOS端:Realm-Cocoa，同时支持 OC 和 Swift两种语言开发。其使用简单，免费，性能优异，跨平台的特点广受关注。</p>\n<p>这里我们会用到2个表。</p>\n<p>因为这是个离线数据库，我们需要考虑数据库变更，与服务端同步问题。<br>所以我们需要一个接口，判断有无新增或者变更的数据。</p>\n<p>需要考虑到增量更新，同时如果数据变更大于一个阙值，比如1000条数据，我们可以认为是全量更新。这时候全量更新的时间和增量插入数据时间几乎相同。</p>\n<p>另外如果第一次获取数据，数据量可能会很大，我们需要考虑压缩，与服务端商议，将json数据压缩，然后我们自行解析为实体类。</p>\n<p>另外增量更新的时候，要特别注意改数据是删除了还是新增的，还是变更的。<br>如果商品删除了，关系表也是要删除的哦。这点很重要，不然后期会导致匹配异常。</p>\n<h2 id=\"3-准备工作，会用Realm\"><a href=\"#3-准备工作，会用Realm\" class=\"headerlink\" title=\"3 准备工作，会用Realm\"></a>3 准备工作，会用Realm</h2><p>因为是从0开始，建议熟悉一下Realm使用方法。<br>可以参考下这篇博客：<a href=\"https://juejin.cn/post/6844904117442215944\">https://juejin.cn/post/6844904117442215944</a>,写得还是相当不错，有Demo，讲述得非常清晰易懂。</p>\n<p>这里就不讲解如何引用这个Realm了。</p>\n<p>这里需要会用一个工具：Realm Studio，<br>下载地址：<a href=\"https://www.mongodb.com/docs/realm/studio/install/\">https://www.mongodb.com/docs/realm/studio/install/</a><br>这里按照自己电脑版本下载相应软件就好了，这个也是免费的。</p>\n<p>如何分析真机里面的realm数据库呢？<br>可以参考下：<a href=\"https://blog.csdn.net/asfasnjn/article/details/124714242\">https://blog.csdn.net/asfasnjn/article/details/124714242</a> 很简单，打开XCode的window下的设备和模拟器，再 点击更多图标，再下载Container，然后下载后，查看包内容，就可以看到这个应用的realm文件了。然后可以右键，用我们下载好的Realm Studio来查看这个文件，文件以表格形式展示，清晰直观。</p>\n<h2 id=\"4-初始化配置数据库\"><a href=\"#4-初始化配置数据库\" class=\"headerlink\" title=\"4 初始化配置数据库\"></a>4 初始化配置数据库</h2><p>这里需要在AppDelegate中配置下realm数据库。<br>很简单的。<br>不过我们没有在AppDelegate初始化，因为我们这个绑定了userId，等用户登录后才初始化，当然也是可以的。</p>\n<p>重点是初始化这个动作要先于使用就行了。</p>\n<pre><code class=\"line-numbers language-Swift\">func configRealm(userID: String?,\n                        keyWord: String? = nil,\n                        schemaVersion: UInt64 = 2, migrationBlock: MigrationBlock? = nil) &#123;\n    // 加密串128位结果为：464e5774625e64306771702463336e316a4074487442325145766477335e21346b715169364c406c6a4976346d695958396245346e356f6a62256d2637566126\n    // let key: Data = &quot;FNWtb^d0gqp$c3n1j@tHtB2QEvdw3^!4kqQi6L@ljIv4miYX9bE4n5ojb%m&amp;7Va&amp;&quot;.data(using: .utf8, allowLossyConversion: false)!\n    // 加密的key\n    // let key: Data = keyWord.data(using: .utf8, allowLossyConversion: false)!\n    // 打开加密文件\n    // (encryptionKey: key)\n    // 使用默认的目录，但是使用用户 ID 来替换默认的文件名\n    \n    //schemaVersion 数据库版本号从0开始\n    let manager = FileManager.default\n    let document = manager.urls(for: .documentDirectory, in: .userDomainMask)\n    let url = document[0] as URL\n    let urlStr = url.absoluteString\n    let path = urlStr + &quot;/&quot; + (&quot;\\(userID!).realm&quot;)\n    let config = Realm.Configuration(fileURL: URL(string: path), schemaVersion: schemaVersion, migrationBlock: &#123; (migration, oldSchemaVersion) in\n        // 目前我们还未进行数据迁移，因此 oldSchemaVersion == 0\n        if oldSchemaVersion &lt; 100 &#123;\n            // 什么都不要做！Realm 会自行检测新增和需要移除的属性，然后自动更新硬盘上的数据库架构\n            // 属性重命名  migration.renameProperty(onType: Person.className(), from: &quot;yearsSinceBirth&quot;, to: &quot;age&quot;)\n            print(oldSchemaVersion)\n            print(&quot;end&quot;)\n        &#125;\n        // 低版本的数据库迁移......\n        if migrationBlock != nil &#123;\n            migrationBlock!(migration, oldSchemaVersion)\n        &#125;\n    &#125;)\n    // 告诉 Realm 为默认的 Realm 数据库使用这个新的配置对象\n    Realm.Configuration.defaultConfiguration = config\n    guard let realm = try? Realm(configuration: config) else &#123;\n        return\n    &#125;\n    currentSchemaVersion = schemaVersion\n    currentRealm = realm\n    currentKeyWord = keyWord\n&#125;\n</code></pre>\n<p>这个realm实际上以userId为名称了。<br>这样就有个弊端了，切换用户后，需要重新下载数据库，特别是数据库特别大的情况下，这对用户体验不是特别好。</p>\n<h2 id=\"5-走接口拿数据\"><a href=\"#5-走接口拿数据\" class=\"headerlink\" title=\"5 走接口拿数据\"></a>5 走接口拿数据</h2><p>这里就是拿商品数据了，这里服务端提供的接口，返回的是加密后的字符串。<br>类似这样：</p>\n<pre><code class=\"line-numbers language-Json\">&#123;\n  &quot;message&quot; : &quot;请求成功&quot;,\n  &quot;code&quot; : 1000,\n  &quot;data&quot; : &quot;H4sIAAAAAAAAAKtWSiwoCCjKTylNLglKzQnz98ksLlGyio7VQZJAFk3OzytJzQ\n  NyDA2NdJRKC1IS\\nS1JDMnNTlayUjAyMjHUNDHWNLBUMTaxMzaxMDJVqAQ0XaZphAAAA&quot;\n&#125;\n</code></pre>\n<p>比如我们接口是这样请求的，这里我们先扩展了一个方法给控制器：</p>\n<pre><code class=\"line-numbers language-Swift\">extension GMBaseViewController &#123;\n    \n    open func updateOfflinePackageData(tips: String = &quot;&quot;, successful: @escaping Handler) &#123;\n        MBProgressHUD.showMessage(tips)\n        OfflinePackageManager.update &#123;\n            successful()\n            MBProgressHUD.hide()\n            MBProgressHUD.hide()\n        &#125; failure: &#123;\n            MBProgressHUD.hide()\n            MBProgressHUD.hide()\n            let alerVC = UIAlertController(\n                title: &quot;&quot;,\n                message: &quot;检测到商品信息变动，系统为您自动更新商品信息失败，请在网络良好的环境下，手动更新商品信息&quot;,\n                preferredStyle: .alert\n            )\n            alerVC.addAction(\n                UIAlertAction(\n                    title: &quot;下载商品信息&quot;,\n                    style: .default\n                ) &#123; (action) in\n                    self.updateOfflinePackageData(successful: successful)\n                &#125;\n            )\n            self.present(alerVC, animated: true, completion:nil)\n        &#125;\n        \n    &#125;\n    \n&#125;\n</code></pre>\n<p>这里我们的OfflinePackageManager就是我们封装好的专门去下载离线库的工具类。<br>成功后走successful的逃逸闭包，失败弹一个弹框。</p>\n<p>继续走进去：</p>\n<pre><code class=\"line-numbers language-Swift\">class OfflinePackageManager: NSObject &#123;\n    \n    open class func update(\n        updateTime: String = Defaults[key: DefaultsKeys.updateTime] ?? &quot;&quot;,\n        successful: @escaping Handler,\n        failure: @escaping Handler\n    ) &#123;\n        let endTimeStr = Defaults[key: DefaultsKeys.updateTime]\n        let updateTimeStr = updateTime\n       \n        productProvider.requestJson(.getProductMetadataForAPP(updateTime: updateTimeStr)) &#123; response in\n            let jsonString = JSON(rawValue: response).jsonString\n            let result = GMBaseRequestModel.deserialize(from: jsonString)\n            if result?.code == 1000 &#123;\n                guard let data = result?.data?.gunzip?.data(using: .utf8) else &#123; return &#125;\n                \n                let file = &quot;zpi_offline_package_data.txt&quot;\n                let text = result?.data?.gunzip ?? &quot;&quot;\n                \n                if let dir = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first &#123;\n                    let fileURL = dir.appendingPathComponent(file)\n                    do &#123;\n                        try text.write(to: fileURL, atomically: false, encoding: .utf8)\n                    &#125; catch &#123;&#125;\n                &#125;\n                \n                guard let model = try? JSONDecoder().decode(StageOfflinePackageData.self, from: data) else &#123; return &#125;\n                \n                if endTimeStr != nil &amp;&amp; (model.appProductVOList.count &gt;= 1000 || model.appProductRelVOList.count &gt;= 1000) &#123;\n                    Defaults[key:DefaultsKeys.updateTime] = nil\n                    OfflinePackageManager.update(updateTime: &quot;&quot;, successful: successful, failure: failure)\n                &#125; else &#123;\n                    if endTimeStr == nil &#123;\n                        OfflinePackageManager.fullUpdate(model: model)\n                    &#125; else &#123;\n                        OfflinePackageManager.incrementalUpdate(model: model)\n                    &#125;\n                    Defaults[key: DefaultsKeys.updateTime] = model.updateTime\n                    successful()\n                &#125;\n            &#125; else &#123;\n                failure()\n            &#125;\n        &#125; failure: &#123; _ in\n            failure()\n        &#125;\n    &#125;\n</code></pre>\n<h2 id=\"6-解压缩字符串\"><a href=\"#6-解压缩字符串\" class=\"headerlink\" title=\"6 解压缩字符串\"></a>6 解压缩字符串</h2><p>这里服务端返回的一段加密后的字符串：</p>\n<pre><code class=\"line-numbers language-Json\">&#123;\n  &quot;message&quot; : &quot;请求成功&quot;,\n  &quot;code&quot; : 1000,\n  &quot;data&quot; : &quot;H4sIAAAAAAAAAKtWSiwoCCjKTylNLglKzQnz98ksLlGyio7VQZJAFk3OzytJzQNyDA2NdJRKC1IS\\nS1JDMnNTlayUjAyMjHUNDHWNLBUMTaxMzaxMDJVqAQ0XaZphAAAA&quot;\n&#125;\n</code></pre>\n<p>不过返回体还是json，我们先拿data里面的字符串。<br>再去解压缩。</p>\n<p>字符串解压缩可以参考这篇文章：<a href=\"https://www.cnblogs.com/strengthen/p/10844466.html\">https://www.cnblogs.com/strengthen/p/10844466.html</a></p>\n<p>这里我们用到了GzipSwift框架。</p>\n<p>这个框架地址为：<a href=\"https://github.com/1024jp/GzipSwift\">https://github.com/1024jp/GzipSwift</a> 还是有挺多人star的。</p>\n<p>具体细节就不讲解了。</p>\n<p>这里我们自己给String做了一个扩展，这样直接能拿到解压缩后的字符串：</p>\n<pre><code class=\"line-numbers language-Swift\">extension String &#123;\n    var gunzip: String? &#123;\n        if let data = Data(base64Encoded: self, options: .ignoreUnknownCharacters) &#123;\n            if data.isGzipped &#123;\n                if let gun = try? data.gunzipped() &#123;\n                    return String(data: gun, encoding: String.Encoding.utf8)\n                &#125;\n            &#125;\n        &#125;\n        return nil\n    &#125;\n&#125;\n</code></pre>\n<p>这里解析后的字符串为：</p>\n<pre><code class=\"line-numbers language-Json\">&#123;\n    &quot;appProductRelVOList&quot;:[],\n    &quot;appProductVOList&quot;:[],\n    &quot;content&quot;:112,\n    &quot;updateTime&quot;:&quot;2023-01-29 14:56:41&quot;\n&#125;\n</code></pre>\n<p>同样也是一个json数组哦。<br>所以我们还是得用Json解析下：</p>\n<pre><code class=\"line-numbers language-Swift\">guard let model = try? JSONDecoder().decode(StageOfflinePackageData.self, from: data)\n                else &#123; return &#125;\n</code></pre>\n<p>这时候我们需要一个实体来接收下：</p>\n<pre><code class=\"line-numbers language-Swift\">class StageOfflinePackageData:Codable&#123;\n    \n    var appProductVOList: [StageGoodsPackgeModelData] = []\n    \n    var appProductRelVOList: [StageGoodsSuitPackgeModelData] = []\n    \n    var updateTime: String = &quot;&quot;\n    \n    \n    private enum Codingkeys: String, CodingKey&#123;\n        case appProductVOList,appProductRelVOList,updateTime\n    &#125;\n    \n    func encode(to encoder: Encoder) throws &#123;&#125;\n    \n    required init(from decoder: Decoder) throws &#123;\n        let values = try decoder.container(keyedBy: Codingkeys.self)\n        appProductVOList = try values.decode(Array.self, forKey: .appProductVOList)\n        appProductRelVOList = try values.decode(Array.self, forKey: .appProductRelVOList)\n        updateTime = try values.decode(String.self, forKey: .updateTime)\n    &#125;\n&#125;\n</code></pre>\n<p>为啥要继承Codable呢？<br>Codable 协议在 Swift4.0 开始被引入，目标是取代现有的 NSCoding 协议，它对结构体，枚举和类都支持。Codable 的引入简化了JSON 和 Swift 类型之间相互转换的难度，能够把 JSON 这种弱类型数据转换成代码中使用的强类型数据。具体可以看这篇文章：<a href=\"https://juejin.cn/post/6971997599725256734\">https://juejin.cn/post/6971997599725256734</a>。</p>\n<p>解析后就拿到服务端的数据了，可能是增量数据，可能是全量数据。后面我们具体分析下。</p>\n<h2 id=\"7-数据处理\"><a href=\"#7-数据处理\" class=\"headerlink\" title=\"7 数据处理\"></a>7 数据处理</h2><p>解析完毕后，我们有一段逻辑是这样的：</p>\n<pre><code class=\"line-numbers language-Swift\">if endTimeStr != nil &amp;&amp; (model.appProductVOList.count &gt;= 1000 || model.appProductRelVOList.count &gt;= 1000) &#123;\n                    Defaults[key:DefaultsKeys.updateTime] = nil\n                    OfflinePackageManager.update(updateTime: &quot;&quot;, successful: successful, failure: failure)\n                &#125; else &#123;\n                    if endTimeStr == nil &#123;\n                        OfflinePackageManager.fullUpdate(model: model)\n                    &#125; else &#123;\n                        OfflinePackageManager.incrementalUpdate(model: model)\n                    &#125;\n                    Defaults[key: DefaultsKeys.updateTime] = model.updateTime\n                    successful()\n                &#125;\n</code></pre>\n<p>这里如果数据大于1000条，我们重新走全量更新接口。<br>如果上次更新时间为空，我们默认为全量更新，将所有数据插入数据库。<br>如果上次更新时间不为空，而且小于1000条，我们就走增量更新逻辑。</p>\n<h3 id=\"7-1-Model层定义\"><a href=\"#7-1-Model层定义\" class=\"headerlink\" title=\"7.1 Model层定义\"></a>7.1 Model层定义</h3><p>这里是定义的Realm的基础模型。</p>\n<p>我们需要定义两个实体，一个是商品模型，一个是关系模型。</p>\n<p>商品模型为：</p>\n<pre><code class=\"line-numbers language-Swift\">\nclass StageGoodsPackgeModelData: Object,Codable&#123;\n    \n    @objc dynamic var barcode: String = &quot;&quot;\n    @objc dynamic var brand: String = &quot;&quot;\n    @objc dynamic var brandId: String = &quot;&quot;\n    @objc dynamic var category: String = &quot;&quot;\n    @objc dynamic var categoryId: Int = 0\n    @objc dynamic var createBy: String = &quot;&quot;\n    @objc dynamic var createTime: String = &quot;&quot;\n    @objc dynamic var delFlag: Int = 0\n    @objc dynamic var groupNum: Int = 1         //返回为&quot;&quot;时服务器需要传1\n    @objc dynamic var id: String = &quot;&quot;\n    @objc dynamic var isGreeProduct: Bool = false\n    @objc dynamic var isGroupedProduct: Bool = false\n    @objc dynamic var isSaleProduct: Bool = false\n    @objc dynamic var length: Double = 0.0\n    @objc dynamic var name: String = &quot;&quot;\n    @objc dynamic var orgId: String = &quot;&quot;\n    @objc dynamic var skuCode: String = &quot;&quot;\n    @objc dynamic var tall: Double = 0\n    @objc dynamic var unit: String = &quot;&quot;\n    @objc dynamic var updateBy: String = &quot;&quot;\n    @objc dynamic var updateTime: String = &quot;&quot;\n    @objc dynamic var volume: Double = 0.0\n    @objc dynamic var weight: Double = 0.0\n    @objc dynamic var wide: Double = 0.0\n    @objc dynamic var isMarketingProduct :Bool = false\n    \n    private enum Codingkeys: String, CodingKey&#123;\n        case barcode\n        ,brand\n        ,brandId\n        ,category\n        ,categoryId\n        ,createBy\n        ,createTime\n        ,delFlag\n        ,groupNum\n        ,id\n        ,isGreeProduct\n        ,isGroupedProduct\n        ,isSaleProduct\n        ,length\n        ,name\n        ,orgId\n        ,skuCode\n        ,tall\n        ,unit\n        ,updateBy\n        ,updateTime\n        ,volume\n        ,weight\n        ,wide,\n        isMarketingProduct\n    &#125;\n    \n    \n    required init(from decoder: Decoder) throws &#123;\n        let values = try decoder.container(keyedBy: Codingkeys.self)\n        \n        do &#123;\n            barcode = try values.decode(String.self, forKey: .barcode)\n        &#125; catch &#123;\n            barcode = &quot;&quot;\n        &#125;\n        do &#123;\n            brand = try values.decode(String.self, forKey: .brand)\n        &#125; catch &#123;\n            brand = &quot;&quot;\n        &#125;\n        do &#123;\n            brandId = try values.decode(String.self, forKey: .brandId)\n        &#125; catch &#123;\n            brandId = &quot;&quot;\n        &#125;\n        do &#123;\n            category = try values.decode(String.self, forKey: .category)\n        &#125; catch &#123;\n            category = &quot;&quot;\n        &#125;\n        do &#123;\n            categoryId = try values.decode(Int.self, forKey: .categoryId)\n        &#125; catch &#123;\n            categoryId = 0\n        &#125;\n        do &#123;\n            createBy = try values.decode(String.self, forKey: .createBy)\n        &#125; catch &#123;\n            createBy = &quot;&quot;\n        &#125;\n        do &#123;\n            createTime = try values.decode(String.self, forKey: .createTime)\n        &#125; catch &#123;\n            createTime = &quot;&quot;\n        &#125;\n        do &#123;\n            delFlag = try values.decode(Int.self, forKey: .delFlag)\n        &#125; catch &#123;\n            delFlag = 0\n        &#125;\n        do &#123;\n            groupNum = try values.decode(Int.self, forKey: .groupNum)\n        &#125; catch &#123;\n            groupNum = 1\n        &#125;\n        do &#123;\n            id = try values.decode(String.self, forKey: .id)\n        &#125; catch &#123;\n            id = &quot;&quot;\n        &#125;\n        do &#123;\n            isGreeProduct = try values.decode(Bool.self, forKey: .isGreeProduct)\n        &#125; catch &#123;\n            isGreeProduct = false\n        &#125;\n        do &#123;\n            isGroupedProduct = try values.decode(Bool.self, forKey: .isGroupedProduct)\n        &#125; catch &#123;\n            isGroupedProduct = false\n        &#125;\n        do &#123;\n            isSaleProduct = try values.decode(Bool.self, forKey: .isSaleProduct)\n        &#125; catch &#123;\n            isSaleProduct = false\n        &#125;\n        do &#123;\n            length = try values.decode(CGFloat.self, forKey: .length)\n        &#125; catch &#123;\n            length = 0.0\n        &#125;\n        do &#123;\n            name = try values.decode(String.self, forKey: .name)\n        &#125; catch &#123;\n            name = &quot;&quot;\n        &#125;\n        do &#123;\n            orgId = try values.decode(String.self, forKey: .orgId)\n        &#125; catch &#123;\n            orgId = &quot;&quot;\n        &#125;\n        do &#123;\n            skuCode = try values.decode(String.self, forKey: .skuCode)\n        &#125; catch &#123;\n            skuCode = &quot;&quot;\n        &#125;\n        do &#123;\n            tall = try values.decode(Double.self, forKey: .tall)\n        &#125; catch &#123;\n            tall = 0\n        &#125;\n        do &#123;\n            unit = try values.decode(String.self, forKey: .unit)\n        &#125; catch &#123;\n            unit = &quot;&quot;\n        &#125;\n        do &#123;\n            updateBy =  try values.decode(String.self, forKey: .updateBy)\n        &#125; catch &#123;\n            updateBy = &quot;&quot;\n        &#125;\n        do &#123;\n            updateTime = try values.decode(String.self, forKey: .updateTime)\n        &#125; catch &#123;\n            updateTime = &quot;&quot;\n        &#125;\n        do &#123;\n            volume = try values.decode(Double.self, forKey: .volume)\n        &#125; catch &#123;\n            volume = 0.0\n        &#125;\n        do &#123;\n            weight = try values.decode(Double.self, forKey: .weight)\n        &#125; catch &#123;\n            weight = 0.0\n        &#125;\n        do &#123;\n            wide = try values.decode(Double.self, forKey: .wide)\n        &#125; catch &#123;\n            wide = 0.0\n        &#125;\n        do &#123;\n            isMarketingProduct = try values.decode(Bool.self, forKey: .isMarketingProduct)\n        &#125; catch &#123;\n            isMarketingProduct = false\n        &#125;\n    &#125;\n    \n    func encode(to encoder: Encoder) throws &#123;&#125;\n    \n    override required init()&#123;&#125;\n&#125;\n</code></pre>\n<p>另外一个为：</p>\n<pre><code class=\"line-numbers language-Swift\">\nclass StageGoodsSuitPackgeModelData: Object,Codable&#123;\n\n    @objc dynamic var groupNum: Int = 0\n    @objc dynamic var id: String = &quot;&quot;\n    @objc dynamic var orgId: String = &quot;&quot;\n    @objc dynamic var productId: String = &quot;&quot;\n    @objc dynamic var subProductId: String = &quot;&quot;\n    \n    private enum Codingkeys: String, CodingKey &#123;\n        case groupNum\n        case id\n        case orgId\n        case productId\n        case subProductId\n    &#125;\n\n    required init(from decoder: Decoder) throws &#123;\n        let values = try decoder.container(keyedBy: Codingkeys.self)\n        \n        do &#123;\n            groupNum = try values.decode(Int.self, forKey: .groupNum)\n        &#125; catch &#123;\n            groupNum = 0\n        &#125;\n        do &#123;\n            id = try values.decode(String.self, forKey: .id)\n        &#125; catch &#123;\n            id = &quot;&quot;\n        &#125;\n        do &#123;\n            orgId = try values.decode(String.self, forKey: .orgId)\n        &#125; catch &#123;\n            orgId = &quot;&quot;\n        &#125;\n        do &#123;\n            productId = try values.decode(String.self, forKey: .productId)\n        &#125; catch &#123;\n            productId = &quot;&quot;\n        &#125;\n        do &#123;\n            subProductId = try values.decode(String.self, forKey: .subProductId)\n        &#125; catch &#123;\n            subProductId = &quot;&quot;\n        &#125;\n    &#125;\n\n    func encode(to encoder: Encoder) throws &#123;&#125;\n    \n    override required init()&#123;&#125;\n&#125;\n</code></pre>\n<h3 id=\"7-2-全量更新\"><a href=\"#7-2-全量更新\" class=\"headerlink\" title=\"7.2 全量更新\"></a>7.2 全量更新</h3><pre><code class=\"line-numbers language-Swift\">private class func fullUpdate(model: StageOfflinePackageData) &#123;\n        let suitResult = objectWithAll(objct: StageGoodsPackgeModelData.self)\n        if suitResult.count != 0 &#123;\n            deleteList(suitResult) &#123;\n                print(&quot;StageGoodsPackgeModelData表数据清除成功&quot;)\n            &#125;\n        &#125;\n        addList(model.appProductVOList) &#123;\n            print(&quot;StageGoodsPackgeModelData 插入成功&quot;)\n        &#125;\n        \n        let relationResult = objectWithAll(objct: StageGoodsSuitPackgeModelData.self)\n        if relationResult.count != 0 &#123;\n            deleteList(relationResult) &#123;\n                print(&quot;StageGoodsSuitPackgeModelData表数据清除成功&quot;)\n            &#125;\n        &#125;\n        addList(model.appProductRelVOList) &#123;\n            print(&quot;StageGoodsSuitPackgeModelData 插入成功&quot;)\n        &#125;\n    &#125;\n</code></pre>\n<p>如果是全量更新就比较简单了。<br>先把之前的那两个删除掉，然后新增新的model就好了。</p>\n<h3 id=\"7-3-增量更新\"><a href=\"#7-3-增量更新\" class=\"headerlink\" title=\"7.3 增量更新\"></a>7.3 增量更新</h3><p>先声明一下sql</p>\n<pre><code class=\"line-numbers language-Swift\">    private class func incrementalUpdate(model: StageOfflinePackageData) &#123;\n        print(&quot;增量处理开始时间----&gt;&quot;, Date().currentTime(0))\n        var addGoodsArr: [StageGoodsPackgeModelData] = []\n        var addRelationsArr: [StageGoodsSuitPackgeModelData] = []\n        var relationidArr: [String] = []\n        \n        var goodsSql = &quot;&quot;\n        var relationSql = &quot;&quot;\n        var deleteGoodsSql = &quot;&quot;\n        var deleteRelationSql = &quot;&quot;\n</code></pre>\n<p>遍历下服务端返回的增量数据库：</p>\n<pre><code class=\"line-numbers language-Swift\">for (_,suitModel) in model.appProductVOList.enumerated() &#123;\n    // delFlag为0表示，不是删除哦，这里是新增商品\n    if suitModel.delFlag == 0 &#123;\n        if goodsSql == &quot;&quot; &#123;\n            let str1 = String(format:&quot;id = &#39;%@&#39;&quot;, suitModel.id)\n            let str2 = String(format:&quot;productId = &#39;%@&#39;&quot;, suitModel.id)\n            goodsSql.append(str1)\n            relationSql.append(str2)\n        &#125; else &#123;\n            let str1 = String(format:&quot;|| id = &#39;%@&#39;&quot;, suitModel.id)\n            let str2 = String(format:&quot;|| productId = &#39;%@&#39;&quot;, suitModel.id)\n            goodsSql.append(str1)\n            relationSql.append(str2)\n        &#125;\n        addGoodsArr.append(suitModel)\n        relationidArr.append(suitModel.id)\n    &#125; else &#123;\n        // delFlag为1表示删除了商品\n        if deleteGoodsSql == &quot;&quot; &#123;\n            let str1 = String(format:&quot;id = &#39;%@&#39;&quot;, suitModel.id)\n            let str2 = String(format:&quot;productId = &#39;%@&#39;&quot;, suitModel.id)\n            deleteGoodsSql.append(str1)\n            deleteRelationSql.append(str2)\n        &#125; else &#123;\n            let str1 = String(format:&quot;|| id = &#39;%@&#39;&quot;, suitModel.id)\n            let str2 = String(format:&quot;|| productId = &#39;%@&#39;&quot;, suitModel.id)\n            deleteGoodsSql.append(str1)\n            deleteRelationSql.append(str2)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>有个一个delFlag变量，就是表示是否删除的意思。<br>如果是删除的话，将sql组合一下，就成为 id &#x3D; ‘12’ || id &#x3D; ‘13’ || id &#x3D; ‘14’ 这种。关系表就是 productId &#x3D; ‘12’ || productId &#x3D; ‘14’ 这种。</p>\n<p>这里就知道哪些商品要删除，哪些要加。哪些关系表要删除，哪些要加。</p>\n<p>这里先处理下新增的商品：</p>\n<pre><code class=\"line-numbers language-Swift\">if goodsSql != &quot;&quot; &#123;\n    let predicate = NSPredicate(format:goodsSql)\n    let suitArr = objectsWithPredicate(object: StageGoodsPackgeModelData.self, predicate: predicate)\n    // 这里需要把可能之前存在相同的去掉\n    deleteList(suitArr)&#123;\n        print(&quot;删除商品成功&quot;)\n    &#125;\n    if addGoodsArr.count != 0 &#123;\n        addList(addGoodsArr)&#123;\n            print(&quot;增量更新商品数据成功&quot;)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里用了系统的NSPredicate类来组合sql语句。它其实是用来过滤数据的类。<br>使用方法可以参考这篇文章：<a href=\"https://juejin.cn/post/6844903540805074951\">https://juejin.cn/post/6844903540805074951</a>。</p>\n<p>然后处理下要删除的商品：</p>\n<pre><code class=\"line-numbers language-Swift\"> if deleteGoodsSql != &quot;&quot; &#123;\n    // NSPredicate是swift 过滤数据的类，类似数据库中的where字段\n    let predicate = NSPredicate(format:deleteGoodsSql)\n    let suitArr = objectsWithPredicate(object: StageGoodsPackgeModelData.self, predicate: predicate)\n    deleteList(suitArr)&#123;\n        print(&quot;删除商品成功&quot;)\n    &#125;\n&#125;\n</code></pre>\n<p>商品处理完成，剩下就是关系表了。</p>\n<p>这里先处理要新增的关系：</p>\n<pre><code class=\"line-numbers language-Swift\">// 这里是新增的关系表\nfor idStr in relationidArr &#123;\n    for relationModel in model.appProductRelVOList&#123;\n        if idStr == relationModel.productId &#123;\n            addRelationsArr.append(relationModel)\n        &#125;\n    &#125;\n&#125;\n\n// 新增的关系表\nif relationSql != &quot;&quot; &#123;\n    let relationPredicate = NSPredicate(format:relationSql)\n    let relationArr = objectsWithPredicate(object: StageGoodsSuitPackgeModelData.self, predicate: relationPredicate)\n    deleteList(relationArr)&#123;\n        print(&quot;删除套机关系模型成功&quot;)\n    &#125;\n    if addRelationsArr.count != 0 &#123;\n        addList(addRelationsArr)&#123;\n            print(&quot;增量更新套机关系模型成功&quot;)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>然后处理下要删除的关系表：</p>\n<pre><code class=\"line-numbers language-Swift\"> if deleteRelationSql != &quot;&quot; &#123;\n    let relationPredicate = NSPredicate(format:deleteRelationSql)\n    let relationArr = objectsWithPredicate(object: StageGoodsSuitPackgeModelData.self, predicate: relationPredicate)\n    deleteList(relationArr)&#123;\n        print(&quot;删除套机关系模型成功&quot;)\n    &#125;\n&#125;\n</code></pre>\n<p>这样增量数据就成功插入了。</p>\n<h2 id=\"8-预览realm数据库\"><a href=\"#8-预览realm数据库\" class=\"headerlink\" title=\"8 预览realm数据库\"></a>8 预览realm数据库</h2><p>插入数据成功后，我们可以用 Realm Studio 来预览数据。<br>上面有讲解如何使用这个可视化工具。</p>\n<p>这里我们就看下最终的结果吧：<br><img src=realm1.png><br><img src=realm2.png></p>\n<h2 id=\"9-总结\"><a href=\"#9-总结\" class=\"headerlink\" title=\"9 总结\"></a>9 总结</h2><ul>\n<li><p>iOS数据库可以考虑使用realm数据库，这个是跨平台，Android也有相应的三方库，使用非常简洁，可以考虑。</p>\n</li>\n<li><p>对于大量数据，我们务必要注意数据的修改，新增，最好采用增量更新的方式，而且如果全量，最好是先压缩下，减小对网络依赖。</p>\n</li>\n<li><p>realm数据库要注意数据库迁移的问题，升级的问题，使用前需要configRealm。</p>\n</li>\n<li><p>真机预览realm数据库可以使用Realm Studio。</p>\n</li>\n<li><p>增量更新一定要注意删除之前的记录，否则数据会很紊乱。</p>\n</li>\n</ul>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-需求定义\"><a href=\"#1-需求定义\" class=\"headerlink\" title=\"1 需求定义\"></a>1 需求定义</h2><p>需要获取服务端的条码数据库，存放到本地数据库。</p>\n<p>背景：集成了扫码功能，扫到的条码头需要匹配数据库中的条码列表，可以认为这个是一个离线数据库。不会实时判断，因为条码很多，这里先获取所有的条码，存放到本地数据库。然后扫码就按照数据库中的关系表来匹配就好了。</p>\n<p>这里我们有两个表，一个商品库表，一个是关系表。为什么有2个表呢？因为我们有配套的关系，2个零件可以看做单个商品，他们组合了也可以看成单独商品哦，这种就是套机了。想必做个电商的人都懂这个道理。比如可以买一件上衣，一条裤子，它们都是独立商品，也可以配套组合一套商品，而且这一套也可以认为是一个商品。</p>\n<h2 id=\"2-需求分析\"><a href=\"#2-需求分析\" class=\"headerlink\" title=\"2 需求分析\"></a>2 需求分析</h2><p>这里我们采用 realm数据库。<br>realm非常简介，效率也是不错的。<br>github地址：<a href=\"https://github.com/realm/realm-swift\">https://github.com/realm/realm-swift</a></p>\n<p>简单描述下realm吧：Realm 是一个跨平台的移动数据库引擎，其性能要优于 Core Data 和 FMDB - 移动端数据库性能比较, 我们可以在 Android 端 realm-java，iOS端:Realm-Cocoa，同时支持 OC 和 Swift两种语言开发。其使用简单，免费，性能优异，跨平台的特点广受关注。</p>\n<p>这里我们会用到2个表。</p>\n<p>因为这是个离线数据库，我们需要考虑数据库变更，与服务端同步问题。<br>所以我们需要一个接口，判断有无新增或者变更的数据。</p>\n<p>需要考虑到增量更新，同时如果数据变更大于一个阙值，比如1000条数据，我们可以认为是全量更新。这时候全量更新的时间和增量插入数据时间几乎相同。</p>\n<p>另外如果第一次获取数据，数据量可能会很大，我们需要考虑压缩，与服务端商议，将json数据压缩，然后我们自行解析为实体类。</p>\n<p>另外增量更新的时候，要特别注意改数据是删除了还是新增的，还是变更的。<br>如果商品删除了，关系表也是要删除的哦。这点很重要，不然后期会导致匹配异常。</p>\n<h2 id=\"3-准备工作，会用Realm\"><a href=\"#3-准备工作，会用Realm\" class=\"headerlink\" title=\"3 准备工作，会用Realm\"></a>3 准备工作，会用Realm</h2><p>因为是从0开始，建议熟悉一下Realm使用方法。<br>可以参考下这篇博客：<a href=\"https://juejin.cn/post/6844904117442215944\">https://juejin.cn/post/6844904117442215944</a>,写得还是相当不错，有Demo，讲述得非常清晰易懂。</p>\n<p>这里就不讲解如何引用这个Realm了。</p>\n<p>这里需要会用一个工具：Realm Studio，<br>下载地址：<a href=\"https://www.mongodb.com/docs/realm/studio/install/\">https://www.mongodb.com/docs/realm/studio/install/</a><br>这里按照自己电脑版本下载相应软件就好了，这个也是免费的。</p>\n<p>如何分析真机里面的realm数据库呢？<br>可以参考下：<a href=\"https://blog.csdn.net/asfasnjn/article/details/124714242\">https://blog.csdn.net/asfasnjn/article/details/124714242</a> 很简单，打开XCode的window下的设备和模拟器，再 点击更多图标，再下载Container，然后下载后，查看包内容，就可以看到这个应用的realm文件了。然后可以右键，用我们下载好的Realm Studio来查看这个文件，文件以表格形式展示，清晰直观。</p>\n<h2 id=\"4-初始化配置数据库\"><a href=\"#4-初始化配置数据库\" class=\"headerlink\" title=\"4 初始化配置数据库\"></a>4 初始化配置数据库</h2><p>这里需要在AppDelegate中配置下realm数据库。<br>很简单的。<br>不过我们没有在AppDelegate初始化，因为我们这个绑定了userId，等用户登录后才初始化，当然也是可以的。</p>\n<p>重点是初始化这个动作要先于使用就行了。</p>\n<pre><code class=\"line-numbers language-Swift\">func configRealm(userID: String?,\n                        keyWord: String? = nil,\n                        schemaVersion: UInt64 = 2, migrationBlock: MigrationBlock? = nil) &#123;\n    // 加密串128位结果为：464e5774625e64306771702463336e316a4074487442325145766477335e21346b715169364c406c6a4976346d695958396245346e356f6a62256d2637566126\n    // let key: Data = &quot;FNWtb^d0gqp$c3n1j@tHtB2QEvdw3^!4kqQi6L@ljIv4miYX9bE4n5ojb%m&amp;7Va&amp;&quot;.data(using: .utf8, allowLossyConversion: false)!\n    // 加密的key\n    // let key: Data = keyWord.data(using: .utf8, allowLossyConversion: false)!\n    // 打开加密文件\n    // (encryptionKey: key)\n    // 使用默认的目录，但是使用用户 ID 来替换默认的文件名\n    \n    //schemaVersion 数据库版本号从0开始\n    let manager = FileManager.default\n    let document = manager.urls(for: .documentDirectory, in: .userDomainMask)\n    let url = document[0] as URL\n    let urlStr = url.absoluteString\n    let path = urlStr + &quot;/&quot; + (&quot;\\(userID!).realm&quot;)\n    let config = Realm.Configuration(fileURL: URL(string: path), schemaVersion: schemaVersion, migrationBlock: &#123; (migration, oldSchemaVersion) in\n        // 目前我们还未进行数据迁移，因此 oldSchemaVersion == 0\n        if oldSchemaVersion &lt; 100 &#123;\n            // 什么都不要做！Realm 会自行检测新增和需要移除的属性，然后自动更新硬盘上的数据库架构\n            // 属性重命名  migration.renameProperty(onType: Person.className(), from: &quot;yearsSinceBirth&quot;, to: &quot;age&quot;)\n            print(oldSchemaVersion)\n            print(&quot;end&quot;)\n        &#125;\n        // 低版本的数据库迁移......\n        if migrationBlock != nil &#123;\n            migrationBlock!(migration, oldSchemaVersion)\n        &#125;\n    &#125;)\n    // 告诉 Realm 为默认的 Realm 数据库使用这个新的配置对象\n    Realm.Configuration.defaultConfiguration = config\n    guard let realm = try? Realm(configuration: config) else &#123;\n        return\n    &#125;\n    currentSchemaVersion = schemaVersion\n    currentRealm = realm\n    currentKeyWord = keyWord\n&#125;\n</code></pre>\n<p>这个realm实际上以userId为名称了。<br>这样就有个弊端了，切换用户后，需要重新下载数据库，特别是数据库特别大的情况下，这对用户体验不是特别好。</p>\n<h2 id=\"5-走接口拿数据\"><a href=\"#5-走接口拿数据\" class=\"headerlink\" title=\"5 走接口拿数据\"></a>5 走接口拿数据</h2><p>这里就是拿商品数据了，这里服务端提供的接口，返回的是加密后的字符串。<br>类似这样：</p>\n<pre><code class=\"line-numbers language-Json\">&#123;\n  &quot;message&quot; : &quot;请求成功&quot;,\n  &quot;code&quot; : 1000,\n  &quot;data&quot; : &quot;H4sIAAAAAAAAAKtWSiwoCCjKTylNLglKzQnz98ksLlGyio7VQZJAFk3OzytJzQ\n  NyDA2NdJRKC1IS\\nS1JDMnNTlayUjAyMjHUNDHWNLBUMTaxMzaxMDJVqAQ0XaZphAAAA&quot;\n&#125;\n</code></pre>\n<p>比如我们接口是这样请求的，这里我们先扩展了一个方法给控制器：</p>\n<pre><code class=\"line-numbers language-Swift\">extension GMBaseViewController &#123;\n    \n    open func updateOfflinePackageData(tips: String = &quot;&quot;, successful: @escaping Handler) &#123;\n        MBProgressHUD.showMessage(tips)\n        OfflinePackageManager.update &#123;\n            successful()\n            MBProgressHUD.hide()\n            MBProgressHUD.hide()\n        &#125; failure: &#123;\n            MBProgressHUD.hide()\n            MBProgressHUD.hide()\n            let alerVC = UIAlertController(\n                title: &quot;&quot;,\n                message: &quot;检测到商品信息变动，系统为您自动更新商品信息失败，请在网络良好的环境下，手动更新商品信息&quot;,\n                preferredStyle: .alert\n            )\n            alerVC.addAction(\n                UIAlertAction(\n                    title: &quot;下载商品信息&quot;,\n                    style: .default\n                ) &#123; (action) in\n                    self.updateOfflinePackageData(successful: successful)\n                &#125;\n            )\n            self.present(alerVC, animated: true, completion:nil)\n        &#125;\n        \n    &#125;\n    \n&#125;\n</code></pre>\n<p>这里我们的OfflinePackageManager就是我们封装好的专门去下载离线库的工具类。<br>成功后走successful的逃逸闭包，失败弹一个弹框。</p>\n<p>继续走进去：</p>\n<pre><code class=\"line-numbers language-Swift\">class OfflinePackageManager: NSObject &#123;\n    \n    open class func update(\n        updateTime: String = Defaults[key: DefaultsKeys.updateTime] ?? &quot;&quot;,\n        successful: @escaping Handler,\n        failure: @escaping Handler\n    ) &#123;\n        let endTimeStr = Defaults[key: DefaultsKeys.updateTime]\n        let updateTimeStr = updateTime\n       \n        productProvider.requestJson(.getProductMetadataForAPP(updateTime: updateTimeStr)) &#123; response in\n            let jsonString = JSON(rawValue: response).jsonString\n            let result = GMBaseRequestModel.deserialize(from: jsonString)\n            if result?.code == 1000 &#123;\n                guard let data = result?.data?.gunzip?.data(using: .utf8) else &#123; return &#125;\n                \n                let file = &quot;zpi_offline_package_data.txt&quot;\n                let text = result?.data?.gunzip ?? &quot;&quot;\n                \n                if let dir = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first &#123;\n                    let fileURL = dir.appendingPathComponent(file)\n                    do &#123;\n                        try text.write(to: fileURL, atomically: false, encoding: .utf8)\n                    &#125; catch &#123;&#125;\n                &#125;\n                \n                guard let model = try? JSONDecoder().decode(StageOfflinePackageData.self, from: data) else &#123; return &#125;\n                \n                if endTimeStr != nil &amp;&amp; (model.appProductVOList.count &gt;= 1000 || model.appProductRelVOList.count &gt;= 1000) &#123;\n                    Defaults[key:DefaultsKeys.updateTime] = nil\n                    OfflinePackageManager.update(updateTime: &quot;&quot;, successful: successful, failure: failure)\n                &#125; else &#123;\n                    if endTimeStr == nil &#123;\n                        OfflinePackageManager.fullUpdate(model: model)\n                    &#125; else &#123;\n                        OfflinePackageManager.incrementalUpdate(model: model)\n                    &#125;\n                    Defaults[key: DefaultsKeys.updateTime] = model.updateTime\n                    successful()\n                &#125;\n            &#125; else &#123;\n                failure()\n            &#125;\n        &#125; failure: &#123; _ in\n            failure()\n        &#125;\n    &#125;\n</code></pre>\n<h2 id=\"6-解压缩字符串\"><a href=\"#6-解压缩字符串\" class=\"headerlink\" title=\"6 解压缩字符串\"></a>6 解压缩字符串</h2><p>这里服务端返回的一段加密后的字符串：</p>\n<pre><code class=\"line-numbers language-Json\">&#123;\n  &quot;message&quot; : &quot;请求成功&quot;,\n  &quot;code&quot; : 1000,\n  &quot;data&quot; : &quot;H4sIAAAAAAAAAKtWSiwoCCjKTylNLglKzQnz98ksLlGyio7VQZJAFk3OzytJzQNyDA2NdJRKC1IS\\nS1JDMnNTlayUjAyMjHUNDHWNLBUMTaxMzaxMDJVqAQ0XaZphAAAA&quot;\n&#125;\n</code></pre>\n<p>不过返回体还是json，我们先拿data里面的字符串。<br>再去解压缩。</p>\n<p>字符串解压缩可以参考这篇文章：<a href=\"https://www.cnblogs.com/strengthen/p/10844466.html\">https://www.cnblogs.com/strengthen/p/10844466.html</a></p>\n<p>这里我们用到了GzipSwift框架。</p>\n<p>这个框架地址为：<a href=\"https://github.com/1024jp/GzipSwift\">https://github.com/1024jp/GzipSwift</a> 还是有挺多人star的。</p>\n<p>具体细节就不讲解了。</p>\n<p>这里我们自己给String做了一个扩展，这样直接能拿到解压缩后的字符串：</p>\n<pre><code class=\"line-numbers language-Swift\">extension String &#123;\n    var gunzip: String? &#123;\n        if let data = Data(base64Encoded: self, options: .ignoreUnknownCharacters) &#123;\n            if data.isGzipped &#123;\n                if let gun = try? data.gunzipped() &#123;\n                    return String(data: gun, encoding: String.Encoding.utf8)\n                &#125;\n            &#125;\n        &#125;\n        return nil\n    &#125;\n&#125;\n</code></pre>\n<p>这里解析后的字符串为：</p>\n<pre><code class=\"line-numbers language-Json\">&#123;\n    &quot;appProductRelVOList&quot;:[],\n    &quot;appProductVOList&quot;:[],\n    &quot;content&quot;:112,\n    &quot;updateTime&quot;:&quot;2023-01-29 14:56:41&quot;\n&#125;\n</code></pre>\n<p>同样也是一个json数组哦。<br>所以我们还是得用Json解析下：</p>\n<pre><code class=\"line-numbers language-Swift\">guard let model = try? JSONDecoder().decode(StageOfflinePackageData.self, from: data)\n                else &#123; return &#125;\n</code></pre>\n<p>这时候我们需要一个实体来接收下：</p>\n<pre><code class=\"line-numbers language-Swift\">class StageOfflinePackageData:Codable&#123;\n    \n    var appProductVOList: [StageGoodsPackgeModelData] = []\n    \n    var appProductRelVOList: [StageGoodsSuitPackgeModelData] = []\n    \n    var updateTime: String = &quot;&quot;\n    \n    \n    private enum Codingkeys: String, CodingKey&#123;\n        case appProductVOList,appProductRelVOList,updateTime\n    &#125;\n    \n    func encode(to encoder: Encoder) throws &#123;&#125;\n    \n    required init(from decoder: Decoder) throws &#123;\n        let values = try decoder.container(keyedBy: Codingkeys.self)\n        appProductVOList = try values.decode(Array.self, forKey: .appProductVOList)\n        appProductRelVOList = try values.decode(Array.self, forKey: .appProductRelVOList)\n        updateTime = try values.decode(String.self, forKey: .updateTime)\n    &#125;\n&#125;\n</code></pre>\n<p>为啥要继承Codable呢？<br>Codable 协议在 Swift4.0 开始被引入，目标是取代现有的 NSCoding 协议，它对结构体，枚举和类都支持。Codable 的引入简化了JSON 和 Swift 类型之间相互转换的难度，能够把 JSON 这种弱类型数据转换成代码中使用的强类型数据。具体可以看这篇文章：<a href=\"https://juejin.cn/post/6971997599725256734\">https://juejin.cn/post/6971997599725256734</a>。</p>\n<p>解析后就拿到服务端的数据了，可能是增量数据，可能是全量数据。后面我们具体分析下。</p>\n<h2 id=\"7-数据处理\"><a href=\"#7-数据处理\" class=\"headerlink\" title=\"7 数据处理\"></a>7 数据处理</h2><p>解析完毕后，我们有一段逻辑是这样的：</p>\n<pre><code class=\"line-numbers language-Swift\">if endTimeStr != nil &amp;&amp; (model.appProductVOList.count &gt;= 1000 || model.appProductRelVOList.count &gt;= 1000) &#123;\n                    Defaults[key:DefaultsKeys.updateTime] = nil\n                    OfflinePackageManager.update(updateTime: &quot;&quot;, successful: successful, failure: failure)\n                &#125; else &#123;\n                    if endTimeStr == nil &#123;\n                        OfflinePackageManager.fullUpdate(model: model)\n                    &#125; else &#123;\n                        OfflinePackageManager.incrementalUpdate(model: model)\n                    &#125;\n                    Defaults[key: DefaultsKeys.updateTime] = model.updateTime\n                    successful()\n                &#125;\n</code></pre>\n<p>这里如果数据大于1000条，我们重新走全量更新接口。<br>如果上次更新时间为空，我们默认为全量更新，将所有数据插入数据库。<br>如果上次更新时间不为空，而且小于1000条，我们就走增量更新逻辑。</p>\n<h3 id=\"7-1-Model层定义\"><a href=\"#7-1-Model层定义\" class=\"headerlink\" title=\"7.1 Model层定义\"></a>7.1 Model层定义</h3><p>这里是定义的Realm的基础模型。</p>\n<p>我们需要定义两个实体，一个是商品模型，一个是关系模型。</p>\n<p>商品模型为：</p>\n<pre><code class=\"line-numbers language-Swift\">\nclass StageGoodsPackgeModelData: Object,Codable&#123;\n    \n    @objc dynamic var barcode: String = &quot;&quot;\n    @objc dynamic var brand: String = &quot;&quot;\n    @objc dynamic var brandId: String = &quot;&quot;\n    @objc dynamic var category: String = &quot;&quot;\n    @objc dynamic var categoryId: Int = 0\n    @objc dynamic var createBy: String = &quot;&quot;\n    @objc dynamic var createTime: String = &quot;&quot;\n    @objc dynamic var delFlag: Int = 0\n    @objc dynamic var groupNum: Int = 1         //返回为&quot;&quot;时服务器需要传1\n    @objc dynamic var id: String = &quot;&quot;\n    @objc dynamic var isGreeProduct: Bool = false\n    @objc dynamic var isGroupedProduct: Bool = false\n    @objc dynamic var isSaleProduct: Bool = false\n    @objc dynamic var length: Double = 0.0\n    @objc dynamic var name: String = &quot;&quot;\n    @objc dynamic var orgId: String = &quot;&quot;\n    @objc dynamic var skuCode: String = &quot;&quot;\n    @objc dynamic var tall: Double = 0\n    @objc dynamic var unit: String = &quot;&quot;\n    @objc dynamic var updateBy: String = &quot;&quot;\n    @objc dynamic var updateTime: String = &quot;&quot;\n    @objc dynamic var volume: Double = 0.0\n    @objc dynamic var weight: Double = 0.0\n    @objc dynamic var wide: Double = 0.0\n    @objc dynamic var isMarketingProduct :Bool = false\n    \n    private enum Codingkeys: String, CodingKey&#123;\n        case barcode\n        ,brand\n        ,brandId\n        ,category\n        ,categoryId\n        ,createBy\n        ,createTime\n        ,delFlag\n        ,groupNum\n        ,id\n        ,isGreeProduct\n        ,isGroupedProduct\n        ,isSaleProduct\n        ,length\n        ,name\n        ,orgId\n        ,skuCode\n        ,tall\n        ,unit\n        ,updateBy\n        ,updateTime\n        ,volume\n        ,weight\n        ,wide,\n        isMarketingProduct\n    &#125;\n    \n    \n    required init(from decoder: Decoder) throws &#123;\n        let values = try decoder.container(keyedBy: Codingkeys.self)\n        \n        do &#123;\n            barcode = try values.decode(String.self, forKey: .barcode)\n        &#125; catch &#123;\n            barcode = &quot;&quot;\n        &#125;\n        do &#123;\n            brand = try values.decode(String.self, forKey: .brand)\n        &#125; catch &#123;\n            brand = &quot;&quot;\n        &#125;\n        do &#123;\n            brandId = try values.decode(String.self, forKey: .brandId)\n        &#125; catch &#123;\n            brandId = &quot;&quot;\n        &#125;\n        do &#123;\n            category = try values.decode(String.self, forKey: .category)\n        &#125; catch &#123;\n            category = &quot;&quot;\n        &#125;\n        do &#123;\n            categoryId = try values.decode(Int.self, forKey: .categoryId)\n        &#125; catch &#123;\n            categoryId = 0\n        &#125;\n        do &#123;\n            createBy = try values.decode(String.self, forKey: .createBy)\n        &#125; catch &#123;\n            createBy = &quot;&quot;\n        &#125;\n        do &#123;\n            createTime = try values.decode(String.self, forKey: .createTime)\n        &#125; catch &#123;\n            createTime = &quot;&quot;\n        &#125;\n        do &#123;\n            delFlag = try values.decode(Int.self, forKey: .delFlag)\n        &#125; catch &#123;\n            delFlag = 0\n        &#125;\n        do &#123;\n            groupNum = try values.decode(Int.self, forKey: .groupNum)\n        &#125; catch &#123;\n            groupNum = 1\n        &#125;\n        do &#123;\n            id = try values.decode(String.self, forKey: .id)\n        &#125; catch &#123;\n            id = &quot;&quot;\n        &#125;\n        do &#123;\n            isGreeProduct = try values.decode(Bool.self, forKey: .isGreeProduct)\n        &#125; catch &#123;\n            isGreeProduct = false\n        &#125;\n        do &#123;\n            isGroupedProduct = try values.decode(Bool.self, forKey: .isGroupedProduct)\n        &#125; catch &#123;\n            isGroupedProduct = false\n        &#125;\n        do &#123;\n            isSaleProduct = try values.decode(Bool.self, forKey: .isSaleProduct)\n        &#125; catch &#123;\n            isSaleProduct = false\n        &#125;\n        do &#123;\n            length = try values.decode(CGFloat.self, forKey: .length)\n        &#125; catch &#123;\n            length = 0.0\n        &#125;\n        do &#123;\n            name = try values.decode(String.self, forKey: .name)\n        &#125; catch &#123;\n            name = &quot;&quot;\n        &#125;\n        do &#123;\n            orgId = try values.decode(String.self, forKey: .orgId)\n        &#125; catch &#123;\n            orgId = &quot;&quot;\n        &#125;\n        do &#123;\n            skuCode = try values.decode(String.self, forKey: .skuCode)\n        &#125; catch &#123;\n            skuCode = &quot;&quot;\n        &#125;\n        do &#123;\n            tall = try values.decode(Double.self, forKey: .tall)\n        &#125; catch &#123;\n            tall = 0\n        &#125;\n        do &#123;\n            unit = try values.decode(String.self, forKey: .unit)\n        &#125; catch &#123;\n            unit = &quot;&quot;\n        &#125;\n        do &#123;\n            updateBy =  try values.decode(String.self, forKey: .updateBy)\n        &#125; catch &#123;\n            updateBy = &quot;&quot;\n        &#125;\n        do &#123;\n            updateTime = try values.decode(String.self, forKey: .updateTime)\n        &#125; catch &#123;\n            updateTime = &quot;&quot;\n        &#125;\n        do &#123;\n            volume = try values.decode(Double.self, forKey: .volume)\n        &#125; catch &#123;\n            volume = 0.0\n        &#125;\n        do &#123;\n            weight = try values.decode(Double.self, forKey: .weight)\n        &#125; catch &#123;\n            weight = 0.0\n        &#125;\n        do &#123;\n            wide = try values.decode(Double.self, forKey: .wide)\n        &#125; catch &#123;\n            wide = 0.0\n        &#125;\n        do &#123;\n            isMarketingProduct = try values.decode(Bool.self, forKey: .isMarketingProduct)\n        &#125; catch &#123;\n            isMarketingProduct = false\n        &#125;\n    &#125;\n    \n    func encode(to encoder: Encoder) throws &#123;&#125;\n    \n    override required init()&#123;&#125;\n&#125;\n</code></pre>\n<p>另外一个为：</p>\n<pre><code class=\"line-numbers language-Swift\">\nclass StageGoodsSuitPackgeModelData: Object,Codable&#123;\n\n    @objc dynamic var groupNum: Int = 0\n    @objc dynamic var id: String = &quot;&quot;\n    @objc dynamic var orgId: String = &quot;&quot;\n    @objc dynamic var productId: String = &quot;&quot;\n    @objc dynamic var subProductId: String = &quot;&quot;\n    \n    private enum Codingkeys: String, CodingKey &#123;\n        case groupNum\n        case id\n        case orgId\n        case productId\n        case subProductId\n    &#125;\n\n    required init(from decoder: Decoder) throws &#123;\n        let values = try decoder.container(keyedBy: Codingkeys.self)\n        \n        do &#123;\n            groupNum = try values.decode(Int.self, forKey: .groupNum)\n        &#125; catch &#123;\n            groupNum = 0\n        &#125;\n        do &#123;\n            id = try values.decode(String.self, forKey: .id)\n        &#125; catch &#123;\n            id = &quot;&quot;\n        &#125;\n        do &#123;\n            orgId = try values.decode(String.self, forKey: .orgId)\n        &#125; catch &#123;\n            orgId = &quot;&quot;\n        &#125;\n        do &#123;\n            productId = try values.decode(String.self, forKey: .productId)\n        &#125; catch &#123;\n            productId = &quot;&quot;\n        &#125;\n        do &#123;\n            subProductId = try values.decode(String.self, forKey: .subProductId)\n        &#125; catch &#123;\n            subProductId = &quot;&quot;\n        &#125;\n    &#125;\n\n    func encode(to encoder: Encoder) throws &#123;&#125;\n    \n    override required init()&#123;&#125;\n&#125;\n</code></pre>\n<h3 id=\"7-2-全量更新\"><a href=\"#7-2-全量更新\" class=\"headerlink\" title=\"7.2 全量更新\"></a>7.2 全量更新</h3><pre><code class=\"line-numbers language-Swift\">private class func fullUpdate(model: StageOfflinePackageData) &#123;\n        let suitResult = objectWithAll(objct: StageGoodsPackgeModelData.self)\n        if suitResult.count != 0 &#123;\n            deleteList(suitResult) &#123;\n                print(&quot;StageGoodsPackgeModelData表数据清除成功&quot;)\n            &#125;\n        &#125;\n        addList(model.appProductVOList) &#123;\n            print(&quot;StageGoodsPackgeModelData 插入成功&quot;)\n        &#125;\n        \n        let relationResult = objectWithAll(objct: StageGoodsSuitPackgeModelData.self)\n        if relationResult.count != 0 &#123;\n            deleteList(relationResult) &#123;\n                print(&quot;StageGoodsSuitPackgeModelData表数据清除成功&quot;)\n            &#125;\n        &#125;\n        addList(model.appProductRelVOList) &#123;\n            print(&quot;StageGoodsSuitPackgeModelData 插入成功&quot;)\n        &#125;\n    &#125;\n</code></pre>\n<p>如果是全量更新就比较简单了。<br>先把之前的那两个删除掉，然后新增新的model就好了。</p>\n<h3 id=\"7-3-增量更新\"><a href=\"#7-3-增量更新\" class=\"headerlink\" title=\"7.3 增量更新\"></a>7.3 增量更新</h3><p>先声明一下sql</p>\n<pre><code class=\"line-numbers language-Swift\">    private class func incrementalUpdate(model: StageOfflinePackageData) &#123;\n        print(&quot;增量处理开始时间----&gt;&quot;, Date().currentTime(0))\n        var addGoodsArr: [StageGoodsPackgeModelData] = []\n        var addRelationsArr: [StageGoodsSuitPackgeModelData] = []\n        var relationidArr: [String] = []\n        \n        var goodsSql = &quot;&quot;\n        var relationSql = &quot;&quot;\n        var deleteGoodsSql = &quot;&quot;\n        var deleteRelationSql = &quot;&quot;\n</code></pre>\n<p>遍历下服务端返回的增量数据库：</p>\n<pre><code class=\"line-numbers language-Swift\">for (_,suitModel) in model.appProductVOList.enumerated() &#123;\n    // delFlag为0表示，不是删除哦，这里是新增商品\n    if suitModel.delFlag == 0 &#123;\n        if goodsSql == &quot;&quot; &#123;\n            let str1 = String(format:&quot;id = &#39;%@&#39;&quot;, suitModel.id)\n            let str2 = String(format:&quot;productId = &#39;%@&#39;&quot;, suitModel.id)\n            goodsSql.append(str1)\n            relationSql.append(str2)\n        &#125; else &#123;\n            let str1 = String(format:&quot;|| id = &#39;%@&#39;&quot;, suitModel.id)\n            let str2 = String(format:&quot;|| productId = &#39;%@&#39;&quot;, suitModel.id)\n            goodsSql.append(str1)\n            relationSql.append(str2)\n        &#125;\n        addGoodsArr.append(suitModel)\n        relationidArr.append(suitModel.id)\n    &#125; else &#123;\n        // delFlag为1表示删除了商品\n        if deleteGoodsSql == &quot;&quot; &#123;\n            let str1 = String(format:&quot;id = &#39;%@&#39;&quot;, suitModel.id)\n            let str2 = String(format:&quot;productId = &#39;%@&#39;&quot;, suitModel.id)\n            deleteGoodsSql.append(str1)\n            deleteRelationSql.append(str2)\n        &#125; else &#123;\n            let str1 = String(format:&quot;|| id = &#39;%@&#39;&quot;, suitModel.id)\n            let str2 = String(format:&quot;|| productId = &#39;%@&#39;&quot;, suitModel.id)\n            deleteGoodsSql.append(str1)\n            deleteRelationSql.append(str2)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>有个一个delFlag变量，就是表示是否删除的意思。<br>如果是删除的话，将sql组合一下，就成为 id &#x3D; ‘12’ || id &#x3D; ‘13’ || id &#x3D; ‘14’ 这种。关系表就是 productId &#x3D; ‘12’ || productId &#x3D; ‘14’ 这种。</p>\n<p>这里就知道哪些商品要删除，哪些要加。哪些关系表要删除，哪些要加。</p>\n<p>这里先处理下新增的商品：</p>\n<pre><code class=\"line-numbers language-Swift\">if goodsSql != &quot;&quot; &#123;\n    let predicate = NSPredicate(format:goodsSql)\n    let suitArr = objectsWithPredicate(object: StageGoodsPackgeModelData.self, predicate: predicate)\n    // 这里需要把可能之前存在相同的去掉\n    deleteList(suitArr)&#123;\n        print(&quot;删除商品成功&quot;)\n    &#125;\n    if addGoodsArr.count != 0 &#123;\n        addList(addGoodsArr)&#123;\n            print(&quot;增量更新商品数据成功&quot;)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里用了系统的NSPredicate类来组合sql语句。它其实是用来过滤数据的类。<br>使用方法可以参考这篇文章：<a href=\"https://juejin.cn/post/6844903540805074951\">https://juejin.cn/post/6844903540805074951</a>。</p>\n<p>然后处理下要删除的商品：</p>\n<pre><code class=\"line-numbers language-Swift\"> if deleteGoodsSql != &quot;&quot; &#123;\n    // NSPredicate是swift 过滤数据的类，类似数据库中的where字段\n    let predicate = NSPredicate(format:deleteGoodsSql)\n    let suitArr = objectsWithPredicate(object: StageGoodsPackgeModelData.self, predicate: predicate)\n    deleteList(suitArr)&#123;\n        print(&quot;删除商品成功&quot;)\n    &#125;\n&#125;\n</code></pre>\n<p>商品处理完成，剩下就是关系表了。</p>\n<p>这里先处理要新增的关系：</p>\n<pre><code class=\"line-numbers language-Swift\">// 这里是新增的关系表\nfor idStr in relationidArr &#123;\n    for relationModel in model.appProductRelVOList&#123;\n        if idStr == relationModel.productId &#123;\n            addRelationsArr.append(relationModel)\n        &#125;\n    &#125;\n&#125;\n\n// 新增的关系表\nif relationSql != &quot;&quot; &#123;\n    let relationPredicate = NSPredicate(format:relationSql)\n    let relationArr = objectsWithPredicate(object: StageGoodsSuitPackgeModelData.self, predicate: relationPredicate)\n    deleteList(relationArr)&#123;\n        print(&quot;删除套机关系模型成功&quot;)\n    &#125;\n    if addRelationsArr.count != 0 &#123;\n        addList(addRelationsArr)&#123;\n            print(&quot;增量更新套机关系模型成功&quot;)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>然后处理下要删除的关系表：</p>\n<pre><code class=\"line-numbers language-Swift\"> if deleteRelationSql != &quot;&quot; &#123;\n    let relationPredicate = NSPredicate(format:deleteRelationSql)\n    let relationArr = objectsWithPredicate(object: StageGoodsSuitPackgeModelData.self, predicate: relationPredicate)\n    deleteList(relationArr)&#123;\n        print(&quot;删除套机关系模型成功&quot;)\n    &#125;\n&#125;\n</code></pre>\n<p>这样增量数据就成功插入了。</p>\n<h2 id=\"8-预览realm数据库\"><a href=\"#8-预览realm数据库\" class=\"headerlink\" title=\"8 预览realm数据库\"></a>8 预览realm数据库</h2><p>插入数据成功后，我们可以用 Realm Studio 来预览数据。<br>上面有讲解如何使用这个可视化工具。</p>\n<p>这里我们就看下最终的结果吧：<br><img src=realm1.png><br><img src=realm2.png></p>\n<h2 id=\"9-总结\"><a href=\"#9-总结\" class=\"headerlink\" title=\"9 总结\"></a>9 总结</h2><ul>\n<li><p>iOS数据库可以考虑使用realm数据库，这个是跨平台，Android也有相应的三方库，使用非常简洁，可以考虑。</p>\n</li>\n<li><p>对于大量数据，我们务必要注意数据的修改，新增，最好采用增量更新的方式，而且如果全量，最好是先压缩下，减小对网络依赖。</p>\n</li>\n<li><p>realm数据库要注意数据库迁移的问题，升级的问题，使用前需要configRealm。</p>\n</li>\n<li><p>真机预览realm数据库可以使用Realm Studio。</p>\n</li>\n<li><p>增量更新一定要注意删除之前的记录，否则数据会很紊乱。</p>\n</li>\n</ul>\n"},{"title":"iOS swift 混编Flutter","date":"2023-02-01T12:05:20.000Z","top":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 集成Flutter原因\n\n最除是项目人员调动，导致产品和开发数量不匹配。领导打算使用跨平台方案，但原有项目都是基于原生实现，如果想转Flutter，肯定得先考虑混编方案，因为需求也是持续迭代的，而且市场上也是由先例，可行性肯定是没问题的。\n\n所以我们考虑使用阿里的Flutter Boost来实现混编，因为已经经过大型App测试过的，我们项目完全是可以用起来的。\n\n## 2 Flutter Boost 初识\n\n从0开始实现混编，首先当然是了解 Flutter Boost如何使用。\n先看下官方文档：[https://github.com/alibaba/flutter_boost/blob/master/docs/install.md](https://github.com/alibaba/flutter_boost/blob/master/docs/install.md)。\n\n文档也很清楚，其它博客没必要重复看了。\n\n大概几个步骤吧：\n* 引用三方库\n* 新建一个代理类，继承FlutterBoostDelegate\n* AppDelegate初始化引擎\n\n## 3 项目结构和引入三方库\n\n这里我们将原生的代码和Flutter代码分两个仓库。\n比如在iOS项目的父文件夹下创建一个Flutter项目，这里面就放Flutter的代码。\n\n首先要明确一点，Flutter Boost是 Flutter代码里面用的三方库。\n这里配置项目结构是混编所需，不是因为依赖了Flutter Boost才这样引用。\n\n为什么原生能用Flutter Boost里面的一些类呢？\n\n这里并不是原生依赖了。\n\n原因是原生项目通过在podFile文件里面配置Flutter项目路径，建立起了链接关系。\n此时原生就可以正常访问Flutter项目里面依赖的三方库提供的一些类了。\n此时就可以在AppDelegate用Flutter Boost提供的类了。\n\n我们是这样配置的：\n```\n# flutter 集成\nflutter_application_path = '../../flutter-pin-module'\nload File.join(flutter_application_path, '.ios', 'Flutter', 'podhelper.rb')\n\nuse_frameworks!\n\ntarget 'GreeSalesSystem' do\n\n# flutter 集成\n  install_all_flutter_pods(flutter_application_path)\n```\n\n这里路径为父文件的父文件下的“flutter-pin-module”，我们将flutter部分单独放置在这个文件夹下，其实这个Flutter部分也是可以单独编译，单独用Android Studio或者VS Code跑起来。\n\n最后再走一次pod install。\n\n这样就成功引入Flutter Boost，可以愉快地在原生项目进行Flutter配置了。\n\n另外可能会有编译问题,没问题就不用加了。\n在podFile文件夹最下面需要加上这段代码：\n```\npost_install do |installer|\n    flutter_post_install(installer) if defined?(flutter_post_install)\n    installer.pods_project.build_configurations.each do |config|\n        config.build_settings[\"EXCLUDED_ARCHS[sdk=iphonesimulator*]\"] = \"arm64\"\n    end\nend\n```\n\n## 4 原生项目配置Flutter\n\n### 4.1 自定义FlutterBoostDelegate\n\n```Swift\n// Flutter Boost 架构Delegate\n// 参考： https://github.com/alibaba/flutter_boost/blob/master/docs/install.md\nclass GMFlutterBoostDelegate : NSObject, FlutterBoostDelegate {\n    \n    ///您用来push的导航栏\n    var navigationController: UINavigationController?\n    \n    ///用来存返回flutter侧返回结果的表\n    var resultTable: Dictionary<String,([AnyHashable:Any]?)->Void> = [:];\n    \n    /// Flutter 跳转 原生\n    func pushNativeRoute(_ pageName: String!, arguments: [AnyHashable : Any]!) {\n        GMFlutterNavigator.pushNative(pageName, arguments: arguments)\n        return\n    }\n    \n    /// 原生 跳转 Flutter\n    func pushFlutterRoute(_ options: FlutterBoostRouteOptions!) {\n        //对这个页面设置结果\n        resultTable[options.pageName] = options.onPageFinished;\n        \n        //用参数来控制是push还是pop\n        let isPresent = (options.arguments?[\"isPresent\"] as? Bool)  ?? false\n        var isAnimated = (options.arguments?[\"isAnimated\"] as? Bool) ?? true\n        \n        // 分销入库成功   distributeWarehousingSuccessPage\n        var vc: FBFlutterViewContainer\n        if options.pageName == DistributeWarehousingSuccessPage.pageName {\n            vc = DistributeWarehousingSuccessPage()\n        } else {\n            .......\n        }\n        \n        vc.hidesBottomBarWhenPushed = true\n        vc.setName(options.pageName, uniqueId: options.uniqueId, params: options.arguments,opaque: options.opaque)\n        \n        \n        //如果是present模式 ，或者要不透明模式，那么就需要以present模式打开页面\n        if(isPresent || !options.opaque){\n            self.navigationController?.present(vc, animated: isAnimated, completion: nil)\n        }else{\n            self.navigationController?.pushViewController(vc, animated: isAnimated)\n        }\n    }\n    \n    /// 原生 pop Flutter\n    func popRoute(_ options: FlutterBoostRouteOptions!) {\n        var animated = true\n        if options.pageName == DisPromotionChooseShopStoreViewController.pageName {\n            animated = false\n        }\n        //如果当前被present的vc是container，那么就执行dismiss逻辑\n        if let vc = self.navigationController?.presentedViewController as? FBFlutterViewContainer, vc.uniqueIDString() == options.uniqueId {\n            \n            //这里分为两种情况，由于UIModalPresentationOverFullScreen下，生命周期显示会有问题\n            //所以需要手动调用的场景，从而使下面底部的vc调用viewAppear相关逻辑\n            if vc.modalPresentationStyle == .overFullScreen {\n                \n                //这里手动beginAppearanceTransition触发页面生命周期\n                self.navigationController?.topViewController?.beginAppearanceTransition(true, animated: false)\n                \n                \n                vc.dismiss(animated: animated) {\n                    self.navigationController?.topViewController?.endAppearanceTransition()\n                }\n            }else{\n                //正常场景，直接dismiss\n                vc.dismiss(animated: animated, completion: nil)\n            }\n        }else{\n            self.navigationController?.popViewController(animated: animated)\n        }\n        //否则直接执行pop逻辑\n        //这里在pop的时候将参数带出,并且从结果表中移除\n        if let onPageFinshed = resultTable[options.pageName] {\n            onPageFinshed(options.arguments)\n            resultTable.removeValue(forKey: options.pageName)\n        }\n    }\n    \n}\n```\n\nFlutter 跳转 原生 主要用这个：pushNativeRoute 方法\n原生 跳转 Flutter 主要用这个： pushFlutterRoute 方法\n\n### 4.2 承载Flutter的容器\n\n其实说白了，Flutter页面本质上还是Controller。\n我们调整到任何一个Flutter，其实都是先跳自己的Controller。\n如下：\n```Swift\nclass DisPromotionChooseShopStoreViewController: FBFlutterViewContainer {\n    \n    static var pageName = \"disPromotionChooseShopStore\"\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n    }\n\n\n}\n```\n这里就是跳转到Flutter的某个页面。\n因为它继承了FBFlutterViewContainer，这个是阿里提供的。\n\n实际上就是一个Controller呀。\n\n### 4.3 应用启动初始化\n\n这个需要再AppDelegate中完成。\n可以搞个扩展方法：\n```Swift\nextension AppDelegate {\n    /// 设置flutter\n    func configFlutterBoost(_ application: UIApplication) {\n        //创建代理，做初始化操作\n        let delegate = GMFlutterBoostDelegate()\n        FlutterBoost.instance().setup(application, delegate: delegate) { engine in\n            \n        }\n    }\n}\n```\n这里面的delegate就是我们前面新建的一个Delegate。\n\n就这样混编没啥问题了。\n\n## 5 混编打包\n\n这里可能还有几个坑要注意下。\n\n在Flutter模块下执行：flutter build ios 报错\n \n 首先我要确保Flutter模块能够在iOS真机上跑起来\n\n### 5.1 真机运行报错\n\n参考了这篇文章：\n[https://honkersk.github.io/2020/07/02/Flutter-09-Flutter%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/](https://honkersk.github.io/2020/07/02/Flutter-09-Flutter%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/)\n\n我这边发现用Xcode单独跑，总是说有些类not found，所以我用Android Studio跑好像可以了。\n\n如果有些依赖有问题可以执行如下命令：\n```\nflutter pub upgrade\npod update\n```\n\n如果还不行可以将flutter项目clean下：\n```\nflutter clean\nflutter pub get\n```\n这样是全新的系统创建的.iOS文件夹，基本没啥问题。\n\n### 5.2 执行flutter build ios 报错\n\n这里报错了的话，先别google。\n\n可以先 flutter clean 再flutter pub get\n然后走 flutter build ios --release --no-codesign\n\n如果有一些shake 图标报错，可以运行这个指令看下：\n`flutter build ios --release --no-tree-shake-icons`\n\n啥都不用改，一次不行，多走几次，我这里试了3次，就成功了。\n<img src=fluttererror2.png>\n这里尝试了几次build，结果成功生成产物了。\n生成路径在flutter模块下的build下的ios文件夹中。\n\n\n### 5.3 build ios 产物分析\n<table><thead><tr><th>产物</th><th>介绍</th></tr></thead><tbody><tr><td>App.framework</td><td>Dart业务源码相关文件，在Debug模式下就是一个很小的空壳，在Release模式下包含全部业务逻辑。</td></tr><tr><td>flutter_assets</td><td>Flutter依赖的静态资源，如字体、图片等。<br><strong>在Flutter 1.9.1这种已经被合并进App.framework</strong>。</td></tr><tr><td>FlutterPluginRegistrant</td><td>Flutter插件注册制，自动注册Flutter插件。</td></tr><tr><td>Flutter.framework</td><td>Flutter库和引擎。</td></tr><tr><td>.symlinks</td><td>指向Flutter插件依赖库的实际地址。</td></tr></tbody></table>\n\n### 5.4 启动App闪退问题\n\n解决方案很简单：在原生主工程配置Release模式 进行archive编译构建\n<img src=fluttererror03.png>\n\n\n## 6 总结\n\n* 明确Flutter混编是系统支持，不是阿里提供的能力，Flutter Boost只是封装好的一个方便混编的工具，其实完全可以不用Flutter Boost，只是为了更好实现混编而已。\n\n* 三部曲，先引入依赖，通过Flutter模块引入，然后通过链接关系，原生可以访问到Flutter依赖，此时再配置Delegate，最后再初始化引擎。\n\n* 打包遇到问题不要急，先保证在真机上能运行起来。然后再走 flutter build ios命令，一次不行，走多次，有其它问题加后缀解决。","source":"_posts/iOS-swift-混编Flutter.md","raw":"---\ntitle: iOS swift 混编Flutter\ndate: 2023-02-01 20:05:20\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- 混编Flutter\ncategories:\n- iOS\n---\n\n## 1 集成Flutter原因\n\n最除是项目人员调动，导致产品和开发数量不匹配。领导打算使用跨平台方案，但原有项目都是基于原生实现，如果想转Flutter，肯定得先考虑混编方案，因为需求也是持续迭代的，而且市场上也是由先例，可行性肯定是没问题的。\n\n所以我们考虑使用阿里的Flutter Boost来实现混编，因为已经经过大型App测试过的，我们项目完全是可以用起来的。\n\n## 2 Flutter Boost 初识\n\n从0开始实现混编，首先当然是了解 Flutter Boost如何使用。\n先看下官方文档：[https://github.com/alibaba/flutter_boost/blob/master/docs/install.md](https://github.com/alibaba/flutter_boost/blob/master/docs/install.md)。\n\n文档也很清楚，其它博客没必要重复看了。\n\n大概几个步骤吧：\n* 引用三方库\n* 新建一个代理类，继承FlutterBoostDelegate\n* AppDelegate初始化引擎\n\n## 3 项目结构和引入三方库\n\n这里我们将原生的代码和Flutter代码分两个仓库。\n比如在iOS项目的父文件夹下创建一个Flutter项目，这里面就放Flutter的代码。\n\n首先要明确一点，Flutter Boost是 Flutter代码里面用的三方库。\n这里配置项目结构是混编所需，不是因为依赖了Flutter Boost才这样引用。\n\n为什么原生能用Flutter Boost里面的一些类呢？\n\n这里并不是原生依赖了。\n\n原因是原生项目通过在podFile文件里面配置Flutter项目路径，建立起了链接关系。\n此时原生就可以正常访问Flutter项目里面依赖的三方库提供的一些类了。\n此时就可以在AppDelegate用Flutter Boost提供的类了。\n\n我们是这样配置的：\n```\n# flutter 集成\nflutter_application_path = '../../flutter-pin-module'\nload File.join(flutter_application_path, '.ios', 'Flutter', 'podhelper.rb')\n\nuse_frameworks!\n\ntarget 'GreeSalesSystem' do\n\n# flutter 集成\n  install_all_flutter_pods(flutter_application_path)\n```\n\n这里路径为父文件的父文件下的“flutter-pin-module”，我们将flutter部分单独放置在这个文件夹下，其实这个Flutter部分也是可以单独编译，单独用Android Studio或者VS Code跑起来。\n\n最后再走一次pod install。\n\n这样就成功引入Flutter Boost，可以愉快地在原生项目进行Flutter配置了。\n\n另外可能会有编译问题,没问题就不用加了。\n在podFile文件夹最下面需要加上这段代码：\n```\npost_install do |installer|\n    flutter_post_install(installer) if defined?(flutter_post_install)\n    installer.pods_project.build_configurations.each do |config|\n        config.build_settings[\"EXCLUDED_ARCHS[sdk=iphonesimulator*]\"] = \"arm64\"\n    end\nend\n```\n\n## 4 原生项目配置Flutter\n\n### 4.1 自定义FlutterBoostDelegate\n\n```Swift\n// Flutter Boost 架构Delegate\n// 参考： https://github.com/alibaba/flutter_boost/blob/master/docs/install.md\nclass GMFlutterBoostDelegate : NSObject, FlutterBoostDelegate {\n    \n    ///您用来push的导航栏\n    var navigationController: UINavigationController?\n    \n    ///用来存返回flutter侧返回结果的表\n    var resultTable: Dictionary<String,([AnyHashable:Any]?)->Void> = [:];\n    \n    /// Flutter 跳转 原生\n    func pushNativeRoute(_ pageName: String!, arguments: [AnyHashable : Any]!) {\n        GMFlutterNavigator.pushNative(pageName, arguments: arguments)\n        return\n    }\n    \n    /// 原生 跳转 Flutter\n    func pushFlutterRoute(_ options: FlutterBoostRouteOptions!) {\n        //对这个页面设置结果\n        resultTable[options.pageName] = options.onPageFinished;\n        \n        //用参数来控制是push还是pop\n        let isPresent = (options.arguments?[\"isPresent\"] as? Bool)  ?? false\n        var isAnimated = (options.arguments?[\"isAnimated\"] as? Bool) ?? true\n        \n        // 分销入库成功   distributeWarehousingSuccessPage\n        var vc: FBFlutterViewContainer\n        if options.pageName == DistributeWarehousingSuccessPage.pageName {\n            vc = DistributeWarehousingSuccessPage()\n        } else {\n            .......\n        }\n        \n        vc.hidesBottomBarWhenPushed = true\n        vc.setName(options.pageName, uniqueId: options.uniqueId, params: options.arguments,opaque: options.opaque)\n        \n        \n        //如果是present模式 ，或者要不透明模式，那么就需要以present模式打开页面\n        if(isPresent || !options.opaque){\n            self.navigationController?.present(vc, animated: isAnimated, completion: nil)\n        }else{\n            self.navigationController?.pushViewController(vc, animated: isAnimated)\n        }\n    }\n    \n    /// 原生 pop Flutter\n    func popRoute(_ options: FlutterBoostRouteOptions!) {\n        var animated = true\n        if options.pageName == DisPromotionChooseShopStoreViewController.pageName {\n            animated = false\n        }\n        //如果当前被present的vc是container，那么就执行dismiss逻辑\n        if let vc = self.navigationController?.presentedViewController as? FBFlutterViewContainer, vc.uniqueIDString() == options.uniqueId {\n            \n            //这里分为两种情况，由于UIModalPresentationOverFullScreen下，生命周期显示会有问题\n            //所以需要手动调用的场景，从而使下面底部的vc调用viewAppear相关逻辑\n            if vc.modalPresentationStyle == .overFullScreen {\n                \n                //这里手动beginAppearanceTransition触发页面生命周期\n                self.navigationController?.topViewController?.beginAppearanceTransition(true, animated: false)\n                \n                \n                vc.dismiss(animated: animated) {\n                    self.navigationController?.topViewController?.endAppearanceTransition()\n                }\n            }else{\n                //正常场景，直接dismiss\n                vc.dismiss(animated: animated, completion: nil)\n            }\n        }else{\n            self.navigationController?.popViewController(animated: animated)\n        }\n        //否则直接执行pop逻辑\n        //这里在pop的时候将参数带出,并且从结果表中移除\n        if let onPageFinshed = resultTable[options.pageName] {\n            onPageFinshed(options.arguments)\n            resultTable.removeValue(forKey: options.pageName)\n        }\n    }\n    \n}\n```\n\nFlutter 跳转 原生 主要用这个：pushNativeRoute 方法\n原生 跳转 Flutter 主要用这个： pushFlutterRoute 方法\n\n### 4.2 承载Flutter的容器\n\n其实说白了，Flutter页面本质上还是Controller。\n我们调整到任何一个Flutter，其实都是先跳自己的Controller。\n如下：\n```Swift\nclass DisPromotionChooseShopStoreViewController: FBFlutterViewContainer {\n    \n    static var pageName = \"disPromotionChooseShopStore\"\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n    }\n\n\n}\n```\n这里就是跳转到Flutter的某个页面。\n因为它继承了FBFlutterViewContainer，这个是阿里提供的。\n\n实际上就是一个Controller呀。\n\n### 4.3 应用启动初始化\n\n这个需要再AppDelegate中完成。\n可以搞个扩展方法：\n```Swift\nextension AppDelegate {\n    /// 设置flutter\n    func configFlutterBoost(_ application: UIApplication) {\n        //创建代理，做初始化操作\n        let delegate = GMFlutterBoostDelegate()\n        FlutterBoost.instance().setup(application, delegate: delegate) { engine in\n            \n        }\n    }\n}\n```\n这里面的delegate就是我们前面新建的一个Delegate。\n\n就这样混编没啥问题了。\n\n## 5 混编打包\n\n这里可能还有几个坑要注意下。\n\n在Flutter模块下执行：flutter build ios 报错\n \n 首先我要确保Flutter模块能够在iOS真机上跑起来\n\n### 5.1 真机运行报错\n\n参考了这篇文章：\n[https://honkersk.github.io/2020/07/02/Flutter-09-Flutter%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/](https://honkersk.github.io/2020/07/02/Flutter-09-Flutter%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/)\n\n我这边发现用Xcode单独跑，总是说有些类not found，所以我用Android Studio跑好像可以了。\n\n如果有些依赖有问题可以执行如下命令：\n```\nflutter pub upgrade\npod update\n```\n\n如果还不行可以将flutter项目clean下：\n```\nflutter clean\nflutter pub get\n```\n这样是全新的系统创建的.iOS文件夹，基本没啥问题。\n\n### 5.2 执行flutter build ios 报错\n\n这里报错了的话，先别google。\n\n可以先 flutter clean 再flutter pub get\n然后走 flutter build ios --release --no-codesign\n\n如果有一些shake 图标报错，可以运行这个指令看下：\n`flutter build ios --release --no-tree-shake-icons`\n\n啥都不用改，一次不行，多走几次，我这里试了3次，就成功了。\n<img src=fluttererror2.png>\n这里尝试了几次build，结果成功生成产物了。\n生成路径在flutter模块下的build下的ios文件夹中。\n\n\n### 5.3 build ios 产物分析\n<table><thead><tr><th>产物</th><th>介绍</th></tr></thead><tbody><tr><td>App.framework</td><td>Dart业务源码相关文件，在Debug模式下就是一个很小的空壳，在Release模式下包含全部业务逻辑。</td></tr><tr><td>flutter_assets</td><td>Flutter依赖的静态资源，如字体、图片等。<br><strong>在Flutter 1.9.1这种已经被合并进App.framework</strong>。</td></tr><tr><td>FlutterPluginRegistrant</td><td>Flutter插件注册制，自动注册Flutter插件。</td></tr><tr><td>Flutter.framework</td><td>Flutter库和引擎。</td></tr><tr><td>.symlinks</td><td>指向Flutter插件依赖库的实际地址。</td></tr></tbody></table>\n\n### 5.4 启动App闪退问题\n\n解决方案很简单：在原生主工程配置Release模式 进行archive编译构建\n<img src=fluttererror03.png>\n\n\n## 6 总结\n\n* 明确Flutter混编是系统支持，不是阿里提供的能力，Flutter Boost只是封装好的一个方便混编的工具，其实完全可以不用Flutter Boost，只是为了更好实现混编而已。\n\n* 三部曲，先引入依赖，通过Flutter模块引入，然后通过链接关系，原生可以访问到Flutter依赖，此时再配置Delegate，最后再初始化引擎。\n\n* 打包遇到问题不要急，先保证在真机上能运行起来。然后再走 flutter build ios命令，一次不行，走多次，有其它问题加后缀解决。","slug":"iOS-swift-混编Flutter","published":1,"updated":"2023-02-01T07:17:16.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlhfhyq000mivv78rzb3wfk","content":"<h2 id=\"1-集成Flutter原因\"><a href=\"#1-集成Flutter原因\" class=\"headerlink\" title=\"1 集成Flutter原因\"></a>1 集成Flutter原因</h2><p>最除是项目人员调动，导致产品和开发数量不匹配。领导打算使用跨平台方案，但原有项目都是基于原生实现，如果想转Flutter，肯定得先考虑混编方案，因为需求也是持续迭代的，而且市场上也是由先例，可行性肯定是没问题的。</p>\n<p>所以我们考虑使用阿里的Flutter Boost来实现混编，因为已经经过大型App测试过的，我们项目完全是可以用起来的。</p>\n<h2 id=\"2-Flutter-Boost-初识\"><a href=\"#2-Flutter-Boost-初识\" class=\"headerlink\" title=\"2 Flutter Boost 初识\"></a>2 Flutter Boost 初识</h2><p>从0开始实现混编，首先当然是了解 Flutter Boost如何使用。<br>先看下官方文档：<a href=\"https://github.com/alibaba/flutter_boost/blob/master/docs/install.md\">https://github.com/alibaba/flutter_boost&#x2F;blob&#x2F;master&#x2F;docs&#x2F;install.md</a>。</p>\n<p>文档也很清楚，其它博客没必要重复看了。</p>\n<p>大概几个步骤吧：</p>\n<ul>\n<li>引用三方库</li>\n<li>新建一个代理类，继承FlutterBoostDelegate</li>\n<li>AppDelegate初始化引擎</li>\n</ul>\n<h2 id=\"3-项目结构和引入三方库\"><a href=\"#3-项目结构和引入三方库\" class=\"headerlink\" title=\"3 项目结构和引入三方库\"></a>3 项目结构和引入三方库</h2><p>这里我们将原生的代码和Flutter代码分两个仓库。<br>比如在iOS项目的父文件夹下创建一个Flutter项目，这里面就放Flutter的代码。</p>\n<p>首先要明确一点，Flutter Boost是 Flutter代码里面用的三方库。<br>这里配置项目结构是混编所需，不是因为依赖了Flutter Boost才这样引用。</p>\n<p>为什么原生能用Flutter Boost里面的一些类呢？</p>\n<p>这里并不是原生依赖了。</p>\n<p>原因是原生项目通过在podFile文件里面配置Flutter项目路径，建立起了链接关系。<br>此时原生就可以正常访问Flutter项目里面依赖的三方库提供的一些类了。<br>此时就可以在AppDelegate用Flutter Boost提供的类了。</p>\n<p>我们是这样配置的：</p>\n<pre><code># flutter 集成\nflutter_application_path = &#39;../../flutter-pin-module&#39;\nload File.join(flutter_application_path, &#39;.ios&#39;, &#39;Flutter&#39;, &#39;podhelper.rb&#39;)\n\nuse_frameworks!\n\ntarget &#39;GreeSalesSystem&#39; do\n\n# flutter 集成\n  install_all_flutter_pods(flutter_application_path)\n</code></pre>\n<p>这里路径为父文件的父文件下的“flutter-pin-module”，我们将flutter部分单独放置在这个文件夹下，其实这个Flutter部分也是可以单独编译，单独用Android Studio或者VS Code跑起来。</p>\n<p>最后再走一次pod install。</p>\n<p>这样就成功引入Flutter Boost，可以愉快地在原生项目进行Flutter配置了。</p>\n<p>另外可能会有编译问题,没问题就不用加了。<br>在podFile文件夹最下面需要加上这段代码：</p>\n<pre><code>post_install do |installer|\n    flutter_post_install(installer) if defined?(flutter_post_install)\n    installer.pods_project.build_configurations.each do |config|\n        config.build_settings[&quot;EXCLUDED_ARCHS[sdk=iphonesimulator*]&quot;] = &quot;arm64&quot;\n    end\nend\n</code></pre>\n<h2 id=\"4-原生项目配置Flutter\"><a href=\"#4-原生项目配置Flutter\" class=\"headerlink\" title=\"4 原生项目配置Flutter\"></a>4 原生项目配置Flutter</h2><h3 id=\"4-1-自定义FlutterBoostDelegate\"><a href=\"#4-1-自定义FlutterBoostDelegate\" class=\"headerlink\" title=\"4.1 自定义FlutterBoostDelegate\"></a>4.1 自定义FlutterBoostDelegate</h3><pre><code class=\"line-numbers language-Swift\">// Flutter Boost 架构Delegate\n// 参考： https://github.com/alibaba/flutter_boost/blob/master/docs/install.md\nclass GMFlutterBoostDelegate : NSObject, FlutterBoostDelegate &#123;\n    \n    ///您用来push的导航栏\n    var navigationController: UINavigationController?\n    \n    ///用来存返回flutter侧返回结果的表\n    var resultTable: Dictionary&lt;String,([AnyHashable:Any]?)-&gt;Void&gt; = [:];\n    \n    /// Flutter 跳转 原生\n    func pushNativeRoute(_ pageName: String!, arguments: [AnyHashable : Any]!) &#123;\n        GMFlutterNavigator.pushNative(pageName, arguments: arguments)\n        return\n    &#125;\n    \n    /// 原生 跳转 Flutter\n    func pushFlutterRoute(_ options: FlutterBoostRouteOptions!) &#123;\n        //对这个页面设置结果\n        resultTable[options.pageName] = options.onPageFinished;\n        \n        //用参数来控制是push还是pop\n        let isPresent = (options.arguments?[&quot;isPresent&quot;] as? Bool)  ?? false\n        var isAnimated = (options.arguments?[&quot;isAnimated&quot;] as? Bool) ?? true\n        \n        // 分销入库成功   distributeWarehousingSuccessPage\n        var vc: FBFlutterViewContainer\n        if options.pageName == DistributeWarehousingSuccessPage.pageName &#123;\n            vc = DistributeWarehousingSuccessPage()\n        &#125; else &#123;\n            .......\n        &#125;\n        \n        vc.hidesBottomBarWhenPushed = true\n        vc.setName(options.pageName, uniqueId: options.uniqueId, params: options.arguments,opaque: options.opaque)\n        \n        \n        //如果是present模式 ，或者要不透明模式，那么就需要以present模式打开页面\n        if(isPresent || !options.opaque)&#123;\n            self.navigationController?.present(vc, animated: isAnimated, completion: nil)\n        &#125;else&#123;\n            self.navigationController?.pushViewController(vc, animated: isAnimated)\n        &#125;\n    &#125;\n    \n    /// 原生 pop Flutter\n    func popRoute(_ options: FlutterBoostRouteOptions!) &#123;\n        var animated = true\n        if options.pageName == DisPromotionChooseShopStoreViewController.pageName &#123;\n            animated = false\n        &#125;\n        //如果当前被present的vc是container，那么就执行dismiss逻辑\n        if let vc = self.navigationController?.presentedViewController as? FBFlutterViewContainer, vc.uniqueIDString() == options.uniqueId &#123;\n            \n            //这里分为两种情况，由于UIModalPresentationOverFullScreen下，生命周期显示会有问题\n            //所以需要手动调用的场景，从而使下面底部的vc调用viewAppear相关逻辑\n            if vc.modalPresentationStyle == .overFullScreen &#123;\n                \n                //这里手动beginAppearanceTransition触发页面生命周期\n                self.navigationController?.topViewController?.beginAppearanceTransition(true, animated: false)\n                \n                \n                vc.dismiss(animated: animated) &#123;\n                    self.navigationController?.topViewController?.endAppearanceTransition()\n                &#125;\n            &#125;else&#123;\n                //正常场景，直接dismiss\n                vc.dismiss(animated: animated, completion: nil)\n            &#125;\n        &#125;else&#123;\n            self.navigationController?.popViewController(animated: animated)\n        &#125;\n        //否则直接执行pop逻辑\n        //这里在pop的时候将参数带出,并且从结果表中移除\n        if let onPageFinshed = resultTable[options.pageName] &#123;\n            onPageFinshed(options.arguments)\n            resultTable.removeValue(forKey: options.pageName)\n        &#125;\n    &#125;\n    \n&#125;\n</code></pre>\n<p>Flutter 跳转 原生 主要用这个：pushNativeRoute 方法<br>原生 跳转 Flutter 主要用这个： pushFlutterRoute 方法</p>\n<h3 id=\"4-2-承载Flutter的容器\"><a href=\"#4-2-承载Flutter的容器\" class=\"headerlink\" title=\"4.2 承载Flutter的容器\"></a>4.2 承载Flutter的容器</h3><p>其实说白了，Flutter页面本质上还是Controller。<br>我们调整到任何一个Flutter，其实都是先跳自己的Controller。<br>如下：</p>\n<pre><code class=\"line-numbers language-Swift\">class DisPromotionChooseShopStoreViewController: FBFlutterViewContainer &#123;\n    \n    static var pageName = &quot;disPromotionChooseShopStore&quot;\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n    &#125;\n\n\n&#125;\n</code></pre>\n<p>这里就是跳转到Flutter的某个页面。<br>因为它继承了FBFlutterViewContainer，这个是阿里提供的。</p>\n<p>实际上就是一个Controller呀。</p>\n<h3 id=\"4-3-应用启动初始化\"><a href=\"#4-3-应用启动初始化\" class=\"headerlink\" title=\"4.3 应用启动初始化\"></a>4.3 应用启动初始化</h3><p>这个需要再AppDelegate中完成。<br>可以搞个扩展方法：</p>\n<pre><code class=\"line-numbers language-Swift\">extension AppDelegate &#123;\n    /// 设置flutter\n    func configFlutterBoost(_ application: UIApplication) &#123;\n        //创建代理，做初始化操作\n        let delegate = GMFlutterBoostDelegate()\n        FlutterBoost.instance().setup(application, delegate: delegate) &#123; engine in\n            \n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里面的delegate就是我们前面新建的一个Delegate。</p>\n<p>就这样混编没啥问题了。</p>\n<h2 id=\"5-混编打包\"><a href=\"#5-混编打包\" class=\"headerlink\" title=\"5 混编打包\"></a>5 混编打包</h2><p>这里可能还有几个坑要注意下。</p>\n<p>在Flutter模块下执行：flutter build ios 报错</p>\n<p> 首先我要确保Flutter模块能够在iOS真机上跑起来</p>\n<h3 id=\"5-1-真机运行报错\"><a href=\"#5-1-真机运行报错\" class=\"headerlink\" title=\"5.1 真机运行报错\"></a>5.1 真机运行报错</h3><p>参考了这篇文章：<br><a href=\"https://honkersk.github.io/2020/07/02/Flutter-09-Flutter%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/\">https://honkersk.github.io/2020/07/02/Flutter-09-Flutter%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</a></p>\n<p>我这边发现用Xcode单独跑，总是说有些类not found，所以我用Android Studio跑好像可以了。</p>\n<p>如果有些依赖有问题可以执行如下命令：</p>\n<pre><code>flutter pub upgrade\npod update\n</code></pre>\n<p>如果还不行可以将flutter项目clean下：</p>\n<pre><code>flutter clean\nflutter pub get\n</code></pre>\n<p>这样是全新的系统创建的.iOS文件夹，基本没啥问题。</p>\n<h3 id=\"5-2-执行flutter-build-ios-报错\"><a href=\"#5-2-执行flutter-build-ios-报错\" class=\"headerlink\" title=\"5.2 执行flutter build ios 报错\"></a>5.2 执行flutter build ios 报错</h3><p>这里报错了的话，先别google。</p>\n<p>可以先 flutter clean 再flutter pub get<br>然后走 flutter build ios –release –no-codesign</p>\n<p>如果有一些shake 图标报错，可以运行这个指令看下：<br><code>flutter build ios --release --no-tree-shake-icons</code></p>\n<p>啥都不用改，一次不行，多走几次，我这里试了3次，就成功了。<br><img src=fluttererror2.png><br>这里尝试了几次build，结果成功生成产物了。<br>生成路径在flutter模块下的build下的ios文件夹中。</p>\n<h3 id=\"5-3-build-ios-产物分析\"><a href=\"#5-3-build-ios-产物分析\" class=\"headerlink\" title=\"5.3 build ios 产物分析\"></a>5.3 build ios 产物分析</h3><table><thead><tr><th>产物</th><th>介绍</th></tr></thead><tbody><tr><td>App.framework</td><td>Dart业务源码相关文件，在Debug模式下就是一个很小的空壳，在Release模式下包含全部业务逻辑。</td></tr><tr><td>flutter_assets</td><td>Flutter依赖的静态资源，如字体、图片等。<br><strong>在Flutter 1.9.1这种已经被合并进App.framework</strong>。</td></tr><tr><td>FlutterPluginRegistrant</td><td>Flutter插件注册制，自动注册Flutter插件。</td></tr><tr><td>Flutter.framework</td><td>Flutter库和引擎。</td></tr><tr><td>.symlinks</td><td>指向Flutter插件依赖库的实际地址。</td></tr></tbody></table>\n\n<h3 id=\"5-4-启动App闪退问题\"><a href=\"#5-4-启动App闪退问题\" class=\"headerlink\" title=\"5.4 启动App闪退问题\"></a>5.4 启动App闪退问题</h3><p>解决方案很简单：在原生主工程配置Release模式 进行archive编译构建<br><img src=fluttererror03.png></p>\n<h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6 总结\"></a>6 总结</h2><ul>\n<li><p>明确Flutter混编是系统支持，不是阿里提供的能力，Flutter Boost只是封装好的一个方便混编的工具，其实完全可以不用Flutter Boost，只是为了更好实现混编而已。</p>\n</li>\n<li><p>三部曲，先引入依赖，通过Flutter模块引入，然后通过链接关系，原生可以访问到Flutter依赖，此时再配置Delegate，最后再初始化引擎。</p>\n</li>\n<li><p>打包遇到问题不要急，先保证在真机上能运行起来。然后再走 flutter build ios命令，一次不行，走多次，有其它问题加后缀解决。</p>\n</li>\n</ul>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-集成Flutter原因\"><a href=\"#1-集成Flutter原因\" class=\"headerlink\" title=\"1 集成Flutter原因\"></a>1 集成Flutter原因</h2><p>最除是项目人员调动，导致产品和开发数量不匹配。领导打算使用跨平台方案，但原有项目都是基于原生实现，如果想转Flutter，肯定得先考虑混编方案，因为需求也是持续迭代的，而且市场上也是由先例，可行性肯定是没问题的。</p>\n<p>所以我们考虑使用阿里的Flutter Boost来实现混编，因为已经经过大型App测试过的，我们项目完全是可以用起来的。</p>\n<h2 id=\"2-Flutter-Boost-初识\"><a href=\"#2-Flutter-Boost-初识\" class=\"headerlink\" title=\"2 Flutter Boost 初识\"></a>2 Flutter Boost 初识</h2><p>从0开始实现混编，首先当然是了解 Flutter Boost如何使用。<br>先看下官方文档：<a href=\"https://github.com/alibaba/flutter_boost/blob/master/docs/install.md\">https://github.com/alibaba/flutter_boost&#x2F;blob&#x2F;master&#x2F;docs&#x2F;install.md</a>。</p>\n<p>文档也很清楚，其它博客没必要重复看了。</p>\n<p>大概几个步骤吧：</p>\n<ul>\n<li>引用三方库</li>\n<li>新建一个代理类，继承FlutterBoostDelegate</li>\n<li>AppDelegate初始化引擎</li>\n</ul>\n<h2 id=\"3-项目结构和引入三方库\"><a href=\"#3-项目结构和引入三方库\" class=\"headerlink\" title=\"3 项目结构和引入三方库\"></a>3 项目结构和引入三方库</h2><p>这里我们将原生的代码和Flutter代码分两个仓库。<br>比如在iOS项目的父文件夹下创建一个Flutter项目，这里面就放Flutter的代码。</p>\n<p>首先要明确一点，Flutter Boost是 Flutter代码里面用的三方库。<br>这里配置项目结构是混编所需，不是因为依赖了Flutter Boost才这样引用。</p>\n<p>为什么原生能用Flutter Boost里面的一些类呢？</p>\n<p>这里并不是原生依赖了。</p>\n<p>原因是原生项目通过在podFile文件里面配置Flutter项目路径，建立起了链接关系。<br>此时原生就可以正常访问Flutter项目里面依赖的三方库提供的一些类了。<br>此时就可以在AppDelegate用Flutter Boost提供的类了。</p>\n<p>我们是这样配置的：</p>\n<pre><code># flutter 集成\nflutter_application_path = &#39;../../flutter-pin-module&#39;\nload File.join(flutter_application_path, &#39;.ios&#39;, &#39;Flutter&#39;, &#39;podhelper.rb&#39;)\n\nuse_frameworks!\n\ntarget &#39;GreeSalesSystem&#39; do\n\n# flutter 集成\n  install_all_flutter_pods(flutter_application_path)\n</code></pre>\n<p>这里路径为父文件的父文件下的“flutter-pin-module”，我们将flutter部分单独放置在这个文件夹下，其实这个Flutter部分也是可以单独编译，单独用Android Studio或者VS Code跑起来。</p>\n<p>最后再走一次pod install。</p>\n<p>这样就成功引入Flutter Boost，可以愉快地在原生项目进行Flutter配置了。</p>\n<p>另外可能会有编译问题,没问题就不用加了。<br>在podFile文件夹最下面需要加上这段代码：</p>\n<pre><code>post_install do |installer|\n    flutter_post_install(installer) if defined?(flutter_post_install)\n    installer.pods_project.build_configurations.each do |config|\n        config.build_settings[&quot;EXCLUDED_ARCHS[sdk=iphonesimulator*]&quot;] = &quot;arm64&quot;\n    end\nend\n</code></pre>\n<h2 id=\"4-原生项目配置Flutter\"><a href=\"#4-原生项目配置Flutter\" class=\"headerlink\" title=\"4 原生项目配置Flutter\"></a>4 原生项目配置Flutter</h2><h3 id=\"4-1-自定义FlutterBoostDelegate\"><a href=\"#4-1-自定义FlutterBoostDelegate\" class=\"headerlink\" title=\"4.1 自定义FlutterBoostDelegate\"></a>4.1 自定义FlutterBoostDelegate</h3><pre><code class=\"line-numbers language-Swift\">// Flutter Boost 架构Delegate\n// 参考： https://github.com/alibaba/flutter_boost/blob/master/docs/install.md\nclass GMFlutterBoostDelegate : NSObject, FlutterBoostDelegate &#123;\n    \n    ///您用来push的导航栏\n    var navigationController: UINavigationController?\n    \n    ///用来存返回flutter侧返回结果的表\n    var resultTable: Dictionary&lt;String,([AnyHashable:Any]?)-&gt;Void&gt; = [:];\n    \n    /// Flutter 跳转 原生\n    func pushNativeRoute(_ pageName: String!, arguments: [AnyHashable : Any]!) &#123;\n        GMFlutterNavigator.pushNative(pageName, arguments: arguments)\n        return\n    &#125;\n    \n    /// 原生 跳转 Flutter\n    func pushFlutterRoute(_ options: FlutterBoostRouteOptions!) &#123;\n        //对这个页面设置结果\n        resultTable[options.pageName] = options.onPageFinished;\n        \n        //用参数来控制是push还是pop\n        let isPresent = (options.arguments?[&quot;isPresent&quot;] as? Bool)  ?? false\n        var isAnimated = (options.arguments?[&quot;isAnimated&quot;] as? Bool) ?? true\n        \n        // 分销入库成功   distributeWarehousingSuccessPage\n        var vc: FBFlutterViewContainer\n        if options.pageName == DistributeWarehousingSuccessPage.pageName &#123;\n            vc = DistributeWarehousingSuccessPage()\n        &#125; else &#123;\n            .......\n        &#125;\n        \n        vc.hidesBottomBarWhenPushed = true\n        vc.setName(options.pageName, uniqueId: options.uniqueId, params: options.arguments,opaque: options.opaque)\n        \n        \n        //如果是present模式 ，或者要不透明模式，那么就需要以present模式打开页面\n        if(isPresent || !options.opaque)&#123;\n            self.navigationController?.present(vc, animated: isAnimated, completion: nil)\n        &#125;else&#123;\n            self.navigationController?.pushViewController(vc, animated: isAnimated)\n        &#125;\n    &#125;\n    \n    /// 原生 pop Flutter\n    func popRoute(_ options: FlutterBoostRouteOptions!) &#123;\n        var animated = true\n        if options.pageName == DisPromotionChooseShopStoreViewController.pageName &#123;\n            animated = false\n        &#125;\n        //如果当前被present的vc是container，那么就执行dismiss逻辑\n        if let vc = self.navigationController?.presentedViewController as? FBFlutterViewContainer, vc.uniqueIDString() == options.uniqueId &#123;\n            \n            //这里分为两种情况，由于UIModalPresentationOverFullScreen下，生命周期显示会有问题\n            //所以需要手动调用的场景，从而使下面底部的vc调用viewAppear相关逻辑\n            if vc.modalPresentationStyle == .overFullScreen &#123;\n                \n                //这里手动beginAppearanceTransition触发页面生命周期\n                self.navigationController?.topViewController?.beginAppearanceTransition(true, animated: false)\n                \n                \n                vc.dismiss(animated: animated) &#123;\n                    self.navigationController?.topViewController?.endAppearanceTransition()\n                &#125;\n            &#125;else&#123;\n                //正常场景，直接dismiss\n                vc.dismiss(animated: animated, completion: nil)\n            &#125;\n        &#125;else&#123;\n            self.navigationController?.popViewController(animated: animated)\n        &#125;\n        //否则直接执行pop逻辑\n        //这里在pop的时候将参数带出,并且从结果表中移除\n        if let onPageFinshed = resultTable[options.pageName] &#123;\n            onPageFinshed(options.arguments)\n            resultTable.removeValue(forKey: options.pageName)\n        &#125;\n    &#125;\n    \n&#125;\n</code></pre>\n<p>Flutter 跳转 原生 主要用这个：pushNativeRoute 方法<br>原生 跳转 Flutter 主要用这个： pushFlutterRoute 方法</p>\n<h3 id=\"4-2-承载Flutter的容器\"><a href=\"#4-2-承载Flutter的容器\" class=\"headerlink\" title=\"4.2 承载Flutter的容器\"></a>4.2 承载Flutter的容器</h3><p>其实说白了，Flutter页面本质上还是Controller。<br>我们调整到任何一个Flutter，其实都是先跳自己的Controller。<br>如下：</p>\n<pre><code class=\"line-numbers language-Swift\">class DisPromotionChooseShopStoreViewController: FBFlutterViewContainer &#123;\n    \n    static var pageName = &quot;disPromotionChooseShopStore&quot;\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n    &#125;\n\n\n&#125;\n</code></pre>\n<p>这里就是跳转到Flutter的某个页面。<br>因为它继承了FBFlutterViewContainer，这个是阿里提供的。</p>\n<p>实际上就是一个Controller呀。</p>\n<h3 id=\"4-3-应用启动初始化\"><a href=\"#4-3-应用启动初始化\" class=\"headerlink\" title=\"4.3 应用启动初始化\"></a>4.3 应用启动初始化</h3><p>这个需要再AppDelegate中完成。<br>可以搞个扩展方法：</p>\n<pre><code class=\"line-numbers language-Swift\">extension AppDelegate &#123;\n    /// 设置flutter\n    func configFlutterBoost(_ application: UIApplication) &#123;\n        //创建代理，做初始化操作\n        let delegate = GMFlutterBoostDelegate()\n        FlutterBoost.instance().setup(application, delegate: delegate) &#123; engine in\n            \n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里面的delegate就是我们前面新建的一个Delegate。</p>\n<p>就这样混编没啥问题了。</p>\n<h2 id=\"5-混编打包\"><a href=\"#5-混编打包\" class=\"headerlink\" title=\"5 混编打包\"></a>5 混编打包</h2><p>这里可能还有几个坑要注意下。</p>\n<p>在Flutter模块下执行：flutter build ios 报错</p>\n<p> 首先我要确保Flutter模块能够在iOS真机上跑起来</p>\n<h3 id=\"5-1-真机运行报错\"><a href=\"#5-1-真机运行报错\" class=\"headerlink\" title=\"5.1 真机运行报错\"></a>5.1 真机运行报错</h3><p>参考了这篇文章：<br><a href=\"https://honkersk.github.io/2020/07/02/Flutter-09-Flutter%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/\">https://honkersk.github.io/2020/07/02/Flutter-09-Flutter%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</a></p>\n<p>我这边发现用Xcode单独跑，总是说有些类not found，所以我用Android Studio跑好像可以了。</p>\n<p>如果有些依赖有问题可以执行如下命令：</p>\n<pre><code>flutter pub upgrade\npod update\n</code></pre>\n<p>如果还不行可以将flutter项目clean下：</p>\n<pre><code>flutter clean\nflutter pub get\n</code></pre>\n<p>这样是全新的系统创建的.iOS文件夹，基本没啥问题。</p>\n<h3 id=\"5-2-执行flutter-build-ios-报错\"><a href=\"#5-2-执行flutter-build-ios-报错\" class=\"headerlink\" title=\"5.2 执行flutter build ios 报错\"></a>5.2 执行flutter build ios 报错</h3><p>这里报错了的话，先别google。</p>\n<p>可以先 flutter clean 再flutter pub get<br>然后走 flutter build ios –release –no-codesign</p>\n<p>如果有一些shake 图标报错，可以运行这个指令看下：<br><code>flutter build ios --release --no-tree-shake-icons</code></p>\n<p>啥都不用改，一次不行，多走几次，我这里试了3次，就成功了。<br><img src=fluttererror2.png><br>这里尝试了几次build，结果成功生成产物了。<br>生成路径在flutter模块下的build下的ios文件夹中。</p>\n<h3 id=\"5-3-build-ios-产物分析\"><a href=\"#5-3-build-ios-产物分析\" class=\"headerlink\" title=\"5.3 build ios 产物分析\"></a>5.3 build ios 产物分析</h3><table><thead><tr><th>产物</th><th>介绍</th></tr></thead><tbody><tr><td>App.framework</td><td>Dart业务源码相关文件，在Debug模式下就是一个很小的空壳，在Release模式下包含全部业务逻辑。</td></tr><tr><td>flutter_assets</td><td>Flutter依赖的静态资源，如字体、图片等。<br><strong>在Flutter 1.9.1这种已经被合并进App.framework</strong>。</td></tr><tr><td>FlutterPluginRegistrant</td><td>Flutter插件注册制，自动注册Flutter插件。</td></tr><tr><td>Flutter.framework</td><td>Flutter库和引擎。</td></tr><tr><td>.symlinks</td><td>指向Flutter插件依赖库的实际地址。</td></tr></tbody></table>\n\n<h3 id=\"5-4-启动App闪退问题\"><a href=\"#5-4-启动App闪退问题\" class=\"headerlink\" title=\"5.4 启动App闪退问题\"></a>5.4 启动App闪退问题</h3><p>解决方案很简单：在原生主工程配置Release模式 进行archive编译构建<br><img src=fluttererror03.png></p>\n<h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6 总结\"></a>6 总结</h2><ul>\n<li><p>明确Flutter混编是系统支持，不是阿里提供的能力，Flutter Boost只是封装好的一个方便混编的工具，其实完全可以不用Flutter Boost，只是为了更好实现混编而已。</p>\n</li>\n<li><p>三部曲，先引入依赖，通过Flutter模块引入，然后通过链接关系，原生可以访问到Flutter依赖，此时再配置Delegate，最后再初始化引擎。</p>\n</li>\n<li><p>打包遇到问题不要急，先保证在真机上能运行起来。然后再走 flutter build ios命令，一次不行，走多次，有其它问题加后缀解决。</p>\n</li>\n</ul>\n"},{"title":"iOS swift 实现简易地图功能","date":"2023-01-31T07:27:26.000Z","top":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 需求定义\n\n产品需要我们实现这样一个需求，就是根据一个地址（可能有经纬度也可能没有）,然后跳转到地图页面去，地图中间会显示这个地址。运行用户自行点击定位，这样中间会显示当前位置。允许左右滑动，地图中心也会随之变更。支持搜索功能，根据用户搜索关键词，获取一个搜索列表。然后就是一个提交功能，这样需要将经纬度提交到服务端。\n\n大致是这样的需求。\n实现效果是这样的：\n<img src=map.png>\n\n## 2 需求分析\n\n根据产品的需求，我们考虑接入高德地图。所以我们需要事先调研下如何接入高德才行。\n\n其实这个应该非常简单，高德提供了Map，我们只需要将中间的坐标设置为我们自己的坐标。如果没有坐标，我们也调研高德的搜索接口，将搜索结果默认第一条，这应该是最准的吧，然后设置给高德的中间坐标即可。\n\n支持用户滑动，高德就应该支持的，这里应该会提供一个代理，我们在这个代理的回调类里面重新去调用下搜索接口，就能出现附近10条地址。\n\n二指放大，高德应该也是支持的，不需要我们额外设置啥。\n\n另外就是定位可能复杂一点，需要实现获取下定位权限，如果没有权限，需要跳转到系统设置。定位就不需要高德支持了，我们直接调用系统接口，获取经纬度，然后设置给高德就行了。\n\n## 3 准备工作：了解高德\n\n首先附上高德官方文档：[https://lbs.amap.com/api/ios-sdk/summary](https://lbs.amap.com/api/ios-sdk/summary)\n\n申请key这些工作就不用交给我们了，让产品自己申请吧。\n\n接入高德地图，做很复杂的需求，可以参考这篇文档，写得还不错：\n[https://www.jianshu.com/p/770728626874](https://www.jianshu.com/p/770728626874) 但是这个是objective-C，不过基本原理是类似的，还是有参考价值的。\n\n另外附上高德地图可配置参数：\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>logoCenter</td>\n<td>CGPoint</td>\n<td>可设置Logo的位置。必须在mapView.bounds之内，否则会被忽略。</td>\n</tr>\n<tr>\n<td>showsCompass</td>\n<td>Bool</td>\n<td>是否显示指南针。</td>\n</tr>\n<tr>\n<td>compassOrigin</td>\n<td>CGPoint</td>\n<td>设置指南针的位置。</td>\n</tr>\n<tr>\n<td>showsScale</td>\n<td>Bool</td>\n<td>是否显示比例值。</td>\n</tr>\n<tr>\n<td>scaleOrigin</td>\n<td>CGPoint</td>\n<td>设置比例尺的位置。</td>\n</tr>\n<tr>\n<td>zoomEnabled</td>\n<td>Bool</td>\n<td>是否开启缩放手势，默认true。</td>\n</tr>\n<tr>\n<td>scrollEnabled</td>\n<td>Bool</td>\n<td>是否开启滑动手势，默认true。</td>\n</tr>\n<tr>\n<td>rotateEnabled</td>\n<td>Bool</td>\n<td>是否开启旋转手势，默认true。</td>\n</tr>\n<tr>\n<td>rotateCameraEnabled</td>\n<td>Bool</td>\n<td>是否开启倾斜旋转手势，默认true。用户可以在地图上放置两个手指，移动它们一起向下或向上去增加或减小倾斜角。</td>\n</tr>\n<tr>\n<td>setZoomLevel</td>\n<td>CGFloat</td>\n<td>改变地图缩放级别。范围从3级到19级，共17级。级别越高，展示的内容越细，例如街道等等。</td>\n</tr>\n<tr>\n<td>setCenter</td>\n<td>CLLocationCoordinate2D</td>\n<td>改变地图中心的位置。传递具体的经纬度。</td>\n</tr>\n</tbody>\n</table>\n\n另外一个就是需要我们在AppDelegate中注册key：\n```Swift\n /// 设置高德地图\nfunc configAMap() {\n    AMapServices.shared().apiKey = \"你申请的key\"\n    AMapServices.shared().enableHTTPS = true\n}\n```\n\n这里，准备工作基本就完成了。\n\n## 4 代码实现\n\n### 4.1 新建两个实体类\n\n```Swift\nclass GMLocationPickerLocationResult: NSObject {\n    \n    //MARK: - property\n    \n    var coordinate: CLLocationCoordinate2D?     // 经纬度\n    \n    var poiName: String = \"\"                    // 名称\n    \n    var province: String = \"\"                   // 省\n    var provinceCode: String = \"\"               // 省编码\n    var city: String = \"\"                       // 市\n    var citycode: String = \"\"                   // 市编码\n    var district: String = \"\"                   // 区\n    var adcode: String = \"\"                     // 区编码\n    var township: String = \"\"                   // 乡镇街道\n    var towncode: String = \"\"                   // 乡镇街道编码(截取前9位)\n    \n    var detailAddress: String = \"\"              // 详细地址\n    var formattedAddress: String = \"\"           // 格式化全地址(4级+详细)\n    \n    var locationInfo: GMLocationPickerLocationInfo? //\n    \n    /// 模型转换\n    convenience init(location: AMapGeoPoint, reGeocode: AMapReGeocode, locationInfo: GMLocationPickerLocationInfo?) {\n        self.init()\n        \n        let latitude = location.latitude\n        let longitude = location.longitude\n        self.coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n        \n        if let locationInfo = locationInfo {\n            // 1.转换基础信息\n            self.poiName = locationInfo.poiName\n            self.province = locationInfo.province\n            self.city = locationInfo.city\n            self.district = locationInfo.district\n            self.township = locationInfo.street\n            self.detailAddress = locationInfo.address\n            self.formattedAddress = locationInfo.province + locationInfo.city + locationInfo.district + locationInfo.address\n        }\n        if let addressComponent = reGeocode.addressComponent {\n            // 2.转换所有信息\n            var poiName = \"\"\n            if let locationInfo = locationInfo {\n                poiName = locationInfo.poiName\n            } else if let aoisName = reGeocode.aois.first?.name {\n                poiName = aoisName\n            } else if let roadinterName = reGeocode.roadinters.first?.firstName {\n                poiName = roadinterName\n            } else {\n                poiName = addressComponent.township ?? \"\"\n            }\n            self.poiName = self.poiName.ty_forEmpty(poiName)\n            \n            self.province = self.province.ty_forEmpty(addressComponent.province ?? \"\")\n            self.city = self.city.ty_forEmpty(addressComponent.city ?? \"\")\n            self.district = self.district.ty_forEmpty(addressComponent.district ?? \"\")\n            self.township = self.township.ty_forEmpty(addressComponent.township ?? \"\")\n            self.formattedAddress = self.formattedAddress.ty_forEmpty(reGeocode.formattedAddress ?? \"\")\n        }\n        if let addressComponent = reGeocode.addressComponent {\n            // 设置编码\n            self.citycode = addressComponent.citycode ?? \"\"\n            self.adcode = addressComponent.adcode ?? \"\"\n            self.towncode = String(addressComponent.towncode.prefix(9)) // 截取前九位\n        }\n        // 设置省份编码 用自带plist\n        if let globalAddressModel = globalAddressModel {\n            for currProvince in globalAddressModel.data {\n                if currProvince.name == self.province {\n                    self.provinceCode = currProvince.code\n                    break\n                }\n            }\n        }\n        self.locationInfo = locationInfo\n    }\n}\n```\n\n这个用了一个convenience关键字来声明init，主要是覆写的作用，重载。可以参考这篇文章：[https://www.jianshu.com/p/09c6c88ed61e](https://www.jianshu.com/p/09c6c88ed61e)。这里面初始化已经用了高德的实体类AMapGeoPoint,这个包含了经纬度；AMapReGeocode，这个是逆地址编码；然后还有一个自定义实体，这个是Info，上面那个是result，info如下定义：\n\n```Swift\n\nclass GMLocationPickerLocationInfo: NSObject {\n    \n    //MARK: - property\n    \n    var coordinate: CLLocationCoordinate2D?     // 经纬度\n    \n    var poiName: String = \"\"                    // 名称\n    var province: String = \"\"                   // 省\n    var city: String = \"\"                       // 市\n    var district: String = \"\"                   // 区\n    var street: String = \"\"                     // 街道(*)\n    var number: String = \"\"                     // 门牌号(*)\n    \n    var address: String = \"\"                    // 地址(街道 + 门牌)\n    \n    var distance: Int = 0                       // 与选中点距离\n    \n    // UI\n    \n    var ui_isSelected = false                   // cell是否选中中\n    \n    //MARK: - life cycle\n    \n    // ------------------------- map 内转换 -------------------------\n    \n    /// 模型转换 根据 [实时定位]获取的 经纬度 & 逆地理信息\n    convenience init(coordinate: CLLocationCoordinate2D?, reGeocode: AMapLocationReGeocode?) {\n        self.init()\n        \n        self.coordinate = coordinate\n        \n        self.poiName = reGeocode?.poiName ?? \"\"\n        self.province = reGeocode?.province ?? \"\"\n        self.city = reGeocode?.city ?? \"\"\n        self.district = reGeocode?.district ?? \"\"\n        self.street = reGeocode?.street ?? \"\"\n        self.number = reGeocode?.number ?? \"\"\n        self.address = (self.street + self.number)\n        if self.street.isEmpty || self.number.isEmpty {\n            let detailAddress = reGeocode?.formattedAddress ?? \"\"\n            self.address = abbreviationAddressIn(detailAddress: detailAddress, province: province, city: city, district: district)\n        }\n        \n        self.distance = 0\n    }\n    \n    /// 模型转换 根据 [搜索{附近|关键词}]获取的 POI模型\n    convenience init(mapPOI: AMapPOI) {\n        self.init()\n        \n        if let location = mapPOI.location {\n            let latitude = location.latitude\n            let longitude = location.longitude\n            self.coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n        }\n        \n        self.poiName = mapPOI.name\n        self.province = mapPOI.province\n        self.city = mapPOI.city\n        self.district = mapPOI.district\n        self.street = \"\"\n        self.number = \"\"\n        self.address = mapPOI.address\n        \n        self.distance = mapPOI.distance // 周边搜索可用\n    }\n    \n    /// 模型转换 根据 [逆地理编码]获取的 经纬度 & 逆地理编码结果\n    convenience init(location: AMapGeoPoint, reGeocode: AMapReGeocode) {\n        self.init()\n        \n        let addressComponent = reGeocode.addressComponent\n        \n        let latitude = location.latitude\n        let longitude = location.longitude\n        self.coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n        \n        if let aoisName = reGeocode.aois.first?.name {\n            self.poiName = aoisName\n        } else if let roadinterName = reGeocode.roadinters.first?.firstName {\n            self.poiName = roadinterName\n        } else {\n            self.poiName = addressComponent?.township ?? \"\"\n        }\n        self.province = addressComponent?.province ?? \"\"\n        self.city = addressComponent?.city ?? \"\"\n        self.district = addressComponent?.district ?? \"\"\n        self.street = addressComponent?.streetNumber?.street ?? \"\"\n        self.number = addressComponent?.streetNumber?.number ?? \"\"\n        self.address = (self.street + self.number)\n        if self.street.isEmpty || self.number.isEmpty {\n            let detailAddress = reGeocode.formattedAddress ?? \"\"\n            self.address = abbreviationAddressIn(detailAddress: detailAddress, province: province, city: city, district: district)\n        }\n        self.distance = 0\n    }\n    \n    /// 详细地址中获取缩略地址\n    /// - Parameters:\n    ///   - detailAddress: 详细地址\n    ///   - province: 省份\n    ///   - city: 城市\n    ///   - district: 区域\n    private func abbreviationAddressIn(detailAddress: String, province: String, city: String, district: String) -> String {\n        var address = detailAddress\n        address = address.replacingOccurrences(of: province, with: \"\")\n        address = address.replacingOccurrences(of: city, with: \"\")\n        address = address.replacingOccurrences(of: city, with: \"\")\n        return address\n    }\n    \n    // ------------------------- model 转换 -------------------------\n    \n    /// 模型转换 根据 地理信息结果模型\n    convenience init(locationResult: GMLocationPickerLocationResult) {\n        self.init()\n        \n        self.coordinate = locationResult.coordinate\n        \n        self.poiName = locationResult.poiName\n        self.province = locationResult.province\n        self.city = locationResult.city\n        self.district = locationResult.district\n        let street = locationResult.township\n        self.address = street\n        \n        self.distance = 0\n    }\n    \n    /// 模型转换 根据 仓库模型\n    convenience init(warehouseInfo: GMWarehouseInfoHomeList) {\n        self.init()\n        \n        self.coordinate = warehouseInfo.cus_coordinate\n        \n        self.poiName = warehouseInfo.name\n        self.province = warehouseInfo.province\n        self.city = warehouseInfo.city\n        self.district = warehouseInfo.region\n        self.street = \"\"\n        self.number = \"\"\n        self.address = warehouseInfo.address\n        \n        self.distance = 0\n    }\n    \n    /// 模型转换 根据 门店模型\n    convenience init(storeInfo: GMStoreInfoHomeModel) {\n        self.init()\n        \n        self.coordinate = storeInfo.cus_coordinate\n        \n        self.poiName = storeInfo.shopName\n        self.province = storeInfo.shopProvince\n        self.city = storeInfo.shopCity\n        self.district = storeInfo.shopCounty\n        self.street = storeInfo.shopStreet\n        self.number = \"\"\n        self.address = storeInfo.shopAddress\n        \n        self.distance = 0\n    }\n}\n```\n这个是地图内部使用，上面那个实体，是为了更好对接服务端设定的一个实体。\n\n### 4.2 外部类定义\n\n```Swift\n/// 地图选择 闭包，向外吐出去\ntypealias GMLocationResultHandler = (GMLocationPickerLocationResult?) -> Swift.Void\n\nprotocol GMLocationPickerControllerDelegate: AnyObject {\n    /// 提交所选位置\n    func locationPickerController(_ collection: GMLocationPickerController, didSubmit locationInfo: GMLocationPickerLocationResult)\n    \n    /// 页面将要pop出\n    func locationPickerControllerWillPop(_ collection: GMLocationPickerController)\n}\n\n/// 从哪里进来的 枚举类\nenum GMLocationPickerFor {\n    case warehouseCreate                                        // 仓库创建\n    case warehouseEdit(warehouseInfo: GMWarehouseInfoHomeList)  // 仓库编辑\n    case storeEdit(storeInfo: GMStoreInfoHomeModel)             // 门店编辑\n}\n\n/// 选择地理位置的原因 什么时候走高德接口\nenum GMLocationPickerRegionChageFor {\n    case located                                                // 实时定位\n    case itemSelected                                           // 搜索项选择\n    case keywordSearchSelected                                  // 关键词搜索 自动选择(第一个)\n    case slideByCustomer                                        // 用户滑动逆地理\n}\n```\n这里定义了可能需要的枚举类和协议。\n枚举类主要跟我们自己业务有关系了，协议也是跟业务有关系。这里并不是实现地图的必须。\n\n### 4.3 UI声明\n\n```Swift\nclass GMLocationPickerController: GMBaseViewController {\n\n    //MARK: - property\n    \n    // UI\n    \n    private weak var btn_submit: UIButton!                      // 提交按钮\n    private weak var mapView: MAMapView!                        // 地图\n    private weak var textF_search: UITextField!                 // 搜索 输入栏\n    private weak var tableView: TYTableView!                    // 搜索 列表\n    private weak var ai_spinner: UIActivityIndicatorView!       // 加载loading\n    private weak var btn_located: UIButton!                     // 定位按钮\n    \n    private weak var imgV_pointAnnotation: UIImageView!         // 自定义大头针\n```\n\n这里声明了实现地图用到的一些材料，当然最关键的是MAMapView了，这个View是高德提供的哦。\n\n### 4.4 数据声明\n\n```Swift\n// Data\nvar navTitle: String?                                       // Nav标题 (可选)\nweak var delegate: GMLocationPickerControllerDelegate?      // 代理\nvar locationResultBlock: GMLocationResultHandler?\n\nprivate var locationInfos = [GMLocationPickerLocationInfo]()// 搜索 地点信息\nprivate var selectingLocationInfo: GMLocationPickerLocationInfo? // 选中地点信息\n\n// Pre Data\n\nvar preLocationInfo: GMLocationPickerLocationInfo?          // 预地理位置信息\nvar preCoordinate: CLLocationCoordinate2D?                  // 预经纬度\nvar preKeyword: String?                                     // 预搜索关键词\nvar pickerFor: GMLocationPickerFor = .warehouseCreate       // 地图选择用于\n```\n这里大致列举了需要用的数据。\n预数据，就是外部传过来的数据，然后我们新建了两个info实体报错搜索的地址和选中的地址。\n\n### 4.5 其它成员声明\n\n```Swift\n// Tool\nprivate var search: AMapSearchAPI!                          // 地图 搜索功能\nprivate var locationManager: AMapLocationManager!           // 地图 定位功能\nprivate var authorizationManager = TYLocationAuthorization()// 权限管理\n\n// flag\n\nprivate var lastSearchKey = \"\"                              // 最后搜索字段\nprivate var isRegionChangedFromCustomer = false             // 地图领域变化原因为用户手动滑动\nprivate var isReGeoRequestForSubmit = false                 // 逆地理请求用于提交\nprivate var viewDidAppear = false  \n```\n\n这里是一些工具和一些flag变量，工具包含地图搜索接口和地图定位功能工具，这些都是高德提供，另外权限是自定义的一个工具来处理的。\n\n### 4.6 生命周期之viewDidLoad\n\n这个走一次，看下做了什么：\n```Swift\noverride func viewDidLoad() {\n        super.viewDidLoad()\n        self.layoutSubviews()\n        self.loadData()\n    }\n```\n加载了子View，然后去加载数据。\n```Swift\nprivate func layoutSubviews() {\n        \n        self.view.backgroundColor = .white\n        \n        // ------------------------- 导航栏 -------------------------\n        let submitBtnF: UIFont = .pingFangRegular(size: 16.0)\n        \n        let btn_submit = UIButton()\n        btn_submit.isEnabled = false\n        btn_submit.ty_setButtonWith(text: \"提交\", font: submitBtnF, color: .ty_409EFF, state: .normal)\n        btn_submit.ty_setButtonWith(text: \"提交\", font: submitBtnF, color: .ty_409EFF.alpha(0.5), state: .disabled)\n        btn_submit.addTarget(self, action: #selector(act_submitBtnClicked(button:)), for: .touchUpInside)\n        let item_submit = UIBarButtonItem(customView: btn_submit)\n        self.navigationItem.rightBarButtonItem = item_submit\n        self.btn_submit = btn_submit\n        \n        // ------------------------- 底部控件 -------------------------\n        let searchListBGW: CGFloat = yScreenWidth\n        let searchListBGH: CGFloat = 104.0\n        let searchListBGR = CGRect(x: 0, y: 0, width: searchListBGW, height: searchListBGH)\n        let searchListBGRadius = 16.0\n        let searchListBGRadiusS = CGSize(width: searchListBGRadius, height: searchListBGRadius)\n        \n        let view_searchListBG = UIView.ty_viewWith(bgColor: .ty_ThemeWhite)\n        view_searchListBG.ty_setCornerWith(rect: searchListBGR, corners: [.topLeft, .topRight], radii: searchListBGRadiusS)\n        self.view.addSubview(view_searchListBG)\n        view_searchListBG.snp.makeConstraints { make in\n            make.bottom.equalTo(self.view.snp.bottom)\n            make.centerX.equalTo(self.view)\n            make.width.equalTo(searchListBGW)\n            make.height.equalTo(searchListBGH)\n        }\n        \n        // 搜索栏\n        let searchBtnF: UIFont = .pingFangRegular(size: 14.0)\n        let searchBtnW: CGFloat = 80.0\n        let searchBtnH: CGFloat = 32.0\n        let searchBarTextFF: UIFont = .pingFangRegular(size: 14.0)\n        let searchBarTextFLeftImageS = CGSize(width: 16.0, height: 16.0)\n        let searchBarTextFLeftViewS = CGSize(width: 32.0, height: 32.0)\n        let searchBarTextFR: CGFloat = 10.0\n        let searchBarTextFH: CGFloat = searchBtnH\n        \n        // 搜索按钮\n        let btn_search = UIButton()\n        btn_search.ty_setButtonWith(text: \"搜索\", font: searchBtnF, color: .ty_TextWhite, state: .normal)\n        btn_search.ty_setBackgroundColor(.ty_409EFF, state: .normal)\n        btn_search.ty_setCornerRadius(searchBtnH/2.0)\n        btn_search.addTarget(self, action: #selector(act_searchBtnClicked(button:)), for: .touchUpInside)\n        \n        view_searchListBG.addSubview(btn_search)\n        btn_search.snp.makeConstraints { make in\n            make.top.equalTo(view_searchListBG).offset(ySuperVerPad)\n            make.right.equalTo(view_searchListBG).offset(-ySuperHorPad)\n            make.width.equalTo(searchBtnW)\n            make.height.equalTo(searchBtnH)\n        }\n        \n        // 搜索栏\n        let textF_search = UITextField.ty_textFieldWith(font: searchBarTextFF, color: .ty_222222)\n        textF_search.backgroundColor = .ty_F7F9FA\n        textF_search.ty_setPlaceholderWith(placeholder: \"请输入地址\", color: .ty_9B9DA7, font: searchBarTextFF)\n        textF_search.ty_setLeftPaddingImage(imageName: \"locationPicker_img_search\", imageSize: searchBarTextFLeftImageS, paddingSize: searchBarTextFLeftViewS)\n        textF_search.ty_setCornerRadius(searchBarTextFH/2.0)\n        \n        textF_search.addTarget(self, action: #selector(act_searchTextFEditChange(textF:)), for: .editingChanged)\n        textF_search.addObserver(self, forKeyPath: \"text\", options: [.new, .old], context: nil)\n        \n        textF_search.delegate = self\n        textF_search.returnKeyType = .search\n        \n        view_searchListBG.addSubview(textF_search)\n        self.textF_search = textF_search\n        textF_search.snp.makeConstraints { make in\n            make.top.equalTo(view_searchListBG).offset(ySuperVerPad)\n            make.left.equalTo(view_searchListBG).offset(ySuperHorPad)\n            make.right.equalTo(btn_search.snp.left).offset(-searchBarTextFR)\n            make.height.equalTo(searchBarTextFH)\n        }\n        \n        // TableView\n        let tableViewT: CGFloat = 6.0\n        \n        let tableView = TYTableView(delegate: self, dataSource: self, style: .plain)\n        tableView.showsVerticalScrollIndicator = false\n        view_searchListBG.addSubview(tableView)\n        self.tableView = tableView\n        tableView.snp.makeConstraints { make in\n            make.top.equalTo(textF_search.snp.bottom).offset(tableViewT)\n            make.left.equalTo(view_searchListBG)\n            make.right.equalTo(view_searchListBG)\n            make.bottom.equalTo(view_searchListBG)\n        }\n        \n        // loading 旋转图\n        let indicatorStyle: UIActivityIndicatorView.Style\n        if #available(iOS 13.0, * ) {\n            indicatorStyle = .medium\n        } else {\n            indicatorStyle = .gray\n        }\n        let ai_spinner = UIActivityIndicatorView(style: indicatorStyle)\n        ai_spinner.startAnimating()\n        view_searchListBG.addSubview(ai_spinner)\n        self.ai_spinner = ai_spinner\n        ai_spinner.snp.makeConstraints { make in\n            make.center.equalTo(view_searchListBG)\n        }\n        \n        // ------------------------- mapView -------------------------\n        let mapViewW: CGFloat = yScreenWidth\n        let mapViewH: CGFloat = yScreenHeight - searchListBGH + searchListBGRadius/2.0\n        let cus_mapViewR = CGRect(x: 0, y: 0, width: mapViewW, height: mapViewH)\n        \n        // MapView\n        let mapView = MAMapView(frame: cus_mapViewR)\n        mapView.zoomLevel = 13.0                // 缩放比例\n        mapView.showsCompass = false            // 显示罗盘\n        mapView.showsScale = false              // 显示比例尺\n        mapView.delegate = self\n        self.view.addSubview(mapView)\n        self.mapView = mapView\n        \n        // 大头针\n        let pointAnnotationImgVW: CGFloat = 40.0\n        let pointAnnotationImgVH: CGFloat = 40.0\n        let imgV_pointAnnotation = UIImageView.ty_imageViewWith(imageName: \"locationPicker_icon_point_annotation\")\n        self.view.addSubview(imgV_pointAnnotation)\n        self.imgV_pointAnnotation = imgV_pointAnnotation\n        imgV_pointAnnotation.snp.makeConstraints { make in\n            make.centerX.equalTo(mapView)\n            make.centerY.equalTo(mapView).offset(-pointAnnotationImgVH/2.0)\n            make.width.equalTo(pointAnnotationImgVW)\n            make.height.equalTo(pointAnnotationImgVH)\n        }\n        \n        // 回归定位按钮\n        let locatedBtnWH: CGFloat = 46.0\n        let locatedBtnR: CGFloat = 9.0\n        let locatedBtnB: CGFloat = 9.0\n        \n        let btn_located = UIButton()\n        btn_located.setImage(UIImage(named: \"locationPicker_btn_located_Blue\"), for: .selected)     // 在当前定位\n        btn_located.setImage(UIImage(named: \"locationPicker_btn_located_Black\"), for: .normal)      // 不在当前定位\n        btn_located.addTarget(self, action: #selector(act_locatedBtnClicked(button:)), for: .touchUpInside)\n        self.view.addSubview(btn_located)\n        self.btn_located = btn_located\n        btn_located.snp.makeConstraints { make in\n            make.right.equalTo(self.view).offset(-locatedBtnR)\n            make.bottom.equalTo(view_searchListBG.snp.top).offset(-locatedBtnB)\n            make.width.equalTo(locatedBtnWH)\n            make.height.equalTo(locatedBtnWH)\n        }\n        \n        self.view.bringSubviewToFront(view_searchListBG)\n    }\n```\n逻辑也是非常清晰，一个一个把视图堆叠进去了。\n这里大头针跟地图一点关系没有，这个只是把大头针放在中间而已。没有跟地图绑定任何关系。\n\n然后去加载数据：\n```Swift\nprivate func loadData() {\n    // 设置标题\n    if let navTitle = self.navTitle, !navTitle.isEmpty {\n        self.title = \"\\(navTitle) 地图定位\"\n    } else {\n        self.title = \"地图定位\"\n    }\n    \n    // 定位功能\n    // 更新App是否显示隐私弹窗的状态，隐私弹窗是否包含高德SDK隐私协议内容的状态\n    AMapLocationManager.updatePrivacyShow(.didShow, privacyInfo: .didContain)\n    // 更新用户授权高德SDK隐私协议状态\n    AMapLocationManager.updatePrivacyAgree(.didAgree)\n    let locationManager = AMapLocationManager()\n    locationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters\n    if #available(iOS 14.0, *) {\n        locationManager.locationAccuracyMode = .fullAccuracy\n    }\n    self.locationManager = locationManager\n    \n    // 搜索\n    let search = AMapSearchAPI()\n    search?.timeout = 10\n    search?.delegate = self\n    self.search = search\n    \n    // 预地理位置信息处理\n    self.data_preLocatedHandle(locationInfo: self.preLocationInfo,\n                                preCoordinate: self.preCoordinate,\n                                preKeyword: self.preKeyword)\n}\n```\n这里设置了标题，然后就去走预地理位置信息处理的方法。这里的pre相关的数据，在跳转前，就给这个controller赋值了，这里跟Android不太一样，Android还要通过intent来传，它这个居然可以直接用controller的实例传值。\n\n具体预制方法为：\n```Swift\n/// 根据预地理位置信息 按照优先级 决定预定位方式\nfunc data_preLocatedHandle(locationInfo: GMLocationPickerLocationInfo? = nil,\n                            preCoordinate: CLLocationCoordinate2D? = nil, preKeyword: String? = nil) {\n    \n    // 预定位处理规则\n    // 完整数据 - 经纬度 - 位置关键词 - 实时定位 - 默认'北京'定位\n    if let preLocationInfo = locationInfo {\n        // 1.完整信息\n        if let coordinate = preLocationInfo.coordinate,\n            coordinate.latitude != 0, coordinate.longitude != 0 {\n            // 1.1 经纬度信息完整\n            self.data_changeRegionTo(preLocationInfo, for: .itemSelected)\n            self.map_searchLocationForNearby()  // 搜索附近\n        } else if !preLocationInfo.address.isEmpty {\n            // 1.2 无经纬度、有地名：搜索地名\n            let searchKey = \"\\(preLocationInfo.city)\\(preLocationInfo.district)\\(preLocationInfo.address)\"\n            self.data_preLocatedHandle(preKeyword: searchKey)\n        } else {\n            // 1.3 都没有：默认操作\n            self.data_preLocatedHandle()\n        }\n    } else if let preCoordinate = preCoordinate {\n        // 2.显示经纬度位置\n        self.mapView.centerCoordinate = preCoordinate\n        self.map_searchLocationForReGeo(isForSubmit: false) // 搜索逆地理编码\n    } else if let preKeyword = preKeyword, preKeyword.count > 0 {\n        // 3.关键词配置\n        self.textF_search.text = preKeyword\n        self.act_searchBtnClicked(button: nil)\n    } else {\n        var isLocationEnable = self.authorizationManager.isLocationAuthroizationEnable()\n        if #available(iOS 14.0, *) {\n            isLocationEnable = isLocationEnable && self.authorizationManager.isAccuracyAuthorizationFull()\n        }\n        if isLocationEnable {\n            // 4.实时定位\n            self.act_locatedBtnClicked(button: nil)\n        } else {\n            // 5.默认北京\n            self.mapView.centerCoordinate = CLLocationCoordinate2D(latitude: 39.909115, longitude: 116.397535)\n            self.map_searchLocationForReGeo(isForSubmit: false) // 搜索逆地理编码\n        }\n    }\n}\n```\n这里就是一段逻辑，如果之前有地址，然后如何去显示的逻辑。如何去移动地图。\n主要是用了一个 self.mapView.centerCoordinate来设置地图中心坐标，然后这里调用搜索词是走了这个方法：\n```Swift\n/// 根据当前地图中间位置 搜索逆地理\n/// - Parameter isForSubmit: 用于提交 or 用户滑动地理获取(顺带搜索附近)\nprivate func map_searchLocationForReGeo(isForSubmit: Bool) {\n    self.isReGeoRequestForSubmit = isForSubmit\n    if isForSubmit {\n        self.ty_showLoadingHUD()\n    } else {\n        // 清空列表数据\n        self.data_reloadTableViewToEmpty(forRequest: true)\n    }\n    \n    // 取消上一个请求\n    self.search.cancelAllRequests()\n    \n    // 逆地理位置请求\n    let coordinate = self.mapView.centerCoordinate\n    let regeo = AMapReGeocodeSearchRequest()\n    regeo.location = AMapGeoPoint.location(withLatitude: coordinate.latitude, longitude: coordinate.longitude)\n    regeo.requireExtension = true\n    self.search.aMapReGoecodeSearch(regeo)\n}\n```\n这里根据地图中心位置调用了搜索接口,具体请求在这里：\n```Swift\nself.search.aMapReGoecodeSearch(regeo)\n```\n\n如何搜索附近地址呢？\n```Swift\n/// 根据选中位置 搜索附近POI\nprivate func map_searchLocationForNearby() {\n    guard let coordinate = self.selectingLocationInfo?.coordinate else { return }\n    // 清空列表数据\n    self.data_reloadTableViewToEmpty(forRequest: true)\n    \n    // 取消上一个请求\n    self.search.cancelAllRequests()\n    \n    // 附近搜索请求\n    let aroundRequest = AMapPOIAroundSearchRequest()\n    let geoPoint = AMapGeoPoint.location(withLatitude: coordinate.latitude,\n                                            longitude: coordinate.longitude)\n    aroundRequest.location = geoPoint\n//        aroundRequest.special = true\n    self.search.aMapPOIAroundSearch(aroundRequest)\n}\n```\n跟上面方法也比较类似。\n\n### 4.7 生命周期之viewWillAppear\n\n```Swift\noverride func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n        setupWhiteNavBarColor()\n        setupWhiteClickCallBack()\n        \n        isHiddenNavBar(isHidden: false)\n    }\n```\n主要处理了导航栏相关的。\n\n### 4.8 生命周期之viewDidAppear\n\n```Swift\noverride func viewDidAppear(_ animated: Bool) {\n        super.viewDidAppear(animated)\n        self.viewDidAppear = true\n    }\n```\n这里没干啥，就设置了一个flag。\n\n### 4.9 析构函数\n\n```Swift\ndeinit {\n        self.tydev_logDeinit()\n    }\n```\n这里也没干啥，打印下日志：\n```Swift\n/// 输出对象销毁日志\nfunc tydev_logDeinit() {\n    self.tydev_logDeinit(nil)\n}\n\n/// 输出对象销毁日志\n/// - Parameter mark: 自定义标识\nfunc tydev_logDeinit(_ mark: String?) {\n    if let mark = mark {\n        print(\">>>>>>>>>>>>>>> deinit view [\\(self)] (\\(mark) <<<<<<<<<<<<<<<\")\n    } else {\n        print(\">>>>>>>>>>>>>>> deinit view [\\(self)] <<<<<<<<<<<<<<<\")\n    }\n}\n```\n\n### 4.10 地图代理\n\n前面我们设置了代理为自己，需要处理下：\n```Swift\n// 地图Delegate - Map\nextension GMLocationPickerController : MAMapViewDelegate {\n    \n    /// 地图区域改变完成后会调用此接口\n    func mapView(_ mapView: MAMapView!, regionDidChangeAnimated animated: Bool) {\n        if !self.viewDidAppear { return }\n        \n        // 大头针动画\n        self.ui_pointAnnotationAnimate()\n        if self.isRegionChangedFromCustomer, self.mapView.userTrackingMode == .none {\n            // 用户手动滑动模式\n            // 搜索逆地理编码(顺带搜索附近)\n            self.map_searchLocationForReGeo(isForSubmit: false)\n        }\n        self.isRegionChangedFromCustomer = true\n    }\n}\n```\n这里是高德自己调用的，估计是滑动后区域改变，这里会走。\n这里我们走完后需要顺带搜索下附近地址，所以需要加上我们自己逻辑哦。\n\n### 4.11 搜索代理\n\n```Swift\n// 地图Delegate - Search\nextension GMLocationPickerController : AMapSearchDelegate {\n    /// POI查询回调函数 [定位获取附近POI、搜索POI]\n    func onPOISearchDone(_ request: AMapPOISearchBaseRequest!, response: AMapPOISearchResponse!) {\n//        if response.pois.count <= 0 {\n//            GMBannerTips.showWarningTips(\"没有找到定位\")\n//            data_reloadTableViewToEmpty(forRequest: false)\n//            return\n//        }\n        \n        let prefixPois = response.pois.prefix(20)     // 最多获取20个数据\n        var locationInfos = prefixPois.map({ GMLocationPickerLocationInfo(mapPOI: $0) })\n        \n        if request.isKind(of: AMapPOIKeywordsSearchRequest.self) {\n            // 1. 搜索关键词(搜索关键词)\n            \n            // 没有搜索到则提示\n            if response.pois.count <= 0 {\n                GMBannerTips.showWarningTips(\"没有找到定位\")\n                data_reloadTableViewToEmpty(forRequest: false)\n                return\n            }\n            \n            // 自动选择第一个位置\n            var selectingInfo = self.selectingLocationInfo\n            if let firstInfo = locationInfos.first {\n                selectingInfo = firstInfo\n                // 移动地图位置\n                self.data_changeRegionTo(firstInfo, for: .keywordSearchSelected)\n            }\n            // 搜索POI距离补全\n            if let selectingInfo = selectingInfo, let selectingCoordinate = selectingInfo.coordinate {\n                let selectingPoint = MAMapPointForCoordinate(selectingCoordinate)\n                for currLocationInfo in locationInfos {\n                    if selectingInfo == currLocationInfo { continue }\n                    if let currCoordinate = currLocationInfo.coordinate {\n                        let currPoint = MAMapPointForCoordinate(currCoordinate)\n                        currLocationInfo.distance = Int(MAMetersBetweenMapPoints(selectingPoint,currPoint))\n                    }\n                }\n            }\n            \n        } else if request.isKind(of: AMapPOIAroundSearchRequest.self) {\n            // 2. 搜索附近位置(定位or选中)\n            \n            // 没有找到定位 则选中当前选中的定位\n            if prefixPois.count <= 0, let selectingInfo = self.selectingLocationInfo {\n                locationInfos.insert(selectingInfo, at: 0)\n            }\n            \n            // 则确保第一个选项为当前地理位置（不匹配则手动添加）\n            if let firstInfo = locationInfos.first, let selectingInfo = self.selectingLocationInfo,\n               firstInfo.poiName != selectingInfo.poiName, firstInfo.address != selectingInfo.address {\n                // 当前第一个位置 非选中中位置\n                locationInfos.insert(selectingInfo, at: 0)\n            }\n            if let firstInfo = locationInfos.first {\n                // 纠正/同步选择中地理位置\n                self.selectingLocationInfo = firstInfo\n            }\n        }\n        \n        // 刷新TableView数据\n        self.data_reloadTableViewWith(locationInfos: locationInfos)\n    }\n    \n    /// 逆地理编码回调 [手动滑动地图时用]\n    func onReGeocodeSearchDone(_ request: AMapReGeocodeSearchRequest!, response: AMapReGeocodeSearchResponse!) {\n        if self.isReGeoRequestForSubmit {\n            // 1. 用于提交的逆地理编码搜索\n            self.ty_hideLoadingHUD()\n            self.isReGeoRequestForSubmit = false\n            \n            guard let location = request.location, let regeocode = response.regeocode else { return }\n            \n            self.view.endEditing(true)\n            let selectingInfo = GMLocationPickerLocationResult(location: location, reGeocode: regeocode, locationInfo: self.selectingLocationInfo)\n            \n            // 提交地址\n            self.delegate?.locationPickerController(self, didSubmit: selectingInfo)\n            locationResultBlock?(selectingInfo)\n            self.popViewController()\n        } else {\n            // 2. 用于用户滑动的逆地理编码搜索\n            guard let location = request.location, let regeocode = response.regeocode else { return }\n            \n            // 设置 locationInfos\n            let prefixPois = regeocode.pois.prefix(20)     // 最多获取20个数据\n            var locationInfos = prefixPois.map({ GMLocationPickerLocationInfo(mapPOI: $0) })\n            \n            let selectingInfo = GMLocationPickerLocationInfo(location: location, reGeocode: regeocode)\n            // 移动地图位置\n            self.data_changeRegionTo(selectingInfo, for: .slideByCustomer)\n            locationInfos.insert(selectingInfo, at: 0)\n            \n            // 刷新TableView数据\n            self.data_reloadTableViewWith(locationInfos: locationInfos)\n        }\n    }\n    \n    /// 当请求发生错误 (timeout)\n    func aMapSearchRequest(_ request: Any!, didFailWithError error: Error!) {\n        let errorCode = error._code\n        \n        var errMsg = \"\"\n        if let searchErrorCode = AMapSearchErrorCode(rawValue: errorCode) {\n            switch searchErrorCode {\n            case .notConnectedToInternet:   break// 网络连接异常\n                //errMsg = AMapSearchError.errorInfo(with: searchErrorCode)\n            default:\n                break\n            }\n        } else {\n            print(\"asdf\")\n        }\n        if !errMsg.isEmpty {\n            self.ty_showMsgHud(errMsg)\n        }\n    }\n    \n}\n```\n这里是高德提供的搜索代理。\n一个是手动滑动，一个是自行搜索，走接口不一样哦。\n\n### 4.12 其它代理\n\n```Swift\n\n// TableView Delegate\nextension GMLocationPickerController: UITableViewDelegate, UITableViewDataSource {\n    \n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        return self.locationInfos.count\n    }\n\n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n        let cell = GMLocationPickerCell.cellWithTableView(tableView)\n        cell.locationInfo = self.locationInfos[indexPath.row]\n        return cell\n    }\n    \n    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n        return GMLocationPickerCell.cellHeight()\n    }\n    \n    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n        let locationInfo = self.locationInfos[indexPath.row]\n        // 清除搜索栏内容\n        self.ui_clearSearchTextF()\n        // 移动地图位置\n        self.data_changeRegionTo(locationInfo, for: .itemSelected)\n        // 搜索附近\n        self.map_searchLocationForNearby()\n    }\n}\n\n// 输入框 & 自定义 Delegate\nextension GMLocationPickerController : UITextFieldDelegate\n{\n    func textFieldShouldReturn(_ textField: UITextField) -> Bool {\n        // 搜索\n        self.act_searchBtnClicked(button: nil)\n        return true\n    }\n}\n```\n这里还用了2个代理，一个是搜索列表的tableView的列表展示，一个是搜索框代理。\n\n### 4.13 如何定位\n\n```Swift\n/// 定位当前位置\nprivate func map_requestLocation(_ completion: ((CLLocation?, AMapLocationReGeocode?) -> ())?) {\n    // 定位请求\n    func requestLocation(_ completion: ((CLLocation?, AMapLocationReGeocode?) -> ())?) {\n        // 单次定位\n        self.locationManager.requestLocation(withReGeocode: true, completionBlock: { (location: CLLocation?, reGeocode: AMapLocationReGeocode?, error: Error?) in\n            // 定位回调\n            if let completion = completion { completion(location, reGeocode) }\n        })\n    }\n    \n    let manager = self.authorizationManager\n    manager.verifyLocationAuthroization(showAlertIn: self, completion: {\n        if #available(iOS 14.0, *) {\n            manager.verifyAccuracyAuthroization(completion: {\n                requestLocation(completion)\n            }, failure: nil)\n        } else {\n            requestLocation(completion)\n        }\n    }, failure: nil)\n}\n```\n别慌，高德也是提供了方法，支持去定位。\n\n### 4.14 地址权限工具\n\n```Swift\n/// 地址权限管理器 配置\nclass TYLocationAuthorizationConfig: NSObject {\n    \n    // info.plist 上配置的 精读权限获取描述\n    // <key>NSLocationTemporaryUsageDescriptionDictionary</key>\n    var accuracyPurposeKey = \"AccuracyUsageDescription\"\n    \n    var locationAlertTitle = \"您需要开启GPS权限\"\n    var locationAlertMessage = \"地图定位需要获取您的GPS权限才能正常使用\"\n}\n\n/// 地址权限管理器\nclass TYLocationAuthorization: NSObject {\n    \n    //MARK: - property\n    \n    // Data\n    \n    private var locationManager: CLLocationManager!             // 定位权限管理\n    \n    private var locationAuthVerifyCompletion: (() -> ())?       // 定位权限获取完成Block (用于权限首次询问)\n    private var locationAuthVerifyFailure: (() -> ())?          // 定位权限获取失败Block (用于权限首次请求)\n    \n    private var config = TYLocationAuthorizationConfig()              // 文本相关配置\n    \n    // State\n    \n    /// 定位权限状态\n    var locationAuthorization: CLAuthorizationStatus {\n        if #available(iOS 14.0, *) {\n            return self.locationManager.authorizationStatus\n        } else {\n            return CLLocationManager.authorizationStatus()\n        }\n    }\n    \n    /// 精读权限状态\n    @available(iOS 14.0, *)\n    var accuracyAuthorization: CLAccuracyAuthorization {\n        return self.locationManager.accuracyAuthorization\n    }\n    \n    \n    //MARK: - life cycle\n    \n    convenience init(config: TYLocationAuthorizationConfig) {\n        self.init()\n        self.config = config\n    }\n    \n    override init() {\n        super.init()\n        self.loadData()\n    }\n    \n    private func loadData() {\n        // 定位权限管理\n        let locationManager = CLLocationManager()\n        locationManager.delegate = self\n        self.locationManager = locationManager\n    }\n    \n    deinit {\n        print(\">>>>>>>>>>>>>>> deinit view [\\(self)] <<<<<<<<<<<<<<<\")\n    }\n    \n    //MARK: - public methods\n    \n    // ------------------------- 权限请求封装 -------------------------\n    \n    /// 定位权限判断\n    func verifyLocationAuthroization(showAlertIn controller: UIViewController? = nil,\n                                     completion: (() -> ())? = nil,\n                                     failure: (() -> ())? = nil) {\n\n        switch self.locationAuthorization {\n        case .notDetermined:                            // 1. 首次打开App时\n            self.locationAuthVerifyCompletion = completion\n            self.locationAuthVerifyFailure = failure\n            self.locationManager.requestWhenInUseAuthorization()    // 使用时 *\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            self.ui_showAlertForDeniedLocationAuthorization(in: controller)\n            if let failure = failure { failure() }\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            if let completion  = completion { completion() }\n        @unknown default:                               // 4. 未知情况\n            self.ui_showAlertForDeniedLocationAuthorization(in: controller)\n            if let failure = failure { failure() }\n        }\n    }\n    \n    /// 精读权限判断(高精读)\n    @available(iOS 14.0, *)\n    func verifyAccuracyAuthroization(completion: (() -> ())? = nil,\n                                     failure: (() -> ())? = nil) {\n        if self.isAccuracyAuthorizationFull() {\n            if let completion = completion { completion() }\n        } else {\n            let key = self.config.accuracyPurposeKey\n            self.locationManager.requestTemporaryFullAccuracyAuthorization(withPurposeKey: key) { err in\n                if self.isAccuracyAuthorizationFull() {\n                    if let completion = completion { completion() }\n                } else {\n                    if let failure = failure { failure() }\n                }\n            }\n        }\n    }\n    \n    // ------------------------- 权限状态 -------------------------\n    \n    /// 定位权限是否被拒绝\n    func isLocationAuthroizationDenied() -> Bool {\n        switch self.locationAuthorization {\n        case .notDetermined:                            // 1. 首次打开App时\n            return false\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            return true\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            return false\n        @unknown default:                               // 4. 未知情况\n            return true\n        }\n    }\n    \n    /// 定位权限是否被允许\n    func isLocationAuthroizationEnable() -> Bool {\n        switch self.locationAuthorization {\n        case .notDetermined:                            // 1. 首次打开App时\n            return false\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            return false\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            return true\n        @unknown default:                               // 4. 未知情况\n            return false\n        }\n    }\n    \n    /// 精准定位\n    @available(iOS 14.0, *)\n    func isAccuracyAuthorizationFull() -> Bool {\n        return self.locationManager.accuracyAuthorization == .fullAccuracy\n    }\n    \n    //MARK: - private methods\n    \n    /// 显示定位权限拒绝 Alert\n    private func ui_showAlertForDeniedLocationAuthorization(in controller: UIViewController?) {\n        guard let controller = controller else { return }\n\n        let title = self.config.locationAlertTitle\n        let message = self.config.locationAlertMessage\n        let alertVC = UIAlertController.ty_doubleOptionAlertWith(title: title, message: message, optionTitle1: \"去设置\", action1: {\n            if let settingURL = URL(string: UIApplication.openSettingsURLString),\n                UIApplication.shared.canOpenURL(settingURL) {\n                UIApplication.shared.open(settingURL, options: [:], completionHandler: nil)\n            }\n        }, optionTitle2: \"取消\", action2: nil)\n        controller.present(alertVC, animated: true, completion: nil)\n    }\n    \n    \n    /// 清空 定位权限获取Block\n    private func clearLocationAuthorizationBlock() {\n        self.locationAuthVerifyCompletion = nil\n        self.locationAuthVerifyFailure = nil\n    }\n}\n\nextension TYLocationAuthorization : CLLocationManagerDelegate {\n    \n    /// 定位权限修改 (iOS 4.2 - 14.0)\n    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {\n        self.data_locationAuthorizationDidChange()\n    }\n    \n    /// 定位权限修改 (iOS 14.0+)\n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {\n        self.data_locationAuthorizationDidChange()\n    }\n    \n    /// 权限状态修改\n    private func data_locationAuthorizationDidChange() {\n        if self.locationAuthVerifyCompletion == nil, self.locationAuthVerifyFailure == nil { return }\n              \n        switch self.locationAuthorization {\n        case .notDetermined:                            // 1. 首次打开App时\n            break\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            if let failure = self.locationAuthVerifyFailure { failure() }\n            self.clearLocationAuthorizationBlock()\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            if let completion = self.locationAuthVerifyCompletion { completion() }\n            self.clearLocationAuthorizationBlock()\n        @unknown default:                               // 4. 未知情况\n            if let failure = self.locationAuthVerifyFailure { failure() }\n            self.clearLocationAuthorizationBlock()\n        }\n        \n    }\n}\n```\n这里需要考虑到多种情况，是否拒绝权限，是否拥有了权限以及不同手机系统的问题。\n用法也是相当简单：\n```Swift\nlet manager = self.authorizationManager\nmanager.verifyLocationAuthroization(showAlertIn: self, completion: {\n    if #available(iOS 14.0, *) {\n        manager.verifyAccuracyAuthroization(completion: {\n            requestLocation(completion)\n        }, failure: nil)\n    } else {\n        requestLocation(completion)\n    }\n}, failure: nil)\n```\n这个manager就是我们的工具类。\n\n大致就是这么多了。\n\n## 5 总结\n\n* 如果要做一个需要三方支持的东西，请务必要提前调研下，如地图，推送，埋点等，这些最后提前了解下三方的接入指南，这样更好去实现需求。\n\n* 高德地图对接非常简单，拿到key后，主要工作就是对Map的处理，用户行为二指缩放这种高德自行实现，我们只需要设置坐标给中间的位置即可。\n\n* 对于地图，一定要考虑是否有权限的情况，没有权限的情况也需要跳转到系统设置，这样才能加强用户体验。万万不可出现没有权限直接闪退的问题。\n\n* 一般做地图都会有一个搜索能力，这样就需要高德搜索接口了，需要了解AMapSearchAPI 这个接口的用法，定位的话就用到AMapLocationManager。","source":"_posts/iOS-swift-实现简易地图功能.md","raw":"---\ntitle: iOS swift 实现简易地图功能\ndate: 2023-01-31 15:27:26\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- 地图\ncategories:\n- iOS\n---\n\n## 1 需求定义\n\n产品需要我们实现这样一个需求，就是根据一个地址（可能有经纬度也可能没有）,然后跳转到地图页面去，地图中间会显示这个地址。运行用户自行点击定位，这样中间会显示当前位置。允许左右滑动，地图中心也会随之变更。支持搜索功能，根据用户搜索关键词，获取一个搜索列表。然后就是一个提交功能，这样需要将经纬度提交到服务端。\n\n大致是这样的需求。\n实现效果是这样的：\n<img src=map.png>\n\n## 2 需求分析\n\n根据产品的需求，我们考虑接入高德地图。所以我们需要事先调研下如何接入高德才行。\n\n其实这个应该非常简单，高德提供了Map，我们只需要将中间的坐标设置为我们自己的坐标。如果没有坐标，我们也调研高德的搜索接口，将搜索结果默认第一条，这应该是最准的吧，然后设置给高德的中间坐标即可。\n\n支持用户滑动，高德就应该支持的，这里应该会提供一个代理，我们在这个代理的回调类里面重新去调用下搜索接口，就能出现附近10条地址。\n\n二指放大，高德应该也是支持的，不需要我们额外设置啥。\n\n另外就是定位可能复杂一点，需要实现获取下定位权限，如果没有权限，需要跳转到系统设置。定位就不需要高德支持了，我们直接调用系统接口，获取经纬度，然后设置给高德就行了。\n\n## 3 准备工作：了解高德\n\n首先附上高德官方文档：[https://lbs.amap.com/api/ios-sdk/summary](https://lbs.amap.com/api/ios-sdk/summary)\n\n申请key这些工作就不用交给我们了，让产品自己申请吧。\n\n接入高德地图，做很复杂的需求，可以参考这篇文档，写得还不错：\n[https://www.jianshu.com/p/770728626874](https://www.jianshu.com/p/770728626874) 但是这个是objective-C，不过基本原理是类似的，还是有参考价值的。\n\n另外附上高德地图可配置参数：\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>logoCenter</td>\n<td>CGPoint</td>\n<td>可设置Logo的位置。必须在mapView.bounds之内，否则会被忽略。</td>\n</tr>\n<tr>\n<td>showsCompass</td>\n<td>Bool</td>\n<td>是否显示指南针。</td>\n</tr>\n<tr>\n<td>compassOrigin</td>\n<td>CGPoint</td>\n<td>设置指南针的位置。</td>\n</tr>\n<tr>\n<td>showsScale</td>\n<td>Bool</td>\n<td>是否显示比例值。</td>\n</tr>\n<tr>\n<td>scaleOrigin</td>\n<td>CGPoint</td>\n<td>设置比例尺的位置。</td>\n</tr>\n<tr>\n<td>zoomEnabled</td>\n<td>Bool</td>\n<td>是否开启缩放手势，默认true。</td>\n</tr>\n<tr>\n<td>scrollEnabled</td>\n<td>Bool</td>\n<td>是否开启滑动手势，默认true。</td>\n</tr>\n<tr>\n<td>rotateEnabled</td>\n<td>Bool</td>\n<td>是否开启旋转手势，默认true。</td>\n</tr>\n<tr>\n<td>rotateCameraEnabled</td>\n<td>Bool</td>\n<td>是否开启倾斜旋转手势，默认true。用户可以在地图上放置两个手指，移动它们一起向下或向上去增加或减小倾斜角。</td>\n</tr>\n<tr>\n<td>setZoomLevel</td>\n<td>CGFloat</td>\n<td>改变地图缩放级别。范围从3级到19级，共17级。级别越高，展示的内容越细，例如街道等等。</td>\n</tr>\n<tr>\n<td>setCenter</td>\n<td>CLLocationCoordinate2D</td>\n<td>改变地图中心的位置。传递具体的经纬度。</td>\n</tr>\n</tbody>\n</table>\n\n另外一个就是需要我们在AppDelegate中注册key：\n```Swift\n /// 设置高德地图\nfunc configAMap() {\n    AMapServices.shared().apiKey = \"你申请的key\"\n    AMapServices.shared().enableHTTPS = true\n}\n```\n\n这里，准备工作基本就完成了。\n\n## 4 代码实现\n\n### 4.1 新建两个实体类\n\n```Swift\nclass GMLocationPickerLocationResult: NSObject {\n    \n    //MARK: - property\n    \n    var coordinate: CLLocationCoordinate2D?     // 经纬度\n    \n    var poiName: String = \"\"                    // 名称\n    \n    var province: String = \"\"                   // 省\n    var provinceCode: String = \"\"               // 省编码\n    var city: String = \"\"                       // 市\n    var citycode: String = \"\"                   // 市编码\n    var district: String = \"\"                   // 区\n    var adcode: String = \"\"                     // 区编码\n    var township: String = \"\"                   // 乡镇街道\n    var towncode: String = \"\"                   // 乡镇街道编码(截取前9位)\n    \n    var detailAddress: String = \"\"              // 详细地址\n    var formattedAddress: String = \"\"           // 格式化全地址(4级+详细)\n    \n    var locationInfo: GMLocationPickerLocationInfo? //\n    \n    /// 模型转换\n    convenience init(location: AMapGeoPoint, reGeocode: AMapReGeocode, locationInfo: GMLocationPickerLocationInfo?) {\n        self.init()\n        \n        let latitude = location.latitude\n        let longitude = location.longitude\n        self.coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n        \n        if let locationInfo = locationInfo {\n            // 1.转换基础信息\n            self.poiName = locationInfo.poiName\n            self.province = locationInfo.province\n            self.city = locationInfo.city\n            self.district = locationInfo.district\n            self.township = locationInfo.street\n            self.detailAddress = locationInfo.address\n            self.formattedAddress = locationInfo.province + locationInfo.city + locationInfo.district + locationInfo.address\n        }\n        if let addressComponent = reGeocode.addressComponent {\n            // 2.转换所有信息\n            var poiName = \"\"\n            if let locationInfo = locationInfo {\n                poiName = locationInfo.poiName\n            } else if let aoisName = reGeocode.aois.first?.name {\n                poiName = aoisName\n            } else if let roadinterName = reGeocode.roadinters.first?.firstName {\n                poiName = roadinterName\n            } else {\n                poiName = addressComponent.township ?? \"\"\n            }\n            self.poiName = self.poiName.ty_forEmpty(poiName)\n            \n            self.province = self.province.ty_forEmpty(addressComponent.province ?? \"\")\n            self.city = self.city.ty_forEmpty(addressComponent.city ?? \"\")\n            self.district = self.district.ty_forEmpty(addressComponent.district ?? \"\")\n            self.township = self.township.ty_forEmpty(addressComponent.township ?? \"\")\n            self.formattedAddress = self.formattedAddress.ty_forEmpty(reGeocode.formattedAddress ?? \"\")\n        }\n        if let addressComponent = reGeocode.addressComponent {\n            // 设置编码\n            self.citycode = addressComponent.citycode ?? \"\"\n            self.adcode = addressComponent.adcode ?? \"\"\n            self.towncode = String(addressComponent.towncode.prefix(9)) // 截取前九位\n        }\n        // 设置省份编码 用自带plist\n        if let globalAddressModel = globalAddressModel {\n            for currProvince in globalAddressModel.data {\n                if currProvince.name == self.province {\n                    self.provinceCode = currProvince.code\n                    break\n                }\n            }\n        }\n        self.locationInfo = locationInfo\n    }\n}\n```\n\n这个用了一个convenience关键字来声明init，主要是覆写的作用，重载。可以参考这篇文章：[https://www.jianshu.com/p/09c6c88ed61e](https://www.jianshu.com/p/09c6c88ed61e)。这里面初始化已经用了高德的实体类AMapGeoPoint,这个包含了经纬度；AMapReGeocode，这个是逆地址编码；然后还有一个自定义实体，这个是Info，上面那个是result，info如下定义：\n\n```Swift\n\nclass GMLocationPickerLocationInfo: NSObject {\n    \n    //MARK: - property\n    \n    var coordinate: CLLocationCoordinate2D?     // 经纬度\n    \n    var poiName: String = \"\"                    // 名称\n    var province: String = \"\"                   // 省\n    var city: String = \"\"                       // 市\n    var district: String = \"\"                   // 区\n    var street: String = \"\"                     // 街道(*)\n    var number: String = \"\"                     // 门牌号(*)\n    \n    var address: String = \"\"                    // 地址(街道 + 门牌)\n    \n    var distance: Int = 0                       // 与选中点距离\n    \n    // UI\n    \n    var ui_isSelected = false                   // cell是否选中中\n    \n    //MARK: - life cycle\n    \n    // ------------------------- map 内转换 -------------------------\n    \n    /// 模型转换 根据 [实时定位]获取的 经纬度 & 逆地理信息\n    convenience init(coordinate: CLLocationCoordinate2D?, reGeocode: AMapLocationReGeocode?) {\n        self.init()\n        \n        self.coordinate = coordinate\n        \n        self.poiName = reGeocode?.poiName ?? \"\"\n        self.province = reGeocode?.province ?? \"\"\n        self.city = reGeocode?.city ?? \"\"\n        self.district = reGeocode?.district ?? \"\"\n        self.street = reGeocode?.street ?? \"\"\n        self.number = reGeocode?.number ?? \"\"\n        self.address = (self.street + self.number)\n        if self.street.isEmpty || self.number.isEmpty {\n            let detailAddress = reGeocode?.formattedAddress ?? \"\"\n            self.address = abbreviationAddressIn(detailAddress: detailAddress, province: province, city: city, district: district)\n        }\n        \n        self.distance = 0\n    }\n    \n    /// 模型转换 根据 [搜索{附近|关键词}]获取的 POI模型\n    convenience init(mapPOI: AMapPOI) {\n        self.init()\n        \n        if let location = mapPOI.location {\n            let latitude = location.latitude\n            let longitude = location.longitude\n            self.coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n        }\n        \n        self.poiName = mapPOI.name\n        self.province = mapPOI.province\n        self.city = mapPOI.city\n        self.district = mapPOI.district\n        self.street = \"\"\n        self.number = \"\"\n        self.address = mapPOI.address\n        \n        self.distance = mapPOI.distance // 周边搜索可用\n    }\n    \n    /// 模型转换 根据 [逆地理编码]获取的 经纬度 & 逆地理编码结果\n    convenience init(location: AMapGeoPoint, reGeocode: AMapReGeocode) {\n        self.init()\n        \n        let addressComponent = reGeocode.addressComponent\n        \n        let latitude = location.latitude\n        let longitude = location.longitude\n        self.coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n        \n        if let aoisName = reGeocode.aois.first?.name {\n            self.poiName = aoisName\n        } else if let roadinterName = reGeocode.roadinters.first?.firstName {\n            self.poiName = roadinterName\n        } else {\n            self.poiName = addressComponent?.township ?? \"\"\n        }\n        self.province = addressComponent?.province ?? \"\"\n        self.city = addressComponent?.city ?? \"\"\n        self.district = addressComponent?.district ?? \"\"\n        self.street = addressComponent?.streetNumber?.street ?? \"\"\n        self.number = addressComponent?.streetNumber?.number ?? \"\"\n        self.address = (self.street + self.number)\n        if self.street.isEmpty || self.number.isEmpty {\n            let detailAddress = reGeocode.formattedAddress ?? \"\"\n            self.address = abbreviationAddressIn(detailAddress: detailAddress, province: province, city: city, district: district)\n        }\n        self.distance = 0\n    }\n    \n    /// 详细地址中获取缩略地址\n    /// - Parameters:\n    ///   - detailAddress: 详细地址\n    ///   - province: 省份\n    ///   - city: 城市\n    ///   - district: 区域\n    private func abbreviationAddressIn(detailAddress: String, province: String, city: String, district: String) -> String {\n        var address = detailAddress\n        address = address.replacingOccurrences(of: province, with: \"\")\n        address = address.replacingOccurrences(of: city, with: \"\")\n        address = address.replacingOccurrences(of: city, with: \"\")\n        return address\n    }\n    \n    // ------------------------- model 转换 -------------------------\n    \n    /// 模型转换 根据 地理信息结果模型\n    convenience init(locationResult: GMLocationPickerLocationResult) {\n        self.init()\n        \n        self.coordinate = locationResult.coordinate\n        \n        self.poiName = locationResult.poiName\n        self.province = locationResult.province\n        self.city = locationResult.city\n        self.district = locationResult.district\n        let street = locationResult.township\n        self.address = street\n        \n        self.distance = 0\n    }\n    \n    /// 模型转换 根据 仓库模型\n    convenience init(warehouseInfo: GMWarehouseInfoHomeList) {\n        self.init()\n        \n        self.coordinate = warehouseInfo.cus_coordinate\n        \n        self.poiName = warehouseInfo.name\n        self.province = warehouseInfo.province\n        self.city = warehouseInfo.city\n        self.district = warehouseInfo.region\n        self.street = \"\"\n        self.number = \"\"\n        self.address = warehouseInfo.address\n        \n        self.distance = 0\n    }\n    \n    /// 模型转换 根据 门店模型\n    convenience init(storeInfo: GMStoreInfoHomeModel) {\n        self.init()\n        \n        self.coordinate = storeInfo.cus_coordinate\n        \n        self.poiName = storeInfo.shopName\n        self.province = storeInfo.shopProvince\n        self.city = storeInfo.shopCity\n        self.district = storeInfo.shopCounty\n        self.street = storeInfo.shopStreet\n        self.number = \"\"\n        self.address = storeInfo.shopAddress\n        \n        self.distance = 0\n    }\n}\n```\n这个是地图内部使用，上面那个实体，是为了更好对接服务端设定的一个实体。\n\n### 4.2 外部类定义\n\n```Swift\n/// 地图选择 闭包，向外吐出去\ntypealias GMLocationResultHandler = (GMLocationPickerLocationResult?) -> Swift.Void\n\nprotocol GMLocationPickerControllerDelegate: AnyObject {\n    /// 提交所选位置\n    func locationPickerController(_ collection: GMLocationPickerController, didSubmit locationInfo: GMLocationPickerLocationResult)\n    \n    /// 页面将要pop出\n    func locationPickerControllerWillPop(_ collection: GMLocationPickerController)\n}\n\n/// 从哪里进来的 枚举类\nenum GMLocationPickerFor {\n    case warehouseCreate                                        // 仓库创建\n    case warehouseEdit(warehouseInfo: GMWarehouseInfoHomeList)  // 仓库编辑\n    case storeEdit(storeInfo: GMStoreInfoHomeModel)             // 门店编辑\n}\n\n/// 选择地理位置的原因 什么时候走高德接口\nenum GMLocationPickerRegionChageFor {\n    case located                                                // 实时定位\n    case itemSelected                                           // 搜索项选择\n    case keywordSearchSelected                                  // 关键词搜索 自动选择(第一个)\n    case slideByCustomer                                        // 用户滑动逆地理\n}\n```\n这里定义了可能需要的枚举类和协议。\n枚举类主要跟我们自己业务有关系了，协议也是跟业务有关系。这里并不是实现地图的必须。\n\n### 4.3 UI声明\n\n```Swift\nclass GMLocationPickerController: GMBaseViewController {\n\n    //MARK: - property\n    \n    // UI\n    \n    private weak var btn_submit: UIButton!                      // 提交按钮\n    private weak var mapView: MAMapView!                        // 地图\n    private weak var textF_search: UITextField!                 // 搜索 输入栏\n    private weak var tableView: TYTableView!                    // 搜索 列表\n    private weak var ai_spinner: UIActivityIndicatorView!       // 加载loading\n    private weak var btn_located: UIButton!                     // 定位按钮\n    \n    private weak var imgV_pointAnnotation: UIImageView!         // 自定义大头针\n```\n\n这里声明了实现地图用到的一些材料，当然最关键的是MAMapView了，这个View是高德提供的哦。\n\n### 4.4 数据声明\n\n```Swift\n// Data\nvar navTitle: String?                                       // Nav标题 (可选)\nweak var delegate: GMLocationPickerControllerDelegate?      // 代理\nvar locationResultBlock: GMLocationResultHandler?\n\nprivate var locationInfos = [GMLocationPickerLocationInfo]()// 搜索 地点信息\nprivate var selectingLocationInfo: GMLocationPickerLocationInfo? // 选中地点信息\n\n// Pre Data\n\nvar preLocationInfo: GMLocationPickerLocationInfo?          // 预地理位置信息\nvar preCoordinate: CLLocationCoordinate2D?                  // 预经纬度\nvar preKeyword: String?                                     // 预搜索关键词\nvar pickerFor: GMLocationPickerFor = .warehouseCreate       // 地图选择用于\n```\n这里大致列举了需要用的数据。\n预数据，就是外部传过来的数据，然后我们新建了两个info实体报错搜索的地址和选中的地址。\n\n### 4.5 其它成员声明\n\n```Swift\n// Tool\nprivate var search: AMapSearchAPI!                          // 地图 搜索功能\nprivate var locationManager: AMapLocationManager!           // 地图 定位功能\nprivate var authorizationManager = TYLocationAuthorization()// 权限管理\n\n// flag\n\nprivate var lastSearchKey = \"\"                              // 最后搜索字段\nprivate var isRegionChangedFromCustomer = false             // 地图领域变化原因为用户手动滑动\nprivate var isReGeoRequestForSubmit = false                 // 逆地理请求用于提交\nprivate var viewDidAppear = false  \n```\n\n这里是一些工具和一些flag变量，工具包含地图搜索接口和地图定位功能工具，这些都是高德提供，另外权限是自定义的一个工具来处理的。\n\n### 4.6 生命周期之viewDidLoad\n\n这个走一次，看下做了什么：\n```Swift\noverride func viewDidLoad() {\n        super.viewDidLoad()\n        self.layoutSubviews()\n        self.loadData()\n    }\n```\n加载了子View，然后去加载数据。\n```Swift\nprivate func layoutSubviews() {\n        \n        self.view.backgroundColor = .white\n        \n        // ------------------------- 导航栏 -------------------------\n        let submitBtnF: UIFont = .pingFangRegular(size: 16.0)\n        \n        let btn_submit = UIButton()\n        btn_submit.isEnabled = false\n        btn_submit.ty_setButtonWith(text: \"提交\", font: submitBtnF, color: .ty_409EFF, state: .normal)\n        btn_submit.ty_setButtonWith(text: \"提交\", font: submitBtnF, color: .ty_409EFF.alpha(0.5), state: .disabled)\n        btn_submit.addTarget(self, action: #selector(act_submitBtnClicked(button:)), for: .touchUpInside)\n        let item_submit = UIBarButtonItem(customView: btn_submit)\n        self.navigationItem.rightBarButtonItem = item_submit\n        self.btn_submit = btn_submit\n        \n        // ------------------------- 底部控件 -------------------------\n        let searchListBGW: CGFloat = yScreenWidth\n        let searchListBGH: CGFloat = 104.0\n        let searchListBGR = CGRect(x: 0, y: 0, width: searchListBGW, height: searchListBGH)\n        let searchListBGRadius = 16.0\n        let searchListBGRadiusS = CGSize(width: searchListBGRadius, height: searchListBGRadius)\n        \n        let view_searchListBG = UIView.ty_viewWith(bgColor: .ty_ThemeWhite)\n        view_searchListBG.ty_setCornerWith(rect: searchListBGR, corners: [.topLeft, .topRight], radii: searchListBGRadiusS)\n        self.view.addSubview(view_searchListBG)\n        view_searchListBG.snp.makeConstraints { make in\n            make.bottom.equalTo(self.view.snp.bottom)\n            make.centerX.equalTo(self.view)\n            make.width.equalTo(searchListBGW)\n            make.height.equalTo(searchListBGH)\n        }\n        \n        // 搜索栏\n        let searchBtnF: UIFont = .pingFangRegular(size: 14.0)\n        let searchBtnW: CGFloat = 80.0\n        let searchBtnH: CGFloat = 32.0\n        let searchBarTextFF: UIFont = .pingFangRegular(size: 14.0)\n        let searchBarTextFLeftImageS = CGSize(width: 16.0, height: 16.0)\n        let searchBarTextFLeftViewS = CGSize(width: 32.0, height: 32.0)\n        let searchBarTextFR: CGFloat = 10.0\n        let searchBarTextFH: CGFloat = searchBtnH\n        \n        // 搜索按钮\n        let btn_search = UIButton()\n        btn_search.ty_setButtonWith(text: \"搜索\", font: searchBtnF, color: .ty_TextWhite, state: .normal)\n        btn_search.ty_setBackgroundColor(.ty_409EFF, state: .normal)\n        btn_search.ty_setCornerRadius(searchBtnH/2.0)\n        btn_search.addTarget(self, action: #selector(act_searchBtnClicked(button:)), for: .touchUpInside)\n        \n        view_searchListBG.addSubview(btn_search)\n        btn_search.snp.makeConstraints { make in\n            make.top.equalTo(view_searchListBG).offset(ySuperVerPad)\n            make.right.equalTo(view_searchListBG).offset(-ySuperHorPad)\n            make.width.equalTo(searchBtnW)\n            make.height.equalTo(searchBtnH)\n        }\n        \n        // 搜索栏\n        let textF_search = UITextField.ty_textFieldWith(font: searchBarTextFF, color: .ty_222222)\n        textF_search.backgroundColor = .ty_F7F9FA\n        textF_search.ty_setPlaceholderWith(placeholder: \"请输入地址\", color: .ty_9B9DA7, font: searchBarTextFF)\n        textF_search.ty_setLeftPaddingImage(imageName: \"locationPicker_img_search\", imageSize: searchBarTextFLeftImageS, paddingSize: searchBarTextFLeftViewS)\n        textF_search.ty_setCornerRadius(searchBarTextFH/2.0)\n        \n        textF_search.addTarget(self, action: #selector(act_searchTextFEditChange(textF:)), for: .editingChanged)\n        textF_search.addObserver(self, forKeyPath: \"text\", options: [.new, .old], context: nil)\n        \n        textF_search.delegate = self\n        textF_search.returnKeyType = .search\n        \n        view_searchListBG.addSubview(textF_search)\n        self.textF_search = textF_search\n        textF_search.snp.makeConstraints { make in\n            make.top.equalTo(view_searchListBG).offset(ySuperVerPad)\n            make.left.equalTo(view_searchListBG).offset(ySuperHorPad)\n            make.right.equalTo(btn_search.snp.left).offset(-searchBarTextFR)\n            make.height.equalTo(searchBarTextFH)\n        }\n        \n        // TableView\n        let tableViewT: CGFloat = 6.0\n        \n        let tableView = TYTableView(delegate: self, dataSource: self, style: .plain)\n        tableView.showsVerticalScrollIndicator = false\n        view_searchListBG.addSubview(tableView)\n        self.tableView = tableView\n        tableView.snp.makeConstraints { make in\n            make.top.equalTo(textF_search.snp.bottom).offset(tableViewT)\n            make.left.equalTo(view_searchListBG)\n            make.right.equalTo(view_searchListBG)\n            make.bottom.equalTo(view_searchListBG)\n        }\n        \n        // loading 旋转图\n        let indicatorStyle: UIActivityIndicatorView.Style\n        if #available(iOS 13.0, * ) {\n            indicatorStyle = .medium\n        } else {\n            indicatorStyle = .gray\n        }\n        let ai_spinner = UIActivityIndicatorView(style: indicatorStyle)\n        ai_spinner.startAnimating()\n        view_searchListBG.addSubview(ai_spinner)\n        self.ai_spinner = ai_spinner\n        ai_spinner.snp.makeConstraints { make in\n            make.center.equalTo(view_searchListBG)\n        }\n        \n        // ------------------------- mapView -------------------------\n        let mapViewW: CGFloat = yScreenWidth\n        let mapViewH: CGFloat = yScreenHeight - searchListBGH + searchListBGRadius/2.0\n        let cus_mapViewR = CGRect(x: 0, y: 0, width: mapViewW, height: mapViewH)\n        \n        // MapView\n        let mapView = MAMapView(frame: cus_mapViewR)\n        mapView.zoomLevel = 13.0                // 缩放比例\n        mapView.showsCompass = false            // 显示罗盘\n        mapView.showsScale = false              // 显示比例尺\n        mapView.delegate = self\n        self.view.addSubview(mapView)\n        self.mapView = mapView\n        \n        // 大头针\n        let pointAnnotationImgVW: CGFloat = 40.0\n        let pointAnnotationImgVH: CGFloat = 40.0\n        let imgV_pointAnnotation = UIImageView.ty_imageViewWith(imageName: \"locationPicker_icon_point_annotation\")\n        self.view.addSubview(imgV_pointAnnotation)\n        self.imgV_pointAnnotation = imgV_pointAnnotation\n        imgV_pointAnnotation.snp.makeConstraints { make in\n            make.centerX.equalTo(mapView)\n            make.centerY.equalTo(mapView).offset(-pointAnnotationImgVH/2.0)\n            make.width.equalTo(pointAnnotationImgVW)\n            make.height.equalTo(pointAnnotationImgVH)\n        }\n        \n        // 回归定位按钮\n        let locatedBtnWH: CGFloat = 46.0\n        let locatedBtnR: CGFloat = 9.0\n        let locatedBtnB: CGFloat = 9.0\n        \n        let btn_located = UIButton()\n        btn_located.setImage(UIImage(named: \"locationPicker_btn_located_Blue\"), for: .selected)     // 在当前定位\n        btn_located.setImage(UIImage(named: \"locationPicker_btn_located_Black\"), for: .normal)      // 不在当前定位\n        btn_located.addTarget(self, action: #selector(act_locatedBtnClicked(button:)), for: .touchUpInside)\n        self.view.addSubview(btn_located)\n        self.btn_located = btn_located\n        btn_located.snp.makeConstraints { make in\n            make.right.equalTo(self.view).offset(-locatedBtnR)\n            make.bottom.equalTo(view_searchListBG.snp.top).offset(-locatedBtnB)\n            make.width.equalTo(locatedBtnWH)\n            make.height.equalTo(locatedBtnWH)\n        }\n        \n        self.view.bringSubviewToFront(view_searchListBG)\n    }\n```\n逻辑也是非常清晰，一个一个把视图堆叠进去了。\n这里大头针跟地图一点关系没有，这个只是把大头针放在中间而已。没有跟地图绑定任何关系。\n\n然后去加载数据：\n```Swift\nprivate func loadData() {\n    // 设置标题\n    if let navTitle = self.navTitle, !navTitle.isEmpty {\n        self.title = \"\\(navTitle) 地图定位\"\n    } else {\n        self.title = \"地图定位\"\n    }\n    \n    // 定位功能\n    // 更新App是否显示隐私弹窗的状态，隐私弹窗是否包含高德SDK隐私协议内容的状态\n    AMapLocationManager.updatePrivacyShow(.didShow, privacyInfo: .didContain)\n    // 更新用户授权高德SDK隐私协议状态\n    AMapLocationManager.updatePrivacyAgree(.didAgree)\n    let locationManager = AMapLocationManager()\n    locationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters\n    if #available(iOS 14.0, *) {\n        locationManager.locationAccuracyMode = .fullAccuracy\n    }\n    self.locationManager = locationManager\n    \n    // 搜索\n    let search = AMapSearchAPI()\n    search?.timeout = 10\n    search?.delegate = self\n    self.search = search\n    \n    // 预地理位置信息处理\n    self.data_preLocatedHandle(locationInfo: self.preLocationInfo,\n                                preCoordinate: self.preCoordinate,\n                                preKeyword: self.preKeyword)\n}\n```\n这里设置了标题，然后就去走预地理位置信息处理的方法。这里的pre相关的数据，在跳转前，就给这个controller赋值了，这里跟Android不太一样，Android还要通过intent来传，它这个居然可以直接用controller的实例传值。\n\n具体预制方法为：\n```Swift\n/// 根据预地理位置信息 按照优先级 决定预定位方式\nfunc data_preLocatedHandle(locationInfo: GMLocationPickerLocationInfo? = nil,\n                            preCoordinate: CLLocationCoordinate2D? = nil, preKeyword: String? = nil) {\n    \n    // 预定位处理规则\n    // 完整数据 - 经纬度 - 位置关键词 - 实时定位 - 默认'北京'定位\n    if let preLocationInfo = locationInfo {\n        // 1.完整信息\n        if let coordinate = preLocationInfo.coordinate,\n            coordinate.latitude != 0, coordinate.longitude != 0 {\n            // 1.1 经纬度信息完整\n            self.data_changeRegionTo(preLocationInfo, for: .itemSelected)\n            self.map_searchLocationForNearby()  // 搜索附近\n        } else if !preLocationInfo.address.isEmpty {\n            // 1.2 无经纬度、有地名：搜索地名\n            let searchKey = \"\\(preLocationInfo.city)\\(preLocationInfo.district)\\(preLocationInfo.address)\"\n            self.data_preLocatedHandle(preKeyword: searchKey)\n        } else {\n            // 1.3 都没有：默认操作\n            self.data_preLocatedHandle()\n        }\n    } else if let preCoordinate = preCoordinate {\n        // 2.显示经纬度位置\n        self.mapView.centerCoordinate = preCoordinate\n        self.map_searchLocationForReGeo(isForSubmit: false) // 搜索逆地理编码\n    } else if let preKeyword = preKeyword, preKeyword.count > 0 {\n        // 3.关键词配置\n        self.textF_search.text = preKeyword\n        self.act_searchBtnClicked(button: nil)\n    } else {\n        var isLocationEnable = self.authorizationManager.isLocationAuthroizationEnable()\n        if #available(iOS 14.0, *) {\n            isLocationEnable = isLocationEnable && self.authorizationManager.isAccuracyAuthorizationFull()\n        }\n        if isLocationEnable {\n            // 4.实时定位\n            self.act_locatedBtnClicked(button: nil)\n        } else {\n            // 5.默认北京\n            self.mapView.centerCoordinate = CLLocationCoordinate2D(latitude: 39.909115, longitude: 116.397535)\n            self.map_searchLocationForReGeo(isForSubmit: false) // 搜索逆地理编码\n        }\n    }\n}\n```\n这里就是一段逻辑，如果之前有地址，然后如何去显示的逻辑。如何去移动地图。\n主要是用了一个 self.mapView.centerCoordinate来设置地图中心坐标，然后这里调用搜索词是走了这个方法：\n```Swift\n/// 根据当前地图中间位置 搜索逆地理\n/// - Parameter isForSubmit: 用于提交 or 用户滑动地理获取(顺带搜索附近)\nprivate func map_searchLocationForReGeo(isForSubmit: Bool) {\n    self.isReGeoRequestForSubmit = isForSubmit\n    if isForSubmit {\n        self.ty_showLoadingHUD()\n    } else {\n        // 清空列表数据\n        self.data_reloadTableViewToEmpty(forRequest: true)\n    }\n    \n    // 取消上一个请求\n    self.search.cancelAllRequests()\n    \n    // 逆地理位置请求\n    let coordinate = self.mapView.centerCoordinate\n    let regeo = AMapReGeocodeSearchRequest()\n    regeo.location = AMapGeoPoint.location(withLatitude: coordinate.latitude, longitude: coordinate.longitude)\n    regeo.requireExtension = true\n    self.search.aMapReGoecodeSearch(regeo)\n}\n```\n这里根据地图中心位置调用了搜索接口,具体请求在这里：\n```Swift\nself.search.aMapReGoecodeSearch(regeo)\n```\n\n如何搜索附近地址呢？\n```Swift\n/// 根据选中位置 搜索附近POI\nprivate func map_searchLocationForNearby() {\n    guard let coordinate = self.selectingLocationInfo?.coordinate else { return }\n    // 清空列表数据\n    self.data_reloadTableViewToEmpty(forRequest: true)\n    \n    // 取消上一个请求\n    self.search.cancelAllRequests()\n    \n    // 附近搜索请求\n    let aroundRequest = AMapPOIAroundSearchRequest()\n    let geoPoint = AMapGeoPoint.location(withLatitude: coordinate.latitude,\n                                            longitude: coordinate.longitude)\n    aroundRequest.location = geoPoint\n//        aroundRequest.special = true\n    self.search.aMapPOIAroundSearch(aroundRequest)\n}\n```\n跟上面方法也比较类似。\n\n### 4.7 生命周期之viewWillAppear\n\n```Swift\noverride func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n        setupWhiteNavBarColor()\n        setupWhiteClickCallBack()\n        \n        isHiddenNavBar(isHidden: false)\n    }\n```\n主要处理了导航栏相关的。\n\n### 4.8 生命周期之viewDidAppear\n\n```Swift\noverride func viewDidAppear(_ animated: Bool) {\n        super.viewDidAppear(animated)\n        self.viewDidAppear = true\n    }\n```\n这里没干啥，就设置了一个flag。\n\n### 4.9 析构函数\n\n```Swift\ndeinit {\n        self.tydev_logDeinit()\n    }\n```\n这里也没干啥，打印下日志：\n```Swift\n/// 输出对象销毁日志\nfunc tydev_logDeinit() {\n    self.tydev_logDeinit(nil)\n}\n\n/// 输出对象销毁日志\n/// - Parameter mark: 自定义标识\nfunc tydev_logDeinit(_ mark: String?) {\n    if let mark = mark {\n        print(\">>>>>>>>>>>>>>> deinit view [\\(self)] (\\(mark) <<<<<<<<<<<<<<<\")\n    } else {\n        print(\">>>>>>>>>>>>>>> deinit view [\\(self)] <<<<<<<<<<<<<<<\")\n    }\n}\n```\n\n### 4.10 地图代理\n\n前面我们设置了代理为自己，需要处理下：\n```Swift\n// 地图Delegate - Map\nextension GMLocationPickerController : MAMapViewDelegate {\n    \n    /// 地图区域改变完成后会调用此接口\n    func mapView(_ mapView: MAMapView!, regionDidChangeAnimated animated: Bool) {\n        if !self.viewDidAppear { return }\n        \n        // 大头针动画\n        self.ui_pointAnnotationAnimate()\n        if self.isRegionChangedFromCustomer, self.mapView.userTrackingMode == .none {\n            // 用户手动滑动模式\n            // 搜索逆地理编码(顺带搜索附近)\n            self.map_searchLocationForReGeo(isForSubmit: false)\n        }\n        self.isRegionChangedFromCustomer = true\n    }\n}\n```\n这里是高德自己调用的，估计是滑动后区域改变，这里会走。\n这里我们走完后需要顺带搜索下附近地址，所以需要加上我们自己逻辑哦。\n\n### 4.11 搜索代理\n\n```Swift\n// 地图Delegate - Search\nextension GMLocationPickerController : AMapSearchDelegate {\n    /// POI查询回调函数 [定位获取附近POI、搜索POI]\n    func onPOISearchDone(_ request: AMapPOISearchBaseRequest!, response: AMapPOISearchResponse!) {\n//        if response.pois.count <= 0 {\n//            GMBannerTips.showWarningTips(\"没有找到定位\")\n//            data_reloadTableViewToEmpty(forRequest: false)\n//            return\n//        }\n        \n        let prefixPois = response.pois.prefix(20)     // 最多获取20个数据\n        var locationInfos = prefixPois.map({ GMLocationPickerLocationInfo(mapPOI: $0) })\n        \n        if request.isKind(of: AMapPOIKeywordsSearchRequest.self) {\n            // 1. 搜索关键词(搜索关键词)\n            \n            // 没有搜索到则提示\n            if response.pois.count <= 0 {\n                GMBannerTips.showWarningTips(\"没有找到定位\")\n                data_reloadTableViewToEmpty(forRequest: false)\n                return\n            }\n            \n            // 自动选择第一个位置\n            var selectingInfo = self.selectingLocationInfo\n            if let firstInfo = locationInfos.first {\n                selectingInfo = firstInfo\n                // 移动地图位置\n                self.data_changeRegionTo(firstInfo, for: .keywordSearchSelected)\n            }\n            // 搜索POI距离补全\n            if let selectingInfo = selectingInfo, let selectingCoordinate = selectingInfo.coordinate {\n                let selectingPoint = MAMapPointForCoordinate(selectingCoordinate)\n                for currLocationInfo in locationInfos {\n                    if selectingInfo == currLocationInfo { continue }\n                    if let currCoordinate = currLocationInfo.coordinate {\n                        let currPoint = MAMapPointForCoordinate(currCoordinate)\n                        currLocationInfo.distance = Int(MAMetersBetweenMapPoints(selectingPoint,currPoint))\n                    }\n                }\n            }\n            \n        } else if request.isKind(of: AMapPOIAroundSearchRequest.self) {\n            // 2. 搜索附近位置(定位or选中)\n            \n            // 没有找到定位 则选中当前选中的定位\n            if prefixPois.count <= 0, let selectingInfo = self.selectingLocationInfo {\n                locationInfos.insert(selectingInfo, at: 0)\n            }\n            \n            // 则确保第一个选项为当前地理位置（不匹配则手动添加）\n            if let firstInfo = locationInfos.first, let selectingInfo = self.selectingLocationInfo,\n               firstInfo.poiName != selectingInfo.poiName, firstInfo.address != selectingInfo.address {\n                // 当前第一个位置 非选中中位置\n                locationInfos.insert(selectingInfo, at: 0)\n            }\n            if let firstInfo = locationInfos.first {\n                // 纠正/同步选择中地理位置\n                self.selectingLocationInfo = firstInfo\n            }\n        }\n        \n        // 刷新TableView数据\n        self.data_reloadTableViewWith(locationInfos: locationInfos)\n    }\n    \n    /// 逆地理编码回调 [手动滑动地图时用]\n    func onReGeocodeSearchDone(_ request: AMapReGeocodeSearchRequest!, response: AMapReGeocodeSearchResponse!) {\n        if self.isReGeoRequestForSubmit {\n            // 1. 用于提交的逆地理编码搜索\n            self.ty_hideLoadingHUD()\n            self.isReGeoRequestForSubmit = false\n            \n            guard let location = request.location, let regeocode = response.regeocode else { return }\n            \n            self.view.endEditing(true)\n            let selectingInfo = GMLocationPickerLocationResult(location: location, reGeocode: regeocode, locationInfo: self.selectingLocationInfo)\n            \n            // 提交地址\n            self.delegate?.locationPickerController(self, didSubmit: selectingInfo)\n            locationResultBlock?(selectingInfo)\n            self.popViewController()\n        } else {\n            // 2. 用于用户滑动的逆地理编码搜索\n            guard let location = request.location, let regeocode = response.regeocode else { return }\n            \n            // 设置 locationInfos\n            let prefixPois = regeocode.pois.prefix(20)     // 最多获取20个数据\n            var locationInfos = prefixPois.map({ GMLocationPickerLocationInfo(mapPOI: $0) })\n            \n            let selectingInfo = GMLocationPickerLocationInfo(location: location, reGeocode: regeocode)\n            // 移动地图位置\n            self.data_changeRegionTo(selectingInfo, for: .slideByCustomer)\n            locationInfos.insert(selectingInfo, at: 0)\n            \n            // 刷新TableView数据\n            self.data_reloadTableViewWith(locationInfos: locationInfos)\n        }\n    }\n    \n    /// 当请求发生错误 (timeout)\n    func aMapSearchRequest(_ request: Any!, didFailWithError error: Error!) {\n        let errorCode = error._code\n        \n        var errMsg = \"\"\n        if let searchErrorCode = AMapSearchErrorCode(rawValue: errorCode) {\n            switch searchErrorCode {\n            case .notConnectedToInternet:   break// 网络连接异常\n                //errMsg = AMapSearchError.errorInfo(with: searchErrorCode)\n            default:\n                break\n            }\n        } else {\n            print(\"asdf\")\n        }\n        if !errMsg.isEmpty {\n            self.ty_showMsgHud(errMsg)\n        }\n    }\n    \n}\n```\n这里是高德提供的搜索代理。\n一个是手动滑动，一个是自行搜索，走接口不一样哦。\n\n### 4.12 其它代理\n\n```Swift\n\n// TableView Delegate\nextension GMLocationPickerController: UITableViewDelegate, UITableViewDataSource {\n    \n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        return self.locationInfos.count\n    }\n\n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n        let cell = GMLocationPickerCell.cellWithTableView(tableView)\n        cell.locationInfo = self.locationInfos[indexPath.row]\n        return cell\n    }\n    \n    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n        return GMLocationPickerCell.cellHeight()\n    }\n    \n    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n        let locationInfo = self.locationInfos[indexPath.row]\n        // 清除搜索栏内容\n        self.ui_clearSearchTextF()\n        // 移动地图位置\n        self.data_changeRegionTo(locationInfo, for: .itemSelected)\n        // 搜索附近\n        self.map_searchLocationForNearby()\n    }\n}\n\n// 输入框 & 自定义 Delegate\nextension GMLocationPickerController : UITextFieldDelegate\n{\n    func textFieldShouldReturn(_ textField: UITextField) -> Bool {\n        // 搜索\n        self.act_searchBtnClicked(button: nil)\n        return true\n    }\n}\n```\n这里还用了2个代理，一个是搜索列表的tableView的列表展示，一个是搜索框代理。\n\n### 4.13 如何定位\n\n```Swift\n/// 定位当前位置\nprivate func map_requestLocation(_ completion: ((CLLocation?, AMapLocationReGeocode?) -> ())?) {\n    // 定位请求\n    func requestLocation(_ completion: ((CLLocation?, AMapLocationReGeocode?) -> ())?) {\n        // 单次定位\n        self.locationManager.requestLocation(withReGeocode: true, completionBlock: { (location: CLLocation?, reGeocode: AMapLocationReGeocode?, error: Error?) in\n            // 定位回调\n            if let completion = completion { completion(location, reGeocode) }\n        })\n    }\n    \n    let manager = self.authorizationManager\n    manager.verifyLocationAuthroization(showAlertIn: self, completion: {\n        if #available(iOS 14.0, *) {\n            manager.verifyAccuracyAuthroization(completion: {\n                requestLocation(completion)\n            }, failure: nil)\n        } else {\n            requestLocation(completion)\n        }\n    }, failure: nil)\n}\n```\n别慌，高德也是提供了方法，支持去定位。\n\n### 4.14 地址权限工具\n\n```Swift\n/// 地址权限管理器 配置\nclass TYLocationAuthorizationConfig: NSObject {\n    \n    // info.plist 上配置的 精读权限获取描述\n    // <key>NSLocationTemporaryUsageDescriptionDictionary</key>\n    var accuracyPurposeKey = \"AccuracyUsageDescription\"\n    \n    var locationAlertTitle = \"您需要开启GPS权限\"\n    var locationAlertMessage = \"地图定位需要获取您的GPS权限才能正常使用\"\n}\n\n/// 地址权限管理器\nclass TYLocationAuthorization: NSObject {\n    \n    //MARK: - property\n    \n    // Data\n    \n    private var locationManager: CLLocationManager!             // 定位权限管理\n    \n    private var locationAuthVerifyCompletion: (() -> ())?       // 定位权限获取完成Block (用于权限首次询问)\n    private var locationAuthVerifyFailure: (() -> ())?          // 定位权限获取失败Block (用于权限首次请求)\n    \n    private var config = TYLocationAuthorizationConfig()              // 文本相关配置\n    \n    // State\n    \n    /// 定位权限状态\n    var locationAuthorization: CLAuthorizationStatus {\n        if #available(iOS 14.0, *) {\n            return self.locationManager.authorizationStatus\n        } else {\n            return CLLocationManager.authorizationStatus()\n        }\n    }\n    \n    /// 精读权限状态\n    @available(iOS 14.0, *)\n    var accuracyAuthorization: CLAccuracyAuthorization {\n        return self.locationManager.accuracyAuthorization\n    }\n    \n    \n    //MARK: - life cycle\n    \n    convenience init(config: TYLocationAuthorizationConfig) {\n        self.init()\n        self.config = config\n    }\n    \n    override init() {\n        super.init()\n        self.loadData()\n    }\n    \n    private func loadData() {\n        // 定位权限管理\n        let locationManager = CLLocationManager()\n        locationManager.delegate = self\n        self.locationManager = locationManager\n    }\n    \n    deinit {\n        print(\">>>>>>>>>>>>>>> deinit view [\\(self)] <<<<<<<<<<<<<<<\")\n    }\n    \n    //MARK: - public methods\n    \n    // ------------------------- 权限请求封装 -------------------------\n    \n    /// 定位权限判断\n    func verifyLocationAuthroization(showAlertIn controller: UIViewController? = nil,\n                                     completion: (() -> ())? = nil,\n                                     failure: (() -> ())? = nil) {\n\n        switch self.locationAuthorization {\n        case .notDetermined:                            // 1. 首次打开App时\n            self.locationAuthVerifyCompletion = completion\n            self.locationAuthVerifyFailure = failure\n            self.locationManager.requestWhenInUseAuthorization()    // 使用时 *\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            self.ui_showAlertForDeniedLocationAuthorization(in: controller)\n            if let failure = failure { failure() }\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            if let completion  = completion { completion() }\n        @unknown default:                               // 4. 未知情况\n            self.ui_showAlertForDeniedLocationAuthorization(in: controller)\n            if let failure = failure { failure() }\n        }\n    }\n    \n    /// 精读权限判断(高精读)\n    @available(iOS 14.0, *)\n    func verifyAccuracyAuthroization(completion: (() -> ())? = nil,\n                                     failure: (() -> ())? = nil) {\n        if self.isAccuracyAuthorizationFull() {\n            if let completion = completion { completion() }\n        } else {\n            let key = self.config.accuracyPurposeKey\n            self.locationManager.requestTemporaryFullAccuracyAuthorization(withPurposeKey: key) { err in\n                if self.isAccuracyAuthorizationFull() {\n                    if let completion = completion { completion() }\n                } else {\n                    if let failure = failure { failure() }\n                }\n            }\n        }\n    }\n    \n    // ------------------------- 权限状态 -------------------------\n    \n    /// 定位权限是否被拒绝\n    func isLocationAuthroizationDenied() -> Bool {\n        switch self.locationAuthorization {\n        case .notDetermined:                            // 1. 首次打开App时\n            return false\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            return true\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            return false\n        @unknown default:                               // 4. 未知情况\n            return true\n        }\n    }\n    \n    /// 定位权限是否被允许\n    func isLocationAuthroizationEnable() -> Bool {\n        switch self.locationAuthorization {\n        case .notDetermined:                            // 1. 首次打开App时\n            return false\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            return false\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            return true\n        @unknown default:                               // 4. 未知情况\n            return false\n        }\n    }\n    \n    /// 精准定位\n    @available(iOS 14.0, *)\n    func isAccuracyAuthorizationFull() -> Bool {\n        return self.locationManager.accuracyAuthorization == .fullAccuracy\n    }\n    \n    //MARK: - private methods\n    \n    /// 显示定位权限拒绝 Alert\n    private func ui_showAlertForDeniedLocationAuthorization(in controller: UIViewController?) {\n        guard let controller = controller else { return }\n\n        let title = self.config.locationAlertTitle\n        let message = self.config.locationAlertMessage\n        let alertVC = UIAlertController.ty_doubleOptionAlertWith(title: title, message: message, optionTitle1: \"去设置\", action1: {\n            if let settingURL = URL(string: UIApplication.openSettingsURLString),\n                UIApplication.shared.canOpenURL(settingURL) {\n                UIApplication.shared.open(settingURL, options: [:], completionHandler: nil)\n            }\n        }, optionTitle2: \"取消\", action2: nil)\n        controller.present(alertVC, animated: true, completion: nil)\n    }\n    \n    \n    /// 清空 定位权限获取Block\n    private func clearLocationAuthorizationBlock() {\n        self.locationAuthVerifyCompletion = nil\n        self.locationAuthVerifyFailure = nil\n    }\n}\n\nextension TYLocationAuthorization : CLLocationManagerDelegate {\n    \n    /// 定位权限修改 (iOS 4.2 - 14.0)\n    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {\n        self.data_locationAuthorizationDidChange()\n    }\n    \n    /// 定位权限修改 (iOS 14.0+)\n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {\n        self.data_locationAuthorizationDidChange()\n    }\n    \n    /// 权限状态修改\n    private func data_locationAuthorizationDidChange() {\n        if self.locationAuthVerifyCompletion == nil, self.locationAuthVerifyFailure == nil { return }\n              \n        switch self.locationAuthorization {\n        case .notDetermined:                            // 1. 首次打开App时\n            break\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            if let failure = self.locationAuthVerifyFailure { failure() }\n            self.clearLocationAuthorizationBlock()\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            if let completion = self.locationAuthVerifyCompletion { completion() }\n            self.clearLocationAuthorizationBlock()\n        @unknown default:                               // 4. 未知情况\n            if let failure = self.locationAuthVerifyFailure { failure() }\n            self.clearLocationAuthorizationBlock()\n        }\n        \n    }\n}\n```\n这里需要考虑到多种情况，是否拒绝权限，是否拥有了权限以及不同手机系统的问题。\n用法也是相当简单：\n```Swift\nlet manager = self.authorizationManager\nmanager.verifyLocationAuthroization(showAlertIn: self, completion: {\n    if #available(iOS 14.0, *) {\n        manager.verifyAccuracyAuthroization(completion: {\n            requestLocation(completion)\n        }, failure: nil)\n    } else {\n        requestLocation(completion)\n    }\n}, failure: nil)\n```\n这个manager就是我们的工具类。\n\n大致就是这么多了。\n\n## 5 总结\n\n* 如果要做一个需要三方支持的东西，请务必要提前调研下，如地图，推送，埋点等，这些最后提前了解下三方的接入指南，这样更好去实现需求。\n\n* 高德地图对接非常简单，拿到key后，主要工作就是对Map的处理，用户行为二指缩放这种高德自行实现，我们只需要设置坐标给中间的位置即可。\n\n* 对于地图，一定要考虑是否有权限的情况，没有权限的情况也需要跳转到系统设置，这样才能加强用户体验。万万不可出现没有权限直接闪退的问题。\n\n* 一般做地图都会有一个搜索能力，这样就需要高德搜索接口了，需要了解AMapSearchAPI 这个接口的用法，定位的话就用到AMapLocationManager。","slug":"iOS-swift-实现简易地图功能","published":1,"updated":"2023-02-01T07:17:16.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlhfhyr000oivv7dxsn53r6","content":"<h2 id=\"1-需求定义\"><a href=\"#1-需求定义\" class=\"headerlink\" title=\"1 需求定义\"></a>1 需求定义</h2><p>产品需要我们实现这样一个需求，就是根据一个地址（可能有经纬度也可能没有）,然后跳转到地图页面去，地图中间会显示这个地址。运行用户自行点击定位，这样中间会显示当前位置。允许左右滑动，地图中心也会随之变更。支持搜索功能，根据用户搜索关键词，获取一个搜索列表。然后就是一个提交功能，这样需要将经纬度提交到服务端。</p>\n<p>大致是这样的需求。<br>实现效果是这样的：<br><img src=map.png></p>\n<h2 id=\"2-需求分析\"><a href=\"#2-需求分析\" class=\"headerlink\" title=\"2 需求分析\"></a>2 需求分析</h2><p>根据产品的需求，我们考虑接入高德地图。所以我们需要事先调研下如何接入高德才行。</p>\n<p>其实这个应该非常简单，高德提供了Map，我们只需要将中间的坐标设置为我们自己的坐标。如果没有坐标，我们也调研高德的搜索接口，将搜索结果默认第一条，这应该是最准的吧，然后设置给高德的中间坐标即可。</p>\n<p>支持用户滑动，高德就应该支持的，这里应该会提供一个代理，我们在这个代理的回调类里面重新去调用下搜索接口，就能出现附近10条地址。</p>\n<p>二指放大，高德应该也是支持的，不需要我们额外设置啥。</p>\n<p>另外就是定位可能复杂一点，需要实现获取下定位权限，如果没有权限，需要跳转到系统设置。定位就不需要高德支持了，我们直接调用系统接口，获取经纬度，然后设置给高德就行了。</p>\n<h2 id=\"3-准备工作：了解高德\"><a href=\"#3-准备工作：了解高德\" class=\"headerlink\" title=\"3 准备工作：了解高德\"></a>3 准备工作：了解高德</h2><p>首先附上高德官方文档：<a href=\"https://lbs.amap.com/api/ios-sdk/summary\">https://lbs.amap.com/api/ios-sdk/summary</a></p>\n<p>申请key这些工作就不用交给我们了，让产品自己申请吧。</p>\n<p>接入高德地图，做很复杂的需求，可以参考这篇文档，写得还不错：<br><a href=\"https://www.jianshu.com/p/770728626874\">https://www.jianshu.com/p/770728626874</a> 但是这个是objective-C，不过基本原理是类似的，还是有参考价值的。</p>\n<p>另外附上高德地图可配置参数：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>logoCenter</td>\n<td>CGPoint</td>\n<td>可设置Logo的位置。必须在mapView.bounds之内，否则会被忽略。</td>\n</tr>\n<tr>\n<td>showsCompass</td>\n<td>Bool</td>\n<td>是否显示指南针。</td>\n</tr>\n<tr>\n<td>compassOrigin</td>\n<td>CGPoint</td>\n<td>设置指南针的位置。</td>\n</tr>\n<tr>\n<td>showsScale</td>\n<td>Bool</td>\n<td>是否显示比例值。</td>\n</tr>\n<tr>\n<td>scaleOrigin</td>\n<td>CGPoint</td>\n<td>设置比例尺的位置。</td>\n</tr>\n<tr>\n<td>zoomEnabled</td>\n<td>Bool</td>\n<td>是否开启缩放手势，默认true。</td>\n</tr>\n<tr>\n<td>scrollEnabled</td>\n<td>Bool</td>\n<td>是否开启滑动手势，默认true。</td>\n</tr>\n<tr>\n<td>rotateEnabled</td>\n<td>Bool</td>\n<td>是否开启旋转手势，默认true。</td>\n</tr>\n<tr>\n<td>rotateCameraEnabled</td>\n<td>Bool</td>\n<td>是否开启倾斜旋转手势，默认true。用户可以在地图上放置两个手指，移动它们一起向下或向上去增加或减小倾斜角。</td>\n</tr>\n<tr>\n<td>setZoomLevel</td>\n<td>CGFloat</td>\n<td>改变地图缩放级别。范围从3级到19级，共17级。级别越高，展示的内容越细，例如街道等等。</td>\n</tr>\n<tr>\n<td>setCenter</td>\n<td>CLLocationCoordinate2D</td>\n<td>改变地图中心的位置。传递具体的经纬度。</td>\n</tr>\n</tbody>\n</table>\n\n<p>另外一个就是需要我们在AppDelegate中注册key：</p>\n<pre><code class=\"line-numbers language-Swift\"> /// 设置高德地图\nfunc configAMap() &#123;\n    AMapServices.shared().apiKey = &quot;你申请的key&quot;\n    AMapServices.shared().enableHTTPS = true\n&#125;\n</code></pre>\n<p>这里，准备工作基本就完成了。</p>\n<h2 id=\"4-代码实现\"><a href=\"#4-代码实现\" class=\"headerlink\" title=\"4 代码实现\"></a>4 代码实现</h2><h3 id=\"4-1-新建两个实体类\"><a href=\"#4-1-新建两个实体类\" class=\"headerlink\" title=\"4.1 新建两个实体类\"></a>4.1 新建两个实体类</h3><pre><code class=\"line-numbers language-Swift\">class GMLocationPickerLocationResult: NSObject &#123;\n    \n    //MARK: - property\n    \n    var coordinate: CLLocationCoordinate2D?     // 经纬度\n    \n    var poiName: String = &quot;&quot;                    // 名称\n    \n    var province: String = &quot;&quot;                   // 省\n    var provinceCode: String = &quot;&quot;               // 省编码\n    var city: String = &quot;&quot;                       // 市\n    var citycode: String = &quot;&quot;                   // 市编码\n    var district: String = &quot;&quot;                   // 区\n    var adcode: String = &quot;&quot;                     // 区编码\n    var township: String = &quot;&quot;                   // 乡镇街道\n    var towncode: String = &quot;&quot;                   // 乡镇街道编码(截取前9位)\n    \n    var detailAddress: String = &quot;&quot;              // 详细地址\n    var formattedAddress: String = &quot;&quot;           // 格式化全地址(4级+详细)\n    \n    var locationInfo: GMLocationPickerLocationInfo? //\n    \n    /// 模型转换\n    convenience init(location: AMapGeoPoint, reGeocode: AMapReGeocode, locationInfo: GMLocationPickerLocationInfo?) &#123;\n        self.init()\n        \n        let latitude = location.latitude\n        let longitude = location.longitude\n        self.coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n        \n        if let locationInfo = locationInfo &#123;\n            // 1.转换基础信息\n            self.poiName = locationInfo.poiName\n            self.province = locationInfo.province\n            self.city = locationInfo.city\n            self.district = locationInfo.district\n            self.township = locationInfo.street\n            self.detailAddress = locationInfo.address\n            self.formattedAddress = locationInfo.province + locationInfo.city + locationInfo.district + locationInfo.address\n        &#125;\n        if let addressComponent = reGeocode.addressComponent &#123;\n            // 2.转换所有信息\n            var poiName = &quot;&quot;\n            if let locationInfo = locationInfo &#123;\n                poiName = locationInfo.poiName\n            &#125; else if let aoisName = reGeocode.aois.first?.name &#123;\n                poiName = aoisName\n            &#125; else if let roadinterName = reGeocode.roadinters.first?.firstName &#123;\n                poiName = roadinterName\n            &#125; else &#123;\n                poiName = addressComponent.township ?? &quot;&quot;\n            &#125;\n            self.poiName = self.poiName.ty_forEmpty(poiName)\n            \n            self.province = self.province.ty_forEmpty(addressComponent.province ?? &quot;&quot;)\n            self.city = self.city.ty_forEmpty(addressComponent.city ?? &quot;&quot;)\n            self.district = self.district.ty_forEmpty(addressComponent.district ?? &quot;&quot;)\n            self.township = self.township.ty_forEmpty(addressComponent.township ?? &quot;&quot;)\n            self.formattedAddress = self.formattedAddress.ty_forEmpty(reGeocode.formattedAddress ?? &quot;&quot;)\n        &#125;\n        if let addressComponent = reGeocode.addressComponent &#123;\n            // 设置编码\n            self.citycode = addressComponent.citycode ?? &quot;&quot;\n            self.adcode = addressComponent.adcode ?? &quot;&quot;\n            self.towncode = String(addressComponent.towncode.prefix(9)) // 截取前九位\n        &#125;\n        // 设置省份编码 用自带plist\n        if let globalAddressModel = globalAddressModel &#123;\n            for currProvince in globalAddressModel.data &#123;\n                if currProvince.name == self.province &#123;\n                    self.provinceCode = currProvince.code\n                    break\n                &#125;\n            &#125;\n        &#125;\n        self.locationInfo = locationInfo\n    &#125;\n&#125;\n</code></pre>\n<p>这个用了一个convenience关键字来声明init，主要是覆写的作用，重载。可以参考这篇文章：<a href=\"https://www.jianshu.com/p/09c6c88ed61e\">https://www.jianshu.com/p/09c6c88ed61e</a>。这里面初始化已经用了高德的实体类AMapGeoPoint,这个包含了经纬度；AMapReGeocode，这个是逆地址编码；然后还有一个自定义实体，这个是Info，上面那个是result，info如下定义：</p>\n<pre><code class=\"line-numbers language-Swift\">\nclass GMLocationPickerLocationInfo: NSObject &#123;\n    \n    //MARK: - property\n    \n    var coordinate: CLLocationCoordinate2D?     // 经纬度\n    \n    var poiName: String = &quot;&quot;                    // 名称\n    var province: String = &quot;&quot;                   // 省\n    var city: String = &quot;&quot;                       // 市\n    var district: String = &quot;&quot;                   // 区\n    var street: String = &quot;&quot;                     // 街道(*)\n    var number: String = &quot;&quot;                     // 门牌号(*)\n    \n    var address: String = &quot;&quot;                    // 地址(街道 + 门牌)\n    \n    var distance: Int = 0                       // 与选中点距离\n    \n    // UI\n    \n    var ui_isSelected = false                   // cell是否选中中\n    \n    //MARK: - life cycle\n    \n    // ------------------------- map 内转换 -------------------------\n    \n    /// 模型转换 根据 [实时定位]获取的 经纬度 &amp; 逆地理信息\n    convenience init(coordinate: CLLocationCoordinate2D?, reGeocode: AMapLocationReGeocode?) &#123;\n        self.init()\n        \n        self.coordinate = coordinate\n        \n        self.poiName = reGeocode?.poiName ?? &quot;&quot;\n        self.province = reGeocode?.province ?? &quot;&quot;\n        self.city = reGeocode?.city ?? &quot;&quot;\n        self.district = reGeocode?.district ?? &quot;&quot;\n        self.street = reGeocode?.street ?? &quot;&quot;\n        self.number = reGeocode?.number ?? &quot;&quot;\n        self.address = (self.street + self.number)\n        if self.street.isEmpty || self.number.isEmpty &#123;\n            let detailAddress = reGeocode?.formattedAddress ?? &quot;&quot;\n            self.address = abbreviationAddressIn(detailAddress: detailAddress, province: province, city: city, district: district)\n        &#125;\n        \n        self.distance = 0\n    &#125;\n    \n    /// 模型转换 根据 [搜索&#123;附近|关键词&#125;]获取的 POI模型\n    convenience init(mapPOI: AMapPOI) &#123;\n        self.init()\n        \n        if let location = mapPOI.location &#123;\n            let latitude = location.latitude\n            let longitude = location.longitude\n            self.coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n        &#125;\n        \n        self.poiName = mapPOI.name\n        self.province = mapPOI.province\n        self.city = mapPOI.city\n        self.district = mapPOI.district\n        self.street = &quot;&quot;\n        self.number = &quot;&quot;\n        self.address = mapPOI.address\n        \n        self.distance = mapPOI.distance // 周边搜索可用\n    &#125;\n    \n    /// 模型转换 根据 [逆地理编码]获取的 经纬度 &amp; 逆地理编码结果\n    convenience init(location: AMapGeoPoint, reGeocode: AMapReGeocode) &#123;\n        self.init()\n        \n        let addressComponent = reGeocode.addressComponent\n        \n        let latitude = location.latitude\n        let longitude = location.longitude\n        self.coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n        \n        if let aoisName = reGeocode.aois.first?.name &#123;\n            self.poiName = aoisName\n        &#125; else if let roadinterName = reGeocode.roadinters.first?.firstName &#123;\n            self.poiName = roadinterName\n        &#125; else &#123;\n            self.poiName = addressComponent?.township ?? &quot;&quot;\n        &#125;\n        self.province = addressComponent?.province ?? &quot;&quot;\n        self.city = addressComponent?.city ?? &quot;&quot;\n        self.district = addressComponent?.district ?? &quot;&quot;\n        self.street = addressComponent?.streetNumber?.street ?? &quot;&quot;\n        self.number = addressComponent?.streetNumber?.number ?? &quot;&quot;\n        self.address = (self.street + self.number)\n        if self.street.isEmpty || self.number.isEmpty &#123;\n            let detailAddress = reGeocode.formattedAddress ?? &quot;&quot;\n            self.address = abbreviationAddressIn(detailAddress: detailAddress, province: province, city: city, district: district)\n        &#125;\n        self.distance = 0\n    &#125;\n    \n    /// 详细地址中获取缩略地址\n    /// - Parameters:\n    ///   - detailAddress: 详细地址\n    ///   - province: 省份\n    ///   - city: 城市\n    ///   - district: 区域\n    private func abbreviationAddressIn(detailAddress: String, province: String, city: String, district: String) -&gt; String &#123;\n        var address = detailAddress\n        address = address.replacingOccurrences(of: province, with: &quot;&quot;)\n        address = address.replacingOccurrences(of: city, with: &quot;&quot;)\n        address = address.replacingOccurrences(of: city, with: &quot;&quot;)\n        return address\n    &#125;\n    \n    // ------------------------- model 转换 -------------------------\n    \n    /// 模型转换 根据 地理信息结果模型\n    convenience init(locationResult: GMLocationPickerLocationResult) &#123;\n        self.init()\n        \n        self.coordinate = locationResult.coordinate\n        \n        self.poiName = locationResult.poiName\n        self.province = locationResult.province\n        self.city = locationResult.city\n        self.district = locationResult.district\n        let street = locationResult.township\n        self.address = street\n        \n        self.distance = 0\n    &#125;\n    \n    /// 模型转换 根据 仓库模型\n    convenience init(warehouseInfo: GMWarehouseInfoHomeList) &#123;\n        self.init()\n        \n        self.coordinate = warehouseInfo.cus_coordinate\n        \n        self.poiName = warehouseInfo.name\n        self.province = warehouseInfo.province\n        self.city = warehouseInfo.city\n        self.district = warehouseInfo.region\n        self.street = &quot;&quot;\n        self.number = &quot;&quot;\n        self.address = warehouseInfo.address\n        \n        self.distance = 0\n    &#125;\n    \n    /// 模型转换 根据 门店模型\n    convenience init(storeInfo: GMStoreInfoHomeModel) &#123;\n        self.init()\n        \n        self.coordinate = storeInfo.cus_coordinate\n        \n        self.poiName = storeInfo.shopName\n        self.province = storeInfo.shopProvince\n        self.city = storeInfo.shopCity\n        self.district = storeInfo.shopCounty\n        self.street = storeInfo.shopStreet\n        self.number = &quot;&quot;\n        self.address = storeInfo.shopAddress\n        \n        self.distance = 0\n    &#125;\n&#125;\n</code></pre>\n<p>这个是地图内部使用，上面那个实体，是为了更好对接服务端设定的一个实体。</p>\n<h3 id=\"4-2-外部类定义\"><a href=\"#4-2-外部类定义\" class=\"headerlink\" title=\"4.2 外部类定义\"></a>4.2 外部类定义</h3><pre><code class=\"line-numbers language-Swift\">/// 地图选择 闭包，向外吐出去\ntypealias GMLocationResultHandler = (GMLocationPickerLocationResult?) -&gt; Swift.Void\n\nprotocol GMLocationPickerControllerDelegate: AnyObject &#123;\n    /// 提交所选位置\n    func locationPickerController(_ collection: GMLocationPickerController, didSubmit locationInfo: GMLocationPickerLocationResult)\n    \n    /// 页面将要pop出\n    func locationPickerControllerWillPop(_ collection: GMLocationPickerController)\n&#125;\n\n/// 从哪里进来的 枚举类\nenum GMLocationPickerFor &#123;\n    case warehouseCreate                                        // 仓库创建\n    case warehouseEdit(warehouseInfo: GMWarehouseInfoHomeList)  // 仓库编辑\n    case storeEdit(storeInfo: GMStoreInfoHomeModel)             // 门店编辑\n&#125;\n\n/// 选择地理位置的原因 什么时候走高德接口\nenum GMLocationPickerRegionChageFor &#123;\n    case located                                                // 实时定位\n    case itemSelected                                           // 搜索项选择\n    case keywordSearchSelected                                  // 关键词搜索 自动选择(第一个)\n    case slideByCustomer                                        // 用户滑动逆地理\n&#125;\n</code></pre>\n<p>这里定义了可能需要的枚举类和协议。<br>枚举类主要跟我们自己业务有关系了，协议也是跟业务有关系。这里并不是实现地图的必须。</p>\n<h3 id=\"4-3-UI声明\"><a href=\"#4-3-UI声明\" class=\"headerlink\" title=\"4.3 UI声明\"></a>4.3 UI声明</h3><pre><code class=\"line-numbers language-Swift\">class GMLocationPickerController: GMBaseViewController &#123;\n\n    //MARK: - property\n    \n    // UI\n    \n    private weak var btn_submit: UIButton!                      // 提交按钮\n    private weak var mapView: MAMapView!                        // 地图\n    private weak var textF_search: UITextField!                 // 搜索 输入栏\n    private weak var tableView: TYTableView!                    // 搜索 列表\n    private weak var ai_spinner: UIActivityIndicatorView!       // 加载loading\n    private weak var btn_located: UIButton!                     // 定位按钮\n    \n    private weak var imgV_pointAnnotation: UIImageView!         // 自定义大头针\n</code></pre>\n<p>这里声明了实现地图用到的一些材料，当然最关键的是MAMapView了，这个View是高德提供的哦。</p>\n<h3 id=\"4-4-数据声明\"><a href=\"#4-4-数据声明\" class=\"headerlink\" title=\"4.4 数据声明\"></a>4.4 数据声明</h3><pre><code class=\"line-numbers language-Swift\">// Data\nvar navTitle: String?                                       // Nav标题 (可选)\nweak var delegate: GMLocationPickerControllerDelegate?      // 代理\nvar locationResultBlock: GMLocationResultHandler?\n\nprivate var locationInfos = [GMLocationPickerLocationInfo]()// 搜索 地点信息\nprivate var selectingLocationInfo: GMLocationPickerLocationInfo? // 选中地点信息\n\n// Pre Data\n\nvar preLocationInfo: GMLocationPickerLocationInfo?          // 预地理位置信息\nvar preCoordinate: CLLocationCoordinate2D?                  // 预经纬度\nvar preKeyword: String?                                     // 预搜索关键词\nvar pickerFor: GMLocationPickerFor = .warehouseCreate       // 地图选择用于\n</code></pre>\n<p>这里大致列举了需要用的数据。<br>预数据，就是外部传过来的数据，然后我们新建了两个info实体报错搜索的地址和选中的地址。</p>\n<h3 id=\"4-5-其它成员声明\"><a href=\"#4-5-其它成员声明\" class=\"headerlink\" title=\"4.5 其它成员声明\"></a>4.5 其它成员声明</h3><pre><code class=\"line-numbers language-Swift\">// Tool\nprivate var search: AMapSearchAPI!                          // 地图 搜索功能\nprivate var locationManager: AMapLocationManager!           // 地图 定位功能\nprivate var authorizationManager = TYLocationAuthorization()// 权限管理\n\n// flag\n\nprivate var lastSearchKey = &quot;&quot;                              // 最后搜索字段\nprivate var isRegionChangedFromCustomer = false             // 地图领域变化原因为用户手动滑动\nprivate var isReGeoRequestForSubmit = false                 // 逆地理请求用于提交\nprivate var viewDidAppear = false  \n</code></pre>\n<p>这里是一些工具和一些flag变量，工具包含地图搜索接口和地图定位功能工具，这些都是高德提供，另外权限是自定义的一个工具来处理的。</p>\n<h3 id=\"4-6-生命周期之viewDidLoad\"><a href=\"#4-6-生命周期之viewDidLoad\" class=\"headerlink\" title=\"4.6 生命周期之viewDidLoad\"></a>4.6 生命周期之viewDidLoad</h3><p>这个走一次，看下做了什么：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        self.layoutSubviews()\n        self.loadData()\n    &#125;\n</code></pre>\n<p>加载了子View，然后去加载数据。</p>\n<pre><code class=\"line-numbers language-Swift\">private func layoutSubviews() &#123;\n        \n        self.view.backgroundColor = .white\n        \n        // ------------------------- 导航栏 -------------------------\n        let submitBtnF: UIFont = .pingFangRegular(size: 16.0)\n        \n        let btn_submit = UIButton()\n        btn_submit.isEnabled = false\n        btn_submit.ty_setButtonWith(text: &quot;提交&quot;, font: submitBtnF, color: .ty_409EFF, state: .normal)\n        btn_submit.ty_setButtonWith(text: &quot;提交&quot;, font: submitBtnF, color: .ty_409EFF.alpha(0.5), state: .disabled)\n        btn_submit.addTarget(self, action: #selector(act_submitBtnClicked(button:)), for: .touchUpInside)\n        let item_submit = UIBarButtonItem(customView: btn_submit)\n        self.navigationItem.rightBarButtonItem = item_submit\n        self.btn_submit = btn_submit\n        \n        // ------------------------- 底部控件 -------------------------\n        let searchListBGW: CGFloat = yScreenWidth\n        let searchListBGH: CGFloat = 104.0\n        let searchListBGR = CGRect(x: 0, y: 0, width: searchListBGW, height: searchListBGH)\n        let searchListBGRadius = 16.0\n        let searchListBGRadiusS = CGSize(width: searchListBGRadius, height: searchListBGRadius)\n        \n        let view_searchListBG = UIView.ty_viewWith(bgColor: .ty_ThemeWhite)\n        view_searchListBG.ty_setCornerWith(rect: searchListBGR, corners: [.topLeft, .topRight], radii: searchListBGRadiusS)\n        self.view.addSubview(view_searchListBG)\n        view_searchListBG.snp.makeConstraints &#123; make in\n            make.bottom.equalTo(self.view.snp.bottom)\n            make.centerX.equalTo(self.view)\n            make.width.equalTo(searchListBGW)\n            make.height.equalTo(searchListBGH)\n        &#125;\n        \n        // 搜索栏\n        let searchBtnF: UIFont = .pingFangRegular(size: 14.0)\n        let searchBtnW: CGFloat = 80.0\n        let searchBtnH: CGFloat = 32.0\n        let searchBarTextFF: UIFont = .pingFangRegular(size: 14.0)\n        let searchBarTextFLeftImageS = CGSize(width: 16.0, height: 16.0)\n        let searchBarTextFLeftViewS = CGSize(width: 32.0, height: 32.0)\n        let searchBarTextFR: CGFloat = 10.0\n        let searchBarTextFH: CGFloat = searchBtnH\n        \n        // 搜索按钮\n        let btn_search = UIButton()\n        btn_search.ty_setButtonWith(text: &quot;搜索&quot;, font: searchBtnF, color: .ty_TextWhite, state: .normal)\n        btn_search.ty_setBackgroundColor(.ty_409EFF, state: .normal)\n        btn_search.ty_setCornerRadius(searchBtnH/2.0)\n        btn_search.addTarget(self, action: #selector(act_searchBtnClicked(button:)), for: .touchUpInside)\n        \n        view_searchListBG.addSubview(btn_search)\n        btn_search.snp.makeConstraints &#123; make in\n            make.top.equalTo(view_searchListBG).offset(ySuperVerPad)\n            make.right.equalTo(view_searchListBG).offset(-ySuperHorPad)\n            make.width.equalTo(searchBtnW)\n            make.height.equalTo(searchBtnH)\n        &#125;\n        \n        // 搜索栏\n        let textF_search = UITextField.ty_textFieldWith(font: searchBarTextFF, color: .ty_222222)\n        textF_search.backgroundColor = .ty_F7F9FA\n        textF_search.ty_setPlaceholderWith(placeholder: &quot;请输入地址&quot;, color: .ty_9B9DA7, font: searchBarTextFF)\n        textF_search.ty_setLeftPaddingImage(imageName: &quot;locationPicker_img_search&quot;, imageSize: searchBarTextFLeftImageS, paddingSize: searchBarTextFLeftViewS)\n        textF_search.ty_setCornerRadius(searchBarTextFH/2.0)\n        \n        textF_search.addTarget(self, action: #selector(act_searchTextFEditChange(textF:)), for: .editingChanged)\n        textF_search.addObserver(self, forKeyPath: &quot;text&quot;, options: [.new, .old], context: nil)\n        \n        textF_search.delegate = self\n        textF_search.returnKeyType = .search\n        \n        view_searchListBG.addSubview(textF_search)\n        self.textF_search = textF_search\n        textF_search.snp.makeConstraints &#123; make in\n            make.top.equalTo(view_searchListBG).offset(ySuperVerPad)\n            make.left.equalTo(view_searchListBG).offset(ySuperHorPad)\n            make.right.equalTo(btn_search.snp.left).offset(-searchBarTextFR)\n            make.height.equalTo(searchBarTextFH)\n        &#125;\n        \n        // TableView\n        let tableViewT: CGFloat = 6.0\n        \n        let tableView = TYTableView(delegate: self, dataSource: self, style: .plain)\n        tableView.showsVerticalScrollIndicator = false\n        view_searchListBG.addSubview(tableView)\n        self.tableView = tableView\n        tableView.snp.makeConstraints &#123; make in\n            make.top.equalTo(textF_search.snp.bottom).offset(tableViewT)\n            make.left.equalTo(view_searchListBG)\n            make.right.equalTo(view_searchListBG)\n            make.bottom.equalTo(view_searchListBG)\n        &#125;\n        \n        // loading 旋转图\n        let indicatorStyle: UIActivityIndicatorView.Style\n        if #available(iOS 13.0, * ) &#123;\n            indicatorStyle = .medium\n        &#125; else &#123;\n            indicatorStyle = .gray\n        &#125;\n        let ai_spinner = UIActivityIndicatorView(style: indicatorStyle)\n        ai_spinner.startAnimating()\n        view_searchListBG.addSubview(ai_spinner)\n        self.ai_spinner = ai_spinner\n        ai_spinner.snp.makeConstraints &#123; make in\n            make.center.equalTo(view_searchListBG)\n        &#125;\n        \n        // ------------------------- mapView -------------------------\n        let mapViewW: CGFloat = yScreenWidth\n        let mapViewH: CGFloat = yScreenHeight - searchListBGH + searchListBGRadius/2.0\n        let cus_mapViewR = CGRect(x: 0, y: 0, width: mapViewW, height: mapViewH)\n        \n        // MapView\n        let mapView = MAMapView(frame: cus_mapViewR)\n        mapView.zoomLevel = 13.0                // 缩放比例\n        mapView.showsCompass = false            // 显示罗盘\n        mapView.showsScale = false              // 显示比例尺\n        mapView.delegate = self\n        self.view.addSubview(mapView)\n        self.mapView = mapView\n        \n        // 大头针\n        let pointAnnotationImgVW: CGFloat = 40.0\n        let pointAnnotationImgVH: CGFloat = 40.0\n        let imgV_pointAnnotation = UIImageView.ty_imageViewWith(imageName: &quot;locationPicker_icon_point_annotation&quot;)\n        self.view.addSubview(imgV_pointAnnotation)\n        self.imgV_pointAnnotation = imgV_pointAnnotation\n        imgV_pointAnnotation.snp.makeConstraints &#123; make in\n            make.centerX.equalTo(mapView)\n            make.centerY.equalTo(mapView).offset(-pointAnnotationImgVH/2.0)\n            make.width.equalTo(pointAnnotationImgVW)\n            make.height.equalTo(pointAnnotationImgVH)\n        &#125;\n        \n        // 回归定位按钮\n        let locatedBtnWH: CGFloat = 46.0\n        let locatedBtnR: CGFloat = 9.0\n        let locatedBtnB: CGFloat = 9.0\n        \n        let btn_located = UIButton()\n        btn_located.setImage(UIImage(named: &quot;locationPicker_btn_located_Blue&quot;), for: .selected)     // 在当前定位\n        btn_located.setImage(UIImage(named: &quot;locationPicker_btn_located_Black&quot;), for: .normal)      // 不在当前定位\n        btn_located.addTarget(self, action: #selector(act_locatedBtnClicked(button:)), for: .touchUpInside)\n        self.view.addSubview(btn_located)\n        self.btn_located = btn_located\n        btn_located.snp.makeConstraints &#123; make in\n            make.right.equalTo(self.view).offset(-locatedBtnR)\n            make.bottom.equalTo(view_searchListBG.snp.top).offset(-locatedBtnB)\n            make.width.equalTo(locatedBtnWH)\n            make.height.equalTo(locatedBtnWH)\n        &#125;\n        \n        self.view.bringSubviewToFront(view_searchListBG)\n    &#125;\n</code></pre>\n<p>逻辑也是非常清晰，一个一个把视图堆叠进去了。<br>这里大头针跟地图一点关系没有，这个只是把大头针放在中间而已。没有跟地图绑定任何关系。</p>\n<p>然后去加载数据：</p>\n<pre><code class=\"line-numbers language-Swift\">private func loadData() &#123;\n    // 设置标题\n    if let navTitle = self.navTitle, !navTitle.isEmpty &#123;\n        self.title = &quot;\\(navTitle) 地图定位&quot;\n    &#125; else &#123;\n        self.title = &quot;地图定位&quot;\n    &#125;\n    \n    // 定位功能\n    // 更新App是否显示隐私弹窗的状态，隐私弹窗是否包含高德SDK隐私协议内容的状态\n    AMapLocationManager.updatePrivacyShow(.didShow, privacyInfo: .didContain)\n    // 更新用户授权高德SDK隐私协议状态\n    AMapLocationManager.updatePrivacyAgree(.didAgree)\n    let locationManager = AMapLocationManager()\n    locationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters\n    if #available(iOS 14.0, *) &#123;\n        locationManager.locationAccuracyMode = .fullAccuracy\n    &#125;\n    self.locationManager = locationManager\n    \n    // 搜索\n    let search = AMapSearchAPI()\n    search?.timeout = 10\n    search?.delegate = self\n    self.search = search\n    \n    // 预地理位置信息处理\n    self.data_preLocatedHandle(locationInfo: self.preLocationInfo,\n                                preCoordinate: self.preCoordinate,\n                                preKeyword: self.preKeyword)\n&#125;\n</code></pre>\n<p>这里设置了标题，然后就去走预地理位置信息处理的方法。这里的pre相关的数据，在跳转前，就给这个controller赋值了，这里跟Android不太一样，Android还要通过intent来传，它这个居然可以直接用controller的实例传值。</p>\n<p>具体预制方法为：</p>\n<pre><code class=\"line-numbers language-Swift\">/// 根据预地理位置信息 按照优先级 决定预定位方式\nfunc data_preLocatedHandle(locationInfo: GMLocationPickerLocationInfo? = nil,\n                            preCoordinate: CLLocationCoordinate2D? = nil, preKeyword: String? = nil) &#123;\n    \n    // 预定位处理规则\n    // 完整数据 - 经纬度 - 位置关键词 - 实时定位 - 默认&#39;北京&#39;定位\n    if let preLocationInfo = locationInfo &#123;\n        // 1.完整信息\n        if let coordinate = preLocationInfo.coordinate,\n            coordinate.latitude != 0, coordinate.longitude != 0 &#123;\n            // 1.1 经纬度信息完整\n            self.data_changeRegionTo(preLocationInfo, for: .itemSelected)\n            self.map_searchLocationForNearby()  // 搜索附近\n        &#125; else if !preLocationInfo.address.isEmpty &#123;\n            // 1.2 无经纬度、有地名：搜索地名\n            let searchKey = &quot;\\(preLocationInfo.city)\\(preLocationInfo.district)\\(preLocationInfo.address)&quot;\n            self.data_preLocatedHandle(preKeyword: searchKey)\n        &#125; else &#123;\n            // 1.3 都没有：默认操作\n            self.data_preLocatedHandle()\n        &#125;\n    &#125; else if let preCoordinate = preCoordinate &#123;\n        // 2.显示经纬度位置\n        self.mapView.centerCoordinate = preCoordinate\n        self.map_searchLocationForReGeo(isForSubmit: false) // 搜索逆地理编码\n    &#125; else if let preKeyword = preKeyword, preKeyword.count &gt; 0 &#123;\n        // 3.关键词配置\n        self.textF_search.text = preKeyword\n        self.act_searchBtnClicked(button: nil)\n    &#125; else &#123;\n        var isLocationEnable = self.authorizationManager.isLocationAuthroizationEnable()\n        if #available(iOS 14.0, *) &#123;\n            isLocationEnable = isLocationEnable &amp;&amp; self.authorizationManager.isAccuracyAuthorizationFull()\n        &#125;\n        if isLocationEnable &#123;\n            // 4.实时定位\n            self.act_locatedBtnClicked(button: nil)\n        &#125; else &#123;\n            // 5.默认北京\n            self.mapView.centerCoordinate = CLLocationCoordinate2D(latitude: 39.909115, longitude: 116.397535)\n            self.map_searchLocationForReGeo(isForSubmit: false) // 搜索逆地理编码\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里就是一段逻辑，如果之前有地址，然后如何去显示的逻辑。如何去移动地图。<br>主要是用了一个 self.mapView.centerCoordinate来设置地图中心坐标，然后这里调用搜索词是走了这个方法：</p>\n<pre><code class=\"line-numbers language-Swift\">/// 根据当前地图中间位置 搜索逆地理\n/// - Parameter isForSubmit: 用于提交 or 用户滑动地理获取(顺带搜索附近)\nprivate func map_searchLocationForReGeo(isForSubmit: Bool) &#123;\n    self.isReGeoRequestForSubmit = isForSubmit\n    if isForSubmit &#123;\n        self.ty_showLoadingHUD()\n    &#125; else &#123;\n        // 清空列表数据\n        self.data_reloadTableViewToEmpty(forRequest: true)\n    &#125;\n    \n    // 取消上一个请求\n    self.search.cancelAllRequests()\n    \n    // 逆地理位置请求\n    let coordinate = self.mapView.centerCoordinate\n    let regeo = AMapReGeocodeSearchRequest()\n    regeo.location = AMapGeoPoint.location(withLatitude: coordinate.latitude, longitude: coordinate.longitude)\n    regeo.requireExtension = true\n    self.search.aMapReGoecodeSearch(regeo)\n&#125;\n</code></pre>\n<p>这里根据地图中心位置调用了搜索接口,具体请求在这里：</p>\n<pre><code class=\"line-numbers language-Swift\">self.search.aMapReGoecodeSearch(regeo)\n</code></pre>\n<p>如何搜索附近地址呢？</p>\n<pre><code class=\"line-numbers language-Swift\">/// 根据选中位置 搜索附近POI\nprivate func map_searchLocationForNearby() &#123;\n    guard let coordinate = self.selectingLocationInfo?.coordinate else &#123; return &#125;\n    // 清空列表数据\n    self.data_reloadTableViewToEmpty(forRequest: true)\n    \n    // 取消上一个请求\n    self.search.cancelAllRequests()\n    \n    // 附近搜索请求\n    let aroundRequest = AMapPOIAroundSearchRequest()\n    let geoPoint = AMapGeoPoint.location(withLatitude: coordinate.latitude,\n                                            longitude: coordinate.longitude)\n    aroundRequest.location = geoPoint\n//        aroundRequest.special = true\n    self.search.aMapPOIAroundSearch(aroundRequest)\n&#125;\n</code></pre>\n<p>跟上面方法也比较类似。</p>\n<h3 id=\"4-7-生命周期之viewWillAppear\"><a href=\"#4-7-生命周期之viewWillAppear\" class=\"headerlink\" title=\"4.7 生命周期之viewWillAppear\"></a>4.7 生命周期之viewWillAppear</h3><pre><code class=\"line-numbers language-Swift\">override func viewWillAppear(_ animated: Bool) &#123;\n        super.viewWillAppear(animated)\n        setupWhiteNavBarColor()\n        setupWhiteClickCallBack()\n        \n        isHiddenNavBar(isHidden: false)\n    &#125;\n</code></pre>\n<p>主要处理了导航栏相关的。</p>\n<h3 id=\"4-8-生命周期之viewDidAppear\"><a href=\"#4-8-生命周期之viewDidAppear\" class=\"headerlink\" title=\"4.8 生命周期之viewDidAppear\"></a>4.8 生命周期之viewDidAppear</h3><pre><code class=\"line-numbers language-Swift\">override func viewDidAppear(_ animated: Bool) &#123;\n        super.viewDidAppear(animated)\n        self.viewDidAppear = true\n    &#125;\n</code></pre>\n<p>这里没干啥，就设置了一个flag。</p>\n<h3 id=\"4-9-析构函数\"><a href=\"#4-9-析构函数\" class=\"headerlink\" title=\"4.9 析构函数\"></a>4.9 析构函数</h3><pre><code class=\"line-numbers language-Swift\">deinit &#123;\n        self.tydev_logDeinit()\n    &#125;\n</code></pre>\n<p>这里也没干啥，打印下日志：</p>\n<pre><code class=\"line-numbers language-Swift\">/// 输出对象销毁日志\nfunc tydev_logDeinit() &#123;\n    self.tydev_logDeinit(nil)\n&#125;\n\n/// 输出对象销毁日志\n/// - Parameter mark: 自定义标识\nfunc tydev_logDeinit(_ mark: String?) &#123;\n    if let mark = mark &#123;\n        print(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; deinit view [\\(self)] (\\(mark) &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;)\n    &#125; else &#123;\n        print(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; deinit view [\\(self)] &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;)\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"4-10-地图代理\"><a href=\"#4-10-地图代理\" class=\"headerlink\" title=\"4.10 地图代理\"></a>4.10 地图代理</h3><p>前面我们设置了代理为自己，需要处理下：</p>\n<pre><code class=\"line-numbers language-Swift\">// 地图Delegate - Map\nextension GMLocationPickerController : MAMapViewDelegate &#123;\n    \n    /// 地图区域改变完成后会调用此接口\n    func mapView(_ mapView: MAMapView!, regionDidChangeAnimated animated: Bool) &#123;\n        if !self.viewDidAppear &#123; return &#125;\n        \n        // 大头针动画\n        self.ui_pointAnnotationAnimate()\n        if self.isRegionChangedFromCustomer, self.mapView.userTrackingMode == .none &#123;\n            // 用户手动滑动模式\n            // 搜索逆地理编码(顺带搜索附近)\n            self.map_searchLocationForReGeo(isForSubmit: false)\n        &#125;\n        self.isRegionChangedFromCustomer = true\n    &#125;\n&#125;\n</code></pre>\n<p>这里是高德自己调用的，估计是滑动后区域改变，这里会走。<br>这里我们走完后需要顺带搜索下附近地址，所以需要加上我们自己逻辑哦。</p>\n<h3 id=\"4-11-搜索代理\"><a href=\"#4-11-搜索代理\" class=\"headerlink\" title=\"4.11 搜索代理\"></a>4.11 搜索代理</h3><pre><code class=\"line-numbers language-Swift\">// 地图Delegate - Search\nextension GMLocationPickerController : AMapSearchDelegate &#123;\n    /// POI查询回调函数 [定位获取附近POI、搜索POI]\n    func onPOISearchDone(_ request: AMapPOISearchBaseRequest!, response: AMapPOISearchResponse!) &#123;\n//        if response.pois.count &lt;= 0 &#123;\n//            GMBannerTips.showWarningTips(&quot;没有找到定位&quot;)\n//            data_reloadTableViewToEmpty(forRequest: false)\n//            return\n//        &#125;\n        \n        let prefixPois = response.pois.prefix(20)     // 最多获取20个数据\n        var locationInfos = prefixPois.map(&#123; GMLocationPickerLocationInfo(mapPOI: $0) &#125;)\n        \n        if request.isKind(of: AMapPOIKeywordsSearchRequest.self) &#123;\n            // 1. 搜索关键词(搜索关键词)\n            \n            // 没有搜索到则提示\n            if response.pois.count &lt;= 0 &#123;\n                GMBannerTips.showWarningTips(&quot;没有找到定位&quot;)\n                data_reloadTableViewToEmpty(forRequest: false)\n                return\n            &#125;\n            \n            // 自动选择第一个位置\n            var selectingInfo = self.selectingLocationInfo\n            if let firstInfo = locationInfos.first &#123;\n                selectingInfo = firstInfo\n                // 移动地图位置\n                self.data_changeRegionTo(firstInfo, for: .keywordSearchSelected)\n            &#125;\n            // 搜索POI距离补全\n            if let selectingInfo = selectingInfo, let selectingCoordinate = selectingInfo.coordinate &#123;\n                let selectingPoint = MAMapPointForCoordinate(selectingCoordinate)\n                for currLocationInfo in locationInfos &#123;\n                    if selectingInfo == currLocationInfo &#123; continue &#125;\n                    if let currCoordinate = currLocationInfo.coordinate &#123;\n                        let currPoint = MAMapPointForCoordinate(currCoordinate)\n                        currLocationInfo.distance = Int(MAMetersBetweenMapPoints(selectingPoint,currPoint))\n                    &#125;\n                &#125;\n            &#125;\n            \n        &#125; else if request.isKind(of: AMapPOIAroundSearchRequest.self) &#123;\n            // 2. 搜索附近位置(定位or选中)\n            \n            // 没有找到定位 则选中当前选中的定位\n            if prefixPois.count &lt;= 0, let selectingInfo = self.selectingLocationInfo &#123;\n                locationInfos.insert(selectingInfo, at: 0)\n            &#125;\n            \n            // 则确保第一个选项为当前地理位置（不匹配则手动添加）\n            if let firstInfo = locationInfos.first, let selectingInfo = self.selectingLocationInfo,\n               firstInfo.poiName != selectingInfo.poiName, firstInfo.address != selectingInfo.address &#123;\n                // 当前第一个位置 非选中中位置\n                locationInfos.insert(selectingInfo, at: 0)\n            &#125;\n            if let firstInfo = locationInfos.first &#123;\n                // 纠正/同步选择中地理位置\n                self.selectingLocationInfo = firstInfo\n            &#125;\n        &#125;\n        \n        // 刷新TableView数据\n        self.data_reloadTableViewWith(locationInfos: locationInfos)\n    &#125;\n    \n    /// 逆地理编码回调 [手动滑动地图时用]\n    func onReGeocodeSearchDone(_ request: AMapReGeocodeSearchRequest!, response: AMapReGeocodeSearchResponse!) &#123;\n        if self.isReGeoRequestForSubmit &#123;\n            // 1. 用于提交的逆地理编码搜索\n            self.ty_hideLoadingHUD()\n            self.isReGeoRequestForSubmit = false\n            \n            guard let location = request.location, let regeocode = response.regeocode else &#123; return &#125;\n            \n            self.view.endEditing(true)\n            let selectingInfo = GMLocationPickerLocationResult(location: location, reGeocode: regeocode, locationInfo: self.selectingLocationInfo)\n            \n            // 提交地址\n            self.delegate?.locationPickerController(self, didSubmit: selectingInfo)\n            locationResultBlock?(selectingInfo)\n            self.popViewController()\n        &#125; else &#123;\n            // 2. 用于用户滑动的逆地理编码搜索\n            guard let location = request.location, let regeocode = response.regeocode else &#123; return &#125;\n            \n            // 设置 locationInfos\n            let prefixPois = regeocode.pois.prefix(20)     // 最多获取20个数据\n            var locationInfos = prefixPois.map(&#123; GMLocationPickerLocationInfo(mapPOI: $0) &#125;)\n            \n            let selectingInfo = GMLocationPickerLocationInfo(location: location, reGeocode: regeocode)\n            // 移动地图位置\n            self.data_changeRegionTo(selectingInfo, for: .slideByCustomer)\n            locationInfos.insert(selectingInfo, at: 0)\n            \n            // 刷新TableView数据\n            self.data_reloadTableViewWith(locationInfos: locationInfos)\n        &#125;\n    &#125;\n    \n    /// 当请求发生错误 (timeout)\n    func aMapSearchRequest(_ request: Any!, didFailWithError error: Error!) &#123;\n        let errorCode = error._code\n        \n        var errMsg = &quot;&quot;\n        if let searchErrorCode = AMapSearchErrorCode(rawValue: errorCode) &#123;\n            switch searchErrorCode &#123;\n            case .notConnectedToInternet:   break// 网络连接异常\n                //errMsg = AMapSearchError.errorInfo(with: searchErrorCode)\n            default:\n                break\n            &#125;\n        &#125; else &#123;\n            print(&quot;asdf&quot;)\n        &#125;\n        if !errMsg.isEmpty &#123;\n            self.ty_showMsgHud(errMsg)\n        &#125;\n    &#125;\n    \n&#125;\n</code></pre>\n<p>这里是高德提供的搜索代理。<br>一个是手动滑动，一个是自行搜索，走接口不一样哦。</p>\n<h3 id=\"4-12-其它代理\"><a href=\"#4-12-其它代理\" class=\"headerlink\" title=\"4.12 其它代理\"></a>4.12 其它代理</h3><pre><code class=\"line-numbers language-Swift\">\n// TableView Delegate\nextension GMLocationPickerController: UITableViewDelegate, UITableViewDataSource &#123;\n    \n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n        return self.locationInfos.count\n    &#125;\n\n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n        let cell = GMLocationPickerCell.cellWithTableView(tableView)\n        cell.locationInfo = self.locationInfos[indexPath.row]\n        return cell\n    &#125;\n    \n    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n        return GMLocationPickerCell.cellHeight()\n    &#125;\n    \n    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123;\n        let locationInfo = self.locationInfos[indexPath.row]\n        // 清除搜索栏内容\n        self.ui_clearSearchTextF()\n        // 移动地图位置\n        self.data_changeRegionTo(locationInfo, for: .itemSelected)\n        // 搜索附近\n        self.map_searchLocationForNearby()\n    &#125;\n&#125;\n\n// 输入框 &amp; 自定义 Delegate\nextension GMLocationPickerController : UITextFieldDelegate\n&#123;\n    func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool &#123;\n        // 搜索\n        self.act_searchBtnClicked(button: nil)\n        return true\n    &#125;\n&#125;\n</code></pre>\n<p>这里还用了2个代理，一个是搜索列表的tableView的列表展示，一个是搜索框代理。</p>\n<h3 id=\"4-13-如何定位\"><a href=\"#4-13-如何定位\" class=\"headerlink\" title=\"4.13 如何定位\"></a>4.13 如何定位</h3><pre><code class=\"line-numbers language-Swift\">/// 定位当前位置\nprivate func map_requestLocation(_ completion: ((CLLocation?, AMapLocationReGeocode?) -&gt; ())?) &#123;\n    // 定位请求\n    func requestLocation(_ completion: ((CLLocation?, AMapLocationReGeocode?) -&gt; ())?) &#123;\n        // 单次定位\n        self.locationManager.requestLocation(withReGeocode: true, completionBlock: &#123; (location: CLLocation?, reGeocode: AMapLocationReGeocode?, error: Error?) in\n            // 定位回调\n            if let completion = completion &#123; completion(location, reGeocode) &#125;\n        &#125;)\n    &#125;\n    \n    let manager = self.authorizationManager\n    manager.verifyLocationAuthroization(showAlertIn: self, completion: &#123;\n        if #available(iOS 14.0, *) &#123;\n            manager.verifyAccuracyAuthroization(completion: &#123;\n                requestLocation(completion)\n            &#125;, failure: nil)\n        &#125; else &#123;\n            requestLocation(completion)\n        &#125;\n    &#125;, failure: nil)\n&#125;\n</code></pre>\n<p>别慌，高德也是提供了方法，支持去定位。</p>\n<h3 id=\"4-14-地址权限工具\"><a href=\"#4-14-地址权限工具\" class=\"headerlink\" title=\"4.14 地址权限工具\"></a>4.14 地址权限工具</h3><pre><code class=\"line-numbers language-Swift\">/// 地址权限管理器 配置\nclass TYLocationAuthorizationConfig: NSObject &#123;\n    \n    // info.plist 上配置的 精读权限获取描述\n    // &lt;key&gt;NSLocationTemporaryUsageDescriptionDictionary&lt;/key&gt;\n    var accuracyPurposeKey = &quot;AccuracyUsageDescription&quot;\n    \n    var locationAlertTitle = &quot;您需要开启GPS权限&quot;\n    var locationAlertMessage = &quot;地图定位需要获取您的GPS权限才能正常使用&quot;\n&#125;\n\n/// 地址权限管理器\nclass TYLocationAuthorization: NSObject &#123;\n    \n    //MARK: - property\n    \n    // Data\n    \n    private var locationManager: CLLocationManager!             // 定位权限管理\n    \n    private var locationAuthVerifyCompletion: (() -&gt; ())?       // 定位权限获取完成Block (用于权限首次询问)\n    private var locationAuthVerifyFailure: (() -&gt; ())?          // 定位权限获取失败Block (用于权限首次请求)\n    \n    private var config = TYLocationAuthorizationConfig()              // 文本相关配置\n    \n    // State\n    \n    /// 定位权限状态\n    var locationAuthorization: CLAuthorizationStatus &#123;\n        if #available(iOS 14.0, *) &#123;\n            return self.locationManager.authorizationStatus\n        &#125; else &#123;\n            return CLLocationManager.authorizationStatus()\n        &#125;\n    &#125;\n    \n    /// 精读权限状态\n    @available(iOS 14.0, *)\n    var accuracyAuthorization: CLAccuracyAuthorization &#123;\n        return self.locationManager.accuracyAuthorization\n    &#125;\n    \n    \n    //MARK: - life cycle\n    \n    convenience init(config: TYLocationAuthorizationConfig) &#123;\n        self.init()\n        self.config = config\n    &#125;\n    \n    override init() &#123;\n        super.init()\n        self.loadData()\n    &#125;\n    \n    private func loadData() &#123;\n        // 定位权限管理\n        let locationManager = CLLocationManager()\n        locationManager.delegate = self\n        self.locationManager = locationManager\n    &#125;\n    \n    deinit &#123;\n        print(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; deinit view [\\(self)] &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;)\n    &#125;\n    \n    //MARK: - public methods\n    \n    // ------------------------- 权限请求封装 -------------------------\n    \n    /// 定位权限判断\n    func verifyLocationAuthroization(showAlertIn controller: UIViewController? = nil,\n                                     completion: (() -&gt; ())? = nil,\n                                     failure: (() -&gt; ())? = nil) &#123;\n\n        switch self.locationAuthorization &#123;\n        case .notDetermined:                            // 1. 首次打开App时\n            self.locationAuthVerifyCompletion = completion\n            self.locationAuthVerifyFailure = failure\n            self.locationManager.requestWhenInUseAuthorization()    // 使用时 *\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            self.ui_showAlertForDeniedLocationAuthorization(in: controller)\n            if let failure = failure &#123; failure() &#125;\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            if let completion  = completion &#123; completion() &#125;\n        @unknown default:                               // 4. 未知情况\n            self.ui_showAlertForDeniedLocationAuthorization(in: controller)\n            if let failure = failure &#123; failure() &#125;\n        &#125;\n    &#125;\n    \n    /// 精读权限判断(高精读)\n    @available(iOS 14.0, *)\n    func verifyAccuracyAuthroization(completion: (() -&gt; ())? = nil,\n                                     failure: (() -&gt; ())? = nil) &#123;\n        if self.isAccuracyAuthorizationFull() &#123;\n            if let completion = completion &#123; completion() &#125;\n        &#125; else &#123;\n            let key = self.config.accuracyPurposeKey\n            self.locationManager.requestTemporaryFullAccuracyAuthorization(withPurposeKey: key) &#123; err in\n                if self.isAccuracyAuthorizationFull() &#123;\n                    if let completion = completion &#123; completion() &#125;\n                &#125; else &#123;\n                    if let failure = failure &#123; failure() &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    \n    // ------------------------- 权限状态 -------------------------\n    \n    /// 定位权限是否被拒绝\n    func isLocationAuthroizationDenied() -&gt; Bool &#123;\n        switch self.locationAuthorization &#123;\n        case .notDetermined:                            // 1. 首次打开App时\n            return false\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            return true\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            return false\n        @unknown default:                               // 4. 未知情况\n            return true\n        &#125;\n    &#125;\n    \n    /// 定位权限是否被允许\n    func isLocationAuthroizationEnable() -&gt; Bool &#123;\n        switch self.locationAuthorization &#123;\n        case .notDetermined:                            // 1. 首次打开App时\n            return false\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            return false\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            return true\n        @unknown default:                               // 4. 未知情况\n            return false\n        &#125;\n    &#125;\n    \n    /// 精准定位\n    @available(iOS 14.0, *)\n    func isAccuracyAuthorizationFull() -&gt; Bool &#123;\n        return self.locationManager.accuracyAuthorization == .fullAccuracy\n    &#125;\n    \n    //MARK: - private methods\n    \n    /// 显示定位权限拒绝 Alert\n    private func ui_showAlertForDeniedLocationAuthorization(in controller: UIViewController?) &#123;\n        guard let controller = controller else &#123; return &#125;\n\n        let title = self.config.locationAlertTitle\n        let message = self.config.locationAlertMessage\n        let alertVC = UIAlertController.ty_doubleOptionAlertWith(title: title, message: message, optionTitle1: &quot;去设置&quot;, action1: &#123;\n            if let settingURL = URL(string: UIApplication.openSettingsURLString),\n                UIApplication.shared.canOpenURL(settingURL) &#123;\n                UIApplication.shared.open(settingURL, options: [:], completionHandler: nil)\n            &#125;\n        &#125;, optionTitle2: &quot;取消&quot;, action2: nil)\n        controller.present(alertVC, animated: true, completion: nil)\n    &#125;\n    \n    \n    /// 清空 定位权限获取Block\n    private func clearLocationAuthorizationBlock() &#123;\n        self.locationAuthVerifyCompletion = nil\n        self.locationAuthVerifyFailure = nil\n    &#125;\n&#125;\n\nextension TYLocationAuthorization : CLLocationManagerDelegate &#123;\n    \n    /// 定位权限修改 (iOS 4.2 - 14.0)\n    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) &#123;\n        self.data_locationAuthorizationDidChange()\n    &#125;\n    \n    /// 定位权限修改 (iOS 14.0+)\n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) &#123;\n        self.data_locationAuthorizationDidChange()\n    &#125;\n    \n    /// 权限状态修改\n    private func data_locationAuthorizationDidChange() &#123;\n        if self.locationAuthVerifyCompletion == nil, self.locationAuthVerifyFailure == nil &#123; return &#125;\n              \n        switch self.locationAuthorization &#123;\n        case .notDetermined:                            // 1. 首次打开App时\n            break\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            if let failure = self.locationAuthVerifyFailure &#123; failure() &#125;\n            self.clearLocationAuthorizationBlock()\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            if let completion = self.locationAuthVerifyCompletion &#123; completion() &#125;\n            self.clearLocationAuthorizationBlock()\n        @unknown default:                               // 4. 未知情况\n            if let failure = self.locationAuthVerifyFailure &#123; failure() &#125;\n            self.clearLocationAuthorizationBlock()\n        &#125;\n        \n    &#125;\n&#125;\n</code></pre>\n<p>这里需要考虑到多种情况，是否拒绝权限，是否拥有了权限以及不同手机系统的问题。<br>用法也是相当简单：</p>\n<pre><code class=\"line-numbers language-Swift\">let manager = self.authorizationManager\nmanager.verifyLocationAuthroization(showAlertIn: self, completion: &#123;\n    if #available(iOS 14.0, *) &#123;\n        manager.verifyAccuracyAuthroization(completion: &#123;\n            requestLocation(completion)\n        &#125;, failure: nil)\n    &#125; else &#123;\n        requestLocation(completion)\n    &#125;\n&#125;, failure: nil)\n</code></pre>\n<p>这个manager就是我们的工具类。</p>\n<p>大致就是这么多了。</p>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5 总结\"></a>5 总结</h2><ul>\n<li><p>如果要做一个需要三方支持的东西，请务必要提前调研下，如地图，推送，埋点等，这些最后提前了解下三方的接入指南，这样更好去实现需求。</p>\n</li>\n<li><p>高德地图对接非常简单，拿到key后，主要工作就是对Map的处理，用户行为二指缩放这种高德自行实现，我们只需要设置坐标给中间的位置即可。</p>\n</li>\n<li><p>对于地图，一定要考虑是否有权限的情况，没有权限的情况也需要跳转到系统设置，这样才能加强用户体验。万万不可出现没有权限直接闪退的问题。</p>\n</li>\n<li><p>一般做地图都会有一个搜索能力，这样就需要高德搜索接口了，需要了解AMapSearchAPI 这个接口的用法，定位的话就用到AMapLocationManager。</p>\n</li>\n</ul>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-需求定义\"><a href=\"#1-需求定义\" class=\"headerlink\" title=\"1 需求定义\"></a>1 需求定义</h2><p>产品需要我们实现这样一个需求，就是根据一个地址（可能有经纬度也可能没有）,然后跳转到地图页面去，地图中间会显示这个地址。运行用户自行点击定位，这样中间会显示当前位置。允许左右滑动，地图中心也会随之变更。支持搜索功能，根据用户搜索关键词，获取一个搜索列表。然后就是一个提交功能，这样需要将经纬度提交到服务端。</p>\n<p>大致是这样的需求。<br>实现效果是这样的：<br><img src=map.png></p>\n<h2 id=\"2-需求分析\"><a href=\"#2-需求分析\" class=\"headerlink\" title=\"2 需求分析\"></a>2 需求分析</h2><p>根据产品的需求，我们考虑接入高德地图。所以我们需要事先调研下如何接入高德才行。</p>\n<p>其实这个应该非常简单，高德提供了Map，我们只需要将中间的坐标设置为我们自己的坐标。如果没有坐标，我们也调研高德的搜索接口，将搜索结果默认第一条，这应该是最准的吧，然后设置给高德的中间坐标即可。</p>\n<p>支持用户滑动，高德就应该支持的，这里应该会提供一个代理，我们在这个代理的回调类里面重新去调用下搜索接口，就能出现附近10条地址。</p>\n<p>二指放大，高德应该也是支持的，不需要我们额外设置啥。</p>\n<p>另外就是定位可能复杂一点，需要实现获取下定位权限，如果没有权限，需要跳转到系统设置。定位就不需要高德支持了，我们直接调用系统接口，获取经纬度，然后设置给高德就行了。</p>\n<h2 id=\"3-准备工作：了解高德\"><a href=\"#3-准备工作：了解高德\" class=\"headerlink\" title=\"3 准备工作：了解高德\"></a>3 准备工作：了解高德</h2><p>首先附上高德官方文档：<a href=\"https://lbs.amap.com/api/ios-sdk/summary\">https://lbs.amap.com/api/ios-sdk/summary</a></p>\n<p>申请key这些工作就不用交给我们了，让产品自己申请吧。</p>\n<p>接入高德地图，做很复杂的需求，可以参考这篇文档，写得还不错：<br><a href=\"https://www.jianshu.com/p/770728626874\">https://www.jianshu.com/p/770728626874</a> 但是这个是objective-C，不过基本原理是类似的，还是有参考价值的。</p>\n<p>另外附上高德地图可配置参数：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>logoCenter</td>\n<td>CGPoint</td>\n<td>可设置Logo的位置。必须在mapView.bounds之内，否则会被忽略。</td>\n</tr>\n<tr>\n<td>showsCompass</td>\n<td>Bool</td>\n<td>是否显示指南针。</td>\n</tr>\n<tr>\n<td>compassOrigin</td>\n<td>CGPoint</td>\n<td>设置指南针的位置。</td>\n</tr>\n<tr>\n<td>showsScale</td>\n<td>Bool</td>\n<td>是否显示比例值。</td>\n</tr>\n<tr>\n<td>scaleOrigin</td>\n<td>CGPoint</td>\n<td>设置比例尺的位置。</td>\n</tr>\n<tr>\n<td>zoomEnabled</td>\n<td>Bool</td>\n<td>是否开启缩放手势，默认true。</td>\n</tr>\n<tr>\n<td>scrollEnabled</td>\n<td>Bool</td>\n<td>是否开启滑动手势，默认true。</td>\n</tr>\n<tr>\n<td>rotateEnabled</td>\n<td>Bool</td>\n<td>是否开启旋转手势，默认true。</td>\n</tr>\n<tr>\n<td>rotateCameraEnabled</td>\n<td>Bool</td>\n<td>是否开启倾斜旋转手势，默认true。用户可以在地图上放置两个手指，移动它们一起向下或向上去增加或减小倾斜角。</td>\n</tr>\n<tr>\n<td>setZoomLevel</td>\n<td>CGFloat</td>\n<td>改变地图缩放级别。范围从3级到19级，共17级。级别越高，展示的内容越细，例如街道等等。</td>\n</tr>\n<tr>\n<td>setCenter</td>\n<td>CLLocationCoordinate2D</td>\n<td>改变地图中心的位置。传递具体的经纬度。</td>\n</tr>\n</tbody>\n</table>\n\n<p>另外一个就是需要我们在AppDelegate中注册key：</p>\n<pre><code class=\"line-numbers language-Swift\"> /// 设置高德地图\nfunc configAMap() &#123;\n    AMapServices.shared().apiKey = &quot;你申请的key&quot;\n    AMapServices.shared().enableHTTPS = true\n&#125;\n</code></pre>\n<p>这里，准备工作基本就完成了。</p>\n<h2 id=\"4-代码实现\"><a href=\"#4-代码实现\" class=\"headerlink\" title=\"4 代码实现\"></a>4 代码实现</h2><h3 id=\"4-1-新建两个实体类\"><a href=\"#4-1-新建两个实体类\" class=\"headerlink\" title=\"4.1 新建两个实体类\"></a>4.1 新建两个实体类</h3><pre><code class=\"line-numbers language-Swift\">class GMLocationPickerLocationResult: NSObject &#123;\n    \n    //MARK: - property\n    \n    var coordinate: CLLocationCoordinate2D?     // 经纬度\n    \n    var poiName: String = &quot;&quot;                    // 名称\n    \n    var province: String = &quot;&quot;                   // 省\n    var provinceCode: String = &quot;&quot;               // 省编码\n    var city: String = &quot;&quot;                       // 市\n    var citycode: String = &quot;&quot;                   // 市编码\n    var district: String = &quot;&quot;                   // 区\n    var adcode: String = &quot;&quot;                     // 区编码\n    var township: String = &quot;&quot;                   // 乡镇街道\n    var towncode: String = &quot;&quot;                   // 乡镇街道编码(截取前9位)\n    \n    var detailAddress: String = &quot;&quot;              // 详细地址\n    var formattedAddress: String = &quot;&quot;           // 格式化全地址(4级+详细)\n    \n    var locationInfo: GMLocationPickerLocationInfo? //\n    \n    /// 模型转换\n    convenience init(location: AMapGeoPoint, reGeocode: AMapReGeocode, locationInfo: GMLocationPickerLocationInfo?) &#123;\n        self.init()\n        \n        let latitude = location.latitude\n        let longitude = location.longitude\n        self.coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n        \n        if let locationInfo = locationInfo &#123;\n            // 1.转换基础信息\n            self.poiName = locationInfo.poiName\n            self.province = locationInfo.province\n            self.city = locationInfo.city\n            self.district = locationInfo.district\n            self.township = locationInfo.street\n            self.detailAddress = locationInfo.address\n            self.formattedAddress = locationInfo.province + locationInfo.city + locationInfo.district + locationInfo.address\n        &#125;\n        if let addressComponent = reGeocode.addressComponent &#123;\n            // 2.转换所有信息\n            var poiName = &quot;&quot;\n            if let locationInfo = locationInfo &#123;\n                poiName = locationInfo.poiName\n            &#125; else if let aoisName = reGeocode.aois.first?.name &#123;\n                poiName = aoisName\n            &#125; else if let roadinterName = reGeocode.roadinters.first?.firstName &#123;\n                poiName = roadinterName\n            &#125; else &#123;\n                poiName = addressComponent.township ?? &quot;&quot;\n            &#125;\n            self.poiName = self.poiName.ty_forEmpty(poiName)\n            \n            self.province = self.province.ty_forEmpty(addressComponent.province ?? &quot;&quot;)\n            self.city = self.city.ty_forEmpty(addressComponent.city ?? &quot;&quot;)\n            self.district = self.district.ty_forEmpty(addressComponent.district ?? &quot;&quot;)\n            self.township = self.township.ty_forEmpty(addressComponent.township ?? &quot;&quot;)\n            self.formattedAddress = self.formattedAddress.ty_forEmpty(reGeocode.formattedAddress ?? &quot;&quot;)\n        &#125;\n        if let addressComponent = reGeocode.addressComponent &#123;\n            // 设置编码\n            self.citycode = addressComponent.citycode ?? &quot;&quot;\n            self.adcode = addressComponent.adcode ?? &quot;&quot;\n            self.towncode = String(addressComponent.towncode.prefix(9)) // 截取前九位\n        &#125;\n        // 设置省份编码 用自带plist\n        if let globalAddressModel = globalAddressModel &#123;\n            for currProvince in globalAddressModel.data &#123;\n                if currProvince.name == self.province &#123;\n                    self.provinceCode = currProvince.code\n                    break\n                &#125;\n            &#125;\n        &#125;\n        self.locationInfo = locationInfo\n    &#125;\n&#125;\n</code></pre>\n<p>这个用了一个convenience关键字来声明init，主要是覆写的作用，重载。可以参考这篇文章：<a href=\"https://www.jianshu.com/p/09c6c88ed61e\">https://www.jianshu.com/p/09c6c88ed61e</a>。这里面初始化已经用了高德的实体类AMapGeoPoint,这个包含了经纬度；AMapReGeocode，这个是逆地址编码；然后还有一个自定义实体，这个是Info，上面那个是result，info如下定义：</p>\n<pre><code class=\"line-numbers language-Swift\">\nclass GMLocationPickerLocationInfo: NSObject &#123;\n    \n    //MARK: - property\n    \n    var coordinate: CLLocationCoordinate2D?     // 经纬度\n    \n    var poiName: String = &quot;&quot;                    // 名称\n    var province: String = &quot;&quot;                   // 省\n    var city: String = &quot;&quot;                       // 市\n    var district: String = &quot;&quot;                   // 区\n    var street: String = &quot;&quot;                     // 街道(*)\n    var number: String = &quot;&quot;                     // 门牌号(*)\n    \n    var address: String = &quot;&quot;                    // 地址(街道 + 门牌)\n    \n    var distance: Int = 0                       // 与选中点距离\n    \n    // UI\n    \n    var ui_isSelected = false                   // cell是否选中中\n    \n    //MARK: - life cycle\n    \n    // ------------------------- map 内转换 -------------------------\n    \n    /// 模型转换 根据 [实时定位]获取的 经纬度 &amp; 逆地理信息\n    convenience init(coordinate: CLLocationCoordinate2D?, reGeocode: AMapLocationReGeocode?) &#123;\n        self.init()\n        \n        self.coordinate = coordinate\n        \n        self.poiName = reGeocode?.poiName ?? &quot;&quot;\n        self.province = reGeocode?.province ?? &quot;&quot;\n        self.city = reGeocode?.city ?? &quot;&quot;\n        self.district = reGeocode?.district ?? &quot;&quot;\n        self.street = reGeocode?.street ?? &quot;&quot;\n        self.number = reGeocode?.number ?? &quot;&quot;\n        self.address = (self.street + self.number)\n        if self.street.isEmpty || self.number.isEmpty &#123;\n            let detailAddress = reGeocode?.formattedAddress ?? &quot;&quot;\n            self.address = abbreviationAddressIn(detailAddress: detailAddress, province: province, city: city, district: district)\n        &#125;\n        \n        self.distance = 0\n    &#125;\n    \n    /// 模型转换 根据 [搜索&#123;附近|关键词&#125;]获取的 POI模型\n    convenience init(mapPOI: AMapPOI) &#123;\n        self.init()\n        \n        if let location = mapPOI.location &#123;\n            let latitude = location.latitude\n            let longitude = location.longitude\n            self.coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n        &#125;\n        \n        self.poiName = mapPOI.name\n        self.province = mapPOI.province\n        self.city = mapPOI.city\n        self.district = mapPOI.district\n        self.street = &quot;&quot;\n        self.number = &quot;&quot;\n        self.address = mapPOI.address\n        \n        self.distance = mapPOI.distance // 周边搜索可用\n    &#125;\n    \n    /// 模型转换 根据 [逆地理编码]获取的 经纬度 &amp; 逆地理编码结果\n    convenience init(location: AMapGeoPoint, reGeocode: AMapReGeocode) &#123;\n        self.init()\n        \n        let addressComponent = reGeocode.addressComponent\n        \n        let latitude = location.latitude\n        let longitude = location.longitude\n        self.coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n        \n        if let aoisName = reGeocode.aois.first?.name &#123;\n            self.poiName = aoisName\n        &#125; else if let roadinterName = reGeocode.roadinters.first?.firstName &#123;\n            self.poiName = roadinterName\n        &#125; else &#123;\n            self.poiName = addressComponent?.township ?? &quot;&quot;\n        &#125;\n        self.province = addressComponent?.province ?? &quot;&quot;\n        self.city = addressComponent?.city ?? &quot;&quot;\n        self.district = addressComponent?.district ?? &quot;&quot;\n        self.street = addressComponent?.streetNumber?.street ?? &quot;&quot;\n        self.number = addressComponent?.streetNumber?.number ?? &quot;&quot;\n        self.address = (self.street + self.number)\n        if self.street.isEmpty || self.number.isEmpty &#123;\n            let detailAddress = reGeocode.formattedAddress ?? &quot;&quot;\n            self.address = abbreviationAddressIn(detailAddress: detailAddress, province: province, city: city, district: district)\n        &#125;\n        self.distance = 0\n    &#125;\n    \n    /// 详细地址中获取缩略地址\n    /// - Parameters:\n    ///   - detailAddress: 详细地址\n    ///   - province: 省份\n    ///   - city: 城市\n    ///   - district: 区域\n    private func abbreviationAddressIn(detailAddress: String, province: String, city: String, district: String) -&gt; String &#123;\n        var address = detailAddress\n        address = address.replacingOccurrences(of: province, with: &quot;&quot;)\n        address = address.replacingOccurrences(of: city, with: &quot;&quot;)\n        address = address.replacingOccurrences(of: city, with: &quot;&quot;)\n        return address\n    &#125;\n    \n    // ------------------------- model 转换 -------------------------\n    \n    /// 模型转换 根据 地理信息结果模型\n    convenience init(locationResult: GMLocationPickerLocationResult) &#123;\n        self.init()\n        \n        self.coordinate = locationResult.coordinate\n        \n        self.poiName = locationResult.poiName\n        self.province = locationResult.province\n        self.city = locationResult.city\n        self.district = locationResult.district\n        let street = locationResult.township\n        self.address = street\n        \n        self.distance = 0\n    &#125;\n    \n    /// 模型转换 根据 仓库模型\n    convenience init(warehouseInfo: GMWarehouseInfoHomeList) &#123;\n        self.init()\n        \n        self.coordinate = warehouseInfo.cus_coordinate\n        \n        self.poiName = warehouseInfo.name\n        self.province = warehouseInfo.province\n        self.city = warehouseInfo.city\n        self.district = warehouseInfo.region\n        self.street = &quot;&quot;\n        self.number = &quot;&quot;\n        self.address = warehouseInfo.address\n        \n        self.distance = 0\n    &#125;\n    \n    /// 模型转换 根据 门店模型\n    convenience init(storeInfo: GMStoreInfoHomeModel) &#123;\n        self.init()\n        \n        self.coordinate = storeInfo.cus_coordinate\n        \n        self.poiName = storeInfo.shopName\n        self.province = storeInfo.shopProvince\n        self.city = storeInfo.shopCity\n        self.district = storeInfo.shopCounty\n        self.street = storeInfo.shopStreet\n        self.number = &quot;&quot;\n        self.address = storeInfo.shopAddress\n        \n        self.distance = 0\n    &#125;\n&#125;\n</code></pre>\n<p>这个是地图内部使用，上面那个实体，是为了更好对接服务端设定的一个实体。</p>\n<h3 id=\"4-2-外部类定义\"><a href=\"#4-2-外部类定义\" class=\"headerlink\" title=\"4.2 外部类定义\"></a>4.2 外部类定义</h3><pre><code class=\"line-numbers language-Swift\">/// 地图选择 闭包，向外吐出去\ntypealias GMLocationResultHandler = (GMLocationPickerLocationResult?) -&gt; Swift.Void\n\nprotocol GMLocationPickerControllerDelegate: AnyObject &#123;\n    /// 提交所选位置\n    func locationPickerController(_ collection: GMLocationPickerController, didSubmit locationInfo: GMLocationPickerLocationResult)\n    \n    /// 页面将要pop出\n    func locationPickerControllerWillPop(_ collection: GMLocationPickerController)\n&#125;\n\n/// 从哪里进来的 枚举类\nenum GMLocationPickerFor &#123;\n    case warehouseCreate                                        // 仓库创建\n    case warehouseEdit(warehouseInfo: GMWarehouseInfoHomeList)  // 仓库编辑\n    case storeEdit(storeInfo: GMStoreInfoHomeModel)             // 门店编辑\n&#125;\n\n/// 选择地理位置的原因 什么时候走高德接口\nenum GMLocationPickerRegionChageFor &#123;\n    case located                                                // 实时定位\n    case itemSelected                                           // 搜索项选择\n    case keywordSearchSelected                                  // 关键词搜索 自动选择(第一个)\n    case slideByCustomer                                        // 用户滑动逆地理\n&#125;\n</code></pre>\n<p>这里定义了可能需要的枚举类和协议。<br>枚举类主要跟我们自己业务有关系了，协议也是跟业务有关系。这里并不是实现地图的必须。</p>\n<h3 id=\"4-3-UI声明\"><a href=\"#4-3-UI声明\" class=\"headerlink\" title=\"4.3 UI声明\"></a>4.3 UI声明</h3><pre><code class=\"line-numbers language-Swift\">class GMLocationPickerController: GMBaseViewController &#123;\n\n    //MARK: - property\n    \n    // UI\n    \n    private weak var btn_submit: UIButton!                      // 提交按钮\n    private weak var mapView: MAMapView!                        // 地图\n    private weak var textF_search: UITextField!                 // 搜索 输入栏\n    private weak var tableView: TYTableView!                    // 搜索 列表\n    private weak var ai_spinner: UIActivityIndicatorView!       // 加载loading\n    private weak var btn_located: UIButton!                     // 定位按钮\n    \n    private weak var imgV_pointAnnotation: UIImageView!         // 自定义大头针\n</code></pre>\n<p>这里声明了实现地图用到的一些材料，当然最关键的是MAMapView了，这个View是高德提供的哦。</p>\n<h3 id=\"4-4-数据声明\"><a href=\"#4-4-数据声明\" class=\"headerlink\" title=\"4.4 数据声明\"></a>4.4 数据声明</h3><pre><code class=\"line-numbers language-Swift\">// Data\nvar navTitle: String?                                       // Nav标题 (可选)\nweak var delegate: GMLocationPickerControllerDelegate?      // 代理\nvar locationResultBlock: GMLocationResultHandler?\n\nprivate var locationInfos = [GMLocationPickerLocationInfo]()// 搜索 地点信息\nprivate var selectingLocationInfo: GMLocationPickerLocationInfo? // 选中地点信息\n\n// Pre Data\n\nvar preLocationInfo: GMLocationPickerLocationInfo?          // 预地理位置信息\nvar preCoordinate: CLLocationCoordinate2D?                  // 预经纬度\nvar preKeyword: String?                                     // 预搜索关键词\nvar pickerFor: GMLocationPickerFor = .warehouseCreate       // 地图选择用于\n</code></pre>\n<p>这里大致列举了需要用的数据。<br>预数据，就是外部传过来的数据，然后我们新建了两个info实体报错搜索的地址和选中的地址。</p>\n<h3 id=\"4-5-其它成员声明\"><a href=\"#4-5-其它成员声明\" class=\"headerlink\" title=\"4.5 其它成员声明\"></a>4.5 其它成员声明</h3><pre><code class=\"line-numbers language-Swift\">// Tool\nprivate var search: AMapSearchAPI!                          // 地图 搜索功能\nprivate var locationManager: AMapLocationManager!           // 地图 定位功能\nprivate var authorizationManager = TYLocationAuthorization()// 权限管理\n\n// flag\n\nprivate var lastSearchKey = &quot;&quot;                              // 最后搜索字段\nprivate var isRegionChangedFromCustomer = false             // 地图领域变化原因为用户手动滑动\nprivate var isReGeoRequestForSubmit = false                 // 逆地理请求用于提交\nprivate var viewDidAppear = false  \n</code></pre>\n<p>这里是一些工具和一些flag变量，工具包含地图搜索接口和地图定位功能工具，这些都是高德提供，另外权限是自定义的一个工具来处理的。</p>\n<h3 id=\"4-6-生命周期之viewDidLoad\"><a href=\"#4-6-生命周期之viewDidLoad\" class=\"headerlink\" title=\"4.6 生命周期之viewDidLoad\"></a>4.6 生命周期之viewDidLoad</h3><p>这个走一次，看下做了什么：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        self.layoutSubviews()\n        self.loadData()\n    &#125;\n</code></pre>\n<p>加载了子View，然后去加载数据。</p>\n<pre><code class=\"line-numbers language-Swift\">private func layoutSubviews() &#123;\n        \n        self.view.backgroundColor = .white\n        \n        // ------------------------- 导航栏 -------------------------\n        let submitBtnF: UIFont = .pingFangRegular(size: 16.0)\n        \n        let btn_submit = UIButton()\n        btn_submit.isEnabled = false\n        btn_submit.ty_setButtonWith(text: &quot;提交&quot;, font: submitBtnF, color: .ty_409EFF, state: .normal)\n        btn_submit.ty_setButtonWith(text: &quot;提交&quot;, font: submitBtnF, color: .ty_409EFF.alpha(0.5), state: .disabled)\n        btn_submit.addTarget(self, action: #selector(act_submitBtnClicked(button:)), for: .touchUpInside)\n        let item_submit = UIBarButtonItem(customView: btn_submit)\n        self.navigationItem.rightBarButtonItem = item_submit\n        self.btn_submit = btn_submit\n        \n        // ------------------------- 底部控件 -------------------------\n        let searchListBGW: CGFloat = yScreenWidth\n        let searchListBGH: CGFloat = 104.0\n        let searchListBGR = CGRect(x: 0, y: 0, width: searchListBGW, height: searchListBGH)\n        let searchListBGRadius = 16.0\n        let searchListBGRadiusS = CGSize(width: searchListBGRadius, height: searchListBGRadius)\n        \n        let view_searchListBG = UIView.ty_viewWith(bgColor: .ty_ThemeWhite)\n        view_searchListBG.ty_setCornerWith(rect: searchListBGR, corners: [.topLeft, .topRight], radii: searchListBGRadiusS)\n        self.view.addSubview(view_searchListBG)\n        view_searchListBG.snp.makeConstraints &#123; make in\n            make.bottom.equalTo(self.view.snp.bottom)\n            make.centerX.equalTo(self.view)\n            make.width.equalTo(searchListBGW)\n            make.height.equalTo(searchListBGH)\n        &#125;\n        \n        // 搜索栏\n        let searchBtnF: UIFont = .pingFangRegular(size: 14.0)\n        let searchBtnW: CGFloat = 80.0\n        let searchBtnH: CGFloat = 32.0\n        let searchBarTextFF: UIFont = .pingFangRegular(size: 14.0)\n        let searchBarTextFLeftImageS = CGSize(width: 16.0, height: 16.0)\n        let searchBarTextFLeftViewS = CGSize(width: 32.0, height: 32.0)\n        let searchBarTextFR: CGFloat = 10.0\n        let searchBarTextFH: CGFloat = searchBtnH\n        \n        // 搜索按钮\n        let btn_search = UIButton()\n        btn_search.ty_setButtonWith(text: &quot;搜索&quot;, font: searchBtnF, color: .ty_TextWhite, state: .normal)\n        btn_search.ty_setBackgroundColor(.ty_409EFF, state: .normal)\n        btn_search.ty_setCornerRadius(searchBtnH/2.0)\n        btn_search.addTarget(self, action: #selector(act_searchBtnClicked(button:)), for: .touchUpInside)\n        \n        view_searchListBG.addSubview(btn_search)\n        btn_search.snp.makeConstraints &#123; make in\n            make.top.equalTo(view_searchListBG).offset(ySuperVerPad)\n            make.right.equalTo(view_searchListBG).offset(-ySuperHorPad)\n            make.width.equalTo(searchBtnW)\n            make.height.equalTo(searchBtnH)\n        &#125;\n        \n        // 搜索栏\n        let textF_search = UITextField.ty_textFieldWith(font: searchBarTextFF, color: .ty_222222)\n        textF_search.backgroundColor = .ty_F7F9FA\n        textF_search.ty_setPlaceholderWith(placeholder: &quot;请输入地址&quot;, color: .ty_9B9DA7, font: searchBarTextFF)\n        textF_search.ty_setLeftPaddingImage(imageName: &quot;locationPicker_img_search&quot;, imageSize: searchBarTextFLeftImageS, paddingSize: searchBarTextFLeftViewS)\n        textF_search.ty_setCornerRadius(searchBarTextFH/2.0)\n        \n        textF_search.addTarget(self, action: #selector(act_searchTextFEditChange(textF:)), for: .editingChanged)\n        textF_search.addObserver(self, forKeyPath: &quot;text&quot;, options: [.new, .old], context: nil)\n        \n        textF_search.delegate = self\n        textF_search.returnKeyType = .search\n        \n        view_searchListBG.addSubview(textF_search)\n        self.textF_search = textF_search\n        textF_search.snp.makeConstraints &#123; make in\n            make.top.equalTo(view_searchListBG).offset(ySuperVerPad)\n            make.left.equalTo(view_searchListBG).offset(ySuperHorPad)\n            make.right.equalTo(btn_search.snp.left).offset(-searchBarTextFR)\n            make.height.equalTo(searchBarTextFH)\n        &#125;\n        \n        // TableView\n        let tableViewT: CGFloat = 6.0\n        \n        let tableView = TYTableView(delegate: self, dataSource: self, style: .plain)\n        tableView.showsVerticalScrollIndicator = false\n        view_searchListBG.addSubview(tableView)\n        self.tableView = tableView\n        tableView.snp.makeConstraints &#123; make in\n            make.top.equalTo(textF_search.snp.bottom).offset(tableViewT)\n            make.left.equalTo(view_searchListBG)\n            make.right.equalTo(view_searchListBG)\n            make.bottom.equalTo(view_searchListBG)\n        &#125;\n        \n        // loading 旋转图\n        let indicatorStyle: UIActivityIndicatorView.Style\n        if #available(iOS 13.0, * ) &#123;\n            indicatorStyle = .medium\n        &#125; else &#123;\n            indicatorStyle = .gray\n        &#125;\n        let ai_spinner = UIActivityIndicatorView(style: indicatorStyle)\n        ai_spinner.startAnimating()\n        view_searchListBG.addSubview(ai_spinner)\n        self.ai_spinner = ai_spinner\n        ai_spinner.snp.makeConstraints &#123; make in\n            make.center.equalTo(view_searchListBG)\n        &#125;\n        \n        // ------------------------- mapView -------------------------\n        let mapViewW: CGFloat = yScreenWidth\n        let mapViewH: CGFloat = yScreenHeight - searchListBGH + searchListBGRadius/2.0\n        let cus_mapViewR = CGRect(x: 0, y: 0, width: mapViewW, height: mapViewH)\n        \n        // MapView\n        let mapView = MAMapView(frame: cus_mapViewR)\n        mapView.zoomLevel = 13.0                // 缩放比例\n        mapView.showsCompass = false            // 显示罗盘\n        mapView.showsScale = false              // 显示比例尺\n        mapView.delegate = self\n        self.view.addSubview(mapView)\n        self.mapView = mapView\n        \n        // 大头针\n        let pointAnnotationImgVW: CGFloat = 40.0\n        let pointAnnotationImgVH: CGFloat = 40.0\n        let imgV_pointAnnotation = UIImageView.ty_imageViewWith(imageName: &quot;locationPicker_icon_point_annotation&quot;)\n        self.view.addSubview(imgV_pointAnnotation)\n        self.imgV_pointAnnotation = imgV_pointAnnotation\n        imgV_pointAnnotation.snp.makeConstraints &#123; make in\n            make.centerX.equalTo(mapView)\n            make.centerY.equalTo(mapView).offset(-pointAnnotationImgVH/2.0)\n            make.width.equalTo(pointAnnotationImgVW)\n            make.height.equalTo(pointAnnotationImgVH)\n        &#125;\n        \n        // 回归定位按钮\n        let locatedBtnWH: CGFloat = 46.0\n        let locatedBtnR: CGFloat = 9.0\n        let locatedBtnB: CGFloat = 9.0\n        \n        let btn_located = UIButton()\n        btn_located.setImage(UIImage(named: &quot;locationPicker_btn_located_Blue&quot;), for: .selected)     // 在当前定位\n        btn_located.setImage(UIImage(named: &quot;locationPicker_btn_located_Black&quot;), for: .normal)      // 不在当前定位\n        btn_located.addTarget(self, action: #selector(act_locatedBtnClicked(button:)), for: .touchUpInside)\n        self.view.addSubview(btn_located)\n        self.btn_located = btn_located\n        btn_located.snp.makeConstraints &#123; make in\n            make.right.equalTo(self.view).offset(-locatedBtnR)\n            make.bottom.equalTo(view_searchListBG.snp.top).offset(-locatedBtnB)\n            make.width.equalTo(locatedBtnWH)\n            make.height.equalTo(locatedBtnWH)\n        &#125;\n        \n        self.view.bringSubviewToFront(view_searchListBG)\n    &#125;\n</code></pre>\n<p>逻辑也是非常清晰，一个一个把视图堆叠进去了。<br>这里大头针跟地图一点关系没有，这个只是把大头针放在中间而已。没有跟地图绑定任何关系。</p>\n<p>然后去加载数据：</p>\n<pre><code class=\"line-numbers language-Swift\">private func loadData() &#123;\n    // 设置标题\n    if let navTitle = self.navTitle, !navTitle.isEmpty &#123;\n        self.title = &quot;\\(navTitle) 地图定位&quot;\n    &#125; else &#123;\n        self.title = &quot;地图定位&quot;\n    &#125;\n    \n    // 定位功能\n    // 更新App是否显示隐私弹窗的状态，隐私弹窗是否包含高德SDK隐私协议内容的状态\n    AMapLocationManager.updatePrivacyShow(.didShow, privacyInfo: .didContain)\n    // 更新用户授权高德SDK隐私协议状态\n    AMapLocationManager.updatePrivacyAgree(.didAgree)\n    let locationManager = AMapLocationManager()\n    locationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters\n    if #available(iOS 14.0, *) &#123;\n        locationManager.locationAccuracyMode = .fullAccuracy\n    &#125;\n    self.locationManager = locationManager\n    \n    // 搜索\n    let search = AMapSearchAPI()\n    search?.timeout = 10\n    search?.delegate = self\n    self.search = search\n    \n    // 预地理位置信息处理\n    self.data_preLocatedHandle(locationInfo: self.preLocationInfo,\n                                preCoordinate: self.preCoordinate,\n                                preKeyword: self.preKeyword)\n&#125;\n</code></pre>\n<p>这里设置了标题，然后就去走预地理位置信息处理的方法。这里的pre相关的数据，在跳转前，就给这个controller赋值了，这里跟Android不太一样，Android还要通过intent来传，它这个居然可以直接用controller的实例传值。</p>\n<p>具体预制方法为：</p>\n<pre><code class=\"line-numbers language-Swift\">/// 根据预地理位置信息 按照优先级 决定预定位方式\nfunc data_preLocatedHandle(locationInfo: GMLocationPickerLocationInfo? = nil,\n                            preCoordinate: CLLocationCoordinate2D? = nil, preKeyword: String? = nil) &#123;\n    \n    // 预定位处理规则\n    // 完整数据 - 经纬度 - 位置关键词 - 实时定位 - 默认&#39;北京&#39;定位\n    if let preLocationInfo = locationInfo &#123;\n        // 1.完整信息\n        if let coordinate = preLocationInfo.coordinate,\n            coordinate.latitude != 0, coordinate.longitude != 0 &#123;\n            // 1.1 经纬度信息完整\n            self.data_changeRegionTo(preLocationInfo, for: .itemSelected)\n            self.map_searchLocationForNearby()  // 搜索附近\n        &#125; else if !preLocationInfo.address.isEmpty &#123;\n            // 1.2 无经纬度、有地名：搜索地名\n            let searchKey = &quot;\\(preLocationInfo.city)\\(preLocationInfo.district)\\(preLocationInfo.address)&quot;\n            self.data_preLocatedHandle(preKeyword: searchKey)\n        &#125; else &#123;\n            // 1.3 都没有：默认操作\n            self.data_preLocatedHandle()\n        &#125;\n    &#125; else if let preCoordinate = preCoordinate &#123;\n        // 2.显示经纬度位置\n        self.mapView.centerCoordinate = preCoordinate\n        self.map_searchLocationForReGeo(isForSubmit: false) // 搜索逆地理编码\n    &#125; else if let preKeyword = preKeyword, preKeyword.count &gt; 0 &#123;\n        // 3.关键词配置\n        self.textF_search.text = preKeyword\n        self.act_searchBtnClicked(button: nil)\n    &#125; else &#123;\n        var isLocationEnable = self.authorizationManager.isLocationAuthroizationEnable()\n        if #available(iOS 14.0, *) &#123;\n            isLocationEnable = isLocationEnable &amp;&amp; self.authorizationManager.isAccuracyAuthorizationFull()\n        &#125;\n        if isLocationEnable &#123;\n            // 4.实时定位\n            self.act_locatedBtnClicked(button: nil)\n        &#125; else &#123;\n            // 5.默认北京\n            self.mapView.centerCoordinate = CLLocationCoordinate2D(latitude: 39.909115, longitude: 116.397535)\n            self.map_searchLocationForReGeo(isForSubmit: false) // 搜索逆地理编码\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里就是一段逻辑，如果之前有地址，然后如何去显示的逻辑。如何去移动地图。<br>主要是用了一个 self.mapView.centerCoordinate来设置地图中心坐标，然后这里调用搜索词是走了这个方法：</p>\n<pre><code class=\"line-numbers language-Swift\">/// 根据当前地图中间位置 搜索逆地理\n/// - Parameter isForSubmit: 用于提交 or 用户滑动地理获取(顺带搜索附近)\nprivate func map_searchLocationForReGeo(isForSubmit: Bool) &#123;\n    self.isReGeoRequestForSubmit = isForSubmit\n    if isForSubmit &#123;\n        self.ty_showLoadingHUD()\n    &#125; else &#123;\n        // 清空列表数据\n        self.data_reloadTableViewToEmpty(forRequest: true)\n    &#125;\n    \n    // 取消上一个请求\n    self.search.cancelAllRequests()\n    \n    // 逆地理位置请求\n    let coordinate = self.mapView.centerCoordinate\n    let regeo = AMapReGeocodeSearchRequest()\n    regeo.location = AMapGeoPoint.location(withLatitude: coordinate.latitude, longitude: coordinate.longitude)\n    regeo.requireExtension = true\n    self.search.aMapReGoecodeSearch(regeo)\n&#125;\n</code></pre>\n<p>这里根据地图中心位置调用了搜索接口,具体请求在这里：</p>\n<pre><code class=\"line-numbers language-Swift\">self.search.aMapReGoecodeSearch(regeo)\n</code></pre>\n<p>如何搜索附近地址呢？</p>\n<pre><code class=\"line-numbers language-Swift\">/// 根据选中位置 搜索附近POI\nprivate func map_searchLocationForNearby() &#123;\n    guard let coordinate = self.selectingLocationInfo?.coordinate else &#123; return &#125;\n    // 清空列表数据\n    self.data_reloadTableViewToEmpty(forRequest: true)\n    \n    // 取消上一个请求\n    self.search.cancelAllRequests()\n    \n    // 附近搜索请求\n    let aroundRequest = AMapPOIAroundSearchRequest()\n    let geoPoint = AMapGeoPoint.location(withLatitude: coordinate.latitude,\n                                            longitude: coordinate.longitude)\n    aroundRequest.location = geoPoint\n//        aroundRequest.special = true\n    self.search.aMapPOIAroundSearch(aroundRequest)\n&#125;\n</code></pre>\n<p>跟上面方法也比较类似。</p>\n<h3 id=\"4-7-生命周期之viewWillAppear\"><a href=\"#4-7-生命周期之viewWillAppear\" class=\"headerlink\" title=\"4.7 生命周期之viewWillAppear\"></a>4.7 生命周期之viewWillAppear</h3><pre><code class=\"line-numbers language-Swift\">override func viewWillAppear(_ animated: Bool) &#123;\n        super.viewWillAppear(animated)\n        setupWhiteNavBarColor()\n        setupWhiteClickCallBack()\n        \n        isHiddenNavBar(isHidden: false)\n    &#125;\n</code></pre>\n<p>主要处理了导航栏相关的。</p>\n<h3 id=\"4-8-生命周期之viewDidAppear\"><a href=\"#4-8-生命周期之viewDidAppear\" class=\"headerlink\" title=\"4.8 生命周期之viewDidAppear\"></a>4.8 生命周期之viewDidAppear</h3><pre><code class=\"line-numbers language-Swift\">override func viewDidAppear(_ animated: Bool) &#123;\n        super.viewDidAppear(animated)\n        self.viewDidAppear = true\n    &#125;\n</code></pre>\n<p>这里没干啥，就设置了一个flag。</p>\n<h3 id=\"4-9-析构函数\"><a href=\"#4-9-析构函数\" class=\"headerlink\" title=\"4.9 析构函数\"></a>4.9 析构函数</h3><pre><code class=\"line-numbers language-Swift\">deinit &#123;\n        self.tydev_logDeinit()\n    &#125;\n</code></pre>\n<p>这里也没干啥，打印下日志：</p>\n<pre><code class=\"line-numbers language-Swift\">/// 输出对象销毁日志\nfunc tydev_logDeinit() &#123;\n    self.tydev_logDeinit(nil)\n&#125;\n\n/// 输出对象销毁日志\n/// - Parameter mark: 自定义标识\nfunc tydev_logDeinit(_ mark: String?) &#123;\n    if let mark = mark &#123;\n        print(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; deinit view [\\(self)] (\\(mark) &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;)\n    &#125; else &#123;\n        print(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; deinit view [\\(self)] &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;)\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"4-10-地图代理\"><a href=\"#4-10-地图代理\" class=\"headerlink\" title=\"4.10 地图代理\"></a>4.10 地图代理</h3><p>前面我们设置了代理为自己，需要处理下：</p>\n<pre><code class=\"line-numbers language-Swift\">// 地图Delegate - Map\nextension GMLocationPickerController : MAMapViewDelegate &#123;\n    \n    /// 地图区域改变完成后会调用此接口\n    func mapView(_ mapView: MAMapView!, regionDidChangeAnimated animated: Bool) &#123;\n        if !self.viewDidAppear &#123; return &#125;\n        \n        // 大头针动画\n        self.ui_pointAnnotationAnimate()\n        if self.isRegionChangedFromCustomer, self.mapView.userTrackingMode == .none &#123;\n            // 用户手动滑动模式\n            // 搜索逆地理编码(顺带搜索附近)\n            self.map_searchLocationForReGeo(isForSubmit: false)\n        &#125;\n        self.isRegionChangedFromCustomer = true\n    &#125;\n&#125;\n</code></pre>\n<p>这里是高德自己调用的，估计是滑动后区域改变，这里会走。<br>这里我们走完后需要顺带搜索下附近地址，所以需要加上我们自己逻辑哦。</p>\n<h3 id=\"4-11-搜索代理\"><a href=\"#4-11-搜索代理\" class=\"headerlink\" title=\"4.11 搜索代理\"></a>4.11 搜索代理</h3><pre><code class=\"line-numbers language-Swift\">// 地图Delegate - Search\nextension GMLocationPickerController : AMapSearchDelegate &#123;\n    /// POI查询回调函数 [定位获取附近POI、搜索POI]\n    func onPOISearchDone(_ request: AMapPOISearchBaseRequest!, response: AMapPOISearchResponse!) &#123;\n//        if response.pois.count &lt;= 0 &#123;\n//            GMBannerTips.showWarningTips(&quot;没有找到定位&quot;)\n//            data_reloadTableViewToEmpty(forRequest: false)\n//            return\n//        &#125;\n        \n        let prefixPois = response.pois.prefix(20)     // 最多获取20个数据\n        var locationInfos = prefixPois.map(&#123; GMLocationPickerLocationInfo(mapPOI: $0) &#125;)\n        \n        if request.isKind(of: AMapPOIKeywordsSearchRequest.self) &#123;\n            // 1. 搜索关键词(搜索关键词)\n            \n            // 没有搜索到则提示\n            if response.pois.count &lt;= 0 &#123;\n                GMBannerTips.showWarningTips(&quot;没有找到定位&quot;)\n                data_reloadTableViewToEmpty(forRequest: false)\n                return\n            &#125;\n            \n            // 自动选择第一个位置\n            var selectingInfo = self.selectingLocationInfo\n            if let firstInfo = locationInfos.first &#123;\n                selectingInfo = firstInfo\n                // 移动地图位置\n                self.data_changeRegionTo(firstInfo, for: .keywordSearchSelected)\n            &#125;\n            // 搜索POI距离补全\n            if let selectingInfo = selectingInfo, let selectingCoordinate = selectingInfo.coordinate &#123;\n                let selectingPoint = MAMapPointForCoordinate(selectingCoordinate)\n                for currLocationInfo in locationInfos &#123;\n                    if selectingInfo == currLocationInfo &#123; continue &#125;\n                    if let currCoordinate = currLocationInfo.coordinate &#123;\n                        let currPoint = MAMapPointForCoordinate(currCoordinate)\n                        currLocationInfo.distance = Int(MAMetersBetweenMapPoints(selectingPoint,currPoint))\n                    &#125;\n                &#125;\n            &#125;\n            \n        &#125; else if request.isKind(of: AMapPOIAroundSearchRequest.self) &#123;\n            // 2. 搜索附近位置(定位or选中)\n            \n            // 没有找到定位 则选中当前选中的定位\n            if prefixPois.count &lt;= 0, let selectingInfo = self.selectingLocationInfo &#123;\n                locationInfos.insert(selectingInfo, at: 0)\n            &#125;\n            \n            // 则确保第一个选项为当前地理位置（不匹配则手动添加）\n            if let firstInfo = locationInfos.first, let selectingInfo = self.selectingLocationInfo,\n               firstInfo.poiName != selectingInfo.poiName, firstInfo.address != selectingInfo.address &#123;\n                // 当前第一个位置 非选中中位置\n                locationInfos.insert(selectingInfo, at: 0)\n            &#125;\n            if let firstInfo = locationInfos.first &#123;\n                // 纠正/同步选择中地理位置\n                self.selectingLocationInfo = firstInfo\n            &#125;\n        &#125;\n        \n        // 刷新TableView数据\n        self.data_reloadTableViewWith(locationInfos: locationInfos)\n    &#125;\n    \n    /// 逆地理编码回调 [手动滑动地图时用]\n    func onReGeocodeSearchDone(_ request: AMapReGeocodeSearchRequest!, response: AMapReGeocodeSearchResponse!) &#123;\n        if self.isReGeoRequestForSubmit &#123;\n            // 1. 用于提交的逆地理编码搜索\n            self.ty_hideLoadingHUD()\n            self.isReGeoRequestForSubmit = false\n            \n            guard let location = request.location, let regeocode = response.regeocode else &#123; return &#125;\n            \n            self.view.endEditing(true)\n            let selectingInfo = GMLocationPickerLocationResult(location: location, reGeocode: regeocode, locationInfo: self.selectingLocationInfo)\n            \n            // 提交地址\n            self.delegate?.locationPickerController(self, didSubmit: selectingInfo)\n            locationResultBlock?(selectingInfo)\n            self.popViewController()\n        &#125; else &#123;\n            // 2. 用于用户滑动的逆地理编码搜索\n            guard let location = request.location, let regeocode = response.regeocode else &#123; return &#125;\n            \n            // 设置 locationInfos\n            let prefixPois = regeocode.pois.prefix(20)     // 最多获取20个数据\n            var locationInfos = prefixPois.map(&#123; GMLocationPickerLocationInfo(mapPOI: $0) &#125;)\n            \n            let selectingInfo = GMLocationPickerLocationInfo(location: location, reGeocode: regeocode)\n            // 移动地图位置\n            self.data_changeRegionTo(selectingInfo, for: .slideByCustomer)\n            locationInfos.insert(selectingInfo, at: 0)\n            \n            // 刷新TableView数据\n            self.data_reloadTableViewWith(locationInfos: locationInfos)\n        &#125;\n    &#125;\n    \n    /// 当请求发生错误 (timeout)\n    func aMapSearchRequest(_ request: Any!, didFailWithError error: Error!) &#123;\n        let errorCode = error._code\n        \n        var errMsg = &quot;&quot;\n        if let searchErrorCode = AMapSearchErrorCode(rawValue: errorCode) &#123;\n            switch searchErrorCode &#123;\n            case .notConnectedToInternet:   break// 网络连接异常\n                //errMsg = AMapSearchError.errorInfo(with: searchErrorCode)\n            default:\n                break\n            &#125;\n        &#125; else &#123;\n            print(&quot;asdf&quot;)\n        &#125;\n        if !errMsg.isEmpty &#123;\n            self.ty_showMsgHud(errMsg)\n        &#125;\n    &#125;\n    \n&#125;\n</code></pre>\n<p>这里是高德提供的搜索代理。<br>一个是手动滑动，一个是自行搜索，走接口不一样哦。</p>\n<h3 id=\"4-12-其它代理\"><a href=\"#4-12-其它代理\" class=\"headerlink\" title=\"4.12 其它代理\"></a>4.12 其它代理</h3><pre><code class=\"line-numbers language-Swift\">\n// TableView Delegate\nextension GMLocationPickerController: UITableViewDelegate, UITableViewDataSource &#123;\n    \n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n        return self.locationInfos.count\n    &#125;\n\n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n        let cell = GMLocationPickerCell.cellWithTableView(tableView)\n        cell.locationInfo = self.locationInfos[indexPath.row]\n        return cell\n    &#125;\n    \n    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n        return GMLocationPickerCell.cellHeight()\n    &#125;\n    \n    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123;\n        let locationInfo = self.locationInfos[indexPath.row]\n        // 清除搜索栏内容\n        self.ui_clearSearchTextF()\n        // 移动地图位置\n        self.data_changeRegionTo(locationInfo, for: .itemSelected)\n        // 搜索附近\n        self.map_searchLocationForNearby()\n    &#125;\n&#125;\n\n// 输入框 &amp; 自定义 Delegate\nextension GMLocationPickerController : UITextFieldDelegate\n&#123;\n    func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool &#123;\n        // 搜索\n        self.act_searchBtnClicked(button: nil)\n        return true\n    &#125;\n&#125;\n</code></pre>\n<p>这里还用了2个代理，一个是搜索列表的tableView的列表展示，一个是搜索框代理。</p>\n<h3 id=\"4-13-如何定位\"><a href=\"#4-13-如何定位\" class=\"headerlink\" title=\"4.13 如何定位\"></a>4.13 如何定位</h3><pre><code class=\"line-numbers language-Swift\">/// 定位当前位置\nprivate func map_requestLocation(_ completion: ((CLLocation?, AMapLocationReGeocode?) -&gt; ())?) &#123;\n    // 定位请求\n    func requestLocation(_ completion: ((CLLocation?, AMapLocationReGeocode?) -&gt; ())?) &#123;\n        // 单次定位\n        self.locationManager.requestLocation(withReGeocode: true, completionBlock: &#123; (location: CLLocation?, reGeocode: AMapLocationReGeocode?, error: Error?) in\n            // 定位回调\n            if let completion = completion &#123; completion(location, reGeocode) &#125;\n        &#125;)\n    &#125;\n    \n    let manager = self.authorizationManager\n    manager.verifyLocationAuthroization(showAlertIn: self, completion: &#123;\n        if #available(iOS 14.0, *) &#123;\n            manager.verifyAccuracyAuthroization(completion: &#123;\n                requestLocation(completion)\n            &#125;, failure: nil)\n        &#125; else &#123;\n            requestLocation(completion)\n        &#125;\n    &#125;, failure: nil)\n&#125;\n</code></pre>\n<p>别慌，高德也是提供了方法，支持去定位。</p>\n<h3 id=\"4-14-地址权限工具\"><a href=\"#4-14-地址权限工具\" class=\"headerlink\" title=\"4.14 地址权限工具\"></a>4.14 地址权限工具</h3><pre><code class=\"line-numbers language-Swift\">/// 地址权限管理器 配置\nclass TYLocationAuthorizationConfig: NSObject &#123;\n    \n    // info.plist 上配置的 精读权限获取描述\n    // &lt;key&gt;NSLocationTemporaryUsageDescriptionDictionary&lt;/key&gt;\n    var accuracyPurposeKey = &quot;AccuracyUsageDescription&quot;\n    \n    var locationAlertTitle = &quot;您需要开启GPS权限&quot;\n    var locationAlertMessage = &quot;地图定位需要获取您的GPS权限才能正常使用&quot;\n&#125;\n\n/// 地址权限管理器\nclass TYLocationAuthorization: NSObject &#123;\n    \n    //MARK: - property\n    \n    // Data\n    \n    private var locationManager: CLLocationManager!             // 定位权限管理\n    \n    private var locationAuthVerifyCompletion: (() -&gt; ())?       // 定位权限获取完成Block (用于权限首次询问)\n    private var locationAuthVerifyFailure: (() -&gt; ())?          // 定位权限获取失败Block (用于权限首次请求)\n    \n    private var config = TYLocationAuthorizationConfig()              // 文本相关配置\n    \n    // State\n    \n    /// 定位权限状态\n    var locationAuthorization: CLAuthorizationStatus &#123;\n        if #available(iOS 14.0, *) &#123;\n            return self.locationManager.authorizationStatus\n        &#125; else &#123;\n            return CLLocationManager.authorizationStatus()\n        &#125;\n    &#125;\n    \n    /// 精读权限状态\n    @available(iOS 14.0, *)\n    var accuracyAuthorization: CLAccuracyAuthorization &#123;\n        return self.locationManager.accuracyAuthorization\n    &#125;\n    \n    \n    //MARK: - life cycle\n    \n    convenience init(config: TYLocationAuthorizationConfig) &#123;\n        self.init()\n        self.config = config\n    &#125;\n    \n    override init() &#123;\n        super.init()\n        self.loadData()\n    &#125;\n    \n    private func loadData() &#123;\n        // 定位权限管理\n        let locationManager = CLLocationManager()\n        locationManager.delegate = self\n        self.locationManager = locationManager\n    &#125;\n    \n    deinit &#123;\n        print(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; deinit view [\\(self)] &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;)\n    &#125;\n    \n    //MARK: - public methods\n    \n    // ------------------------- 权限请求封装 -------------------------\n    \n    /// 定位权限判断\n    func verifyLocationAuthroization(showAlertIn controller: UIViewController? = nil,\n                                     completion: (() -&gt; ())? = nil,\n                                     failure: (() -&gt; ())? = nil) &#123;\n\n        switch self.locationAuthorization &#123;\n        case .notDetermined:                            // 1. 首次打开App时\n            self.locationAuthVerifyCompletion = completion\n            self.locationAuthVerifyFailure = failure\n            self.locationManager.requestWhenInUseAuthorization()    // 使用时 *\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            self.ui_showAlertForDeniedLocationAuthorization(in: controller)\n            if let failure = failure &#123; failure() &#125;\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            if let completion  = completion &#123; completion() &#125;\n        @unknown default:                               // 4. 未知情况\n            self.ui_showAlertForDeniedLocationAuthorization(in: controller)\n            if let failure = failure &#123; failure() &#125;\n        &#125;\n    &#125;\n    \n    /// 精读权限判断(高精读)\n    @available(iOS 14.0, *)\n    func verifyAccuracyAuthroization(completion: (() -&gt; ())? = nil,\n                                     failure: (() -&gt; ())? = nil) &#123;\n        if self.isAccuracyAuthorizationFull() &#123;\n            if let completion = completion &#123; completion() &#125;\n        &#125; else &#123;\n            let key = self.config.accuracyPurposeKey\n            self.locationManager.requestTemporaryFullAccuracyAuthorization(withPurposeKey: key) &#123; err in\n                if self.isAccuracyAuthorizationFull() &#123;\n                    if let completion = completion &#123; completion() &#125;\n                &#125; else &#123;\n                    if let failure = failure &#123; failure() &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    \n    // ------------------------- 权限状态 -------------------------\n    \n    /// 定位权限是否被拒绝\n    func isLocationAuthroizationDenied() -&gt; Bool &#123;\n        switch self.locationAuthorization &#123;\n        case .notDetermined:                            // 1. 首次打开App时\n            return false\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            return true\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            return false\n        @unknown default:                               // 4. 未知情况\n            return true\n        &#125;\n    &#125;\n    \n    /// 定位权限是否被允许\n    func isLocationAuthroizationEnable() -&gt; Bool &#123;\n        switch self.locationAuthorization &#123;\n        case .notDetermined:                            // 1. 首次打开App时\n            return false\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            return false\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            return true\n        @unknown default:                               // 4. 未知情况\n            return false\n        &#125;\n    &#125;\n    \n    /// 精准定位\n    @available(iOS 14.0, *)\n    func isAccuracyAuthorizationFull() -&gt; Bool &#123;\n        return self.locationManager.accuracyAuthorization == .fullAccuracy\n    &#125;\n    \n    //MARK: - private methods\n    \n    /// 显示定位权限拒绝 Alert\n    private func ui_showAlertForDeniedLocationAuthorization(in controller: UIViewController?) &#123;\n        guard let controller = controller else &#123; return &#125;\n\n        let title = self.config.locationAlertTitle\n        let message = self.config.locationAlertMessage\n        let alertVC = UIAlertController.ty_doubleOptionAlertWith(title: title, message: message, optionTitle1: &quot;去设置&quot;, action1: &#123;\n            if let settingURL = URL(string: UIApplication.openSettingsURLString),\n                UIApplication.shared.canOpenURL(settingURL) &#123;\n                UIApplication.shared.open(settingURL, options: [:], completionHandler: nil)\n            &#125;\n        &#125;, optionTitle2: &quot;取消&quot;, action2: nil)\n        controller.present(alertVC, animated: true, completion: nil)\n    &#125;\n    \n    \n    /// 清空 定位权限获取Block\n    private func clearLocationAuthorizationBlock() &#123;\n        self.locationAuthVerifyCompletion = nil\n        self.locationAuthVerifyFailure = nil\n    &#125;\n&#125;\n\nextension TYLocationAuthorization : CLLocationManagerDelegate &#123;\n    \n    /// 定位权限修改 (iOS 4.2 - 14.0)\n    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) &#123;\n        self.data_locationAuthorizationDidChange()\n    &#125;\n    \n    /// 定位权限修改 (iOS 14.0+)\n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) &#123;\n        self.data_locationAuthorizationDidChange()\n    &#125;\n    \n    /// 权限状态修改\n    private func data_locationAuthorizationDidChange() &#123;\n        if self.locationAuthVerifyCompletion == nil, self.locationAuthVerifyFailure == nil &#123; return &#125;\n              \n        switch self.locationAuthorization &#123;\n        case .notDetermined:                            // 1. 首次打开App时\n            break\n        case .restricted, .denied:                      // 2. 父母限制 or 拒绝\n            if let failure = self.locationAuthVerifyFailure &#123; failure() &#125;\n            self.clearLocationAuthorizationBlock()\n        case .authorizedAlways, .authorizedWhenInUse:   // 3. 已授权\n            if let completion = self.locationAuthVerifyCompletion &#123; completion() &#125;\n            self.clearLocationAuthorizationBlock()\n        @unknown default:                               // 4. 未知情况\n            if let failure = self.locationAuthVerifyFailure &#123; failure() &#125;\n            self.clearLocationAuthorizationBlock()\n        &#125;\n        \n    &#125;\n&#125;\n</code></pre>\n<p>这里需要考虑到多种情况，是否拒绝权限，是否拥有了权限以及不同手机系统的问题。<br>用法也是相当简单：</p>\n<pre><code class=\"line-numbers language-Swift\">let manager = self.authorizationManager\nmanager.verifyLocationAuthroization(showAlertIn: self, completion: &#123;\n    if #available(iOS 14.0, *) &#123;\n        manager.verifyAccuracyAuthroization(completion: &#123;\n            requestLocation(completion)\n        &#125;, failure: nil)\n    &#125; else &#123;\n        requestLocation(completion)\n    &#125;\n&#125;, failure: nil)\n</code></pre>\n<p>这个manager就是我们的工具类。</p>\n<p>大致就是这么多了。</p>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5 总结\"></a>5 总结</h2><ul>\n<li><p>如果要做一个需要三方支持的东西，请务必要提前调研下，如地图，推送，埋点等，这些最后提前了解下三方的接入指南，这样更好去实现需求。</p>\n</li>\n<li><p>高德地图对接非常简单，拿到key后，主要工作就是对Map的处理，用户行为二指缩放这种高德自行实现，我们只需要设置坐标给中间的位置即可。</p>\n</li>\n<li><p>对于地图，一定要考虑是否有权限的情况，没有权限的情况也需要跳转到系统设置，这样才能加强用户体验。万万不可出现没有权限直接闪退的问题。</p>\n</li>\n<li><p>一般做地图都会有一个搜索能力，这样就需要高德搜索接口了，需要了解AMapSearchAPI 这个接口的用法，定位的话就用到AMapLocationManager。</p>\n</li>\n</ul>\n"},{"title":"Android 学习导航","date":"2023-01-21T06:14:49.000Z","top":true,"cover":false,"toc":true,"mathjax":true,"_content":"\n# 1 知识体系\n\t\n## 1.1 Android性能优化\n\n### 1.1.1 包体积优化\n> [https://juejin.cn/post/7186580175222472759](https://juejin.cn/post/7186580175222472759)\n\n### 1.1.2 NDK OpenGLES 3.0\n> [https://github.com/githubhaohao/NDK_OpenGLES_3_0](https://github.com/githubhaohao/NDK_OpenGLES_3_0)\n\n> [https://github.com/ouyangpeng/OpenGLESDemo](https://github.com/ouyangpeng/OpenGLESDemo)\n\n# 2 优秀站点\n\n## 2.1 玩Android\n\n### 2.1.1 热门博文\n> [https://www.wanandroid.com/index?cid=0](https://www.wanandroid.com/index?cid=0)\n\t\t\n### 2.1.2 每日更新\n> [https://www.wanandroid.com/user_article](https://www.wanandroid.com/user_article)\n\n\n## 2.2 掘金\n\n### 2.2.1 热门博文\n> [https://juejin.cn/android?sort=monthly_hottest](https://juejin.cn/android?sort=monthly_hottest)\n\n### 2.2.2 每日更新\n> [https://juejin.cn/android?sort=newest](https://juejin.cn/android?sort=newest)\n\n\n## 2.3 简书\n\n### 2.3.1 热门博文\n> [https://www.jianshu.com/techareas/andriod](https://www.jianshu.com/techareas/andriod)\n\n## 2.4 CSDN\n\n### 2.4.1 热门博文\n> [https://blog.csdn.net/nav/mobile/android](https://blog.csdn.net/nav/mobile/android)\n\n## 2.5 开源中国\n\n### 2.5.1 Android开发专区\n> [https://www.oschina.net/android](https://www.oschina.net/android)\n\n## 2.6 Medium(国外)\n\n### 2.6.1 热门问答\n> [https://medium.com/tag/android](https://medium.com/tag/android)\n\n## 2.7 stackoverflow(国外)\n\n### 2.7.1 热门问答\n> [https://stackoverflow.com/questions/tagged/android](https://stackoverflow.com/questions/tagged/android)\n\n## 2.8 Android周报（国外）\n> [https://androidweekly.net/](https://androidweekly.net/)\n\n## 2.9 codeKK\n\n### 2.9.1 Github每日开源\n> [https://p.codekk.com/](https://p.codekk.com/)\n\n## 2.10 github相关\n\n### 2.10.1 关于kotlin每日趋势增长\n> [https://github.com/trending/kotlin?since=daily](https://github.com/trending/kotlin?since=weekly)\n\n## 2.10.2 关于Android的话题\n> [https://github.com/topics/android](https://github.com/topics/android)\n\n\n# 3.公众号\n\n## 3.1 鸿洋\n<img src=hongyang.jpeg>\n\t\t\n## 3.2 郭霖\n<img src=guolin.jpeg>\n\t\t\n## 3.3 Carson\n<img src=carson.jpeg>\n\t\t\n## 3.4 JsonChao\n<img src=jsonchao.jpeg>\n\t\t\n## 3.5 Android群英传\n<img src=qunyingzhuan.jpeg>\n\t\t\n## 3.6 Android编程精选\n<img src=bianchengjingxuan.jpeg>\n\t\t\n## 3.7 Android技术专家\n<img src=jishuzhuanjia.jpeg>\n\t\t\n## 3.8 Android技术圈\n<img src=jishuquan.jpeg>\n\t\t\n\n# 4.大神博客\n\n## 4.1 jsonChao（平安）\n> [https://juejin.cn/user/4318537403878167/posts](https://juejin.cn/user/4318537403878167/posts)\n\n## 4.2 鸿洋（百度）\n> [https://blog.csdn.net/lmj623565791/](https://blog.csdn.net/lmj623565791/)\n\n## 4.3 郭霖\n> [https://blog.csdn.net/guolin_blog/](https://blog.csdn.net/guolin_blog/)\n\n## 4.4 Carson（微信）\n> [https://www.jianshu.com/u/383970bef0a0](https://www.jianshu.com/u/383970bef0a0)\n\n## 4.5 何强（魅族）\n> [https://www.heqiangfly.com/archives/](https://www.heqiangfly.com/archives/)\n\n## 4.6 爱雨浮龙（阿里）\n> [https://juejin.cn/user/2805609405877415/posts](https://juejin.cn/user/2805609405877415/posts)\n\n## 4.7 Android学习资源大全（19年后未更新了）\n> [https://juejin.cn/user/2805609405877415/posts](https://juejin.cn/user/2805609405877415/posts)\n\n## 4.8 徐医生\n> [https://blog.csdn.net/eclipsexys](https://blog.csdn.net/eclipsexys)\n\n## 4.9 技术小黑屋\n> [https://droidyue.com/](https://droidyue.com/)\n\t\n## 4.10 刘望舒\n> [https://liuwangshu.blog.csdn.net/](https://liuwangshu.blog.csdn.net/)\n\n## 4.11 任玉刚\n> [https://blog.csdn.net/singwhatiwanna](https://blog.csdn.net/singwhatiwanna)\n\n## 4.12 Gityuan\n> [http://gityuan.com/](http://gityuan.com/)\n\n## 4.13 扔物线\n> [https://rengwuxian.com/](https://rengwuxian.com/)\n\n## 4.14 yrom\n> [https://yrom.net/archives/](https://yrom.net/archives/)\n\n## 4.15 美团\n> [https://tech.meituan.com/](https://tech.meituan.com/)\n\n## 4.16 切切歆语\n> [https://blog.csdn.net/dickyqie/category_6238189.html](https://blog.csdn.net/dickyqie/category_6238189.html)\n\n# 5.优秀三方库\n\t\n## 5.1 网络相关\n\n### 5.1.1 Retrofit\n> [https://github.com/square/retrofit](https://github.com/square/retrofit)\n\n### 5.1.2 OKHttp\n> [https://github.com/square/okhttp](https://github.com/square/okhttp)\n\n## 5.2 图片相关\n\n### 5.2.1 Glide\n> [https://github.com/bumptech/glide](https://github.com/bumptech/glide)\n\n## 5.3 响应式相关\n\n### 5.3.1 RxJava\n> [https://github.com/ReactiveX/RxJava](https://github.com/ReactiveX/RxJava)\n\n## 5.4 事件相关\n\n### 5.4.1 EventBus\n> [https://github.com/greenrobot/EventBus](https://github.com/greenrobot/EventBus)\n\n## 5.5 数据库相关\n\n### 5.5.1 greenDAO\n> [https://github.com/greenrobot/greenDAO](https://github.com/greenrobot/greenDAO)\n\n# 6.项目推荐\n\n## 6.1 wanAndroid项目推荐\n> [https://www.wanandroid.com/projectindex](https://www.wanandroid.com/projectindex)\n\n## 6.2 官方demo==nowinandroid\n> [https://github.com/android/nowinandroidhttps://github.com/android/nowinandroid](https://github.com/android/nowinandroid)\n\n## 6.3 emo==腾讯大神封装的compse基础UI\n> [https://github.com/cgspine/emo](https://github.com/cgspine/emo)\n\n# 7.其它\n\n## 7.1 面试相关\n\n## 7.2 开发工具相关\n\n## 7.3 官方资源\n\n### 7.3.1 Android官网\n> [https://developer.android.google.cn/](https://developer.android.google.cn/)\n\n### 7.3.2 Google Samples\n> [https://github.com/googlesamples](https://github.com/googlesamples)\n\n## 7.4 随记\n\n### 7.4.1 kotlin let also run with 用法\n> [https://juejin.cn/post/6868179386344931342](https://juejin.cn/post/6868179386344931342)\n\n","source":"_posts/Android-学习导航.md","raw":"---\ntitle: Android 学习导航\ndate: 2023-01-21 14:14:49\ntop: true\ncover: false\ntoc: true\nmathjax: true\ntags:\n- Android\ncategories:\n- Android\n---\n\n# 1 知识体系\n\t\n## 1.1 Android性能优化\n\n### 1.1.1 包体积优化\n> [https://juejin.cn/post/7186580175222472759](https://juejin.cn/post/7186580175222472759)\n\n### 1.1.2 NDK OpenGLES 3.0\n> [https://github.com/githubhaohao/NDK_OpenGLES_3_0](https://github.com/githubhaohao/NDK_OpenGLES_3_0)\n\n> [https://github.com/ouyangpeng/OpenGLESDemo](https://github.com/ouyangpeng/OpenGLESDemo)\n\n# 2 优秀站点\n\n## 2.1 玩Android\n\n### 2.1.1 热门博文\n> [https://www.wanandroid.com/index?cid=0](https://www.wanandroid.com/index?cid=0)\n\t\t\n### 2.1.2 每日更新\n> [https://www.wanandroid.com/user_article](https://www.wanandroid.com/user_article)\n\n\n## 2.2 掘金\n\n### 2.2.1 热门博文\n> [https://juejin.cn/android?sort=monthly_hottest](https://juejin.cn/android?sort=monthly_hottest)\n\n### 2.2.2 每日更新\n> [https://juejin.cn/android?sort=newest](https://juejin.cn/android?sort=newest)\n\n\n## 2.3 简书\n\n### 2.3.1 热门博文\n> [https://www.jianshu.com/techareas/andriod](https://www.jianshu.com/techareas/andriod)\n\n## 2.4 CSDN\n\n### 2.4.1 热门博文\n> [https://blog.csdn.net/nav/mobile/android](https://blog.csdn.net/nav/mobile/android)\n\n## 2.5 开源中国\n\n### 2.5.1 Android开发专区\n> [https://www.oschina.net/android](https://www.oschina.net/android)\n\n## 2.6 Medium(国外)\n\n### 2.6.1 热门问答\n> [https://medium.com/tag/android](https://medium.com/tag/android)\n\n## 2.7 stackoverflow(国外)\n\n### 2.7.1 热门问答\n> [https://stackoverflow.com/questions/tagged/android](https://stackoverflow.com/questions/tagged/android)\n\n## 2.8 Android周报（国外）\n> [https://androidweekly.net/](https://androidweekly.net/)\n\n## 2.9 codeKK\n\n### 2.9.1 Github每日开源\n> [https://p.codekk.com/](https://p.codekk.com/)\n\n## 2.10 github相关\n\n### 2.10.1 关于kotlin每日趋势增长\n> [https://github.com/trending/kotlin?since=daily](https://github.com/trending/kotlin?since=weekly)\n\n## 2.10.2 关于Android的话题\n> [https://github.com/topics/android](https://github.com/topics/android)\n\n\n# 3.公众号\n\n## 3.1 鸿洋\n<img src=hongyang.jpeg>\n\t\t\n## 3.2 郭霖\n<img src=guolin.jpeg>\n\t\t\n## 3.3 Carson\n<img src=carson.jpeg>\n\t\t\n## 3.4 JsonChao\n<img src=jsonchao.jpeg>\n\t\t\n## 3.5 Android群英传\n<img src=qunyingzhuan.jpeg>\n\t\t\n## 3.6 Android编程精选\n<img src=bianchengjingxuan.jpeg>\n\t\t\n## 3.7 Android技术专家\n<img src=jishuzhuanjia.jpeg>\n\t\t\n## 3.8 Android技术圈\n<img src=jishuquan.jpeg>\n\t\t\n\n# 4.大神博客\n\n## 4.1 jsonChao（平安）\n> [https://juejin.cn/user/4318537403878167/posts](https://juejin.cn/user/4318537403878167/posts)\n\n## 4.2 鸿洋（百度）\n> [https://blog.csdn.net/lmj623565791/](https://blog.csdn.net/lmj623565791/)\n\n## 4.3 郭霖\n> [https://blog.csdn.net/guolin_blog/](https://blog.csdn.net/guolin_blog/)\n\n## 4.4 Carson（微信）\n> [https://www.jianshu.com/u/383970bef0a0](https://www.jianshu.com/u/383970bef0a0)\n\n## 4.5 何强（魅族）\n> [https://www.heqiangfly.com/archives/](https://www.heqiangfly.com/archives/)\n\n## 4.6 爱雨浮龙（阿里）\n> [https://juejin.cn/user/2805609405877415/posts](https://juejin.cn/user/2805609405877415/posts)\n\n## 4.7 Android学习资源大全（19年后未更新了）\n> [https://juejin.cn/user/2805609405877415/posts](https://juejin.cn/user/2805609405877415/posts)\n\n## 4.8 徐医生\n> [https://blog.csdn.net/eclipsexys](https://blog.csdn.net/eclipsexys)\n\n## 4.9 技术小黑屋\n> [https://droidyue.com/](https://droidyue.com/)\n\t\n## 4.10 刘望舒\n> [https://liuwangshu.blog.csdn.net/](https://liuwangshu.blog.csdn.net/)\n\n## 4.11 任玉刚\n> [https://blog.csdn.net/singwhatiwanna](https://blog.csdn.net/singwhatiwanna)\n\n## 4.12 Gityuan\n> [http://gityuan.com/](http://gityuan.com/)\n\n## 4.13 扔物线\n> [https://rengwuxian.com/](https://rengwuxian.com/)\n\n## 4.14 yrom\n> [https://yrom.net/archives/](https://yrom.net/archives/)\n\n## 4.15 美团\n> [https://tech.meituan.com/](https://tech.meituan.com/)\n\n## 4.16 切切歆语\n> [https://blog.csdn.net/dickyqie/category_6238189.html](https://blog.csdn.net/dickyqie/category_6238189.html)\n\n# 5.优秀三方库\n\t\n## 5.1 网络相关\n\n### 5.1.1 Retrofit\n> [https://github.com/square/retrofit](https://github.com/square/retrofit)\n\n### 5.1.2 OKHttp\n> [https://github.com/square/okhttp](https://github.com/square/okhttp)\n\n## 5.2 图片相关\n\n### 5.2.1 Glide\n> [https://github.com/bumptech/glide](https://github.com/bumptech/glide)\n\n## 5.3 响应式相关\n\n### 5.3.1 RxJava\n> [https://github.com/ReactiveX/RxJava](https://github.com/ReactiveX/RxJava)\n\n## 5.4 事件相关\n\n### 5.4.1 EventBus\n> [https://github.com/greenrobot/EventBus](https://github.com/greenrobot/EventBus)\n\n## 5.5 数据库相关\n\n### 5.5.1 greenDAO\n> [https://github.com/greenrobot/greenDAO](https://github.com/greenrobot/greenDAO)\n\n# 6.项目推荐\n\n## 6.1 wanAndroid项目推荐\n> [https://www.wanandroid.com/projectindex](https://www.wanandroid.com/projectindex)\n\n## 6.2 官方demo==nowinandroid\n> [https://github.com/android/nowinandroidhttps://github.com/android/nowinandroid](https://github.com/android/nowinandroid)\n\n## 6.3 emo==腾讯大神封装的compse基础UI\n> [https://github.com/cgspine/emo](https://github.com/cgspine/emo)\n\n# 7.其它\n\n## 7.1 面试相关\n\n## 7.2 开发工具相关\n\n## 7.3 官方资源\n\n### 7.3.1 Android官网\n> [https://developer.android.google.cn/](https://developer.android.google.cn/)\n\n### 7.3.2 Google Samples\n> [https://github.com/googlesamples](https://github.com/googlesamples)\n\n## 7.4 随记\n\n### 7.4.1 kotlin let also run with 用法\n> [https://juejin.cn/post/6868179386344931342](https://juejin.cn/post/6868179386344931342)\n\n","slug":"Android-学习导航","published":1,"updated":"2023-02-07T07:47:14.186Z","_id":"cldlhfhyu001givv7araa49aa","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"1-知识体系\"><a href=\"#1-知识体系\" class=\"headerlink\" title=\"1 知识体系\"></a>1 知识体系</h1><h2 id=\"1-1-Android性能优化\"><a href=\"#1-1-Android性能优化\" class=\"headerlink\" title=\"1.1 Android性能优化\"></a>1.1 Android性能优化</h2><h3 id=\"1-1-1-包体积优化\"><a href=\"#1-1-1-包体积优化\" class=\"headerlink\" title=\"1.1.1 包体积优化\"></a>1.1.1 包体积优化</h3><blockquote>\n<p><a href=\"https://juejin.cn/post/7186580175222472759\">https://juejin.cn/post/7186580175222472759</a></p>\n</blockquote>\n<h3 id=\"1-1-2-NDK-OpenGLES-3-0\"><a href=\"#1-1-2-NDK-OpenGLES-3-0\" class=\"headerlink\" title=\"1.1.2 NDK OpenGLES 3.0\"></a>1.1.2 NDK OpenGLES 3.0</h3><blockquote>\n<p><a href=\"https://github.com/githubhaohao/NDK_OpenGLES_3_0\">https://github.com/githubhaohao/NDK_OpenGLES_3_0</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/ouyangpeng/OpenGLESDemo\">https://github.com/ouyangpeng/OpenGLESDemo</a></p>\n</blockquote>\n<h1 id=\"2-优秀站点\"><a href=\"#2-优秀站点\" class=\"headerlink\" title=\"2 优秀站点\"></a>2 优秀站点</h1><h2 id=\"2-1-玩Android\"><a href=\"#2-1-玩Android\" class=\"headerlink\" title=\"2.1 玩Android\"></a>2.1 玩Android</h2><h3 id=\"2-1-1-热门博文\"><a href=\"#2-1-1-热门博文\" class=\"headerlink\" title=\"2.1.1 热门博文\"></a>2.1.1 热门博文</h3><blockquote>\n<p><a href=\"https://www.wanandroid.com/index?cid=0\">https://www.wanandroid.com/index?cid=0</a></p>\n</blockquote>\n<h3 id=\"2-1-2-每日更新\"><a href=\"#2-1-2-每日更新\" class=\"headerlink\" title=\"2.1.2 每日更新\"></a>2.1.2 每日更新</h3><blockquote>\n<p><a href=\"https://www.wanandroid.com/user_article\">https://www.wanandroid.com/user_article</a></p>\n</blockquote>\n<h2 id=\"2-2-掘金\"><a href=\"#2-2-掘金\" class=\"headerlink\" title=\"2.2 掘金\"></a>2.2 掘金</h2><h3 id=\"2-2-1-热门博文\"><a href=\"#2-2-1-热门博文\" class=\"headerlink\" title=\"2.2.1 热门博文\"></a>2.2.1 热门博文</h3><blockquote>\n<p><a href=\"https://juejin.cn/android?sort=monthly_hottest\">https://juejin.cn/android?sort=monthly_hottest</a></p>\n</blockquote>\n<h3 id=\"2-2-2-每日更新\"><a href=\"#2-2-2-每日更新\" class=\"headerlink\" title=\"2.2.2 每日更新\"></a>2.2.2 每日更新</h3><blockquote>\n<p><a href=\"https://juejin.cn/android?sort=newest\">https://juejin.cn/android?sort=newest</a></p>\n</blockquote>\n<h2 id=\"2-3-简书\"><a href=\"#2-3-简书\" class=\"headerlink\" title=\"2.3 简书\"></a>2.3 简书</h2><h3 id=\"2-3-1-热门博文\"><a href=\"#2-3-1-热门博文\" class=\"headerlink\" title=\"2.3.1 热门博文\"></a>2.3.1 热门博文</h3><blockquote>\n<p><a href=\"https://www.jianshu.com/techareas/andriod\">https://www.jianshu.com/techareas/andriod</a></p>\n</blockquote>\n<h2 id=\"2-4-CSDN\"><a href=\"#2-4-CSDN\" class=\"headerlink\" title=\"2.4 CSDN\"></a>2.4 CSDN</h2><h3 id=\"2-4-1-热门博文\"><a href=\"#2-4-1-热门博文\" class=\"headerlink\" title=\"2.4.1 热门博文\"></a>2.4.1 热门博文</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/nav/mobile/android\">https://blog.csdn.net/nav/mobile/android</a></p>\n</blockquote>\n<h2 id=\"2-5-开源中国\"><a href=\"#2-5-开源中国\" class=\"headerlink\" title=\"2.5 开源中国\"></a>2.5 开源中国</h2><h3 id=\"2-5-1-Android开发专区\"><a href=\"#2-5-1-Android开发专区\" class=\"headerlink\" title=\"2.5.1 Android开发专区\"></a>2.5.1 Android开发专区</h3><blockquote>\n<p><a href=\"https://www.oschina.net/android\">https://www.oschina.net/android</a></p>\n</blockquote>\n<h2 id=\"2-6-Medium-国外\"><a href=\"#2-6-Medium-国外\" class=\"headerlink\" title=\"2.6 Medium(国外)\"></a>2.6 Medium(国外)</h2><h3 id=\"2-6-1-热门问答\"><a href=\"#2-6-1-热门问答\" class=\"headerlink\" title=\"2.6.1 热门问答\"></a>2.6.1 热门问答</h3><blockquote>\n<p><a href=\"https://medium.com/tag/android\">https://medium.com/tag/android</a></p>\n</blockquote>\n<h2 id=\"2-7-stackoverflow-国外\"><a href=\"#2-7-stackoverflow-国外\" class=\"headerlink\" title=\"2.7 stackoverflow(国外)\"></a>2.7 stackoverflow(国外)</h2><h3 id=\"2-7-1-热门问答\"><a href=\"#2-7-1-热门问答\" class=\"headerlink\" title=\"2.7.1 热门问答\"></a>2.7.1 热门问答</h3><blockquote>\n<p><a href=\"https://stackoverflow.com/questions/tagged/android\">https://stackoverflow.com/questions/tagged/android</a></p>\n</blockquote>\n<h2 id=\"2-8-Android周报（国外）\"><a href=\"#2-8-Android周报（国外）\" class=\"headerlink\" title=\"2.8 Android周报（国外）\"></a>2.8 Android周报（国外）</h2><blockquote>\n<p><a href=\"https://androidweekly.net/\">https://androidweekly.net/</a></p>\n</blockquote>\n<h2 id=\"2-9-codeKK\"><a href=\"#2-9-codeKK\" class=\"headerlink\" title=\"2.9 codeKK\"></a>2.9 codeKK</h2><h3 id=\"2-9-1-Github每日开源\"><a href=\"#2-9-1-Github每日开源\" class=\"headerlink\" title=\"2.9.1 Github每日开源\"></a>2.9.1 Github每日开源</h3><blockquote>\n<p><a href=\"https://p.codekk.com/\">https://p.codekk.com/</a></p>\n</blockquote>\n<h2 id=\"2-10-github相关\"><a href=\"#2-10-github相关\" class=\"headerlink\" title=\"2.10 github相关\"></a>2.10 github相关</h2><h3 id=\"2-10-1-关于kotlin每日趋势增长\"><a href=\"#2-10-1-关于kotlin每日趋势增长\" class=\"headerlink\" title=\"2.10.1 关于kotlin每日趋势增长\"></a>2.10.1 关于kotlin每日趋势增长</h3><blockquote>\n<p><a href=\"https://github.com/trending/kotlin?since=weekly\">https://github.com/trending/kotlin?since=daily</a></p>\n</blockquote>\n<h2 id=\"2-10-2-关于Android的话题\"><a href=\"#2-10-2-关于Android的话题\" class=\"headerlink\" title=\"2.10.2 关于Android的话题\"></a>2.10.2 关于Android的话题</h2><blockquote>\n<p><a href=\"https://github.com/topics/android\">https://github.com/topics/android</a></p>\n</blockquote>\n<h1 id=\"3-公众号\"><a href=\"#3-公众号\" class=\"headerlink\" title=\"3.公众号\"></a>3.公众号</h1><h2 id=\"3-1-鸿洋\"><a href=\"#3-1-鸿洋\" class=\"headerlink\" title=\"3.1 鸿洋\"></a>3.1 鸿洋</h2><img src=hongyang.jpeg>\n        \n<h2 id=\"3-2-郭霖\"><a href=\"#3-2-郭霖\" class=\"headerlink\" title=\"3.2 郭霖\"></a>3.2 郭霖</h2><img src=guolin.jpeg>\n        \n<h2 id=\"3-3-Carson\"><a href=\"#3-3-Carson\" class=\"headerlink\" title=\"3.3 Carson\"></a>3.3 Carson</h2><img src=carson.jpeg>\n        \n<h2 id=\"3-4-JsonChao\"><a href=\"#3-4-JsonChao\" class=\"headerlink\" title=\"3.4 JsonChao\"></a>3.4 JsonChao</h2><img src=jsonchao.jpeg>\n        \n<h2 id=\"3-5-Android群英传\"><a href=\"#3-5-Android群英传\" class=\"headerlink\" title=\"3.5 Android群英传\"></a>3.5 Android群英传</h2><img src=qunyingzhuan.jpeg>\n        \n<h2 id=\"3-6-Android编程精选\"><a href=\"#3-6-Android编程精选\" class=\"headerlink\" title=\"3.6 Android编程精选\"></a>3.6 Android编程精选</h2><img src=bianchengjingxuan.jpeg>\n        \n<h2 id=\"3-7-Android技术专家\"><a href=\"#3-7-Android技术专家\" class=\"headerlink\" title=\"3.7 Android技术专家\"></a>3.7 Android技术专家</h2><img src=jishuzhuanjia.jpeg>\n        \n<h2 id=\"3-8-Android技术圈\"><a href=\"#3-8-Android技术圈\" class=\"headerlink\" title=\"3.8 Android技术圈\"></a>3.8 Android技术圈</h2><img src=jishuquan.jpeg>\n        \n\n<h1 id=\"4-大神博客\"><a href=\"#4-大神博客\" class=\"headerlink\" title=\"4.大神博客\"></a>4.大神博客</h1><h2 id=\"4-1-jsonChao（平安）\"><a href=\"#4-1-jsonChao（平安）\" class=\"headerlink\" title=\"4.1 jsonChao（平安）\"></a>4.1 jsonChao（平安）</h2><blockquote>\n<p><a href=\"https://juejin.cn/user/4318537403878167/posts\">https://juejin.cn/user/4318537403878167/posts</a></p>\n</blockquote>\n<h2 id=\"4-2-鸿洋（百度）\"><a href=\"#4-2-鸿洋（百度）\" class=\"headerlink\" title=\"4.2 鸿洋（百度）\"></a>4.2 鸿洋（百度）</h2><blockquote>\n<p><a href=\"https://blog.csdn.net/lmj623565791/\">https://blog.csdn.net/lmj623565791/</a></p>\n</blockquote>\n<h2 id=\"4-3-郭霖\"><a href=\"#4-3-郭霖\" class=\"headerlink\" title=\"4.3 郭霖\"></a>4.3 郭霖</h2><blockquote>\n<p><a href=\"https://blog.csdn.net/guolin_blog/\">https://blog.csdn.net/guolin_blog&#x2F;</a></p>\n</blockquote>\n<h2 id=\"4-4-Carson（微信）\"><a href=\"#4-4-Carson（微信）\" class=\"headerlink\" title=\"4.4 Carson（微信）\"></a>4.4 Carson（微信）</h2><blockquote>\n<p><a href=\"https://www.jianshu.com/u/383970bef0a0\">https://www.jianshu.com/u/383970bef0a0</a></p>\n</blockquote>\n<h2 id=\"4-5-何强（魅族）\"><a href=\"#4-5-何强（魅族）\" class=\"headerlink\" title=\"4.5 何强（魅族）\"></a>4.5 何强（魅族）</h2><blockquote>\n<p><a href=\"https://www.heqiangfly.com/archives/\">https://www.heqiangfly.com/archives/</a></p>\n</blockquote>\n<h2 id=\"4-6-爱雨浮龙（阿里）\"><a href=\"#4-6-爱雨浮龙（阿里）\" class=\"headerlink\" title=\"4.6 爱雨浮龙（阿里）\"></a>4.6 爱雨浮龙（阿里）</h2><blockquote>\n<p><a href=\"https://juejin.cn/user/2805609405877415/posts\">https://juejin.cn/user/2805609405877415/posts</a></p>\n</blockquote>\n<h2 id=\"4-7-Android学习资源大全（19年后未更新了）\"><a href=\"#4-7-Android学习资源大全（19年后未更新了）\" class=\"headerlink\" title=\"4.7 Android学习资源大全（19年后未更新了）\"></a>4.7 Android学习资源大全（19年后未更新了）</h2><blockquote>\n<p><a href=\"https://juejin.cn/user/2805609405877415/posts\">https://juejin.cn/user/2805609405877415/posts</a></p>\n</blockquote>\n<h2 id=\"4-8-徐医生\"><a href=\"#4-8-徐医生\" class=\"headerlink\" title=\"4.8 徐医生\"></a>4.8 徐医生</h2><blockquote>\n<p><a href=\"https://blog.csdn.net/eclipsexys\">https://blog.csdn.net/eclipsexys</a></p>\n</blockquote>\n<h2 id=\"4-9-技术小黑屋\"><a href=\"#4-9-技术小黑屋\" class=\"headerlink\" title=\"4.9 技术小黑屋\"></a>4.9 技术小黑屋</h2><blockquote>\n<p><a href=\"https://droidyue.com/\">https://droidyue.com/</a></p>\n</blockquote>\n<h2 id=\"4-10-刘望舒\"><a href=\"#4-10-刘望舒\" class=\"headerlink\" title=\"4.10 刘望舒\"></a>4.10 刘望舒</h2><blockquote>\n<p><a href=\"https://liuwangshu.blog.csdn.net/\">https://liuwangshu.blog.csdn.net/</a></p>\n</blockquote>\n<h2 id=\"4-11-任玉刚\"><a href=\"#4-11-任玉刚\" class=\"headerlink\" title=\"4.11 任玉刚\"></a>4.11 任玉刚</h2><blockquote>\n<p><a href=\"https://blog.csdn.net/singwhatiwanna\">https://blog.csdn.net/singwhatiwanna</a></p>\n</blockquote>\n<h2 id=\"4-12-Gityuan\"><a href=\"#4-12-Gityuan\" class=\"headerlink\" title=\"4.12 Gityuan\"></a>4.12 Gityuan</h2><blockquote>\n<p><a href=\"http://gityuan.com/\">http://gityuan.com/</a></p>\n</blockquote>\n<h2 id=\"4-13-扔物线\"><a href=\"#4-13-扔物线\" class=\"headerlink\" title=\"4.13 扔物线\"></a>4.13 扔物线</h2><blockquote>\n<p><a href=\"https://rengwuxian.com/\">https://rengwuxian.com/</a></p>\n</blockquote>\n<h2 id=\"4-14-yrom\"><a href=\"#4-14-yrom\" class=\"headerlink\" title=\"4.14 yrom\"></a>4.14 yrom</h2><blockquote>\n<p><a href=\"https://yrom.net/archives/\">https://yrom.net/archives/</a></p>\n</blockquote>\n<h2 id=\"4-15-美团\"><a href=\"#4-15-美团\" class=\"headerlink\" title=\"4.15 美团\"></a>4.15 美团</h2><blockquote>\n<p><a href=\"https://tech.meituan.com/\">https://tech.meituan.com/</a></p>\n</blockquote>\n<h2 id=\"4-16-切切歆语\"><a href=\"#4-16-切切歆语\" class=\"headerlink\" title=\"4.16 切切歆语\"></a>4.16 切切歆语</h2><blockquote>\n<p><a href=\"https://blog.csdn.net/dickyqie/category_6238189.html\">https://blog.csdn.net/dickyqie/category_6238189.html</a></p>\n</blockquote>\n<h1 id=\"5-优秀三方库\"><a href=\"#5-优秀三方库\" class=\"headerlink\" title=\"5.优秀三方库\"></a>5.优秀三方库</h1><h2 id=\"5-1-网络相关\"><a href=\"#5-1-网络相关\" class=\"headerlink\" title=\"5.1 网络相关\"></a>5.1 网络相关</h2><h3 id=\"5-1-1-Retrofit\"><a href=\"#5-1-1-Retrofit\" class=\"headerlink\" title=\"5.1.1 Retrofit\"></a>5.1.1 Retrofit</h3><blockquote>\n<p><a href=\"https://github.com/square/retrofit\">https://github.com/square/retrofit</a></p>\n</blockquote>\n<h3 id=\"5-1-2-OKHttp\"><a href=\"#5-1-2-OKHttp\" class=\"headerlink\" title=\"5.1.2 OKHttp\"></a>5.1.2 OKHttp</h3><blockquote>\n<p><a href=\"https://github.com/square/okhttp\">https://github.com/square/okhttp</a></p>\n</blockquote>\n<h2 id=\"5-2-图片相关\"><a href=\"#5-2-图片相关\" class=\"headerlink\" title=\"5.2 图片相关\"></a>5.2 图片相关</h2><h3 id=\"5-2-1-Glide\"><a href=\"#5-2-1-Glide\" class=\"headerlink\" title=\"5.2.1 Glide\"></a>5.2.1 Glide</h3><blockquote>\n<p><a href=\"https://github.com/bumptech/glide\">https://github.com/bumptech/glide</a></p>\n</blockquote>\n<h2 id=\"5-3-响应式相关\"><a href=\"#5-3-响应式相关\" class=\"headerlink\" title=\"5.3 响应式相关\"></a>5.3 响应式相关</h2><h3 id=\"5-3-1-RxJava\"><a href=\"#5-3-1-RxJava\" class=\"headerlink\" title=\"5.3.1 RxJava\"></a>5.3.1 RxJava</h3><blockquote>\n<p><a href=\"https://github.com/ReactiveX/RxJava\">https://github.com/ReactiveX/RxJava</a></p>\n</blockquote>\n<h2 id=\"5-4-事件相关\"><a href=\"#5-4-事件相关\" class=\"headerlink\" title=\"5.4 事件相关\"></a>5.4 事件相关</h2><h3 id=\"5-4-1-EventBus\"><a href=\"#5-4-1-EventBus\" class=\"headerlink\" title=\"5.4.1 EventBus\"></a>5.4.1 EventBus</h3><blockquote>\n<p><a href=\"https://github.com/greenrobot/EventBus\">https://github.com/greenrobot/EventBus</a></p>\n</blockquote>\n<h2 id=\"5-5-数据库相关\"><a href=\"#5-5-数据库相关\" class=\"headerlink\" title=\"5.5 数据库相关\"></a>5.5 数据库相关</h2><h3 id=\"5-5-1-greenDAO\"><a href=\"#5-5-1-greenDAO\" class=\"headerlink\" title=\"5.5.1 greenDAO\"></a>5.5.1 greenDAO</h3><blockquote>\n<p><a href=\"https://github.com/greenrobot/greenDAO\">https://github.com/greenrobot/greenDAO</a></p>\n</blockquote>\n<h1 id=\"6-项目推荐\"><a href=\"#6-项目推荐\" class=\"headerlink\" title=\"6.项目推荐\"></a>6.项目推荐</h1><h2 id=\"6-1-wanAndroid项目推荐\"><a href=\"#6-1-wanAndroid项目推荐\" class=\"headerlink\" title=\"6.1 wanAndroid项目推荐\"></a>6.1 wanAndroid项目推荐</h2><blockquote>\n<p><a href=\"https://www.wanandroid.com/projectindex\">https://www.wanandroid.com/projectindex</a></p>\n</blockquote>\n<h2 id=\"6-2-官方demo-x3D-x3D-nowinandroid\"><a href=\"#6-2-官方demo-x3D-x3D-nowinandroid\" class=\"headerlink\" title=\"6.2 官方demo&#x3D;&#x3D;nowinandroid\"></a>6.2 官方demo&#x3D;&#x3D;nowinandroid</h2><blockquote>\n<p><a href=\"https://github.com/android/nowinandroid\">https://github.com/android/nowinandroidhttps://github.com/android/nowinandroid</a></p>\n</blockquote>\n<h2 id=\"6-3-emo-x3D-x3D-腾讯大神封装的compse基础UI\"><a href=\"#6-3-emo-x3D-x3D-腾讯大神封装的compse基础UI\" class=\"headerlink\" title=\"6.3 emo&#x3D;&#x3D;腾讯大神封装的compse基础UI\"></a>6.3 emo&#x3D;&#x3D;腾讯大神封装的compse基础UI</h2><blockquote>\n<p><a href=\"https://github.com/cgspine/emo\">https://github.com/cgspine/emo</a></p>\n</blockquote>\n<h1 id=\"7-其它\"><a href=\"#7-其它\" class=\"headerlink\" title=\"7.其它\"></a>7.其它</h1><h2 id=\"7-1-面试相关\"><a href=\"#7-1-面试相关\" class=\"headerlink\" title=\"7.1 面试相关\"></a>7.1 面试相关</h2><h2 id=\"7-2-开发工具相关\"><a href=\"#7-2-开发工具相关\" class=\"headerlink\" title=\"7.2 开发工具相关\"></a>7.2 开发工具相关</h2><h2 id=\"7-3-官方资源\"><a href=\"#7-3-官方资源\" class=\"headerlink\" title=\"7.3 官方资源\"></a>7.3 官方资源</h2><h3 id=\"7-3-1-Android官网\"><a href=\"#7-3-1-Android官网\" class=\"headerlink\" title=\"7.3.1 Android官网\"></a>7.3.1 Android官网</h3><blockquote>\n<p><a href=\"https://developer.android.google.cn/\">https://developer.android.google.cn/</a></p>\n</blockquote>\n<h3 id=\"7-3-2-Google-Samples\"><a href=\"#7-3-2-Google-Samples\" class=\"headerlink\" title=\"7.3.2 Google Samples\"></a>7.3.2 Google Samples</h3><blockquote>\n<p><a href=\"https://github.com/googlesamples\">https://github.com/googlesamples</a></p>\n</blockquote>\n<h2 id=\"7-4-随记\"><a href=\"#7-4-随记\" class=\"headerlink\" title=\"7.4 随记\"></a>7.4 随记</h2><h3 id=\"7-4-1-kotlin-let-also-run-with-用法\"><a href=\"#7-4-1-kotlin-let-also-run-with-用法\" class=\"headerlink\" title=\"7.4.1 kotlin let also run with 用法\"></a>7.4.1 kotlin let also run with 用法</h3><blockquote>\n<p><a href=\"https://juejin.cn/post/6868179386344931342\">https://juejin.cn/post/6868179386344931342</a></p>\n</blockquote>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h1 id=\"1-知识体系\"><a href=\"#1-知识体系\" class=\"headerlink\" title=\"1 知识体系\"></a>1 知识体系</h1><h2 id=\"1-1-Android性能优化\"><a href=\"#1-1-Android性能优化\" class=\"headerlink\" title=\"1.1 Android性能优化\"></a>1.1 Android性能优化</h2><h3 id=\"1-1-1-包体积优化\"><a href=\"#1-1-1-包体积优化\" class=\"headerlink\" title=\"1.1.1 包体积优化\"></a>1.1.1 包体积优化</h3><blockquote>\n<p><a href=\"https://juejin.cn/post/7186580175222472759\">https://juejin.cn/post/7186580175222472759</a></p>\n</blockquote>\n<h3 id=\"1-1-2-NDK-OpenGLES-3-0\"><a href=\"#1-1-2-NDK-OpenGLES-3-0\" class=\"headerlink\" title=\"1.1.2 NDK OpenGLES 3.0\"></a>1.1.2 NDK OpenGLES 3.0</h3><blockquote>\n<p><a href=\"https://github.com/githubhaohao/NDK_OpenGLES_3_0\">https://github.com/githubhaohao/NDK_OpenGLES_3_0</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/ouyangpeng/OpenGLESDemo\">https://github.com/ouyangpeng/OpenGLESDemo</a></p>\n</blockquote>\n<h1 id=\"2-优秀站点\"><a href=\"#2-优秀站点\" class=\"headerlink\" title=\"2 优秀站点\"></a>2 优秀站点</h1><h2 id=\"2-1-玩Android\"><a href=\"#2-1-玩Android\" class=\"headerlink\" title=\"2.1 玩Android\"></a>2.1 玩Android</h2><h3 id=\"2-1-1-热门博文\"><a href=\"#2-1-1-热门博文\" class=\"headerlink\" title=\"2.1.1 热门博文\"></a>2.1.1 热门博文</h3><blockquote>\n<p><a href=\"https://www.wanandroid.com/index?cid=0\">https://www.wanandroid.com/index?cid=0</a></p>\n</blockquote>\n<h3 id=\"2-1-2-每日更新\"><a href=\"#2-1-2-每日更新\" class=\"headerlink\" title=\"2.1.2 每日更新\"></a>2.1.2 每日更新</h3><blockquote>\n<p><a href=\"https://www.wanandroid.com/user_article\">https://www.wanandroid.com/user_article</a></p>\n</blockquote>\n<h2 id=\"2-2-掘金\"><a href=\"#2-2-掘金\" class=\"headerlink\" title=\"2.2 掘金\"></a>2.2 掘金</h2><h3 id=\"2-2-1-热门博文\"><a href=\"#2-2-1-热门博文\" class=\"headerlink\" title=\"2.2.1 热门博文\"></a>2.2.1 热门博文</h3><blockquote>\n<p><a href=\"https://juejin.cn/android?sort=monthly_hottest\">https://juejin.cn/android?sort=monthly_hottest</a></p>\n</blockquote>\n<h3 id=\"2-2-2-每日更新\"><a href=\"#2-2-2-每日更新\" class=\"headerlink\" title=\"2.2.2 每日更新\"></a>2.2.2 每日更新</h3><blockquote>\n<p><a href=\"https://juejin.cn/android?sort=newest\">https://juejin.cn/android?sort=newest</a></p>\n</blockquote>\n<h2 id=\"2-3-简书\"><a href=\"#2-3-简书\" class=\"headerlink\" title=\"2.3 简书\"></a>2.3 简书</h2><h3 id=\"2-3-1-热门博文\"><a href=\"#2-3-1-热门博文\" class=\"headerlink\" title=\"2.3.1 热门博文\"></a>2.3.1 热门博文</h3><blockquote>\n<p><a href=\"https://www.jianshu.com/techareas/andriod\">https://www.jianshu.com/techareas/andriod</a></p>\n</blockquote>\n<h2 id=\"2-4-CSDN\"><a href=\"#2-4-CSDN\" class=\"headerlink\" title=\"2.4 CSDN\"></a>2.4 CSDN</h2><h3 id=\"2-4-1-热门博文\"><a href=\"#2-4-1-热门博文\" class=\"headerlink\" title=\"2.4.1 热门博文\"></a>2.4.1 热门博文</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/nav/mobile/android\">https://blog.csdn.net/nav/mobile/android</a></p>\n</blockquote>\n<h2 id=\"2-5-开源中国\"><a href=\"#2-5-开源中国\" class=\"headerlink\" title=\"2.5 开源中国\"></a>2.5 开源中国</h2><h3 id=\"2-5-1-Android开发专区\"><a href=\"#2-5-1-Android开发专区\" class=\"headerlink\" title=\"2.5.1 Android开发专区\"></a>2.5.1 Android开发专区</h3><blockquote>\n<p><a href=\"https://www.oschina.net/android\">https://www.oschina.net/android</a></p>\n</blockquote>\n<h2 id=\"2-6-Medium-国外\"><a href=\"#2-6-Medium-国外\" class=\"headerlink\" title=\"2.6 Medium(国外)\"></a>2.6 Medium(国外)</h2><h3 id=\"2-6-1-热门问答\"><a href=\"#2-6-1-热门问答\" class=\"headerlink\" title=\"2.6.1 热门问答\"></a>2.6.1 热门问答</h3><blockquote>\n<p><a href=\"https://medium.com/tag/android\">https://medium.com/tag/android</a></p>\n</blockquote>\n<h2 id=\"2-7-stackoverflow-国外\"><a href=\"#2-7-stackoverflow-国外\" class=\"headerlink\" title=\"2.7 stackoverflow(国外)\"></a>2.7 stackoverflow(国外)</h2><h3 id=\"2-7-1-热门问答\"><a href=\"#2-7-1-热门问答\" class=\"headerlink\" title=\"2.7.1 热门问答\"></a>2.7.1 热门问答</h3><blockquote>\n<p><a href=\"https://stackoverflow.com/questions/tagged/android\">https://stackoverflow.com/questions/tagged/android</a></p>\n</blockquote>\n<h2 id=\"2-8-Android周报（国外）\"><a href=\"#2-8-Android周报（国外）\" class=\"headerlink\" title=\"2.8 Android周报（国外）\"></a>2.8 Android周报（国外）</h2><blockquote>\n<p><a href=\"https://androidweekly.net/\">https://androidweekly.net/</a></p>\n</blockquote>\n<h2 id=\"2-9-codeKK\"><a href=\"#2-9-codeKK\" class=\"headerlink\" title=\"2.9 codeKK\"></a>2.9 codeKK</h2><h3 id=\"2-9-1-Github每日开源\"><a href=\"#2-9-1-Github每日开源\" class=\"headerlink\" title=\"2.9.1 Github每日开源\"></a>2.9.1 Github每日开源</h3><blockquote>\n<p><a href=\"https://p.codekk.com/\">https://p.codekk.com/</a></p>\n</blockquote>\n<h2 id=\"2-10-github相关\"><a href=\"#2-10-github相关\" class=\"headerlink\" title=\"2.10 github相关\"></a>2.10 github相关</h2><h3 id=\"2-10-1-关于kotlin每日趋势增长\"><a href=\"#2-10-1-关于kotlin每日趋势增长\" class=\"headerlink\" title=\"2.10.1 关于kotlin每日趋势增长\"></a>2.10.1 关于kotlin每日趋势增长</h3><blockquote>\n<p><a href=\"https://github.com/trending/kotlin?since=weekly\">https://github.com/trending/kotlin?since=daily</a></p>\n</blockquote>\n<h2 id=\"2-10-2-关于Android的话题\"><a href=\"#2-10-2-关于Android的话题\" class=\"headerlink\" title=\"2.10.2 关于Android的话题\"></a>2.10.2 关于Android的话题</h2><blockquote>\n<p><a href=\"https://github.com/topics/android\">https://github.com/topics/android</a></p>\n</blockquote>\n<h1 id=\"3-公众号\"><a href=\"#3-公众号\" class=\"headerlink\" title=\"3.公众号\"></a>3.公众号</h1><h2 id=\"3-1-鸿洋\"><a href=\"#3-1-鸿洋\" class=\"headerlink\" title=\"3.1 鸿洋\"></a>3.1 鸿洋</h2><img src=hongyang.jpeg>\n        \n<h2 id=\"3-2-郭霖\"><a href=\"#3-2-郭霖\" class=\"headerlink\" title=\"3.2 郭霖\"></a>3.2 郭霖</h2><img src=guolin.jpeg>\n        \n<h2 id=\"3-3-Carson\"><a href=\"#3-3-Carson\" class=\"headerlink\" title=\"3.3 Carson\"></a>3.3 Carson</h2><img src=carson.jpeg>\n        \n<h2 id=\"3-4-JsonChao\"><a href=\"#3-4-JsonChao\" class=\"headerlink\" title=\"3.4 JsonChao\"></a>3.4 JsonChao</h2><img src=jsonchao.jpeg>\n        \n<h2 id=\"3-5-Android群英传\"><a href=\"#3-5-Android群英传\" class=\"headerlink\" title=\"3.5 Android群英传\"></a>3.5 Android群英传</h2><img src=qunyingzhuan.jpeg>\n        \n<h2 id=\"3-6-Android编程精选\"><a href=\"#3-6-Android编程精选\" class=\"headerlink\" title=\"3.6 Android编程精选\"></a>3.6 Android编程精选</h2><img src=bianchengjingxuan.jpeg>\n        \n<h2 id=\"3-7-Android技术专家\"><a href=\"#3-7-Android技术专家\" class=\"headerlink\" title=\"3.7 Android技术专家\"></a>3.7 Android技术专家</h2><img src=jishuzhuanjia.jpeg>\n        \n<h2 id=\"3-8-Android技术圈\"><a href=\"#3-8-Android技术圈\" class=\"headerlink\" title=\"3.8 Android技术圈\"></a>3.8 Android技术圈</h2><img src=jishuquan.jpeg>\n        \n\n<h1 id=\"4-大神博客\"><a href=\"#4-大神博客\" class=\"headerlink\" title=\"4.大神博客\"></a>4.大神博客</h1><h2 id=\"4-1-jsonChao（平安）\"><a href=\"#4-1-jsonChao（平安）\" class=\"headerlink\" title=\"4.1 jsonChao（平安）\"></a>4.1 jsonChao（平安）</h2><blockquote>\n<p><a href=\"https://juejin.cn/user/4318537403878167/posts\">https://juejin.cn/user/4318537403878167/posts</a></p>\n</blockquote>\n<h2 id=\"4-2-鸿洋（百度）\"><a href=\"#4-2-鸿洋（百度）\" class=\"headerlink\" title=\"4.2 鸿洋（百度）\"></a>4.2 鸿洋（百度）</h2><blockquote>\n<p><a href=\"https://blog.csdn.net/lmj623565791/\">https://blog.csdn.net/lmj623565791/</a></p>\n</blockquote>\n<h2 id=\"4-3-郭霖\"><a href=\"#4-3-郭霖\" class=\"headerlink\" title=\"4.3 郭霖\"></a>4.3 郭霖</h2><blockquote>\n<p><a href=\"https://blog.csdn.net/guolin_blog/\">https://blog.csdn.net/guolin_blog&#x2F;</a></p>\n</blockquote>\n<h2 id=\"4-4-Carson（微信）\"><a href=\"#4-4-Carson（微信）\" class=\"headerlink\" title=\"4.4 Carson（微信）\"></a>4.4 Carson（微信）</h2><blockquote>\n<p><a href=\"https://www.jianshu.com/u/383970bef0a0\">https://www.jianshu.com/u/383970bef0a0</a></p>\n</blockquote>\n<h2 id=\"4-5-何强（魅族）\"><a href=\"#4-5-何强（魅族）\" class=\"headerlink\" title=\"4.5 何强（魅族）\"></a>4.5 何强（魅族）</h2><blockquote>\n<p><a href=\"https://www.heqiangfly.com/archives/\">https://www.heqiangfly.com/archives/</a></p>\n</blockquote>\n<h2 id=\"4-6-爱雨浮龙（阿里）\"><a href=\"#4-6-爱雨浮龙（阿里）\" class=\"headerlink\" title=\"4.6 爱雨浮龙（阿里）\"></a>4.6 爱雨浮龙（阿里）</h2><blockquote>\n<p><a href=\"https://juejin.cn/user/2805609405877415/posts\">https://juejin.cn/user/2805609405877415/posts</a></p>\n</blockquote>\n<h2 id=\"4-7-Android学习资源大全（19年后未更新了）\"><a href=\"#4-7-Android学习资源大全（19年后未更新了）\" class=\"headerlink\" title=\"4.7 Android学习资源大全（19年后未更新了）\"></a>4.7 Android学习资源大全（19年后未更新了）</h2><blockquote>\n<p><a href=\"https://juejin.cn/user/2805609405877415/posts\">https://juejin.cn/user/2805609405877415/posts</a></p>\n</blockquote>\n<h2 id=\"4-8-徐医生\"><a href=\"#4-8-徐医生\" class=\"headerlink\" title=\"4.8 徐医生\"></a>4.8 徐医生</h2><blockquote>\n<p><a href=\"https://blog.csdn.net/eclipsexys\">https://blog.csdn.net/eclipsexys</a></p>\n</blockquote>\n<h2 id=\"4-9-技术小黑屋\"><a href=\"#4-9-技术小黑屋\" class=\"headerlink\" title=\"4.9 技术小黑屋\"></a>4.9 技术小黑屋</h2><blockquote>\n<p><a href=\"https://droidyue.com/\">https://droidyue.com/</a></p>\n</blockquote>\n<h2 id=\"4-10-刘望舒\"><a href=\"#4-10-刘望舒\" class=\"headerlink\" title=\"4.10 刘望舒\"></a>4.10 刘望舒</h2><blockquote>\n<p><a href=\"https://liuwangshu.blog.csdn.net/\">https://liuwangshu.blog.csdn.net/</a></p>\n</blockquote>\n<h2 id=\"4-11-任玉刚\"><a href=\"#4-11-任玉刚\" class=\"headerlink\" title=\"4.11 任玉刚\"></a>4.11 任玉刚</h2><blockquote>\n<p><a href=\"https://blog.csdn.net/singwhatiwanna\">https://blog.csdn.net/singwhatiwanna</a></p>\n</blockquote>\n<h2 id=\"4-12-Gityuan\"><a href=\"#4-12-Gityuan\" class=\"headerlink\" title=\"4.12 Gityuan\"></a>4.12 Gityuan</h2><blockquote>\n<p><a href=\"http://gityuan.com/\">http://gityuan.com/</a></p>\n</blockquote>\n<h2 id=\"4-13-扔物线\"><a href=\"#4-13-扔物线\" class=\"headerlink\" title=\"4.13 扔物线\"></a>4.13 扔物线</h2><blockquote>\n<p><a href=\"https://rengwuxian.com/\">https://rengwuxian.com/</a></p>\n</blockquote>\n<h2 id=\"4-14-yrom\"><a href=\"#4-14-yrom\" class=\"headerlink\" title=\"4.14 yrom\"></a>4.14 yrom</h2><blockquote>\n<p><a href=\"https://yrom.net/archives/\">https://yrom.net/archives/</a></p>\n</blockquote>\n<h2 id=\"4-15-美团\"><a href=\"#4-15-美团\" class=\"headerlink\" title=\"4.15 美团\"></a>4.15 美团</h2><blockquote>\n<p><a href=\"https://tech.meituan.com/\">https://tech.meituan.com/</a></p>\n</blockquote>\n<h2 id=\"4-16-切切歆语\"><a href=\"#4-16-切切歆语\" class=\"headerlink\" title=\"4.16 切切歆语\"></a>4.16 切切歆语</h2><blockquote>\n<p><a href=\"https://blog.csdn.net/dickyqie/category_6238189.html\">https://blog.csdn.net/dickyqie/category_6238189.html</a></p>\n</blockquote>\n<h1 id=\"5-优秀三方库\"><a href=\"#5-优秀三方库\" class=\"headerlink\" title=\"5.优秀三方库\"></a>5.优秀三方库</h1><h2 id=\"5-1-网络相关\"><a href=\"#5-1-网络相关\" class=\"headerlink\" title=\"5.1 网络相关\"></a>5.1 网络相关</h2><h3 id=\"5-1-1-Retrofit\"><a href=\"#5-1-1-Retrofit\" class=\"headerlink\" title=\"5.1.1 Retrofit\"></a>5.1.1 Retrofit</h3><blockquote>\n<p><a href=\"https://github.com/square/retrofit\">https://github.com/square/retrofit</a></p>\n</blockquote>\n<h3 id=\"5-1-2-OKHttp\"><a href=\"#5-1-2-OKHttp\" class=\"headerlink\" title=\"5.1.2 OKHttp\"></a>5.1.2 OKHttp</h3><blockquote>\n<p><a href=\"https://github.com/square/okhttp\">https://github.com/square/okhttp</a></p>\n</blockquote>\n<h2 id=\"5-2-图片相关\"><a href=\"#5-2-图片相关\" class=\"headerlink\" title=\"5.2 图片相关\"></a>5.2 图片相关</h2><h3 id=\"5-2-1-Glide\"><a href=\"#5-2-1-Glide\" class=\"headerlink\" title=\"5.2.1 Glide\"></a>5.2.1 Glide</h3><blockquote>\n<p><a href=\"https://github.com/bumptech/glide\">https://github.com/bumptech/glide</a></p>\n</blockquote>\n<h2 id=\"5-3-响应式相关\"><a href=\"#5-3-响应式相关\" class=\"headerlink\" title=\"5.3 响应式相关\"></a>5.3 响应式相关</h2><h3 id=\"5-3-1-RxJava\"><a href=\"#5-3-1-RxJava\" class=\"headerlink\" title=\"5.3.1 RxJava\"></a>5.3.1 RxJava</h3><blockquote>\n<p><a href=\"https://github.com/ReactiveX/RxJava\">https://github.com/ReactiveX/RxJava</a></p>\n</blockquote>\n<h2 id=\"5-4-事件相关\"><a href=\"#5-4-事件相关\" class=\"headerlink\" title=\"5.4 事件相关\"></a>5.4 事件相关</h2><h3 id=\"5-4-1-EventBus\"><a href=\"#5-4-1-EventBus\" class=\"headerlink\" title=\"5.4.1 EventBus\"></a>5.4.1 EventBus</h3><blockquote>\n<p><a href=\"https://github.com/greenrobot/EventBus\">https://github.com/greenrobot/EventBus</a></p>\n</blockquote>\n<h2 id=\"5-5-数据库相关\"><a href=\"#5-5-数据库相关\" class=\"headerlink\" title=\"5.5 数据库相关\"></a>5.5 数据库相关</h2><h3 id=\"5-5-1-greenDAO\"><a href=\"#5-5-1-greenDAO\" class=\"headerlink\" title=\"5.5.1 greenDAO\"></a>5.5.1 greenDAO</h3><blockquote>\n<p><a href=\"https://github.com/greenrobot/greenDAO\">https://github.com/greenrobot/greenDAO</a></p>\n</blockquote>\n<h1 id=\"6-项目推荐\"><a href=\"#6-项目推荐\" class=\"headerlink\" title=\"6.项目推荐\"></a>6.项目推荐</h1><h2 id=\"6-1-wanAndroid项目推荐\"><a href=\"#6-1-wanAndroid项目推荐\" class=\"headerlink\" title=\"6.1 wanAndroid项目推荐\"></a>6.1 wanAndroid项目推荐</h2><blockquote>\n<p><a href=\"https://www.wanandroid.com/projectindex\">https://www.wanandroid.com/projectindex</a></p>\n</blockquote>\n<h2 id=\"6-2-官方demo-x3D-x3D-nowinandroid\"><a href=\"#6-2-官方demo-x3D-x3D-nowinandroid\" class=\"headerlink\" title=\"6.2 官方demo&#x3D;&#x3D;nowinandroid\"></a>6.2 官方demo&#x3D;&#x3D;nowinandroid</h2><blockquote>\n<p><a href=\"https://github.com/android/nowinandroid\">https://github.com/android/nowinandroidhttps://github.com/android/nowinandroid</a></p>\n</blockquote>\n<h2 id=\"6-3-emo-x3D-x3D-腾讯大神封装的compse基础UI\"><a href=\"#6-3-emo-x3D-x3D-腾讯大神封装的compse基础UI\" class=\"headerlink\" title=\"6.3 emo&#x3D;&#x3D;腾讯大神封装的compse基础UI\"></a>6.3 emo&#x3D;&#x3D;腾讯大神封装的compse基础UI</h2><blockquote>\n<p><a href=\"https://github.com/cgspine/emo\">https://github.com/cgspine/emo</a></p>\n</blockquote>\n<h1 id=\"7-其它\"><a href=\"#7-其它\" class=\"headerlink\" title=\"7.其它\"></a>7.其它</h1><h2 id=\"7-1-面试相关\"><a href=\"#7-1-面试相关\" class=\"headerlink\" title=\"7.1 面试相关\"></a>7.1 面试相关</h2><h2 id=\"7-2-开发工具相关\"><a href=\"#7-2-开发工具相关\" class=\"headerlink\" title=\"7.2 开发工具相关\"></a>7.2 开发工具相关</h2><h2 id=\"7-3-官方资源\"><a href=\"#7-3-官方资源\" class=\"headerlink\" title=\"7.3 官方资源\"></a>7.3 官方资源</h2><h3 id=\"7-3-1-Android官网\"><a href=\"#7-3-1-Android官网\" class=\"headerlink\" title=\"7.3.1 Android官网\"></a>7.3.1 Android官网</h3><blockquote>\n<p><a href=\"https://developer.android.google.cn/\">https://developer.android.google.cn/</a></p>\n</blockquote>\n<h3 id=\"7-3-2-Google-Samples\"><a href=\"#7-3-2-Google-Samples\" class=\"headerlink\" title=\"7.3.2 Google Samples\"></a>7.3.2 Google Samples</h3><blockquote>\n<p><a href=\"https://github.com/googlesamples\">https://github.com/googlesamples</a></p>\n</blockquote>\n<h2 id=\"7-4-随记\"><a href=\"#7-4-随记\" class=\"headerlink\" title=\"7.4 随记\"></a>7.4 随记</h2><h3 id=\"7-4-1-kotlin-let-also-run-with-用法\"><a href=\"#7-4-1-kotlin-let-also-run-with-用法\" class=\"headerlink\" title=\"7.4.1 kotlin let also run with 用法\"></a>7.4.1 kotlin let also run with 用法</h3><blockquote>\n<p><a href=\"https://juejin.cn/post/6868179386344931342\">https://juejin.cn/post/6868179386344931342</a></p>\n</blockquote>\n"},{"title":"iOS-swift-网络请求二次封装moya","date":"2023-02-01T08:44:45.000Z","top":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 github地址\n\n> [https://github.com/chensx1993/moyaManager](https://github.com/chensx1993/moyaManager)\n\n这个应该是一个小姐姐，我看到我们项目用了这个三方库，所以这边分析下封装细节。\n\n简单介绍下吧：\n\nmoya是对Alamofire的再次封装。它可以实现各种自定义配置，真正实现了对网络层的高度抽象。\n\n还有一个优秀的网络框架([github地址](https://github.com/mmoaay/Bamboots))，大家可以看看，跟`moya`对比一下。\n\n有关moya的介绍可以看看: [Moya的使用](https://www.jianshu.com/p/2ee5258828ff)。\n\n## 2 框架架构\n\n<img src=moya1.png>\n\n* Core应该是核心模块，存放网络状态管理员，Network.swift应该是最关键的暴露给开发者使用的类吧，所有的请求都是经过这层转发的，Request就是内部请求相关，比如get和post请求层的封装吧。\n\n* Extension是扩展层，这里扩展了String，也扩展了网络请求基础返回体，这里可以根据项目来。\n\n* Plugin是插件层，这个可以自由添加。\n\n* Server是网络层，这里我们可以定义一些通过的请求参数，比如token啥的。\n\n* API层，这就和我们自己定义的Api相关了，怎么请求，怎么传参这些定义。\n\n* Error层，这里应该是异常层了。\n\n## 3 实例分析\n\n这里我们考虑用一个真实案例，来深入分析这个封装框架如何实现网络请求的。\n这里就以登录接口为案例吧。\n\n可以建立一个登录相关接口，比如修改密码啥的，跟登录有关的统一用一个Manager。\n如下：\n```swift\nimport Foundation\nimport Moya\n\n// MARK: - 用户登录信息请求\nlet loginApiRequest = Networking<UserLoginAPIManagerService>()\n\n\nenum UserLoginAPIManagerService {\n    /// 账号密码登录\n    case userAccountLogin(userName:String, passWord:String)\n    /// 是否显示注册\n    case isShowRegister\n    /// 注册\n    case register(_ params: [String: Any])\n    /// 更新是否已经提醒用户修改密码标记\n    case signNotFirstLogin(userId:String)\n    /// 修改密码\n    case changePassword(newPassword:String, oldPassword:String, username:String)\n    /// 校验原密码\n    case checkOldPassword(oldPassword:String, username:String)\n    /// 登出\n    case logOut\n\n}\n\nextension UserLoginAPIManagerService : MyServerType {\n    \n    //域名\n    var baseURL: URL {\n        switch self {\n        case .register:\n            return URL(string: mainHost)!\n        case .isShowRegister:\n            return URL(string: mainHost)!\n        case .userAccountLogin:\n            return URL(string: LoginHost)!\n        case .signNotFirstLogin:\n            return URL(string: mainHost)!\n        case .changePassword,.checkOldPassword:\n            return URL(string: mainHost)!\n        default:\n            return URL(string: LoginHost)!\n        }\n        \n    }\n    \n    //接口路径\n    public var path: String {\n        switch self {\n        case .userAccountLogin:\n            return \"oauth/token\"\n        case .register:\n            return \"v1/user/Register\"\n        case.isShowRegister:\n            return \"v1/user/iosIsEnabled\"\n        case .signNotFirstLogin:\n            return \"v1/exposure/password/flag\"\n        case .changePassword:\n            return \"v1/user/reset/myself\"\n        case .logOut:\n            return \"ssoLogout\"\n        case .checkOldPassword:\n            return \"v1/user/check/reset-password\"\n        }\n    }\n    \n    //是否执行Alamofire验证\n    var validate: Bool {\n        return false\n    }\n    \n    //验证方式\n    var validationType: MyValidationType {\n        return .none\n    }\n    \n    //单元测试模拟的数据\n    var sampleData: Data {\n        return \"{}\".data(using: String.Encoding.utf8)!\n    }\n    \n    //请求类型：get、post、delete、put\n    var method: HTTPMethod {\n        switch self {\n        case .userAccountLogin(userName: _ , passWord: _),\n                .register,\n                .isShowRegister,\n                .changePassword,\n                .checkOldPassword:\n            return .post\n        default:\n            return .get\n        }\n    }\n    \n    //请求任务:\n    public var task: Task {\n        switch self {\n        case .userAccountLogin(let userName, let passWord):\n            let secret = \"1234\".toMD5\n            let params = [\"client_id\": clientId,\n                          \"client_secret\":secret,\n                          \"username\": userName,\n                          \"password\": passWord] as [String : Any]\n            return .requestParameters(parameters: params, encoding:URLEncoding.default)\n        case .register(let params):\n            return .requestParameters(parameters: params, encoding:JSONEncoding.default)\n        case .isShowRegister:\n            return .requestParameters(parameters: [: ], encoding: URLEncoding.default)\n        case .logOut:\n            return .requestPlain\n        case .signNotFirstLogin(let userId):\n            let params = [\"userId\": userId] as [String : Any]\n            return .requestParameters(parameters: params, encoding:URLEncoding.default)\n        case .changePassword(let newPassword, let oldPassword, let username):\n            let params = [\"newPassword\":newPassword,\n                          \"oldPassword\":oldPassword,\n                          \"username\": username] as [String : Any]\n            return .requestParameters(parameters: params, encoding: JSONEncoding.default)\n        case .checkOldPassword(let oldPassword, let username):\n            let params = [\"oldPassword\":oldPassword,\n                          \"username\": username] as [String : Any]\n            return .requestParameters(parameters: params, encoding: JSONEncoding.default)\n        }\n        \n    }\n    \n    //请求头\n    var appendHeaders: [String : String]? {\n        switch self {\n        case .register:\n            return [\"Content-Type\": \"application/json\"]\n        case .signNotFirstLogin,\n                .checkOldPassword,\n                .logOut:\n            return [: ]\n        case .changePassword:\n            return [\"menuPath\": MenuPath.changePassword.info]\n        default:\n            return [: ]\n        }\n    }\n    \n}\n```\n\n首先是建立了一个常量，一个Networking包装了MyServerType，当然这个MyServerType和Networking都是封装好的。主要操作就是自定义这个MyServerType了。\n\n这个接口基本就写好了。\n请求头可配置，参数可配置，接口路径可配置，后端怎么改都不怕了。\n\n然后就是我们调用的地方了。\n\n在登录的地方这样用：\n```swift\n loginApiRequest.requestJson(.userAccountLogin(userName: userName, passWord: safePassWord)) {result in\n    let json = JSON.init(rawValue: result)\n    if json?[\"code\"].intValue == 1000 {\n        MBProgressHUD.hide()\n        guard let model = UserInformationData.deserialize(from: json?[\"data\"].jsonString) else { return }\n        self.saveLoginSuccessUserInformation(model: model, userName: userName, passWord: passWord)\n        callBack(model)\n        \n        self.requestUploadLog(userName,1,\"登录成功\")\n    }else{\n        MBProgressHUD.hide()\n        let str = json?[\"message\"].stringValue ?? \"登录失败\"\n        GMToast.showFailure(str)\n        self.requestUploadLog(userName,0,str)\n    }\n    \n} failure: { error in\n    MBProgressHUD.hide()\n    GMToast.showFailure()\n}\n```\n\nloginApiRequest就是我们前面定义的登录类接口的常量。\n\n因为这是一个Networking，所有它有requestJson方法，这个方法也是框架自己二次封装好的，等下具体分析下这里面的代码即可。\n\n注意到这里有传参，需要关注下.userAccoutLogin是啥东西？\n> 原来就是我们定义的泛型类，MyServerType，这里.userAccountLogin是一个枚举也是一个MyServerType，我们可以在这里面添加请求参数，这样就关联起来了。\n\n```swift\nenum UserLoginAPIManagerService {\n    /// 账号密码登录\n    case userAccountLogin(userName:String, passWord:String)\n    /// 是否显示注册\n    case isShowRegister\n    /// 注册\n    case register(_ params: [String: Any])\n    /// 更新是否已经提醒用户修改密码标记\n    case signNotFirstLogin(userId:String)\n    /// 修改密码\n    case changePassword(newPassword:String, oldPassword:String, username:String)\n    /// 校验原密码\n    case checkOldPassword(oldPassword:String, username:String)\n    /// 登出\n    case logOut\n\n}\n```\n果然就是第一个“账号密码登录”。\n\n所有对于使用还是相当方便的，只需要写一个Manager，就可以很方便请求接口了。\n\n## 4 细节分析\n\n继续上面的案例，当我们发送json请求时，走了一个框架封装好的方法，看下：\n```swift\n@discardableResult\n    public func requestJson(_ target: T,\n                            callbackQueue: DispatchQueue? = DispatchQueue.main,\n                            progress: ProgressBlock? = .none,\n                            success: @escaping JsonSuccess,\n                            failure: @escaping Failure) -> Cancellable {\n        return self.request(target, callbackQueue: callbackQueue, progress: progress, success: { (response) in\n            do {\n                let result = try JSON.init(data: response.data)\n                let vc = UIViewController.current()\n                if vc is LoginPageViewController {}else{\n                    if response.statusCode == 403 || response.statusCode == 401 {\n                        //token过期\n                        if tokenInvalidHandle != nil {\n                            tokenInvalidHandle()\n                            return\n                        }\n                    }\n                }\n                #if DEBUG\n                    print(result)\n                #endif\n                success(result)\n            } catch (let error) {\n                failure(error as? NetworkError ?? NetworkError.invalidURL)\n            }\n        }) { (error) in\n            #if DEBUG\n                print(error)\n            #endif\n            failure(error)\n        }\n    }\n```\n这里继续走了内部的self.request方法，T就是我们自定义的MyServerType。\n里面回调是我们自己的逻辑，就是解析了下Json，然后就是403或401的时候，跳转了登录页，这里的逻辑不需要关注。\n\n看下内部的request方法吧：\n```swift\n@discardableResult\n    public func request(_ target: T,\n                        callbackQueue: DispatchQueue? = DispatchQueue.main,\n                        progress: ProgressBlock? = .none,\n                        success: @escaping Success,\n                        failure: @escaping Failure) -> Cancellable {\n        return self.provider.request(target, callbackQueue: callbackQueue, progress: progress) { (result) in\n            switch result {\n            case let .success(response):\n                #if DEBUG\n                if let body = response.request?.httpBody,\n                   let param = String(data: body, encoding: .utf8),\n                   let interface = response.request?.url {\n                    print(\"✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅\")\n                    print(\"接口地址：\\n\\(interface)\")\n                    print(\"✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅\")\n                    print(\"请求参数：\\n\\(param)\")\n                    print(\"✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅\")\n                }\n                #endif\n                success(response);\n            case let .failure(error):\n                #if DEBUG\n                print(\"❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌\")\n                print(error)\n                #endif\n                let err = NetworkError.init(error: error)\n                failure(err);\n                break\n            }\n        }\n    }\n```\n这里的回调队列，进度，都有默认实例，当然可以自由传递。\n另外就是成功和失败的逃逸闭包了。\n\n其实内部继续走了self.provider.request才是重中之重。\n\n\n### 4.1 生产Moya Provider\n首先看下provider怎么来的：\n```swift\npublic struct Networking<T: MyServerType> {\n    public let provider: MoyaProvider<T>\n    \n    public init(provider: MoyaProvider<T> = newDefaultProvider()) {\n        self.provider = provider\n    }\n}\n\npublic static func newDefaultProvider() -> MoyaProvider<T> {\n        return newProvider(plugins: plugins)\n}\n\n/// 如何新建MoyaProvider\nfunc newProvider<T>(plugins: [PluginType],session: Session = newManager()) -> MoyaProvider<T> where T: MyServerType {\n    \n    return MoyaProvider(endpointClosure: Networking<T>.endpointsClosure(),\n                        requestClosure: Networking<T>.endpointResolver(),\n                        stubClosure: Networking<T>.APIKeysBasedStubBehaviour,\n                        session: session,\n                        plugins: plugins,\n                        trackInflights: false\n    )\n}\n\n/// 新建Provider需要的参数1\nfunc newManager(delegate: SessionDelegate = SessionDelegate()) -> Session {\n//    let configuration = URLSessionConfiguration.default\n//    configuration.httpAdditionalHeaders = Alamofire.SessionManager.defaultHTTPHeaders\n    let configuration = Alamofire.Session.default.session.configuration\n    let session = Alamofire.Session(configuration: configuration, delegate: delegate, startRequestsImmediately: false)\n    return session\n}\n\n/// 新建Provider需要的参数2\nstatic var plugins: [PluginType] {\n        let activityPlugin = NewNetworkActivityPlugin { (state, targetType) in\n            switch state {\n            case .began:\n                if targetType.isShowLoading { //这是我扩展的协议\n                    // 显示loading\n                }\n            case .ended:\n                if targetType.isShowLoading { //这是我扩展的协议\n                    // 关闭loading\n                }\n            }\n        }\n        \n        return [\n            activityPlugin, myLoggorPlugin\n        ]\n    }\n\n```\n这里创建的时候，就默认传了一个默认的Provider，这个是Moya官方的哦。\n\n另外新建这个MoyaProvider的时候还需要3个闭包，我们通过Networking来生产：\n```swift\nstatic func endpointsClosure<T>() -> (T) -> Endpoint where T: MyServerType {\n    return { target in\n        var headers: [String: String] = target.headers ?? [:]\n        if apiEnvironment == .product {\n            //生产环境灰度\n            if canary == true {\n                headers[\"canary\"] = \"true\"\n            }\n        }\n        //生产环境api路径设置\n        var str = \"\"\n        str = URL(target: target).absoluteString\n        if apiEnvironment != .test && apiEnvironment != .dev {\n            str = str.replacingOccurrences(of: \"-test\", with: \"\", options: .literal, range: nil)\n        }\n        let absoluteString = str\n        let defaultEndpoint = Endpoint(\n            url: absoluteString,\n            sampleResponseClosure: { target.sampleResponse },\n            method: target.method,\n            task: target.task,\n            httpHeaderFields: headers\n        )\n        return defaultEndpoint;\n    }\n}\n\n//测试网络错误,如超时等.\nstatic func endpointResolver() -> MoyaProvider<T>.RequestClosure {\n    return { (endpoint, closure) in\n        do {\n            var request = try endpoint.urlRequest()\n            request.httpShouldHandleCookies = false\n            request.timeoutInterval = WebService.shared.timeoutInterval\n            closure(.success(request))\n        } catch let error {\n            closure(.failure(MoyaError.underlying(error, nil)))\n        }\n    }\n}   \n\nstatic func APIKeysBasedStubBehaviour<T>(_ target: T) -> Moya.StubBehavior where T: MyServerType {\n        return target.stubBehavior;\n    }\n```\n这里我们自己生产了3个闭包给moya，也是moya需要的3个闭包。\n\n### 4.2 继续走Provider的request\n\n```swift\n/// Designated request-making method. Returns a `Cancellable` token to cancel the request later.\n    @discardableResult\n    open func request(_ target: Target,\n                      callbackQueue: DispatchQueue? = .none,\n                      progress: ProgressBlock? = .none,\n                      completion: @escaping Completion) -> Cancellable {\n\n        let callbackQueue = callbackQueue ?? self.callbackQueue\n        return requestNormal(target, callbackQueue: callbackQueue, progress: progress, completion: completion)\n    }\n```\n这个是moya三方库里面的代码了，简单看下就好，不是我们这期重点。\n\n### 4.3 如何封装MyServerType\n\n个人感觉这个也是非常关键，我们外部使用，需要建立一个枚举，同时也是一个MyServerType，这个携带了请求参数，请求方法之类的，总之它包装了一切我们请求需要的东西。\n\n```swift\nimport Foundation\nimport Moya\n\npublic typealias HTTPMethod = Moya.Method\npublic typealias MyValidationType = Moya.ValidationType\npublic typealias MySampleResponse = Moya.EndpointSampleResponse\npublic typealias MyStubBehavior = Moya.StubBehavior\n\npublic protocol MyServerType: TargetType {\n    var isShowLoading: Bool { get }\n    /// 附加请求头（如需添加额外的，使用这个）\n    var appendHeaders: [String : String]? { get }\n    var parameters: [String: Any]? { get }\n    var stubBehavior: MyStubBehavior { get }\n    var sampleResponse: MySampleResponse { get }\n}\n```\n首先，它这个继承了Moya自己的TargetType，还增加了自己额外的一些协议。\n\n```swift\nextension MyServerType {\n    public var base: String { return WebService.shared.rootUrl}\n    \n    public var baseURL: URL { return URL(string: base)! }\n    /// 请求头 （默认请求头 + appendHeaders），需求添加额外的改appendHeaders\n    public var headers: [String : String]? {\n        var result: [String : String]? = WebService().headers\n        guard let appendHeaders = appendHeaders else { return result }\n        result = WebService().headers?.merging(appendHeaders, uniquingKeysWith: { (_, new) in new })\n        return result\n    }\n    public var appendHeaders: [String : String]? { return nil }\n    public var parameters: [String: Any]? { return WebService.shared.parameters }\n    \n    public var isShowLoading: Bool { return false }\n    \n    public var task: Task {\n        let encoding: ParameterEncoding\n        switch self.method {\n        case .post:\n            encoding = JSONEncoding.default\n        default:\n            encoding = URLEncoding.default\n        }\n        if let requestParameters = parameters {\n            return .requestParameters(parameters: requestParameters, encoding: encoding)\n        }\n        return .requestPlain\n    }\n    \n    \n    public var method: HTTPMethod {\n        return .post\n    }\n    \n    public var validationType: MyValidationType {\n        return .successCodes\n    }\n    \n    public var stubBehavior: StubBehavior {\n        return .never\n    }\n    \n    public var validate: Bool {\n        return false\n    }\n    \n    public var sampleData: Data {\n        return \"response: test data\".data(using: String.Encoding.utf8)!\n    }\n    \n    public var sampleResponse: MySampleResponse {\n        return .networkResponse(200, self.sampleData)\n    }\n}\n```\n这里应该是实现了默认值的设定。\n当然我们是可以更改的。\n\n```swift\nfunc myBaseUrl(_ path: String) -> String {\n    if path.isCompleteUrl { return path }\n    return WebService.shared.rootUrl;\n}\n\nfunc myPath(_ path: String) -> String {\n    if path.isCompleteUrl { return \"\" }\n    return path;\n}\n\nextension String {\n    var isCompleteUrl: Bool {\n        let scheme = self.lowercased()\n        if scheme.contains(\"http\") { return true }\n        return false\n    }\n}\n```\n然后是其它工具方法。\n\n这里有用到一个WebService类，这里面存放的也是一些默认值设定：\n```swift\nimport Foundation\nimport UIKit\nimport AdSupport\nimport Alamofire\nimport Moya\n\nclass WebService: NSObject {\n    \n    var rootUrl: String = mainHost\n    var headers: [String: String]? = defaultHeaders()\n    var parameters: [String: Any]? = defaultParameters()\n    var timeoutInterval: Double = 30.0\n    //和服务器时间相差的时间戳:备注每次app恢复活跃状态需更新一次\n    static var serviceTimeSpace: String?\n    \n    static let shared = WebService()\n    override init() {}\n    \n    static func defaultHeaders() -> [String : String]? {\n        var headers = [\"x-flag\": \"iOS\", \"serverName\": \"APP\", \"clientId\": clientId]\n        if let token = Defaults[key: DefaultsKeys.access_token] {\n            headers[\"Authorization\"] = \"Bearer\" + token\n        }\n        let isMonopoly = Defaults[key: DefaultsKeys.isMonopoly] ?? false\n        /// appVersion 字段，（1表示专业版，0表示简易版）\n        headers[\"appVersion\"] = isMonopoly ? \"0\" : \"1\"\n        return headers\n    }\n    \n    static func defaultParameters() -> [String : Any]? {\n        return [\"platform\" : \"ios\",\n            \"version\" : \"1.2.3\",\n        ]\n    }\n    \n    /**\n     获取当前app版本号\n     */\n    static func getAppShortVersion() -> String {\n        let infoDictionary = Bundle.main.infoDictionary!\n        let version = infoDictionary[\"CFBundleShortVersionString\"] as! String\n        return version\n    }\n    \n    /**\n    获取当前请求User-Agent\n     */\n    static func getUserAgent() -> String {\n        let infoDictionary = Bundle.main.infoDictionary!\n        let version = infoDictionary[\"CFBundleShortVersionString\"] as! String\n        let userAgent = String(format: \"GREEMall%@(%@; iOS %@; Scale/%.2f)\", version, UIDevice.current.model, UIDevice.current.systemVersion, UIScreen.main.scale)\n        \n        return userAgent\n    }\n    \n    /**\n    获取服务器时间和计算时间差\n     */\n    static func setServiceTimeInterval(timeInterval:TimeInterval) {\n        serviceTimeSpace = String(format: \"%@\", timeInterval)\n    }\n    \n    /**\n     获取服务器时间戳\n     */\n    static func getServiceTimeInterval() -> Int {\n        return Int(serviceTimeSpace!)!\n    }\n    \n    /**\n     设置请求统一参数\n     */\n    static func getSystemParameterData() -> Dictionary<String, String> {\n        var data = [String: String]()\n        data[\"source\"] = \"iOS\"\n        var timeSpace: String = \"\"\n        if serviceTimeSpace != nil {\n            let now: TimeInterval = Date.init().timeIntervalSince1970\n            let appTime: TimeInterval = now + Double(CLongLong(serviceTimeSpace!)!)\n            timeSpace = String(format:\"%@\", appTime)\n        } else {\n            timeSpace = String(format:\"%@\", Date.init().timeIntervalSince1970)\n        }\n        data[\"t\"] = timeSpace\n        data[\"version\"] = self.getAppShortVersion()\n        data[\"ios_idfa\"] = ASIdentifierManager.shared().advertisingIdentifier.uuidString\n        return data\n    }\n    \n    /**\n     签名MD5处理\n     */\n    static func appendSign(paramterDic: Dictionary<String, String>, secrekey:String) -> String {\n        var sign:String = \"\"\n        var keys:Array = Array(paramterDic.keys)\n        keys = keys.sorted()\n        for key:String in keys {\n            if key == \"sign\" {\n                continue\n            } else {\n                let keyValue: String = String(format: \"%@\", paramterDic[key]!)\n                sign.append(String(format: \"%@%@\", key, keyValue.EscapesValr))\n            }\n        }\n        sign.append(secrekey)\n        return sign.td.md5.uppercased()\n    }\n}\n```\n\n大致就是这样了。\n\n## 5 总结\n\n* 这个二次封装主要是基于Moya，简化moya流程，提供了一个MyServerType，封装了一些请求参数，请求方法，方便我们进行接口配置。\n\n* 使用方法很简单，不过需要将一类接口单独放置，全部放一起不方便管理，这里比如登录相关接口统一用一个Manger配置，接口参数都写在这个Manager里面，其实也是由一定好处的。\n\n* 这里将moya更加封装成一个系统了，我们需要的结果无非就是接口成功或失败，传参也是我们必要的，将必要的都封装起来了，总体上使用还是比较便捷。\n\n* 如果有特殊请求，比如下载文件这种，需要我们单独抽一个方法处理，这里稍微增加了一点复杂度吧，一般的请求还是可以直接使用的。","source":"_posts/iOS-swift-网络请求二次封装moya.md","raw":"---\ntitle: iOS-swift-网络请求二次封装moya\ndate: 2023-02-01 16:44:45\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- 网络请求\ncategories:\n- iOS\n---\n\n## 1 github地址\n\n> [https://github.com/chensx1993/moyaManager](https://github.com/chensx1993/moyaManager)\n\n这个应该是一个小姐姐，我看到我们项目用了这个三方库，所以这边分析下封装细节。\n\n简单介绍下吧：\n\nmoya是对Alamofire的再次封装。它可以实现各种自定义配置，真正实现了对网络层的高度抽象。\n\n还有一个优秀的网络框架([github地址](https://github.com/mmoaay/Bamboots))，大家可以看看，跟`moya`对比一下。\n\n有关moya的介绍可以看看: [Moya的使用](https://www.jianshu.com/p/2ee5258828ff)。\n\n## 2 框架架构\n\n<img src=moya1.png>\n\n* Core应该是核心模块，存放网络状态管理员，Network.swift应该是最关键的暴露给开发者使用的类吧，所有的请求都是经过这层转发的，Request就是内部请求相关，比如get和post请求层的封装吧。\n\n* Extension是扩展层，这里扩展了String，也扩展了网络请求基础返回体，这里可以根据项目来。\n\n* Plugin是插件层，这个可以自由添加。\n\n* Server是网络层，这里我们可以定义一些通过的请求参数，比如token啥的。\n\n* API层，这就和我们自己定义的Api相关了，怎么请求，怎么传参这些定义。\n\n* Error层，这里应该是异常层了。\n\n## 3 实例分析\n\n这里我们考虑用一个真实案例，来深入分析这个封装框架如何实现网络请求的。\n这里就以登录接口为案例吧。\n\n可以建立一个登录相关接口，比如修改密码啥的，跟登录有关的统一用一个Manager。\n如下：\n```swift\nimport Foundation\nimport Moya\n\n// MARK: - 用户登录信息请求\nlet loginApiRequest = Networking<UserLoginAPIManagerService>()\n\n\nenum UserLoginAPIManagerService {\n    /// 账号密码登录\n    case userAccountLogin(userName:String, passWord:String)\n    /// 是否显示注册\n    case isShowRegister\n    /// 注册\n    case register(_ params: [String: Any])\n    /// 更新是否已经提醒用户修改密码标记\n    case signNotFirstLogin(userId:String)\n    /// 修改密码\n    case changePassword(newPassword:String, oldPassword:String, username:String)\n    /// 校验原密码\n    case checkOldPassword(oldPassword:String, username:String)\n    /// 登出\n    case logOut\n\n}\n\nextension UserLoginAPIManagerService : MyServerType {\n    \n    //域名\n    var baseURL: URL {\n        switch self {\n        case .register:\n            return URL(string: mainHost)!\n        case .isShowRegister:\n            return URL(string: mainHost)!\n        case .userAccountLogin:\n            return URL(string: LoginHost)!\n        case .signNotFirstLogin:\n            return URL(string: mainHost)!\n        case .changePassword,.checkOldPassword:\n            return URL(string: mainHost)!\n        default:\n            return URL(string: LoginHost)!\n        }\n        \n    }\n    \n    //接口路径\n    public var path: String {\n        switch self {\n        case .userAccountLogin:\n            return \"oauth/token\"\n        case .register:\n            return \"v1/user/Register\"\n        case.isShowRegister:\n            return \"v1/user/iosIsEnabled\"\n        case .signNotFirstLogin:\n            return \"v1/exposure/password/flag\"\n        case .changePassword:\n            return \"v1/user/reset/myself\"\n        case .logOut:\n            return \"ssoLogout\"\n        case .checkOldPassword:\n            return \"v1/user/check/reset-password\"\n        }\n    }\n    \n    //是否执行Alamofire验证\n    var validate: Bool {\n        return false\n    }\n    \n    //验证方式\n    var validationType: MyValidationType {\n        return .none\n    }\n    \n    //单元测试模拟的数据\n    var sampleData: Data {\n        return \"{}\".data(using: String.Encoding.utf8)!\n    }\n    \n    //请求类型：get、post、delete、put\n    var method: HTTPMethod {\n        switch self {\n        case .userAccountLogin(userName: _ , passWord: _),\n                .register,\n                .isShowRegister,\n                .changePassword,\n                .checkOldPassword:\n            return .post\n        default:\n            return .get\n        }\n    }\n    \n    //请求任务:\n    public var task: Task {\n        switch self {\n        case .userAccountLogin(let userName, let passWord):\n            let secret = \"1234\".toMD5\n            let params = [\"client_id\": clientId,\n                          \"client_secret\":secret,\n                          \"username\": userName,\n                          \"password\": passWord] as [String : Any]\n            return .requestParameters(parameters: params, encoding:URLEncoding.default)\n        case .register(let params):\n            return .requestParameters(parameters: params, encoding:JSONEncoding.default)\n        case .isShowRegister:\n            return .requestParameters(parameters: [: ], encoding: URLEncoding.default)\n        case .logOut:\n            return .requestPlain\n        case .signNotFirstLogin(let userId):\n            let params = [\"userId\": userId] as [String : Any]\n            return .requestParameters(parameters: params, encoding:URLEncoding.default)\n        case .changePassword(let newPassword, let oldPassword, let username):\n            let params = [\"newPassword\":newPassword,\n                          \"oldPassword\":oldPassword,\n                          \"username\": username] as [String : Any]\n            return .requestParameters(parameters: params, encoding: JSONEncoding.default)\n        case .checkOldPassword(let oldPassword, let username):\n            let params = [\"oldPassword\":oldPassword,\n                          \"username\": username] as [String : Any]\n            return .requestParameters(parameters: params, encoding: JSONEncoding.default)\n        }\n        \n    }\n    \n    //请求头\n    var appendHeaders: [String : String]? {\n        switch self {\n        case .register:\n            return [\"Content-Type\": \"application/json\"]\n        case .signNotFirstLogin,\n                .checkOldPassword,\n                .logOut:\n            return [: ]\n        case .changePassword:\n            return [\"menuPath\": MenuPath.changePassword.info]\n        default:\n            return [: ]\n        }\n    }\n    \n}\n```\n\n首先是建立了一个常量，一个Networking包装了MyServerType，当然这个MyServerType和Networking都是封装好的。主要操作就是自定义这个MyServerType了。\n\n这个接口基本就写好了。\n请求头可配置，参数可配置，接口路径可配置，后端怎么改都不怕了。\n\n然后就是我们调用的地方了。\n\n在登录的地方这样用：\n```swift\n loginApiRequest.requestJson(.userAccountLogin(userName: userName, passWord: safePassWord)) {result in\n    let json = JSON.init(rawValue: result)\n    if json?[\"code\"].intValue == 1000 {\n        MBProgressHUD.hide()\n        guard let model = UserInformationData.deserialize(from: json?[\"data\"].jsonString) else { return }\n        self.saveLoginSuccessUserInformation(model: model, userName: userName, passWord: passWord)\n        callBack(model)\n        \n        self.requestUploadLog(userName,1,\"登录成功\")\n    }else{\n        MBProgressHUD.hide()\n        let str = json?[\"message\"].stringValue ?? \"登录失败\"\n        GMToast.showFailure(str)\n        self.requestUploadLog(userName,0,str)\n    }\n    \n} failure: { error in\n    MBProgressHUD.hide()\n    GMToast.showFailure()\n}\n```\n\nloginApiRequest就是我们前面定义的登录类接口的常量。\n\n因为这是一个Networking，所有它有requestJson方法，这个方法也是框架自己二次封装好的，等下具体分析下这里面的代码即可。\n\n注意到这里有传参，需要关注下.userAccoutLogin是啥东西？\n> 原来就是我们定义的泛型类，MyServerType，这里.userAccountLogin是一个枚举也是一个MyServerType，我们可以在这里面添加请求参数，这样就关联起来了。\n\n```swift\nenum UserLoginAPIManagerService {\n    /// 账号密码登录\n    case userAccountLogin(userName:String, passWord:String)\n    /// 是否显示注册\n    case isShowRegister\n    /// 注册\n    case register(_ params: [String: Any])\n    /// 更新是否已经提醒用户修改密码标记\n    case signNotFirstLogin(userId:String)\n    /// 修改密码\n    case changePassword(newPassword:String, oldPassword:String, username:String)\n    /// 校验原密码\n    case checkOldPassword(oldPassword:String, username:String)\n    /// 登出\n    case logOut\n\n}\n```\n果然就是第一个“账号密码登录”。\n\n所有对于使用还是相当方便的，只需要写一个Manager，就可以很方便请求接口了。\n\n## 4 细节分析\n\n继续上面的案例，当我们发送json请求时，走了一个框架封装好的方法，看下：\n```swift\n@discardableResult\n    public func requestJson(_ target: T,\n                            callbackQueue: DispatchQueue? = DispatchQueue.main,\n                            progress: ProgressBlock? = .none,\n                            success: @escaping JsonSuccess,\n                            failure: @escaping Failure) -> Cancellable {\n        return self.request(target, callbackQueue: callbackQueue, progress: progress, success: { (response) in\n            do {\n                let result = try JSON.init(data: response.data)\n                let vc = UIViewController.current()\n                if vc is LoginPageViewController {}else{\n                    if response.statusCode == 403 || response.statusCode == 401 {\n                        //token过期\n                        if tokenInvalidHandle != nil {\n                            tokenInvalidHandle()\n                            return\n                        }\n                    }\n                }\n                #if DEBUG\n                    print(result)\n                #endif\n                success(result)\n            } catch (let error) {\n                failure(error as? NetworkError ?? NetworkError.invalidURL)\n            }\n        }) { (error) in\n            #if DEBUG\n                print(error)\n            #endif\n            failure(error)\n        }\n    }\n```\n这里继续走了内部的self.request方法，T就是我们自定义的MyServerType。\n里面回调是我们自己的逻辑，就是解析了下Json，然后就是403或401的时候，跳转了登录页，这里的逻辑不需要关注。\n\n看下内部的request方法吧：\n```swift\n@discardableResult\n    public func request(_ target: T,\n                        callbackQueue: DispatchQueue? = DispatchQueue.main,\n                        progress: ProgressBlock? = .none,\n                        success: @escaping Success,\n                        failure: @escaping Failure) -> Cancellable {\n        return self.provider.request(target, callbackQueue: callbackQueue, progress: progress) { (result) in\n            switch result {\n            case let .success(response):\n                #if DEBUG\n                if let body = response.request?.httpBody,\n                   let param = String(data: body, encoding: .utf8),\n                   let interface = response.request?.url {\n                    print(\"✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅\")\n                    print(\"接口地址：\\n\\(interface)\")\n                    print(\"✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅\")\n                    print(\"请求参数：\\n\\(param)\")\n                    print(\"✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅\")\n                }\n                #endif\n                success(response);\n            case let .failure(error):\n                #if DEBUG\n                print(\"❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌\")\n                print(error)\n                #endif\n                let err = NetworkError.init(error: error)\n                failure(err);\n                break\n            }\n        }\n    }\n```\n这里的回调队列，进度，都有默认实例，当然可以自由传递。\n另外就是成功和失败的逃逸闭包了。\n\n其实内部继续走了self.provider.request才是重中之重。\n\n\n### 4.1 生产Moya Provider\n首先看下provider怎么来的：\n```swift\npublic struct Networking<T: MyServerType> {\n    public let provider: MoyaProvider<T>\n    \n    public init(provider: MoyaProvider<T> = newDefaultProvider()) {\n        self.provider = provider\n    }\n}\n\npublic static func newDefaultProvider() -> MoyaProvider<T> {\n        return newProvider(plugins: plugins)\n}\n\n/// 如何新建MoyaProvider\nfunc newProvider<T>(plugins: [PluginType],session: Session = newManager()) -> MoyaProvider<T> where T: MyServerType {\n    \n    return MoyaProvider(endpointClosure: Networking<T>.endpointsClosure(),\n                        requestClosure: Networking<T>.endpointResolver(),\n                        stubClosure: Networking<T>.APIKeysBasedStubBehaviour,\n                        session: session,\n                        plugins: plugins,\n                        trackInflights: false\n    )\n}\n\n/// 新建Provider需要的参数1\nfunc newManager(delegate: SessionDelegate = SessionDelegate()) -> Session {\n//    let configuration = URLSessionConfiguration.default\n//    configuration.httpAdditionalHeaders = Alamofire.SessionManager.defaultHTTPHeaders\n    let configuration = Alamofire.Session.default.session.configuration\n    let session = Alamofire.Session(configuration: configuration, delegate: delegate, startRequestsImmediately: false)\n    return session\n}\n\n/// 新建Provider需要的参数2\nstatic var plugins: [PluginType] {\n        let activityPlugin = NewNetworkActivityPlugin { (state, targetType) in\n            switch state {\n            case .began:\n                if targetType.isShowLoading { //这是我扩展的协议\n                    // 显示loading\n                }\n            case .ended:\n                if targetType.isShowLoading { //这是我扩展的协议\n                    // 关闭loading\n                }\n            }\n        }\n        \n        return [\n            activityPlugin, myLoggorPlugin\n        ]\n    }\n\n```\n这里创建的时候，就默认传了一个默认的Provider，这个是Moya官方的哦。\n\n另外新建这个MoyaProvider的时候还需要3个闭包，我们通过Networking来生产：\n```swift\nstatic func endpointsClosure<T>() -> (T) -> Endpoint where T: MyServerType {\n    return { target in\n        var headers: [String: String] = target.headers ?? [:]\n        if apiEnvironment == .product {\n            //生产环境灰度\n            if canary == true {\n                headers[\"canary\"] = \"true\"\n            }\n        }\n        //生产环境api路径设置\n        var str = \"\"\n        str = URL(target: target).absoluteString\n        if apiEnvironment != .test && apiEnvironment != .dev {\n            str = str.replacingOccurrences(of: \"-test\", with: \"\", options: .literal, range: nil)\n        }\n        let absoluteString = str\n        let defaultEndpoint = Endpoint(\n            url: absoluteString,\n            sampleResponseClosure: { target.sampleResponse },\n            method: target.method,\n            task: target.task,\n            httpHeaderFields: headers\n        )\n        return defaultEndpoint;\n    }\n}\n\n//测试网络错误,如超时等.\nstatic func endpointResolver() -> MoyaProvider<T>.RequestClosure {\n    return { (endpoint, closure) in\n        do {\n            var request = try endpoint.urlRequest()\n            request.httpShouldHandleCookies = false\n            request.timeoutInterval = WebService.shared.timeoutInterval\n            closure(.success(request))\n        } catch let error {\n            closure(.failure(MoyaError.underlying(error, nil)))\n        }\n    }\n}   \n\nstatic func APIKeysBasedStubBehaviour<T>(_ target: T) -> Moya.StubBehavior where T: MyServerType {\n        return target.stubBehavior;\n    }\n```\n这里我们自己生产了3个闭包给moya，也是moya需要的3个闭包。\n\n### 4.2 继续走Provider的request\n\n```swift\n/// Designated request-making method. Returns a `Cancellable` token to cancel the request later.\n    @discardableResult\n    open func request(_ target: Target,\n                      callbackQueue: DispatchQueue? = .none,\n                      progress: ProgressBlock? = .none,\n                      completion: @escaping Completion) -> Cancellable {\n\n        let callbackQueue = callbackQueue ?? self.callbackQueue\n        return requestNormal(target, callbackQueue: callbackQueue, progress: progress, completion: completion)\n    }\n```\n这个是moya三方库里面的代码了，简单看下就好，不是我们这期重点。\n\n### 4.3 如何封装MyServerType\n\n个人感觉这个也是非常关键，我们外部使用，需要建立一个枚举，同时也是一个MyServerType，这个携带了请求参数，请求方法之类的，总之它包装了一切我们请求需要的东西。\n\n```swift\nimport Foundation\nimport Moya\n\npublic typealias HTTPMethod = Moya.Method\npublic typealias MyValidationType = Moya.ValidationType\npublic typealias MySampleResponse = Moya.EndpointSampleResponse\npublic typealias MyStubBehavior = Moya.StubBehavior\n\npublic protocol MyServerType: TargetType {\n    var isShowLoading: Bool { get }\n    /// 附加请求头（如需添加额外的，使用这个）\n    var appendHeaders: [String : String]? { get }\n    var parameters: [String: Any]? { get }\n    var stubBehavior: MyStubBehavior { get }\n    var sampleResponse: MySampleResponse { get }\n}\n```\n首先，它这个继承了Moya自己的TargetType，还增加了自己额外的一些协议。\n\n```swift\nextension MyServerType {\n    public var base: String { return WebService.shared.rootUrl}\n    \n    public var baseURL: URL { return URL(string: base)! }\n    /// 请求头 （默认请求头 + appendHeaders），需求添加额外的改appendHeaders\n    public var headers: [String : String]? {\n        var result: [String : String]? = WebService().headers\n        guard let appendHeaders = appendHeaders else { return result }\n        result = WebService().headers?.merging(appendHeaders, uniquingKeysWith: { (_, new) in new })\n        return result\n    }\n    public var appendHeaders: [String : String]? { return nil }\n    public var parameters: [String: Any]? { return WebService.shared.parameters }\n    \n    public var isShowLoading: Bool { return false }\n    \n    public var task: Task {\n        let encoding: ParameterEncoding\n        switch self.method {\n        case .post:\n            encoding = JSONEncoding.default\n        default:\n            encoding = URLEncoding.default\n        }\n        if let requestParameters = parameters {\n            return .requestParameters(parameters: requestParameters, encoding: encoding)\n        }\n        return .requestPlain\n    }\n    \n    \n    public var method: HTTPMethod {\n        return .post\n    }\n    \n    public var validationType: MyValidationType {\n        return .successCodes\n    }\n    \n    public var stubBehavior: StubBehavior {\n        return .never\n    }\n    \n    public var validate: Bool {\n        return false\n    }\n    \n    public var sampleData: Data {\n        return \"response: test data\".data(using: String.Encoding.utf8)!\n    }\n    \n    public var sampleResponse: MySampleResponse {\n        return .networkResponse(200, self.sampleData)\n    }\n}\n```\n这里应该是实现了默认值的设定。\n当然我们是可以更改的。\n\n```swift\nfunc myBaseUrl(_ path: String) -> String {\n    if path.isCompleteUrl { return path }\n    return WebService.shared.rootUrl;\n}\n\nfunc myPath(_ path: String) -> String {\n    if path.isCompleteUrl { return \"\" }\n    return path;\n}\n\nextension String {\n    var isCompleteUrl: Bool {\n        let scheme = self.lowercased()\n        if scheme.contains(\"http\") { return true }\n        return false\n    }\n}\n```\n然后是其它工具方法。\n\n这里有用到一个WebService类，这里面存放的也是一些默认值设定：\n```swift\nimport Foundation\nimport UIKit\nimport AdSupport\nimport Alamofire\nimport Moya\n\nclass WebService: NSObject {\n    \n    var rootUrl: String = mainHost\n    var headers: [String: String]? = defaultHeaders()\n    var parameters: [String: Any]? = defaultParameters()\n    var timeoutInterval: Double = 30.0\n    //和服务器时间相差的时间戳:备注每次app恢复活跃状态需更新一次\n    static var serviceTimeSpace: String?\n    \n    static let shared = WebService()\n    override init() {}\n    \n    static func defaultHeaders() -> [String : String]? {\n        var headers = [\"x-flag\": \"iOS\", \"serverName\": \"APP\", \"clientId\": clientId]\n        if let token = Defaults[key: DefaultsKeys.access_token] {\n            headers[\"Authorization\"] = \"Bearer\" + token\n        }\n        let isMonopoly = Defaults[key: DefaultsKeys.isMonopoly] ?? false\n        /// appVersion 字段，（1表示专业版，0表示简易版）\n        headers[\"appVersion\"] = isMonopoly ? \"0\" : \"1\"\n        return headers\n    }\n    \n    static func defaultParameters() -> [String : Any]? {\n        return [\"platform\" : \"ios\",\n            \"version\" : \"1.2.3\",\n        ]\n    }\n    \n    /**\n     获取当前app版本号\n     */\n    static func getAppShortVersion() -> String {\n        let infoDictionary = Bundle.main.infoDictionary!\n        let version = infoDictionary[\"CFBundleShortVersionString\"] as! String\n        return version\n    }\n    \n    /**\n    获取当前请求User-Agent\n     */\n    static func getUserAgent() -> String {\n        let infoDictionary = Bundle.main.infoDictionary!\n        let version = infoDictionary[\"CFBundleShortVersionString\"] as! String\n        let userAgent = String(format: \"GREEMall%@(%@; iOS %@; Scale/%.2f)\", version, UIDevice.current.model, UIDevice.current.systemVersion, UIScreen.main.scale)\n        \n        return userAgent\n    }\n    \n    /**\n    获取服务器时间和计算时间差\n     */\n    static func setServiceTimeInterval(timeInterval:TimeInterval) {\n        serviceTimeSpace = String(format: \"%@\", timeInterval)\n    }\n    \n    /**\n     获取服务器时间戳\n     */\n    static func getServiceTimeInterval() -> Int {\n        return Int(serviceTimeSpace!)!\n    }\n    \n    /**\n     设置请求统一参数\n     */\n    static func getSystemParameterData() -> Dictionary<String, String> {\n        var data = [String: String]()\n        data[\"source\"] = \"iOS\"\n        var timeSpace: String = \"\"\n        if serviceTimeSpace != nil {\n            let now: TimeInterval = Date.init().timeIntervalSince1970\n            let appTime: TimeInterval = now + Double(CLongLong(serviceTimeSpace!)!)\n            timeSpace = String(format:\"%@\", appTime)\n        } else {\n            timeSpace = String(format:\"%@\", Date.init().timeIntervalSince1970)\n        }\n        data[\"t\"] = timeSpace\n        data[\"version\"] = self.getAppShortVersion()\n        data[\"ios_idfa\"] = ASIdentifierManager.shared().advertisingIdentifier.uuidString\n        return data\n    }\n    \n    /**\n     签名MD5处理\n     */\n    static func appendSign(paramterDic: Dictionary<String, String>, secrekey:String) -> String {\n        var sign:String = \"\"\n        var keys:Array = Array(paramterDic.keys)\n        keys = keys.sorted()\n        for key:String in keys {\n            if key == \"sign\" {\n                continue\n            } else {\n                let keyValue: String = String(format: \"%@\", paramterDic[key]!)\n                sign.append(String(format: \"%@%@\", key, keyValue.EscapesValr))\n            }\n        }\n        sign.append(secrekey)\n        return sign.td.md5.uppercased()\n    }\n}\n```\n\n大致就是这样了。\n\n## 5 总结\n\n* 这个二次封装主要是基于Moya，简化moya流程，提供了一个MyServerType，封装了一些请求参数，请求方法，方便我们进行接口配置。\n\n* 使用方法很简单，不过需要将一类接口单独放置，全部放一起不方便管理，这里比如登录相关接口统一用一个Manger配置，接口参数都写在这个Manager里面，其实也是由一定好处的。\n\n* 这里将moya更加封装成一个系统了，我们需要的结果无非就是接口成功或失败，传参也是我们必要的，将必要的都封装起来了，总体上使用还是比较便捷。\n\n* 如果有特殊请求，比如下载文件这种，需要我们单独抽一个方法处理，这里稍微增加了一点复杂度吧，一般的请求还是可以直接使用的。","slug":"iOS-swift-网络请求二次封装moya","published":1,"updated":"2023-02-01T07:17:16.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlhfhyu001hivv7299c0bkj","content":"<h2 id=\"1-github地址\"><a href=\"#1-github地址\" class=\"headerlink\" title=\"1 github地址\"></a>1 github地址</h2><blockquote>\n<p><a href=\"https://github.com/chensx1993/moyaManager\">https://github.com/chensx1993/moyaManager</a></p>\n</blockquote>\n<p>这个应该是一个小姐姐，我看到我们项目用了这个三方库，所以这边分析下封装细节。</p>\n<p>简单介绍下吧：</p>\n<p>moya是对Alamofire的再次封装。它可以实现各种自定义配置，真正实现了对网络层的高度抽象。</p>\n<p>还有一个优秀的网络框架(<a href=\"https://github.com/mmoaay/Bamboots\">github地址</a>)，大家可以看看，跟<code>moya</code>对比一下。</p>\n<p>有关moya的介绍可以看看: <a href=\"https://www.jianshu.com/p/2ee5258828ff\">Moya的使用</a>。</p>\n<h2 id=\"2-框架架构\"><a href=\"#2-框架架构\" class=\"headerlink\" title=\"2 框架架构\"></a>2 框架架构</h2><img src=moya1.png>\n\n<ul>\n<li><p>Core应该是核心模块，存放网络状态管理员，Network.swift应该是最关键的暴露给开发者使用的类吧，所有的请求都是经过这层转发的，Request就是内部请求相关，比如get和post请求层的封装吧。</p>\n</li>\n<li><p>Extension是扩展层，这里扩展了String，也扩展了网络请求基础返回体，这里可以根据项目来。</p>\n</li>\n<li><p>Plugin是插件层，这个可以自由添加。</p>\n</li>\n<li><p>Server是网络层，这里我们可以定义一些通过的请求参数，比如token啥的。</p>\n</li>\n<li><p>API层，这就和我们自己定义的Api相关了，怎么请求，怎么传参这些定义。</p>\n</li>\n<li><p>Error层，这里应该是异常层了。</p>\n</li>\n</ul>\n<h2 id=\"3-实例分析\"><a href=\"#3-实例分析\" class=\"headerlink\" title=\"3 实例分析\"></a>3 实例分析</h2><p>这里我们考虑用一个真实案例，来深入分析这个封装框架如何实现网络请求的。<br>这里就以登录接口为案例吧。</p>\n<p>可以建立一个登录相关接口，比如修改密码啥的，跟登录有关的统一用一个Manager。<br>如下：</p>\n<pre><code class=\"line-numbers language-swift\">import Foundation\nimport Moya\n\n// MARK: - 用户登录信息请求\nlet loginApiRequest = Networking&lt;UserLoginAPIManagerService&gt;()\n\n\nenum UserLoginAPIManagerService &#123;\n    /// 账号密码登录\n    case userAccountLogin(userName:String, passWord:String)\n    /// 是否显示注册\n    case isShowRegister\n    /// 注册\n    case register(_ params: [String: Any])\n    /// 更新是否已经提醒用户修改密码标记\n    case signNotFirstLogin(userId:String)\n    /// 修改密码\n    case changePassword(newPassword:String, oldPassword:String, username:String)\n    /// 校验原密码\n    case checkOldPassword(oldPassword:String, username:String)\n    /// 登出\n    case logOut\n\n&#125;\n\nextension UserLoginAPIManagerService : MyServerType &#123;\n    \n    //域名\n    var baseURL: URL &#123;\n        switch self &#123;\n        case .register:\n            return URL(string: mainHost)!\n        case .isShowRegister:\n            return URL(string: mainHost)!\n        case .userAccountLogin:\n            return URL(string: LoginHost)!\n        case .signNotFirstLogin:\n            return URL(string: mainHost)!\n        case .changePassword,.checkOldPassword:\n            return URL(string: mainHost)!\n        default:\n            return URL(string: LoginHost)!\n        &#125;\n        \n    &#125;\n    \n    //接口路径\n    public var path: String &#123;\n        switch self &#123;\n        case .userAccountLogin:\n            return &quot;oauth/token&quot;\n        case .register:\n            return &quot;v1/user/Register&quot;\n        case.isShowRegister:\n            return &quot;v1/user/iosIsEnabled&quot;\n        case .signNotFirstLogin:\n            return &quot;v1/exposure/password/flag&quot;\n        case .changePassword:\n            return &quot;v1/user/reset/myself&quot;\n        case .logOut:\n            return &quot;ssoLogout&quot;\n        case .checkOldPassword:\n            return &quot;v1/user/check/reset-password&quot;\n        &#125;\n    &#125;\n    \n    //是否执行Alamofire验证\n    var validate: Bool &#123;\n        return false\n    &#125;\n    \n    //验证方式\n    var validationType: MyValidationType &#123;\n        return .none\n    &#125;\n    \n    //单元测试模拟的数据\n    var sampleData: Data &#123;\n        return &quot;&#123;&#125;&quot;.data(using: String.Encoding.utf8)!\n    &#125;\n    \n    //请求类型：get、post、delete、put\n    var method: HTTPMethod &#123;\n        switch self &#123;\n        case .userAccountLogin(userName: _ , passWord: _),\n                .register,\n                .isShowRegister,\n                .changePassword,\n                .checkOldPassword:\n            return .post\n        default:\n            return .get\n        &#125;\n    &#125;\n    \n    //请求任务:\n    public var task: Task &#123;\n        switch self &#123;\n        case .userAccountLogin(let userName, let passWord):\n            let secret = &quot;1234&quot;.toMD5\n            let params = [&quot;client_id&quot;: clientId,\n                          &quot;client_secret&quot;:secret,\n                          &quot;username&quot;: userName,\n                          &quot;password&quot;: passWord] as [String : Any]\n            return .requestParameters(parameters: params, encoding:URLEncoding.default)\n        case .register(let params):\n            return .requestParameters(parameters: params, encoding:JSONEncoding.default)\n        case .isShowRegister:\n            return .requestParameters(parameters: [: ], encoding: URLEncoding.default)\n        case .logOut:\n            return .requestPlain\n        case .signNotFirstLogin(let userId):\n            let params = [&quot;userId&quot;: userId] as [String : Any]\n            return .requestParameters(parameters: params, encoding:URLEncoding.default)\n        case .changePassword(let newPassword, let oldPassword, let username):\n            let params = [&quot;newPassword&quot;:newPassword,\n                          &quot;oldPassword&quot;:oldPassword,\n                          &quot;username&quot;: username] as [String : Any]\n            return .requestParameters(parameters: params, encoding: JSONEncoding.default)\n        case .checkOldPassword(let oldPassword, let username):\n            let params = [&quot;oldPassword&quot;:oldPassword,\n                          &quot;username&quot;: username] as [String : Any]\n            return .requestParameters(parameters: params, encoding: JSONEncoding.default)\n        &#125;\n        \n    &#125;\n    \n    //请求头\n    var appendHeaders: [String : String]? &#123;\n        switch self &#123;\n        case .register:\n            return [&quot;Content-Type&quot;: &quot;application/json&quot;]\n        case .signNotFirstLogin,\n                .checkOldPassword,\n                .logOut:\n            return [: ]\n        case .changePassword:\n            return [&quot;menuPath&quot;: MenuPath.changePassword.info]\n        default:\n            return [: ]\n        &#125;\n    &#125;\n    \n&#125;\n</code></pre>\n<p>首先是建立了一个常量，一个Networking包装了MyServerType，当然这个MyServerType和Networking都是封装好的。主要操作就是自定义这个MyServerType了。</p>\n<p>这个接口基本就写好了。<br>请求头可配置，参数可配置，接口路径可配置，后端怎么改都不怕了。</p>\n<p>然后就是我们调用的地方了。</p>\n<p>在登录的地方这样用：</p>\n<pre><code class=\"line-numbers language-swift\"> loginApiRequest.requestJson(.userAccountLogin(userName: userName, passWord: safePassWord)) &#123;result in\n    let json = JSON.init(rawValue: result)\n    if json?[&quot;code&quot;].intValue == 1000 &#123;\n        MBProgressHUD.hide()\n        guard let model = UserInformationData.deserialize(from: json?[&quot;data&quot;].jsonString) else &#123; return &#125;\n        self.saveLoginSuccessUserInformation(model: model, userName: userName, passWord: passWord)\n        callBack(model)\n        \n        self.requestUploadLog(userName,1,&quot;登录成功&quot;)\n    &#125;else&#123;\n        MBProgressHUD.hide()\n        let str = json?[&quot;message&quot;].stringValue ?? &quot;登录失败&quot;\n        GMToast.showFailure(str)\n        self.requestUploadLog(userName,0,str)\n    &#125;\n    \n&#125; failure: &#123; error in\n    MBProgressHUD.hide()\n    GMToast.showFailure()\n&#125;\n</code></pre>\n<p>loginApiRequest就是我们前面定义的登录类接口的常量。</p>\n<p>因为这是一个Networking，所有它有requestJson方法，这个方法也是框架自己二次封装好的，等下具体分析下这里面的代码即可。</p>\n<p>注意到这里有传参，需要关注下.userAccoutLogin是啥东西？</p>\n<blockquote>\n<p>原来就是我们定义的泛型类，MyServerType，这里.userAccountLogin是一个枚举也是一个MyServerType，我们可以在这里面添加请求参数，这样就关联起来了。</p>\n</blockquote>\n<pre><code class=\"line-numbers language-swift\">enum UserLoginAPIManagerService &#123;\n    /// 账号密码登录\n    case userAccountLogin(userName:String, passWord:String)\n    /// 是否显示注册\n    case isShowRegister\n    /// 注册\n    case register(_ params: [String: Any])\n    /// 更新是否已经提醒用户修改密码标记\n    case signNotFirstLogin(userId:String)\n    /// 修改密码\n    case changePassword(newPassword:String, oldPassword:String, username:String)\n    /// 校验原密码\n    case checkOldPassword(oldPassword:String, username:String)\n    /// 登出\n    case logOut\n\n&#125;\n</code></pre>\n<p>果然就是第一个“账号密码登录”。</p>\n<p>所有对于使用还是相当方便的，只需要写一个Manager，就可以很方便请求接口了。</p>\n<h2 id=\"4-细节分析\"><a href=\"#4-细节分析\" class=\"headerlink\" title=\"4 细节分析\"></a>4 细节分析</h2><p>继续上面的案例，当我们发送json请求时，走了一个框架封装好的方法，看下：</p>\n<pre><code class=\"line-numbers language-swift\">@discardableResult\n    public func requestJson(_ target: T,\n                            callbackQueue: DispatchQueue? = DispatchQueue.main,\n                            progress: ProgressBlock? = .none,\n                            success: @escaping JsonSuccess,\n                            failure: @escaping Failure) -&gt; Cancellable &#123;\n        return self.request(target, callbackQueue: callbackQueue, progress: progress, success: &#123; (response) in\n            do &#123;\n                let result = try JSON.init(data: response.data)\n                let vc = UIViewController.current()\n                if vc is LoginPageViewController &#123;&#125;else&#123;\n                    if response.statusCode == 403 || response.statusCode == 401 &#123;\n                        //token过期\n                        if tokenInvalidHandle != nil &#123;\n                            tokenInvalidHandle()\n                            return\n                        &#125;\n                    &#125;\n                &#125;\n                #if DEBUG\n                    print(result)\n                #endif\n                success(result)\n            &#125; catch (let error) &#123;\n                failure(error as? NetworkError ?? NetworkError.invalidURL)\n            &#125;\n        &#125;) &#123; (error) in\n            #if DEBUG\n                print(error)\n            #endif\n            failure(error)\n        &#125;\n    &#125;\n</code></pre>\n<p>这里继续走了内部的self.request方法，T就是我们自定义的MyServerType。<br>里面回调是我们自己的逻辑，就是解析了下Json，然后就是403或401的时候，跳转了登录页，这里的逻辑不需要关注。</p>\n<p>看下内部的request方法吧：</p>\n<pre><code class=\"line-numbers language-swift\">@discardableResult\n    public func request(_ target: T,\n                        callbackQueue: DispatchQueue? = DispatchQueue.main,\n                        progress: ProgressBlock? = .none,\n                        success: @escaping Success,\n                        failure: @escaping Failure) -&gt; Cancellable &#123;\n        return self.provider.request(target, callbackQueue: callbackQueue, progress: progress) &#123; (result) in\n            switch result &#123;\n            case let .success(response):\n                #if DEBUG\n                if let body = response.request?.httpBody,\n                   let param = String(data: body, encoding: .utf8),\n                   let interface = response.request?.url &#123;\n                    print(&quot;✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅&quot;)\n                    print(&quot;接口地址：\\n\\(interface)&quot;)\n                    print(&quot;✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅&quot;)\n                    print(&quot;请求参数：\\n\\(param)&quot;)\n                    print(&quot;✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅&quot;)\n                &#125;\n                #endif\n                success(response);\n            case let .failure(error):\n                #if DEBUG\n                print(&quot;❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌&quot;)\n                print(error)\n                #endif\n                let err = NetworkError.init(error: error)\n                failure(err);\n                break\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>这里的回调队列，进度，都有默认实例，当然可以自由传递。<br>另外就是成功和失败的逃逸闭包了。</p>\n<p>其实内部继续走了self.provider.request才是重中之重。</p>\n<h3 id=\"4-1-生产Moya-Provider\"><a href=\"#4-1-生产Moya-Provider\" class=\"headerlink\" title=\"4.1 生产Moya Provider\"></a>4.1 生产Moya Provider</h3><p>首先看下provider怎么来的：</p>\n<pre><code class=\"line-numbers language-swift\">public struct Networking&lt;T: MyServerType&gt; &#123;\n    public let provider: MoyaProvider&lt;T&gt;\n    \n    public init(provider: MoyaProvider&lt;T&gt; = newDefaultProvider()) &#123;\n        self.provider = provider\n    &#125;\n&#125;\n\npublic static func newDefaultProvider() -&gt; MoyaProvider&lt;T&gt; &#123;\n        return newProvider(plugins: plugins)\n&#125;\n\n/// 如何新建MoyaProvider\nfunc newProvider&lt;T&gt;(plugins: [PluginType],session: Session = newManager()) -&gt; MoyaProvider&lt;T&gt; where T: MyServerType &#123;\n    \n    return MoyaProvider(endpointClosure: Networking&lt;T&gt;.endpointsClosure(),\n                        requestClosure: Networking&lt;T&gt;.endpointResolver(),\n                        stubClosure: Networking&lt;T&gt;.APIKeysBasedStubBehaviour,\n                        session: session,\n                        plugins: plugins,\n                        trackInflights: false\n    )\n&#125;\n\n/// 新建Provider需要的参数1\nfunc newManager(delegate: SessionDelegate = SessionDelegate()) -&gt; Session &#123;\n//    let configuration = URLSessionConfiguration.default\n//    configuration.httpAdditionalHeaders = Alamofire.SessionManager.defaultHTTPHeaders\n    let configuration = Alamofire.Session.default.session.configuration\n    let session = Alamofire.Session(configuration: configuration, delegate: delegate, startRequestsImmediately: false)\n    return session\n&#125;\n\n/// 新建Provider需要的参数2\nstatic var plugins: [PluginType] &#123;\n        let activityPlugin = NewNetworkActivityPlugin &#123; (state, targetType) in\n            switch state &#123;\n            case .began:\n                if targetType.isShowLoading &#123; //这是我扩展的协议\n                    // 显示loading\n                &#125;\n            case .ended:\n                if targetType.isShowLoading &#123; //这是我扩展的协议\n                    // 关闭loading\n                &#125;\n            &#125;\n        &#125;\n        \n        return [\n            activityPlugin, myLoggorPlugin\n        ]\n    &#125;\n</code></pre>\n<p>这里创建的时候，就默认传了一个默认的Provider，这个是Moya官方的哦。</p>\n<p>另外新建这个MoyaProvider的时候还需要3个闭包，我们通过Networking来生产：</p>\n<pre><code class=\"line-numbers language-swift\">static func endpointsClosure&lt;T&gt;() -&gt; (T) -&gt; Endpoint where T: MyServerType &#123;\n    return &#123; target in\n        var headers: [String: String] = target.headers ?? [:]\n        if apiEnvironment == .product &#123;\n            //生产环境灰度\n            if canary == true &#123;\n                headers[&quot;canary&quot;] = &quot;true&quot;\n            &#125;\n        &#125;\n        //生产环境api路径设置\n        var str = &quot;&quot;\n        str = URL(target: target).absoluteString\n        if apiEnvironment != .test &amp;&amp; apiEnvironment != .dev &#123;\n            str = str.replacingOccurrences(of: &quot;-test&quot;, with: &quot;&quot;, options: .literal, range: nil)\n        &#125;\n        let absoluteString = str\n        let defaultEndpoint = Endpoint(\n            url: absoluteString,\n            sampleResponseClosure: &#123; target.sampleResponse &#125;,\n            method: target.method,\n            task: target.task,\n            httpHeaderFields: headers\n        )\n        return defaultEndpoint;\n    &#125;\n&#125;\n\n//测试网络错误,如超时等.\nstatic func endpointResolver() -&gt; MoyaProvider&lt;T&gt;.RequestClosure &#123;\n    return &#123; (endpoint, closure) in\n        do &#123;\n            var request = try endpoint.urlRequest()\n            request.httpShouldHandleCookies = false\n            request.timeoutInterval = WebService.shared.timeoutInterval\n            closure(.success(request))\n        &#125; catch let error &#123;\n            closure(.failure(MoyaError.underlying(error, nil)))\n        &#125;\n    &#125;\n&#125;   \n\nstatic func APIKeysBasedStubBehaviour&lt;T&gt;(_ target: T) -&gt; Moya.StubBehavior where T: MyServerType &#123;\n        return target.stubBehavior;\n    &#125;\n</code></pre>\n<p>这里我们自己生产了3个闭包给moya，也是moya需要的3个闭包。</p>\n<h3 id=\"4-2-继续走Provider的request\"><a href=\"#4-2-继续走Provider的request\" class=\"headerlink\" title=\"4.2 继续走Provider的request\"></a>4.2 继续走Provider的request</h3><pre><code class=\"line-numbers language-swift\">/// Designated request-making method. Returns a `Cancellable` token to cancel the request later.\n    @discardableResult\n    open func request(_ target: Target,\n                      callbackQueue: DispatchQueue? = .none,\n                      progress: ProgressBlock? = .none,\n                      completion: @escaping Completion) -&gt; Cancellable &#123;\n\n        let callbackQueue = callbackQueue ?? self.callbackQueue\n        return requestNormal(target, callbackQueue: callbackQueue, progress: progress, completion: completion)\n    &#125;\n</code></pre>\n<p>这个是moya三方库里面的代码了，简单看下就好，不是我们这期重点。</p>\n<h3 id=\"4-3-如何封装MyServerType\"><a href=\"#4-3-如何封装MyServerType\" class=\"headerlink\" title=\"4.3 如何封装MyServerType\"></a>4.3 如何封装MyServerType</h3><p>个人感觉这个也是非常关键，我们外部使用，需要建立一个枚举，同时也是一个MyServerType，这个携带了请求参数，请求方法之类的，总之它包装了一切我们请求需要的东西。</p>\n<pre><code class=\"line-numbers language-swift\">import Foundation\nimport Moya\n\npublic typealias HTTPMethod = Moya.Method\npublic typealias MyValidationType = Moya.ValidationType\npublic typealias MySampleResponse = Moya.EndpointSampleResponse\npublic typealias MyStubBehavior = Moya.StubBehavior\n\npublic protocol MyServerType: TargetType &#123;\n    var isShowLoading: Bool &#123; get &#125;\n    /// 附加请求头（如需添加额外的，使用这个）\n    var appendHeaders: [String : String]? &#123; get &#125;\n    var parameters: [String: Any]? &#123; get &#125;\n    var stubBehavior: MyStubBehavior &#123; get &#125;\n    var sampleResponse: MySampleResponse &#123; get &#125;\n&#125;\n</code></pre>\n<p>首先，它这个继承了Moya自己的TargetType，还增加了自己额外的一些协议。</p>\n<pre><code class=\"line-numbers language-swift\">extension MyServerType &#123;\n    public var base: String &#123; return WebService.shared.rootUrl&#125;\n    \n    public var baseURL: URL &#123; return URL(string: base)! &#125;\n    /// 请求头 （默认请求头 + appendHeaders），需求添加额外的改appendHeaders\n    public var headers: [String : String]? &#123;\n        var result: [String : String]? = WebService().headers\n        guard let appendHeaders = appendHeaders else &#123; return result &#125;\n        result = WebService().headers?.merging(appendHeaders, uniquingKeysWith: &#123; (_, new) in new &#125;)\n        return result\n    &#125;\n    public var appendHeaders: [String : String]? &#123; return nil &#125;\n    public var parameters: [String: Any]? &#123; return WebService.shared.parameters &#125;\n    \n    public var isShowLoading: Bool &#123; return false &#125;\n    \n    public var task: Task &#123;\n        let encoding: ParameterEncoding\n        switch self.method &#123;\n        case .post:\n            encoding = JSONEncoding.default\n        default:\n            encoding = URLEncoding.default\n        &#125;\n        if let requestParameters = parameters &#123;\n            return .requestParameters(parameters: requestParameters, encoding: encoding)\n        &#125;\n        return .requestPlain\n    &#125;\n    \n    \n    public var method: HTTPMethod &#123;\n        return .post\n    &#125;\n    \n    public var validationType: MyValidationType &#123;\n        return .successCodes\n    &#125;\n    \n    public var stubBehavior: StubBehavior &#123;\n        return .never\n    &#125;\n    \n    public var validate: Bool &#123;\n        return false\n    &#125;\n    \n    public var sampleData: Data &#123;\n        return &quot;response: test data&quot;.data(using: String.Encoding.utf8)!\n    &#125;\n    \n    public var sampleResponse: MySampleResponse &#123;\n        return .networkResponse(200, self.sampleData)\n    &#125;\n&#125;\n</code></pre>\n<p>这里应该是实现了默认值的设定。<br>当然我们是可以更改的。</p>\n<pre><code class=\"line-numbers language-swift\">func myBaseUrl(_ path: String) -&gt; String &#123;\n    if path.isCompleteUrl &#123; return path &#125;\n    return WebService.shared.rootUrl;\n&#125;\n\nfunc myPath(_ path: String) -&gt; String &#123;\n    if path.isCompleteUrl &#123; return &quot;&quot; &#125;\n    return path;\n&#125;\n\nextension String &#123;\n    var isCompleteUrl: Bool &#123;\n        let scheme = self.lowercased()\n        if scheme.contains(&quot;http&quot;) &#123; return true &#125;\n        return false\n    &#125;\n&#125;\n</code></pre>\n<p>然后是其它工具方法。</p>\n<p>这里有用到一个WebService类，这里面存放的也是一些默认值设定：</p>\n<pre><code class=\"line-numbers language-swift\">import Foundation\nimport UIKit\nimport AdSupport\nimport Alamofire\nimport Moya\n\nclass WebService: NSObject &#123;\n    \n    var rootUrl: String = mainHost\n    var headers: [String: String]? = defaultHeaders()\n    var parameters: [String: Any]? = defaultParameters()\n    var timeoutInterval: Double = 30.0\n    //和服务器时间相差的时间戳:备注每次app恢复活跃状态需更新一次\n    static var serviceTimeSpace: String?\n    \n    static let shared = WebService()\n    override init() &#123;&#125;\n    \n    static func defaultHeaders() -&gt; [String : String]? &#123;\n        var headers = [&quot;x-flag&quot;: &quot;iOS&quot;, &quot;serverName&quot;: &quot;APP&quot;, &quot;clientId&quot;: clientId]\n        if let token = Defaults[key: DefaultsKeys.access_token] &#123;\n            headers[&quot;Authorization&quot;] = &quot;Bearer&quot; + token\n        &#125;\n        let isMonopoly = Defaults[key: DefaultsKeys.isMonopoly] ?? false\n        /// appVersion 字段，（1表示专业版，0表示简易版）\n        headers[&quot;appVersion&quot;] = isMonopoly ? &quot;0&quot; : &quot;1&quot;\n        return headers\n    &#125;\n    \n    static func defaultParameters() -&gt; [String : Any]? &#123;\n        return [&quot;platform&quot; : &quot;ios&quot;,\n            &quot;version&quot; : &quot;1.2.3&quot;,\n        ]\n    &#125;\n    \n    /**\n     获取当前app版本号\n     */\n    static func getAppShortVersion() -&gt; String &#123;\n        let infoDictionary = Bundle.main.infoDictionary!\n        let version = infoDictionary[&quot;CFBundleShortVersionString&quot;] as! String\n        return version\n    &#125;\n    \n    /**\n    获取当前请求User-Agent\n     */\n    static func getUserAgent() -&gt; String &#123;\n        let infoDictionary = Bundle.main.infoDictionary!\n        let version = infoDictionary[&quot;CFBundleShortVersionString&quot;] as! String\n        let userAgent = String(format: &quot;GREEMall%@(%@; iOS %@; Scale/%.2f)&quot;, version, UIDevice.current.model, UIDevice.current.systemVersion, UIScreen.main.scale)\n        \n        return userAgent\n    &#125;\n    \n    /**\n    获取服务器时间和计算时间差\n     */\n    static func setServiceTimeInterval(timeInterval:TimeInterval) &#123;\n        serviceTimeSpace = String(format: &quot;%@&quot;, timeInterval)\n    &#125;\n    \n    /**\n     获取服务器时间戳\n     */\n    static func getServiceTimeInterval() -&gt; Int &#123;\n        return Int(serviceTimeSpace!)!\n    &#125;\n    \n    /**\n     设置请求统一参数\n     */\n    static func getSystemParameterData() -&gt; Dictionary&lt;String, String&gt; &#123;\n        var data = [String: String]()\n        data[&quot;source&quot;] = &quot;iOS&quot;\n        var timeSpace: String = &quot;&quot;\n        if serviceTimeSpace != nil &#123;\n            let now: TimeInterval = Date.init().timeIntervalSince1970\n            let appTime: TimeInterval = now + Double(CLongLong(serviceTimeSpace!)!)\n            timeSpace = String(format:&quot;%@&quot;, appTime)\n        &#125; else &#123;\n            timeSpace = String(format:&quot;%@&quot;, Date.init().timeIntervalSince1970)\n        &#125;\n        data[&quot;t&quot;] = timeSpace\n        data[&quot;version&quot;] = self.getAppShortVersion()\n        data[&quot;ios_idfa&quot;] = ASIdentifierManager.shared().advertisingIdentifier.uuidString\n        return data\n    &#125;\n    \n    /**\n     签名MD5处理\n     */\n    static func appendSign(paramterDic: Dictionary&lt;String, String&gt;, secrekey:String) -&gt; String &#123;\n        var sign:String = &quot;&quot;\n        var keys:Array = Array(paramterDic.keys)\n        keys = keys.sorted()\n        for key:String in keys &#123;\n            if key == &quot;sign&quot; &#123;\n                continue\n            &#125; else &#123;\n                let keyValue: String = String(format: &quot;%@&quot;, paramterDic[key]!)\n                sign.append(String(format: &quot;%@%@&quot;, key, keyValue.EscapesValr))\n            &#125;\n        &#125;\n        sign.append(secrekey)\n        return sign.td.md5.uppercased()\n    &#125;\n&#125;\n</code></pre>\n<p>大致就是这样了。</p>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5 总结\"></a>5 总结</h2><ul>\n<li><p>这个二次封装主要是基于Moya，简化moya流程，提供了一个MyServerType，封装了一些请求参数，请求方法，方便我们进行接口配置。</p>\n</li>\n<li><p>使用方法很简单，不过需要将一类接口单独放置，全部放一起不方便管理，这里比如登录相关接口统一用一个Manger配置，接口参数都写在这个Manager里面，其实也是由一定好处的。</p>\n</li>\n<li><p>这里将moya更加封装成一个系统了，我们需要的结果无非就是接口成功或失败，传参也是我们必要的，将必要的都封装起来了，总体上使用还是比较便捷。</p>\n</li>\n<li><p>如果有特殊请求，比如下载文件这种，需要我们单独抽一个方法处理，这里稍微增加了一点复杂度吧，一般的请求还是可以直接使用的。</p>\n</li>\n</ul>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-github地址\"><a href=\"#1-github地址\" class=\"headerlink\" title=\"1 github地址\"></a>1 github地址</h2><blockquote>\n<p><a href=\"https://github.com/chensx1993/moyaManager\">https://github.com/chensx1993/moyaManager</a></p>\n</blockquote>\n<p>这个应该是一个小姐姐，我看到我们项目用了这个三方库，所以这边分析下封装细节。</p>\n<p>简单介绍下吧：</p>\n<p>moya是对Alamofire的再次封装。它可以实现各种自定义配置，真正实现了对网络层的高度抽象。</p>\n<p>还有一个优秀的网络框架(<a href=\"https://github.com/mmoaay/Bamboots\">github地址</a>)，大家可以看看，跟<code>moya</code>对比一下。</p>\n<p>有关moya的介绍可以看看: <a href=\"https://www.jianshu.com/p/2ee5258828ff\">Moya的使用</a>。</p>\n<h2 id=\"2-框架架构\"><a href=\"#2-框架架构\" class=\"headerlink\" title=\"2 框架架构\"></a>2 框架架构</h2><img src=moya1.png>\n\n<ul>\n<li><p>Core应该是核心模块，存放网络状态管理员，Network.swift应该是最关键的暴露给开发者使用的类吧，所有的请求都是经过这层转发的，Request就是内部请求相关，比如get和post请求层的封装吧。</p>\n</li>\n<li><p>Extension是扩展层，这里扩展了String，也扩展了网络请求基础返回体，这里可以根据项目来。</p>\n</li>\n<li><p>Plugin是插件层，这个可以自由添加。</p>\n</li>\n<li><p>Server是网络层，这里我们可以定义一些通过的请求参数，比如token啥的。</p>\n</li>\n<li><p>API层，这就和我们自己定义的Api相关了，怎么请求，怎么传参这些定义。</p>\n</li>\n<li><p>Error层，这里应该是异常层了。</p>\n</li>\n</ul>\n<h2 id=\"3-实例分析\"><a href=\"#3-实例分析\" class=\"headerlink\" title=\"3 实例分析\"></a>3 实例分析</h2><p>这里我们考虑用一个真实案例，来深入分析这个封装框架如何实现网络请求的。<br>这里就以登录接口为案例吧。</p>\n<p>可以建立一个登录相关接口，比如修改密码啥的，跟登录有关的统一用一个Manager。<br>如下：</p>\n<pre><code class=\"line-numbers language-swift\">import Foundation\nimport Moya\n\n// MARK: - 用户登录信息请求\nlet loginApiRequest = Networking&lt;UserLoginAPIManagerService&gt;()\n\n\nenum UserLoginAPIManagerService &#123;\n    /// 账号密码登录\n    case userAccountLogin(userName:String, passWord:String)\n    /// 是否显示注册\n    case isShowRegister\n    /// 注册\n    case register(_ params: [String: Any])\n    /// 更新是否已经提醒用户修改密码标记\n    case signNotFirstLogin(userId:String)\n    /// 修改密码\n    case changePassword(newPassword:String, oldPassword:String, username:String)\n    /// 校验原密码\n    case checkOldPassword(oldPassword:String, username:String)\n    /// 登出\n    case logOut\n\n&#125;\n\nextension UserLoginAPIManagerService : MyServerType &#123;\n    \n    //域名\n    var baseURL: URL &#123;\n        switch self &#123;\n        case .register:\n            return URL(string: mainHost)!\n        case .isShowRegister:\n            return URL(string: mainHost)!\n        case .userAccountLogin:\n            return URL(string: LoginHost)!\n        case .signNotFirstLogin:\n            return URL(string: mainHost)!\n        case .changePassword,.checkOldPassword:\n            return URL(string: mainHost)!\n        default:\n            return URL(string: LoginHost)!\n        &#125;\n        \n    &#125;\n    \n    //接口路径\n    public var path: String &#123;\n        switch self &#123;\n        case .userAccountLogin:\n            return &quot;oauth/token&quot;\n        case .register:\n            return &quot;v1/user/Register&quot;\n        case.isShowRegister:\n            return &quot;v1/user/iosIsEnabled&quot;\n        case .signNotFirstLogin:\n            return &quot;v1/exposure/password/flag&quot;\n        case .changePassword:\n            return &quot;v1/user/reset/myself&quot;\n        case .logOut:\n            return &quot;ssoLogout&quot;\n        case .checkOldPassword:\n            return &quot;v1/user/check/reset-password&quot;\n        &#125;\n    &#125;\n    \n    //是否执行Alamofire验证\n    var validate: Bool &#123;\n        return false\n    &#125;\n    \n    //验证方式\n    var validationType: MyValidationType &#123;\n        return .none\n    &#125;\n    \n    //单元测试模拟的数据\n    var sampleData: Data &#123;\n        return &quot;&#123;&#125;&quot;.data(using: String.Encoding.utf8)!\n    &#125;\n    \n    //请求类型：get、post、delete、put\n    var method: HTTPMethod &#123;\n        switch self &#123;\n        case .userAccountLogin(userName: _ , passWord: _),\n                .register,\n                .isShowRegister,\n                .changePassword,\n                .checkOldPassword:\n            return .post\n        default:\n            return .get\n        &#125;\n    &#125;\n    \n    //请求任务:\n    public var task: Task &#123;\n        switch self &#123;\n        case .userAccountLogin(let userName, let passWord):\n            let secret = &quot;1234&quot;.toMD5\n            let params = [&quot;client_id&quot;: clientId,\n                          &quot;client_secret&quot;:secret,\n                          &quot;username&quot;: userName,\n                          &quot;password&quot;: passWord] as [String : Any]\n            return .requestParameters(parameters: params, encoding:URLEncoding.default)\n        case .register(let params):\n            return .requestParameters(parameters: params, encoding:JSONEncoding.default)\n        case .isShowRegister:\n            return .requestParameters(parameters: [: ], encoding: URLEncoding.default)\n        case .logOut:\n            return .requestPlain\n        case .signNotFirstLogin(let userId):\n            let params = [&quot;userId&quot;: userId] as [String : Any]\n            return .requestParameters(parameters: params, encoding:URLEncoding.default)\n        case .changePassword(let newPassword, let oldPassword, let username):\n            let params = [&quot;newPassword&quot;:newPassword,\n                          &quot;oldPassword&quot;:oldPassword,\n                          &quot;username&quot;: username] as [String : Any]\n            return .requestParameters(parameters: params, encoding: JSONEncoding.default)\n        case .checkOldPassword(let oldPassword, let username):\n            let params = [&quot;oldPassword&quot;:oldPassword,\n                          &quot;username&quot;: username] as [String : Any]\n            return .requestParameters(parameters: params, encoding: JSONEncoding.default)\n        &#125;\n        \n    &#125;\n    \n    //请求头\n    var appendHeaders: [String : String]? &#123;\n        switch self &#123;\n        case .register:\n            return [&quot;Content-Type&quot;: &quot;application/json&quot;]\n        case .signNotFirstLogin,\n                .checkOldPassword,\n                .logOut:\n            return [: ]\n        case .changePassword:\n            return [&quot;menuPath&quot;: MenuPath.changePassword.info]\n        default:\n            return [: ]\n        &#125;\n    &#125;\n    \n&#125;\n</code></pre>\n<p>首先是建立了一个常量，一个Networking包装了MyServerType，当然这个MyServerType和Networking都是封装好的。主要操作就是自定义这个MyServerType了。</p>\n<p>这个接口基本就写好了。<br>请求头可配置，参数可配置，接口路径可配置，后端怎么改都不怕了。</p>\n<p>然后就是我们调用的地方了。</p>\n<p>在登录的地方这样用：</p>\n<pre><code class=\"line-numbers language-swift\"> loginApiRequest.requestJson(.userAccountLogin(userName: userName, passWord: safePassWord)) &#123;result in\n    let json = JSON.init(rawValue: result)\n    if json?[&quot;code&quot;].intValue == 1000 &#123;\n        MBProgressHUD.hide()\n        guard let model = UserInformationData.deserialize(from: json?[&quot;data&quot;].jsonString) else &#123; return &#125;\n        self.saveLoginSuccessUserInformation(model: model, userName: userName, passWord: passWord)\n        callBack(model)\n        \n        self.requestUploadLog(userName,1,&quot;登录成功&quot;)\n    &#125;else&#123;\n        MBProgressHUD.hide()\n        let str = json?[&quot;message&quot;].stringValue ?? &quot;登录失败&quot;\n        GMToast.showFailure(str)\n        self.requestUploadLog(userName,0,str)\n    &#125;\n    \n&#125; failure: &#123; error in\n    MBProgressHUD.hide()\n    GMToast.showFailure()\n&#125;\n</code></pre>\n<p>loginApiRequest就是我们前面定义的登录类接口的常量。</p>\n<p>因为这是一个Networking，所有它有requestJson方法，这个方法也是框架自己二次封装好的，等下具体分析下这里面的代码即可。</p>\n<p>注意到这里有传参，需要关注下.userAccoutLogin是啥东西？</p>\n<blockquote>\n<p>原来就是我们定义的泛型类，MyServerType，这里.userAccountLogin是一个枚举也是一个MyServerType，我们可以在这里面添加请求参数，这样就关联起来了。</p>\n</blockquote>\n<pre><code class=\"line-numbers language-swift\">enum UserLoginAPIManagerService &#123;\n    /// 账号密码登录\n    case userAccountLogin(userName:String, passWord:String)\n    /// 是否显示注册\n    case isShowRegister\n    /// 注册\n    case register(_ params: [String: Any])\n    /// 更新是否已经提醒用户修改密码标记\n    case signNotFirstLogin(userId:String)\n    /// 修改密码\n    case changePassword(newPassword:String, oldPassword:String, username:String)\n    /// 校验原密码\n    case checkOldPassword(oldPassword:String, username:String)\n    /// 登出\n    case logOut\n\n&#125;\n</code></pre>\n<p>果然就是第一个“账号密码登录”。</p>\n<p>所有对于使用还是相当方便的，只需要写一个Manager，就可以很方便请求接口了。</p>\n<h2 id=\"4-细节分析\"><a href=\"#4-细节分析\" class=\"headerlink\" title=\"4 细节分析\"></a>4 细节分析</h2><p>继续上面的案例，当我们发送json请求时，走了一个框架封装好的方法，看下：</p>\n<pre><code class=\"line-numbers language-swift\">@discardableResult\n    public func requestJson(_ target: T,\n                            callbackQueue: DispatchQueue? = DispatchQueue.main,\n                            progress: ProgressBlock? = .none,\n                            success: @escaping JsonSuccess,\n                            failure: @escaping Failure) -&gt; Cancellable &#123;\n        return self.request(target, callbackQueue: callbackQueue, progress: progress, success: &#123; (response) in\n            do &#123;\n                let result = try JSON.init(data: response.data)\n                let vc = UIViewController.current()\n                if vc is LoginPageViewController &#123;&#125;else&#123;\n                    if response.statusCode == 403 || response.statusCode == 401 &#123;\n                        //token过期\n                        if tokenInvalidHandle != nil &#123;\n                            tokenInvalidHandle()\n                            return\n                        &#125;\n                    &#125;\n                &#125;\n                #if DEBUG\n                    print(result)\n                #endif\n                success(result)\n            &#125; catch (let error) &#123;\n                failure(error as? NetworkError ?? NetworkError.invalidURL)\n            &#125;\n        &#125;) &#123; (error) in\n            #if DEBUG\n                print(error)\n            #endif\n            failure(error)\n        &#125;\n    &#125;\n</code></pre>\n<p>这里继续走了内部的self.request方法，T就是我们自定义的MyServerType。<br>里面回调是我们自己的逻辑，就是解析了下Json，然后就是403或401的时候，跳转了登录页，这里的逻辑不需要关注。</p>\n<p>看下内部的request方法吧：</p>\n<pre><code class=\"line-numbers language-swift\">@discardableResult\n    public func request(_ target: T,\n                        callbackQueue: DispatchQueue? = DispatchQueue.main,\n                        progress: ProgressBlock? = .none,\n                        success: @escaping Success,\n                        failure: @escaping Failure) -&gt; Cancellable &#123;\n        return self.provider.request(target, callbackQueue: callbackQueue, progress: progress) &#123; (result) in\n            switch result &#123;\n            case let .success(response):\n                #if DEBUG\n                if let body = response.request?.httpBody,\n                   let param = String(data: body, encoding: .utf8),\n                   let interface = response.request?.url &#123;\n                    print(&quot;✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅&quot;)\n                    print(&quot;接口地址：\\n\\(interface)&quot;)\n                    print(&quot;✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅&quot;)\n                    print(&quot;请求参数：\\n\\(param)&quot;)\n                    print(&quot;✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅&quot;)\n                &#125;\n                #endif\n                success(response);\n            case let .failure(error):\n                #if DEBUG\n                print(&quot;❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌&quot;)\n                print(error)\n                #endif\n                let err = NetworkError.init(error: error)\n                failure(err);\n                break\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>这里的回调队列，进度，都有默认实例，当然可以自由传递。<br>另外就是成功和失败的逃逸闭包了。</p>\n<p>其实内部继续走了self.provider.request才是重中之重。</p>\n<h3 id=\"4-1-生产Moya-Provider\"><a href=\"#4-1-生产Moya-Provider\" class=\"headerlink\" title=\"4.1 生产Moya Provider\"></a>4.1 生产Moya Provider</h3><p>首先看下provider怎么来的：</p>\n<pre><code class=\"line-numbers language-swift\">public struct Networking&lt;T: MyServerType&gt; &#123;\n    public let provider: MoyaProvider&lt;T&gt;\n    \n    public init(provider: MoyaProvider&lt;T&gt; = newDefaultProvider()) &#123;\n        self.provider = provider\n    &#125;\n&#125;\n\npublic static func newDefaultProvider() -&gt; MoyaProvider&lt;T&gt; &#123;\n        return newProvider(plugins: plugins)\n&#125;\n\n/// 如何新建MoyaProvider\nfunc newProvider&lt;T&gt;(plugins: [PluginType],session: Session = newManager()) -&gt; MoyaProvider&lt;T&gt; where T: MyServerType &#123;\n    \n    return MoyaProvider(endpointClosure: Networking&lt;T&gt;.endpointsClosure(),\n                        requestClosure: Networking&lt;T&gt;.endpointResolver(),\n                        stubClosure: Networking&lt;T&gt;.APIKeysBasedStubBehaviour,\n                        session: session,\n                        plugins: plugins,\n                        trackInflights: false\n    )\n&#125;\n\n/// 新建Provider需要的参数1\nfunc newManager(delegate: SessionDelegate = SessionDelegate()) -&gt; Session &#123;\n//    let configuration = URLSessionConfiguration.default\n//    configuration.httpAdditionalHeaders = Alamofire.SessionManager.defaultHTTPHeaders\n    let configuration = Alamofire.Session.default.session.configuration\n    let session = Alamofire.Session(configuration: configuration, delegate: delegate, startRequestsImmediately: false)\n    return session\n&#125;\n\n/// 新建Provider需要的参数2\nstatic var plugins: [PluginType] &#123;\n        let activityPlugin = NewNetworkActivityPlugin &#123; (state, targetType) in\n            switch state &#123;\n            case .began:\n                if targetType.isShowLoading &#123; //这是我扩展的协议\n                    // 显示loading\n                &#125;\n            case .ended:\n                if targetType.isShowLoading &#123; //这是我扩展的协议\n                    // 关闭loading\n                &#125;\n            &#125;\n        &#125;\n        \n        return [\n            activityPlugin, myLoggorPlugin\n        ]\n    &#125;\n</code></pre>\n<p>这里创建的时候，就默认传了一个默认的Provider，这个是Moya官方的哦。</p>\n<p>另外新建这个MoyaProvider的时候还需要3个闭包，我们通过Networking来生产：</p>\n<pre><code class=\"line-numbers language-swift\">static func endpointsClosure&lt;T&gt;() -&gt; (T) -&gt; Endpoint where T: MyServerType &#123;\n    return &#123; target in\n        var headers: [String: String] = target.headers ?? [:]\n        if apiEnvironment == .product &#123;\n            //生产环境灰度\n            if canary == true &#123;\n                headers[&quot;canary&quot;] = &quot;true&quot;\n            &#125;\n        &#125;\n        //生产环境api路径设置\n        var str = &quot;&quot;\n        str = URL(target: target).absoluteString\n        if apiEnvironment != .test &amp;&amp; apiEnvironment != .dev &#123;\n            str = str.replacingOccurrences(of: &quot;-test&quot;, with: &quot;&quot;, options: .literal, range: nil)\n        &#125;\n        let absoluteString = str\n        let defaultEndpoint = Endpoint(\n            url: absoluteString,\n            sampleResponseClosure: &#123; target.sampleResponse &#125;,\n            method: target.method,\n            task: target.task,\n            httpHeaderFields: headers\n        )\n        return defaultEndpoint;\n    &#125;\n&#125;\n\n//测试网络错误,如超时等.\nstatic func endpointResolver() -&gt; MoyaProvider&lt;T&gt;.RequestClosure &#123;\n    return &#123; (endpoint, closure) in\n        do &#123;\n            var request = try endpoint.urlRequest()\n            request.httpShouldHandleCookies = false\n            request.timeoutInterval = WebService.shared.timeoutInterval\n            closure(.success(request))\n        &#125; catch let error &#123;\n            closure(.failure(MoyaError.underlying(error, nil)))\n        &#125;\n    &#125;\n&#125;   \n\nstatic func APIKeysBasedStubBehaviour&lt;T&gt;(_ target: T) -&gt; Moya.StubBehavior where T: MyServerType &#123;\n        return target.stubBehavior;\n    &#125;\n</code></pre>\n<p>这里我们自己生产了3个闭包给moya，也是moya需要的3个闭包。</p>\n<h3 id=\"4-2-继续走Provider的request\"><a href=\"#4-2-继续走Provider的request\" class=\"headerlink\" title=\"4.2 继续走Provider的request\"></a>4.2 继续走Provider的request</h3><pre><code class=\"line-numbers language-swift\">/// Designated request-making method. Returns a `Cancellable` token to cancel the request later.\n    @discardableResult\n    open func request(_ target: Target,\n                      callbackQueue: DispatchQueue? = .none,\n                      progress: ProgressBlock? = .none,\n                      completion: @escaping Completion) -&gt; Cancellable &#123;\n\n        let callbackQueue = callbackQueue ?? self.callbackQueue\n        return requestNormal(target, callbackQueue: callbackQueue, progress: progress, completion: completion)\n    &#125;\n</code></pre>\n<p>这个是moya三方库里面的代码了，简单看下就好，不是我们这期重点。</p>\n<h3 id=\"4-3-如何封装MyServerType\"><a href=\"#4-3-如何封装MyServerType\" class=\"headerlink\" title=\"4.3 如何封装MyServerType\"></a>4.3 如何封装MyServerType</h3><p>个人感觉这个也是非常关键，我们外部使用，需要建立一个枚举，同时也是一个MyServerType，这个携带了请求参数，请求方法之类的，总之它包装了一切我们请求需要的东西。</p>\n<pre><code class=\"line-numbers language-swift\">import Foundation\nimport Moya\n\npublic typealias HTTPMethod = Moya.Method\npublic typealias MyValidationType = Moya.ValidationType\npublic typealias MySampleResponse = Moya.EndpointSampleResponse\npublic typealias MyStubBehavior = Moya.StubBehavior\n\npublic protocol MyServerType: TargetType &#123;\n    var isShowLoading: Bool &#123; get &#125;\n    /// 附加请求头（如需添加额外的，使用这个）\n    var appendHeaders: [String : String]? &#123; get &#125;\n    var parameters: [String: Any]? &#123; get &#125;\n    var stubBehavior: MyStubBehavior &#123; get &#125;\n    var sampleResponse: MySampleResponse &#123; get &#125;\n&#125;\n</code></pre>\n<p>首先，它这个继承了Moya自己的TargetType，还增加了自己额外的一些协议。</p>\n<pre><code class=\"line-numbers language-swift\">extension MyServerType &#123;\n    public var base: String &#123; return WebService.shared.rootUrl&#125;\n    \n    public var baseURL: URL &#123; return URL(string: base)! &#125;\n    /// 请求头 （默认请求头 + appendHeaders），需求添加额外的改appendHeaders\n    public var headers: [String : String]? &#123;\n        var result: [String : String]? = WebService().headers\n        guard let appendHeaders = appendHeaders else &#123; return result &#125;\n        result = WebService().headers?.merging(appendHeaders, uniquingKeysWith: &#123; (_, new) in new &#125;)\n        return result\n    &#125;\n    public var appendHeaders: [String : String]? &#123; return nil &#125;\n    public var parameters: [String: Any]? &#123; return WebService.shared.parameters &#125;\n    \n    public var isShowLoading: Bool &#123; return false &#125;\n    \n    public var task: Task &#123;\n        let encoding: ParameterEncoding\n        switch self.method &#123;\n        case .post:\n            encoding = JSONEncoding.default\n        default:\n            encoding = URLEncoding.default\n        &#125;\n        if let requestParameters = parameters &#123;\n            return .requestParameters(parameters: requestParameters, encoding: encoding)\n        &#125;\n        return .requestPlain\n    &#125;\n    \n    \n    public var method: HTTPMethod &#123;\n        return .post\n    &#125;\n    \n    public var validationType: MyValidationType &#123;\n        return .successCodes\n    &#125;\n    \n    public var stubBehavior: StubBehavior &#123;\n        return .never\n    &#125;\n    \n    public var validate: Bool &#123;\n        return false\n    &#125;\n    \n    public var sampleData: Data &#123;\n        return &quot;response: test data&quot;.data(using: String.Encoding.utf8)!\n    &#125;\n    \n    public var sampleResponse: MySampleResponse &#123;\n        return .networkResponse(200, self.sampleData)\n    &#125;\n&#125;\n</code></pre>\n<p>这里应该是实现了默认值的设定。<br>当然我们是可以更改的。</p>\n<pre><code class=\"line-numbers language-swift\">func myBaseUrl(_ path: String) -&gt; String &#123;\n    if path.isCompleteUrl &#123; return path &#125;\n    return WebService.shared.rootUrl;\n&#125;\n\nfunc myPath(_ path: String) -&gt; String &#123;\n    if path.isCompleteUrl &#123; return &quot;&quot; &#125;\n    return path;\n&#125;\n\nextension String &#123;\n    var isCompleteUrl: Bool &#123;\n        let scheme = self.lowercased()\n        if scheme.contains(&quot;http&quot;) &#123; return true &#125;\n        return false\n    &#125;\n&#125;\n</code></pre>\n<p>然后是其它工具方法。</p>\n<p>这里有用到一个WebService类，这里面存放的也是一些默认值设定：</p>\n<pre><code class=\"line-numbers language-swift\">import Foundation\nimport UIKit\nimport AdSupport\nimport Alamofire\nimport Moya\n\nclass WebService: NSObject &#123;\n    \n    var rootUrl: String = mainHost\n    var headers: [String: String]? = defaultHeaders()\n    var parameters: [String: Any]? = defaultParameters()\n    var timeoutInterval: Double = 30.0\n    //和服务器时间相差的时间戳:备注每次app恢复活跃状态需更新一次\n    static var serviceTimeSpace: String?\n    \n    static let shared = WebService()\n    override init() &#123;&#125;\n    \n    static func defaultHeaders() -&gt; [String : String]? &#123;\n        var headers = [&quot;x-flag&quot;: &quot;iOS&quot;, &quot;serverName&quot;: &quot;APP&quot;, &quot;clientId&quot;: clientId]\n        if let token = Defaults[key: DefaultsKeys.access_token] &#123;\n            headers[&quot;Authorization&quot;] = &quot;Bearer&quot; + token\n        &#125;\n        let isMonopoly = Defaults[key: DefaultsKeys.isMonopoly] ?? false\n        /// appVersion 字段，（1表示专业版，0表示简易版）\n        headers[&quot;appVersion&quot;] = isMonopoly ? &quot;0&quot; : &quot;1&quot;\n        return headers\n    &#125;\n    \n    static func defaultParameters() -&gt; [String : Any]? &#123;\n        return [&quot;platform&quot; : &quot;ios&quot;,\n            &quot;version&quot; : &quot;1.2.3&quot;,\n        ]\n    &#125;\n    \n    /**\n     获取当前app版本号\n     */\n    static func getAppShortVersion() -&gt; String &#123;\n        let infoDictionary = Bundle.main.infoDictionary!\n        let version = infoDictionary[&quot;CFBundleShortVersionString&quot;] as! String\n        return version\n    &#125;\n    \n    /**\n    获取当前请求User-Agent\n     */\n    static func getUserAgent() -&gt; String &#123;\n        let infoDictionary = Bundle.main.infoDictionary!\n        let version = infoDictionary[&quot;CFBundleShortVersionString&quot;] as! String\n        let userAgent = String(format: &quot;GREEMall%@(%@; iOS %@; Scale/%.2f)&quot;, version, UIDevice.current.model, UIDevice.current.systemVersion, UIScreen.main.scale)\n        \n        return userAgent\n    &#125;\n    \n    /**\n    获取服务器时间和计算时间差\n     */\n    static func setServiceTimeInterval(timeInterval:TimeInterval) &#123;\n        serviceTimeSpace = String(format: &quot;%@&quot;, timeInterval)\n    &#125;\n    \n    /**\n     获取服务器时间戳\n     */\n    static func getServiceTimeInterval() -&gt; Int &#123;\n        return Int(serviceTimeSpace!)!\n    &#125;\n    \n    /**\n     设置请求统一参数\n     */\n    static func getSystemParameterData() -&gt; Dictionary&lt;String, String&gt; &#123;\n        var data = [String: String]()\n        data[&quot;source&quot;] = &quot;iOS&quot;\n        var timeSpace: String = &quot;&quot;\n        if serviceTimeSpace != nil &#123;\n            let now: TimeInterval = Date.init().timeIntervalSince1970\n            let appTime: TimeInterval = now + Double(CLongLong(serviceTimeSpace!)!)\n            timeSpace = String(format:&quot;%@&quot;, appTime)\n        &#125; else &#123;\n            timeSpace = String(format:&quot;%@&quot;, Date.init().timeIntervalSince1970)\n        &#125;\n        data[&quot;t&quot;] = timeSpace\n        data[&quot;version&quot;] = self.getAppShortVersion()\n        data[&quot;ios_idfa&quot;] = ASIdentifierManager.shared().advertisingIdentifier.uuidString\n        return data\n    &#125;\n    \n    /**\n     签名MD5处理\n     */\n    static func appendSign(paramterDic: Dictionary&lt;String, String&gt;, secrekey:String) -&gt; String &#123;\n        var sign:String = &quot;&quot;\n        var keys:Array = Array(paramterDic.keys)\n        keys = keys.sorted()\n        for key:String in keys &#123;\n            if key == &quot;sign&quot; &#123;\n                continue\n            &#125; else &#123;\n                let keyValue: String = String(format: &quot;%@&quot;, paramterDic[key]!)\n                sign.append(String(format: &quot;%@%@&quot;, key, keyValue.EscapesValr))\n            &#125;\n        &#125;\n        sign.append(secrekey)\n        return sign.td.md5.uppercased()\n    &#125;\n&#125;\n</code></pre>\n<p>大致就是这样了。</p>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5 总结\"></a>5 总结</h2><ul>\n<li><p>这个二次封装主要是基于Moya，简化moya流程，提供了一个MyServerType，封装了一些请求参数，请求方法，方便我们进行接口配置。</p>\n</li>\n<li><p>使用方法很简单，不过需要将一类接口单独放置，全部放一起不方便管理，这里比如登录相关接口统一用一个Manger配置，接口参数都写在这个Manager里面，其实也是由一定好处的。</p>\n</li>\n<li><p>这里将moya更加封装成一个系统了，我们需要的结果无非就是接口成功或失败，传参也是我们必要的，将必要的都封装起来了，总体上使用还是比较便捷。</p>\n</li>\n<li><p>如果有特殊请求，比如下载文件这种，需要我们单独抽一个方法处理，这里稍微增加了一点复杂度吧，一般的请求还是可以直接使用的。</p>\n</li>\n</ul>\n"},{"title":"iOS-swift-自定义View之四级地址","date":"2023-01-27T08:26:44.000Z","top":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 需求分析\n目标是可以选择四级地址，什么是四级地址呢？省市区街道。类似淘宝买东西时，支付订单时需要填写收货地址，这里就需要构造一个四级地址弹框，让用户去选择。具体效果如下：\n<img src=%E5%9B%9B%E7%BA%A7%E5%9C%B0%E5%9D%80.gif>\n\n这个我们可以单独将这个地址弹框单独封装一下，本身就是一个工具，很多地方可能会用的。\n另外还需要提供传参，因为可能用户之前选择了某些地址，现在要更改，就需要跳转到已选择的四级地址，并且可以自己切换任何一个省市区，如果重新选择省，那么下级地址都需要清空；如果重新更新了市，那么下级清空，上级保留。\n大概就是这样子。\n\n所以我们就可以将四级地址视图用一个UIView来实现。\n\n## 2 控件结构\n\n首先我们分析下如何来完成这个需求，代码如何实现。\n这里我们考虑将ui提供的四级地址，通过自定义View来实现。\n\n顶部有一个列表，就是记录用户已选地址，省市区街道。\n底部也有一个列表，而且有分组，以地址的拼音首字母分组，组下也可能有会有不定行数的cell。\n\n这里我们就考虑 用两个UITableView来承载顶部和底部的列表。\n两个UITableView都放在  AddressView 的自定义View里面吧。\n\n所以会多出两个Cell，一个是顶部Cell，就叫做AddressCell吧；一个是底部Cell，承载底部列表，就叫做AddressSelectorCell吧。\n\n另外还有数据层，就叫它 AddressModel吧，放地址数据的。\n\n所以我们只需要4个文件就可以完成这个需求了。\n\n* AddressView 四级地址自定义View\n* AddressCell 顶部Cell\n* AddressSelectorCell 底部Cell\n* AddressModel 数据层\n\n## 3 AddressView 实现逻辑\n\n### 3.1 全局变量定义\n```Swift\nclass AddressView: UIView {\n    \n    typealias selectAddressBlock = (Array<RegionModel>)->()\n    var selectAddressHandle: selectAddressBlock?\n    var cancelAddressHandle: Handler?\n    \n    var modelArray: Array<Any> = []\n    var addressArray: Array<(key: Swift.String, value: Array<RegionModel>)> = []\n    var selectedIndex: Int = 0\n```\n这里定义一个闭包，就是用户勾选了4级地址后，需要将地址暴露个调用方，肯定需要一个方法发出去的。\n\ncancelAddressHandle是一个取消函数，主要处理用户点击蒙层或者点击取消的事件。\n\nmodelArray是记录顶部列表数据的数组。\n\naddressArray是记录底部列表数据的数组。\n\nselectedIndex是记录顶部选择了第几项的全局变量记录。\n\n然后是2个懒加载的UITableView，看下哈：\n```Swift\n/// 顶部视图列表\nprivate lazy var tblView: UITableView = {\n    let tableView = UITableView.init(frame: CGRect(x: 0, y: 196, width: ScreenWidth, height: ScreenHeight - 196), style: .grouped)\n    tableView.register(AddressCell.self, forCellReuseIdentifier: AddressCell.identifier)\n    tableView.delegate = self\n    tableView.dataSource = self\n    tableView.separatorStyle = .none\n    tableView.backgroundColor = .white\n    tableView.showsVerticalScrollIndicator = false\n    tableView.showsHorizontalScrollIndicator = false\n    tableView.isScrollEnabled = false\n    tableView.layer.cornerRadius = 14\n    tableView.layer.maskedCorners = [.layerMinXMinYCorner,.layerMaxXMinYCorner]\n    return tableView\n}()\n```\n\n还有一个底部的列表：\n```Swift\n/// 底部视图列表\nprivate lazy var addressTblView: UITableView = {\n    let tableView = UITableView.init(frame: CGRect.zero, style: .grouped)\n    tableView.register(AddressSelectorCell.self, forCellReuseIdentifier: AddressSelectorCell.identifier)\n    tableView.delegate = self\n    tableView.dataSource = self\n    tableView.backgroundColor = .white\n    tableView.separatorStyle = .none\n    tableView.showsVerticalScrollIndicator = false\n    tableView.showsHorizontalScrollIndicator = false\n    return tableView\n}()\n```\n虽然是两个UITableView，但可以共享同一个代理和数据源，需要在里面另外加if else判断下。\n\n### 3.2 生命周期函数\n这里只有一个初始化，但其实没有做什么，也没有把那两个UITableView加进去，这里应该就是空白的区域。\n```Swift\n  override init(frame: CGRect) {\n        super.init(frame: frame)\n        self.backgroundColor = UIColor.init(red: 0, green: 0, blue: 0, alpha: 0.6)\n    }\n    \n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n```\n\n### 3.3 初始化数据\n这里是另外提供的函数，来初始化，所以需要调用方额外调用这个方法。\n也正是这个方法，才会去加载ui的。\n\n```Swift\nfunc traverse(province: String, city: String, area: String, street: String){\n        modelArray.removeAll()\n        let dataArr: [RegionModel] = globalAddressModel?.data ?? AddressModel.init().data\n        self.recursive(dataArr: dataArr, province: province, city: city, area: area, street: street)\n        \n        if globalAddressModel != nil {\n            if modelArray.count == 0 {\n                /// 这里就展示省列表\n                self.setData(data: globalAddressModel!)\n            }else if modelArray.count == 4{\n                /// 这里展示街道列表\n                let model = modelArray[2]\n                self.setData(data: model)\n            } else{\n                /// 其它情况，就拿最后一个数据，在设置给底部内容tableView里面\n                let model = modelArray.last as! RegionModel\n                self.setData(data: model)\n            }\n        }\n        if modelArray.count < 4 {\n            modelArray.append(\"请选择\")\n        }\n        \n        /// 大概意思就是找到“请选择”在哪一个位置\n        selectedIndex = modelArray.firstIndex{$0 is String} ?? modelArray.count-1\n        /// 开始加载UI\n        self.loadUI()\n    }\n```\nglobalAddressModel 实际上再AppDelegate初始化的时候就去异步加载json文件了，这个应该就是保存的所有的四级地址信息了。\n\n然后这里用到了一个函数 recursive函数，是递归来寻找目标四级地址。\n```Swift\n/// 递归获取目标地址\nfunc recursive(dataArr: [RegionModel], province: String, city: String, area: String, street: String){\n    for model in dataArr{\n        if model.name.contains(province) ||\n            model.name.contains(city) ||\n            model.name.contains(area) ||\n            model.name.contains(street){\n            modelArray.append(model)\n            self.recursive(dataArr: model.children, province: province, city: city, area: area, street: street)\n            break\n        }\n    }\n}\n```\n找到后，会将实体append到这个数组中。\n\n然后上面初始化数据还用到一个函数：setData，作用是设置底部数据，因为这里底部自始至终都是同一个UITableView，会经常需要刷新数据。这里就是刷新底部数据的意思吧。\n\n看下这个setData函数哈：\n```Swift\nfunc setData(data: Any){\n        var dataArr: [RegionModel] = []\n        if data is AddressModel {\n            let tmpData = data as! AddressModel\n            dataArr = tmpData.data\n        }else{\n            let tmpData = data as! RegionModel\n            dataArr = tmpData.children\n        }\n        /// 上面的代码目的是为了拿到 RegionModel数组\n        \n        if dataArr.count == 0 {\n            return\n        }\n        \n        var tmpDic: Dictionary<String,Array<RegionModel>> = Dictionary<String,Array<RegionModel>>()\n        for model in dataArr{\n            var key: String = \"\"\n            key = self.findFirstLetterFromString(aString: model.name)\n            var arr = tmpDic[key] ?? Array<RegionModel>()\n            arr.append(model)\n            tmpDic[key] = arr\n        }\n        \n        //处理了第二个字首字母排序\n        _ = tmpDic.keys.compactMap{ key in\n            var tmpArr = tmpDic[key]!\n            tmpArr = tmpArr.sorted{(model1,model2) in\n                var key1 = \"\"\n                var key2 = \"\"\n                key1 = self.findFirstLetterFromString(aString: model1.name, isSecond: true)\n                key2 = self.findFirstLetterFromString(aString: model2.name, isSecond: true)\n                return key1 < key2\n            }\n            tmpDic[key] = tmpArr\n        }\n        addressArray = tmpDic.sorted{$0.key < $1.key}\n        \n        /// addressArray应该是拿到目前展示的内容区域数据 底部区域\n        self.addressTblView.reloadData()\n    }\n```\n这里代码虽然长，但实际上具体还是挺简单的，主要是生成一个字典的映射关系，key存放首字母，value存放同一个首字母下对应的地址列表。大概意思就是这个tmpDic是一个key value形式的map集合，key是这些比如省份首字母为G，那么value就对应广东省，甘肃省，广西，贵州省等下的所有地址。这里就对应tableView里面的每一组的数据了。然后处理下第二个首字母排序的问题。\n\n好的，这里打住了，回到第一个函数 traverse方法中，里面根据modelArray的长度去决定刷新哪一个列表，因为调用方给的地址不一定是四级，可能是1级或2级或3级，这里也是需要考虑到的。能在哪个层级搜索到，就定位到哪个层级，那么最后一个层级这里使用 append一个“请选择”，这里说明如果是字符串了，那么这里就是最后一层级。感觉这还可以优化下，比较用字符串来判断到哪一层级不太合适的。\n\ntraverse最后一个方法是加载UI。\n```Swift\nfunc loadUI(){\n        /// 先加顶部\n        self.addSubview(tblView)\n        /// 顶部布局\n        self.updateUI()\n        \n        /// 再加底部\n        self.addSubview(addressTblView)\n        /// 底部布局\n        addressTblView.snp.remakeConstraints{make in\n            make.leading.trailing.bottom.equalTo(0)\n            make.top.equalTo(tblView.snp.bottom).offset(0)\n        }\n    }\n\nfunc updateUI(){\n        tblView.snp.remakeConstraints{make in\n            make.leading.trailing.equalTo(0)\n            make.top.equalTo(196)\n            if modelArray.count == 1 {\n                make.height.equalTo(96)\n            }else{\n                make.height.equalTo(96+modelArray.count*48)\n            }\n        }\n        self.tblView.reloadData()\n    }\n```\n大概意思就是把那两个UITableView加给父View。\n\n然后需要用的扩展方法有下面这个：\n```Swift\nextension AddressView{\n    \n    /// 找到中文对应的第一个字符对应的第一个字母拼音\n    func findFirstLetterFromString(aString: String, isSecond : Bool = false) -> String {\n        //转变成可变字符串\n        let mutableString = NSMutableString.init(string: aString)\n        \n        //将中文转换成带声调的拼音\n        CFStringTransform(mutableString as CFMutableString, nil,      kCFStringTransformToLatin, false)\n        \n        //去掉声调\n        let pinyinString = mutableString.folding(options:          String.CompareOptions.diacriticInsensitive, locale:   NSLocale.current)\n        \n        //将拼音首字母换成大写\n        let strPinYin = polyphoneStringHandle(nameString: aString,    pinyinString: pinyinString).uppercased()\n        \n        //截取大写首字母\n        let arr = strPinYin.components(separatedBy: \" \")\n        let completeStr = isSecond == false ? arr[0] : arr[1]\n        let firstString = completeStr.subScript(index: 0, length: 1)\n        //判断首字母是否为大写\n        let regexA = \"^[A-Z]$\"\n        let predA = NSPredicate.init(format: \"SELF MATCHES %@\", regexA)\n        return predA.evaluate(with: firstString) ? firstString : \"#\"\n    }\n    \n    //多音字处理，根据需要添自行加\n    func polyphoneStringHandle(nameString: String, pinyinString: String) -> String {\n        //        if nameString.hasPrefix(\"长\") {return \"chang\"}\n        //        if nameString.hasPrefix(\"沈\") {return \"shen\"}\n        //        if nameString.hasPrefix(\"厦\") {return \"xia\"}\n        //        if nameString.hasPrefix(\"地\") {return \"di\"}\n        //        if nameString.hasPrefix(\"重\") {return \"chong\"}\n        return pinyinString\n    }\n}\n```\n这里主要是一个工具方法，内部使用，无需多讲。\n\n好了，前面的ui基本就这些。\n下面主要是讲解下UITableView的代理方法和数据源配置。\n\n```Swift\n/// 设置顶部tableView 代理和数据\nextension AddressView: UITableViewDelegate,UITableViewDataSource{\n    func numberOfSections(in tableView: UITableView) -> Int {\n        if tableView == tblView {\n            return 1    /// 顶部tableView只有一组\n        }else{\n            return addressArray.count   /// 很多组 26个字母都有的话，就26组\n        }\n    }\n```\n这里扩展AddressView，去实现UITableViewDelegate和UITableViewDataSource协议。\n这是第一个方法，numberOfSections，返回有多少组。这里因为顶部只有一种类型，也就只有一组，底部用了一个数组记录，组数就是数组的长度。\n\n```Swift\nfunc tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        if tableView == tblView {\n            /// 顶部，如果没有 历史地址，则为0，有则显示 一组多少个\n            if modelArray.count == 1 && (modelArray.last is String) {\n                return 0\n            }else{\n                return modelArray.count\n            }\n        }else{\n            /// 取当前组里面多少个\n            let dic = addressArray[section]\n            let arr = dic.value\n            return arr.count\n        }\n    }\n```\n这是第二个方法，numberOfRowsInSection，意思就是这个组下有多少行。\n\n```Swift\n func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n        /// 上面下面都是48\n        if tableView == tblView {\n            return 48\n        }else{\n            return 48\n        }\n    }\n```\n这里是每行的高度。\n\n```Swift\n/// 每个cell怎么显示\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    /// 如果是顶部\n    if tblView == tableView {\n        /// 顶部用AddressCell\n        let cell = tableView.dequeueReusableCell(withIdentifier: AddressCell.identifier, for: indexPath) as! AddressCell\n        let model = modelArray[indexPath.row]\n        /// 数据用modelArray里面的数据\n        cell.model = model\n        /// 选中的话，高亮显示文字颜色\n        if selectedIndex == indexPath.row {\n            cell.titleLb.textColor = UIColor.init(hex: \"#409EFF\")\n        }else{\n            cell.titleLb.textColor = UIColor.init(hex: \"#3B4058\")\n        }\n        /// 这里是请选择什么\n        if model is String {\n            cell.updateUI(indexPath: indexPath)\n        }\n        \n        /// 指示剂方向\n        if indexPath.row == 0 {\n            cell.position = .down // 第0行，只有下面的\n        }else if indexPath.row == modelArray.count-1{\n            cell.position = .top /// 最后一行，只有上面\n        }else{\n            cell.position = .middle /// 其它都有\n        }\n        \n        return cell\n    }else{\n        /// 如果是底部，数据取addressArray里面的\n        let dic = addressArray[indexPath.section]\n        let arr = dic.value\n        let model = arr[indexPath.row] // 这个字母类别里面的 第row行\n        \n        /// 这个cell用 AddressSelector来实现\n        let cell = tableView.dequeueReusableCell(withIdentifier: AddressSelectorCell.identifier, for: indexPath) as! AddressSelectorCell\n        \n        /// 第1行才有字母\n        if indexPath.row == 0 {\n            cell.indexLb.text = dic.key\n        }else{\n            cell.indexLb.text = \"\"\n        }\n        \n        /// 当前在那个层级 比如是广东省\n        let obj = modelArray[selectedIndex]\n        if obj is String { /// 请选择层级\n            cell.checkImgView.isHidden = true\n            cell.nameLb.textColor = UIColor.init(hex: \"#3B4058\")\n        }else{\n            /// 已选层级\n            let selectedModel = obj as! RegionModel\n            if selectedModel.name == model.name { /// 列表中的就是已选的，高亮一下\n                cell.nameLb.textColor = UIColor.init(hex: \"#409EFF\")\n                cell.checkImgView.isHidden = false\n            }else{\n                cell.nameLb.textColor = UIColor.init(hex: \"#3B4058\")\n                cell.checkImgView.isHidden = true\n            }\n        }\n        \n        ///  显示目标地址名称\n        cell.nameLb.text = model.name\n        return cell\n    }\n}\n```\n这个方法就比较关键了，就是每行怎么展现的。\n用哪个Cell，是否要高亮，指示剂怎么展示，这里有点像Android的adpter里面的bindAdapter实现逻辑。这里需要按照需求在item里面自行处理逻辑。\n\n如果是底部，就需要考虑是否显示字母，是否高亮这些了。\n\n```Swift\n/// 标题和单元格间隔\nfunc tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {\n    /// 顶部头部预留48dp显示标题“请选择所在地区”\n    if tableView == tblView {\n        return 48\n    }else{\n        return 0.01\n    }\n}\n```\n顶部预留高度，用来展示自己的标题。\n\n```Swift\n/// 和上面对应，预留48个dp怎么显示\nfunc tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {\n    if tableView == tblView {\n        let view = UIView.init(frame: CGRect.init(x: 0, y: 0, width: ScreenWidth, height: 48))\n        let label = UILabel.init()\n        label.font = .pingFangSemibold(size: 18)\n        label.textColor = UIColor.init(hex: \"#3B4058\")\n        label.text = \"请选择所在地区\"\n        \n        let closeBtn: UIButton = {\n            let btn = UIButton()\n            btn.setTitle(\"取消\", for: .normal)\n            btn.setTitleColor(UIColor.init(hex: \"#409EFF\"), for: .normal)\n            btn.titleLabel?.font = .pingFangRegular(size: 16)\n            btn.addTarget(self, action: #selector(actionForClose), for: .touchUpInside)\n            return btn\n        }()\n        \n        view.addSubview(label)\n        view.addSubview(closeBtn)\n        label.snp.makeConstraints{make in\n            make.centerY.equalTo(view)\n            make.centerX.equalTo(view)\n            make.width.equalTo(130)\n            make.height.equalTo(30)\n        }\n        closeBtn.snp.makeConstraints{make in\n            make.trailing.equalTo(-16)\n            make.centerY.equalTo(view)\n            make.width.equalTo(48)\n            make.height.equalTo(48)\n        }\n        return view\n    }else{\n        return UIView()\n    }\n}\n```\n标题和取消按钮显示逻辑。\n\n```Swift\n/// 单元格尾巴怎么显示\nfunc tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -> CGFloat {\n    /// 如果是顶部tableView，预留48个dp\n    if tableView == tblView {\n        return 48\n    }else{\n        return 0.01\n    }\n}\n```\n这里顶部有效，有48个单位长度，用来显示底部标题。\n\n```Swift\n/// 尾部显示 选择下级地址\nfunc tableView(_ tableView: UITableView, viewForFooterInSection section: Int) -> UIView? {\n    if tableView == tblView {\n        let view = UIView.init(frame: CGRect.init(x: 0, y: 0, width: ScreenWidth, height: 48))\n        \n        let lineView = UIView()\n        lineView.backgroundColor = UIColor.init(hex: \"#F6F6F6\")\n        let label = UILabel.init()\n        label.font = .pingFangSemibold(size: 16)\n        label.textColor = UIColor.init(hex: \"#3B4058\")\n        \n        if selectedIndex == 0 {\n            label.text = \"选择省份/地区\"\n        }else if selectedIndex == 1{\n            label.text = \"选择城市\"\n        }else if selectedIndex == 2{\n            label.text = \"选择区/县\"\n        }else{\n            label.text = \"选择街道/镇\"\n        }\n        \n        view.addSubview(lineView)\n        view.addSubview(label)\n        \n        lineView.snp.makeConstraints{make in\n            make.top.equalTo(4)\n            make.leading.trailing.equalTo(0)\n            make.height.equalTo(0.5)\n        }\n        label.snp.makeConstraints{make in\n            make.top.equalTo(16)\n            make.leading.equalTo(8)\n            make.width.equalTo(150)\n            make.height.equalTo(30)\n        }\n        return view\n    }else{\n        return UIView()\n    }\n}\n```\n这里就是确定底部标题的怎么显示的。\n\n```Swift\n/// 点击了单元格\nfunc tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n    if tblView == tableView {\n        /// 顶部点击了哪个单元格\n        if indexPath.row == 0 {\n            self.setData(data: globalAddressModel!)\n        }else{\n            let model = modelArray[indexPath.row-1]\n            self.setData(data: model)\n        }\n        selectedIndex = indexPath.row\n        /// 改变全局变量 selectedIndex，再去加载\n        self.tblView.reloadData()\n    }else{\n        /// 当前是哪一组\n        let dic = addressArray[indexPath.section]\n        let arr = dic.value\n        /// 当前是哪一行\n        let model = arr[indexPath.row]\n        \n        /// 请选择是第几个\n        let index = modelArray.firstIndex{$0 is String} ?? 0\n        /// 顶部是请选择\n        if modelArray[selectedIndex] is String && modelArray.count < 5{\n            /// 插入目标点击的地址 给modelArray\n            modelArray.insert(model, at: index)\n            if modelArray.count == 5 {\n                modelArray.removeLast()\n            }\n        }else{\n            /// 顶部不是请选择,而已已选择的地址\n            modelArray[selectedIndex] = model\n            /// 下面有请选择，需要清空之前选择的值\n            let isContain = modelArray.contains(where: {$0 is String})\n            if isContain {\n                for i in (selectedIndex+1 ... modelArray.count-1).reversed(){\n                    if modelArray[i] is String {\n                        continue\n                    }\n                    modelArray.remove(at: i)\n                }\n            } else if !isContain && selectedIndex != 3{\n                for i in (selectedIndex+1 ... modelArray.count-1).reversed(){\n                    modelArray.remove(at: i)\n                }\n            }\n            \n            if modelArray.count < 4 && !modelArray.contains(where: {$0 is String}){\n                modelArray.append(\"请选择\")\n            }\n        }\n        \n        /// 没有请选择了，会直接关闭弹框，执行回调\n        if modelArray.count == 4 && !modelArray.contains(where: {$0 is String}){\n            var arr: [RegionModel] = []\n            for model in modelArray {\n                let obj = model as! RegionModel\n                arr.append(obj)\n            }\n            selectAddressHandle?(arr)\n            self.removeFromSuperview()\n        }else{\n            /// 更新底部数据，以及顶部选择index\n            self.setData(data: model)\n            self.updateUI()\n            selectedIndex += 1\n        }\n    }\n}\n```\n上面的代码逻辑，主要就是处理点击顶部单元格，和底部单元格的逻辑。\n顶部点击会调用setData,会同步刷新底部。\n\n底部点击也会setData,刷新底部数据，如果全部选择，则会走闭包回调，将用户选择的四级地址回调出去。\n\n然后还有一些其它扩展方法，简单看下哈。\n```Swift\n/// 扩展给外部\nextension AddressView{\n    /// 通知调用者当有一个或者多个手指触摸到了视图或者窗口时触发此方法。\n    /// touches是UITouch的集合，通过UITouch我们可以检测触摸事件的属性，是单拍还是双拍，还有触摸的位置等。\n    /// 这里应该是触摸到蒙层后关闭弹框\n    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {\n        guard let point = touches.first?.location(in: self) else { return }\n        let p = self.layer.convert(point, from: self.layer)\n        if self.layer.contains(p) {\n            self.actionForClose()\n        }\n    }\n    \n    /// 移除自己，类似关闭弹框效果\n    @objc func actionForClose(){\n        cancelAddressHandle?()\n        self.removeFromSuperview()\n    }\n}\n```\n这里actionForClose是UiButton设置的一个action，上面哪个是覆写的官方方法，应该是触摸到蒙层自动关闭弹框。\n\n## 4 AddressCell 实现逻辑\n这个可以理解成Android中的Adapter了。也就是item怎么显示。\n```Swift\n/// 顶部cell\nclass AddressCell: UITableViewCell {\n    \n    enum LinePosition {\n        case down\n        case middle\n        case top\n    }\n    \n    static var identifier: String = \"AddressCell\"\n```\n这里需要继承UITableViewCell，必须要有一个identifier，这个主要是为了复用，因为列表可能会很长，为了合理复用，这里一般都需要一个标识符。\n\n### 4.1 子View定义\n```Swift\n /// 安徽省\nlazy var titleLb: UILabel = {\n    let label = UILabel()\n    label.font = .pingFangMedium(size: 16)\n    label.textColor = UIColor.init(hex: \"#3B4058\")\n    return label\n}()\n\n/// 实心圆\nlazy var roundView: UIView = {\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: \"#409EFF\")\n    view.layer.cornerRadius = 3.5\n    view.layer.borderWidth = 1\n    view.layer.borderColor = UIColor.init(hex: \"#409EFF\").cgColor\n    return view\n}()\n\n/// 圆上面的线条\nlazy private var toplineView: UIView = {\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: \"#409EFF\")\n    return view\n}()\n\n/// 圆下面的线条\nlazy private var downlineView: UIView = {\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: \"#409EFF\")\n    return view\n}()\n\n/// 右侧箭头\nlazy private var rightImgView: UIImageView = {\n    let imgView = UIImageView()\n    imgView.image = UIImage.init(named: \"客户信息_右箭头\")\n    return imgView\n}()\n```\n这里是顶部item用的一些零部件。\n比如上下线图，右侧箭头，中间文字。实心圆。\n这里变空心，实际上只是设置了中间颜色为纯白。\n\n### 4.2 数据定义\n```Swift\n/// 监听数据变化 数据填充\nvar model: Any?{\n    didSet{\n        guard let _model = model else{return}\n        if _model is RegionModel {\n            let tmp = _model as! RegionModel\n            titleLb.text = tmp.name\n        }\n    }\n}\n    \n/// 线条位置\nvar position: LinePosition?{\n    didSet{\n        guard let _position = position else{return}\n        /// 上面和下面的线条都先一出去\n        toplineView.removeFromSuperview()\n        downlineView.removeFromSuperview()\n        \n        /// 如果在下面 空心圆\n        if _position == .down {\n            contentView.addSubview(downlineView)\n            downlineView.snp.makeConstraints{make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(roundView.snp.top).offset(0)\n                make.bottom.equalTo(0)\n                make.width.equalTo(1)\n            }\n            roundView.backgroundColor = UIColor.init(hex: \"#409EFF\")\n        }else if _position == .top{\n            /// 如果在上面 空心圆\n            contentView.addSubview(toplineView)\n            toplineView.snp.makeConstraints{make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(0)\n                make.bottom.equalTo(roundView.snp.top)\n                make.width.equalTo(1)\n            }\n            if model is String {\n                roundView.backgroundColor = .white\n            }else{\n                roundView.backgroundColor = UIColor.init(hex: \"#409EFF\")\n            }\n        }else{\n            /// 都不在，也是都存在的意思\n            contentView.addSubview(toplineView)\n            contentView.addSubview(downlineView)\n            toplineView.snp.makeConstraints{make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(0)\n                make.bottom.equalTo(roundView.snp.top)\n                make.width.equalTo(1)\n            }\n            downlineView.snp.remakeConstraints{make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(roundView.snp.bottom)\n                make.bottom.equalTo(0)\n                make.width.equalTo(1)\n            }\n            roundView.backgroundColor = UIColor.init(hex: \"#409EFF\")\n        }\n    }\n}\n```\n这里定义了2个数据，1个是具体显示什么的数据，一个是线条怎么展示，什么时候展示实心和空心圆的逻辑。\n\n### 4.3 生命周期函数\n首先看下初始化。\n```Swift\noverride init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        \n        self.selectionStyle = .none\n        \n        /// 添加安徽省\n        contentView.addSubview(titleLb)\n        titleLb.snp.makeConstraints{make in\n            make.centerY.equalToSuperview()\n            make.leading.equalTo(roundView.snp.trailing).offset(22)\n            make.trailing.equalTo(rightImgView.snp.leading).offset(10)\n            make.height.equalTo(20)\n        }\n        \n        /// 添加圆形指示器\n        contentView.addSubview(roundView)\n        roundView.snp.makeConstraints{make in\n            make.centerY.equalToSuperview()\n            make.leading.equalTo(14)\n            make.width.equalTo(7)\n            make.height.equalTo(7)\n        }\n        \n        /// 添加右侧箭头\n        contentView.addSubview(rightImgView)\n        rightImgView.snp.makeConstraints{make in\n            make.centerY.equalToSuperview()\n            make.trailing.equalTo(-16)\n            make.width.equalTo(19)\n            make.height.equalTo(19)\n        }\n        \n    }\n    \n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n```\n这里就加了3个视图，并且布局了。\n\n### 4.4 其它扩展方法\n```Swift\nextension AddressCell{\n    func updateUI(indexPath: IndexPath){\n        if indexPath.row == 1 {\n            titleLb.text = \"请选择城市\"\n        }else if indexPath.row == 2 {\n            titleLb.text = \"请选择县\"\n        }else if indexPath.row == 3{\n            titleLb.text = \"请选街道\"\n        }else{\n            titleLb.text = \"\"//model as? String\n        }\n    }\n}\n```\n这里就是显示item特殊情况的文案。\n\n## 5 AddressSelectorCell 实现逻辑\n这里也同上面的Cell，有一个标识符。\n```Swift\n/// 底部Cell\nclass AddressSelectorCell: UITableViewCell {\n    \n    static var identifier: String = \"UITableViewCell\"\n```\n\n### 5.1 子View\n这里需要哪些子View呢？\n```Swift\n//索引 eg: A字母\nlazy var indexLb: UILabel = {\n    let label = UILabel()\n    label.font = .pingFangMedium(size: 12)\n    label.textColor = UIColor.init(hex: \"#9B9DA7\")\n    return label\n}()\n\n//名称 eg: 安徽省\nlazy var nameLb: UILabel = {\n    let label = UILabel()\n    label.font = .pingFangMedium(size: 14)\n    label.textColor = UIColor.init(hex: \"#3B4058\")\n    return label\n}()\n\n//勾选图标\nlazy var checkImgView: UIImageView = {\n    let imgView = UIImageView()\n    imgView.isHidden = true\n    imgView.image = UIImage.init(named: \"勾选\")\n    return imgView\n}()\n```\n这里非常简单，只有3个子视图，字母，中间名称，是否勾选。\n\n### 5.2 生命周期函数\n看下初始化吧。\n```Swift\noverride init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        self.selectionStyle = .none\n        \n        /// 添加索引，并且布局\n        contentView.addSubview(indexLb)\n        indexLb.snp.makeConstraints{make in\n            make.leading.equalTo(8)\n            make.centerY.equalToSuperview()\n            make.width.equalTo(10)\n            make.height.equalTo(20)\n        }\n        \n        /// 添加名称，并且位置确定\n        contentView.addSubview(nameLb)\n        nameLb.snp.makeConstraints{make in\n            make.leading.equalTo(indexLb.snp.trailing).offset(16)\n            make.trailing.equalTo(-16)\n            make.centerY.equalToSuperview()\n            make.height.equalTo(20)\n        }\n        \n        /// 确定勾选图标\n        contentView.addSubview(checkImgView)\n        checkImgView.snp.makeConstraints{make in\n            make.trailing.equalTo(-16)\n            make.centerY.equalToSuperview()\n            make.width.equalTo(16)\n            make.height.equalTo(16)\n        }\n    }\n    \n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n```\n也是非常简单，添加了3个子视图，并且确定位置了。\n\n## 6 AddressModel 实现逻辑\n这个是四级地址的数据模型，可以看下：\n```Swift\nimport Foundation\nimport HandyJSON\n\nclass AddressModel: HandyJSON {\n    var data: [RegionModel] = []\n    required init() {}\n}\n\nclass RegionModel: HandyJSON {\n    var code: String = \"\"\n    var name: String = \"\"\n    var children: [RegionModel] = []\n    required init() {}\n}\n```\n继承了HandyJSON，方便解析。\n这里AddressModel实际上内部也是由 RegionModel数组构成的。\n这个AddressModel用来存放省列表比较合适。\n\nRegionModel可以存放市，区，街道，都没问题。\n\n封装四级地址基本上就这些了。\n\n## 7 外部调用方式\n\n### 7.1 先声明一个四级地址View\n```Swift\nlazy private var addressView: AddressView = {\n        let tmpview = AddressView(frame: CGRect.init(x: 0, y: 0, width: ScreenWidth, height: ScreenHeight))\n        return tmpview\n    }()\n```\n这里设定了它的frame，也就是大小位置。\n\n### 7.2  弹出四级地址\n```Swift\nfunc showAddressSelector(){\n        self.view.addSubview(self.addressView)\n        self.addressView.traverse(province: self.orderAddressModel?.province ?? \"\", city: self.orderAddressModel?.city ?? \"\", area: self.orderAddressModel?.region ?? \"\", street: self.orderAddressModel?.street ?? \"\")\n        addressView.selectAddressHandle = {[weak self] (arr)in\n            guard let weakSelf = self else{return}\n            let pModel = arr[0]\n            let cModel = arr[1]\n            let aModel = arr[2]\n            let tModel = arr[3]\n            ...\n            \n        }\n    }\n```\n这里通过addSubview的方式，将这个四级地址添加到这个UIViewController的根布局上。类似叠加布局的方式。\n\n然后调用了一个关键的函数，traverse，将初始地址设置进去。\n\n然后设置了选择回调函数，这里用户选择了四级地址后，会回调到这个handle里面哦。\n\n## 8 总结\n\n* 做一个复杂的自定义View，一定要化繁为简，将复杂的结构一步一步拆分成一个一个基本视图，这样能够很好规划实现方案。\n\n* 任何一个自定义View实现方案可能会有多种，可以选择自己最熟悉的一种，然后进行研究，觉得不合适可以换其它方案来实现。\n\n* 四级地址最关键的应该是数据了，这里我们实现方案是单页面，数据同步刷新的方式，其实也可以考虑多页面，可自由切换，毕竟地址层级不会太多。\n\n* 需要考虑到用户之前填写的地址，可能只填了1到3级，所以一定要考虑全面一点，作为封装视图者，不能只考虑到最完美的情况。\n\n* 多个UITableView是可以共用同一个代理和数据源的，只需要再代理里面区分下是那个UITableView即可。\n\n* UITableView有很多代理协议，这里可以设置多个组类，一个组多少行，头部View，尾部View，头部高度，尾部高度，点击item，等多种方法，可以实现很复杂的逻辑。\n\n* UITableView的Cell一定要分配一个标识符，用来复用，增加程序稳定性。","source":"_posts/iOS-swift-自定义View之四级地址.md","raw":"---\ntitle: iOS-swift-自定义View之四级地址\ndate: 2023-01-27 16:26:44\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- iOS 自定义View\ncategories:\n- iOS\n---\n\n## 1 需求分析\n目标是可以选择四级地址，什么是四级地址呢？省市区街道。类似淘宝买东西时，支付订单时需要填写收货地址，这里就需要构造一个四级地址弹框，让用户去选择。具体效果如下：\n<img src=%E5%9B%9B%E7%BA%A7%E5%9C%B0%E5%9D%80.gif>\n\n这个我们可以单独将这个地址弹框单独封装一下，本身就是一个工具，很多地方可能会用的。\n另外还需要提供传参，因为可能用户之前选择了某些地址，现在要更改，就需要跳转到已选择的四级地址，并且可以自己切换任何一个省市区，如果重新选择省，那么下级地址都需要清空；如果重新更新了市，那么下级清空，上级保留。\n大概就是这样子。\n\n所以我们就可以将四级地址视图用一个UIView来实现。\n\n## 2 控件结构\n\n首先我们分析下如何来完成这个需求，代码如何实现。\n这里我们考虑将ui提供的四级地址，通过自定义View来实现。\n\n顶部有一个列表，就是记录用户已选地址，省市区街道。\n底部也有一个列表，而且有分组，以地址的拼音首字母分组，组下也可能有会有不定行数的cell。\n\n这里我们就考虑 用两个UITableView来承载顶部和底部的列表。\n两个UITableView都放在  AddressView 的自定义View里面吧。\n\n所以会多出两个Cell，一个是顶部Cell，就叫做AddressCell吧；一个是底部Cell，承载底部列表，就叫做AddressSelectorCell吧。\n\n另外还有数据层，就叫它 AddressModel吧，放地址数据的。\n\n所以我们只需要4个文件就可以完成这个需求了。\n\n* AddressView 四级地址自定义View\n* AddressCell 顶部Cell\n* AddressSelectorCell 底部Cell\n* AddressModel 数据层\n\n## 3 AddressView 实现逻辑\n\n### 3.1 全局变量定义\n```Swift\nclass AddressView: UIView {\n    \n    typealias selectAddressBlock = (Array<RegionModel>)->()\n    var selectAddressHandle: selectAddressBlock?\n    var cancelAddressHandle: Handler?\n    \n    var modelArray: Array<Any> = []\n    var addressArray: Array<(key: Swift.String, value: Array<RegionModel>)> = []\n    var selectedIndex: Int = 0\n```\n这里定义一个闭包，就是用户勾选了4级地址后，需要将地址暴露个调用方，肯定需要一个方法发出去的。\n\ncancelAddressHandle是一个取消函数，主要处理用户点击蒙层或者点击取消的事件。\n\nmodelArray是记录顶部列表数据的数组。\n\naddressArray是记录底部列表数据的数组。\n\nselectedIndex是记录顶部选择了第几项的全局变量记录。\n\n然后是2个懒加载的UITableView，看下哈：\n```Swift\n/// 顶部视图列表\nprivate lazy var tblView: UITableView = {\n    let tableView = UITableView.init(frame: CGRect(x: 0, y: 196, width: ScreenWidth, height: ScreenHeight - 196), style: .grouped)\n    tableView.register(AddressCell.self, forCellReuseIdentifier: AddressCell.identifier)\n    tableView.delegate = self\n    tableView.dataSource = self\n    tableView.separatorStyle = .none\n    tableView.backgroundColor = .white\n    tableView.showsVerticalScrollIndicator = false\n    tableView.showsHorizontalScrollIndicator = false\n    tableView.isScrollEnabled = false\n    tableView.layer.cornerRadius = 14\n    tableView.layer.maskedCorners = [.layerMinXMinYCorner,.layerMaxXMinYCorner]\n    return tableView\n}()\n```\n\n还有一个底部的列表：\n```Swift\n/// 底部视图列表\nprivate lazy var addressTblView: UITableView = {\n    let tableView = UITableView.init(frame: CGRect.zero, style: .grouped)\n    tableView.register(AddressSelectorCell.self, forCellReuseIdentifier: AddressSelectorCell.identifier)\n    tableView.delegate = self\n    tableView.dataSource = self\n    tableView.backgroundColor = .white\n    tableView.separatorStyle = .none\n    tableView.showsVerticalScrollIndicator = false\n    tableView.showsHorizontalScrollIndicator = false\n    return tableView\n}()\n```\n虽然是两个UITableView，但可以共享同一个代理和数据源，需要在里面另外加if else判断下。\n\n### 3.2 生命周期函数\n这里只有一个初始化，但其实没有做什么，也没有把那两个UITableView加进去，这里应该就是空白的区域。\n```Swift\n  override init(frame: CGRect) {\n        super.init(frame: frame)\n        self.backgroundColor = UIColor.init(red: 0, green: 0, blue: 0, alpha: 0.6)\n    }\n    \n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n```\n\n### 3.3 初始化数据\n这里是另外提供的函数，来初始化，所以需要调用方额外调用这个方法。\n也正是这个方法，才会去加载ui的。\n\n```Swift\nfunc traverse(province: String, city: String, area: String, street: String){\n        modelArray.removeAll()\n        let dataArr: [RegionModel] = globalAddressModel?.data ?? AddressModel.init().data\n        self.recursive(dataArr: dataArr, province: province, city: city, area: area, street: street)\n        \n        if globalAddressModel != nil {\n            if modelArray.count == 0 {\n                /// 这里就展示省列表\n                self.setData(data: globalAddressModel!)\n            }else if modelArray.count == 4{\n                /// 这里展示街道列表\n                let model = modelArray[2]\n                self.setData(data: model)\n            } else{\n                /// 其它情况，就拿最后一个数据，在设置给底部内容tableView里面\n                let model = modelArray.last as! RegionModel\n                self.setData(data: model)\n            }\n        }\n        if modelArray.count < 4 {\n            modelArray.append(\"请选择\")\n        }\n        \n        /// 大概意思就是找到“请选择”在哪一个位置\n        selectedIndex = modelArray.firstIndex{$0 is String} ?? modelArray.count-1\n        /// 开始加载UI\n        self.loadUI()\n    }\n```\nglobalAddressModel 实际上再AppDelegate初始化的时候就去异步加载json文件了，这个应该就是保存的所有的四级地址信息了。\n\n然后这里用到了一个函数 recursive函数，是递归来寻找目标四级地址。\n```Swift\n/// 递归获取目标地址\nfunc recursive(dataArr: [RegionModel], province: String, city: String, area: String, street: String){\n    for model in dataArr{\n        if model.name.contains(province) ||\n            model.name.contains(city) ||\n            model.name.contains(area) ||\n            model.name.contains(street){\n            modelArray.append(model)\n            self.recursive(dataArr: model.children, province: province, city: city, area: area, street: street)\n            break\n        }\n    }\n}\n```\n找到后，会将实体append到这个数组中。\n\n然后上面初始化数据还用到一个函数：setData，作用是设置底部数据，因为这里底部自始至终都是同一个UITableView，会经常需要刷新数据。这里就是刷新底部数据的意思吧。\n\n看下这个setData函数哈：\n```Swift\nfunc setData(data: Any){\n        var dataArr: [RegionModel] = []\n        if data is AddressModel {\n            let tmpData = data as! AddressModel\n            dataArr = tmpData.data\n        }else{\n            let tmpData = data as! RegionModel\n            dataArr = tmpData.children\n        }\n        /// 上面的代码目的是为了拿到 RegionModel数组\n        \n        if dataArr.count == 0 {\n            return\n        }\n        \n        var tmpDic: Dictionary<String,Array<RegionModel>> = Dictionary<String,Array<RegionModel>>()\n        for model in dataArr{\n            var key: String = \"\"\n            key = self.findFirstLetterFromString(aString: model.name)\n            var arr = tmpDic[key] ?? Array<RegionModel>()\n            arr.append(model)\n            tmpDic[key] = arr\n        }\n        \n        //处理了第二个字首字母排序\n        _ = tmpDic.keys.compactMap{ key in\n            var tmpArr = tmpDic[key]!\n            tmpArr = tmpArr.sorted{(model1,model2) in\n                var key1 = \"\"\n                var key2 = \"\"\n                key1 = self.findFirstLetterFromString(aString: model1.name, isSecond: true)\n                key2 = self.findFirstLetterFromString(aString: model2.name, isSecond: true)\n                return key1 < key2\n            }\n            tmpDic[key] = tmpArr\n        }\n        addressArray = tmpDic.sorted{$0.key < $1.key}\n        \n        /// addressArray应该是拿到目前展示的内容区域数据 底部区域\n        self.addressTblView.reloadData()\n    }\n```\n这里代码虽然长，但实际上具体还是挺简单的，主要是生成一个字典的映射关系，key存放首字母，value存放同一个首字母下对应的地址列表。大概意思就是这个tmpDic是一个key value形式的map集合，key是这些比如省份首字母为G，那么value就对应广东省，甘肃省，广西，贵州省等下的所有地址。这里就对应tableView里面的每一组的数据了。然后处理下第二个首字母排序的问题。\n\n好的，这里打住了，回到第一个函数 traverse方法中，里面根据modelArray的长度去决定刷新哪一个列表，因为调用方给的地址不一定是四级，可能是1级或2级或3级，这里也是需要考虑到的。能在哪个层级搜索到，就定位到哪个层级，那么最后一个层级这里使用 append一个“请选择”，这里说明如果是字符串了，那么这里就是最后一层级。感觉这还可以优化下，比较用字符串来判断到哪一层级不太合适的。\n\ntraverse最后一个方法是加载UI。\n```Swift\nfunc loadUI(){\n        /// 先加顶部\n        self.addSubview(tblView)\n        /// 顶部布局\n        self.updateUI()\n        \n        /// 再加底部\n        self.addSubview(addressTblView)\n        /// 底部布局\n        addressTblView.snp.remakeConstraints{make in\n            make.leading.trailing.bottom.equalTo(0)\n            make.top.equalTo(tblView.snp.bottom).offset(0)\n        }\n    }\n\nfunc updateUI(){\n        tblView.snp.remakeConstraints{make in\n            make.leading.trailing.equalTo(0)\n            make.top.equalTo(196)\n            if modelArray.count == 1 {\n                make.height.equalTo(96)\n            }else{\n                make.height.equalTo(96+modelArray.count*48)\n            }\n        }\n        self.tblView.reloadData()\n    }\n```\n大概意思就是把那两个UITableView加给父View。\n\n然后需要用的扩展方法有下面这个：\n```Swift\nextension AddressView{\n    \n    /// 找到中文对应的第一个字符对应的第一个字母拼音\n    func findFirstLetterFromString(aString: String, isSecond : Bool = false) -> String {\n        //转变成可变字符串\n        let mutableString = NSMutableString.init(string: aString)\n        \n        //将中文转换成带声调的拼音\n        CFStringTransform(mutableString as CFMutableString, nil,      kCFStringTransformToLatin, false)\n        \n        //去掉声调\n        let pinyinString = mutableString.folding(options:          String.CompareOptions.diacriticInsensitive, locale:   NSLocale.current)\n        \n        //将拼音首字母换成大写\n        let strPinYin = polyphoneStringHandle(nameString: aString,    pinyinString: pinyinString).uppercased()\n        \n        //截取大写首字母\n        let arr = strPinYin.components(separatedBy: \" \")\n        let completeStr = isSecond == false ? arr[0] : arr[1]\n        let firstString = completeStr.subScript(index: 0, length: 1)\n        //判断首字母是否为大写\n        let regexA = \"^[A-Z]$\"\n        let predA = NSPredicate.init(format: \"SELF MATCHES %@\", regexA)\n        return predA.evaluate(with: firstString) ? firstString : \"#\"\n    }\n    \n    //多音字处理，根据需要添自行加\n    func polyphoneStringHandle(nameString: String, pinyinString: String) -> String {\n        //        if nameString.hasPrefix(\"长\") {return \"chang\"}\n        //        if nameString.hasPrefix(\"沈\") {return \"shen\"}\n        //        if nameString.hasPrefix(\"厦\") {return \"xia\"}\n        //        if nameString.hasPrefix(\"地\") {return \"di\"}\n        //        if nameString.hasPrefix(\"重\") {return \"chong\"}\n        return pinyinString\n    }\n}\n```\n这里主要是一个工具方法，内部使用，无需多讲。\n\n好了，前面的ui基本就这些。\n下面主要是讲解下UITableView的代理方法和数据源配置。\n\n```Swift\n/// 设置顶部tableView 代理和数据\nextension AddressView: UITableViewDelegate,UITableViewDataSource{\n    func numberOfSections(in tableView: UITableView) -> Int {\n        if tableView == tblView {\n            return 1    /// 顶部tableView只有一组\n        }else{\n            return addressArray.count   /// 很多组 26个字母都有的话，就26组\n        }\n    }\n```\n这里扩展AddressView，去实现UITableViewDelegate和UITableViewDataSource协议。\n这是第一个方法，numberOfSections，返回有多少组。这里因为顶部只有一种类型，也就只有一组，底部用了一个数组记录，组数就是数组的长度。\n\n```Swift\nfunc tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        if tableView == tblView {\n            /// 顶部，如果没有 历史地址，则为0，有则显示 一组多少个\n            if modelArray.count == 1 && (modelArray.last is String) {\n                return 0\n            }else{\n                return modelArray.count\n            }\n        }else{\n            /// 取当前组里面多少个\n            let dic = addressArray[section]\n            let arr = dic.value\n            return arr.count\n        }\n    }\n```\n这是第二个方法，numberOfRowsInSection，意思就是这个组下有多少行。\n\n```Swift\n func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n        /// 上面下面都是48\n        if tableView == tblView {\n            return 48\n        }else{\n            return 48\n        }\n    }\n```\n这里是每行的高度。\n\n```Swift\n/// 每个cell怎么显示\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    /// 如果是顶部\n    if tblView == tableView {\n        /// 顶部用AddressCell\n        let cell = tableView.dequeueReusableCell(withIdentifier: AddressCell.identifier, for: indexPath) as! AddressCell\n        let model = modelArray[indexPath.row]\n        /// 数据用modelArray里面的数据\n        cell.model = model\n        /// 选中的话，高亮显示文字颜色\n        if selectedIndex == indexPath.row {\n            cell.titleLb.textColor = UIColor.init(hex: \"#409EFF\")\n        }else{\n            cell.titleLb.textColor = UIColor.init(hex: \"#3B4058\")\n        }\n        /// 这里是请选择什么\n        if model is String {\n            cell.updateUI(indexPath: indexPath)\n        }\n        \n        /// 指示剂方向\n        if indexPath.row == 0 {\n            cell.position = .down // 第0行，只有下面的\n        }else if indexPath.row == modelArray.count-1{\n            cell.position = .top /// 最后一行，只有上面\n        }else{\n            cell.position = .middle /// 其它都有\n        }\n        \n        return cell\n    }else{\n        /// 如果是底部，数据取addressArray里面的\n        let dic = addressArray[indexPath.section]\n        let arr = dic.value\n        let model = arr[indexPath.row] // 这个字母类别里面的 第row行\n        \n        /// 这个cell用 AddressSelector来实现\n        let cell = tableView.dequeueReusableCell(withIdentifier: AddressSelectorCell.identifier, for: indexPath) as! AddressSelectorCell\n        \n        /// 第1行才有字母\n        if indexPath.row == 0 {\n            cell.indexLb.text = dic.key\n        }else{\n            cell.indexLb.text = \"\"\n        }\n        \n        /// 当前在那个层级 比如是广东省\n        let obj = modelArray[selectedIndex]\n        if obj is String { /// 请选择层级\n            cell.checkImgView.isHidden = true\n            cell.nameLb.textColor = UIColor.init(hex: \"#3B4058\")\n        }else{\n            /// 已选层级\n            let selectedModel = obj as! RegionModel\n            if selectedModel.name == model.name { /// 列表中的就是已选的，高亮一下\n                cell.nameLb.textColor = UIColor.init(hex: \"#409EFF\")\n                cell.checkImgView.isHidden = false\n            }else{\n                cell.nameLb.textColor = UIColor.init(hex: \"#3B4058\")\n                cell.checkImgView.isHidden = true\n            }\n        }\n        \n        ///  显示目标地址名称\n        cell.nameLb.text = model.name\n        return cell\n    }\n}\n```\n这个方法就比较关键了，就是每行怎么展现的。\n用哪个Cell，是否要高亮，指示剂怎么展示，这里有点像Android的adpter里面的bindAdapter实现逻辑。这里需要按照需求在item里面自行处理逻辑。\n\n如果是底部，就需要考虑是否显示字母，是否高亮这些了。\n\n```Swift\n/// 标题和单元格间隔\nfunc tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {\n    /// 顶部头部预留48dp显示标题“请选择所在地区”\n    if tableView == tblView {\n        return 48\n    }else{\n        return 0.01\n    }\n}\n```\n顶部预留高度，用来展示自己的标题。\n\n```Swift\n/// 和上面对应，预留48个dp怎么显示\nfunc tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {\n    if tableView == tblView {\n        let view = UIView.init(frame: CGRect.init(x: 0, y: 0, width: ScreenWidth, height: 48))\n        let label = UILabel.init()\n        label.font = .pingFangSemibold(size: 18)\n        label.textColor = UIColor.init(hex: \"#3B4058\")\n        label.text = \"请选择所在地区\"\n        \n        let closeBtn: UIButton = {\n            let btn = UIButton()\n            btn.setTitle(\"取消\", for: .normal)\n            btn.setTitleColor(UIColor.init(hex: \"#409EFF\"), for: .normal)\n            btn.titleLabel?.font = .pingFangRegular(size: 16)\n            btn.addTarget(self, action: #selector(actionForClose), for: .touchUpInside)\n            return btn\n        }()\n        \n        view.addSubview(label)\n        view.addSubview(closeBtn)\n        label.snp.makeConstraints{make in\n            make.centerY.equalTo(view)\n            make.centerX.equalTo(view)\n            make.width.equalTo(130)\n            make.height.equalTo(30)\n        }\n        closeBtn.snp.makeConstraints{make in\n            make.trailing.equalTo(-16)\n            make.centerY.equalTo(view)\n            make.width.equalTo(48)\n            make.height.equalTo(48)\n        }\n        return view\n    }else{\n        return UIView()\n    }\n}\n```\n标题和取消按钮显示逻辑。\n\n```Swift\n/// 单元格尾巴怎么显示\nfunc tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -> CGFloat {\n    /// 如果是顶部tableView，预留48个dp\n    if tableView == tblView {\n        return 48\n    }else{\n        return 0.01\n    }\n}\n```\n这里顶部有效，有48个单位长度，用来显示底部标题。\n\n```Swift\n/// 尾部显示 选择下级地址\nfunc tableView(_ tableView: UITableView, viewForFooterInSection section: Int) -> UIView? {\n    if tableView == tblView {\n        let view = UIView.init(frame: CGRect.init(x: 0, y: 0, width: ScreenWidth, height: 48))\n        \n        let lineView = UIView()\n        lineView.backgroundColor = UIColor.init(hex: \"#F6F6F6\")\n        let label = UILabel.init()\n        label.font = .pingFangSemibold(size: 16)\n        label.textColor = UIColor.init(hex: \"#3B4058\")\n        \n        if selectedIndex == 0 {\n            label.text = \"选择省份/地区\"\n        }else if selectedIndex == 1{\n            label.text = \"选择城市\"\n        }else if selectedIndex == 2{\n            label.text = \"选择区/县\"\n        }else{\n            label.text = \"选择街道/镇\"\n        }\n        \n        view.addSubview(lineView)\n        view.addSubview(label)\n        \n        lineView.snp.makeConstraints{make in\n            make.top.equalTo(4)\n            make.leading.trailing.equalTo(0)\n            make.height.equalTo(0.5)\n        }\n        label.snp.makeConstraints{make in\n            make.top.equalTo(16)\n            make.leading.equalTo(8)\n            make.width.equalTo(150)\n            make.height.equalTo(30)\n        }\n        return view\n    }else{\n        return UIView()\n    }\n}\n```\n这里就是确定底部标题的怎么显示的。\n\n```Swift\n/// 点击了单元格\nfunc tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n    if tblView == tableView {\n        /// 顶部点击了哪个单元格\n        if indexPath.row == 0 {\n            self.setData(data: globalAddressModel!)\n        }else{\n            let model = modelArray[indexPath.row-1]\n            self.setData(data: model)\n        }\n        selectedIndex = indexPath.row\n        /// 改变全局变量 selectedIndex，再去加载\n        self.tblView.reloadData()\n    }else{\n        /// 当前是哪一组\n        let dic = addressArray[indexPath.section]\n        let arr = dic.value\n        /// 当前是哪一行\n        let model = arr[indexPath.row]\n        \n        /// 请选择是第几个\n        let index = modelArray.firstIndex{$0 is String} ?? 0\n        /// 顶部是请选择\n        if modelArray[selectedIndex] is String && modelArray.count < 5{\n            /// 插入目标点击的地址 给modelArray\n            modelArray.insert(model, at: index)\n            if modelArray.count == 5 {\n                modelArray.removeLast()\n            }\n        }else{\n            /// 顶部不是请选择,而已已选择的地址\n            modelArray[selectedIndex] = model\n            /// 下面有请选择，需要清空之前选择的值\n            let isContain = modelArray.contains(where: {$0 is String})\n            if isContain {\n                for i in (selectedIndex+1 ... modelArray.count-1).reversed(){\n                    if modelArray[i] is String {\n                        continue\n                    }\n                    modelArray.remove(at: i)\n                }\n            } else if !isContain && selectedIndex != 3{\n                for i in (selectedIndex+1 ... modelArray.count-1).reversed(){\n                    modelArray.remove(at: i)\n                }\n            }\n            \n            if modelArray.count < 4 && !modelArray.contains(where: {$0 is String}){\n                modelArray.append(\"请选择\")\n            }\n        }\n        \n        /// 没有请选择了，会直接关闭弹框，执行回调\n        if modelArray.count == 4 && !modelArray.contains(where: {$0 is String}){\n            var arr: [RegionModel] = []\n            for model in modelArray {\n                let obj = model as! RegionModel\n                arr.append(obj)\n            }\n            selectAddressHandle?(arr)\n            self.removeFromSuperview()\n        }else{\n            /// 更新底部数据，以及顶部选择index\n            self.setData(data: model)\n            self.updateUI()\n            selectedIndex += 1\n        }\n    }\n}\n```\n上面的代码逻辑，主要就是处理点击顶部单元格，和底部单元格的逻辑。\n顶部点击会调用setData,会同步刷新底部。\n\n底部点击也会setData,刷新底部数据，如果全部选择，则会走闭包回调，将用户选择的四级地址回调出去。\n\n然后还有一些其它扩展方法，简单看下哈。\n```Swift\n/// 扩展给外部\nextension AddressView{\n    /// 通知调用者当有一个或者多个手指触摸到了视图或者窗口时触发此方法。\n    /// touches是UITouch的集合，通过UITouch我们可以检测触摸事件的属性，是单拍还是双拍，还有触摸的位置等。\n    /// 这里应该是触摸到蒙层后关闭弹框\n    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {\n        guard let point = touches.first?.location(in: self) else { return }\n        let p = self.layer.convert(point, from: self.layer)\n        if self.layer.contains(p) {\n            self.actionForClose()\n        }\n    }\n    \n    /// 移除自己，类似关闭弹框效果\n    @objc func actionForClose(){\n        cancelAddressHandle?()\n        self.removeFromSuperview()\n    }\n}\n```\n这里actionForClose是UiButton设置的一个action，上面哪个是覆写的官方方法，应该是触摸到蒙层自动关闭弹框。\n\n## 4 AddressCell 实现逻辑\n这个可以理解成Android中的Adapter了。也就是item怎么显示。\n```Swift\n/// 顶部cell\nclass AddressCell: UITableViewCell {\n    \n    enum LinePosition {\n        case down\n        case middle\n        case top\n    }\n    \n    static var identifier: String = \"AddressCell\"\n```\n这里需要继承UITableViewCell，必须要有一个identifier，这个主要是为了复用，因为列表可能会很长，为了合理复用，这里一般都需要一个标识符。\n\n### 4.1 子View定义\n```Swift\n /// 安徽省\nlazy var titleLb: UILabel = {\n    let label = UILabel()\n    label.font = .pingFangMedium(size: 16)\n    label.textColor = UIColor.init(hex: \"#3B4058\")\n    return label\n}()\n\n/// 实心圆\nlazy var roundView: UIView = {\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: \"#409EFF\")\n    view.layer.cornerRadius = 3.5\n    view.layer.borderWidth = 1\n    view.layer.borderColor = UIColor.init(hex: \"#409EFF\").cgColor\n    return view\n}()\n\n/// 圆上面的线条\nlazy private var toplineView: UIView = {\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: \"#409EFF\")\n    return view\n}()\n\n/// 圆下面的线条\nlazy private var downlineView: UIView = {\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: \"#409EFF\")\n    return view\n}()\n\n/// 右侧箭头\nlazy private var rightImgView: UIImageView = {\n    let imgView = UIImageView()\n    imgView.image = UIImage.init(named: \"客户信息_右箭头\")\n    return imgView\n}()\n```\n这里是顶部item用的一些零部件。\n比如上下线图，右侧箭头，中间文字。实心圆。\n这里变空心，实际上只是设置了中间颜色为纯白。\n\n### 4.2 数据定义\n```Swift\n/// 监听数据变化 数据填充\nvar model: Any?{\n    didSet{\n        guard let _model = model else{return}\n        if _model is RegionModel {\n            let tmp = _model as! RegionModel\n            titleLb.text = tmp.name\n        }\n    }\n}\n    \n/// 线条位置\nvar position: LinePosition?{\n    didSet{\n        guard let _position = position else{return}\n        /// 上面和下面的线条都先一出去\n        toplineView.removeFromSuperview()\n        downlineView.removeFromSuperview()\n        \n        /// 如果在下面 空心圆\n        if _position == .down {\n            contentView.addSubview(downlineView)\n            downlineView.snp.makeConstraints{make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(roundView.snp.top).offset(0)\n                make.bottom.equalTo(0)\n                make.width.equalTo(1)\n            }\n            roundView.backgroundColor = UIColor.init(hex: \"#409EFF\")\n        }else if _position == .top{\n            /// 如果在上面 空心圆\n            contentView.addSubview(toplineView)\n            toplineView.snp.makeConstraints{make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(0)\n                make.bottom.equalTo(roundView.snp.top)\n                make.width.equalTo(1)\n            }\n            if model is String {\n                roundView.backgroundColor = .white\n            }else{\n                roundView.backgroundColor = UIColor.init(hex: \"#409EFF\")\n            }\n        }else{\n            /// 都不在，也是都存在的意思\n            contentView.addSubview(toplineView)\n            contentView.addSubview(downlineView)\n            toplineView.snp.makeConstraints{make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(0)\n                make.bottom.equalTo(roundView.snp.top)\n                make.width.equalTo(1)\n            }\n            downlineView.snp.remakeConstraints{make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(roundView.snp.bottom)\n                make.bottom.equalTo(0)\n                make.width.equalTo(1)\n            }\n            roundView.backgroundColor = UIColor.init(hex: \"#409EFF\")\n        }\n    }\n}\n```\n这里定义了2个数据，1个是具体显示什么的数据，一个是线条怎么展示，什么时候展示实心和空心圆的逻辑。\n\n### 4.3 生命周期函数\n首先看下初始化。\n```Swift\noverride init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        \n        self.selectionStyle = .none\n        \n        /// 添加安徽省\n        contentView.addSubview(titleLb)\n        titleLb.snp.makeConstraints{make in\n            make.centerY.equalToSuperview()\n            make.leading.equalTo(roundView.snp.trailing).offset(22)\n            make.trailing.equalTo(rightImgView.snp.leading).offset(10)\n            make.height.equalTo(20)\n        }\n        \n        /// 添加圆形指示器\n        contentView.addSubview(roundView)\n        roundView.snp.makeConstraints{make in\n            make.centerY.equalToSuperview()\n            make.leading.equalTo(14)\n            make.width.equalTo(7)\n            make.height.equalTo(7)\n        }\n        \n        /// 添加右侧箭头\n        contentView.addSubview(rightImgView)\n        rightImgView.snp.makeConstraints{make in\n            make.centerY.equalToSuperview()\n            make.trailing.equalTo(-16)\n            make.width.equalTo(19)\n            make.height.equalTo(19)\n        }\n        \n    }\n    \n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n```\n这里就加了3个视图，并且布局了。\n\n### 4.4 其它扩展方法\n```Swift\nextension AddressCell{\n    func updateUI(indexPath: IndexPath){\n        if indexPath.row == 1 {\n            titleLb.text = \"请选择城市\"\n        }else if indexPath.row == 2 {\n            titleLb.text = \"请选择县\"\n        }else if indexPath.row == 3{\n            titleLb.text = \"请选街道\"\n        }else{\n            titleLb.text = \"\"//model as? String\n        }\n    }\n}\n```\n这里就是显示item特殊情况的文案。\n\n## 5 AddressSelectorCell 实现逻辑\n这里也同上面的Cell，有一个标识符。\n```Swift\n/// 底部Cell\nclass AddressSelectorCell: UITableViewCell {\n    \n    static var identifier: String = \"UITableViewCell\"\n```\n\n### 5.1 子View\n这里需要哪些子View呢？\n```Swift\n//索引 eg: A字母\nlazy var indexLb: UILabel = {\n    let label = UILabel()\n    label.font = .pingFangMedium(size: 12)\n    label.textColor = UIColor.init(hex: \"#9B9DA7\")\n    return label\n}()\n\n//名称 eg: 安徽省\nlazy var nameLb: UILabel = {\n    let label = UILabel()\n    label.font = .pingFangMedium(size: 14)\n    label.textColor = UIColor.init(hex: \"#3B4058\")\n    return label\n}()\n\n//勾选图标\nlazy var checkImgView: UIImageView = {\n    let imgView = UIImageView()\n    imgView.isHidden = true\n    imgView.image = UIImage.init(named: \"勾选\")\n    return imgView\n}()\n```\n这里非常简单，只有3个子视图，字母，中间名称，是否勾选。\n\n### 5.2 生命周期函数\n看下初始化吧。\n```Swift\noverride init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        self.selectionStyle = .none\n        \n        /// 添加索引，并且布局\n        contentView.addSubview(indexLb)\n        indexLb.snp.makeConstraints{make in\n            make.leading.equalTo(8)\n            make.centerY.equalToSuperview()\n            make.width.equalTo(10)\n            make.height.equalTo(20)\n        }\n        \n        /// 添加名称，并且位置确定\n        contentView.addSubview(nameLb)\n        nameLb.snp.makeConstraints{make in\n            make.leading.equalTo(indexLb.snp.trailing).offset(16)\n            make.trailing.equalTo(-16)\n            make.centerY.equalToSuperview()\n            make.height.equalTo(20)\n        }\n        \n        /// 确定勾选图标\n        contentView.addSubview(checkImgView)\n        checkImgView.snp.makeConstraints{make in\n            make.trailing.equalTo(-16)\n            make.centerY.equalToSuperview()\n            make.width.equalTo(16)\n            make.height.equalTo(16)\n        }\n    }\n    \n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n```\n也是非常简单，添加了3个子视图，并且确定位置了。\n\n## 6 AddressModel 实现逻辑\n这个是四级地址的数据模型，可以看下：\n```Swift\nimport Foundation\nimport HandyJSON\n\nclass AddressModel: HandyJSON {\n    var data: [RegionModel] = []\n    required init() {}\n}\n\nclass RegionModel: HandyJSON {\n    var code: String = \"\"\n    var name: String = \"\"\n    var children: [RegionModel] = []\n    required init() {}\n}\n```\n继承了HandyJSON，方便解析。\n这里AddressModel实际上内部也是由 RegionModel数组构成的。\n这个AddressModel用来存放省列表比较合适。\n\nRegionModel可以存放市，区，街道，都没问题。\n\n封装四级地址基本上就这些了。\n\n## 7 外部调用方式\n\n### 7.1 先声明一个四级地址View\n```Swift\nlazy private var addressView: AddressView = {\n        let tmpview = AddressView(frame: CGRect.init(x: 0, y: 0, width: ScreenWidth, height: ScreenHeight))\n        return tmpview\n    }()\n```\n这里设定了它的frame，也就是大小位置。\n\n### 7.2  弹出四级地址\n```Swift\nfunc showAddressSelector(){\n        self.view.addSubview(self.addressView)\n        self.addressView.traverse(province: self.orderAddressModel?.province ?? \"\", city: self.orderAddressModel?.city ?? \"\", area: self.orderAddressModel?.region ?? \"\", street: self.orderAddressModel?.street ?? \"\")\n        addressView.selectAddressHandle = {[weak self] (arr)in\n            guard let weakSelf = self else{return}\n            let pModel = arr[0]\n            let cModel = arr[1]\n            let aModel = arr[2]\n            let tModel = arr[3]\n            ...\n            \n        }\n    }\n```\n这里通过addSubview的方式，将这个四级地址添加到这个UIViewController的根布局上。类似叠加布局的方式。\n\n然后调用了一个关键的函数，traverse，将初始地址设置进去。\n\n然后设置了选择回调函数，这里用户选择了四级地址后，会回调到这个handle里面哦。\n\n## 8 总结\n\n* 做一个复杂的自定义View，一定要化繁为简，将复杂的结构一步一步拆分成一个一个基本视图，这样能够很好规划实现方案。\n\n* 任何一个自定义View实现方案可能会有多种，可以选择自己最熟悉的一种，然后进行研究，觉得不合适可以换其它方案来实现。\n\n* 四级地址最关键的应该是数据了，这里我们实现方案是单页面，数据同步刷新的方式，其实也可以考虑多页面，可自由切换，毕竟地址层级不会太多。\n\n* 需要考虑到用户之前填写的地址，可能只填了1到3级，所以一定要考虑全面一点，作为封装视图者，不能只考虑到最完美的情况。\n\n* 多个UITableView是可以共用同一个代理和数据源的，只需要再代理里面区分下是那个UITableView即可。\n\n* UITableView有很多代理协议，这里可以设置多个组类，一个组多少行，头部View，尾部View，头部高度，尾部高度，点击item，等多种方法，可以实现很复杂的逻辑。\n\n* UITableView的Cell一定要分配一个标识符，用来复用，增加程序稳定性。","slug":"iOS-swift-自定义View之四级地址","published":1,"updated":"2023-02-01T07:17:16.382Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlhfhyv001jivv724f849t5","content":"<h2 id=\"1-需求分析\"><a href=\"#1-需求分析\" class=\"headerlink\" title=\"1 需求分析\"></a>1 需求分析</h2><p>目标是可以选择四级地址，什么是四级地址呢？省市区街道。类似淘宝买东西时，支付订单时需要填写收货地址，这里就需要构造一个四级地址弹框，让用户去选择。具体效果如下：<br><img src=%E5%9B%9B%E7%BA%A7%E5%9C%B0%E5%9D%80.gif></p>\n<p>这个我们可以单独将这个地址弹框单独封装一下，本身就是一个工具，很多地方可能会用的。<br>另外还需要提供传参，因为可能用户之前选择了某些地址，现在要更改，就需要跳转到已选择的四级地址，并且可以自己切换任何一个省市区，如果重新选择省，那么下级地址都需要清空；如果重新更新了市，那么下级清空，上级保留。<br>大概就是这样子。</p>\n<p>所以我们就可以将四级地址视图用一个UIView来实现。</p>\n<h2 id=\"2-控件结构\"><a href=\"#2-控件结构\" class=\"headerlink\" title=\"2 控件结构\"></a>2 控件结构</h2><p>首先我们分析下如何来完成这个需求，代码如何实现。<br>这里我们考虑将ui提供的四级地址，通过自定义View来实现。</p>\n<p>顶部有一个列表，就是记录用户已选地址，省市区街道。<br>底部也有一个列表，而且有分组，以地址的拼音首字母分组，组下也可能有会有不定行数的cell。</p>\n<p>这里我们就考虑 用两个UITableView来承载顶部和底部的列表。<br>两个UITableView都放在  AddressView 的自定义View里面吧。</p>\n<p>所以会多出两个Cell，一个是顶部Cell，就叫做AddressCell吧；一个是底部Cell，承载底部列表，就叫做AddressSelectorCell吧。</p>\n<p>另外还有数据层，就叫它 AddressModel吧，放地址数据的。</p>\n<p>所以我们只需要4个文件就可以完成这个需求了。</p>\n<ul>\n<li>AddressView 四级地址自定义View</li>\n<li>AddressCell 顶部Cell</li>\n<li>AddressSelectorCell 底部Cell</li>\n<li>AddressModel 数据层</li>\n</ul>\n<h2 id=\"3-AddressView-实现逻辑\"><a href=\"#3-AddressView-实现逻辑\" class=\"headerlink\" title=\"3 AddressView 实现逻辑\"></a>3 AddressView 实现逻辑</h2><h3 id=\"3-1-全局变量定义\"><a href=\"#3-1-全局变量定义\" class=\"headerlink\" title=\"3.1 全局变量定义\"></a>3.1 全局变量定义</h3><pre><code class=\"line-numbers language-Swift\">class AddressView: UIView &#123;\n    \n    typealias selectAddressBlock = (Array&lt;RegionModel&gt;)-&gt;()\n    var selectAddressHandle: selectAddressBlock?\n    var cancelAddressHandle: Handler?\n    \n    var modelArray: Array&lt;Any&gt; = []\n    var addressArray: Array&lt;(key: Swift.String, value: Array&lt;RegionModel&gt;)&gt; = []\n    var selectedIndex: Int = 0\n</code></pre>\n<p>这里定义一个闭包，就是用户勾选了4级地址后，需要将地址暴露个调用方，肯定需要一个方法发出去的。</p>\n<p>cancelAddressHandle是一个取消函数，主要处理用户点击蒙层或者点击取消的事件。</p>\n<p>modelArray是记录顶部列表数据的数组。</p>\n<p>addressArray是记录底部列表数据的数组。</p>\n<p>selectedIndex是记录顶部选择了第几项的全局变量记录。</p>\n<p>然后是2个懒加载的UITableView，看下哈：</p>\n<pre><code class=\"line-numbers language-Swift\">/// 顶部视图列表\nprivate lazy var tblView: UITableView = &#123;\n    let tableView = UITableView.init(frame: CGRect(x: 0, y: 196, width: ScreenWidth, height: ScreenHeight - 196), style: .grouped)\n    tableView.register(AddressCell.self, forCellReuseIdentifier: AddressCell.identifier)\n    tableView.delegate = self\n    tableView.dataSource = self\n    tableView.separatorStyle = .none\n    tableView.backgroundColor = .white\n    tableView.showsVerticalScrollIndicator = false\n    tableView.showsHorizontalScrollIndicator = false\n    tableView.isScrollEnabled = false\n    tableView.layer.cornerRadius = 14\n    tableView.layer.maskedCorners = [.layerMinXMinYCorner,.layerMaxXMinYCorner]\n    return tableView\n&#125;()\n</code></pre>\n<p>还有一个底部的列表：</p>\n<pre><code class=\"line-numbers language-Swift\">/// 底部视图列表\nprivate lazy var addressTblView: UITableView = &#123;\n    let tableView = UITableView.init(frame: CGRect.zero, style: .grouped)\n    tableView.register(AddressSelectorCell.self, forCellReuseIdentifier: AddressSelectorCell.identifier)\n    tableView.delegate = self\n    tableView.dataSource = self\n    tableView.backgroundColor = .white\n    tableView.separatorStyle = .none\n    tableView.showsVerticalScrollIndicator = false\n    tableView.showsHorizontalScrollIndicator = false\n    return tableView\n&#125;()\n</code></pre>\n<p>虽然是两个UITableView，但可以共享同一个代理和数据源，需要在里面另外加if else判断下。</p>\n<h3 id=\"3-2-生命周期函数\"><a href=\"#3-2-生命周期函数\" class=\"headerlink\" title=\"3.2 生命周期函数\"></a>3.2 生命周期函数</h3><p>这里只有一个初始化，但其实没有做什么，也没有把那两个UITableView加进去，这里应该就是空白的区域。</p>\n<pre><code class=\"line-numbers language-Swift\">  override init(frame: CGRect) &#123;\n        super.init(frame: frame)\n        self.backgroundColor = UIColor.init(red: 0, green: 0, blue: 0, alpha: 0.6)\n    &#125;\n    \n    required init?(coder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n</code></pre>\n<h3 id=\"3-3-初始化数据\"><a href=\"#3-3-初始化数据\" class=\"headerlink\" title=\"3.3 初始化数据\"></a>3.3 初始化数据</h3><p>这里是另外提供的函数，来初始化，所以需要调用方额外调用这个方法。<br>也正是这个方法，才会去加载ui的。</p>\n<pre><code class=\"line-numbers language-Swift\">func traverse(province: String, city: String, area: String, street: String)&#123;\n        modelArray.removeAll()\n        let dataArr: [RegionModel] = globalAddressModel?.data ?? AddressModel.init().data\n        self.recursive(dataArr: dataArr, province: province, city: city, area: area, street: street)\n        \n        if globalAddressModel != nil &#123;\n            if modelArray.count == 0 &#123;\n                /// 这里就展示省列表\n                self.setData(data: globalAddressModel!)\n            &#125;else if modelArray.count == 4&#123;\n                /// 这里展示街道列表\n                let model = modelArray[2]\n                self.setData(data: model)\n            &#125; else&#123;\n                /// 其它情况，就拿最后一个数据，在设置给底部内容tableView里面\n                let model = modelArray.last as! RegionModel\n                self.setData(data: model)\n            &#125;\n        &#125;\n        if modelArray.count &lt; 4 &#123;\n            modelArray.append(&quot;请选择&quot;)\n        &#125;\n        \n        /// 大概意思就是找到“请选择”在哪一个位置\n        selectedIndex = modelArray.firstIndex&#123;$0 is String&#125; ?? modelArray.count-1\n        /// 开始加载UI\n        self.loadUI()\n    &#125;\n</code></pre>\n<p>globalAddressModel 实际上再AppDelegate初始化的时候就去异步加载json文件了，这个应该就是保存的所有的四级地址信息了。</p>\n<p>然后这里用到了一个函数 recursive函数，是递归来寻找目标四级地址。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 递归获取目标地址\nfunc recursive(dataArr: [RegionModel], province: String, city: String, area: String, street: String)&#123;\n    for model in dataArr&#123;\n        if model.name.contains(province) ||\n            model.name.contains(city) ||\n            model.name.contains(area) ||\n            model.name.contains(street)&#123;\n            modelArray.append(model)\n            self.recursive(dataArr: model.children, province: province, city: city, area: area, street: street)\n            break\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>找到后，会将实体append到这个数组中。</p>\n<p>然后上面初始化数据还用到一个函数：setData，作用是设置底部数据，因为这里底部自始至终都是同一个UITableView，会经常需要刷新数据。这里就是刷新底部数据的意思吧。</p>\n<p>看下这个setData函数哈：</p>\n<pre><code class=\"line-numbers language-Swift\">func setData(data: Any)&#123;\n        var dataArr: [RegionModel] = []\n        if data is AddressModel &#123;\n            let tmpData = data as! AddressModel\n            dataArr = tmpData.data\n        &#125;else&#123;\n            let tmpData = data as! RegionModel\n            dataArr = tmpData.children\n        &#125;\n        /// 上面的代码目的是为了拿到 RegionModel数组\n        \n        if dataArr.count == 0 &#123;\n            return\n        &#125;\n        \n        var tmpDic: Dictionary&lt;String,Array&lt;RegionModel&gt;&gt; = Dictionary&lt;String,Array&lt;RegionModel&gt;&gt;()\n        for model in dataArr&#123;\n            var key: String = &quot;&quot;\n            key = self.findFirstLetterFromString(aString: model.name)\n            var arr = tmpDic[key] ?? Array&lt;RegionModel&gt;()\n            arr.append(model)\n            tmpDic[key] = arr\n        &#125;\n        \n        //处理了第二个字首字母排序\n        _ = tmpDic.keys.compactMap&#123; key in\n            var tmpArr = tmpDic[key]!\n            tmpArr = tmpArr.sorted&#123;(model1,model2) in\n                var key1 = &quot;&quot;\n                var key2 = &quot;&quot;\n                key1 = self.findFirstLetterFromString(aString: model1.name, isSecond: true)\n                key2 = self.findFirstLetterFromString(aString: model2.name, isSecond: true)\n                return key1 &lt; key2\n            &#125;\n            tmpDic[key] = tmpArr\n        &#125;\n        addressArray = tmpDic.sorted&#123;$0.key &lt; $1.key&#125;\n        \n        /// addressArray应该是拿到目前展示的内容区域数据 底部区域\n        self.addressTblView.reloadData()\n    &#125;\n</code></pre>\n<p>这里代码虽然长，但实际上具体还是挺简单的，主要是生成一个字典的映射关系，key存放首字母，value存放同一个首字母下对应的地址列表。大概意思就是这个tmpDic是一个key value形式的map集合，key是这些比如省份首字母为G，那么value就对应广东省，甘肃省，广西，贵州省等下的所有地址。这里就对应tableView里面的每一组的数据了。然后处理下第二个首字母排序的问题。</p>\n<p>好的，这里打住了，回到第一个函数 traverse方法中，里面根据modelArray的长度去决定刷新哪一个列表，因为调用方给的地址不一定是四级，可能是1级或2级或3级，这里也是需要考虑到的。能在哪个层级搜索到，就定位到哪个层级，那么最后一个层级这里使用 append一个“请选择”，这里说明如果是字符串了，那么这里就是最后一层级。感觉这还可以优化下，比较用字符串来判断到哪一层级不太合适的。</p>\n<p>traverse最后一个方法是加载UI。</p>\n<pre><code class=\"line-numbers language-Swift\">func loadUI()&#123;\n        /// 先加顶部\n        self.addSubview(tblView)\n        /// 顶部布局\n        self.updateUI()\n        \n        /// 再加底部\n        self.addSubview(addressTblView)\n        /// 底部布局\n        addressTblView.snp.remakeConstraints&#123;make in\n            make.leading.trailing.bottom.equalTo(0)\n            make.top.equalTo(tblView.snp.bottom).offset(0)\n        &#125;\n    &#125;\n\nfunc updateUI()&#123;\n        tblView.snp.remakeConstraints&#123;make in\n            make.leading.trailing.equalTo(0)\n            make.top.equalTo(196)\n            if modelArray.count == 1 &#123;\n                make.height.equalTo(96)\n            &#125;else&#123;\n                make.height.equalTo(96+modelArray.count*48)\n            &#125;\n        &#125;\n        self.tblView.reloadData()\n    &#125;\n</code></pre>\n<p>大概意思就是把那两个UITableView加给父View。</p>\n<p>然后需要用的扩展方法有下面这个：</p>\n<pre><code class=\"line-numbers language-Swift\">extension AddressView&#123;\n    \n    /// 找到中文对应的第一个字符对应的第一个字母拼音\n    func findFirstLetterFromString(aString: String, isSecond : Bool = false) -&gt; String &#123;\n        //转变成可变字符串\n        let mutableString = NSMutableString.init(string: aString)\n        \n        //将中文转换成带声调的拼音\n        CFStringTransform(mutableString as CFMutableString, nil,      kCFStringTransformToLatin, false)\n        \n        //去掉声调\n        let pinyinString = mutableString.folding(options:          String.CompareOptions.diacriticInsensitive, locale:   NSLocale.current)\n        \n        //将拼音首字母换成大写\n        let strPinYin = polyphoneStringHandle(nameString: aString,    pinyinString: pinyinString).uppercased()\n        \n        //截取大写首字母\n        let arr = strPinYin.components(separatedBy: &quot; &quot;)\n        let completeStr = isSecond == false ? arr[0] : arr[1]\n        let firstString = completeStr.subScript(index: 0, length: 1)\n        //判断首字母是否为大写\n        let regexA = &quot;^[A-Z]$&quot;\n        let predA = NSPredicate.init(format: &quot;SELF MATCHES %@&quot;, regexA)\n        return predA.evaluate(with: firstString) ? firstString : &quot;#&quot;\n    &#125;\n    \n    //多音字处理，根据需要添自行加\n    func polyphoneStringHandle(nameString: String, pinyinString: String) -&gt; String &#123;\n        //        if nameString.hasPrefix(&quot;长&quot;) &#123;return &quot;chang&quot;&#125;\n        //        if nameString.hasPrefix(&quot;沈&quot;) &#123;return &quot;shen&quot;&#125;\n        //        if nameString.hasPrefix(&quot;厦&quot;) &#123;return &quot;xia&quot;&#125;\n        //        if nameString.hasPrefix(&quot;地&quot;) &#123;return &quot;di&quot;&#125;\n        //        if nameString.hasPrefix(&quot;重&quot;) &#123;return &quot;chong&quot;&#125;\n        return pinyinString\n    &#125;\n&#125;\n</code></pre>\n<p>这里主要是一个工具方法，内部使用，无需多讲。</p>\n<p>好了，前面的ui基本就这些。<br>下面主要是讲解下UITableView的代理方法和数据源配置。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 设置顶部tableView 代理和数据\nextension AddressView: UITableViewDelegate,UITableViewDataSource&#123;\n    func numberOfSections(in tableView: UITableView) -&gt; Int &#123;\n        if tableView == tblView &#123;\n            return 1    /// 顶部tableView只有一组\n        &#125;else&#123;\n            return addressArray.count   /// 很多组 26个字母都有的话，就26组\n        &#125;\n    &#125;\n</code></pre>\n<p>这里扩展AddressView，去实现UITableViewDelegate和UITableViewDataSource协议。<br>这是第一个方法，numberOfSections，返回有多少组。这里因为顶部只有一种类型，也就只有一组，底部用了一个数组记录，组数就是数组的长度。</p>\n<pre><code class=\"line-numbers language-Swift\">func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n        if tableView == tblView &#123;\n            /// 顶部，如果没有 历史地址，则为0，有则显示 一组多少个\n            if modelArray.count == 1 &amp;&amp; (modelArray.last is String) &#123;\n                return 0\n            &#125;else&#123;\n                return modelArray.count\n            &#125;\n        &#125;else&#123;\n            /// 取当前组里面多少个\n            let dic = addressArray[section]\n            let arr = dic.value\n            return arr.count\n        &#125;\n    &#125;\n</code></pre>\n<p>这是第二个方法，numberOfRowsInSection，意思就是这个组下有多少行。</p>\n<pre><code class=\"line-numbers language-Swift\"> func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n        /// 上面下面都是48\n        if tableView == tblView &#123;\n            return 48\n        &#125;else&#123;\n            return 48\n        &#125;\n    &#125;\n</code></pre>\n<p>这里是每行的高度。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 每个cell怎么显示\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n    /// 如果是顶部\n    if tblView == tableView &#123;\n        /// 顶部用AddressCell\n        let cell = tableView.dequeueReusableCell(withIdentifier: AddressCell.identifier, for: indexPath) as! AddressCell\n        let model = modelArray[indexPath.row]\n        /// 数据用modelArray里面的数据\n        cell.model = model\n        /// 选中的话，高亮显示文字颜色\n        if selectedIndex == indexPath.row &#123;\n            cell.titleLb.textColor = UIColor.init(hex: &quot;#409EFF&quot;)\n        &#125;else&#123;\n            cell.titleLb.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n        &#125;\n        /// 这里是请选择什么\n        if model is String &#123;\n            cell.updateUI(indexPath: indexPath)\n        &#125;\n        \n        /// 指示剂方向\n        if indexPath.row == 0 &#123;\n            cell.position = .down // 第0行，只有下面的\n        &#125;else if indexPath.row == modelArray.count-1&#123;\n            cell.position = .top /// 最后一行，只有上面\n        &#125;else&#123;\n            cell.position = .middle /// 其它都有\n        &#125;\n        \n        return cell\n    &#125;else&#123;\n        /// 如果是底部，数据取addressArray里面的\n        let dic = addressArray[indexPath.section]\n        let arr = dic.value\n        let model = arr[indexPath.row] // 这个字母类别里面的 第row行\n        \n        /// 这个cell用 AddressSelector来实现\n        let cell = tableView.dequeueReusableCell(withIdentifier: AddressSelectorCell.identifier, for: indexPath) as! AddressSelectorCell\n        \n        /// 第1行才有字母\n        if indexPath.row == 0 &#123;\n            cell.indexLb.text = dic.key\n        &#125;else&#123;\n            cell.indexLb.text = &quot;&quot;\n        &#125;\n        \n        /// 当前在那个层级 比如是广东省\n        let obj = modelArray[selectedIndex]\n        if obj is String &#123; /// 请选择层级\n            cell.checkImgView.isHidden = true\n            cell.nameLb.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n        &#125;else&#123;\n            /// 已选层级\n            let selectedModel = obj as! RegionModel\n            if selectedModel.name == model.name &#123; /// 列表中的就是已选的，高亮一下\n                cell.nameLb.textColor = UIColor.init(hex: &quot;#409EFF&quot;)\n                cell.checkImgView.isHidden = false\n            &#125;else&#123;\n                cell.nameLb.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n                cell.checkImgView.isHidden = true\n            &#125;\n        &#125;\n        \n        ///  显示目标地址名称\n        cell.nameLb.text = model.name\n        return cell\n    &#125;\n&#125;\n</code></pre>\n<p>这个方法就比较关键了，就是每行怎么展现的。<br>用哪个Cell，是否要高亮，指示剂怎么展示，这里有点像Android的adpter里面的bindAdapter实现逻辑。这里需要按照需求在item里面自行处理逻辑。</p>\n<p>如果是底部，就需要考虑是否显示字母，是否高亮这些了。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 标题和单元格间隔\nfunc tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat &#123;\n    /// 顶部头部预留48dp显示标题“请选择所在地区”\n    if tableView == tblView &#123;\n        return 48\n    &#125;else&#123;\n        return 0.01\n    &#125;\n&#125;\n</code></pre>\n<p>顶部预留高度，用来展示自己的标题。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 和上面对应，预留48个dp怎么显示\nfunc tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -&gt; UIView? &#123;\n    if tableView == tblView &#123;\n        let view = UIView.init(frame: CGRect.init(x: 0, y: 0, width: ScreenWidth, height: 48))\n        let label = UILabel.init()\n        label.font = .pingFangSemibold(size: 18)\n        label.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n        label.text = &quot;请选择所在地区&quot;\n        \n        let closeBtn: UIButton = &#123;\n            let btn = UIButton()\n            btn.setTitle(&quot;取消&quot;, for: .normal)\n            btn.setTitleColor(UIColor.init(hex: &quot;#409EFF&quot;), for: .normal)\n            btn.titleLabel?.font = .pingFangRegular(size: 16)\n            btn.addTarget(self, action: #selector(actionForClose), for: .touchUpInside)\n            return btn\n        &#125;()\n        \n        view.addSubview(label)\n        view.addSubview(closeBtn)\n        label.snp.makeConstraints&#123;make in\n            make.centerY.equalTo(view)\n            make.centerX.equalTo(view)\n            make.width.equalTo(130)\n            make.height.equalTo(30)\n        &#125;\n        closeBtn.snp.makeConstraints&#123;make in\n            make.trailing.equalTo(-16)\n            make.centerY.equalTo(view)\n            make.width.equalTo(48)\n            make.height.equalTo(48)\n        &#125;\n        return view\n    &#125;else&#123;\n        return UIView()\n    &#125;\n&#125;\n</code></pre>\n<p>标题和取消按钮显示逻辑。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 单元格尾巴怎么显示\nfunc tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -&gt; CGFloat &#123;\n    /// 如果是顶部tableView，预留48个dp\n    if tableView == tblView &#123;\n        return 48\n    &#125;else&#123;\n        return 0.01\n    &#125;\n&#125;\n</code></pre>\n<p>这里顶部有效，有48个单位长度，用来显示底部标题。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 尾部显示 选择下级地址\nfunc tableView(_ tableView: UITableView, viewForFooterInSection section: Int) -&gt; UIView? &#123;\n    if tableView == tblView &#123;\n        let view = UIView.init(frame: CGRect.init(x: 0, y: 0, width: ScreenWidth, height: 48))\n        \n        let lineView = UIView()\n        lineView.backgroundColor = UIColor.init(hex: &quot;#F6F6F6&quot;)\n        let label = UILabel.init()\n        label.font = .pingFangSemibold(size: 16)\n        label.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n        \n        if selectedIndex == 0 &#123;\n            label.text = &quot;选择省份/地区&quot;\n        &#125;else if selectedIndex == 1&#123;\n            label.text = &quot;选择城市&quot;\n        &#125;else if selectedIndex == 2&#123;\n            label.text = &quot;选择区/县&quot;\n        &#125;else&#123;\n            label.text = &quot;选择街道/镇&quot;\n        &#125;\n        \n        view.addSubview(lineView)\n        view.addSubview(label)\n        \n        lineView.snp.makeConstraints&#123;make in\n            make.top.equalTo(4)\n            make.leading.trailing.equalTo(0)\n            make.height.equalTo(0.5)\n        &#125;\n        label.snp.makeConstraints&#123;make in\n            make.top.equalTo(16)\n            make.leading.equalTo(8)\n            make.width.equalTo(150)\n            make.height.equalTo(30)\n        &#125;\n        return view\n    &#125;else&#123;\n        return UIView()\n    &#125;\n&#125;\n</code></pre>\n<p>这里就是确定底部标题的怎么显示的。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 点击了单元格\nfunc tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123;\n    if tblView == tableView &#123;\n        /// 顶部点击了哪个单元格\n        if indexPath.row == 0 &#123;\n            self.setData(data: globalAddressModel!)\n        &#125;else&#123;\n            let model = modelArray[indexPath.row-1]\n            self.setData(data: model)\n        &#125;\n        selectedIndex = indexPath.row\n        /// 改变全局变量 selectedIndex，再去加载\n        self.tblView.reloadData()\n    &#125;else&#123;\n        /// 当前是哪一组\n        let dic = addressArray[indexPath.section]\n        let arr = dic.value\n        /// 当前是哪一行\n        let model = arr[indexPath.row]\n        \n        /// 请选择是第几个\n        let index = modelArray.firstIndex&#123;$0 is String&#125; ?? 0\n        /// 顶部是请选择\n        if modelArray[selectedIndex] is String &amp;&amp; modelArray.count &lt; 5&#123;\n            /// 插入目标点击的地址 给modelArray\n            modelArray.insert(model, at: index)\n            if modelArray.count == 5 &#123;\n                modelArray.removeLast()\n            &#125;\n        &#125;else&#123;\n            /// 顶部不是请选择,而已已选择的地址\n            modelArray[selectedIndex] = model\n            /// 下面有请选择，需要清空之前选择的值\n            let isContain = modelArray.contains(where: &#123;$0 is String&#125;)\n            if isContain &#123;\n                for i in (selectedIndex+1 ... modelArray.count-1).reversed()&#123;\n                    if modelArray[i] is String &#123;\n                        continue\n                    &#125;\n                    modelArray.remove(at: i)\n                &#125;\n            &#125; else if !isContain &amp;&amp; selectedIndex != 3&#123;\n                for i in (selectedIndex+1 ... modelArray.count-1).reversed()&#123;\n                    modelArray.remove(at: i)\n                &#125;\n            &#125;\n            \n            if modelArray.count &lt; 4 &amp;&amp; !modelArray.contains(where: &#123;$0 is String&#125;)&#123;\n                modelArray.append(&quot;请选择&quot;)\n            &#125;\n        &#125;\n        \n        /// 没有请选择了，会直接关闭弹框，执行回调\n        if modelArray.count == 4 &amp;&amp; !modelArray.contains(where: &#123;$0 is String&#125;)&#123;\n            var arr: [RegionModel] = []\n            for model in modelArray &#123;\n                let obj = model as! RegionModel\n                arr.append(obj)\n            &#125;\n            selectAddressHandle?(arr)\n            self.removeFromSuperview()\n        &#125;else&#123;\n            /// 更新底部数据，以及顶部选择index\n            self.setData(data: model)\n            self.updateUI()\n            selectedIndex += 1\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>上面的代码逻辑，主要就是处理点击顶部单元格，和底部单元格的逻辑。<br>顶部点击会调用setData,会同步刷新底部。</p>\n<p>底部点击也会setData,刷新底部数据，如果全部选择，则会走闭包回调，将用户选择的四级地址回调出去。</p>\n<p>然后还有一些其它扩展方法，简单看下哈。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 扩展给外部\nextension AddressView&#123;\n    /// 通知调用者当有一个或者多个手指触摸到了视图或者窗口时触发此方法。\n    /// touches是UITouch的集合，通过UITouch我们可以检测触摸事件的属性，是单拍还是双拍，还有触摸的位置等。\n    /// 这里应该是触摸到蒙层后关闭弹框\n    override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123;\n        guard let point = touches.first?.location(in: self) else &#123; return &#125;\n        let p = self.layer.convert(point, from: self.layer)\n        if self.layer.contains(p) &#123;\n            self.actionForClose()\n        &#125;\n    &#125;\n    \n    /// 移除自己，类似关闭弹框效果\n    @objc func actionForClose()&#123;\n        cancelAddressHandle?()\n        self.removeFromSuperview()\n    &#125;\n&#125;\n</code></pre>\n<p>这里actionForClose是UiButton设置的一个action，上面哪个是覆写的官方方法，应该是触摸到蒙层自动关闭弹框。</p>\n<h2 id=\"4-AddressCell-实现逻辑\"><a href=\"#4-AddressCell-实现逻辑\" class=\"headerlink\" title=\"4 AddressCell 实现逻辑\"></a>4 AddressCell 实现逻辑</h2><p>这个可以理解成Android中的Adapter了。也就是item怎么显示。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 顶部cell\nclass AddressCell: UITableViewCell &#123;\n    \n    enum LinePosition &#123;\n        case down\n        case middle\n        case top\n    &#125;\n    \n    static var identifier: String = &quot;AddressCell&quot;\n</code></pre>\n<p>这里需要继承UITableViewCell，必须要有一个identifier，这个主要是为了复用，因为列表可能会很长，为了合理复用，这里一般都需要一个标识符。</p>\n<h3 id=\"4-1-子View定义\"><a href=\"#4-1-子View定义\" class=\"headerlink\" title=\"4.1 子View定义\"></a>4.1 子View定义</h3><pre><code class=\"line-numbers language-Swift\"> /// 安徽省\nlazy var titleLb: UILabel = &#123;\n    let label = UILabel()\n    label.font = .pingFangMedium(size: 16)\n    label.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n    return label\n&#125;()\n\n/// 实心圆\nlazy var roundView: UIView = &#123;\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n    view.layer.cornerRadius = 3.5\n    view.layer.borderWidth = 1\n    view.layer.borderColor = UIColor.init(hex: &quot;#409EFF&quot;).cgColor\n    return view\n&#125;()\n\n/// 圆上面的线条\nlazy private var toplineView: UIView = &#123;\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n    return view\n&#125;()\n\n/// 圆下面的线条\nlazy private var downlineView: UIView = &#123;\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n    return view\n&#125;()\n\n/// 右侧箭头\nlazy private var rightImgView: UIImageView = &#123;\n    let imgView = UIImageView()\n    imgView.image = UIImage.init(named: &quot;客户信息_右箭头&quot;)\n    return imgView\n&#125;()\n</code></pre>\n<p>这里是顶部item用的一些零部件。<br>比如上下线图，右侧箭头，中间文字。实心圆。<br>这里变空心，实际上只是设置了中间颜色为纯白。</p>\n<h3 id=\"4-2-数据定义\"><a href=\"#4-2-数据定义\" class=\"headerlink\" title=\"4.2 数据定义\"></a>4.2 数据定义</h3><pre><code class=\"line-numbers language-Swift\">/// 监听数据变化 数据填充\nvar model: Any?&#123;\n    didSet&#123;\n        guard let _model = model else&#123;return&#125;\n        if _model is RegionModel &#123;\n            let tmp = _model as! RegionModel\n            titleLb.text = tmp.name\n        &#125;\n    &#125;\n&#125;\n    \n/// 线条位置\nvar position: LinePosition?&#123;\n    didSet&#123;\n        guard let _position = position else&#123;return&#125;\n        /// 上面和下面的线条都先一出去\n        toplineView.removeFromSuperview()\n        downlineView.removeFromSuperview()\n        \n        /// 如果在下面 空心圆\n        if _position == .down &#123;\n            contentView.addSubview(downlineView)\n            downlineView.snp.makeConstraints&#123;make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(roundView.snp.top).offset(0)\n                make.bottom.equalTo(0)\n                make.width.equalTo(1)\n            &#125;\n            roundView.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n        &#125;else if _position == .top&#123;\n            /// 如果在上面 空心圆\n            contentView.addSubview(toplineView)\n            toplineView.snp.makeConstraints&#123;make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(0)\n                make.bottom.equalTo(roundView.snp.top)\n                make.width.equalTo(1)\n            &#125;\n            if model is String &#123;\n                roundView.backgroundColor = .white\n            &#125;else&#123;\n                roundView.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n            &#125;\n        &#125;else&#123;\n            /// 都不在，也是都存在的意思\n            contentView.addSubview(toplineView)\n            contentView.addSubview(downlineView)\n            toplineView.snp.makeConstraints&#123;make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(0)\n                make.bottom.equalTo(roundView.snp.top)\n                make.width.equalTo(1)\n            &#125;\n            downlineView.snp.remakeConstraints&#123;make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(roundView.snp.bottom)\n                make.bottom.equalTo(0)\n                make.width.equalTo(1)\n            &#125;\n            roundView.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里定义了2个数据，1个是具体显示什么的数据，一个是线条怎么展示，什么时候展示实心和空心圆的逻辑。</p>\n<h3 id=\"4-3-生命周期函数\"><a href=\"#4-3-生命周期函数\" class=\"headerlink\" title=\"4.3 生命周期函数\"></a>4.3 生命周期函数</h3><p>首先看下初始化。</p>\n<pre><code class=\"line-numbers language-Swift\">override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) &#123;\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        \n        self.selectionStyle = .none\n        \n        /// 添加安徽省\n        contentView.addSubview(titleLb)\n        titleLb.snp.makeConstraints&#123;make in\n            make.centerY.equalToSuperview()\n            make.leading.equalTo(roundView.snp.trailing).offset(22)\n            make.trailing.equalTo(rightImgView.snp.leading).offset(10)\n            make.height.equalTo(20)\n        &#125;\n        \n        /// 添加圆形指示器\n        contentView.addSubview(roundView)\n        roundView.snp.makeConstraints&#123;make in\n            make.centerY.equalToSuperview()\n            make.leading.equalTo(14)\n            make.width.equalTo(7)\n            make.height.equalTo(7)\n        &#125;\n        \n        /// 添加右侧箭头\n        contentView.addSubview(rightImgView)\n        rightImgView.snp.makeConstraints&#123;make in\n            make.centerY.equalToSuperview()\n            make.trailing.equalTo(-16)\n            make.width.equalTo(19)\n            make.height.equalTo(19)\n        &#125;\n        \n    &#125;\n    \n    required init?(coder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n</code></pre>\n<p>这里就加了3个视图，并且布局了。</p>\n<h3 id=\"4-4-其它扩展方法\"><a href=\"#4-4-其它扩展方法\" class=\"headerlink\" title=\"4.4 其它扩展方法\"></a>4.4 其它扩展方法</h3><pre><code class=\"line-numbers language-Swift\">extension AddressCell&#123;\n    func updateUI(indexPath: IndexPath)&#123;\n        if indexPath.row == 1 &#123;\n            titleLb.text = &quot;请选择城市&quot;\n        &#125;else if indexPath.row == 2 &#123;\n            titleLb.text = &quot;请选择县&quot;\n        &#125;else if indexPath.row == 3&#123;\n            titleLb.text = &quot;请选街道&quot;\n        &#125;else&#123;\n            titleLb.text = &quot;&quot;//model as? String\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里就是显示item特殊情况的文案。</p>\n<h2 id=\"5-AddressSelectorCell-实现逻辑\"><a href=\"#5-AddressSelectorCell-实现逻辑\" class=\"headerlink\" title=\"5 AddressSelectorCell 实现逻辑\"></a>5 AddressSelectorCell 实现逻辑</h2><p>这里也同上面的Cell，有一个标识符。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 底部Cell\nclass AddressSelectorCell: UITableViewCell &#123;\n    \n    static var identifier: String = &quot;UITableViewCell&quot;\n</code></pre>\n<h3 id=\"5-1-子View\"><a href=\"#5-1-子View\" class=\"headerlink\" title=\"5.1 子View\"></a>5.1 子View</h3><p>这里需要哪些子View呢？</p>\n<pre><code class=\"line-numbers language-Swift\">//索引 eg: A字母\nlazy var indexLb: UILabel = &#123;\n    let label = UILabel()\n    label.font = .pingFangMedium(size: 12)\n    label.textColor = UIColor.init(hex: &quot;#9B9DA7&quot;)\n    return label\n&#125;()\n\n//名称 eg: 安徽省\nlazy var nameLb: UILabel = &#123;\n    let label = UILabel()\n    label.font = .pingFangMedium(size: 14)\n    label.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n    return label\n&#125;()\n\n//勾选图标\nlazy var checkImgView: UIImageView = &#123;\n    let imgView = UIImageView()\n    imgView.isHidden = true\n    imgView.image = UIImage.init(named: &quot;勾选&quot;)\n    return imgView\n&#125;()\n</code></pre>\n<p>这里非常简单，只有3个子视图，字母，中间名称，是否勾选。</p>\n<h3 id=\"5-2-生命周期函数\"><a href=\"#5-2-生命周期函数\" class=\"headerlink\" title=\"5.2 生命周期函数\"></a>5.2 生命周期函数</h3><p>看下初始化吧。</p>\n<pre><code class=\"line-numbers language-Swift\">override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) &#123;\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        self.selectionStyle = .none\n        \n        /// 添加索引，并且布局\n        contentView.addSubview(indexLb)\n        indexLb.snp.makeConstraints&#123;make in\n            make.leading.equalTo(8)\n            make.centerY.equalToSuperview()\n            make.width.equalTo(10)\n            make.height.equalTo(20)\n        &#125;\n        \n        /// 添加名称，并且位置确定\n        contentView.addSubview(nameLb)\n        nameLb.snp.makeConstraints&#123;make in\n            make.leading.equalTo(indexLb.snp.trailing).offset(16)\n            make.trailing.equalTo(-16)\n            make.centerY.equalToSuperview()\n            make.height.equalTo(20)\n        &#125;\n        \n        /// 确定勾选图标\n        contentView.addSubview(checkImgView)\n        checkImgView.snp.makeConstraints&#123;make in\n            make.trailing.equalTo(-16)\n            make.centerY.equalToSuperview()\n            make.width.equalTo(16)\n            make.height.equalTo(16)\n        &#125;\n    &#125;\n    \n    required init?(coder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n</code></pre>\n<p>也是非常简单，添加了3个子视图，并且确定位置了。</p>\n<h2 id=\"6-AddressModel-实现逻辑\"><a href=\"#6-AddressModel-实现逻辑\" class=\"headerlink\" title=\"6 AddressModel 实现逻辑\"></a>6 AddressModel 实现逻辑</h2><p>这个是四级地址的数据模型，可以看下：</p>\n<pre><code class=\"line-numbers language-Swift\">import Foundation\nimport HandyJSON\n\nclass AddressModel: HandyJSON &#123;\n    var data: [RegionModel] = []\n    required init() &#123;&#125;\n&#125;\n\nclass RegionModel: HandyJSON &#123;\n    var code: String = &quot;&quot;\n    var name: String = &quot;&quot;\n    var children: [RegionModel] = []\n    required init() &#123;&#125;\n&#125;\n</code></pre>\n<p>继承了HandyJSON，方便解析。<br>这里AddressModel实际上内部也是由 RegionModel数组构成的。<br>这个AddressModel用来存放省列表比较合适。</p>\n<p>RegionModel可以存放市，区，街道，都没问题。</p>\n<p>封装四级地址基本上就这些了。</p>\n<h2 id=\"7-外部调用方式\"><a href=\"#7-外部调用方式\" class=\"headerlink\" title=\"7 外部调用方式\"></a>7 外部调用方式</h2><h3 id=\"7-1-先声明一个四级地址View\"><a href=\"#7-1-先声明一个四级地址View\" class=\"headerlink\" title=\"7.1 先声明一个四级地址View\"></a>7.1 先声明一个四级地址View</h3><pre><code class=\"line-numbers language-Swift\">lazy private var addressView: AddressView = &#123;\n        let tmpview = AddressView(frame: CGRect.init(x: 0, y: 0, width: ScreenWidth, height: ScreenHeight))\n        return tmpview\n    &#125;()\n</code></pre>\n<p>这里设定了它的frame，也就是大小位置。</p>\n<h3 id=\"7-2-弹出四级地址\"><a href=\"#7-2-弹出四级地址\" class=\"headerlink\" title=\"7.2  弹出四级地址\"></a>7.2  弹出四级地址</h3><pre><code class=\"line-numbers language-Swift\">func showAddressSelector()&#123;\n        self.view.addSubview(self.addressView)\n        self.addressView.traverse(province: self.orderAddressModel?.province ?? &quot;&quot;, city: self.orderAddressModel?.city ?? &quot;&quot;, area: self.orderAddressModel?.region ?? &quot;&quot;, street: self.orderAddressModel?.street ?? &quot;&quot;)\n        addressView.selectAddressHandle = &#123;[weak self] (arr)in\n            guard let weakSelf = self else&#123;return&#125;\n            let pModel = arr[0]\n            let cModel = arr[1]\n            let aModel = arr[2]\n            let tModel = arr[3]\n            ...\n            \n        &#125;\n    &#125;\n</code></pre>\n<p>这里通过addSubview的方式，将这个四级地址添加到这个UIViewController的根布局上。类似叠加布局的方式。</p>\n<p>然后调用了一个关键的函数，traverse，将初始地址设置进去。</p>\n<p>然后设置了选择回调函数，这里用户选择了四级地址后，会回调到这个handle里面哦。</p>\n<h2 id=\"8-总结\"><a href=\"#8-总结\" class=\"headerlink\" title=\"8 总结\"></a>8 总结</h2><ul>\n<li><p>做一个复杂的自定义View，一定要化繁为简，将复杂的结构一步一步拆分成一个一个基本视图，这样能够很好规划实现方案。</p>\n</li>\n<li><p>任何一个自定义View实现方案可能会有多种，可以选择自己最熟悉的一种，然后进行研究，觉得不合适可以换其它方案来实现。</p>\n</li>\n<li><p>四级地址最关键的应该是数据了，这里我们实现方案是单页面，数据同步刷新的方式，其实也可以考虑多页面，可自由切换，毕竟地址层级不会太多。</p>\n</li>\n<li><p>需要考虑到用户之前填写的地址，可能只填了1到3级，所以一定要考虑全面一点，作为封装视图者，不能只考虑到最完美的情况。</p>\n</li>\n<li><p>多个UITableView是可以共用同一个代理和数据源的，只需要再代理里面区分下是那个UITableView即可。</p>\n</li>\n<li><p>UITableView有很多代理协议，这里可以设置多个组类，一个组多少行，头部View，尾部View，头部高度，尾部高度，点击item，等多种方法，可以实现很复杂的逻辑。</p>\n</li>\n<li><p>UITableView的Cell一定要分配一个标识符，用来复用，增加程序稳定性。</p>\n</li>\n</ul>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-需求分析\"><a href=\"#1-需求分析\" class=\"headerlink\" title=\"1 需求分析\"></a>1 需求分析</h2><p>目标是可以选择四级地址，什么是四级地址呢？省市区街道。类似淘宝买东西时，支付订单时需要填写收货地址，这里就需要构造一个四级地址弹框，让用户去选择。具体效果如下：<br><img src=%E5%9B%9B%E7%BA%A7%E5%9C%B0%E5%9D%80.gif></p>\n<p>这个我们可以单独将这个地址弹框单独封装一下，本身就是一个工具，很多地方可能会用的。<br>另外还需要提供传参，因为可能用户之前选择了某些地址，现在要更改，就需要跳转到已选择的四级地址，并且可以自己切换任何一个省市区，如果重新选择省，那么下级地址都需要清空；如果重新更新了市，那么下级清空，上级保留。<br>大概就是这样子。</p>\n<p>所以我们就可以将四级地址视图用一个UIView来实现。</p>\n<h2 id=\"2-控件结构\"><a href=\"#2-控件结构\" class=\"headerlink\" title=\"2 控件结构\"></a>2 控件结构</h2><p>首先我们分析下如何来完成这个需求，代码如何实现。<br>这里我们考虑将ui提供的四级地址，通过自定义View来实现。</p>\n<p>顶部有一个列表，就是记录用户已选地址，省市区街道。<br>底部也有一个列表，而且有分组，以地址的拼音首字母分组，组下也可能有会有不定行数的cell。</p>\n<p>这里我们就考虑 用两个UITableView来承载顶部和底部的列表。<br>两个UITableView都放在  AddressView 的自定义View里面吧。</p>\n<p>所以会多出两个Cell，一个是顶部Cell，就叫做AddressCell吧；一个是底部Cell，承载底部列表，就叫做AddressSelectorCell吧。</p>\n<p>另外还有数据层，就叫它 AddressModel吧，放地址数据的。</p>\n<p>所以我们只需要4个文件就可以完成这个需求了。</p>\n<ul>\n<li>AddressView 四级地址自定义View</li>\n<li>AddressCell 顶部Cell</li>\n<li>AddressSelectorCell 底部Cell</li>\n<li>AddressModel 数据层</li>\n</ul>\n<h2 id=\"3-AddressView-实现逻辑\"><a href=\"#3-AddressView-实现逻辑\" class=\"headerlink\" title=\"3 AddressView 实现逻辑\"></a>3 AddressView 实现逻辑</h2><h3 id=\"3-1-全局变量定义\"><a href=\"#3-1-全局变量定义\" class=\"headerlink\" title=\"3.1 全局变量定义\"></a>3.1 全局变量定义</h3><pre><code class=\"line-numbers language-Swift\">class AddressView: UIView &#123;\n    \n    typealias selectAddressBlock = (Array&lt;RegionModel&gt;)-&gt;()\n    var selectAddressHandle: selectAddressBlock?\n    var cancelAddressHandle: Handler?\n    \n    var modelArray: Array&lt;Any&gt; = []\n    var addressArray: Array&lt;(key: Swift.String, value: Array&lt;RegionModel&gt;)&gt; = []\n    var selectedIndex: Int = 0\n</code></pre>\n<p>这里定义一个闭包，就是用户勾选了4级地址后，需要将地址暴露个调用方，肯定需要一个方法发出去的。</p>\n<p>cancelAddressHandle是一个取消函数，主要处理用户点击蒙层或者点击取消的事件。</p>\n<p>modelArray是记录顶部列表数据的数组。</p>\n<p>addressArray是记录底部列表数据的数组。</p>\n<p>selectedIndex是记录顶部选择了第几项的全局变量记录。</p>\n<p>然后是2个懒加载的UITableView，看下哈：</p>\n<pre><code class=\"line-numbers language-Swift\">/// 顶部视图列表\nprivate lazy var tblView: UITableView = &#123;\n    let tableView = UITableView.init(frame: CGRect(x: 0, y: 196, width: ScreenWidth, height: ScreenHeight - 196), style: .grouped)\n    tableView.register(AddressCell.self, forCellReuseIdentifier: AddressCell.identifier)\n    tableView.delegate = self\n    tableView.dataSource = self\n    tableView.separatorStyle = .none\n    tableView.backgroundColor = .white\n    tableView.showsVerticalScrollIndicator = false\n    tableView.showsHorizontalScrollIndicator = false\n    tableView.isScrollEnabled = false\n    tableView.layer.cornerRadius = 14\n    tableView.layer.maskedCorners = [.layerMinXMinYCorner,.layerMaxXMinYCorner]\n    return tableView\n&#125;()\n</code></pre>\n<p>还有一个底部的列表：</p>\n<pre><code class=\"line-numbers language-Swift\">/// 底部视图列表\nprivate lazy var addressTblView: UITableView = &#123;\n    let tableView = UITableView.init(frame: CGRect.zero, style: .grouped)\n    tableView.register(AddressSelectorCell.self, forCellReuseIdentifier: AddressSelectorCell.identifier)\n    tableView.delegate = self\n    tableView.dataSource = self\n    tableView.backgroundColor = .white\n    tableView.separatorStyle = .none\n    tableView.showsVerticalScrollIndicator = false\n    tableView.showsHorizontalScrollIndicator = false\n    return tableView\n&#125;()\n</code></pre>\n<p>虽然是两个UITableView，但可以共享同一个代理和数据源，需要在里面另外加if else判断下。</p>\n<h3 id=\"3-2-生命周期函数\"><a href=\"#3-2-生命周期函数\" class=\"headerlink\" title=\"3.2 生命周期函数\"></a>3.2 生命周期函数</h3><p>这里只有一个初始化，但其实没有做什么，也没有把那两个UITableView加进去，这里应该就是空白的区域。</p>\n<pre><code class=\"line-numbers language-Swift\">  override init(frame: CGRect) &#123;\n        super.init(frame: frame)\n        self.backgroundColor = UIColor.init(red: 0, green: 0, blue: 0, alpha: 0.6)\n    &#125;\n    \n    required init?(coder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n</code></pre>\n<h3 id=\"3-3-初始化数据\"><a href=\"#3-3-初始化数据\" class=\"headerlink\" title=\"3.3 初始化数据\"></a>3.3 初始化数据</h3><p>这里是另外提供的函数，来初始化，所以需要调用方额外调用这个方法。<br>也正是这个方法，才会去加载ui的。</p>\n<pre><code class=\"line-numbers language-Swift\">func traverse(province: String, city: String, area: String, street: String)&#123;\n        modelArray.removeAll()\n        let dataArr: [RegionModel] = globalAddressModel?.data ?? AddressModel.init().data\n        self.recursive(dataArr: dataArr, province: province, city: city, area: area, street: street)\n        \n        if globalAddressModel != nil &#123;\n            if modelArray.count == 0 &#123;\n                /// 这里就展示省列表\n                self.setData(data: globalAddressModel!)\n            &#125;else if modelArray.count == 4&#123;\n                /// 这里展示街道列表\n                let model = modelArray[2]\n                self.setData(data: model)\n            &#125; else&#123;\n                /// 其它情况，就拿最后一个数据，在设置给底部内容tableView里面\n                let model = modelArray.last as! RegionModel\n                self.setData(data: model)\n            &#125;\n        &#125;\n        if modelArray.count &lt; 4 &#123;\n            modelArray.append(&quot;请选择&quot;)\n        &#125;\n        \n        /// 大概意思就是找到“请选择”在哪一个位置\n        selectedIndex = modelArray.firstIndex&#123;$0 is String&#125; ?? modelArray.count-1\n        /// 开始加载UI\n        self.loadUI()\n    &#125;\n</code></pre>\n<p>globalAddressModel 实际上再AppDelegate初始化的时候就去异步加载json文件了，这个应该就是保存的所有的四级地址信息了。</p>\n<p>然后这里用到了一个函数 recursive函数，是递归来寻找目标四级地址。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 递归获取目标地址\nfunc recursive(dataArr: [RegionModel], province: String, city: String, area: String, street: String)&#123;\n    for model in dataArr&#123;\n        if model.name.contains(province) ||\n            model.name.contains(city) ||\n            model.name.contains(area) ||\n            model.name.contains(street)&#123;\n            modelArray.append(model)\n            self.recursive(dataArr: model.children, province: province, city: city, area: area, street: street)\n            break\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>找到后，会将实体append到这个数组中。</p>\n<p>然后上面初始化数据还用到一个函数：setData，作用是设置底部数据，因为这里底部自始至终都是同一个UITableView，会经常需要刷新数据。这里就是刷新底部数据的意思吧。</p>\n<p>看下这个setData函数哈：</p>\n<pre><code class=\"line-numbers language-Swift\">func setData(data: Any)&#123;\n        var dataArr: [RegionModel] = []\n        if data is AddressModel &#123;\n            let tmpData = data as! AddressModel\n            dataArr = tmpData.data\n        &#125;else&#123;\n            let tmpData = data as! RegionModel\n            dataArr = tmpData.children\n        &#125;\n        /// 上面的代码目的是为了拿到 RegionModel数组\n        \n        if dataArr.count == 0 &#123;\n            return\n        &#125;\n        \n        var tmpDic: Dictionary&lt;String,Array&lt;RegionModel&gt;&gt; = Dictionary&lt;String,Array&lt;RegionModel&gt;&gt;()\n        for model in dataArr&#123;\n            var key: String = &quot;&quot;\n            key = self.findFirstLetterFromString(aString: model.name)\n            var arr = tmpDic[key] ?? Array&lt;RegionModel&gt;()\n            arr.append(model)\n            tmpDic[key] = arr\n        &#125;\n        \n        //处理了第二个字首字母排序\n        _ = tmpDic.keys.compactMap&#123; key in\n            var tmpArr = tmpDic[key]!\n            tmpArr = tmpArr.sorted&#123;(model1,model2) in\n                var key1 = &quot;&quot;\n                var key2 = &quot;&quot;\n                key1 = self.findFirstLetterFromString(aString: model1.name, isSecond: true)\n                key2 = self.findFirstLetterFromString(aString: model2.name, isSecond: true)\n                return key1 &lt; key2\n            &#125;\n            tmpDic[key] = tmpArr\n        &#125;\n        addressArray = tmpDic.sorted&#123;$0.key &lt; $1.key&#125;\n        \n        /// addressArray应该是拿到目前展示的内容区域数据 底部区域\n        self.addressTblView.reloadData()\n    &#125;\n</code></pre>\n<p>这里代码虽然长，但实际上具体还是挺简单的，主要是生成一个字典的映射关系，key存放首字母，value存放同一个首字母下对应的地址列表。大概意思就是这个tmpDic是一个key value形式的map集合，key是这些比如省份首字母为G，那么value就对应广东省，甘肃省，广西，贵州省等下的所有地址。这里就对应tableView里面的每一组的数据了。然后处理下第二个首字母排序的问题。</p>\n<p>好的，这里打住了，回到第一个函数 traverse方法中，里面根据modelArray的长度去决定刷新哪一个列表，因为调用方给的地址不一定是四级，可能是1级或2级或3级，这里也是需要考虑到的。能在哪个层级搜索到，就定位到哪个层级，那么最后一个层级这里使用 append一个“请选择”，这里说明如果是字符串了，那么这里就是最后一层级。感觉这还可以优化下，比较用字符串来判断到哪一层级不太合适的。</p>\n<p>traverse最后一个方法是加载UI。</p>\n<pre><code class=\"line-numbers language-Swift\">func loadUI()&#123;\n        /// 先加顶部\n        self.addSubview(tblView)\n        /// 顶部布局\n        self.updateUI()\n        \n        /// 再加底部\n        self.addSubview(addressTblView)\n        /// 底部布局\n        addressTblView.snp.remakeConstraints&#123;make in\n            make.leading.trailing.bottom.equalTo(0)\n            make.top.equalTo(tblView.snp.bottom).offset(0)\n        &#125;\n    &#125;\n\nfunc updateUI()&#123;\n        tblView.snp.remakeConstraints&#123;make in\n            make.leading.trailing.equalTo(0)\n            make.top.equalTo(196)\n            if modelArray.count == 1 &#123;\n                make.height.equalTo(96)\n            &#125;else&#123;\n                make.height.equalTo(96+modelArray.count*48)\n            &#125;\n        &#125;\n        self.tblView.reloadData()\n    &#125;\n</code></pre>\n<p>大概意思就是把那两个UITableView加给父View。</p>\n<p>然后需要用的扩展方法有下面这个：</p>\n<pre><code class=\"line-numbers language-Swift\">extension AddressView&#123;\n    \n    /// 找到中文对应的第一个字符对应的第一个字母拼音\n    func findFirstLetterFromString(aString: String, isSecond : Bool = false) -&gt; String &#123;\n        //转变成可变字符串\n        let mutableString = NSMutableString.init(string: aString)\n        \n        //将中文转换成带声调的拼音\n        CFStringTransform(mutableString as CFMutableString, nil,      kCFStringTransformToLatin, false)\n        \n        //去掉声调\n        let pinyinString = mutableString.folding(options:          String.CompareOptions.diacriticInsensitive, locale:   NSLocale.current)\n        \n        //将拼音首字母换成大写\n        let strPinYin = polyphoneStringHandle(nameString: aString,    pinyinString: pinyinString).uppercased()\n        \n        //截取大写首字母\n        let arr = strPinYin.components(separatedBy: &quot; &quot;)\n        let completeStr = isSecond == false ? arr[0] : arr[1]\n        let firstString = completeStr.subScript(index: 0, length: 1)\n        //判断首字母是否为大写\n        let regexA = &quot;^[A-Z]$&quot;\n        let predA = NSPredicate.init(format: &quot;SELF MATCHES %@&quot;, regexA)\n        return predA.evaluate(with: firstString) ? firstString : &quot;#&quot;\n    &#125;\n    \n    //多音字处理，根据需要添自行加\n    func polyphoneStringHandle(nameString: String, pinyinString: String) -&gt; String &#123;\n        //        if nameString.hasPrefix(&quot;长&quot;) &#123;return &quot;chang&quot;&#125;\n        //        if nameString.hasPrefix(&quot;沈&quot;) &#123;return &quot;shen&quot;&#125;\n        //        if nameString.hasPrefix(&quot;厦&quot;) &#123;return &quot;xia&quot;&#125;\n        //        if nameString.hasPrefix(&quot;地&quot;) &#123;return &quot;di&quot;&#125;\n        //        if nameString.hasPrefix(&quot;重&quot;) &#123;return &quot;chong&quot;&#125;\n        return pinyinString\n    &#125;\n&#125;\n</code></pre>\n<p>这里主要是一个工具方法，内部使用，无需多讲。</p>\n<p>好了，前面的ui基本就这些。<br>下面主要是讲解下UITableView的代理方法和数据源配置。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 设置顶部tableView 代理和数据\nextension AddressView: UITableViewDelegate,UITableViewDataSource&#123;\n    func numberOfSections(in tableView: UITableView) -&gt; Int &#123;\n        if tableView == tblView &#123;\n            return 1    /// 顶部tableView只有一组\n        &#125;else&#123;\n            return addressArray.count   /// 很多组 26个字母都有的话，就26组\n        &#125;\n    &#125;\n</code></pre>\n<p>这里扩展AddressView，去实现UITableViewDelegate和UITableViewDataSource协议。<br>这是第一个方法，numberOfSections，返回有多少组。这里因为顶部只有一种类型，也就只有一组，底部用了一个数组记录，组数就是数组的长度。</p>\n<pre><code class=\"line-numbers language-Swift\">func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n        if tableView == tblView &#123;\n            /// 顶部，如果没有 历史地址，则为0，有则显示 一组多少个\n            if modelArray.count == 1 &amp;&amp; (modelArray.last is String) &#123;\n                return 0\n            &#125;else&#123;\n                return modelArray.count\n            &#125;\n        &#125;else&#123;\n            /// 取当前组里面多少个\n            let dic = addressArray[section]\n            let arr = dic.value\n            return arr.count\n        &#125;\n    &#125;\n</code></pre>\n<p>这是第二个方法，numberOfRowsInSection，意思就是这个组下有多少行。</p>\n<pre><code class=\"line-numbers language-Swift\"> func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n        /// 上面下面都是48\n        if tableView == tblView &#123;\n            return 48\n        &#125;else&#123;\n            return 48\n        &#125;\n    &#125;\n</code></pre>\n<p>这里是每行的高度。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 每个cell怎么显示\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n    /// 如果是顶部\n    if tblView == tableView &#123;\n        /// 顶部用AddressCell\n        let cell = tableView.dequeueReusableCell(withIdentifier: AddressCell.identifier, for: indexPath) as! AddressCell\n        let model = modelArray[indexPath.row]\n        /// 数据用modelArray里面的数据\n        cell.model = model\n        /// 选中的话，高亮显示文字颜色\n        if selectedIndex == indexPath.row &#123;\n            cell.titleLb.textColor = UIColor.init(hex: &quot;#409EFF&quot;)\n        &#125;else&#123;\n            cell.titleLb.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n        &#125;\n        /// 这里是请选择什么\n        if model is String &#123;\n            cell.updateUI(indexPath: indexPath)\n        &#125;\n        \n        /// 指示剂方向\n        if indexPath.row == 0 &#123;\n            cell.position = .down // 第0行，只有下面的\n        &#125;else if indexPath.row == modelArray.count-1&#123;\n            cell.position = .top /// 最后一行，只有上面\n        &#125;else&#123;\n            cell.position = .middle /// 其它都有\n        &#125;\n        \n        return cell\n    &#125;else&#123;\n        /// 如果是底部，数据取addressArray里面的\n        let dic = addressArray[indexPath.section]\n        let arr = dic.value\n        let model = arr[indexPath.row] // 这个字母类别里面的 第row行\n        \n        /// 这个cell用 AddressSelector来实现\n        let cell = tableView.dequeueReusableCell(withIdentifier: AddressSelectorCell.identifier, for: indexPath) as! AddressSelectorCell\n        \n        /// 第1行才有字母\n        if indexPath.row == 0 &#123;\n            cell.indexLb.text = dic.key\n        &#125;else&#123;\n            cell.indexLb.text = &quot;&quot;\n        &#125;\n        \n        /// 当前在那个层级 比如是广东省\n        let obj = modelArray[selectedIndex]\n        if obj is String &#123; /// 请选择层级\n            cell.checkImgView.isHidden = true\n            cell.nameLb.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n        &#125;else&#123;\n            /// 已选层级\n            let selectedModel = obj as! RegionModel\n            if selectedModel.name == model.name &#123; /// 列表中的就是已选的，高亮一下\n                cell.nameLb.textColor = UIColor.init(hex: &quot;#409EFF&quot;)\n                cell.checkImgView.isHidden = false\n            &#125;else&#123;\n                cell.nameLb.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n                cell.checkImgView.isHidden = true\n            &#125;\n        &#125;\n        \n        ///  显示目标地址名称\n        cell.nameLb.text = model.name\n        return cell\n    &#125;\n&#125;\n</code></pre>\n<p>这个方法就比较关键了，就是每行怎么展现的。<br>用哪个Cell，是否要高亮，指示剂怎么展示，这里有点像Android的adpter里面的bindAdapter实现逻辑。这里需要按照需求在item里面自行处理逻辑。</p>\n<p>如果是底部，就需要考虑是否显示字母，是否高亮这些了。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 标题和单元格间隔\nfunc tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat &#123;\n    /// 顶部头部预留48dp显示标题“请选择所在地区”\n    if tableView == tblView &#123;\n        return 48\n    &#125;else&#123;\n        return 0.01\n    &#125;\n&#125;\n</code></pre>\n<p>顶部预留高度，用来展示自己的标题。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 和上面对应，预留48个dp怎么显示\nfunc tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -&gt; UIView? &#123;\n    if tableView == tblView &#123;\n        let view = UIView.init(frame: CGRect.init(x: 0, y: 0, width: ScreenWidth, height: 48))\n        let label = UILabel.init()\n        label.font = .pingFangSemibold(size: 18)\n        label.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n        label.text = &quot;请选择所在地区&quot;\n        \n        let closeBtn: UIButton = &#123;\n            let btn = UIButton()\n            btn.setTitle(&quot;取消&quot;, for: .normal)\n            btn.setTitleColor(UIColor.init(hex: &quot;#409EFF&quot;), for: .normal)\n            btn.titleLabel?.font = .pingFangRegular(size: 16)\n            btn.addTarget(self, action: #selector(actionForClose), for: .touchUpInside)\n            return btn\n        &#125;()\n        \n        view.addSubview(label)\n        view.addSubview(closeBtn)\n        label.snp.makeConstraints&#123;make in\n            make.centerY.equalTo(view)\n            make.centerX.equalTo(view)\n            make.width.equalTo(130)\n            make.height.equalTo(30)\n        &#125;\n        closeBtn.snp.makeConstraints&#123;make in\n            make.trailing.equalTo(-16)\n            make.centerY.equalTo(view)\n            make.width.equalTo(48)\n            make.height.equalTo(48)\n        &#125;\n        return view\n    &#125;else&#123;\n        return UIView()\n    &#125;\n&#125;\n</code></pre>\n<p>标题和取消按钮显示逻辑。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 单元格尾巴怎么显示\nfunc tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -&gt; CGFloat &#123;\n    /// 如果是顶部tableView，预留48个dp\n    if tableView == tblView &#123;\n        return 48\n    &#125;else&#123;\n        return 0.01\n    &#125;\n&#125;\n</code></pre>\n<p>这里顶部有效，有48个单位长度，用来显示底部标题。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 尾部显示 选择下级地址\nfunc tableView(_ tableView: UITableView, viewForFooterInSection section: Int) -&gt; UIView? &#123;\n    if tableView == tblView &#123;\n        let view = UIView.init(frame: CGRect.init(x: 0, y: 0, width: ScreenWidth, height: 48))\n        \n        let lineView = UIView()\n        lineView.backgroundColor = UIColor.init(hex: &quot;#F6F6F6&quot;)\n        let label = UILabel.init()\n        label.font = .pingFangSemibold(size: 16)\n        label.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n        \n        if selectedIndex == 0 &#123;\n            label.text = &quot;选择省份/地区&quot;\n        &#125;else if selectedIndex == 1&#123;\n            label.text = &quot;选择城市&quot;\n        &#125;else if selectedIndex == 2&#123;\n            label.text = &quot;选择区/县&quot;\n        &#125;else&#123;\n            label.text = &quot;选择街道/镇&quot;\n        &#125;\n        \n        view.addSubview(lineView)\n        view.addSubview(label)\n        \n        lineView.snp.makeConstraints&#123;make in\n            make.top.equalTo(4)\n            make.leading.trailing.equalTo(0)\n            make.height.equalTo(0.5)\n        &#125;\n        label.snp.makeConstraints&#123;make in\n            make.top.equalTo(16)\n            make.leading.equalTo(8)\n            make.width.equalTo(150)\n            make.height.equalTo(30)\n        &#125;\n        return view\n    &#125;else&#123;\n        return UIView()\n    &#125;\n&#125;\n</code></pre>\n<p>这里就是确定底部标题的怎么显示的。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 点击了单元格\nfunc tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123;\n    if tblView == tableView &#123;\n        /// 顶部点击了哪个单元格\n        if indexPath.row == 0 &#123;\n            self.setData(data: globalAddressModel!)\n        &#125;else&#123;\n            let model = modelArray[indexPath.row-1]\n            self.setData(data: model)\n        &#125;\n        selectedIndex = indexPath.row\n        /// 改变全局变量 selectedIndex，再去加载\n        self.tblView.reloadData()\n    &#125;else&#123;\n        /// 当前是哪一组\n        let dic = addressArray[indexPath.section]\n        let arr = dic.value\n        /// 当前是哪一行\n        let model = arr[indexPath.row]\n        \n        /// 请选择是第几个\n        let index = modelArray.firstIndex&#123;$0 is String&#125; ?? 0\n        /// 顶部是请选择\n        if modelArray[selectedIndex] is String &amp;&amp; modelArray.count &lt; 5&#123;\n            /// 插入目标点击的地址 给modelArray\n            modelArray.insert(model, at: index)\n            if modelArray.count == 5 &#123;\n                modelArray.removeLast()\n            &#125;\n        &#125;else&#123;\n            /// 顶部不是请选择,而已已选择的地址\n            modelArray[selectedIndex] = model\n            /// 下面有请选择，需要清空之前选择的值\n            let isContain = modelArray.contains(where: &#123;$0 is String&#125;)\n            if isContain &#123;\n                for i in (selectedIndex+1 ... modelArray.count-1).reversed()&#123;\n                    if modelArray[i] is String &#123;\n                        continue\n                    &#125;\n                    modelArray.remove(at: i)\n                &#125;\n            &#125; else if !isContain &amp;&amp; selectedIndex != 3&#123;\n                for i in (selectedIndex+1 ... modelArray.count-1).reversed()&#123;\n                    modelArray.remove(at: i)\n                &#125;\n            &#125;\n            \n            if modelArray.count &lt; 4 &amp;&amp; !modelArray.contains(where: &#123;$0 is String&#125;)&#123;\n                modelArray.append(&quot;请选择&quot;)\n            &#125;\n        &#125;\n        \n        /// 没有请选择了，会直接关闭弹框，执行回调\n        if modelArray.count == 4 &amp;&amp; !modelArray.contains(where: &#123;$0 is String&#125;)&#123;\n            var arr: [RegionModel] = []\n            for model in modelArray &#123;\n                let obj = model as! RegionModel\n                arr.append(obj)\n            &#125;\n            selectAddressHandle?(arr)\n            self.removeFromSuperview()\n        &#125;else&#123;\n            /// 更新底部数据，以及顶部选择index\n            self.setData(data: model)\n            self.updateUI()\n            selectedIndex += 1\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>上面的代码逻辑，主要就是处理点击顶部单元格，和底部单元格的逻辑。<br>顶部点击会调用setData,会同步刷新底部。</p>\n<p>底部点击也会setData,刷新底部数据，如果全部选择，则会走闭包回调，将用户选择的四级地址回调出去。</p>\n<p>然后还有一些其它扩展方法，简单看下哈。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 扩展给外部\nextension AddressView&#123;\n    /// 通知调用者当有一个或者多个手指触摸到了视图或者窗口时触发此方法。\n    /// touches是UITouch的集合，通过UITouch我们可以检测触摸事件的属性，是单拍还是双拍，还有触摸的位置等。\n    /// 这里应该是触摸到蒙层后关闭弹框\n    override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123;\n        guard let point = touches.first?.location(in: self) else &#123; return &#125;\n        let p = self.layer.convert(point, from: self.layer)\n        if self.layer.contains(p) &#123;\n            self.actionForClose()\n        &#125;\n    &#125;\n    \n    /// 移除自己，类似关闭弹框效果\n    @objc func actionForClose()&#123;\n        cancelAddressHandle?()\n        self.removeFromSuperview()\n    &#125;\n&#125;\n</code></pre>\n<p>这里actionForClose是UiButton设置的一个action，上面哪个是覆写的官方方法，应该是触摸到蒙层自动关闭弹框。</p>\n<h2 id=\"4-AddressCell-实现逻辑\"><a href=\"#4-AddressCell-实现逻辑\" class=\"headerlink\" title=\"4 AddressCell 实现逻辑\"></a>4 AddressCell 实现逻辑</h2><p>这个可以理解成Android中的Adapter了。也就是item怎么显示。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 顶部cell\nclass AddressCell: UITableViewCell &#123;\n    \n    enum LinePosition &#123;\n        case down\n        case middle\n        case top\n    &#125;\n    \n    static var identifier: String = &quot;AddressCell&quot;\n</code></pre>\n<p>这里需要继承UITableViewCell，必须要有一个identifier，这个主要是为了复用，因为列表可能会很长，为了合理复用，这里一般都需要一个标识符。</p>\n<h3 id=\"4-1-子View定义\"><a href=\"#4-1-子View定义\" class=\"headerlink\" title=\"4.1 子View定义\"></a>4.1 子View定义</h3><pre><code class=\"line-numbers language-Swift\"> /// 安徽省\nlazy var titleLb: UILabel = &#123;\n    let label = UILabel()\n    label.font = .pingFangMedium(size: 16)\n    label.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n    return label\n&#125;()\n\n/// 实心圆\nlazy var roundView: UIView = &#123;\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n    view.layer.cornerRadius = 3.5\n    view.layer.borderWidth = 1\n    view.layer.borderColor = UIColor.init(hex: &quot;#409EFF&quot;).cgColor\n    return view\n&#125;()\n\n/// 圆上面的线条\nlazy private var toplineView: UIView = &#123;\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n    return view\n&#125;()\n\n/// 圆下面的线条\nlazy private var downlineView: UIView = &#123;\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n    return view\n&#125;()\n\n/// 右侧箭头\nlazy private var rightImgView: UIImageView = &#123;\n    let imgView = UIImageView()\n    imgView.image = UIImage.init(named: &quot;客户信息_右箭头&quot;)\n    return imgView\n&#125;()\n</code></pre>\n<p>这里是顶部item用的一些零部件。<br>比如上下线图，右侧箭头，中间文字。实心圆。<br>这里变空心，实际上只是设置了中间颜色为纯白。</p>\n<h3 id=\"4-2-数据定义\"><a href=\"#4-2-数据定义\" class=\"headerlink\" title=\"4.2 数据定义\"></a>4.2 数据定义</h3><pre><code class=\"line-numbers language-Swift\">/// 监听数据变化 数据填充\nvar model: Any?&#123;\n    didSet&#123;\n        guard let _model = model else&#123;return&#125;\n        if _model is RegionModel &#123;\n            let tmp = _model as! RegionModel\n            titleLb.text = tmp.name\n        &#125;\n    &#125;\n&#125;\n    \n/// 线条位置\nvar position: LinePosition?&#123;\n    didSet&#123;\n        guard let _position = position else&#123;return&#125;\n        /// 上面和下面的线条都先一出去\n        toplineView.removeFromSuperview()\n        downlineView.removeFromSuperview()\n        \n        /// 如果在下面 空心圆\n        if _position == .down &#123;\n            contentView.addSubview(downlineView)\n            downlineView.snp.makeConstraints&#123;make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(roundView.snp.top).offset(0)\n                make.bottom.equalTo(0)\n                make.width.equalTo(1)\n            &#125;\n            roundView.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n        &#125;else if _position == .top&#123;\n            /// 如果在上面 空心圆\n            contentView.addSubview(toplineView)\n            toplineView.snp.makeConstraints&#123;make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(0)\n                make.bottom.equalTo(roundView.snp.top)\n                make.width.equalTo(1)\n            &#125;\n            if model is String &#123;\n                roundView.backgroundColor = .white\n            &#125;else&#123;\n                roundView.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n            &#125;\n        &#125;else&#123;\n            /// 都不在，也是都存在的意思\n            contentView.addSubview(toplineView)\n            contentView.addSubview(downlineView)\n            toplineView.snp.makeConstraints&#123;make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(0)\n                make.bottom.equalTo(roundView.snp.top)\n                make.width.equalTo(1)\n            &#125;\n            downlineView.snp.remakeConstraints&#123;make in\n                make.centerX.equalTo(roundView)\n                make.top.equalTo(roundView.snp.bottom)\n                make.bottom.equalTo(0)\n                make.width.equalTo(1)\n            &#125;\n            roundView.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里定义了2个数据，1个是具体显示什么的数据，一个是线条怎么展示，什么时候展示实心和空心圆的逻辑。</p>\n<h3 id=\"4-3-生命周期函数\"><a href=\"#4-3-生命周期函数\" class=\"headerlink\" title=\"4.3 生命周期函数\"></a>4.3 生命周期函数</h3><p>首先看下初始化。</p>\n<pre><code class=\"line-numbers language-Swift\">override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) &#123;\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        \n        self.selectionStyle = .none\n        \n        /// 添加安徽省\n        contentView.addSubview(titleLb)\n        titleLb.snp.makeConstraints&#123;make in\n            make.centerY.equalToSuperview()\n            make.leading.equalTo(roundView.snp.trailing).offset(22)\n            make.trailing.equalTo(rightImgView.snp.leading).offset(10)\n            make.height.equalTo(20)\n        &#125;\n        \n        /// 添加圆形指示器\n        contentView.addSubview(roundView)\n        roundView.snp.makeConstraints&#123;make in\n            make.centerY.equalToSuperview()\n            make.leading.equalTo(14)\n            make.width.equalTo(7)\n            make.height.equalTo(7)\n        &#125;\n        \n        /// 添加右侧箭头\n        contentView.addSubview(rightImgView)\n        rightImgView.snp.makeConstraints&#123;make in\n            make.centerY.equalToSuperview()\n            make.trailing.equalTo(-16)\n            make.width.equalTo(19)\n            make.height.equalTo(19)\n        &#125;\n        \n    &#125;\n    \n    required init?(coder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n</code></pre>\n<p>这里就加了3个视图，并且布局了。</p>\n<h3 id=\"4-4-其它扩展方法\"><a href=\"#4-4-其它扩展方法\" class=\"headerlink\" title=\"4.4 其它扩展方法\"></a>4.4 其它扩展方法</h3><pre><code class=\"line-numbers language-Swift\">extension AddressCell&#123;\n    func updateUI(indexPath: IndexPath)&#123;\n        if indexPath.row == 1 &#123;\n            titleLb.text = &quot;请选择城市&quot;\n        &#125;else if indexPath.row == 2 &#123;\n            titleLb.text = &quot;请选择县&quot;\n        &#125;else if indexPath.row == 3&#123;\n            titleLb.text = &quot;请选街道&quot;\n        &#125;else&#123;\n            titleLb.text = &quot;&quot;//model as? String\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里就是显示item特殊情况的文案。</p>\n<h2 id=\"5-AddressSelectorCell-实现逻辑\"><a href=\"#5-AddressSelectorCell-实现逻辑\" class=\"headerlink\" title=\"5 AddressSelectorCell 实现逻辑\"></a>5 AddressSelectorCell 实现逻辑</h2><p>这里也同上面的Cell，有一个标识符。</p>\n<pre><code class=\"line-numbers language-Swift\">/// 底部Cell\nclass AddressSelectorCell: UITableViewCell &#123;\n    \n    static var identifier: String = &quot;UITableViewCell&quot;\n</code></pre>\n<h3 id=\"5-1-子View\"><a href=\"#5-1-子View\" class=\"headerlink\" title=\"5.1 子View\"></a>5.1 子View</h3><p>这里需要哪些子View呢？</p>\n<pre><code class=\"line-numbers language-Swift\">//索引 eg: A字母\nlazy var indexLb: UILabel = &#123;\n    let label = UILabel()\n    label.font = .pingFangMedium(size: 12)\n    label.textColor = UIColor.init(hex: &quot;#9B9DA7&quot;)\n    return label\n&#125;()\n\n//名称 eg: 安徽省\nlazy var nameLb: UILabel = &#123;\n    let label = UILabel()\n    label.font = .pingFangMedium(size: 14)\n    label.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n    return label\n&#125;()\n\n//勾选图标\nlazy var checkImgView: UIImageView = &#123;\n    let imgView = UIImageView()\n    imgView.isHidden = true\n    imgView.image = UIImage.init(named: &quot;勾选&quot;)\n    return imgView\n&#125;()\n</code></pre>\n<p>这里非常简单，只有3个子视图，字母，中间名称，是否勾选。</p>\n<h3 id=\"5-2-生命周期函数\"><a href=\"#5-2-生命周期函数\" class=\"headerlink\" title=\"5.2 生命周期函数\"></a>5.2 生命周期函数</h3><p>看下初始化吧。</p>\n<pre><code class=\"line-numbers language-Swift\">override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) &#123;\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        self.selectionStyle = .none\n        \n        /// 添加索引，并且布局\n        contentView.addSubview(indexLb)\n        indexLb.snp.makeConstraints&#123;make in\n            make.leading.equalTo(8)\n            make.centerY.equalToSuperview()\n            make.width.equalTo(10)\n            make.height.equalTo(20)\n        &#125;\n        \n        /// 添加名称，并且位置确定\n        contentView.addSubview(nameLb)\n        nameLb.snp.makeConstraints&#123;make in\n            make.leading.equalTo(indexLb.snp.trailing).offset(16)\n            make.trailing.equalTo(-16)\n            make.centerY.equalToSuperview()\n            make.height.equalTo(20)\n        &#125;\n        \n        /// 确定勾选图标\n        contentView.addSubview(checkImgView)\n        checkImgView.snp.makeConstraints&#123;make in\n            make.trailing.equalTo(-16)\n            make.centerY.equalToSuperview()\n            make.width.equalTo(16)\n            make.height.equalTo(16)\n        &#125;\n    &#125;\n    \n    required init?(coder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n</code></pre>\n<p>也是非常简单，添加了3个子视图，并且确定位置了。</p>\n<h2 id=\"6-AddressModel-实现逻辑\"><a href=\"#6-AddressModel-实现逻辑\" class=\"headerlink\" title=\"6 AddressModel 实现逻辑\"></a>6 AddressModel 实现逻辑</h2><p>这个是四级地址的数据模型，可以看下：</p>\n<pre><code class=\"line-numbers language-Swift\">import Foundation\nimport HandyJSON\n\nclass AddressModel: HandyJSON &#123;\n    var data: [RegionModel] = []\n    required init() &#123;&#125;\n&#125;\n\nclass RegionModel: HandyJSON &#123;\n    var code: String = &quot;&quot;\n    var name: String = &quot;&quot;\n    var children: [RegionModel] = []\n    required init() &#123;&#125;\n&#125;\n</code></pre>\n<p>继承了HandyJSON，方便解析。<br>这里AddressModel实际上内部也是由 RegionModel数组构成的。<br>这个AddressModel用来存放省列表比较合适。</p>\n<p>RegionModel可以存放市，区，街道，都没问题。</p>\n<p>封装四级地址基本上就这些了。</p>\n<h2 id=\"7-外部调用方式\"><a href=\"#7-外部调用方式\" class=\"headerlink\" title=\"7 外部调用方式\"></a>7 外部调用方式</h2><h3 id=\"7-1-先声明一个四级地址View\"><a href=\"#7-1-先声明一个四级地址View\" class=\"headerlink\" title=\"7.1 先声明一个四级地址View\"></a>7.1 先声明一个四级地址View</h3><pre><code class=\"line-numbers language-Swift\">lazy private var addressView: AddressView = &#123;\n        let tmpview = AddressView(frame: CGRect.init(x: 0, y: 0, width: ScreenWidth, height: ScreenHeight))\n        return tmpview\n    &#125;()\n</code></pre>\n<p>这里设定了它的frame，也就是大小位置。</p>\n<h3 id=\"7-2-弹出四级地址\"><a href=\"#7-2-弹出四级地址\" class=\"headerlink\" title=\"7.2  弹出四级地址\"></a>7.2  弹出四级地址</h3><pre><code class=\"line-numbers language-Swift\">func showAddressSelector()&#123;\n        self.view.addSubview(self.addressView)\n        self.addressView.traverse(province: self.orderAddressModel?.province ?? &quot;&quot;, city: self.orderAddressModel?.city ?? &quot;&quot;, area: self.orderAddressModel?.region ?? &quot;&quot;, street: self.orderAddressModel?.street ?? &quot;&quot;)\n        addressView.selectAddressHandle = &#123;[weak self] (arr)in\n            guard let weakSelf = self else&#123;return&#125;\n            let pModel = arr[0]\n            let cModel = arr[1]\n            let aModel = arr[2]\n            let tModel = arr[3]\n            ...\n            \n        &#125;\n    &#125;\n</code></pre>\n<p>这里通过addSubview的方式，将这个四级地址添加到这个UIViewController的根布局上。类似叠加布局的方式。</p>\n<p>然后调用了一个关键的函数，traverse，将初始地址设置进去。</p>\n<p>然后设置了选择回调函数，这里用户选择了四级地址后，会回调到这个handle里面哦。</p>\n<h2 id=\"8-总结\"><a href=\"#8-总结\" class=\"headerlink\" title=\"8 总结\"></a>8 总结</h2><ul>\n<li><p>做一个复杂的自定义View，一定要化繁为简，将复杂的结构一步一步拆分成一个一个基本视图，这样能够很好规划实现方案。</p>\n</li>\n<li><p>任何一个自定义View实现方案可能会有多种，可以选择自己最熟悉的一种，然后进行研究，觉得不合适可以换其它方案来实现。</p>\n</li>\n<li><p>四级地址最关键的应该是数据了，这里我们实现方案是单页面，数据同步刷新的方式，其实也可以考虑多页面，可自由切换，毕竟地址层级不会太多。</p>\n</li>\n<li><p>需要考虑到用户之前填写的地址，可能只填了1到3级，所以一定要考虑全面一点，作为封装视图者，不能只考虑到最完美的情况。</p>\n</li>\n<li><p>多个UITableView是可以共用同一个代理和数据源的，只需要再代理里面区分下是那个UITableView即可。</p>\n</li>\n<li><p>UITableView有很多代理协议，这里可以设置多个组类，一个组多少行，头部View，尾部View，头部高度，尾部高度，点击item，等多种方法，可以实现很复杂的逻辑。</p>\n</li>\n<li><p>UITableView的Cell一定要分配一个标识符，用来复用，增加程序稳定性。</p>\n</li>\n</ul>\n"},{"title":"iOS swift 自定义View之步进器","date":"2023-01-26T02:54:54.000Z","top":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 需求分析\n 需要实现一个步进器效果，比如我们在购买商品时，需要添加这个商品，可以点击+或者-，也可以手动输入购买数量。\n 效果如下：\n \n <img src=\"stepper0.png\">\n <img src=\"stepper5.png\">\n\n 基本交互很简单，有最小值和最大值，点击减号就将数量减1，点击加号就将数量加1，如果是最大值或者最小值，就将图标置灰不可点击。\n\n## 2 代码实现\n\n### 2.1 类外声明\n\n```Swift\n/// 定义一个闭包，主要是需要暴露里面的数字给外面，可以理解成定义一个接口类型\npublic typealias ResultClosure = (_ number: String)->()\n```\n\n这个主要是给调用步进器的地方使用，当用户行为导致数量变更，肯定要通知外部处理自己逻辑，这是封装自定义View的基本常识，一定要给外部一定的可操作空间。\n\n### 2.2 创建步进器类\n```Swift\n/// 这里是自定义步进器了  @IBDesignable关键字用来声明一个类是可以被设计的，可以实时渲染在interface builder 上\n/// @IBInspectable关键字用来声明一个属性，可以在interface builder上修改该属性，就可以实时渲染border的变化\n/// open 修饰的 class 在 Module 内部和外部都可以被访问和继承\n@IBDesignable open class PPNumberButton: UIView {\n```\n这里继承了UIView，这个注解只是用来实时预览，这里不要也行。如果想了解自定义View实时预览功能，可以参考下这篇文档：[https://blog.wangruofeng007.com/posts/56184/]()\n\n### 2.3 定义类属性\n```Swift\n    /// 0为默认，1为零售开单\n    var documentType:Int = 0\n    \n    /// 结果闭包，用自定义的闭包类型\n    var NumberResultClosure: ResultClosure?\n    \n    var decreaseBtn: UIButton!     // 减按钮\n    var increaseBtn: UIButton!     // 加按钮\n    var textField: UITextField!    // 数量展示/输入框\n    var timer: Timer!              // 快速加减定时器\n    public var _minValue = 1                 // 最小值\n    public var _maxValue = Int.max           // 最大值\n    public var shakeAnimation: Bool = false  // 是否打开抖动动画\n    \n    var decreaseBgBtn:UIButton!  //减按钮(增大可触面积)\n    var increaseBgBtn:UIButton!  //加按钮(增大可触面积)\n    \n    /// rxSwift生命的袋子\n    let bag = DisposeBag()\n```\n\n这里documentType是自己的业务逻辑，忽略。结果闭包2.1声明的那个类型。然后就是几个基本视图了。这里还有个timer，主要用途是长按实现持续增加数字的功能，体验会好一点。\n最大值最小值就是步进器的最大值和最小值。\n抖动动画，是如果已经到最大值了，用户还在按加，就弹一个动画效果。\n然后还有两个UIButton覆盖在增加和减号的图标上面，只是为了扩大点击热区。\n\n### 2.4 生命周期函数\n\n```Swift\n/// UIView的初始化函数，这里一般会覆写这个方法\noverride public init(frame: CGRect) {\n    super.init(frame: frame)\n    \n    setupUI()\n    \n    //整个控件的默认尺寸\n    if frame.isEmpty {\n        self.frame = CGRect(x: 0, y: 0, width: 110, height: 30)\n    }\n    \n}\n\nrequired public init?(coder aDecoder: NSCoder) {\n    super.init(coder: aDecoder)\n\n}\n```\n一般情况，自定义View都需要覆写下这两个init函数。用来初始化UI。\n\n```Swift\n//设置UI布局\nfileprivate func setupUI() {\n    /// 背景颜色清空\n    backgroundColor = UIColor.clear\n\n    /// 加图标和热区加按钮\n    decreaseBtn = setupButton(title: \"reduce_available\")\n    decreaseBgBtn = setupButton(title: \" \")\n    increaseBtn = setupButton(title: \"increase_available\")\n    increaseBgBtn = setupButton(title: \" \")\n    \n    decreaseBtn.backgroundColor = .clear\n    increaseBtn.backgroundColor = .clear\n    //减按钮(增大可触面积)\n    decreaseBgBtn.backgroundColor = .clear\n    //加按钮(增大可触面积)\n    increaseBgBtn.backgroundColor = .clear\n    \n    /// 中间区域的编辑框\n    textField = UITextField.init()\n    textField.font = UIFont.pingFangMedium(size: 16)\n    textField.layer.borderColor = UIColor(red: 0.79, green: 0.80, blue: 0.83, alpha: 1.00).cgColor\n    textField.layer.borderWidth = 1\n    textField.backgroundColor = UIColor(red: 0.97, green: 0.97, blue: 0.99, alpha: 1.00)\n    textField.layer.cornerRadius = 8\n    textField.textColor = UIColor(hex:\"#3B4058\")\n    textField.delegate = self\n    textField.adjustsFontSizeToFitWidth = true        //当文字超出文本框宽度时，自动调整文字大小\n    textField.minimumFontSize = 14                   //最小可缩小的字号\n    textField.keyboardType = UIKeyboardType.numberPad\n    textField.textAlignment = NSTextAlignment.center\n    self.addSubview(textField)\n}\n```\n\n内部用了一个setupButton给按钮增加背景，看下哈：\n```Swift\n//设置加减按钮的公共方法 设置action\nfileprivate func setupButton(title:String) -> UIButton {\n    let button = UIButton.init();\n    button.setBackgroundImage(UIImage.init(named: title), for: .normal)\n    button.setTitleColor(UIColor.gray, for: .normal)\n    button.addTarget(self, action:#selector(self.touchDown(_:)) , for: .touchDown)\n    button.addTarget(self, action:#selector(self.touchUp) , for:.touchUpOutside)\n    button.addTarget(self, action:#selector(self.touchUp) , for:.touchUpInside)\n    button.addTarget(self, action:#selector(self.touchUp) , for:.touchCancel)\n    self.addSubview(button)\n    \n    return button;\n}\n```\n\n这里给按钮增加了一个action，主要是处理用户行为点击加号或者减号的逻辑：\n```Swift\n@objc fileprivate func touchDown(_ button: UIButton) {\n        textField.endEditing(false)\n        if button == decreaseBtn || button == decreaseBgBtn {\n            timer = Timer.scheduledTimer(timeInterval: 0.15, target: self, selector: #selector(self.decrease), userInfo: nil, repeats: true)\n        } else {\n            timer = Timer.scheduledTimer(timeInterval: 0.15, target: self, selector: #selector(self.increase), userInfo: nil, repeats: true)\n        }\n        timer.fire()\n    }\n```\n这里给按钮添加的action的函数，都需要@objc注解，原因是swift是静态编程语言，objc是动态的，所以这里需要转换为动态效果，所以要声明这个注解，不知道我理解得对不对。\n\n这里只有点击了就去执行加或者减的逻辑，用了一个定时器，保证150ms才走一次。\n加的逻辑看下哈：\n```Swift\n@objc fileprivate func increase() {\n        if (textField.text?.count)! == 0 || Int(textField.text!)! <= _minValue {\n            textField.text = \"\\(_minValue)\"\n        }\n        \n        let number = Int(textField.text!)! + 1;\n        \n        if number <= _maxValue {\n            textField.text = \"\\(number)\";\n            //闭包回调\n            NumberResultClosure?(\"\\(number)\")\n        } else {\n            //添加抖动动画\n            if shakeAnimation {shakeAnimationFunc()}\n            print(\"已超过最大数量\\(_maxValue)\");\n            if documentType == 1 {\n                MBProgressHUD.showTipsMessage(\"数量已超出零售上限\")\n            }\n        }\n        /// 触发rxSwift监听处更新\n        textField.sendActions(for: .valueChanged)\n        \n        if Int(textField.text!)! >= maxValue {\n            decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_available\"), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_Disable\"), for: .normal)\n        }else{\n            decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_available\"), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_available\"), for: .normal)\n        }\n    }\n```\n这里主要就是最大值和最小值判断，这里有个sendActions的方法，个人不是很理解。猜测是用了RxSwift的话，内部编辑框的值变更，会通知到rx的回调处，其实也是通知外部同步刷新。\n\n减的逻辑基本一致，这里就不再看了。\n\n上面还遗漏了一个抬起手后，将定时器取消，这点很重要，如果不及时处理，很容易造成内存泄漏。看下上面给touchCancel和其它按钮状态绑定的事件：\n```Swift\n//松开按钮:清除定时器\n@objc fileprivate func touchUp()  {\n    cleanTimer()\n}\n\n/// 内部实现\nfileprivate func cleanTimer() {\n        if ((timer?.isValid) != nil) {\n            timer.invalidate()\n            timer = nil;\n        }\n    }\n    \n/// 析构函数    \ndeinit {\n    cleanTimer()\n}\n```\n\n这里还有一个非常关键的生命周期函数：\n```Swift\n// MARK: - 重新布局UI\n    /// https://juejin.cn/post/6984250995874365448 layoutSubviews调用时机\n    /// 改变一个UIView的Frame会触发layoutSubviews\n    /// layoutSubviews, 当我们在某个类的内部调整子视图位置时，需要调用。反过来的意思就是说：如果你想要在外部设置subviews的位置，就不要重写。\n    /// 这个方法，默认没有做任何事情，需要子类进行重写\n    /// 如果没有这个方法，那么结果会是空白的，看不到任何东西\n    override open func layoutSubviews() {\n        super.layoutSubviews()\n        \n        let height = frame.size.height\n        let width = frame.size.width\n        let textFieldWidth:CGFloat = 90\n        let BgBtnWidth:CGFloat = 42\n        let btnSize:CGFloat = 28\n        decreaseBtn.frame = CGRect(x: 0, y: (height-btnSize)/2, width: btnSize, height: btnSize)\n        //减按钮(增大可触面积)\n        decreaseBgBtn.frame = CGRect(x: 0, y: 0, width: BgBtnWidth, height: height)\n        increaseBtn.frame = CGRect(x: width-btnSize, y: (height-btnSize)/2, width: btnSize, height: btnSize)\n        //加按钮(增大可触面积)\n        increaseBgBtn.frame = CGRect(x: BgBtnWidth + textFieldWidth, y: 0, width: BgBtnWidth, height: height)\n        textField.frame = CGRect(x: BgBtnWidth, y: 0, width: textFieldWidth, height: height)\n    }\n```\n这个方法必须要实现，确定视图frame，才可以真正显示到屏幕上。\n\n### 2.5 给TextField绑定代理\n在前面初始化UI里面有句代码是这样的：\n`textField.delegate = self`\n这里需要新建一个代理类来支持一下：\n```Swift\nextension PPNumberButton: UITextFieldDelegate {\n    \n    // MARK: - UITextFieldDelegate\n    public func textFieldDidEndEditing(_ textField: UITextField) {\n        if (textField.text?.count)! == 0 || Int(textField.text!) ?? 999999999 < _minValue {\n            textField.text = \"\\(_minValue)\"\n        }\n        if Int(textField.text!) ?? 999999999 > _maxValue {\n            if documentType == 1 {\n                MBProgressHUD.showTipsMessage(\"数量已超出零售上限\")\n            }\n        }\n        if Int(textField.text!) ?? 999999999 >= _maxValue {\n            textField.text = \"\\(_maxValue)\"\n        }\n        //闭包回调，传递值给外部\n        NumberResultClosure?(\"\\(textField.text!)\")\n        //delegate的回调，暴露内部值给外部\n//        delegate2?.numberButtonResult(self, number: \"\\(textField.text!)\")\n        \n        print(\"当前值:   \\(textField.text?.int ?? 0)\")\n        \n        if (textField.text?.int ?? 0) <= 0 {\n            decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_Disable\"), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_available\"), for: .normal)\n        }else if (textField.text?.int ?? 0) >= maxValue {\n            decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_available\"), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_Disable\"), for: .normal)\n        }else{\n            decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_available\"), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_available\"), for: .normal)\n        }\n    }\n    \n    public func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {\n        \n        if range.location <= 8 {\n            return true\n        }else{\n            return false\n        }\n    }\n    \n}\n```\n这里重写了官方文本代理的两个函数：\n· textFieldDidEndEditing 结束编辑调用\n· textField 实时调用，能否显示\n\n### 2.6 自定义扩展函数\n原因是每个地方使用场景不同，这里需要通过扩展函数，可以自己添加一些逻辑，方便调用处能够实现效果。\n```Swift\npublic extension PPNumberButton {\n    \n    /**\n     输入框中的内容\n     */\n    var currentNumber: String? {\n        get {\n            return (textField.text!)\n        }\n        set {\n            textField.text = newValue\n            if isUserInteractionEnabled {\n                if (newValue?.int ?? 0) <= 0 {\n                    decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_Disable\"), for: .normal)\n                    increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_available\"), for: .normal)\n                } else if (newValue?.int ?? 0) >= maxValue {\n                    decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_available\"), for: .normal)\n                    increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_Disable\"), for: .normal)\n                }else{\n                    decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_available\"), for: .normal)\n                    increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_available\"), for: .normal)\n                }\n            }\n        }\n    }\n    /**\n     设置最小值\n     */\n    var minValue: Int {\n        get {\n            return _minValue\n        }\n        set {\n            _minValue = newValue\n            textField.text = \"\\(newValue)\"\n        }\n    }\n    /**\n     设置最大值\n     */\n    var maxValue: Int {\n        get {\n            return _maxValue\n        }\n        set {\n            _maxValue = newValue\n        }\n    }\n    \n    /**\n     * 加减按钮的响应闭包回调\n     * 当数字变化后，暴露给外部，执行自己逻辑\n     */\n    func numberResult(_ finished: @escaping ResultClosure) {\n        NumberResultClosure = finished\n    }\n    \n    /**\n     输入框中的字体属性\n     */\n    func inputFieldFont(_ inputFieldFont: UIFont) {\n        textField.font = inputFieldFont;\n    }\n    \n    /**\n     加减按钮的字体属性\n     */\n    func buttonTitleFont(_ buttonTitleFont: UIFont) {\n        increaseBtn.titleLabel!.font = buttonTitleFont;\n        decreaseBtn.titleLabel!.font = buttonTitleFont;\n    }\n    \n    /**\n     设置按钮的边框颜色\n     */\n    func borderColor(_ borderColor: UIColor) {\n//        layer.borderColor = borderColor.cgColor;\n        decreaseBtn.layer.borderColor = borderColor.cgColor;\n        increaseBtn.layer.borderColor = borderColor.cgColor;\n        \n//        layer.borderWidth = 0.5;\n        decreaseBtn.layer.borderWidth = 0.5;\n        increaseBtn.layer.borderWidth = 0.5;\n    }\n    \n    //注意:加减号按钮的标题和背景图片只能设置其中一个,若全部设置,则以最后设置的类型为准\n    \n    /**\n     设置加/减按钮的标题\n     \n     - parameter decreaseTitle: 减按钮标题\n     - parameter increaseTitle: 加按钮标题\n     */\n    func setTitle(decreaseTitle: String, increaseTitle: String) {\n        decreaseBtn.setBackgroundImage(nil, for: .normal)\n        increaseBtn.setBackgroundImage(nil, for: .normal)\n        \n        decreaseBtn.setTitle(decreaseTitle, for: .normal)\n        increaseBtn.setTitle(increaseTitle, for: .normal)\n    }\n    \n    /**\n     设置加/减按钮的背景图片\n     \n     - parameter decreaseImage: 减按钮背景图片\n     - parameter increaseImage: 加按钮背景图片\n     */\n    func setImage(decreaseImage: UIImage, increaseImage: UIImage) {\n        decreaseBtn.setTitle(nil, for: .normal)\n        increaseBtn.setTitle(nil, for: .normal)\n        \n        decreaseBtn.setBackgroundImage(decreaseImage, for: .normal)\n        increaseBtn.setBackgroundImage(increaseImage, for: .normal)\n    }\n    \n}\n\n```\n这些都是暴露给外部调用者的函数，外部可以轻松改变背景，改变边框颜色等。\n\n```Swift\npublic extension PPNumberButton {\n    \n    /// 是否开启交互 这里主要是设置能否点击，业务需求是某些情况没有超过最大值或低于最小值也不可点击哦\n    var enabled: Bool {\n        get {\n            return isUserInteractionEnabled\n        }\n        set {\n            isUserInteractionEnabled = newValue\n            if isUserInteractionEnabled {\n                let text = textField.text\n                currentNumber = text\n            } else {\n                decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_Disable\"), for: .normal)\n                increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_Disable\"), for: .normal)\n            }\n        }\n    }\n    \n}\n```\n上面的代码也是因为增加了 特殊需求，添加的一个扩展方法。\n\n另外还有一部分代码是使用RxSwift，增加了扩展方法，看下哈：\n```Swift\nextension Reactive where Base: PPNumberButton {\n    var gmMaxValue: Binder<Int> {\n        return Binder(self.base) { (pp, max) in\n            pp.maxValue = max\n        }\n    }\n}\n```\n这里应该是获取最大值，pp指代这个步进器，max就是最大值。\n\n### 2.7 调用者如何使用\n上面基本就把步进器实现完了。\n下面看看调用者如何来使用步进器，这里简单示例下：\n\n先声明一个步进器\n```Swift\nprivate weak var cus_stepper: PPNumberButton!\n```\n\n然后目标地方创建一个步进器，并且初始化步进器相关属性\n```Swift\nlet stepperViewW: CGFloat = 178.0\nlet stepperViewH: CGFloat = 40.0\nlet stepperViewB: CGFloat = 24.0\n\n/// 创建步进器并初始化\nlet cus_stepper = PPNumberButton()\ncus_stepper.shakeAnimation = true\ncus_stepper.maxValue = 999999999\ncus_stepper.minValue = 0\n\n/// 暴露回调给外部，里面就是自己逻辑了\ncus_stepper.numberResult { [weak self] number in\n    guard let self = self else { return }\n    self.act_stepperCountChnage(number)\n}\n\n/// 添加到目标contentView里面\ncontentView.addSubview(cus_stepper)\nself.cus_stepper = cus_stepper\n\n/// 布局设置\ncus_stepper.snp.makeConstraints { make in\n    make.top.equalTo(imgV_photo.snp.bottom).offset(ySuperVerPad)\n    make.right.equalTo(contentView).offset(-ySuperHorPad)\n    make.width.equalTo(stepperViewW)\n    make.height.equalTo(stepperViewH)\n}\n\ncus_stepper.snp.makeConstraints { make in\n    make.bottom.equalTo(contentView).offset(-stepperViewB)\n}\n```\n\n基本就这样。\n\n## 3 总结\n\n1.自定义View需要先分析下交互，确定下如何拆分这个自定义View，再复杂的视图都是一块砖一块瓦拼接起来的，其实这个步进器就3个结构，左右图标，中间编辑框。\n2.iOS自定义View一般都是继承UIView，重写两个init函数，layoutSubviews这个方法确定视图frame，才能显示到屏幕上。\n3.给UIButton添加action一定要用@objc注解，表示可以使用动态方法。\n4.对于封装自定义View一定要严格将某些方法暴露出去，某些方法私有，因为调用者不知道具体细节，所以封装者就一定要注意扩展性，一方面提供好用的扩展方法出去，能够方便调用者去设置各种属性，另一方面要注意类安全性，以及解耦性，尽量不要跟数据太耦合了。\n","source":"_posts/iOS-swift-自定义View之步进器.md","raw":"---\ntitle: iOS swift 自定义View之步进器\ndate: 2023-01-26 10:54:54\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- iOS 自定义View\ncategories:\n- iOS\n---\n\n## 1 需求分析\n 需要实现一个步进器效果，比如我们在购买商品时，需要添加这个商品，可以点击+或者-，也可以手动输入购买数量。\n 效果如下：\n \n <img src=\"stepper0.png\">\n <img src=\"stepper5.png\">\n\n 基本交互很简单，有最小值和最大值，点击减号就将数量减1，点击加号就将数量加1，如果是最大值或者最小值，就将图标置灰不可点击。\n\n## 2 代码实现\n\n### 2.1 类外声明\n\n```Swift\n/// 定义一个闭包，主要是需要暴露里面的数字给外面，可以理解成定义一个接口类型\npublic typealias ResultClosure = (_ number: String)->()\n```\n\n这个主要是给调用步进器的地方使用，当用户行为导致数量变更，肯定要通知外部处理自己逻辑，这是封装自定义View的基本常识，一定要给外部一定的可操作空间。\n\n### 2.2 创建步进器类\n```Swift\n/// 这里是自定义步进器了  @IBDesignable关键字用来声明一个类是可以被设计的，可以实时渲染在interface builder 上\n/// @IBInspectable关键字用来声明一个属性，可以在interface builder上修改该属性，就可以实时渲染border的变化\n/// open 修饰的 class 在 Module 内部和外部都可以被访问和继承\n@IBDesignable open class PPNumberButton: UIView {\n```\n这里继承了UIView，这个注解只是用来实时预览，这里不要也行。如果想了解自定义View实时预览功能，可以参考下这篇文档：[https://blog.wangruofeng007.com/posts/56184/]()\n\n### 2.3 定义类属性\n```Swift\n    /// 0为默认，1为零售开单\n    var documentType:Int = 0\n    \n    /// 结果闭包，用自定义的闭包类型\n    var NumberResultClosure: ResultClosure?\n    \n    var decreaseBtn: UIButton!     // 减按钮\n    var increaseBtn: UIButton!     // 加按钮\n    var textField: UITextField!    // 数量展示/输入框\n    var timer: Timer!              // 快速加减定时器\n    public var _minValue = 1                 // 最小值\n    public var _maxValue = Int.max           // 最大值\n    public var shakeAnimation: Bool = false  // 是否打开抖动动画\n    \n    var decreaseBgBtn:UIButton!  //减按钮(增大可触面积)\n    var increaseBgBtn:UIButton!  //加按钮(增大可触面积)\n    \n    /// rxSwift生命的袋子\n    let bag = DisposeBag()\n```\n\n这里documentType是自己的业务逻辑，忽略。结果闭包2.1声明的那个类型。然后就是几个基本视图了。这里还有个timer，主要用途是长按实现持续增加数字的功能，体验会好一点。\n最大值最小值就是步进器的最大值和最小值。\n抖动动画，是如果已经到最大值了，用户还在按加，就弹一个动画效果。\n然后还有两个UIButton覆盖在增加和减号的图标上面，只是为了扩大点击热区。\n\n### 2.4 生命周期函数\n\n```Swift\n/// UIView的初始化函数，这里一般会覆写这个方法\noverride public init(frame: CGRect) {\n    super.init(frame: frame)\n    \n    setupUI()\n    \n    //整个控件的默认尺寸\n    if frame.isEmpty {\n        self.frame = CGRect(x: 0, y: 0, width: 110, height: 30)\n    }\n    \n}\n\nrequired public init?(coder aDecoder: NSCoder) {\n    super.init(coder: aDecoder)\n\n}\n```\n一般情况，自定义View都需要覆写下这两个init函数。用来初始化UI。\n\n```Swift\n//设置UI布局\nfileprivate func setupUI() {\n    /// 背景颜色清空\n    backgroundColor = UIColor.clear\n\n    /// 加图标和热区加按钮\n    decreaseBtn = setupButton(title: \"reduce_available\")\n    decreaseBgBtn = setupButton(title: \" \")\n    increaseBtn = setupButton(title: \"increase_available\")\n    increaseBgBtn = setupButton(title: \" \")\n    \n    decreaseBtn.backgroundColor = .clear\n    increaseBtn.backgroundColor = .clear\n    //减按钮(增大可触面积)\n    decreaseBgBtn.backgroundColor = .clear\n    //加按钮(增大可触面积)\n    increaseBgBtn.backgroundColor = .clear\n    \n    /// 中间区域的编辑框\n    textField = UITextField.init()\n    textField.font = UIFont.pingFangMedium(size: 16)\n    textField.layer.borderColor = UIColor(red: 0.79, green: 0.80, blue: 0.83, alpha: 1.00).cgColor\n    textField.layer.borderWidth = 1\n    textField.backgroundColor = UIColor(red: 0.97, green: 0.97, blue: 0.99, alpha: 1.00)\n    textField.layer.cornerRadius = 8\n    textField.textColor = UIColor(hex:\"#3B4058\")\n    textField.delegate = self\n    textField.adjustsFontSizeToFitWidth = true        //当文字超出文本框宽度时，自动调整文字大小\n    textField.minimumFontSize = 14                   //最小可缩小的字号\n    textField.keyboardType = UIKeyboardType.numberPad\n    textField.textAlignment = NSTextAlignment.center\n    self.addSubview(textField)\n}\n```\n\n内部用了一个setupButton给按钮增加背景，看下哈：\n```Swift\n//设置加减按钮的公共方法 设置action\nfileprivate func setupButton(title:String) -> UIButton {\n    let button = UIButton.init();\n    button.setBackgroundImage(UIImage.init(named: title), for: .normal)\n    button.setTitleColor(UIColor.gray, for: .normal)\n    button.addTarget(self, action:#selector(self.touchDown(_:)) , for: .touchDown)\n    button.addTarget(self, action:#selector(self.touchUp) , for:.touchUpOutside)\n    button.addTarget(self, action:#selector(self.touchUp) , for:.touchUpInside)\n    button.addTarget(self, action:#selector(self.touchUp) , for:.touchCancel)\n    self.addSubview(button)\n    \n    return button;\n}\n```\n\n这里给按钮增加了一个action，主要是处理用户行为点击加号或者减号的逻辑：\n```Swift\n@objc fileprivate func touchDown(_ button: UIButton) {\n        textField.endEditing(false)\n        if button == decreaseBtn || button == decreaseBgBtn {\n            timer = Timer.scheduledTimer(timeInterval: 0.15, target: self, selector: #selector(self.decrease), userInfo: nil, repeats: true)\n        } else {\n            timer = Timer.scheduledTimer(timeInterval: 0.15, target: self, selector: #selector(self.increase), userInfo: nil, repeats: true)\n        }\n        timer.fire()\n    }\n```\n这里给按钮添加的action的函数，都需要@objc注解，原因是swift是静态编程语言，objc是动态的，所以这里需要转换为动态效果，所以要声明这个注解，不知道我理解得对不对。\n\n这里只有点击了就去执行加或者减的逻辑，用了一个定时器，保证150ms才走一次。\n加的逻辑看下哈：\n```Swift\n@objc fileprivate func increase() {\n        if (textField.text?.count)! == 0 || Int(textField.text!)! <= _minValue {\n            textField.text = \"\\(_minValue)\"\n        }\n        \n        let number = Int(textField.text!)! + 1;\n        \n        if number <= _maxValue {\n            textField.text = \"\\(number)\";\n            //闭包回调\n            NumberResultClosure?(\"\\(number)\")\n        } else {\n            //添加抖动动画\n            if shakeAnimation {shakeAnimationFunc()}\n            print(\"已超过最大数量\\(_maxValue)\");\n            if documentType == 1 {\n                MBProgressHUD.showTipsMessage(\"数量已超出零售上限\")\n            }\n        }\n        /// 触发rxSwift监听处更新\n        textField.sendActions(for: .valueChanged)\n        \n        if Int(textField.text!)! >= maxValue {\n            decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_available\"), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_Disable\"), for: .normal)\n        }else{\n            decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_available\"), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_available\"), for: .normal)\n        }\n    }\n```\n这里主要就是最大值和最小值判断，这里有个sendActions的方法，个人不是很理解。猜测是用了RxSwift的话，内部编辑框的值变更，会通知到rx的回调处，其实也是通知外部同步刷新。\n\n减的逻辑基本一致，这里就不再看了。\n\n上面还遗漏了一个抬起手后，将定时器取消，这点很重要，如果不及时处理，很容易造成内存泄漏。看下上面给touchCancel和其它按钮状态绑定的事件：\n```Swift\n//松开按钮:清除定时器\n@objc fileprivate func touchUp()  {\n    cleanTimer()\n}\n\n/// 内部实现\nfileprivate func cleanTimer() {\n        if ((timer?.isValid) != nil) {\n            timer.invalidate()\n            timer = nil;\n        }\n    }\n    \n/// 析构函数    \ndeinit {\n    cleanTimer()\n}\n```\n\n这里还有一个非常关键的生命周期函数：\n```Swift\n// MARK: - 重新布局UI\n    /// https://juejin.cn/post/6984250995874365448 layoutSubviews调用时机\n    /// 改变一个UIView的Frame会触发layoutSubviews\n    /// layoutSubviews, 当我们在某个类的内部调整子视图位置时，需要调用。反过来的意思就是说：如果你想要在外部设置subviews的位置，就不要重写。\n    /// 这个方法，默认没有做任何事情，需要子类进行重写\n    /// 如果没有这个方法，那么结果会是空白的，看不到任何东西\n    override open func layoutSubviews() {\n        super.layoutSubviews()\n        \n        let height = frame.size.height\n        let width = frame.size.width\n        let textFieldWidth:CGFloat = 90\n        let BgBtnWidth:CGFloat = 42\n        let btnSize:CGFloat = 28\n        decreaseBtn.frame = CGRect(x: 0, y: (height-btnSize)/2, width: btnSize, height: btnSize)\n        //减按钮(增大可触面积)\n        decreaseBgBtn.frame = CGRect(x: 0, y: 0, width: BgBtnWidth, height: height)\n        increaseBtn.frame = CGRect(x: width-btnSize, y: (height-btnSize)/2, width: btnSize, height: btnSize)\n        //加按钮(增大可触面积)\n        increaseBgBtn.frame = CGRect(x: BgBtnWidth + textFieldWidth, y: 0, width: BgBtnWidth, height: height)\n        textField.frame = CGRect(x: BgBtnWidth, y: 0, width: textFieldWidth, height: height)\n    }\n```\n这个方法必须要实现，确定视图frame，才可以真正显示到屏幕上。\n\n### 2.5 给TextField绑定代理\n在前面初始化UI里面有句代码是这样的：\n`textField.delegate = self`\n这里需要新建一个代理类来支持一下：\n```Swift\nextension PPNumberButton: UITextFieldDelegate {\n    \n    // MARK: - UITextFieldDelegate\n    public func textFieldDidEndEditing(_ textField: UITextField) {\n        if (textField.text?.count)! == 0 || Int(textField.text!) ?? 999999999 < _minValue {\n            textField.text = \"\\(_minValue)\"\n        }\n        if Int(textField.text!) ?? 999999999 > _maxValue {\n            if documentType == 1 {\n                MBProgressHUD.showTipsMessage(\"数量已超出零售上限\")\n            }\n        }\n        if Int(textField.text!) ?? 999999999 >= _maxValue {\n            textField.text = \"\\(_maxValue)\"\n        }\n        //闭包回调，传递值给外部\n        NumberResultClosure?(\"\\(textField.text!)\")\n        //delegate的回调，暴露内部值给外部\n//        delegate2?.numberButtonResult(self, number: \"\\(textField.text!)\")\n        \n        print(\"当前值:   \\(textField.text?.int ?? 0)\")\n        \n        if (textField.text?.int ?? 0) <= 0 {\n            decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_Disable\"), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_available\"), for: .normal)\n        }else if (textField.text?.int ?? 0) >= maxValue {\n            decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_available\"), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_Disable\"), for: .normal)\n        }else{\n            decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_available\"), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_available\"), for: .normal)\n        }\n    }\n    \n    public func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {\n        \n        if range.location <= 8 {\n            return true\n        }else{\n            return false\n        }\n    }\n    \n}\n```\n这里重写了官方文本代理的两个函数：\n· textFieldDidEndEditing 结束编辑调用\n· textField 实时调用，能否显示\n\n### 2.6 自定义扩展函数\n原因是每个地方使用场景不同，这里需要通过扩展函数，可以自己添加一些逻辑，方便调用处能够实现效果。\n```Swift\npublic extension PPNumberButton {\n    \n    /**\n     输入框中的内容\n     */\n    var currentNumber: String? {\n        get {\n            return (textField.text!)\n        }\n        set {\n            textField.text = newValue\n            if isUserInteractionEnabled {\n                if (newValue?.int ?? 0) <= 0 {\n                    decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_Disable\"), for: .normal)\n                    increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_available\"), for: .normal)\n                } else if (newValue?.int ?? 0) >= maxValue {\n                    decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_available\"), for: .normal)\n                    increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_Disable\"), for: .normal)\n                }else{\n                    decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_available\"), for: .normal)\n                    increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_available\"), for: .normal)\n                }\n            }\n        }\n    }\n    /**\n     设置最小值\n     */\n    var minValue: Int {\n        get {\n            return _minValue\n        }\n        set {\n            _minValue = newValue\n            textField.text = \"\\(newValue)\"\n        }\n    }\n    /**\n     设置最大值\n     */\n    var maxValue: Int {\n        get {\n            return _maxValue\n        }\n        set {\n            _maxValue = newValue\n        }\n    }\n    \n    /**\n     * 加减按钮的响应闭包回调\n     * 当数字变化后，暴露给外部，执行自己逻辑\n     */\n    func numberResult(_ finished: @escaping ResultClosure) {\n        NumberResultClosure = finished\n    }\n    \n    /**\n     输入框中的字体属性\n     */\n    func inputFieldFont(_ inputFieldFont: UIFont) {\n        textField.font = inputFieldFont;\n    }\n    \n    /**\n     加减按钮的字体属性\n     */\n    func buttonTitleFont(_ buttonTitleFont: UIFont) {\n        increaseBtn.titleLabel!.font = buttonTitleFont;\n        decreaseBtn.titleLabel!.font = buttonTitleFont;\n    }\n    \n    /**\n     设置按钮的边框颜色\n     */\n    func borderColor(_ borderColor: UIColor) {\n//        layer.borderColor = borderColor.cgColor;\n        decreaseBtn.layer.borderColor = borderColor.cgColor;\n        increaseBtn.layer.borderColor = borderColor.cgColor;\n        \n//        layer.borderWidth = 0.5;\n        decreaseBtn.layer.borderWidth = 0.5;\n        increaseBtn.layer.borderWidth = 0.5;\n    }\n    \n    //注意:加减号按钮的标题和背景图片只能设置其中一个,若全部设置,则以最后设置的类型为准\n    \n    /**\n     设置加/减按钮的标题\n     \n     - parameter decreaseTitle: 减按钮标题\n     - parameter increaseTitle: 加按钮标题\n     */\n    func setTitle(decreaseTitle: String, increaseTitle: String) {\n        decreaseBtn.setBackgroundImage(nil, for: .normal)\n        increaseBtn.setBackgroundImage(nil, for: .normal)\n        \n        decreaseBtn.setTitle(decreaseTitle, for: .normal)\n        increaseBtn.setTitle(increaseTitle, for: .normal)\n    }\n    \n    /**\n     设置加/减按钮的背景图片\n     \n     - parameter decreaseImage: 减按钮背景图片\n     - parameter increaseImage: 加按钮背景图片\n     */\n    func setImage(decreaseImage: UIImage, increaseImage: UIImage) {\n        decreaseBtn.setTitle(nil, for: .normal)\n        increaseBtn.setTitle(nil, for: .normal)\n        \n        decreaseBtn.setBackgroundImage(decreaseImage, for: .normal)\n        increaseBtn.setBackgroundImage(increaseImage, for: .normal)\n    }\n    \n}\n\n```\n这些都是暴露给外部调用者的函数，外部可以轻松改变背景，改变边框颜色等。\n\n```Swift\npublic extension PPNumberButton {\n    \n    /// 是否开启交互 这里主要是设置能否点击，业务需求是某些情况没有超过最大值或低于最小值也不可点击哦\n    var enabled: Bool {\n        get {\n            return isUserInteractionEnabled\n        }\n        set {\n            isUserInteractionEnabled = newValue\n            if isUserInteractionEnabled {\n                let text = textField.text\n                currentNumber = text\n            } else {\n                decreaseBtn.setBackgroundImage(UIImage.init(named: \"reduce_Disable\"), for: .normal)\n                increaseBtn.setBackgroundImage(UIImage.init(named: \"increase_Disable\"), for: .normal)\n            }\n        }\n    }\n    \n}\n```\n上面的代码也是因为增加了 特殊需求，添加的一个扩展方法。\n\n另外还有一部分代码是使用RxSwift，增加了扩展方法，看下哈：\n```Swift\nextension Reactive where Base: PPNumberButton {\n    var gmMaxValue: Binder<Int> {\n        return Binder(self.base) { (pp, max) in\n            pp.maxValue = max\n        }\n    }\n}\n```\n这里应该是获取最大值，pp指代这个步进器，max就是最大值。\n\n### 2.7 调用者如何使用\n上面基本就把步进器实现完了。\n下面看看调用者如何来使用步进器，这里简单示例下：\n\n先声明一个步进器\n```Swift\nprivate weak var cus_stepper: PPNumberButton!\n```\n\n然后目标地方创建一个步进器，并且初始化步进器相关属性\n```Swift\nlet stepperViewW: CGFloat = 178.0\nlet stepperViewH: CGFloat = 40.0\nlet stepperViewB: CGFloat = 24.0\n\n/// 创建步进器并初始化\nlet cus_stepper = PPNumberButton()\ncus_stepper.shakeAnimation = true\ncus_stepper.maxValue = 999999999\ncus_stepper.minValue = 0\n\n/// 暴露回调给外部，里面就是自己逻辑了\ncus_stepper.numberResult { [weak self] number in\n    guard let self = self else { return }\n    self.act_stepperCountChnage(number)\n}\n\n/// 添加到目标contentView里面\ncontentView.addSubview(cus_stepper)\nself.cus_stepper = cus_stepper\n\n/// 布局设置\ncus_stepper.snp.makeConstraints { make in\n    make.top.equalTo(imgV_photo.snp.bottom).offset(ySuperVerPad)\n    make.right.equalTo(contentView).offset(-ySuperHorPad)\n    make.width.equalTo(stepperViewW)\n    make.height.equalTo(stepperViewH)\n}\n\ncus_stepper.snp.makeConstraints { make in\n    make.bottom.equalTo(contentView).offset(-stepperViewB)\n}\n```\n\n基本就这样。\n\n## 3 总结\n\n1.自定义View需要先分析下交互，确定下如何拆分这个自定义View，再复杂的视图都是一块砖一块瓦拼接起来的，其实这个步进器就3个结构，左右图标，中间编辑框。\n2.iOS自定义View一般都是继承UIView，重写两个init函数，layoutSubviews这个方法确定视图frame，才能显示到屏幕上。\n3.给UIButton添加action一定要用@objc注解，表示可以使用动态方法。\n4.对于封装自定义View一定要严格将某些方法暴露出去，某些方法私有，因为调用者不知道具体细节，所以封装者就一定要注意扩展性，一方面提供好用的扩展方法出去，能够方便调用者去设置各种属性，另一方面要注意类安全性，以及解耦性，尽量不要跟数据太耦合了。\n","slug":"iOS-swift-自定义View之步进器","published":1,"updated":"2023-02-01T07:17:16.383Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlhfhyv001livv7390secfa","content":"<h2 id=\"1-需求分析\"><a href=\"#1-需求分析\" class=\"headerlink\" title=\"1 需求分析\"></a>1 需求分析</h2><p> 需要实现一个步进器效果，比如我们在购买商品时，需要添加这个商品，可以点击+或者-，也可以手动输入购买数量。<br> 效果如下：</p>\n <img src=\"stepper0.png\">\n <img src=\"stepper5.png\">\n\n<p> 基本交互很简单，有最小值和最大值，点击减号就将数量减1，点击加号就将数量加1，如果是最大值或者最小值，就将图标置灰不可点击。</p>\n<h2 id=\"2-代码实现\"><a href=\"#2-代码实现\" class=\"headerlink\" title=\"2 代码实现\"></a>2 代码实现</h2><h3 id=\"2-1-类外声明\"><a href=\"#2-1-类外声明\" class=\"headerlink\" title=\"2.1 类外声明\"></a>2.1 类外声明</h3><pre><code class=\"line-numbers language-Swift\">/// 定义一个闭包，主要是需要暴露里面的数字给外面，可以理解成定义一个接口类型\npublic typealias ResultClosure = (_ number: String)-&gt;()\n</code></pre>\n<p>这个主要是给调用步进器的地方使用，当用户行为导致数量变更，肯定要通知外部处理自己逻辑，这是封装自定义View的基本常识，一定要给外部一定的可操作空间。</p>\n<h3 id=\"2-2-创建步进器类\"><a href=\"#2-2-创建步进器类\" class=\"headerlink\" title=\"2.2 创建步进器类\"></a>2.2 创建步进器类</h3><pre><code class=\"line-numbers language-Swift\">/// 这里是自定义步进器了  @IBDesignable关键字用来声明一个类是可以被设计的，可以实时渲染在interface builder 上\n/// @IBInspectable关键字用来声明一个属性，可以在interface builder上修改该属性，就可以实时渲染border的变化\n/// open 修饰的 class 在 Module 内部和外部都可以被访问和继承\n@IBDesignable open class PPNumberButton: UIView &#123;\n</code></pre>\n<p>这里继承了UIView，这个注解只是用来实时预览，这里不要也行。如果想了解自定义View实时预览功能，可以参考下这篇文档：<a href=\"\">https://blog.wangruofeng007.com/posts/56184/</a></p>\n<h3 id=\"2-3-定义类属性\"><a href=\"#2-3-定义类属性\" class=\"headerlink\" title=\"2.3 定义类属性\"></a>2.3 定义类属性</h3><pre><code class=\"line-numbers language-Swift\">    /// 0为默认，1为零售开单\n    var documentType:Int = 0\n    \n    /// 结果闭包，用自定义的闭包类型\n    var NumberResultClosure: ResultClosure?\n    \n    var decreaseBtn: UIButton!     // 减按钮\n    var increaseBtn: UIButton!     // 加按钮\n    var textField: UITextField!    // 数量展示/输入框\n    var timer: Timer!              // 快速加减定时器\n    public var _minValue = 1                 // 最小值\n    public var _maxValue = Int.max           // 最大值\n    public var shakeAnimation: Bool = false  // 是否打开抖动动画\n    \n    var decreaseBgBtn:UIButton!  //减按钮(增大可触面积)\n    var increaseBgBtn:UIButton!  //加按钮(增大可触面积)\n    \n    /// rxSwift生命的袋子\n    let bag = DisposeBag()\n</code></pre>\n<p>这里documentType是自己的业务逻辑，忽略。结果闭包2.1声明的那个类型。然后就是几个基本视图了。这里还有个timer，主要用途是长按实现持续增加数字的功能，体验会好一点。<br>最大值最小值就是步进器的最大值和最小值。<br>抖动动画，是如果已经到最大值了，用户还在按加，就弹一个动画效果。<br>然后还有两个UIButton覆盖在增加和减号的图标上面，只是为了扩大点击热区。</p>\n<h3 id=\"2-4-生命周期函数\"><a href=\"#2-4-生命周期函数\" class=\"headerlink\" title=\"2.4 生命周期函数\"></a>2.4 生命周期函数</h3><pre><code class=\"line-numbers language-Swift\">/// UIView的初始化函数，这里一般会覆写这个方法\noverride public init(frame: CGRect) &#123;\n    super.init(frame: frame)\n    \n    setupUI()\n    \n    //整个控件的默认尺寸\n    if frame.isEmpty &#123;\n        self.frame = CGRect(x: 0, y: 0, width: 110, height: 30)\n    &#125;\n    \n&#125;\n\nrequired public init?(coder aDecoder: NSCoder) &#123;\n    super.init(coder: aDecoder)\n\n&#125;\n</code></pre>\n<p>一般情况，自定义View都需要覆写下这两个init函数。用来初始化UI。</p>\n<pre><code class=\"line-numbers language-Swift\">//设置UI布局\nfileprivate func setupUI() &#123;\n    /// 背景颜色清空\n    backgroundColor = UIColor.clear\n\n    /// 加图标和热区加按钮\n    decreaseBtn = setupButton(title: &quot;reduce_available&quot;)\n    decreaseBgBtn = setupButton(title: &quot; &quot;)\n    increaseBtn = setupButton(title: &quot;increase_available&quot;)\n    increaseBgBtn = setupButton(title: &quot; &quot;)\n    \n    decreaseBtn.backgroundColor = .clear\n    increaseBtn.backgroundColor = .clear\n    //减按钮(增大可触面积)\n    decreaseBgBtn.backgroundColor = .clear\n    //加按钮(增大可触面积)\n    increaseBgBtn.backgroundColor = .clear\n    \n    /// 中间区域的编辑框\n    textField = UITextField.init()\n    textField.font = UIFont.pingFangMedium(size: 16)\n    textField.layer.borderColor = UIColor(red: 0.79, green: 0.80, blue: 0.83, alpha: 1.00).cgColor\n    textField.layer.borderWidth = 1\n    textField.backgroundColor = UIColor(red: 0.97, green: 0.97, blue: 0.99, alpha: 1.00)\n    textField.layer.cornerRadius = 8\n    textField.textColor = UIColor(hex:&quot;#3B4058&quot;)\n    textField.delegate = self\n    textField.adjustsFontSizeToFitWidth = true        //当文字超出文本框宽度时，自动调整文字大小\n    textField.minimumFontSize = 14                   //最小可缩小的字号\n    textField.keyboardType = UIKeyboardType.numberPad\n    textField.textAlignment = NSTextAlignment.center\n    self.addSubview(textField)\n&#125;\n</code></pre>\n<p>内部用了一个setupButton给按钮增加背景，看下哈：</p>\n<pre><code class=\"line-numbers language-Swift\">//设置加减按钮的公共方法 设置action\nfileprivate func setupButton(title:String) -&gt; UIButton &#123;\n    let button = UIButton.init();\n    button.setBackgroundImage(UIImage.init(named: title), for: .normal)\n    button.setTitleColor(UIColor.gray, for: .normal)\n    button.addTarget(self, action:#selector(self.touchDown(_:)) , for: .touchDown)\n    button.addTarget(self, action:#selector(self.touchUp) , for:.touchUpOutside)\n    button.addTarget(self, action:#selector(self.touchUp) , for:.touchUpInside)\n    button.addTarget(self, action:#selector(self.touchUp) , for:.touchCancel)\n    self.addSubview(button)\n    \n    return button;\n&#125;\n</code></pre>\n<p>这里给按钮增加了一个action，主要是处理用户行为点击加号或者减号的逻辑：</p>\n<pre><code class=\"line-numbers language-Swift\">@objc fileprivate func touchDown(_ button: UIButton) &#123;\n        textField.endEditing(false)\n        if button == decreaseBtn || button == decreaseBgBtn &#123;\n            timer = Timer.scheduledTimer(timeInterval: 0.15, target: self, selector: #selector(self.decrease), userInfo: nil, repeats: true)\n        &#125; else &#123;\n            timer = Timer.scheduledTimer(timeInterval: 0.15, target: self, selector: #selector(self.increase), userInfo: nil, repeats: true)\n        &#125;\n        timer.fire()\n    &#125;\n</code></pre>\n<p>这里给按钮添加的action的函数，都需要@objc注解，原因是swift是静态编程语言，objc是动态的，所以这里需要转换为动态效果，所以要声明这个注解，不知道我理解得对不对。</p>\n<p>这里只有点击了就去执行加或者减的逻辑，用了一个定时器，保证150ms才走一次。<br>加的逻辑看下哈：</p>\n<pre><code class=\"line-numbers language-Swift\">@objc fileprivate func increase() &#123;\n        if (textField.text?.count)! == 0 || Int(textField.text!)! &lt;= _minValue &#123;\n            textField.text = &quot;\\(_minValue)&quot;\n        &#125;\n        \n        let number = Int(textField.text!)! + 1;\n        \n        if number &lt;= _maxValue &#123;\n            textField.text = &quot;\\(number)&quot;;\n            //闭包回调\n            NumberResultClosure?(&quot;\\(number)&quot;)\n        &#125; else &#123;\n            //添加抖动动画\n            if shakeAnimation &#123;shakeAnimationFunc()&#125;\n            print(&quot;已超过最大数量\\(_maxValue)&quot;);\n            if documentType == 1 &#123;\n                MBProgressHUD.showTipsMessage(&quot;数量已超出零售上限&quot;)\n            &#125;\n        &#125;\n        /// 触发rxSwift监听处更新\n        textField.sendActions(for: .valueChanged)\n        \n        if Int(textField.text!)! &gt;= maxValue &#123;\n            decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_available&quot;), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_Disable&quot;), for: .normal)\n        &#125;else&#123;\n            decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_available&quot;), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_available&quot;), for: .normal)\n        &#125;\n    &#125;\n</code></pre>\n<p>这里主要就是最大值和最小值判断，这里有个sendActions的方法，个人不是很理解。猜测是用了RxSwift的话，内部编辑框的值变更，会通知到rx的回调处，其实也是通知外部同步刷新。</p>\n<p>减的逻辑基本一致，这里就不再看了。</p>\n<p>上面还遗漏了一个抬起手后，将定时器取消，这点很重要，如果不及时处理，很容易造成内存泄漏。看下上面给touchCancel和其它按钮状态绑定的事件：</p>\n<pre><code class=\"line-numbers language-Swift\">//松开按钮:清除定时器\n@objc fileprivate func touchUp()  &#123;\n    cleanTimer()\n&#125;\n\n/// 内部实现\nfileprivate func cleanTimer() &#123;\n        if ((timer?.isValid) != nil) &#123;\n            timer.invalidate()\n            timer = nil;\n        &#125;\n    &#125;\n    \n/// 析构函数    \ndeinit &#123;\n    cleanTimer()\n&#125;\n</code></pre>\n<p>这里还有一个非常关键的生命周期函数：</p>\n<pre><code class=\"line-numbers language-Swift\">// MARK: - 重新布局UI\n    /// https://juejin.cn/post/6984250995874365448 layoutSubviews调用时机\n    /// 改变一个UIView的Frame会触发layoutSubviews\n    /// layoutSubviews, 当我们在某个类的内部调整子视图位置时，需要调用。反过来的意思就是说：如果你想要在外部设置subviews的位置，就不要重写。\n    /// 这个方法，默认没有做任何事情，需要子类进行重写\n    /// 如果没有这个方法，那么结果会是空白的，看不到任何东西\n    override open func layoutSubviews() &#123;\n        super.layoutSubviews()\n        \n        let height = frame.size.height\n        let width = frame.size.width\n        let textFieldWidth:CGFloat = 90\n        let BgBtnWidth:CGFloat = 42\n        let btnSize:CGFloat = 28\n        decreaseBtn.frame = CGRect(x: 0, y: (height-btnSize)/2, width: btnSize, height: btnSize)\n        //减按钮(增大可触面积)\n        decreaseBgBtn.frame = CGRect(x: 0, y: 0, width: BgBtnWidth, height: height)\n        increaseBtn.frame = CGRect(x: width-btnSize, y: (height-btnSize)/2, width: btnSize, height: btnSize)\n        //加按钮(增大可触面积)\n        increaseBgBtn.frame = CGRect(x: BgBtnWidth + textFieldWidth, y: 0, width: BgBtnWidth, height: height)\n        textField.frame = CGRect(x: BgBtnWidth, y: 0, width: textFieldWidth, height: height)\n    &#125;\n</code></pre>\n<p>这个方法必须要实现，确定视图frame，才可以真正显示到屏幕上。</p>\n<h3 id=\"2-5-给TextField绑定代理\"><a href=\"#2-5-给TextField绑定代理\" class=\"headerlink\" title=\"2.5 给TextField绑定代理\"></a>2.5 给TextField绑定代理</h3><p>在前面初始化UI里面有句代码是这样的：<br><code>textField.delegate = self</code><br>这里需要新建一个代理类来支持一下：</p>\n<pre><code class=\"line-numbers language-Swift\">extension PPNumberButton: UITextFieldDelegate &#123;\n    \n    // MARK: - UITextFieldDelegate\n    public func textFieldDidEndEditing(_ textField: UITextField) &#123;\n        if (textField.text?.count)! == 0 || Int(textField.text!) ?? 999999999 &lt; _minValue &#123;\n            textField.text = &quot;\\(_minValue)&quot;\n        &#125;\n        if Int(textField.text!) ?? 999999999 &gt; _maxValue &#123;\n            if documentType == 1 &#123;\n                MBProgressHUD.showTipsMessage(&quot;数量已超出零售上限&quot;)\n            &#125;\n        &#125;\n        if Int(textField.text!) ?? 999999999 &gt;= _maxValue &#123;\n            textField.text = &quot;\\(_maxValue)&quot;\n        &#125;\n        //闭包回调，传递值给外部\n        NumberResultClosure?(&quot;\\(textField.text!)&quot;)\n        //delegate的回调，暴露内部值给外部\n//        delegate2?.numberButtonResult(self, number: &quot;\\(textField.text!)&quot;)\n        \n        print(&quot;当前值:   \\(textField.text?.int ?? 0)&quot;)\n        \n        if (textField.text?.int ?? 0) &lt;= 0 &#123;\n            decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_Disable&quot;), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_available&quot;), for: .normal)\n        &#125;else if (textField.text?.int ?? 0) &gt;= maxValue &#123;\n            decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_available&quot;), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_Disable&quot;), for: .normal)\n        &#125;else&#123;\n            decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_available&quot;), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_available&quot;), for: .normal)\n        &#125;\n    &#125;\n    \n    public func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -&gt; Bool &#123;\n        \n        if range.location &lt;= 8 &#123;\n            return true\n        &#125;else&#123;\n            return false\n        &#125;\n    &#125;\n    \n&#125;\n</code></pre>\n<p>这里重写了官方文本代理的两个函数：<br>· textFieldDidEndEditing 结束编辑调用<br>· textField 实时调用，能否显示</p>\n<h3 id=\"2-6-自定义扩展函数\"><a href=\"#2-6-自定义扩展函数\" class=\"headerlink\" title=\"2.6 自定义扩展函数\"></a>2.6 自定义扩展函数</h3><p>原因是每个地方使用场景不同，这里需要通过扩展函数，可以自己添加一些逻辑，方便调用处能够实现效果。</p>\n<pre><code class=\"line-numbers language-Swift\">public extension PPNumberButton &#123;\n    \n    /**\n     输入框中的内容\n     */\n    var currentNumber: String? &#123;\n        get &#123;\n            return (textField.text!)\n        &#125;\n        set &#123;\n            textField.text = newValue\n            if isUserInteractionEnabled &#123;\n                if (newValue?.int ?? 0) &lt;= 0 &#123;\n                    decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_Disable&quot;), for: .normal)\n                    increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_available&quot;), for: .normal)\n                &#125; else if (newValue?.int ?? 0) &gt;= maxValue &#123;\n                    decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_available&quot;), for: .normal)\n                    increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_Disable&quot;), for: .normal)\n                &#125;else&#123;\n                    decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_available&quot;), for: .normal)\n                    increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_available&quot;), for: .normal)\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    /**\n     设置最小值\n     */\n    var minValue: Int &#123;\n        get &#123;\n            return _minValue\n        &#125;\n        set &#123;\n            _minValue = newValue\n            textField.text = &quot;\\(newValue)&quot;\n        &#125;\n    &#125;\n    /**\n     设置最大值\n     */\n    var maxValue: Int &#123;\n        get &#123;\n            return _maxValue\n        &#125;\n        set &#123;\n            _maxValue = newValue\n        &#125;\n    &#125;\n    \n    /**\n     * 加减按钮的响应闭包回调\n     * 当数字变化后，暴露给外部，执行自己逻辑\n     */\n    func numberResult(_ finished: @escaping ResultClosure) &#123;\n        NumberResultClosure = finished\n    &#125;\n    \n    /**\n     输入框中的字体属性\n     */\n    func inputFieldFont(_ inputFieldFont: UIFont) &#123;\n        textField.font = inputFieldFont;\n    &#125;\n    \n    /**\n     加减按钮的字体属性\n     */\n    func buttonTitleFont(_ buttonTitleFont: UIFont) &#123;\n        increaseBtn.titleLabel!.font = buttonTitleFont;\n        decreaseBtn.titleLabel!.font = buttonTitleFont;\n    &#125;\n    \n    /**\n     设置按钮的边框颜色\n     */\n    func borderColor(_ borderColor: UIColor) &#123;\n//        layer.borderColor = borderColor.cgColor;\n        decreaseBtn.layer.borderColor = borderColor.cgColor;\n        increaseBtn.layer.borderColor = borderColor.cgColor;\n        \n//        layer.borderWidth = 0.5;\n        decreaseBtn.layer.borderWidth = 0.5;\n        increaseBtn.layer.borderWidth = 0.5;\n    &#125;\n    \n    //注意:加减号按钮的标题和背景图片只能设置其中一个,若全部设置,则以最后设置的类型为准\n    \n    /**\n     设置加/减按钮的标题\n     \n     - parameter decreaseTitle: 减按钮标题\n     - parameter increaseTitle: 加按钮标题\n     */\n    func setTitle(decreaseTitle: String, increaseTitle: String) &#123;\n        decreaseBtn.setBackgroundImage(nil, for: .normal)\n        increaseBtn.setBackgroundImage(nil, for: .normal)\n        \n        decreaseBtn.setTitle(decreaseTitle, for: .normal)\n        increaseBtn.setTitle(increaseTitle, for: .normal)\n    &#125;\n    \n    /**\n     设置加/减按钮的背景图片\n     \n     - parameter decreaseImage: 减按钮背景图片\n     - parameter increaseImage: 加按钮背景图片\n     */\n    func setImage(decreaseImage: UIImage, increaseImage: UIImage) &#123;\n        decreaseBtn.setTitle(nil, for: .normal)\n        increaseBtn.setTitle(nil, for: .normal)\n        \n        decreaseBtn.setBackgroundImage(decreaseImage, for: .normal)\n        increaseBtn.setBackgroundImage(increaseImage, for: .normal)\n    &#125;\n    \n&#125;\n</code></pre>\n<p>这些都是暴露给外部调用者的函数，外部可以轻松改变背景，改变边框颜色等。</p>\n<pre><code class=\"line-numbers language-Swift\">public extension PPNumberButton &#123;\n    \n    /// 是否开启交互 这里主要是设置能否点击，业务需求是某些情况没有超过最大值或低于最小值也不可点击哦\n    var enabled: Bool &#123;\n        get &#123;\n            return isUserInteractionEnabled\n        &#125;\n        set &#123;\n            isUserInteractionEnabled = newValue\n            if isUserInteractionEnabled &#123;\n                let text = textField.text\n                currentNumber = text\n            &#125; else &#123;\n                decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_Disable&quot;), for: .normal)\n                increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_Disable&quot;), for: .normal)\n            &#125;\n        &#125;\n    &#125;\n    \n&#125;\n</code></pre>\n<p>上面的代码也是因为增加了 特殊需求，添加的一个扩展方法。</p>\n<p>另外还有一部分代码是使用RxSwift，增加了扩展方法，看下哈：</p>\n<pre><code class=\"line-numbers language-Swift\">extension Reactive where Base: PPNumberButton &#123;\n    var gmMaxValue: Binder&lt;Int&gt; &#123;\n        return Binder(self.base) &#123; (pp, max) in\n            pp.maxValue = max\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里应该是获取最大值，pp指代这个步进器，max就是最大值。</p>\n<h3 id=\"2-7-调用者如何使用\"><a href=\"#2-7-调用者如何使用\" class=\"headerlink\" title=\"2.7 调用者如何使用\"></a>2.7 调用者如何使用</h3><p>上面基本就把步进器实现完了。<br>下面看看调用者如何来使用步进器，这里简单示例下：</p>\n<p>先声明一个步进器</p>\n<pre><code class=\"line-numbers language-Swift\">private weak var cus_stepper: PPNumberButton!\n</code></pre>\n<p>然后目标地方创建一个步进器，并且初始化步进器相关属性</p>\n<pre><code class=\"line-numbers language-Swift\">let stepperViewW: CGFloat = 178.0\nlet stepperViewH: CGFloat = 40.0\nlet stepperViewB: CGFloat = 24.0\n\n/// 创建步进器并初始化\nlet cus_stepper = PPNumberButton()\ncus_stepper.shakeAnimation = true\ncus_stepper.maxValue = 999999999\ncus_stepper.minValue = 0\n\n/// 暴露回调给外部，里面就是自己逻辑了\ncus_stepper.numberResult &#123; [weak self] number in\n    guard let self = self else &#123; return &#125;\n    self.act_stepperCountChnage(number)\n&#125;\n\n/// 添加到目标contentView里面\ncontentView.addSubview(cus_stepper)\nself.cus_stepper = cus_stepper\n\n/// 布局设置\ncus_stepper.snp.makeConstraints &#123; make in\n    make.top.equalTo(imgV_photo.snp.bottom).offset(ySuperVerPad)\n    make.right.equalTo(contentView).offset(-ySuperHorPad)\n    make.width.equalTo(stepperViewW)\n    make.height.equalTo(stepperViewH)\n&#125;\n\ncus_stepper.snp.makeConstraints &#123; make in\n    make.bottom.equalTo(contentView).offset(-stepperViewB)\n&#125;\n</code></pre>\n<p>基本就这样。</p>\n<h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3 总结\"></a>3 总结</h2><p>1.自定义View需要先分析下交互，确定下如何拆分这个自定义View，再复杂的视图都是一块砖一块瓦拼接起来的，其实这个步进器就3个结构，左右图标，中间编辑框。<br>2.iOS自定义View一般都是继承UIView，重写两个init函数，layoutSubviews这个方法确定视图frame，才能显示到屏幕上。<br>3.给UIButton添加action一定要用@objc注解，表示可以使用动态方法。<br>4.对于封装自定义View一定要严格将某些方法暴露出去，某些方法私有，因为调用者不知道具体细节，所以封装者就一定要注意扩展性，一方面提供好用的扩展方法出去，能够方便调用者去设置各种属性，另一方面要注意类安全性，以及解耦性，尽量不要跟数据太耦合了。</p>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-需求分析\"><a href=\"#1-需求分析\" class=\"headerlink\" title=\"1 需求分析\"></a>1 需求分析</h2><p> 需要实现一个步进器效果，比如我们在购买商品时，需要添加这个商品，可以点击+或者-，也可以手动输入购买数量。<br> 效果如下：</p>\n <img src=\"stepper0.png\">\n <img src=\"stepper5.png\">\n\n<p> 基本交互很简单，有最小值和最大值，点击减号就将数量减1，点击加号就将数量加1，如果是最大值或者最小值，就将图标置灰不可点击。</p>\n<h2 id=\"2-代码实现\"><a href=\"#2-代码实现\" class=\"headerlink\" title=\"2 代码实现\"></a>2 代码实现</h2><h3 id=\"2-1-类外声明\"><a href=\"#2-1-类外声明\" class=\"headerlink\" title=\"2.1 类外声明\"></a>2.1 类外声明</h3><pre><code class=\"line-numbers language-Swift\">/// 定义一个闭包，主要是需要暴露里面的数字给外面，可以理解成定义一个接口类型\npublic typealias ResultClosure = (_ number: String)-&gt;()\n</code></pre>\n<p>这个主要是给调用步进器的地方使用，当用户行为导致数量变更，肯定要通知外部处理自己逻辑，这是封装自定义View的基本常识，一定要给外部一定的可操作空间。</p>\n<h3 id=\"2-2-创建步进器类\"><a href=\"#2-2-创建步进器类\" class=\"headerlink\" title=\"2.2 创建步进器类\"></a>2.2 创建步进器类</h3><pre><code class=\"line-numbers language-Swift\">/// 这里是自定义步进器了  @IBDesignable关键字用来声明一个类是可以被设计的，可以实时渲染在interface builder 上\n/// @IBInspectable关键字用来声明一个属性，可以在interface builder上修改该属性，就可以实时渲染border的变化\n/// open 修饰的 class 在 Module 内部和外部都可以被访问和继承\n@IBDesignable open class PPNumberButton: UIView &#123;\n</code></pre>\n<p>这里继承了UIView，这个注解只是用来实时预览，这里不要也行。如果想了解自定义View实时预览功能，可以参考下这篇文档：<a href=\"\">https://blog.wangruofeng007.com/posts/56184/</a></p>\n<h3 id=\"2-3-定义类属性\"><a href=\"#2-3-定义类属性\" class=\"headerlink\" title=\"2.3 定义类属性\"></a>2.3 定义类属性</h3><pre><code class=\"line-numbers language-Swift\">    /// 0为默认，1为零售开单\n    var documentType:Int = 0\n    \n    /// 结果闭包，用自定义的闭包类型\n    var NumberResultClosure: ResultClosure?\n    \n    var decreaseBtn: UIButton!     // 减按钮\n    var increaseBtn: UIButton!     // 加按钮\n    var textField: UITextField!    // 数量展示/输入框\n    var timer: Timer!              // 快速加减定时器\n    public var _minValue = 1                 // 最小值\n    public var _maxValue = Int.max           // 最大值\n    public var shakeAnimation: Bool = false  // 是否打开抖动动画\n    \n    var decreaseBgBtn:UIButton!  //减按钮(增大可触面积)\n    var increaseBgBtn:UIButton!  //加按钮(增大可触面积)\n    \n    /// rxSwift生命的袋子\n    let bag = DisposeBag()\n</code></pre>\n<p>这里documentType是自己的业务逻辑，忽略。结果闭包2.1声明的那个类型。然后就是几个基本视图了。这里还有个timer，主要用途是长按实现持续增加数字的功能，体验会好一点。<br>最大值最小值就是步进器的最大值和最小值。<br>抖动动画，是如果已经到最大值了，用户还在按加，就弹一个动画效果。<br>然后还有两个UIButton覆盖在增加和减号的图标上面，只是为了扩大点击热区。</p>\n<h3 id=\"2-4-生命周期函数\"><a href=\"#2-4-生命周期函数\" class=\"headerlink\" title=\"2.4 生命周期函数\"></a>2.4 生命周期函数</h3><pre><code class=\"line-numbers language-Swift\">/// UIView的初始化函数，这里一般会覆写这个方法\noverride public init(frame: CGRect) &#123;\n    super.init(frame: frame)\n    \n    setupUI()\n    \n    //整个控件的默认尺寸\n    if frame.isEmpty &#123;\n        self.frame = CGRect(x: 0, y: 0, width: 110, height: 30)\n    &#125;\n    \n&#125;\n\nrequired public init?(coder aDecoder: NSCoder) &#123;\n    super.init(coder: aDecoder)\n\n&#125;\n</code></pre>\n<p>一般情况，自定义View都需要覆写下这两个init函数。用来初始化UI。</p>\n<pre><code class=\"line-numbers language-Swift\">//设置UI布局\nfileprivate func setupUI() &#123;\n    /// 背景颜色清空\n    backgroundColor = UIColor.clear\n\n    /// 加图标和热区加按钮\n    decreaseBtn = setupButton(title: &quot;reduce_available&quot;)\n    decreaseBgBtn = setupButton(title: &quot; &quot;)\n    increaseBtn = setupButton(title: &quot;increase_available&quot;)\n    increaseBgBtn = setupButton(title: &quot; &quot;)\n    \n    decreaseBtn.backgroundColor = .clear\n    increaseBtn.backgroundColor = .clear\n    //减按钮(增大可触面积)\n    decreaseBgBtn.backgroundColor = .clear\n    //加按钮(增大可触面积)\n    increaseBgBtn.backgroundColor = .clear\n    \n    /// 中间区域的编辑框\n    textField = UITextField.init()\n    textField.font = UIFont.pingFangMedium(size: 16)\n    textField.layer.borderColor = UIColor(red: 0.79, green: 0.80, blue: 0.83, alpha: 1.00).cgColor\n    textField.layer.borderWidth = 1\n    textField.backgroundColor = UIColor(red: 0.97, green: 0.97, blue: 0.99, alpha: 1.00)\n    textField.layer.cornerRadius = 8\n    textField.textColor = UIColor(hex:&quot;#3B4058&quot;)\n    textField.delegate = self\n    textField.adjustsFontSizeToFitWidth = true        //当文字超出文本框宽度时，自动调整文字大小\n    textField.minimumFontSize = 14                   //最小可缩小的字号\n    textField.keyboardType = UIKeyboardType.numberPad\n    textField.textAlignment = NSTextAlignment.center\n    self.addSubview(textField)\n&#125;\n</code></pre>\n<p>内部用了一个setupButton给按钮增加背景，看下哈：</p>\n<pre><code class=\"line-numbers language-Swift\">//设置加减按钮的公共方法 设置action\nfileprivate func setupButton(title:String) -&gt; UIButton &#123;\n    let button = UIButton.init();\n    button.setBackgroundImage(UIImage.init(named: title), for: .normal)\n    button.setTitleColor(UIColor.gray, for: .normal)\n    button.addTarget(self, action:#selector(self.touchDown(_:)) , for: .touchDown)\n    button.addTarget(self, action:#selector(self.touchUp) , for:.touchUpOutside)\n    button.addTarget(self, action:#selector(self.touchUp) , for:.touchUpInside)\n    button.addTarget(self, action:#selector(self.touchUp) , for:.touchCancel)\n    self.addSubview(button)\n    \n    return button;\n&#125;\n</code></pre>\n<p>这里给按钮增加了一个action，主要是处理用户行为点击加号或者减号的逻辑：</p>\n<pre><code class=\"line-numbers language-Swift\">@objc fileprivate func touchDown(_ button: UIButton) &#123;\n        textField.endEditing(false)\n        if button == decreaseBtn || button == decreaseBgBtn &#123;\n            timer = Timer.scheduledTimer(timeInterval: 0.15, target: self, selector: #selector(self.decrease), userInfo: nil, repeats: true)\n        &#125; else &#123;\n            timer = Timer.scheduledTimer(timeInterval: 0.15, target: self, selector: #selector(self.increase), userInfo: nil, repeats: true)\n        &#125;\n        timer.fire()\n    &#125;\n</code></pre>\n<p>这里给按钮添加的action的函数，都需要@objc注解，原因是swift是静态编程语言，objc是动态的，所以这里需要转换为动态效果，所以要声明这个注解，不知道我理解得对不对。</p>\n<p>这里只有点击了就去执行加或者减的逻辑，用了一个定时器，保证150ms才走一次。<br>加的逻辑看下哈：</p>\n<pre><code class=\"line-numbers language-Swift\">@objc fileprivate func increase() &#123;\n        if (textField.text?.count)! == 0 || Int(textField.text!)! &lt;= _minValue &#123;\n            textField.text = &quot;\\(_minValue)&quot;\n        &#125;\n        \n        let number = Int(textField.text!)! + 1;\n        \n        if number &lt;= _maxValue &#123;\n            textField.text = &quot;\\(number)&quot;;\n            //闭包回调\n            NumberResultClosure?(&quot;\\(number)&quot;)\n        &#125; else &#123;\n            //添加抖动动画\n            if shakeAnimation &#123;shakeAnimationFunc()&#125;\n            print(&quot;已超过最大数量\\(_maxValue)&quot;);\n            if documentType == 1 &#123;\n                MBProgressHUD.showTipsMessage(&quot;数量已超出零售上限&quot;)\n            &#125;\n        &#125;\n        /// 触发rxSwift监听处更新\n        textField.sendActions(for: .valueChanged)\n        \n        if Int(textField.text!)! &gt;= maxValue &#123;\n            decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_available&quot;), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_Disable&quot;), for: .normal)\n        &#125;else&#123;\n            decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_available&quot;), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_available&quot;), for: .normal)\n        &#125;\n    &#125;\n</code></pre>\n<p>这里主要就是最大值和最小值判断，这里有个sendActions的方法，个人不是很理解。猜测是用了RxSwift的话，内部编辑框的值变更，会通知到rx的回调处，其实也是通知外部同步刷新。</p>\n<p>减的逻辑基本一致，这里就不再看了。</p>\n<p>上面还遗漏了一个抬起手后，将定时器取消，这点很重要，如果不及时处理，很容易造成内存泄漏。看下上面给touchCancel和其它按钮状态绑定的事件：</p>\n<pre><code class=\"line-numbers language-Swift\">//松开按钮:清除定时器\n@objc fileprivate func touchUp()  &#123;\n    cleanTimer()\n&#125;\n\n/// 内部实现\nfileprivate func cleanTimer() &#123;\n        if ((timer?.isValid) != nil) &#123;\n            timer.invalidate()\n            timer = nil;\n        &#125;\n    &#125;\n    \n/// 析构函数    \ndeinit &#123;\n    cleanTimer()\n&#125;\n</code></pre>\n<p>这里还有一个非常关键的生命周期函数：</p>\n<pre><code class=\"line-numbers language-Swift\">// MARK: - 重新布局UI\n    /// https://juejin.cn/post/6984250995874365448 layoutSubviews调用时机\n    /// 改变一个UIView的Frame会触发layoutSubviews\n    /// layoutSubviews, 当我们在某个类的内部调整子视图位置时，需要调用。反过来的意思就是说：如果你想要在外部设置subviews的位置，就不要重写。\n    /// 这个方法，默认没有做任何事情，需要子类进行重写\n    /// 如果没有这个方法，那么结果会是空白的，看不到任何东西\n    override open func layoutSubviews() &#123;\n        super.layoutSubviews()\n        \n        let height = frame.size.height\n        let width = frame.size.width\n        let textFieldWidth:CGFloat = 90\n        let BgBtnWidth:CGFloat = 42\n        let btnSize:CGFloat = 28\n        decreaseBtn.frame = CGRect(x: 0, y: (height-btnSize)/2, width: btnSize, height: btnSize)\n        //减按钮(增大可触面积)\n        decreaseBgBtn.frame = CGRect(x: 0, y: 0, width: BgBtnWidth, height: height)\n        increaseBtn.frame = CGRect(x: width-btnSize, y: (height-btnSize)/2, width: btnSize, height: btnSize)\n        //加按钮(增大可触面积)\n        increaseBgBtn.frame = CGRect(x: BgBtnWidth + textFieldWidth, y: 0, width: BgBtnWidth, height: height)\n        textField.frame = CGRect(x: BgBtnWidth, y: 0, width: textFieldWidth, height: height)\n    &#125;\n</code></pre>\n<p>这个方法必须要实现，确定视图frame，才可以真正显示到屏幕上。</p>\n<h3 id=\"2-5-给TextField绑定代理\"><a href=\"#2-5-给TextField绑定代理\" class=\"headerlink\" title=\"2.5 给TextField绑定代理\"></a>2.5 给TextField绑定代理</h3><p>在前面初始化UI里面有句代码是这样的：<br><code>textField.delegate = self</code><br>这里需要新建一个代理类来支持一下：</p>\n<pre><code class=\"line-numbers language-Swift\">extension PPNumberButton: UITextFieldDelegate &#123;\n    \n    // MARK: - UITextFieldDelegate\n    public func textFieldDidEndEditing(_ textField: UITextField) &#123;\n        if (textField.text?.count)! == 0 || Int(textField.text!) ?? 999999999 &lt; _minValue &#123;\n            textField.text = &quot;\\(_minValue)&quot;\n        &#125;\n        if Int(textField.text!) ?? 999999999 &gt; _maxValue &#123;\n            if documentType == 1 &#123;\n                MBProgressHUD.showTipsMessage(&quot;数量已超出零售上限&quot;)\n            &#125;\n        &#125;\n        if Int(textField.text!) ?? 999999999 &gt;= _maxValue &#123;\n            textField.text = &quot;\\(_maxValue)&quot;\n        &#125;\n        //闭包回调，传递值给外部\n        NumberResultClosure?(&quot;\\(textField.text!)&quot;)\n        //delegate的回调，暴露内部值给外部\n//        delegate2?.numberButtonResult(self, number: &quot;\\(textField.text!)&quot;)\n        \n        print(&quot;当前值:   \\(textField.text?.int ?? 0)&quot;)\n        \n        if (textField.text?.int ?? 0) &lt;= 0 &#123;\n            decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_Disable&quot;), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_available&quot;), for: .normal)\n        &#125;else if (textField.text?.int ?? 0) &gt;= maxValue &#123;\n            decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_available&quot;), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_Disable&quot;), for: .normal)\n        &#125;else&#123;\n            decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_available&quot;), for: .normal)\n            increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_available&quot;), for: .normal)\n        &#125;\n    &#125;\n    \n    public func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -&gt; Bool &#123;\n        \n        if range.location &lt;= 8 &#123;\n            return true\n        &#125;else&#123;\n            return false\n        &#125;\n    &#125;\n    \n&#125;\n</code></pre>\n<p>这里重写了官方文本代理的两个函数：<br>· textFieldDidEndEditing 结束编辑调用<br>· textField 实时调用，能否显示</p>\n<h3 id=\"2-6-自定义扩展函数\"><a href=\"#2-6-自定义扩展函数\" class=\"headerlink\" title=\"2.6 自定义扩展函数\"></a>2.6 自定义扩展函数</h3><p>原因是每个地方使用场景不同，这里需要通过扩展函数，可以自己添加一些逻辑，方便调用处能够实现效果。</p>\n<pre><code class=\"line-numbers language-Swift\">public extension PPNumberButton &#123;\n    \n    /**\n     输入框中的内容\n     */\n    var currentNumber: String? &#123;\n        get &#123;\n            return (textField.text!)\n        &#125;\n        set &#123;\n            textField.text = newValue\n            if isUserInteractionEnabled &#123;\n                if (newValue?.int ?? 0) &lt;= 0 &#123;\n                    decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_Disable&quot;), for: .normal)\n                    increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_available&quot;), for: .normal)\n                &#125; else if (newValue?.int ?? 0) &gt;= maxValue &#123;\n                    decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_available&quot;), for: .normal)\n                    increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_Disable&quot;), for: .normal)\n                &#125;else&#123;\n                    decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_available&quot;), for: .normal)\n                    increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_available&quot;), for: .normal)\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    /**\n     设置最小值\n     */\n    var minValue: Int &#123;\n        get &#123;\n            return _minValue\n        &#125;\n        set &#123;\n            _minValue = newValue\n            textField.text = &quot;\\(newValue)&quot;\n        &#125;\n    &#125;\n    /**\n     设置最大值\n     */\n    var maxValue: Int &#123;\n        get &#123;\n            return _maxValue\n        &#125;\n        set &#123;\n            _maxValue = newValue\n        &#125;\n    &#125;\n    \n    /**\n     * 加减按钮的响应闭包回调\n     * 当数字变化后，暴露给外部，执行自己逻辑\n     */\n    func numberResult(_ finished: @escaping ResultClosure) &#123;\n        NumberResultClosure = finished\n    &#125;\n    \n    /**\n     输入框中的字体属性\n     */\n    func inputFieldFont(_ inputFieldFont: UIFont) &#123;\n        textField.font = inputFieldFont;\n    &#125;\n    \n    /**\n     加减按钮的字体属性\n     */\n    func buttonTitleFont(_ buttonTitleFont: UIFont) &#123;\n        increaseBtn.titleLabel!.font = buttonTitleFont;\n        decreaseBtn.titleLabel!.font = buttonTitleFont;\n    &#125;\n    \n    /**\n     设置按钮的边框颜色\n     */\n    func borderColor(_ borderColor: UIColor) &#123;\n//        layer.borderColor = borderColor.cgColor;\n        decreaseBtn.layer.borderColor = borderColor.cgColor;\n        increaseBtn.layer.borderColor = borderColor.cgColor;\n        \n//        layer.borderWidth = 0.5;\n        decreaseBtn.layer.borderWidth = 0.5;\n        increaseBtn.layer.borderWidth = 0.5;\n    &#125;\n    \n    //注意:加减号按钮的标题和背景图片只能设置其中一个,若全部设置,则以最后设置的类型为准\n    \n    /**\n     设置加/减按钮的标题\n     \n     - parameter decreaseTitle: 减按钮标题\n     - parameter increaseTitle: 加按钮标题\n     */\n    func setTitle(decreaseTitle: String, increaseTitle: String) &#123;\n        decreaseBtn.setBackgroundImage(nil, for: .normal)\n        increaseBtn.setBackgroundImage(nil, for: .normal)\n        \n        decreaseBtn.setTitle(decreaseTitle, for: .normal)\n        increaseBtn.setTitle(increaseTitle, for: .normal)\n    &#125;\n    \n    /**\n     设置加/减按钮的背景图片\n     \n     - parameter decreaseImage: 减按钮背景图片\n     - parameter increaseImage: 加按钮背景图片\n     */\n    func setImage(decreaseImage: UIImage, increaseImage: UIImage) &#123;\n        decreaseBtn.setTitle(nil, for: .normal)\n        increaseBtn.setTitle(nil, for: .normal)\n        \n        decreaseBtn.setBackgroundImage(decreaseImage, for: .normal)\n        increaseBtn.setBackgroundImage(increaseImage, for: .normal)\n    &#125;\n    \n&#125;\n</code></pre>\n<p>这些都是暴露给外部调用者的函数，外部可以轻松改变背景，改变边框颜色等。</p>\n<pre><code class=\"line-numbers language-Swift\">public extension PPNumberButton &#123;\n    \n    /// 是否开启交互 这里主要是设置能否点击，业务需求是某些情况没有超过最大值或低于最小值也不可点击哦\n    var enabled: Bool &#123;\n        get &#123;\n            return isUserInteractionEnabled\n        &#125;\n        set &#123;\n            isUserInteractionEnabled = newValue\n            if isUserInteractionEnabled &#123;\n                let text = textField.text\n                currentNumber = text\n            &#125; else &#123;\n                decreaseBtn.setBackgroundImage(UIImage.init(named: &quot;reduce_Disable&quot;), for: .normal)\n                increaseBtn.setBackgroundImage(UIImage.init(named: &quot;increase_Disable&quot;), for: .normal)\n            &#125;\n        &#125;\n    &#125;\n    \n&#125;\n</code></pre>\n<p>上面的代码也是因为增加了 特殊需求，添加的一个扩展方法。</p>\n<p>另外还有一部分代码是使用RxSwift，增加了扩展方法，看下哈：</p>\n<pre><code class=\"line-numbers language-Swift\">extension Reactive where Base: PPNumberButton &#123;\n    var gmMaxValue: Binder&lt;Int&gt; &#123;\n        return Binder(self.base) &#123; (pp, max) in\n            pp.maxValue = max\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里应该是获取最大值，pp指代这个步进器，max就是最大值。</p>\n<h3 id=\"2-7-调用者如何使用\"><a href=\"#2-7-调用者如何使用\" class=\"headerlink\" title=\"2.7 调用者如何使用\"></a>2.7 调用者如何使用</h3><p>上面基本就把步进器实现完了。<br>下面看看调用者如何来使用步进器，这里简单示例下：</p>\n<p>先声明一个步进器</p>\n<pre><code class=\"line-numbers language-Swift\">private weak var cus_stepper: PPNumberButton!\n</code></pre>\n<p>然后目标地方创建一个步进器，并且初始化步进器相关属性</p>\n<pre><code class=\"line-numbers language-Swift\">let stepperViewW: CGFloat = 178.0\nlet stepperViewH: CGFloat = 40.0\nlet stepperViewB: CGFloat = 24.0\n\n/// 创建步进器并初始化\nlet cus_stepper = PPNumberButton()\ncus_stepper.shakeAnimation = true\ncus_stepper.maxValue = 999999999\ncus_stepper.minValue = 0\n\n/// 暴露回调给外部，里面就是自己逻辑了\ncus_stepper.numberResult &#123; [weak self] number in\n    guard let self = self else &#123; return &#125;\n    self.act_stepperCountChnage(number)\n&#125;\n\n/// 添加到目标contentView里面\ncontentView.addSubview(cus_stepper)\nself.cus_stepper = cus_stepper\n\n/// 布局设置\ncus_stepper.snp.makeConstraints &#123; make in\n    make.top.equalTo(imgV_photo.snp.bottom).offset(ySuperVerPad)\n    make.right.equalTo(contentView).offset(-ySuperHorPad)\n    make.width.equalTo(stepperViewW)\n    make.height.equalTo(stepperViewH)\n&#125;\n\ncus_stepper.snp.makeConstraints &#123; make in\n    make.bottom.equalTo(contentView).offset(-stepperViewB)\n&#125;\n</code></pre>\n<p>基本就这样。</p>\n<h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3 总结\"></a>3 总结</h2><p>1.自定义View需要先分析下交互，确定下如何拆分这个自定义View，再复杂的视图都是一块砖一块瓦拼接起来的，其实这个步进器就3个结构，左右图标，中间编辑框。<br>2.iOS自定义View一般都是继承UIView，重写两个init函数，layoutSubviews这个方法确定视图frame，才能显示到屏幕上。<br>3.给UIButton添加action一定要用@objc注解，表示可以使用动态方法。<br>4.对于封装自定义View一定要严格将某些方法暴露出去，某些方法私有，因为调用者不知道具体细节，所以封装者就一定要注意扩展性，一方面提供好用的扩展方法出去，能够方便调用者去设置各种属性，另一方面要注意类安全性，以及解耦性，尽量不要跟数据太耦合了。</p>\n"},{"title":"iOS-swift-自定义View之时间选择器","date":"2023-01-28T01:56:57.000Z","top":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 需求分析\n当我们选择购买一个东西时，有时需要预约发货，这时候需要用户手动选择某一天某一个时间，ui给的方案是这样的：\n预约日期：\n<img src=%E9%A2%84%E7%BA%A6%E6%97%A5%E6%9C%9F.png>\n\n预约时间：\n<img src=%E9%A2%84%E7%BA%A6%E6%97%B6%E9%97%B4.png>\n这里是间隔了2个小时一个时间。\n\n可以看到这个日期是以日历形式展现，可以选择未来某个日期；时间是以滚轮的方式展现，可以上下滑动到目标时间点。\n\n对于这个需求，我们要如何实现呢？‘\n\n答案当然是自定义View了。\n\n## 2 结构分析\n显而易见，这个因为设计到分页，我们可以考虑分页区域使用一个UIScrollView，水平滑动，宽度设置为屏幕的2倍，一半用来展示日历，一半用来展示预约时间的UIPickerView。\n\n所以需要我们自定义一个UIView，这里面先绘制顶部分割线，再绘制标题，“预约日期”和“预约时间”和“取消”的文案。\n\n然后是一个显示日历操作栏，包括左右箭头和中间的月份显示，这个要放到UIScrollView的左半边，包括星期视图和日历的UICollectionView的集合View，这里日历我们采用这个集合View很容易实现的。\n\n然后右侧就是一个UIPickerView,这个系统封装好了，使用很方便，我们主要负责填充数据。\n\n那这个结构大体出来了，一个是整个自定义View，暂且把它叫做CalenderView，还有一个就是日历内部的Cell，暂且叫做CalenderCell。\n\n## 3 撸下CalenderView\n\n### 3.1 全局变量\n\n```Swift\nclass CalendarView: UIView {\n    \n    /// 传出去给调用者\n    typealias DoneBlock = (TimeModel)->()\n    var doneHandle: DoneBlock!\n    \n    // 当月日期Model\n    var modelArr: [TimeModel] = []\n    \n    // 动态调整上下月的时间变量\n    var dynamicDate = Date()\n    \n    //默认选中的日期\n    var timeModel: TimeModel = TimeModel()\n    \n    //时间时短数据\n    static let range: String = \"                      \"\n    private var timeArr: [String] = [\"08:00\\(range)10:00\",\n                                   \"10:00\\(range)12:00\",\n                                   \"12:00\\(range)14:00\",\n                                   \"14:00\\(range)16:00\",\n                                   \"16:00\\(range)18:00\",\n                                   \"18:00\\(range)20:00\",\n                                   \"20:00\\(range)22:00\"]\n    private var selectIndex = 0\n    \n```\n这里定义了一个闭包返回，主要是用户选择后，回调给外部。\n\n然后有一个TimeModel的数组， 也就是填充我们的日历视图。\n\ntimeModel是我们选择的日期，会高亮显示。\n\ntimeArr是我们右侧使用的UIPickerView要用的数据。\n\n### 3.2 UI定义\n\n这里我们大致会用到这些视图。\n```Swift\n//白色背景底 整个半屏的视图\nprivate lazy var acView: UIView = {\n    let view = UIView()\n    view.backgroundColor = .white\n    return view\n}()\n\n//选中条\nprivate lazy var lineView: UIView = {\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: \"#409EFF\")\n    return view\n}()\n\n/// 预约日期按钮\nprivate lazy var dateBtn: UIButton = {\n    let btn = UIButton()\n    btn.setTitle(\"预约日期\", for: .normal)\n    btn.titleFont = .pingFangMedium(size: 16)\n    btn.setTitleColor(UIColor.lightGray, for: .normal)\n    btn.setTitleColor(UIColor.black, for: .selected)\n    btn.addTarget(self, action: #selector(actionForChooseDate), for: .touchUpInside)\n    btn.isSelected = true\n    return btn\n}()\n\n/// 预约时间按钮\nprivate lazy var timeBtn: UIButton = {\n    let btn = UIButton()\n    btn.setTitle(\"预约时间\", for: .normal)\n    btn.titleFont = .pingFangMedium(size: 16)\n    btn.setTitleColor(UIColor.lightGray, for: .normal)\n    btn.setTitleColor(UIColor.black, for: .selected)\n    btn.addTarget(self, action: #selector(actionForChooseTime), for: .touchUpInside)\n    return btn\n}()\n\n/// 取消按钮\nprivate lazy var cancelBtn: UIButton = {\n    let btn = UIButton()\n    btn.setTitle(\"取消\", for: .normal)\n    btn.setTitleColor(UIColor.init(hex: \"#409EFF\"), for: .normal)\n    btn.titleFont = .pingFangRegular(size: 16)\n    btn.addTarget(self, action: #selector(actionForCancel), for: .touchUpInside)\n    return btn\n}()\n\n//日历工具条\nprivate lazy var dateToolView: UIView = {\n    let view = UIView()\n    return view\n}()\n\n//日历工具条显示当前月份标签\nprivate lazy var monthLb: UILabel = {\n    let lab = UILabel()\n    lab.font = .pingFangMedium(size: 16)\n    lab.textColor = UIColor.init(hex: \"#3B4058\")\n    lab.text = \"\"\n    lab.textAlignment = .center\n    return lab\n}()\n\n//日历工具条左箭头\nprivate lazy var toolLeftBtn: UIButton = {\n    let btn = UIButton()\n    btn.setImage(UIImage.init(named: \"日历_左箭头\"), for: .normal)\n    btn.addTarget(self, action: #selector(actionForLeftEvent), for: .touchUpInside)\n    btn.isHidden = true\n    return btn\n}()\n\n//日历工具条右箭头\nprivate lazy var toolRightBtn: UIButton =  {\n    let btn = UIButton()\n    btn.setImage(UIImage.init(named: \"日历_右箭头\"), for: .normal)\n    btn.addTarget(self, action: #selector(actionForRightEvent), for: .touchUpInside)\n    return btn\n}()\n\n//星期X显示条\nprivate lazy var weeksView: UIView = {\n    let view = UIView()\n    view.backgroundColor = .white\n    view.layer.shadowColor = UIColor.init(hex: \"#7D7E80\").cgColor\n    view.layer.shadowOffset = CGSize.init(width: 0, height: 2)\n    view.layer.shadowRadius = 10\n    view.layer.shadowOpacity = 0.16\n    return view\n}()\n\n//滚动视图 左右滚动\nprivate lazy var scrollView: UIScrollView = {\n    let _scrollView = UIScrollView()\n    _scrollView.contentSize = CGSize.init(width: ScreenWidth*2, height: _scrollView.size.height)\n    _scrollView.bounces = false\n    _scrollView.isScrollEnabled = true\n    _scrollView.isPagingEnabled = true\n    _scrollView.showsVerticalScrollIndicator = false\n    _scrollView.showsHorizontalScrollIndicator = false\n    return _scrollView\n}()\n\n//月份水印背景\nprivate lazy var watermarkView: CalendarWatermark = {\n    let view = CalendarWatermark()\n    view.backgroundColor = .white\n    view.isHidden = true  //当前版本隐藏水印\n    return view\n}()\n\n//日历展示表\n    private lazy var collectionView: UICollectionView = {\n        let layout = UICollectionViewFlowLayout()\n        layout.scrollDirection = .vertical\n        let collection = UICollectionView(frame: CGRect.init(x: 0, y: 34+40, width: ScreenWidth, height: ScreenHeight*0.57*0.57), collectionViewLayout: layout)\n        collection.backgroundColor = .clear\n        collection.delegate = self\n        collection.dataSource = self\n        collection.isPagingEnabled = true\n        collection.showsHorizontalScrollIndicator = false\n        collection.bounces = false\n        collection.register(CalendarCell.self, forCellWithReuseIdentifier: CalendarCell.identifier)\n        return collection\n}()\n\n//时间选择器 x轴以 屏幕宽度为起点，刚好在第二屏了\nprivate lazy var pickerView: UIPickerView = {\n    let picker = UIPickerView.init(frame: CGRect.init(x: ScreenWidth, y: 0, width: ScreenWidth, height: ScreenHeight*0.57*0.57+34+40))\n    picker.delegate = self\n    picker.dataSource = self\n    return picker\n}()\n```\n\n这些需要用代理和数据源的都设置self，后面再具体实现。\n\n这里可以认为是我们搭建房子用到的一些素材。先写好，后期再拼接下。\n\n### 3.3 生命周期函数\n\n初始化看下，应该要先设置一个蒙层。\n```Swift\noverride init(frame: CGRect){\n        super.init(frame: frame)\n        /// 这里应该是蒙层\n        self.backgroundColor = UIColor.init(r: 100, g: 1, b: 1, a: 0.3)\n        self.alpha = 0\n        \n        let lastDyaDate = YSDateTool.lastDay()\n        let com = YSDateTool.currentDateCom(date: lastDyaDate)\n        watermarkView.monthStr = \"\\(com.month!)\"\n    }\n    \n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n```\n确实如此，这里就只加了个颜色。\n\n### 3.4 定义方法，展示和隐藏选择器\n\n```Swift\nextension CalendarView{\n    /// 显示弹窗\n    public func showAlertView() {\n        let str = \"\\(timeModel.startTime)\\(CalendarView.range)\\(timeModel.endTime)\"\n        selectIndex = timeArr.firstIndex(of:str) ?? 0\n        let timeStr = \"\\(timeModel.year)-\\(timeModel.month)-\\(timeModel.day)\"\n        let date = YSDateTool.dateStringToDate(timeStr)\n        self.setDate(date: date)\n        self.setUI()\n        pickerView.selectRow(selectIndex, inComponent: 0, animated: false)\n        UIView.animate(withDuration: 0.25) {\n            self.alpha = 1\n        }\n    }\n\n    /// 隐藏弹窗\n    public func dismissAlertView() {\n        self.animate(duration: 0.25) {\n            self.alpha = 0\n        } completion: { finish in\n            self.removeFromSuperview()\n        }\n    }\n}\n```\n这个方法很重要，主要提供给外部使用，这里帮助外部设置数据，因为外部调用者可能不知道内部细节，所以我们最好在这个类里面实现展示弹框的方法。\n\n### 3.5 设置初始化日期\n\n外部可能有选择好的日期，所以我们必须提供一个方法，设置数据。\n```Swift\nextension CalendarView{\n    /// 按照这个date获取这个月的数据\n    func setDate(date: Date = Date()){\n        modelArr.removeAll()\n        let count = YSDateTool.countOfDaysInCurrentMonth(date: date)    //当月天数\n        for i in 0..<count{\n            let model = self.initializeModel(date: date, day: i+1)\n            modelArr.append(model)\n        }\n        let firstWeekDay = YSDateTool.firstWeekDayInCurrentMonth(date: date)    //当月第一天周几\n        \n        //头部空缺数据填充 插入一个空的model\n        if firstWeekDay != 7 {\n            for _ in 0 ..< firstWeekDay{\n                let model = self.initializeModel(date: date, day: 0)\n                modelArr.insert(model, at: 0)\n            }\n        }\n        //尾部空缺数据填充,插入一个空的model\n        if modelArr.count < 35{\n            for _ in modelArr.count ..< 35{\n                let model = self.initializeModel(date: date, day: 0)\n                modelArr.append(model)\n            }\n        }\n        \n        collectionView.reloadData()\n    }\n    \n    /// 初始化数据，返回\n    func initializeModel(date: Date, day: Int)->TimeModel{\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        let model = TimeModel()\n        model.year = com.year!\n        model.month = com.month!\n        model.day = day\n        \n        // model指代当前时间\n        let monthStr = com.month! < 10 ? \"0\\(model.month)\" : \"\\(model.month)\"\n        let dayStr = com.day! < 10 ? \"0\\(model.day)\" : \"\\(model.day)\"\n        model.dateStr = \"\\(com.year!)-\\(monthStr)-\\(dayStr)\"\n        return model\n    }\n}\n```\n这里也搞了2个扩展函数，会根据目标日期，获取到该日期的一个月的数据，然后会填充第一天非星期天的情况的数据，也会填最后几天空白区域的数据。\n\n### 3.6 设置UI\n\n有了日期就可以设置UI了，所以我们看下如何填充视图的。\n\n```Swift\nextension CalendarView {\n    func setUI() {\n        \n        //日历顶部按钮布局\n        self.addSubview(acView)\n        acView.snp.makeConstraints{make in\n            make.leading.trailing.bottom.equalTo(0)\n            make.height.equalTo(ScreenHeight*0.57)\n        }\n        \n        // 加顶部横线 左上角默认位置\n        acView.addSubview(lineView)\n        self.lineViewLayout()\n        \n        // 加预约日期\n        acView.addSubview(dateBtn)\n        dateBtn.snp.makeConstraints{make in\n            make.top.equalTo(11)\n            make.leading.equalTo(28)\n            make.width.equalTo(66)\n            make.height.equalTo(22)\n        }\n        \n        // 预约时间\n        acView.addSubview(timeBtn)\n        timeBtn.snp.makeConstraints{make in\n            make.top.equalTo(11)\n            make.centerX.equalToSuperview()\n            make.width.equalTo(66)\n            make.height.equalTo(22)\n        }\n        \n        // 加取消按钮\n        acView.addSubview(cancelBtn)\n        cancelBtn.snp.makeConstraints{make in\n            make.top.equalTo(11)\n            make.trailing.equalTo(-16)\n            make.width.equalTo(66)\n            make.height.equalTo(22)\n        }\n        \n        \n        // 继续加滚动视图\n        acView.addSubview(scrollView)\n        scrollView.snp.makeConstraints{make in\n            make.top.equalTo(dateBtn.snp.bottom).offset(10)\n            make.leading.trailing.equalToSuperview()\n            make.bottom.equalToSuperview()\n        }\n        \n        // acView添加完毕，现在到内部ScrollView层级了--------------\n    \n        // 加个集合View 集合View因为初始化确定了y轴高度，这里无需重复布局\n        scrollView.addSubview(collectionView)\n        \n        // 再加个pickerView 时间滚轮，这里直接加到ScrollView里面了，也无需布局，直接覆盖到上层的\n        scrollView.addSubview(pickerView)\n        \n        // 先加工具栏\n        scrollView.addSubview(dateToolView)\n        dateToolView.snp.makeConstraints{make in\n            make.top.leading.equalTo(0)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(40)\n        }\n        \n        // 滚动视图再加星期视图\n        scrollView.addSubview(weeksView)\n        weeksView.snp.makeConstraints{make in\n            make.top.equalTo(dateToolView.snp.bottom).offset(4)\n            make.leading.equalTo(0)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(30)\n        }\n        \n        \n        // 处理下工具栏内部布局\n        dateToolView.addSubview(monthLb)\n        monthLb.snp.makeConstraints{make in\n            make.centerY.equalToSuperview()\n            make.centerX.equalToSuperview()\n            make.width.equalTo(100)\n            make.height.equalTo(20)\n        }\n        \n        // 日历工具条加左按钮\n        dateToolView.addSubview(toolLeftBtn)\n        toolLeftBtn.snp.makeConstraints{make in\n            make.centerY.equalToSuperview()\n            make.width.height.equalTo(40)\n            make.leading.equalTo(16)\n        }\n\n        // 日历工具条加右侧箭头\n        dateToolView.addSubview(toolRightBtn)\n        toolRightBtn.snp.makeConstraints{make in\n            make.centerY.equalToSuperview()\n            make.width.height.equalTo(40)\n            make.trailing.equalTo(-16)\n        }\n        \n        // 设置星期几内部布局\n        setWeekUiInner()\n        \n        // 地址底部按钮\n        addBottomUI()\n    \n    }\n```\n中规中矩，老老实实从上到下，从左到右布局。\n\n内部星期几看下如何布局的：\n```Swift\nfunc setWeekUiInner() {\n        let arr = [\"日\",\"一\",\"二\",\"三\",\"四\",\"五\",\"六\"]\n\n        for i in 0 ..< arr.count {\n            let width = ScreenWidth/7\n            let lab = UILabel()\n            lab.text = arr[i]\n            lab.textColor = UIColor.init(hex: \"#323233\")\n            lab.font = .pingFangRegular(size: 12)\n            lab.textAlignment = .center\n            weeksView.addSubview(lab)\n            lab.snp.makeConstraints{make in\n                make.leading.equalTo(width*CGFloat(i))\n                make.centerY.equalToSuperview()\n                make.width.equalTo(width)\n                make.height.equalTo(20)\n            }\n        }\n    }\n```\n\n还有底部的下一步和完成：\n```Swift\nfunc addBottomUI() {\n        let nextBtn: UIButton = UIButton.init(type: .custom)\n        nextBtn.frame = CGRect.init(x: 16, y: ScreenHeight*0.57*0.57+8+34+40, width: (ScreenWidth-32), height: 44)\n        nextBtn.titleFont = .pingFangMedium(size: 16)\n        nextBtn.setTitleColor(.white, for: .normal)\n        nextBtn.backgroundColor = UIColor.init(hex: \"#409EFF\")\n        nextBtn.setTitle(\"下一步\", for: .normal)\n        nextBtn.layer.cornerRadius = 22\n        nextBtn.addTarget(self, action: #selector(actionForNext), for: .touchUpInside)\n        scrollView.addSubview(nextBtn)\n        \n        let doneBtn: UIButton = UIButton.init(type: .custom)\n        doneBtn.frame = CGRect.init(x: ScreenWidth+16, y: ScreenHeight*0.57*0.57+8+34+40, width: (ScreenWidth-32), height: 44)\n        doneBtn.titleFont = .pingFangMedium(size: 16)\n        doneBtn.setTitleColor(.white, for: .normal)\n        doneBtn.backgroundColor = UIColor.init(hex: \"#409EFF\")\n        doneBtn.setTitle(\"完成\", for: .normal)\n        doneBtn.layer.cornerRadius = 22\n        doneBtn.addTarget(self, action: #selector(actionForDone), for: .touchUpInside)\n        scrollView.addSubview(doneBtn)\n    }\n```\n\n### 3.7 填充数据\n\n这里先看下日历数据如何使用代理和数据源的：\n```Swift\nextension CalendarView: UICollectionViewDelegate,UICollectionViewDataSource,UICollectionViewDelegateFlowLayout{\n    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {\n        return modelArr.count\n    }\n    \n    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: CalendarCell.identifier, for: indexPath) as! CalendarCell\n        cell.model = modelArr[indexPath.item]\n        cell.selectedModel = timeModel\n        return cell\n    }\n\n    // 定义每个Cell的大小\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {\n        let width = ScreenWidth/7\n        let height = modelArr.count > 35 ? (ScreenHeight*0.57*0.57)/6 : (ScreenHeight*0.57*0.57)/5\n        return CGSize(width: width-2, height: height-1)\n    }\n    \n    // 定义每个Section的四边间距\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -> UIEdgeInsets {\n        return UIEdgeInsets(top: 0, left: 3.5, bottom: 0, right: 0)\n    }\n    \n    // 这个是两行cell之间的间距（上下行cell的间距）\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -> CGFloat {\n        return 1.0\n    }\n    \n    // 两个cell之间的间距（同一行的cell的间距）\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Int) -> CGFloat {\n        return 1.0\n    }\n    \n    // 选中某个ietm\n    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {\n        let model = modelArr[indexPath.item]\n        let com = YSDateTool.currentDateCom()\n        if com.year == model.year && com.month == model.month && model.day <= com.day! || model.day == 0{\n            return\n        }\n\n        timeModel.year = model.year\n        timeModel.month = model.month\n        timeModel.day = model.day\n        collectionView.reloadData()\n    }\n}\n```\n主要逻辑委托给Cell来实现了。后面再看下。\n\n### 3.8 UIPickerView数据填充\n\n然后看下预约时间如何填充数据的。\n```Swift\nextension CalendarView:UIPickerViewDelegate,UIPickerViewDataSource {\n\n    func numberOfComponents(in pickerView: UIPickerView) -> Int {\n        return 1\n    }\n    \n    func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -> Int {\n        return timeArr.count\n    }\n\n    func pickerView(_ pickerView: UIPickerView, widthForComponent component: Int) -> CGFloat {\n        return ScreenWidth\n    }\n    \n    func pickerView(_ pickerView: UIPickerView, rowHeightForComponent component: Int) -> CGFloat {\n        44\n    }\n    \n    func pickerView(_ pickerView: UIPickerView, viewForRow row: Int, forComponent component: Int, reusing view: UIView?) -> UIView {\n        \n        //设置分割线 pickerView的subvews的第二个一般用来做分割线 subviews会有2个view\n        for view in pickerView.subviews {\n            print(\"view.height=\\(view.size.height) 长度为：\\(pickerView.subviews.count)\")\n            if view.size.height <= 50 {\n                view.backgroundColor = .clear\n                //自定义分割线\n                let toplayer = CALayer()\n                toplayer.frame = CGRect.init(x: 0, y: 0, width: ScreenWidth, height: 1)\n                toplayer.backgroundColor = UIColor.init(hex: \"#EBEDF0\").cgColor\n                view.layer.addSublayer(toplayer)\n\n                let bottomlayer = CALayer()\n                bottomlayer.frame = CGRect.init(x: 0, y: 44-1, width: ScreenWidth, height: 1)\n                bottomlayer.backgroundColor = UIColor.init(hex: \"#EBEDF0\").cgColor\n                view.layer.addSublayer(bottomlayer)\n               \n            }else{\n                view.backgroundColor = .clear\n            }\n        }\n        \n        //设置内容样式\n        var label = view as? UILabel\n        if label == nil {\n            label = UILabel.init()\n            label?.backgroundColor = .clear\n            label?.frame = CGRect.init(x: 0, y: 0, width:ScreenWidth, height:44)\n        }\n        if row == selectIndex {\n            label?.textColor = UIColor.init(hex: \"#409EFF\")\n        }else{\n            label?.textColor = UIColor.init(hex: \"#3B4058\")\n        }\n        label?.textAlignment = .center\n        label?.font = .pingFangRegular(size: 16)\n        //label?.minimumScaleFactor = 0.5\n        //label?.adjustsFontSizeToFitWidth = true\n        label?.text = timeArr[row]\n        return label!\n    }\n    \n    func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) {\n        selectIndex = row\n        pickerView.reloadAllComponents()\n    }\n}\n```\n主要逻辑是viewForRow覆写的方法里面。\n交代了如何绘制分割线和选中高亮显示。\n这里有个点要注意，这个分割线用到了 UIPickerView的subViews，这里通常设置分割线都要用到这个东西，具体细节我不是很清楚，预测这个subViews第二个就是居中的item。第一个item很长，不能用来分割线。\n\n然后就是didSelectRow用来响应用户点击事件，需要刷新下components。\n\n### 3.9 交互事件\n\n这里交互事件统一用一个扩展类来实现。\n```Swift\nextension CalendarView {\n    \n    @objc func actionForChooseDate(){\n        self.lineViewLayout()\n        self.scrollDate()\n    }\n    \n    @objc func actionForChooseTime(){\n        self.lineViewLayout(leading: 1)\n        self.scrollTime()\n    }\n    \n    @objc func actionForCancel(){\n        self.dismissAlertView()\n    }\n    \n    @objc func actionForLeftEvent(){\n        dynamicDate = YSDateTool.lastMonth(date: dynamicDate)\n        self.isRefrenshMonth()\n    }\n    \n    @objc func actionForRightEvent(){\n        dynamicDate = YSDateTool.nextMonth(date: dynamicDate)\n        self.isRefrenshMonth()\n    }\n    \n    @objc func actionForNext(){\n        self.lineViewLayout(leading: 1)\n        self.scrollTime()\n    }\n    \n    @objc func actionForDone(){\n        if doneHandle != nil {\n            let str = timeArr[selectIndex]\n            let arr = str.components(separatedBy: CalendarView.range)\n            timeModel.startTime = arr[0]\n            timeModel.endTime = arr[1]\n            \n            let monthStr = timeModel.month < 10 ? \"0\\(timeModel.month)\" : \"\\(timeModel.month)\"\n            let dayStr = timeModel.day < 10 ? \"0\\(timeModel.day)\" : \"\\(timeModel.day)\"\n            timeModel.dateStr = \"\\(timeModel.year)-\\(monthStr)-\\(dayStr)\"\n            \n            doneHandle(timeModel)\n        }\n        self.dismissAlertView()\n    }\n    \n    // 滑动到日期\n    func scrollDate(){\n        dateBtn.isSelected = true\n        timeBtn.isSelected = false\n        scrollView.setContentOffset(CGPoint.init(x: 0, y: 0), animated: true)\n    }\n    \n    // 滑动到时间\n    func scrollTime(){\n        dateBtn.isSelected = false\n        timeBtn.isSelected = true\n        scrollView.setContentOffset(CGPoint.init(x: ScreenWidth, y: 0), animated: true)\n    }\n    \n    func isRefrenshMonth(){\n        self.setDate(date: dynamicDate)\n        let com = YSDateTool.currentDateCom(date: dynamicDate)\n        monthLb.text = \"\\(com.year!)年\\(com.month!)月\"\n        watermarkView.monthStr = \"\\(com.month!)\"\n        \n        let currentCom = YSDateTool.currentDateCom()\n        if (com.year! == currentCom.year!  && com.month! > currentCom.month!) || (com.year! > currentCom.year!){\n            toolLeftBtn.isHidden = false\n        }else{\n            toolLeftBtn.isHidden = true\n        }\n    }\n    \n    func lineViewLayout(leading: Int = 0){\n        lineView.snp.remakeConstraints{make in\n            make.top.equalTo(0)\n            if leading == 0 {\n                make.leading.equalTo(leading)\n            }else{\n                make.centerX.equalToSuperview() // 居中了\n            }\n            make.width.equalTo(66+56) // 宽度\n            make.height.equalTo(2)  // 高度\n        }\n    }\n}\n```\n\n## 4 撸下时间工具\n\n这个只是个单纯工具，不必重复造轮子。\n```Swift\nclass YSDateTool {\n    // MARK: - 当前时间组件\n    static func currentDateCom(date: Date = Date()) -> DateComponents{\n        let calendar = Calendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com\n    }\n    // MARK: - 今年\n    static func currentYear(date: Date = Date()) -> Int {\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com.year!\n    }\n  \n    // MARK: - 今月\n    static func currentMonth(date: Date = Date()) -> Int {\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com.month!\n    }\n  \n    // MARK: - 今日\n    static func currentDay(date: Date = Date()) -> Int {\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com.day!\n    }\n    \n    // MARK: - 今天星期几\n    static func currentWeekDay(date: Date = Date()) -> Int {\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.weekday], from: date)\n        return com.weekday!\n    }\n    \n    // MARK: - 农历今年\n    static func currentChineseYear(date: Date = Date()) -> String {\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.year], from: date)\n        return numberToChina(yearNum: (com?.year)!) + \"年\"\n    }\n    \n    // MARK: - 农历今月\n    static func currentChineseMonth(date: Date = Date()) -> String {\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.month], from: date)\n        return numberToChina(monthNum: (com?.month)!)\n    }\n\n    // MARK: - 农历今日\n    static func currentChineseDay(date: Date = Date()) -> String {\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.day], from: date)\n        return numberToChina(dayNum: (com?.day)!)\n    }\n    \n    // MARK: - 农历今日\n    static func currentChineseDayInt(date: Date = Date()) -> Int {\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.day], from: date)\n        return (com?.day)!\n    }\n    \n    // MARK: - 农历星期\n    static func currentChineseWeekYear(date: Date = Date()) -> String {\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.weekday], from: date)\n        return numberToChina(weekNum: (com?.weekday)!)\n    }\n  \n    // MARK: - 下个月\n    static func nextMonth(date: Date = Date()) -> Date {\n        let calendar = NSCalendar.current\n        let nDate = calendar.date(byAdding: DateComponents(month: 1), to: date)\n        return nDate!\n    }\n    \n    // MARK: - 上个月\n    static func lastMonth(date: Date = Date()) -> Date {\n        let calendar = NSCalendar.current\n        let lDate = calendar.date(byAdding: DateComponents(month: -1), to: date)\n        return lDate!\n    }\n    \n    // MARK: - 下一天\n    static func lastDay(date: Date = Date()) -> Date{\n        let calendar = NSCalendar.current\n        let lDate = calendar.date(byAdding: DateComponents(day: 1), to: date)\n        return lDate!\n    }\n  \n    // MARK: - 本月天数\n    static func countOfDaysInCurrentMonth(date: Date = Date()) -> Int {\n        let calendar = Calendar(identifier: Calendar.Identifier.gregorian)\n        let range = (calendar as NSCalendar?)?.range(of: NSCalendar.Unit.day, in: NSCalendar.Unit.month, for: date)\n        return (range?.length)!\n    }\n \n    // MARK: - 当月第一天是星期几\n    static func firstWeekDayInCurrentMonth(date: Date = Date()) -> Int {\n        // 星期和数字一一对应 星期日：7\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = \"yyyy-MM\"\n        let date = dateFormatter.date(from: String(date.xj.year)+\"-\"+String(date.xj.month))\n        let calender = Calendar(identifier: Calendar.Identifier.gregorian)\n        let comps = (calender as NSCalendar?)?.components(NSCalendar.Unit.weekday, from: date!)\n        var week = comps?.weekday\n        if week == 1 {\n            week = 8\n        }\n        return week! - 1\n    }\n\n    // MARK: - - 获取指定日期各种值\n    // 根据年月得到某月天数\n    static func getCountOfDaysInMonth(year: Int, month: Int) -> Int{\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = \"yyyy-MM\"\n        let date = dateFormatter.date(from: String(year)+\"-\"+String(month))\n        let calendar = Calendar(identifier: Calendar.Identifier.gregorian)\n        let range = (calendar as NSCalendar?)?.range(of: NSCalendar.Unit.day, in: NSCalendar.Unit.month, for: date!)\n        return (range?.length)!\n    }\n    \n    // MARK: - 根据年月得到某月第一天是周几\n    static func getfirstWeekDayInMonth(year: Int, month: Int) -> Int{\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = \"yyyy-MM\"\n        let date = dateFormatter.date(from: String(year)+\"-\"+String(month))\n        let calendar = Calendar(identifier: Calendar.Identifier.gregorian)\n        let comps = (calendar as NSCalendar?)?.components(NSCalendar.Unit.weekday, from: date!)\n        let week = comps?.weekday\n        return week! - 1\n    }\n\n    // MARK: - date转日期字符串\n    static func dateToDateString(_ date: Date, dateFormat: String) -> String {\n        let timeZone = NSTimeZone.default\n        let formatter = DateFormatter()\n        formatter.timeZone = timeZone\n        formatter.dateFormat = dateFormat\n        let date = formatter.string(from: date)\n        return date\n    }\n\n    // MARK: - 日期字符串转date\n    static func dateStringToDate(_ dateStr: String) -> Date {\n        let dateFormatter = DateFormatter()\n        dateFormatter.timeZone = TimeZone(abbreviation: \"UTC+8\")\n        dateFormatter.dateFormat = \"yyyy-MM-dd\"\n        let date = dateFormatter.date(from: dateStr)\n        return date!\n    }\n    \n    // MARK: - 时间字符串转date\n    static func timeStringToDate(_ dateStr: String) -> Date {\n        let dateFormatter = DateFormatter()\n        dateFormatter.timeZone = TimeZone(abbreviation: \"UTC+8\")\n        dateFormatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n        let date = dateFormatter.date(from: dateStr)\n        return date!\n    }\n\n    // MARK: - 计算天数差\n    static func dateDifference(_ dateA: Date, from dateB: Date) -> Double {\n        let interval = dateA.timeIntervalSince(dateB)\n        return interval/86400\n    }\n\n    // MARK: - 比较时间先后\n    static func compareOneDay(oneDay: Date, withAnotherDay anotherDay: Date) -> Int {\n        let dateFormatter: DateFormatter = DateFormatter()\n        dateFormatter.dateFormat = \"yyyy-MM-dd\"\n        let oneDayStr: String = dateFormatter.string(from: oneDay)\n        let anotherDayStr: String = dateFormatter.string(from: anotherDay)\n        let dateA = dateFormatter.date(from: oneDayStr)\n        let dateB = dateFormatter.date(from: anotherDayStr)\n        let result: ComparisonResult = (dateA?.compare(dateB!))!\n        // Date1 is in the future\n        if(result == ComparisonResult.orderedDescending ) {\n            return 1\n        }\n        // Date1 is in the past\n        else if(result == ComparisonResult.orderedAscending) {\n            return 2\n        }\n            // Both dates are the same\n        else {\n            return 0\n        }\n    }\n\n    // MARK: - 时间与时间戳之间的转化\n    // 将时间转换为时间戳\n    static func stringToTimeStamp(_ stringTime: String) -> Int {\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat = \"yyyy-MM-dd HH: mm: ss\"\n        dfmatter.locale = Locale.current\n        let date = dfmatter.date(from: stringTime)\n        let dateStamp: TimeInterval = date!.timeIntervalSince1970\n        let dateSt: Int = Int(dateStamp)\n        return dateSt\n    }\n    \n    // 将时间戳转换为年月日\n    static func timeStampToString(_ timeStamp: String) -> String {\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=\"yyyy年MM月dd日\"\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    }\n    \n    // 将时间戳转换为具体时间\n    static func timeStampToStringDetail(_ timeStamp: String) -> String {\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=\"yyyy年MM月dd日HH: mm: ss\"\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    }\n    \n    // 将时间戳转换为时分秒\n    static func timeStampToHHMMSS(_ timeStamp: String) -> String {\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=\"HH: mm: ss\"\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    }\n    \n    // 将时间戳转换为时分\n    static func timeStampToHHMM(_ timeStamp: String) -> String {\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=\"HH: mm\"\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    }\n    \n    // 获取系统的当前时间戳\n    static func getStamp(date: Date = Date()) -> Int{\n        // 获取当前时间戳\n        let timeInterval: Int = Int(date.timeIntervalSince1970)\n        return timeInterval\n    }\n    \n    // 日数字转汉字\n    static func numberToChina(yearNum: Int) -> String {\n        // 以一个天干和一个地支相配，排列起来，天干在前，地支在后，天干由甲起，地支由子起，阳干对阳支，阴干对阴支（阳干不配阴支，阴干不配阳支）\n        // 就会得到六十年一周期的甲子回圈，一般称为“六十甲子”或“花甲子”\n        // 十天干： 甲（jiǎ）、乙（yǐ）、丙（bǐng）、丁（dīng）、戊（wù）、己（jǐ）、庚（gēng）、辛（xīn）、壬（rén）、癸（guǐ）\n        // 十二地支： 子（zǐ）、丑（chǒu）、寅（yín）、卯（mǎo）、辰（chén）、巳（sì）、午（wǔ）、未（wèi）、申（shēn）、酉（yǒu）、戌（xū）、亥（hài）\n        let ChinaArray = [ \"甲子\", \"乙丑\", \"丙寅\", \"丁卯\", \"戊辰\", \"己巳\", \"庚午\", \"辛未\", \"壬申\", \"癸酉\",\n                         \"甲戌\", \"乙亥\", \"丙子\", \"丁丑\", \"戊寅\", \"己卯\", \"庚辰\", \"辛己\", \"壬午\", \"癸未\",\n                         \"甲申\", \"乙酉\", \"丙戌\", \"丁亥\", \"戊子\", \"己丑\", \"庚寅\", \"辛卯\", \"壬辰\", \"癸巳\",\n                         \"甲午\", \"乙未\", \"丙申\", \"丁酉\", \"戊戌\", \"己亥\", \"庚子\", \"辛丑\", \"壬寅\", \"癸丑\",\n                         \"甲辰\", \"乙巳\", \"丙午\", \"丁未\", \"戊申\", \"己酉\", \"庚戌\", \"辛亥\", \"壬子\", \"癸丑\",\n                         \"甲寅\", \"乙卯\", \"丙辰\", \"丁巳\", \"戊午\", \"己未\", \"庚申\", \"辛酉\", \"壬戌\", \"癸亥\"]\n        let ChinaStr: String = ChinaArray[yearNum - 1]\n        return ChinaStr\n    }\n    \n    // 月份数字转汉字\n    static func numberToChina(monthNum: Int) -> String {\n        let ChinaArray = [\"一月\", \"二月\", \"三月\", \"四月\", \"五月\", \"六月\", \"七月\", \"八月\", \"九月\", \"十月\", \"十一月\", \"十二月\"]\n        let ChinaStr: String = ChinaArray[monthNum - 1]\n        return ChinaStr\n    }\n    \n    // 日数字转汉字\n    static func numberToChina(dayNum: Int) -> String {\n        let ChinaArray = [ \"初一\", \"初二\", \"初三\", \"初四\", \"初五\", \"初六\", \"初七\", \"初八\", \"初九\", \"初十\",\n                         \"十一\", \"十二\", \"十三\", \"十四\", \"十五\", \"十六\", \"十七\", \"十八\", \"十九\", \"二十\",\n                         \"廿一\", \"廿二\", \"廿三\", \"廿四\", \"廿五\", \"廿六\", \"廿七\", \"廿八\", \"廿九\", \"三十\"]\n        let ChinaStr: String = ChinaArray[dayNum - 1]\n        return ChinaStr\n    }\n      \n    // 星期数字转汉字\n    static func numberToChina(weekNum: Int) -> String {\n        let ChinaArray = [\"一月\", \"二月\", \"三月\", \"四月\", \"五月\", \"六月\", \"七月\", \"八月\", \"九月\", \"十月\", \"十一月\", \"十二月\"]\n        let ChinaStr: String = ChinaArray[weekNum - 1]\n        return ChinaStr\n    }\n    \n    // MARK: - 数字前补0\n    static func add0BeforeNumber(_ number: Int) -> String {\n        if number >= 10 {\n            return String(number)\n        }else{\n            return \"0\" + String(number)\n        }\n    }\n    \n    static func getCurrentSystemDate() -> Date{\n        let date = Date() // 获得时间对象\n        let zone = NSTimeZone.system // 获得系统的时区\n        let time = zone.secondsFromGMT(for: date)// 以秒为单位返回当前时间与系统格林尼治时间的差\n        return date.addingTimeInterval(TimeInterval(time))// 然后把差的时间加上,就是当前系统准确的时间\n    }\n    \n    static func date(_ date: String?, dateFormat: String = \"yyyy-MM-dd\") -> Date? {\n        guard let date = date else {\n            return nil\n        }\n        let dateformatter = DateFormatter()\n        dateformatter.timeZone = TimeZone.init(secondsFromGMT: 0)\n        dateformatter.dateFormat = dateFormat\n        return dateformatter.date(from: date)\n    }\n\n    // MARK: - 将时间显示为（几分钟前，几小时前，几天前）\n    static func compareCurrentTime(str: String) -> String {\n        //let currentDateStr = dateToDateString(Date(), dateFormat: \"yyyy-MM-dd hh:mm:ss\")\n        let currentDate = getCurrentSystemDate()\n        let sendTimeDate = date(str,dateFormat: \"yyyy-MM-dd HH:mm:ss\")!//self.timeStringToDate(str)\n        let sendTimeInterval = Double(getStamp(date: sendTimeDate))\n        let timeInterval = currentDate.timeIntervalSince(sendTimeDate)\n\n        var todayStr = dateToDateString(Date(), dateFormat: \"yyyy-MM-dd\")\n        todayStr = todayStr+\" 00:00\"\n        let todayTimeInterval = Double(Date().stringToSecondTimeStamp(todayStr)) ?? 0\n        let yestDayTimeInterval = Double(todayTimeInterval - 86400)\n        let nextDayTimeInterval = Double(todayTimeInterval + 86400)\n\n        var temp: Double = 0\n        var result: String = \"\"\n        if timeInterval/60 < 1 {\n            result = \"刚刚\"\n        }else if (timeInterval/60) < 60{\n            temp = timeInterval/60\n            result = \"\\(Int(temp))分钟前\"\n        }else if sendTimeInterval > todayTimeInterval && sendTimeInterval < nextDayTimeInterval{\n\n            //let interval = nextDayTimeInterval - sendTimeInterval\n            temp = timeInterval/60/60\n            result = \"\\(Int(temp))小时前\"\n        }else if sendTimeInterval > yestDayTimeInterval && sendTimeInterval < todayTimeInterval{\n            //let str = timeStampToHHMM(String.init(format: \"%d\", sendTimeInterval))\n            let timeStr = str.components(separatedBy: \" \").last ?? \"\"\n            let str = timeStr.prefix(5)\n            result = \"昨天\\(str)\"\n        }else{\n            let timeStr = str.components(separatedBy: \" \").first ?? \"\"\n            let timeArr = timeStr.components(separatedBy: \"-\")\n            if !timeArr.isEmpty {\n                result = \"\\(timeArr[0])年\\(timeArr[1])月\\(timeArr[2])日\"\n            }\n            //result = timeStampToString(String.init(format: \"%d\", sendTimeInterval))\n        }\n        \n//        else if timeInterval/(30 * 24 * 60 * 60) < 12 {\n//            temp = timeInterval/(30 * 24 * 60 * 60)\n//            result = \"\\(Int(temp))个月前\"\n//        }else{\n//            temp = timeInterval/(12 * 30 * 24 * 60 * 60)\n//            result = \"\\(Int(temp))年前\"\n//        }\n        return result\n    }\n}\n\n```\n\n## 5 撸下最后的日历Cell\n\n这个就是日历里面的item，还是相当简单的。\n\n### 5.1 全局变量\n```Swift\nclass CalendarCell: UICollectionViewCell {\n    \n    static var identifier = \"UICollectionViewCell\"\n    \n    var isGreaterThan: Bool = false     //是否取大于今天的值\n    \n    var isShowPassTime: Int = 0         //是否设定禁选\n    \n    var model:TimeModel?{\n        didSet{\n            guard let _model = model else {return}\n            if _model.day != 0 {\n                titleLab.text = \"\\(_model.day)\"\n            }else{\n                titleLab.text = \"\" // 为0，啥也不显示\n            }\n            \n            let com = YSDateTool.currentDateCom()\n            \n            // 是否是选中的日子\n            if com.year == _model.year && com.month == _model.month && com.day == _model.day {\n                titleLab.textColor = UIColor.init(hex: \"#409EFF\")\n            }else{\n                titleLab.textColor = UIColor.init(hex: \"#323233\")\n            }\n            \n            // 禁用还是可用\n            if isShowPassTime == 0 {\n                if isGreaterThan {\n                    if (com.year == _model.year && com.month == _model.month && _model.day > com.day!) || (_model.year == com.year! && _model.month > com.month!) || (_model.year > com.year!){\n                        titleLab.textColor = UIColor.init(hex: \"#C8C9CC\")\n                    }\n                }else{\n                    // 如果要大于今天，那么前面的时间就的置灰了 前一个月的点不过去，不考虑了\n                    if com.year == _model.year && com.month == _model.month && _model.day < com.day!{\n                        titleLab.textColor = UIColor.init(hex: \"#C8C9CC\")\n                    }\n                }\n            }\n        }\n    }\n    \n    // 选中的item，背景颜色高亮\n    var selectedModel: TimeModel?{\n        didSet{\n            guard let _model = selectedModel else{return}\n            if _model.year == model?.year && _model.month == model?.month && _model.day == model?.day{\n                titleLab.backgroundColor = UIColor.init(hex: \"#409EFF\")\n                titleLab.textColor = UIColor.white\n            }else{\n                titleLab.backgroundColor = UIColor.clear\n            }\n        }\n    }\n```\n比较重要的是model，表示当前时间实体类。这里监听变量改变，利用didSet实现动态改变文案效果。\n\n另外一个是selectedModel，这个是当前选中的item，会比对item是否为选中，选中样式会有所不同。\n\n### 5.2 UI子View\n\n这里只用到一个子View。\n```Swift\nvar titleLab: UILabel = {\n        let lan = UILabel()\n        lan.font = .pingFangRegular(size: 16)\n        lan.textAlignment = .center\n        lan.textColor = UIColor.init(hex: \"#323233\")\n        \n        lan.layer.cornerRadius = 4\n        lan.layer.masksToBounds = true\n        return lan\n    }()\n```\n\n### 5.3 生命周期函数\n\n```Swift\noverride init(frame: CGRect) {\n        super.init(frame: frame)\n        contentView.backgroundColor = .clear\n        contentView.addSubview(titleLab)\n        titleLab.snp.makeConstraints{make in\n            make.top.bottom.leading.trailing.equalToSuperview()\n        }\n    }\n    \n    required init?(coder aDecoder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n```\n把那个子View添加到Cell里面去了。\n\n大概就是这样子。\n\n## 6 总结\n\n* 如果UI图有那种Tab页，就可以考虑使用多种方案来实现，iOS直接用简单的Button也是可以实现的，分割线也是可以用最简单的UIView来实现，不一定要用封装好的框架，谁用挖掘机来搬小石头呢，大材小用了。\n\n* 分页效果可以使用UIScrollView来实现，把它宽度设置为屏幕的n倍，这样最有滑动可以很好控制的，不要动画也可以设置的，办法总是就很多的。\n\n* 日历效果可以用UICollectionView来实现，看着很复杂，其实很简单，主要逻辑也不复杂，控制好数据刷新就好了。UICollectionView可以实现类似网格的效果，我们只需要在Cell里面绘制一个一个Cell，空的部分，我们啥不展示就好了。\n\n* 系统的UIPickerView设置分割线很简单，利用UIPickerView下有一个subViews，这里寻找高度为item高度大小的，然后给view设置一个Layer即可。","source":"_posts/iOS-swift-自定义View之时间选择器.md","raw":"---\ntitle: iOS-swift-自定义View之时间选择器\ndate: 2023-01-28 09:56:57\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- iOS 自定义View\ncategories:\n- iOS\n---\n\n## 1 需求分析\n当我们选择购买一个东西时，有时需要预约发货，这时候需要用户手动选择某一天某一个时间，ui给的方案是这样的：\n预约日期：\n<img src=%E9%A2%84%E7%BA%A6%E6%97%A5%E6%9C%9F.png>\n\n预约时间：\n<img src=%E9%A2%84%E7%BA%A6%E6%97%B6%E9%97%B4.png>\n这里是间隔了2个小时一个时间。\n\n可以看到这个日期是以日历形式展现，可以选择未来某个日期；时间是以滚轮的方式展现，可以上下滑动到目标时间点。\n\n对于这个需求，我们要如何实现呢？‘\n\n答案当然是自定义View了。\n\n## 2 结构分析\n显而易见，这个因为设计到分页，我们可以考虑分页区域使用一个UIScrollView，水平滑动，宽度设置为屏幕的2倍，一半用来展示日历，一半用来展示预约时间的UIPickerView。\n\n所以需要我们自定义一个UIView，这里面先绘制顶部分割线，再绘制标题，“预约日期”和“预约时间”和“取消”的文案。\n\n然后是一个显示日历操作栏，包括左右箭头和中间的月份显示，这个要放到UIScrollView的左半边，包括星期视图和日历的UICollectionView的集合View，这里日历我们采用这个集合View很容易实现的。\n\n然后右侧就是一个UIPickerView,这个系统封装好了，使用很方便，我们主要负责填充数据。\n\n那这个结构大体出来了，一个是整个自定义View，暂且把它叫做CalenderView，还有一个就是日历内部的Cell，暂且叫做CalenderCell。\n\n## 3 撸下CalenderView\n\n### 3.1 全局变量\n\n```Swift\nclass CalendarView: UIView {\n    \n    /// 传出去给调用者\n    typealias DoneBlock = (TimeModel)->()\n    var doneHandle: DoneBlock!\n    \n    // 当月日期Model\n    var modelArr: [TimeModel] = []\n    \n    // 动态调整上下月的时间变量\n    var dynamicDate = Date()\n    \n    //默认选中的日期\n    var timeModel: TimeModel = TimeModel()\n    \n    //时间时短数据\n    static let range: String = \"                      \"\n    private var timeArr: [String] = [\"08:00\\(range)10:00\",\n                                   \"10:00\\(range)12:00\",\n                                   \"12:00\\(range)14:00\",\n                                   \"14:00\\(range)16:00\",\n                                   \"16:00\\(range)18:00\",\n                                   \"18:00\\(range)20:00\",\n                                   \"20:00\\(range)22:00\"]\n    private var selectIndex = 0\n    \n```\n这里定义了一个闭包返回，主要是用户选择后，回调给外部。\n\n然后有一个TimeModel的数组， 也就是填充我们的日历视图。\n\ntimeModel是我们选择的日期，会高亮显示。\n\ntimeArr是我们右侧使用的UIPickerView要用的数据。\n\n### 3.2 UI定义\n\n这里我们大致会用到这些视图。\n```Swift\n//白色背景底 整个半屏的视图\nprivate lazy var acView: UIView = {\n    let view = UIView()\n    view.backgroundColor = .white\n    return view\n}()\n\n//选中条\nprivate lazy var lineView: UIView = {\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: \"#409EFF\")\n    return view\n}()\n\n/// 预约日期按钮\nprivate lazy var dateBtn: UIButton = {\n    let btn = UIButton()\n    btn.setTitle(\"预约日期\", for: .normal)\n    btn.titleFont = .pingFangMedium(size: 16)\n    btn.setTitleColor(UIColor.lightGray, for: .normal)\n    btn.setTitleColor(UIColor.black, for: .selected)\n    btn.addTarget(self, action: #selector(actionForChooseDate), for: .touchUpInside)\n    btn.isSelected = true\n    return btn\n}()\n\n/// 预约时间按钮\nprivate lazy var timeBtn: UIButton = {\n    let btn = UIButton()\n    btn.setTitle(\"预约时间\", for: .normal)\n    btn.titleFont = .pingFangMedium(size: 16)\n    btn.setTitleColor(UIColor.lightGray, for: .normal)\n    btn.setTitleColor(UIColor.black, for: .selected)\n    btn.addTarget(self, action: #selector(actionForChooseTime), for: .touchUpInside)\n    return btn\n}()\n\n/// 取消按钮\nprivate lazy var cancelBtn: UIButton = {\n    let btn = UIButton()\n    btn.setTitle(\"取消\", for: .normal)\n    btn.setTitleColor(UIColor.init(hex: \"#409EFF\"), for: .normal)\n    btn.titleFont = .pingFangRegular(size: 16)\n    btn.addTarget(self, action: #selector(actionForCancel), for: .touchUpInside)\n    return btn\n}()\n\n//日历工具条\nprivate lazy var dateToolView: UIView = {\n    let view = UIView()\n    return view\n}()\n\n//日历工具条显示当前月份标签\nprivate lazy var monthLb: UILabel = {\n    let lab = UILabel()\n    lab.font = .pingFangMedium(size: 16)\n    lab.textColor = UIColor.init(hex: \"#3B4058\")\n    lab.text = \"\"\n    lab.textAlignment = .center\n    return lab\n}()\n\n//日历工具条左箭头\nprivate lazy var toolLeftBtn: UIButton = {\n    let btn = UIButton()\n    btn.setImage(UIImage.init(named: \"日历_左箭头\"), for: .normal)\n    btn.addTarget(self, action: #selector(actionForLeftEvent), for: .touchUpInside)\n    btn.isHidden = true\n    return btn\n}()\n\n//日历工具条右箭头\nprivate lazy var toolRightBtn: UIButton =  {\n    let btn = UIButton()\n    btn.setImage(UIImage.init(named: \"日历_右箭头\"), for: .normal)\n    btn.addTarget(self, action: #selector(actionForRightEvent), for: .touchUpInside)\n    return btn\n}()\n\n//星期X显示条\nprivate lazy var weeksView: UIView = {\n    let view = UIView()\n    view.backgroundColor = .white\n    view.layer.shadowColor = UIColor.init(hex: \"#7D7E80\").cgColor\n    view.layer.shadowOffset = CGSize.init(width: 0, height: 2)\n    view.layer.shadowRadius = 10\n    view.layer.shadowOpacity = 0.16\n    return view\n}()\n\n//滚动视图 左右滚动\nprivate lazy var scrollView: UIScrollView = {\n    let _scrollView = UIScrollView()\n    _scrollView.contentSize = CGSize.init(width: ScreenWidth*2, height: _scrollView.size.height)\n    _scrollView.bounces = false\n    _scrollView.isScrollEnabled = true\n    _scrollView.isPagingEnabled = true\n    _scrollView.showsVerticalScrollIndicator = false\n    _scrollView.showsHorizontalScrollIndicator = false\n    return _scrollView\n}()\n\n//月份水印背景\nprivate lazy var watermarkView: CalendarWatermark = {\n    let view = CalendarWatermark()\n    view.backgroundColor = .white\n    view.isHidden = true  //当前版本隐藏水印\n    return view\n}()\n\n//日历展示表\n    private lazy var collectionView: UICollectionView = {\n        let layout = UICollectionViewFlowLayout()\n        layout.scrollDirection = .vertical\n        let collection = UICollectionView(frame: CGRect.init(x: 0, y: 34+40, width: ScreenWidth, height: ScreenHeight*0.57*0.57), collectionViewLayout: layout)\n        collection.backgroundColor = .clear\n        collection.delegate = self\n        collection.dataSource = self\n        collection.isPagingEnabled = true\n        collection.showsHorizontalScrollIndicator = false\n        collection.bounces = false\n        collection.register(CalendarCell.self, forCellWithReuseIdentifier: CalendarCell.identifier)\n        return collection\n}()\n\n//时间选择器 x轴以 屏幕宽度为起点，刚好在第二屏了\nprivate lazy var pickerView: UIPickerView = {\n    let picker = UIPickerView.init(frame: CGRect.init(x: ScreenWidth, y: 0, width: ScreenWidth, height: ScreenHeight*0.57*0.57+34+40))\n    picker.delegate = self\n    picker.dataSource = self\n    return picker\n}()\n```\n\n这些需要用代理和数据源的都设置self，后面再具体实现。\n\n这里可以认为是我们搭建房子用到的一些素材。先写好，后期再拼接下。\n\n### 3.3 生命周期函数\n\n初始化看下，应该要先设置一个蒙层。\n```Swift\noverride init(frame: CGRect){\n        super.init(frame: frame)\n        /// 这里应该是蒙层\n        self.backgroundColor = UIColor.init(r: 100, g: 1, b: 1, a: 0.3)\n        self.alpha = 0\n        \n        let lastDyaDate = YSDateTool.lastDay()\n        let com = YSDateTool.currentDateCom(date: lastDyaDate)\n        watermarkView.monthStr = \"\\(com.month!)\"\n    }\n    \n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n```\n确实如此，这里就只加了个颜色。\n\n### 3.4 定义方法，展示和隐藏选择器\n\n```Swift\nextension CalendarView{\n    /// 显示弹窗\n    public func showAlertView() {\n        let str = \"\\(timeModel.startTime)\\(CalendarView.range)\\(timeModel.endTime)\"\n        selectIndex = timeArr.firstIndex(of:str) ?? 0\n        let timeStr = \"\\(timeModel.year)-\\(timeModel.month)-\\(timeModel.day)\"\n        let date = YSDateTool.dateStringToDate(timeStr)\n        self.setDate(date: date)\n        self.setUI()\n        pickerView.selectRow(selectIndex, inComponent: 0, animated: false)\n        UIView.animate(withDuration: 0.25) {\n            self.alpha = 1\n        }\n    }\n\n    /// 隐藏弹窗\n    public func dismissAlertView() {\n        self.animate(duration: 0.25) {\n            self.alpha = 0\n        } completion: { finish in\n            self.removeFromSuperview()\n        }\n    }\n}\n```\n这个方法很重要，主要提供给外部使用，这里帮助外部设置数据，因为外部调用者可能不知道内部细节，所以我们最好在这个类里面实现展示弹框的方法。\n\n### 3.5 设置初始化日期\n\n外部可能有选择好的日期，所以我们必须提供一个方法，设置数据。\n```Swift\nextension CalendarView{\n    /// 按照这个date获取这个月的数据\n    func setDate(date: Date = Date()){\n        modelArr.removeAll()\n        let count = YSDateTool.countOfDaysInCurrentMonth(date: date)    //当月天数\n        for i in 0..<count{\n            let model = self.initializeModel(date: date, day: i+1)\n            modelArr.append(model)\n        }\n        let firstWeekDay = YSDateTool.firstWeekDayInCurrentMonth(date: date)    //当月第一天周几\n        \n        //头部空缺数据填充 插入一个空的model\n        if firstWeekDay != 7 {\n            for _ in 0 ..< firstWeekDay{\n                let model = self.initializeModel(date: date, day: 0)\n                modelArr.insert(model, at: 0)\n            }\n        }\n        //尾部空缺数据填充,插入一个空的model\n        if modelArr.count < 35{\n            for _ in modelArr.count ..< 35{\n                let model = self.initializeModel(date: date, day: 0)\n                modelArr.append(model)\n            }\n        }\n        \n        collectionView.reloadData()\n    }\n    \n    /// 初始化数据，返回\n    func initializeModel(date: Date, day: Int)->TimeModel{\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        let model = TimeModel()\n        model.year = com.year!\n        model.month = com.month!\n        model.day = day\n        \n        // model指代当前时间\n        let monthStr = com.month! < 10 ? \"0\\(model.month)\" : \"\\(model.month)\"\n        let dayStr = com.day! < 10 ? \"0\\(model.day)\" : \"\\(model.day)\"\n        model.dateStr = \"\\(com.year!)-\\(monthStr)-\\(dayStr)\"\n        return model\n    }\n}\n```\n这里也搞了2个扩展函数，会根据目标日期，获取到该日期的一个月的数据，然后会填充第一天非星期天的情况的数据，也会填最后几天空白区域的数据。\n\n### 3.6 设置UI\n\n有了日期就可以设置UI了，所以我们看下如何填充视图的。\n\n```Swift\nextension CalendarView {\n    func setUI() {\n        \n        //日历顶部按钮布局\n        self.addSubview(acView)\n        acView.snp.makeConstraints{make in\n            make.leading.trailing.bottom.equalTo(0)\n            make.height.equalTo(ScreenHeight*0.57)\n        }\n        \n        // 加顶部横线 左上角默认位置\n        acView.addSubview(lineView)\n        self.lineViewLayout()\n        \n        // 加预约日期\n        acView.addSubview(dateBtn)\n        dateBtn.snp.makeConstraints{make in\n            make.top.equalTo(11)\n            make.leading.equalTo(28)\n            make.width.equalTo(66)\n            make.height.equalTo(22)\n        }\n        \n        // 预约时间\n        acView.addSubview(timeBtn)\n        timeBtn.snp.makeConstraints{make in\n            make.top.equalTo(11)\n            make.centerX.equalToSuperview()\n            make.width.equalTo(66)\n            make.height.equalTo(22)\n        }\n        \n        // 加取消按钮\n        acView.addSubview(cancelBtn)\n        cancelBtn.snp.makeConstraints{make in\n            make.top.equalTo(11)\n            make.trailing.equalTo(-16)\n            make.width.equalTo(66)\n            make.height.equalTo(22)\n        }\n        \n        \n        // 继续加滚动视图\n        acView.addSubview(scrollView)\n        scrollView.snp.makeConstraints{make in\n            make.top.equalTo(dateBtn.snp.bottom).offset(10)\n            make.leading.trailing.equalToSuperview()\n            make.bottom.equalToSuperview()\n        }\n        \n        // acView添加完毕，现在到内部ScrollView层级了--------------\n    \n        // 加个集合View 集合View因为初始化确定了y轴高度，这里无需重复布局\n        scrollView.addSubview(collectionView)\n        \n        // 再加个pickerView 时间滚轮，这里直接加到ScrollView里面了，也无需布局，直接覆盖到上层的\n        scrollView.addSubview(pickerView)\n        \n        // 先加工具栏\n        scrollView.addSubview(dateToolView)\n        dateToolView.snp.makeConstraints{make in\n            make.top.leading.equalTo(0)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(40)\n        }\n        \n        // 滚动视图再加星期视图\n        scrollView.addSubview(weeksView)\n        weeksView.snp.makeConstraints{make in\n            make.top.equalTo(dateToolView.snp.bottom).offset(4)\n            make.leading.equalTo(0)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(30)\n        }\n        \n        \n        // 处理下工具栏内部布局\n        dateToolView.addSubview(monthLb)\n        monthLb.snp.makeConstraints{make in\n            make.centerY.equalToSuperview()\n            make.centerX.equalToSuperview()\n            make.width.equalTo(100)\n            make.height.equalTo(20)\n        }\n        \n        // 日历工具条加左按钮\n        dateToolView.addSubview(toolLeftBtn)\n        toolLeftBtn.snp.makeConstraints{make in\n            make.centerY.equalToSuperview()\n            make.width.height.equalTo(40)\n            make.leading.equalTo(16)\n        }\n\n        // 日历工具条加右侧箭头\n        dateToolView.addSubview(toolRightBtn)\n        toolRightBtn.snp.makeConstraints{make in\n            make.centerY.equalToSuperview()\n            make.width.height.equalTo(40)\n            make.trailing.equalTo(-16)\n        }\n        \n        // 设置星期几内部布局\n        setWeekUiInner()\n        \n        // 地址底部按钮\n        addBottomUI()\n    \n    }\n```\n中规中矩，老老实实从上到下，从左到右布局。\n\n内部星期几看下如何布局的：\n```Swift\nfunc setWeekUiInner() {\n        let arr = [\"日\",\"一\",\"二\",\"三\",\"四\",\"五\",\"六\"]\n\n        for i in 0 ..< arr.count {\n            let width = ScreenWidth/7\n            let lab = UILabel()\n            lab.text = arr[i]\n            lab.textColor = UIColor.init(hex: \"#323233\")\n            lab.font = .pingFangRegular(size: 12)\n            lab.textAlignment = .center\n            weeksView.addSubview(lab)\n            lab.snp.makeConstraints{make in\n                make.leading.equalTo(width*CGFloat(i))\n                make.centerY.equalToSuperview()\n                make.width.equalTo(width)\n                make.height.equalTo(20)\n            }\n        }\n    }\n```\n\n还有底部的下一步和完成：\n```Swift\nfunc addBottomUI() {\n        let nextBtn: UIButton = UIButton.init(type: .custom)\n        nextBtn.frame = CGRect.init(x: 16, y: ScreenHeight*0.57*0.57+8+34+40, width: (ScreenWidth-32), height: 44)\n        nextBtn.titleFont = .pingFangMedium(size: 16)\n        nextBtn.setTitleColor(.white, for: .normal)\n        nextBtn.backgroundColor = UIColor.init(hex: \"#409EFF\")\n        nextBtn.setTitle(\"下一步\", for: .normal)\n        nextBtn.layer.cornerRadius = 22\n        nextBtn.addTarget(self, action: #selector(actionForNext), for: .touchUpInside)\n        scrollView.addSubview(nextBtn)\n        \n        let doneBtn: UIButton = UIButton.init(type: .custom)\n        doneBtn.frame = CGRect.init(x: ScreenWidth+16, y: ScreenHeight*0.57*0.57+8+34+40, width: (ScreenWidth-32), height: 44)\n        doneBtn.titleFont = .pingFangMedium(size: 16)\n        doneBtn.setTitleColor(.white, for: .normal)\n        doneBtn.backgroundColor = UIColor.init(hex: \"#409EFF\")\n        doneBtn.setTitle(\"完成\", for: .normal)\n        doneBtn.layer.cornerRadius = 22\n        doneBtn.addTarget(self, action: #selector(actionForDone), for: .touchUpInside)\n        scrollView.addSubview(doneBtn)\n    }\n```\n\n### 3.7 填充数据\n\n这里先看下日历数据如何使用代理和数据源的：\n```Swift\nextension CalendarView: UICollectionViewDelegate,UICollectionViewDataSource,UICollectionViewDelegateFlowLayout{\n    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {\n        return modelArr.count\n    }\n    \n    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: CalendarCell.identifier, for: indexPath) as! CalendarCell\n        cell.model = modelArr[indexPath.item]\n        cell.selectedModel = timeModel\n        return cell\n    }\n\n    // 定义每个Cell的大小\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {\n        let width = ScreenWidth/7\n        let height = modelArr.count > 35 ? (ScreenHeight*0.57*0.57)/6 : (ScreenHeight*0.57*0.57)/5\n        return CGSize(width: width-2, height: height-1)\n    }\n    \n    // 定义每个Section的四边间距\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -> UIEdgeInsets {\n        return UIEdgeInsets(top: 0, left: 3.5, bottom: 0, right: 0)\n    }\n    \n    // 这个是两行cell之间的间距（上下行cell的间距）\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -> CGFloat {\n        return 1.0\n    }\n    \n    // 两个cell之间的间距（同一行的cell的间距）\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Int) -> CGFloat {\n        return 1.0\n    }\n    \n    // 选中某个ietm\n    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {\n        let model = modelArr[indexPath.item]\n        let com = YSDateTool.currentDateCom()\n        if com.year == model.year && com.month == model.month && model.day <= com.day! || model.day == 0{\n            return\n        }\n\n        timeModel.year = model.year\n        timeModel.month = model.month\n        timeModel.day = model.day\n        collectionView.reloadData()\n    }\n}\n```\n主要逻辑委托给Cell来实现了。后面再看下。\n\n### 3.8 UIPickerView数据填充\n\n然后看下预约时间如何填充数据的。\n```Swift\nextension CalendarView:UIPickerViewDelegate,UIPickerViewDataSource {\n\n    func numberOfComponents(in pickerView: UIPickerView) -> Int {\n        return 1\n    }\n    \n    func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -> Int {\n        return timeArr.count\n    }\n\n    func pickerView(_ pickerView: UIPickerView, widthForComponent component: Int) -> CGFloat {\n        return ScreenWidth\n    }\n    \n    func pickerView(_ pickerView: UIPickerView, rowHeightForComponent component: Int) -> CGFloat {\n        44\n    }\n    \n    func pickerView(_ pickerView: UIPickerView, viewForRow row: Int, forComponent component: Int, reusing view: UIView?) -> UIView {\n        \n        //设置分割线 pickerView的subvews的第二个一般用来做分割线 subviews会有2个view\n        for view in pickerView.subviews {\n            print(\"view.height=\\(view.size.height) 长度为：\\(pickerView.subviews.count)\")\n            if view.size.height <= 50 {\n                view.backgroundColor = .clear\n                //自定义分割线\n                let toplayer = CALayer()\n                toplayer.frame = CGRect.init(x: 0, y: 0, width: ScreenWidth, height: 1)\n                toplayer.backgroundColor = UIColor.init(hex: \"#EBEDF0\").cgColor\n                view.layer.addSublayer(toplayer)\n\n                let bottomlayer = CALayer()\n                bottomlayer.frame = CGRect.init(x: 0, y: 44-1, width: ScreenWidth, height: 1)\n                bottomlayer.backgroundColor = UIColor.init(hex: \"#EBEDF0\").cgColor\n                view.layer.addSublayer(bottomlayer)\n               \n            }else{\n                view.backgroundColor = .clear\n            }\n        }\n        \n        //设置内容样式\n        var label = view as? UILabel\n        if label == nil {\n            label = UILabel.init()\n            label?.backgroundColor = .clear\n            label?.frame = CGRect.init(x: 0, y: 0, width:ScreenWidth, height:44)\n        }\n        if row == selectIndex {\n            label?.textColor = UIColor.init(hex: \"#409EFF\")\n        }else{\n            label?.textColor = UIColor.init(hex: \"#3B4058\")\n        }\n        label?.textAlignment = .center\n        label?.font = .pingFangRegular(size: 16)\n        //label?.minimumScaleFactor = 0.5\n        //label?.adjustsFontSizeToFitWidth = true\n        label?.text = timeArr[row]\n        return label!\n    }\n    \n    func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) {\n        selectIndex = row\n        pickerView.reloadAllComponents()\n    }\n}\n```\n主要逻辑是viewForRow覆写的方法里面。\n交代了如何绘制分割线和选中高亮显示。\n这里有个点要注意，这个分割线用到了 UIPickerView的subViews，这里通常设置分割线都要用到这个东西，具体细节我不是很清楚，预测这个subViews第二个就是居中的item。第一个item很长，不能用来分割线。\n\n然后就是didSelectRow用来响应用户点击事件，需要刷新下components。\n\n### 3.9 交互事件\n\n这里交互事件统一用一个扩展类来实现。\n```Swift\nextension CalendarView {\n    \n    @objc func actionForChooseDate(){\n        self.lineViewLayout()\n        self.scrollDate()\n    }\n    \n    @objc func actionForChooseTime(){\n        self.lineViewLayout(leading: 1)\n        self.scrollTime()\n    }\n    \n    @objc func actionForCancel(){\n        self.dismissAlertView()\n    }\n    \n    @objc func actionForLeftEvent(){\n        dynamicDate = YSDateTool.lastMonth(date: dynamicDate)\n        self.isRefrenshMonth()\n    }\n    \n    @objc func actionForRightEvent(){\n        dynamicDate = YSDateTool.nextMonth(date: dynamicDate)\n        self.isRefrenshMonth()\n    }\n    \n    @objc func actionForNext(){\n        self.lineViewLayout(leading: 1)\n        self.scrollTime()\n    }\n    \n    @objc func actionForDone(){\n        if doneHandle != nil {\n            let str = timeArr[selectIndex]\n            let arr = str.components(separatedBy: CalendarView.range)\n            timeModel.startTime = arr[0]\n            timeModel.endTime = arr[1]\n            \n            let monthStr = timeModel.month < 10 ? \"0\\(timeModel.month)\" : \"\\(timeModel.month)\"\n            let dayStr = timeModel.day < 10 ? \"0\\(timeModel.day)\" : \"\\(timeModel.day)\"\n            timeModel.dateStr = \"\\(timeModel.year)-\\(monthStr)-\\(dayStr)\"\n            \n            doneHandle(timeModel)\n        }\n        self.dismissAlertView()\n    }\n    \n    // 滑动到日期\n    func scrollDate(){\n        dateBtn.isSelected = true\n        timeBtn.isSelected = false\n        scrollView.setContentOffset(CGPoint.init(x: 0, y: 0), animated: true)\n    }\n    \n    // 滑动到时间\n    func scrollTime(){\n        dateBtn.isSelected = false\n        timeBtn.isSelected = true\n        scrollView.setContentOffset(CGPoint.init(x: ScreenWidth, y: 0), animated: true)\n    }\n    \n    func isRefrenshMonth(){\n        self.setDate(date: dynamicDate)\n        let com = YSDateTool.currentDateCom(date: dynamicDate)\n        monthLb.text = \"\\(com.year!)年\\(com.month!)月\"\n        watermarkView.monthStr = \"\\(com.month!)\"\n        \n        let currentCom = YSDateTool.currentDateCom()\n        if (com.year! == currentCom.year!  && com.month! > currentCom.month!) || (com.year! > currentCom.year!){\n            toolLeftBtn.isHidden = false\n        }else{\n            toolLeftBtn.isHidden = true\n        }\n    }\n    \n    func lineViewLayout(leading: Int = 0){\n        lineView.snp.remakeConstraints{make in\n            make.top.equalTo(0)\n            if leading == 0 {\n                make.leading.equalTo(leading)\n            }else{\n                make.centerX.equalToSuperview() // 居中了\n            }\n            make.width.equalTo(66+56) // 宽度\n            make.height.equalTo(2)  // 高度\n        }\n    }\n}\n```\n\n## 4 撸下时间工具\n\n这个只是个单纯工具，不必重复造轮子。\n```Swift\nclass YSDateTool {\n    // MARK: - 当前时间组件\n    static func currentDateCom(date: Date = Date()) -> DateComponents{\n        let calendar = Calendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com\n    }\n    // MARK: - 今年\n    static func currentYear(date: Date = Date()) -> Int {\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com.year!\n    }\n  \n    // MARK: - 今月\n    static func currentMonth(date: Date = Date()) -> Int {\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com.month!\n    }\n  \n    // MARK: - 今日\n    static func currentDay(date: Date = Date()) -> Int {\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com.day!\n    }\n    \n    // MARK: - 今天星期几\n    static func currentWeekDay(date: Date = Date()) -> Int {\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.weekday], from: date)\n        return com.weekday!\n    }\n    \n    // MARK: - 农历今年\n    static func currentChineseYear(date: Date = Date()) -> String {\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.year], from: date)\n        return numberToChina(yearNum: (com?.year)!) + \"年\"\n    }\n    \n    // MARK: - 农历今月\n    static func currentChineseMonth(date: Date = Date()) -> String {\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.month], from: date)\n        return numberToChina(monthNum: (com?.month)!)\n    }\n\n    // MARK: - 农历今日\n    static func currentChineseDay(date: Date = Date()) -> String {\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.day], from: date)\n        return numberToChina(dayNum: (com?.day)!)\n    }\n    \n    // MARK: - 农历今日\n    static func currentChineseDayInt(date: Date = Date()) -> Int {\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.day], from: date)\n        return (com?.day)!\n    }\n    \n    // MARK: - 农历星期\n    static func currentChineseWeekYear(date: Date = Date()) -> String {\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.weekday], from: date)\n        return numberToChina(weekNum: (com?.weekday)!)\n    }\n  \n    // MARK: - 下个月\n    static func nextMonth(date: Date = Date()) -> Date {\n        let calendar = NSCalendar.current\n        let nDate = calendar.date(byAdding: DateComponents(month: 1), to: date)\n        return nDate!\n    }\n    \n    // MARK: - 上个月\n    static func lastMonth(date: Date = Date()) -> Date {\n        let calendar = NSCalendar.current\n        let lDate = calendar.date(byAdding: DateComponents(month: -1), to: date)\n        return lDate!\n    }\n    \n    // MARK: - 下一天\n    static func lastDay(date: Date = Date()) -> Date{\n        let calendar = NSCalendar.current\n        let lDate = calendar.date(byAdding: DateComponents(day: 1), to: date)\n        return lDate!\n    }\n  \n    // MARK: - 本月天数\n    static func countOfDaysInCurrentMonth(date: Date = Date()) -> Int {\n        let calendar = Calendar(identifier: Calendar.Identifier.gregorian)\n        let range = (calendar as NSCalendar?)?.range(of: NSCalendar.Unit.day, in: NSCalendar.Unit.month, for: date)\n        return (range?.length)!\n    }\n \n    // MARK: - 当月第一天是星期几\n    static func firstWeekDayInCurrentMonth(date: Date = Date()) -> Int {\n        // 星期和数字一一对应 星期日：7\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = \"yyyy-MM\"\n        let date = dateFormatter.date(from: String(date.xj.year)+\"-\"+String(date.xj.month))\n        let calender = Calendar(identifier: Calendar.Identifier.gregorian)\n        let comps = (calender as NSCalendar?)?.components(NSCalendar.Unit.weekday, from: date!)\n        var week = comps?.weekday\n        if week == 1 {\n            week = 8\n        }\n        return week! - 1\n    }\n\n    // MARK: - - 获取指定日期各种值\n    // 根据年月得到某月天数\n    static func getCountOfDaysInMonth(year: Int, month: Int) -> Int{\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = \"yyyy-MM\"\n        let date = dateFormatter.date(from: String(year)+\"-\"+String(month))\n        let calendar = Calendar(identifier: Calendar.Identifier.gregorian)\n        let range = (calendar as NSCalendar?)?.range(of: NSCalendar.Unit.day, in: NSCalendar.Unit.month, for: date!)\n        return (range?.length)!\n    }\n    \n    // MARK: - 根据年月得到某月第一天是周几\n    static func getfirstWeekDayInMonth(year: Int, month: Int) -> Int{\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = \"yyyy-MM\"\n        let date = dateFormatter.date(from: String(year)+\"-\"+String(month))\n        let calendar = Calendar(identifier: Calendar.Identifier.gregorian)\n        let comps = (calendar as NSCalendar?)?.components(NSCalendar.Unit.weekday, from: date!)\n        let week = comps?.weekday\n        return week! - 1\n    }\n\n    // MARK: - date转日期字符串\n    static func dateToDateString(_ date: Date, dateFormat: String) -> String {\n        let timeZone = NSTimeZone.default\n        let formatter = DateFormatter()\n        formatter.timeZone = timeZone\n        formatter.dateFormat = dateFormat\n        let date = formatter.string(from: date)\n        return date\n    }\n\n    // MARK: - 日期字符串转date\n    static func dateStringToDate(_ dateStr: String) -> Date {\n        let dateFormatter = DateFormatter()\n        dateFormatter.timeZone = TimeZone(abbreviation: \"UTC+8\")\n        dateFormatter.dateFormat = \"yyyy-MM-dd\"\n        let date = dateFormatter.date(from: dateStr)\n        return date!\n    }\n    \n    // MARK: - 时间字符串转date\n    static func timeStringToDate(_ dateStr: String) -> Date {\n        let dateFormatter = DateFormatter()\n        dateFormatter.timeZone = TimeZone(abbreviation: \"UTC+8\")\n        dateFormatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n        let date = dateFormatter.date(from: dateStr)\n        return date!\n    }\n\n    // MARK: - 计算天数差\n    static func dateDifference(_ dateA: Date, from dateB: Date) -> Double {\n        let interval = dateA.timeIntervalSince(dateB)\n        return interval/86400\n    }\n\n    // MARK: - 比较时间先后\n    static func compareOneDay(oneDay: Date, withAnotherDay anotherDay: Date) -> Int {\n        let dateFormatter: DateFormatter = DateFormatter()\n        dateFormatter.dateFormat = \"yyyy-MM-dd\"\n        let oneDayStr: String = dateFormatter.string(from: oneDay)\n        let anotherDayStr: String = dateFormatter.string(from: anotherDay)\n        let dateA = dateFormatter.date(from: oneDayStr)\n        let dateB = dateFormatter.date(from: anotherDayStr)\n        let result: ComparisonResult = (dateA?.compare(dateB!))!\n        // Date1 is in the future\n        if(result == ComparisonResult.orderedDescending ) {\n            return 1\n        }\n        // Date1 is in the past\n        else if(result == ComparisonResult.orderedAscending) {\n            return 2\n        }\n            // Both dates are the same\n        else {\n            return 0\n        }\n    }\n\n    // MARK: - 时间与时间戳之间的转化\n    // 将时间转换为时间戳\n    static func stringToTimeStamp(_ stringTime: String) -> Int {\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat = \"yyyy-MM-dd HH: mm: ss\"\n        dfmatter.locale = Locale.current\n        let date = dfmatter.date(from: stringTime)\n        let dateStamp: TimeInterval = date!.timeIntervalSince1970\n        let dateSt: Int = Int(dateStamp)\n        return dateSt\n    }\n    \n    // 将时间戳转换为年月日\n    static func timeStampToString(_ timeStamp: String) -> String {\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=\"yyyy年MM月dd日\"\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    }\n    \n    // 将时间戳转换为具体时间\n    static func timeStampToStringDetail(_ timeStamp: String) -> String {\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=\"yyyy年MM月dd日HH: mm: ss\"\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    }\n    \n    // 将时间戳转换为时分秒\n    static func timeStampToHHMMSS(_ timeStamp: String) -> String {\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=\"HH: mm: ss\"\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    }\n    \n    // 将时间戳转换为时分\n    static func timeStampToHHMM(_ timeStamp: String) -> String {\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=\"HH: mm\"\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    }\n    \n    // 获取系统的当前时间戳\n    static func getStamp(date: Date = Date()) -> Int{\n        // 获取当前时间戳\n        let timeInterval: Int = Int(date.timeIntervalSince1970)\n        return timeInterval\n    }\n    \n    // 日数字转汉字\n    static func numberToChina(yearNum: Int) -> String {\n        // 以一个天干和一个地支相配，排列起来，天干在前，地支在后，天干由甲起，地支由子起，阳干对阳支，阴干对阴支（阳干不配阴支，阴干不配阳支）\n        // 就会得到六十年一周期的甲子回圈，一般称为“六十甲子”或“花甲子”\n        // 十天干： 甲（jiǎ）、乙（yǐ）、丙（bǐng）、丁（dīng）、戊（wù）、己（jǐ）、庚（gēng）、辛（xīn）、壬（rén）、癸（guǐ）\n        // 十二地支： 子（zǐ）、丑（chǒu）、寅（yín）、卯（mǎo）、辰（chén）、巳（sì）、午（wǔ）、未（wèi）、申（shēn）、酉（yǒu）、戌（xū）、亥（hài）\n        let ChinaArray = [ \"甲子\", \"乙丑\", \"丙寅\", \"丁卯\", \"戊辰\", \"己巳\", \"庚午\", \"辛未\", \"壬申\", \"癸酉\",\n                         \"甲戌\", \"乙亥\", \"丙子\", \"丁丑\", \"戊寅\", \"己卯\", \"庚辰\", \"辛己\", \"壬午\", \"癸未\",\n                         \"甲申\", \"乙酉\", \"丙戌\", \"丁亥\", \"戊子\", \"己丑\", \"庚寅\", \"辛卯\", \"壬辰\", \"癸巳\",\n                         \"甲午\", \"乙未\", \"丙申\", \"丁酉\", \"戊戌\", \"己亥\", \"庚子\", \"辛丑\", \"壬寅\", \"癸丑\",\n                         \"甲辰\", \"乙巳\", \"丙午\", \"丁未\", \"戊申\", \"己酉\", \"庚戌\", \"辛亥\", \"壬子\", \"癸丑\",\n                         \"甲寅\", \"乙卯\", \"丙辰\", \"丁巳\", \"戊午\", \"己未\", \"庚申\", \"辛酉\", \"壬戌\", \"癸亥\"]\n        let ChinaStr: String = ChinaArray[yearNum - 1]\n        return ChinaStr\n    }\n    \n    // 月份数字转汉字\n    static func numberToChina(monthNum: Int) -> String {\n        let ChinaArray = [\"一月\", \"二月\", \"三月\", \"四月\", \"五月\", \"六月\", \"七月\", \"八月\", \"九月\", \"十月\", \"十一月\", \"十二月\"]\n        let ChinaStr: String = ChinaArray[monthNum - 1]\n        return ChinaStr\n    }\n    \n    // 日数字转汉字\n    static func numberToChina(dayNum: Int) -> String {\n        let ChinaArray = [ \"初一\", \"初二\", \"初三\", \"初四\", \"初五\", \"初六\", \"初七\", \"初八\", \"初九\", \"初十\",\n                         \"十一\", \"十二\", \"十三\", \"十四\", \"十五\", \"十六\", \"十七\", \"十八\", \"十九\", \"二十\",\n                         \"廿一\", \"廿二\", \"廿三\", \"廿四\", \"廿五\", \"廿六\", \"廿七\", \"廿八\", \"廿九\", \"三十\"]\n        let ChinaStr: String = ChinaArray[dayNum - 1]\n        return ChinaStr\n    }\n      \n    // 星期数字转汉字\n    static func numberToChina(weekNum: Int) -> String {\n        let ChinaArray = [\"一月\", \"二月\", \"三月\", \"四月\", \"五月\", \"六月\", \"七月\", \"八月\", \"九月\", \"十月\", \"十一月\", \"十二月\"]\n        let ChinaStr: String = ChinaArray[weekNum - 1]\n        return ChinaStr\n    }\n    \n    // MARK: - 数字前补0\n    static func add0BeforeNumber(_ number: Int) -> String {\n        if number >= 10 {\n            return String(number)\n        }else{\n            return \"0\" + String(number)\n        }\n    }\n    \n    static func getCurrentSystemDate() -> Date{\n        let date = Date() // 获得时间对象\n        let zone = NSTimeZone.system // 获得系统的时区\n        let time = zone.secondsFromGMT(for: date)// 以秒为单位返回当前时间与系统格林尼治时间的差\n        return date.addingTimeInterval(TimeInterval(time))// 然后把差的时间加上,就是当前系统准确的时间\n    }\n    \n    static func date(_ date: String?, dateFormat: String = \"yyyy-MM-dd\") -> Date? {\n        guard let date = date else {\n            return nil\n        }\n        let dateformatter = DateFormatter()\n        dateformatter.timeZone = TimeZone.init(secondsFromGMT: 0)\n        dateformatter.dateFormat = dateFormat\n        return dateformatter.date(from: date)\n    }\n\n    // MARK: - 将时间显示为（几分钟前，几小时前，几天前）\n    static func compareCurrentTime(str: String) -> String {\n        //let currentDateStr = dateToDateString(Date(), dateFormat: \"yyyy-MM-dd hh:mm:ss\")\n        let currentDate = getCurrentSystemDate()\n        let sendTimeDate = date(str,dateFormat: \"yyyy-MM-dd HH:mm:ss\")!//self.timeStringToDate(str)\n        let sendTimeInterval = Double(getStamp(date: sendTimeDate))\n        let timeInterval = currentDate.timeIntervalSince(sendTimeDate)\n\n        var todayStr = dateToDateString(Date(), dateFormat: \"yyyy-MM-dd\")\n        todayStr = todayStr+\" 00:00\"\n        let todayTimeInterval = Double(Date().stringToSecondTimeStamp(todayStr)) ?? 0\n        let yestDayTimeInterval = Double(todayTimeInterval - 86400)\n        let nextDayTimeInterval = Double(todayTimeInterval + 86400)\n\n        var temp: Double = 0\n        var result: String = \"\"\n        if timeInterval/60 < 1 {\n            result = \"刚刚\"\n        }else if (timeInterval/60) < 60{\n            temp = timeInterval/60\n            result = \"\\(Int(temp))分钟前\"\n        }else if sendTimeInterval > todayTimeInterval && sendTimeInterval < nextDayTimeInterval{\n\n            //let interval = nextDayTimeInterval - sendTimeInterval\n            temp = timeInterval/60/60\n            result = \"\\(Int(temp))小时前\"\n        }else if sendTimeInterval > yestDayTimeInterval && sendTimeInterval < todayTimeInterval{\n            //let str = timeStampToHHMM(String.init(format: \"%d\", sendTimeInterval))\n            let timeStr = str.components(separatedBy: \" \").last ?? \"\"\n            let str = timeStr.prefix(5)\n            result = \"昨天\\(str)\"\n        }else{\n            let timeStr = str.components(separatedBy: \" \").first ?? \"\"\n            let timeArr = timeStr.components(separatedBy: \"-\")\n            if !timeArr.isEmpty {\n                result = \"\\(timeArr[0])年\\(timeArr[1])月\\(timeArr[2])日\"\n            }\n            //result = timeStampToString(String.init(format: \"%d\", sendTimeInterval))\n        }\n        \n//        else if timeInterval/(30 * 24 * 60 * 60) < 12 {\n//            temp = timeInterval/(30 * 24 * 60 * 60)\n//            result = \"\\(Int(temp))个月前\"\n//        }else{\n//            temp = timeInterval/(12 * 30 * 24 * 60 * 60)\n//            result = \"\\(Int(temp))年前\"\n//        }\n        return result\n    }\n}\n\n```\n\n## 5 撸下最后的日历Cell\n\n这个就是日历里面的item，还是相当简单的。\n\n### 5.1 全局变量\n```Swift\nclass CalendarCell: UICollectionViewCell {\n    \n    static var identifier = \"UICollectionViewCell\"\n    \n    var isGreaterThan: Bool = false     //是否取大于今天的值\n    \n    var isShowPassTime: Int = 0         //是否设定禁选\n    \n    var model:TimeModel?{\n        didSet{\n            guard let _model = model else {return}\n            if _model.day != 0 {\n                titleLab.text = \"\\(_model.day)\"\n            }else{\n                titleLab.text = \"\" // 为0，啥也不显示\n            }\n            \n            let com = YSDateTool.currentDateCom()\n            \n            // 是否是选中的日子\n            if com.year == _model.year && com.month == _model.month && com.day == _model.day {\n                titleLab.textColor = UIColor.init(hex: \"#409EFF\")\n            }else{\n                titleLab.textColor = UIColor.init(hex: \"#323233\")\n            }\n            \n            // 禁用还是可用\n            if isShowPassTime == 0 {\n                if isGreaterThan {\n                    if (com.year == _model.year && com.month == _model.month && _model.day > com.day!) || (_model.year == com.year! && _model.month > com.month!) || (_model.year > com.year!){\n                        titleLab.textColor = UIColor.init(hex: \"#C8C9CC\")\n                    }\n                }else{\n                    // 如果要大于今天，那么前面的时间就的置灰了 前一个月的点不过去，不考虑了\n                    if com.year == _model.year && com.month == _model.month && _model.day < com.day!{\n                        titleLab.textColor = UIColor.init(hex: \"#C8C9CC\")\n                    }\n                }\n            }\n        }\n    }\n    \n    // 选中的item，背景颜色高亮\n    var selectedModel: TimeModel?{\n        didSet{\n            guard let _model = selectedModel else{return}\n            if _model.year == model?.year && _model.month == model?.month && _model.day == model?.day{\n                titleLab.backgroundColor = UIColor.init(hex: \"#409EFF\")\n                titleLab.textColor = UIColor.white\n            }else{\n                titleLab.backgroundColor = UIColor.clear\n            }\n        }\n    }\n```\n比较重要的是model，表示当前时间实体类。这里监听变量改变，利用didSet实现动态改变文案效果。\n\n另外一个是selectedModel，这个是当前选中的item，会比对item是否为选中，选中样式会有所不同。\n\n### 5.2 UI子View\n\n这里只用到一个子View。\n```Swift\nvar titleLab: UILabel = {\n        let lan = UILabel()\n        lan.font = .pingFangRegular(size: 16)\n        lan.textAlignment = .center\n        lan.textColor = UIColor.init(hex: \"#323233\")\n        \n        lan.layer.cornerRadius = 4\n        lan.layer.masksToBounds = true\n        return lan\n    }()\n```\n\n### 5.3 生命周期函数\n\n```Swift\noverride init(frame: CGRect) {\n        super.init(frame: frame)\n        contentView.backgroundColor = .clear\n        contentView.addSubview(titleLab)\n        titleLab.snp.makeConstraints{make in\n            make.top.bottom.leading.trailing.equalToSuperview()\n        }\n    }\n    \n    required init?(coder aDecoder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n```\n把那个子View添加到Cell里面去了。\n\n大概就是这样子。\n\n## 6 总结\n\n* 如果UI图有那种Tab页，就可以考虑使用多种方案来实现，iOS直接用简单的Button也是可以实现的，分割线也是可以用最简单的UIView来实现，不一定要用封装好的框架，谁用挖掘机来搬小石头呢，大材小用了。\n\n* 分页效果可以使用UIScrollView来实现，把它宽度设置为屏幕的n倍，这样最有滑动可以很好控制的，不要动画也可以设置的，办法总是就很多的。\n\n* 日历效果可以用UICollectionView来实现，看着很复杂，其实很简单，主要逻辑也不复杂，控制好数据刷新就好了。UICollectionView可以实现类似网格的效果，我们只需要在Cell里面绘制一个一个Cell，空的部分，我们啥不展示就好了。\n\n* 系统的UIPickerView设置分割线很简单，利用UIPickerView下有一个subViews，这里寻找高度为item高度大小的，然后给view设置一个Layer即可。","slug":"iOS-swift-自定义View之时间选择器","published":1,"updated":"2023-02-01T07:17:16.382Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlhfhyv001nivv70woa9s3r","content":"<h2 id=\"1-需求分析\"><a href=\"#1-需求分析\" class=\"headerlink\" title=\"1 需求分析\"></a>1 需求分析</h2><p>当我们选择购买一个东西时，有时需要预约发货，这时候需要用户手动选择某一天某一个时间，ui给的方案是这样的：<br>预约日期：<br><img src=%E9%A2%84%E7%BA%A6%E6%97%A5%E6%9C%9F.png></p>\n<p>预约时间：<br><img src=%E9%A2%84%E7%BA%A6%E6%97%B6%E9%97%B4.png><br>这里是间隔了2个小时一个时间。</p>\n<p>可以看到这个日期是以日历形式展现，可以选择未来某个日期；时间是以滚轮的方式展现，可以上下滑动到目标时间点。</p>\n<p>对于这个需求，我们要如何实现呢？‘</p>\n<p>答案当然是自定义View了。</p>\n<h2 id=\"2-结构分析\"><a href=\"#2-结构分析\" class=\"headerlink\" title=\"2 结构分析\"></a>2 结构分析</h2><p>显而易见，这个因为设计到分页，我们可以考虑分页区域使用一个UIScrollView，水平滑动，宽度设置为屏幕的2倍，一半用来展示日历，一半用来展示预约时间的UIPickerView。</p>\n<p>所以需要我们自定义一个UIView，这里面先绘制顶部分割线，再绘制标题，“预约日期”和“预约时间”和“取消”的文案。</p>\n<p>然后是一个显示日历操作栏，包括左右箭头和中间的月份显示，这个要放到UIScrollView的左半边，包括星期视图和日历的UICollectionView的集合View，这里日历我们采用这个集合View很容易实现的。</p>\n<p>然后右侧就是一个UIPickerView,这个系统封装好了，使用很方便，我们主要负责填充数据。</p>\n<p>那这个结构大体出来了，一个是整个自定义View，暂且把它叫做CalenderView，还有一个就是日历内部的Cell，暂且叫做CalenderCell。</p>\n<h2 id=\"3-撸下CalenderView\"><a href=\"#3-撸下CalenderView\" class=\"headerlink\" title=\"3 撸下CalenderView\"></a>3 撸下CalenderView</h2><h3 id=\"3-1-全局变量\"><a href=\"#3-1-全局变量\" class=\"headerlink\" title=\"3.1 全局变量\"></a>3.1 全局变量</h3><pre><code class=\"line-numbers language-Swift\">class CalendarView: UIView &#123;\n    \n    /// 传出去给调用者\n    typealias DoneBlock = (TimeModel)-&gt;()\n    var doneHandle: DoneBlock!\n    \n    // 当月日期Model\n    var modelArr: [TimeModel] = []\n    \n    // 动态调整上下月的时间变量\n    var dynamicDate = Date()\n    \n    //默认选中的日期\n    var timeModel: TimeModel = TimeModel()\n    \n    //时间时短数据\n    static let range: String = &quot;                      &quot;\n    private var timeArr: [String] = [&quot;08:00\\(range)10:00&quot;,\n                                   &quot;10:00\\(range)12:00&quot;,\n                                   &quot;12:00\\(range)14:00&quot;,\n                                   &quot;14:00\\(range)16:00&quot;,\n                                   &quot;16:00\\(range)18:00&quot;,\n                                   &quot;18:00\\(range)20:00&quot;,\n                                   &quot;20:00\\(range)22:00&quot;]\n    private var selectIndex = 0\n    \n</code></pre>\n<p>这里定义了一个闭包返回，主要是用户选择后，回调给外部。</p>\n<p>然后有一个TimeModel的数组， 也就是填充我们的日历视图。</p>\n<p>timeModel是我们选择的日期，会高亮显示。</p>\n<p>timeArr是我们右侧使用的UIPickerView要用的数据。</p>\n<h3 id=\"3-2-UI定义\"><a href=\"#3-2-UI定义\" class=\"headerlink\" title=\"3.2 UI定义\"></a>3.2 UI定义</h3><p>这里我们大致会用到这些视图。</p>\n<pre><code class=\"line-numbers language-Swift\">//白色背景底 整个半屏的视图\nprivate lazy var acView: UIView = &#123;\n    let view = UIView()\n    view.backgroundColor = .white\n    return view\n&#125;()\n\n//选中条\nprivate lazy var lineView: UIView = &#123;\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n    return view\n&#125;()\n\n/// 预约日期按钮\nprivate lazy var dateBtn: UIButton = &#123;\n    let btn = UIButton()\n    btn.setTitle(&quot;预约日期&quot;, for: .normal)\n    btn.titleFont = .pingFangMedium(size: 16)\n    btn.setTitleColor(UIColor.lightGray, for: .normal)\n    btn.setTitleColor(UIColor.black, for: .selected)\n    btn.addTarget(self, action: #selector(actionForChooseDate), for: .touchUpInside)\n    btn.isSelected = true\n    return btn\n&#125;()\n\n/// 预约时间按钮\nprivate lazy var timeBtn: UIButton = &#123;\n    let btn = UIButton()\n    btn.setTitle(&quot;预约时间&quot;, for: .normal)\n    btn.titleFont = .pingFangMedium(size: 16)\n    btn.setTitleColor(UIColor.lightGray, for: .normal)\n    btn.setTitleColor(UIColor.black, for: .selected)\n    btn.addTarget(self, action: #selector(actionForChooseTime), for: .touchUpInside)\n    return btn\n&#125;()\n\n/// 取消按钮\nprivate lazy var cancelBtn: UIButton = &#123;\n    let btn = UIButton()\n    btn.setTitle(&quot;取消&quot;, for: .normal)\n    btn.setTitleColor(UIColor.init(hex: &quot;#409EFF&quot;), for: .normal)\n    btn.titleFont = .pingFangRegular(size: 16)\n    btn.addTarget(self, action: #selector(actionForCancel), for: .touchUpInside)\n    return btn\n&#125;()\n\n//日历工具条\nprivate lazy var dateToolView: UIView = &#123;\n    let view = UIView()\n    return view\n&#125;()\n\n//日历工具条显示当前月份标签\nprivate lazy var monthLb: UILabel = &#123;\n    let lab = UILabel()\n    lab.font = .pingFangMedium(size: 16)\n    lab.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n    lab.text = &quot;&quot;\n    lab.textAlignment = .center\n    return lab\n&#125;()\n\n//日历工具条左箭头\nprivate lazy var toolLeftBtn: UIButton = &#123;\n    let btn = UIButton()\n    btn.setImage(UIImage.init(named: &quot;日历_左箭头&quot;), for: .normal)\n    btn.addTarget(self, action: #selector(actionForLeftEvent), for: .touchUpInside)\n    btn.isHidden = true\n    return btn\n&#125;()\n\n//日历工具条右箭头\nprivate lazy var toolRightBtn: UIButton =  &#123;\n    let btn = UIButton()\n    btn.setImage(UIImage.init(named: &quot;日历_右箭头&quot;), for: .normal)\n    btn.addTarget(self, action: #selector(actionForRightEvent), for: .touchUpInside)\n    return btn\n&#125;()\n\n//星期X显示条\nprivate lazy var weeksView: UIView = &#123;\n    let view = UIView()\n    view.backgroundColor = .white\n    view.layer.shadowColor = UIColor.init(hex: &quot;#7D7E80&quot;).cgColor\n    view.layer.shadowOffset = CGSize.init(width: 0, height: 2)\n    view.layer.shadowRadius = 10\n    view.layer.shadowOpacity = 0.16\n    return view\n&#125;()\n\n//滚动视图 左右滚动\nprivate lazy var scrollView: UIScrollView = &#123;\n    let _scrollView = UIScrollView()\n    _scrollView.contentSize = CGSize.init(width: ScreenWidth*2, height: _scrollView.size.height)\n    _scrollView.bounces = false\n    _scrollView.isScrollEnabled = true\n    _scrollView.isPagingEnabled = true\n    _scrollView.showsVerticalScrollIndicator = false\n    _scrollView.showsHorizontalScrollIndicator = false\n    return _scrollView\n&#125;()\n\n//月份水印背景\nprivate lazy var watermarkView: CalendarWatermark = &#123;\n    let view = CalendarWatermark()\n    view.backgroundColor = .white\n    view.isHidden = true  //当前版本隐藏水印\n    return view\n&#125;()\n\n//日历展示表\n    private lazy var collectionView: UICollectionView = &#123;\n        let layout = UICollectionViewFlowLayout()\n        layout.scrollDirection = .vertical\n        let collection = UICollectionView(frame: CGRect.init(x: 0, y: 34+40, width: ScreenWidth, height: ScreenHeight*0.57*0.57), collectionViewLayout: layout)\n        collection.backgroundColor = .clear\n        collection.delegate = self\n        collection.dataSource = self\n        collection.isPagingEnabled = true\n        collection.showsHorizontalScrollIndicator = false\n        collection.bounces = false\n        collection.register(CalendarCell.self, forCellWithReuseIdentifier: CalendarCell.identifier)\n        return collection\n&#125;()\n\n//时间选择器 x轴以 屏幕宽度为起点，刚好在第二屏了\nprivate lazy var pickerView: UIPickerView = &#123;\n    let picker = UIPickerView.init(frame: CGRect.init(x: ScreenWidth, y: 0, width: ScreenWidth, height: ScreenHeight*0.57*0.57+34+40))\n    picker.delegate = self\n    picker.dataSource = self\n    return picker\n&#125;()\n</code></pre>\n<p>这些需要用代理和数据源的都设置self，后面再具体实现。</p>\n<p>这里可以认为是我们搭建房子用到的一些素材。先写好，后期再拼接下。</p>\n<h3 id=\"3-3-生命周期函数\"><a href=\"#3-3-生命周期函数\" class=\"headerlink\" title=\"3.3 生命周期函数\"></a>3.3 生命周期函数</h3><p>初始化看下，应该要先设置一个蒙层。</p>\n<pre><code class=\"line-numbers language-Swift\">override init(frame: CGRect)&#123;\n        super.init(frame: frame)\n        /// 这里应该是蒙层\n        self.backgroundColor = UIColor.init(r: 100, g: 1, b: 1, a: 0.3)\n        self.alpha = 0\n        \n        let lastDyaDate = YSDateTool.lastDay()\n        let com = YSDateTool.currentDateCom(date: lastDyaDate)\n        watermarkView.monthStr = &quot;\\(com.month!)&quot;\n    &#125;\n    \n    required init?(coder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n</code></pre>\n<p>确实如此，这里就只加了个颜色。</p>\n<h3 id=\"3-4-定义方法，展示和隐藏选择器\"><a href=\"#3-4-定义方法，展示和隐藏选择器\" class=\"headerlink\" title=\"3.4 定义方法，展示和隐藏选择器\"></a>3.4 定义方法，展示和隐藏选择器</h3><pre><code class=\"line-numbers language-Swift\">extension CalendarView&#123;\n    /// 显示弹窗\n    public func showAlertView() &#123;\n        let str = &quot;\\(timeModel.startTime)\\(CalendarView.range)\\(timeModel.endTime)&quot;\n        selectIndex = timeArr.firstIndex(of:str) ?? 0\n        let timeStr = &quot;\\(timeModel.year)-\\(timeModel.month)-\\(timeModel.day)&quot;\n        let date = YSDateTool.dateStringToDate(timeStr)\n        self.setDate(date: date)\n        self.setUI()\n        pickerView.selectRow(selectIndex, inComponent: 0, animated: false)\n        UIView.animate(withDuration: 0.25) &#123;\n            self.alpha = 1\n        &#125;\n    &#125;\n\n    /// 隐藏弹窗\n    public func dismissAlertView() &#123;\n        self.animate(duration: 0.25) &#123;\n            self.alpha = 0\n        &#125; completion: &#123; finish in\n            self.removeFromSuperview()\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这个方法很重要，主要提供给外部使用，这里帮助外部设置数据，因为外部调用者可能不知道内部细节，所以我们最好在这个类里面实现展示弹框的方法。</p>\n<h3 id=\"3-5-设置初始化日期\"><a href=\"#3-5-设置初始化日期\" class=\"headerlink\" title=\"3.5 设置初始化日期\"></a>3.5 设置初始化日期</h3><p>外部可能有选择好的日期，所以我们必须提供一个方法，设置数据。</p>\n<pre><code class=\"line-numbers language-Swift\">extension CalendarView&#123;\n    /// 按照这个date获取这个月的数据\n    func setDate(date: Date = Date())&#123;\n        modelArr.removeAll()\n        let count = YSDateTool.countOfDaysInCurrentMonth(date: date)    //当月天数\n        for i in 0..&lt;count&#123;\n            let model = self.initializeModel(date: date, day: i+1)\n            modelArr.append(model)\n        &#125;\n        let firstWeekDay = YSDateTool.firstWeekDayInCurrentMonth(date: date)    //当月第一天周几\n        \n        //头部空缺数据填充 插入一个空的model\n        if firstWeekDay != 7 &#123;\n            for _ in 0 ..&lt; firstWeekDay&#123;\n                let model = self.initializeModel(date: date, day: 0)\n                modelArr.insert(model, at: 0)\n            &#125;\n        &#125;\n        //尾部空缺数据填充,插入一个空的model\n        if modelArr.count &lt; 35&#123;\n            for _ in modelArr.count ..&lt; 35&#123;\n                let model = self.initializeModel(date: date, day: 0)\n                modelArr.append(model)\n            &#125;\n        &#125;\n        \n        collectionView.reloadData()\n    &#125;\n    \n    /// 初始化数据，返回\n    func initializeModel(date: Date, day: Int)-&gt;TimeModel&#123;\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        let model = TimeModel()\n        model.year = com.year!\n        model.month = com.month!\n        model.day = day\n        \n        // model指代当前时间\n        let monthStr = com.month! &lt; 10 ? &quot;0\\(model.month)&quot; : &quot;\\(model.month)&quot;\n        let dayStr = com.day! &lt; 10 ? &quot;0\\(model.day)&quot; : &quot;\\(model.day)&quot;\n        model.dateStr = &quot;\\(com.year!)-\\(monthStr)-\\(dayStr)&quot;\n        return model\n    &#125;\n&#125;\n</code></pre>\n<p>这里也搞了2个扩展函数，会根据目标日期，获取到该日期的一个月的数据，然后会填充第一天非星期天的情况的数据，也会填最后几天空白区域的数据。</p>\n<h3 id=\"3-6-设置UI\"><a href=\"#3-6-设置UI\" class=\"headerlink\" title=\"3.6 设置UI\"></a>3.6 设置UI</h3><p>有了日期就可以设置UI了，所以我们看下如何填充视图的。</p>\n<pre><code class=\"line-numbers language-Swift\">extension CalendarView &#123;\n    func setUI() &#123;\n        \n        //日历顶部按钮布局\n        self.addSubview(acView)\n        acView.snp.makeConstraints&#123;make in\n            make.leading.trailing.bottom.equalTo(0)\n            make.height.equalTo(ScreenHeight*0.57)\n        &#125;\n        \n        // 加顶部横线 左上角默认位置\n        acView.addSubview(lineView)\n        self.lineViewLayout()\n        \n        // 加预约日期\n        acView.addSubview(dateBtn)\n        dateBtn.snp.makeConstraints&#123;make in\n            make.top.equalTo(11)\n            make.leading.equalTo(28)\n            make.width.equalTo(66)\n            make.height.equalTo(22)\n        &#125;\n        \n        // 预约时间\n        acView.addSubview(timeBtn)\n        timeBtn.snp.makeConstraints&#123;make in\n            make.top.equalTo(11)\n            make.centerX.equalToSuperview()\n            make.width.equalTo(66)\n            make.height.equalTo(22)\n        &#125;\n        \n        // 加取消按钮\n        acView.addSubview(cancelBtn)\n        cancelBtn.snp.makeConstraints&#123;make in\n            make.top.equalTo(11)\n            make.trailing.equalTo(-16)\n            make.width.equalTo(66)\n            make.height.equalTo(22)\n        &#125;\n        \n        \n        // 继续加滚动视图\n        acView.addSubview(scrollView)\n        scrollView.snp.makeConstraints&#123;make in\n            make.top.equalTo(dateBtn.snp.bottom).offset(10)\n            make.leading.trailing.equalToSuperview()\n            make.bottom.equalToSuperview()\n        &#125;\n        \n        // acView添加完毕，现在到内部ScrollView层级了--------------\n    \n        // 加个集合View 集合View因为初始化确定了y轴高度，这里无需重复布局\n        scrollView.addSubview(collectionView)\n        \n        // 再加个pickerView 时间滚轮，这里直接加到ScrollView里面了，也无需布局，直接覆盖到上层的\n        scrollView.addSubview(pickerView)\n        \n        // 先加工具栏\n        scrollView.addSubview(dateToolView)\n        dateToolView.snp.makeConstraints&#123;make in\n            make.top.leading.equalTo(0)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(40)\n        &#125;\n        \n        // 滚动视图再加星期视图\n        scrollView.addSubview(weeksView)\n        weeksView.snp.makeConstraints&#123;make in\n            make.top.equalTo(dateToolView.snp.bottom).offset(4)\n            make.leading.equalTo(0)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(30)\n        &#125;\n        \n        \n        // 处理下工具栏内部布局\n        dateToolView.addSubview(monthLb)\n        monthLb.snp.makeConstraints&#123;make in\n            make.centerY.equalToSuperview()\n            make.centerX.equalToSuperview()\n            make.width.equalTo(100)\n            make.height.equalTo(20)\n        &#125;\n        \n        // 日历工具条加左按钮\n        dateToolView.addSubview(toolLeftBtn)\n        toolLeftBtn.snp.makeConstraints&#123;make in\n            make.centerY.equalToSuperview()\n            make.width.height.equalTo(40)\n            make.leading.equalTo(16)\n        &#125;\n\n        // 日历工具条加右侧箭头\n        dateToolView.addSubview(toolRightBtn)\n        toolRightBtn.snp.makeConstraints&#123;make in\n            make.centerY.equalToSuperview()\n            make.width.height.equalTo(40)\n            make.trailing.equalTo(-16)\n        &#125;\n        \n        // 设置星期几内部布局\n        setWeekUiInner()\n        \n        // 地址底部按钮\n        addBottomUI()\n    \n    &#125;\n</code></pre>\n<p>中规中矩，老老实实从上到下，从左到右布局。</p>\n<p>内部星期几看下如何布局的：</p>\n<pre><code class=\"line-numbers language-Swift\">func setWeekUiInner() &#123;\n        let arr = [&quot;日&quot;,&quot;一&quot;,&quot;二&quot;,&quot;三&quot;,&quot;四&quot;,&quot;五&quot;,&quot;六&quot;]\n\n        for i in 0 ..&lt; arr.count &#123;\n            let width = ScreenWidth/7\n            let lab = UILabel()\n            lab.text = arr[i]\n            lab.textColor = UIColor.init(hex: &quot;#323233&quot;)\n            lab.font = .pingFangRegular(size: 12)\n            lab.textAlignment = .center\n            weeksView.addSubview(lab)\n            lab.snp.makeConstraints&#123;make in\n                make.leading.equalTo(width*CGFloat(i))\n                make.centerY.equalToSuperview()\n                make.width.equalTo(width)\n                make.height.equalTo(20)\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>还有底部的下一步和完成：</p>\n<pre><code class=\"line-numbers language-Swift\">func addBottomUI() &#123;\n        let nextBtn: UIButton = UIButton.init(type: .custom)\n        nextBtn.frame = CGRect.init(x: 16, y: ScreenHeight*0.57*0.57+8+34+40, width: (ScreenWidth-32), height: 44)\n        nextBtn.titleFont = .pingFangMedium(size: 16)\n        nextBtn.setTitleColor(.white, for: .normal)\n        nextBtn.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n        nextBtn.setTitle(&quot;下一步&quot;, for: .normal)\n        nextBtn.layer.cornerRadius = 22\n        nextBtn.addTarget(self, action: #selector(actionForNext), for: .touchUpInside)\n        scrollView.addSubview(nextBtn)\n        \n        let doneBtn: UIButton = UIButton.init(type: .custom)\n        doneBtn.frame = CGRect.init(x: ScreenWidth+16, y: ScreenHeight*0.57*0.57+8+34+40, width: (ScreenWidth-32), height: 44)\n        doneBtn.titleFont = .pingFangMedium(size: 16)\n        doneBtn.setTitleColor(.white, for: .normal)\n        doneBtn.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n        doneBtn.setTitle(&quot;完成&quot;, for: .normal)\n        doneBtn.layer.cornerRadius = 22\n        doneBtn.addTarget(self, action: #selector(actionForDone), for: .touchUpInside)\n        scrollView.addSubview(doneBtn)\n    &#125;\n</code></pre>\n<h3 id=\"3-7-填充数据\"><a href=\"#3-7-填充数据\" class=\"headerlink\" title=\"3.7 填充数据\"></a>3.7 填充数据</h3><p>这里先看下日历数据如何使用代理和数据源的：</p>\n<pre><code class=\"line-numbers language-Swift\">extension CalendarView: UICollectionViewDelegate,UICollectionViewDataSource,UICollectionViewDelegateFlowLayout&#123;\n    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123;\n        return modelArr.count\n    &#125;\n    \n    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123;\n        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: CalendarCell.identifier, for: indexPath) as! CalendarCell\n        cell.model = modelArr[indexPath.item]\n        cell.selectedModel = timeModel\n        return cell\n    &#125;\n\n    // 定义每个Cell的大小\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -&gt; CGSize &#123;\n        let width = ScreenWidth/7\n        let height = modelArr.count &gt; 35 ? (ScreenHeight*0.57*0.57)/6 : (ScreenHeight*0.57*0.57)/5\n        return CGSize(width: width-2, height: height-1)\n    &#125;\n    \n    // 定义每个Section的四边间距\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -&gt; UIEdgeInsets &#123;\n        return UIEdgeInsets(top: 0, left: 3.5, bottom: 0, right: 0)\n    &#125;\n    \n    // 这个是两行cell之间的间距（上下行cell的间距）\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -&gt; CGFloat &#123;\n        return 1.0\n    &#125;\n    \n    // 两个cell之间的间距（同一行的cell的间距）\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Int) -&gt; CGFloat &#123;\n        return 1.0\n    &#125;\n    \n    // 选中某个ietm\n    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) &#123;\n        let model = modelArr[indexPath.item]\n        let com = YSDateTool.currentDateCom()\n        if com.year == model.year &amp;&amp; com.month == model.month &amp;&amp; model.day &lt;= com.day! || model.day == 0&#123;\n            return\n        &#125;\n\n        timeModel.year = model.year\n        timeModel.month = model.month\n        timeModel.day = model.day\n        collectionView.reloadData()\n    &#125;\n&#125;\n</code></pre>\n<p>主要逻辑委托给Cell来实现了。后面再看下。</p>\n<h3 id=\"3-8-UIPickerView数据填充\"><a href=\"#3-8-UIPickerView数据填充\" class=\"headerlink\" title=\"3.8 UIPickerView数据填充\"></a>3.8 UIPickerView数据填充</h3><p>然后看下预约时间如何填充数据的。</p>\n<pre><code class=\"line-numbers language-Swift\">extension CalendarView:UIPickerViewDelegate,UIPickerViewDataSource &#123;\n\n    func numberOfComponents(in pickerView: UIPickerView) -&gt; Int &#123;\n        return 1\n    &#125;\n    \n    func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -&gt; Int &#123;\n        return timeArr.count\n    &#125;\n\n    func pickerView(_ pickerView: UIPickerView, widthForComponent component: Int) -&gt; CGFloat &#123;\n        return ScreenWidth\n    &#125;\n    \n    func pickerView(_ pickerView: UIPickerView, rowHeightForComponent component: Int) -&gt; CGFloat &#123;\n        44\n    &#125;\n    \n    func pickerView(_ pickerView: UIPickerView, viewForRow row: Int, forComponent component: Int, reusing view: UIView?) -&gt; UIView &#123;\n        \n        //设置分割线 pickerView的subvews的第二个一般用来做分割线 subviews会有2个view\n        for view in pickerView.subviews &#123;\n            print(&quot;view.height=\\(view.size.height) 长度为：\\(pickerView.subviews.count)&quot;)\n            if view.size.height &lt;= 50 &#123;\n                view.backgroundColor = .clear\n                //自定义分割线\n                let toplayer = CALayer()\n                toplayer.frame = CGRect.init(x: 0, y: 0, width: ScreenWidth, height: 1)\n                toplayer.backgroundColor = UIColor.init(hex: &quot;#EBEDF0&quot;).cgColor\n                view.layer.addSublayer(toplayer)\n\n                let bottomlayer = CALayer()\n                bottomlayer.frame = CGRect.init(x: 0, y: 44-1, width: ScreenWidth, height: 1)\n                bottomlayer.backgroundColor = UIColor.init(hex: &quot;#EBEDF0&quot;).cgColor\n                view.layer.addSublayer(bottomlayer)\n               \n            &#125;else&#123;\n                view.backgroundColor = .clear\n            &#125;\n        &#125;\n        \n        //设置内容样式\n        var label = view as? UILabel\n        if label == nil &#123;\n            label = UILabel.init()\n            label?.backgroundColor = .clear\n            label?.frame = CGRect.init(x: 0, y: 0, width:ScreenWidth, height:44)\n        &#125;\n        if row == selectIndex &#123;\n            label?.textColor = UIColor.init(hex: &quot;#409EFF&quot;)\n        &#125;else&#123;\n            label?.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n        &#125;\n        label?.textAlignment = .center\n        label?.font = .pingFangRegular(size: 16)\n        //label?.minimumScaleFactor = 0.5\n        //label?.adjustsFontSizeToFitWidth = true\n        label?.text = timeArr[row]\n        return label!\n    &#125;\n    \n    func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) &#123;\n        selectIndex = row\n        pickerView.reloadAllComponents()\n    &#125;\n&#125;\n</code></pre>\n<p>主要逻辑是viewForRow覆写的方法里面。<br>交代了如何绘制分割线和选中高亮显示。<br>这里有个点要注意，这个分割线用到了 UIPickerView的subViews，这里通常设置分割线都要用到这个东西，具体细节我不是很清楚，预测这个subViews第二个就是居中的item。第一个item很长，不能用来分割线。</p>\n<p>然后就是didSelectRow用来响应用户点击事件，需要刷新下components。</p>\n<h3 id=\"3-9-交互事件\"><a href=\"#3-9-交互事件\" class=\"headerlink\" title=\"3.9 交互事件\"></a>3.9 交互事件</h3><p>这里交互事件统一用一个扩展类来实现。</p>\n<pre><code class=\"line-numbers language-Swift\">extension CalendarView &#123;\n    \n    @objc func actionForChooseDate()&#123;\n        self.lineViewLayout()\n        self.scrollDate()\n    &#125;\n    \n    @objc func actionForChooseTime()&#123;\n        self.lineViewLayout(leading: 1)\n        self.scrollTime()\n    &#125;\n    \n    @objc func actionForCancel()&#123;\n        self.dismissAlertView()\n    &#125;\n    \n    @objc func actionForLeftEvent()&#123;\n        dynamicDate = YSDateTool.lastMonth(date: dynamicDate)\n        self.isRefrenshMonth()\n    &#125;\n    \n    @objc func actionForRightEvent()&#123;\n        dynamicDate = YSDateTool.nextMonth(date: dynamicDate)\n        self.isRefrenshMonth()\n    &#125;\n    \n    @objc func actionForNext()&#123;\n        self.lineViewLayout(leading: 1)\n        self.scrollTime()\n    &#125;\n    \n    @objc func actionForDone()&#123;\n        if doneHandle != nil &#123;\n            let str = timeArr[selectIndex]\n            let arr = str.components(separatedBy: CalendarView.range)\n            timeModel.startTime = arr[0]\n            timeModel.endTime = arr[1]\n            \n            let monthStr = timeModel.month &lt; 10 ? &quot;0\\(timeModel.month)&quot; : &quot;\\(timeModel.month)&quot;\n            let dayStr = timeModel.day &lt; 10 ? &quot;0\\(timeModel.day)&quot; : &quot;\\(timeModel.day)&quot;\n            timeModel.dateStr = &quot;\\(timeModel.year)-\\(monthStr)-\\(dayStr)&quot;\n            \n            doneHandle(timeModel)\n        &#125;\n        self.dismissAlertView()\n    &#125;\n    \n    // 滑动到日期\n    func scrollDate()&#123;\n        dateBtn.isSelected = true\n        timeBtn.isSelected = false\n        scrollView.setContentOffset(CGPoint.init(x: 0, y: 0), animated: true)\n    &#125;\n    \n    // 滑动到时间\n    func scrollTime()&#123;\n        dateBtn.isSelected = false\n        timeBtn.isSelected = true\n        scrollView.setContentOffset(CGPoint.init(x: ScreenWidth, y: 0), animated: true)\n    &#125;\n    \n    func isRefrenshMonth()&#123;\n        self.setDate(date: dynamicDate)\n        let com = YSDateTool.currentDateCom(date: dynamicDate)\n        monthLb.text = &quot;\\(com.year!)年\\(com.month!)月&quot;\n        watermarkView.monthStr = &quot;\\(com.month!)&quot;\n        \n        let currentCom = YSDateTool.currentDateCom()\n        if (com.year! == currentCom.year!  &amp;&amp; com.month! &gt; currentCom.month!) || (com.year! &gt; currentCom.year!)&#123;\n            toolLeftBtn.isHidden = false\n        &#125;else&#123;\n            toolLeftBtn.isHidden = true\n        &#125;\n    &#125;\n    \n    func lineViewLayout(leading: Int = 0)&#123;\n        lineView.snp.remakeConstraints&#123;make in\n            make.top.equalTo(0)\n            if leading == 0 &#123;\n                make.leading.equalTo(leading)\n            &#125;else&#123;\n                make.centerX.equalToSuperview() // 居中了\n            &#125;\n            make.width.equalTo(66+56) // 宽度\n            make.height.equalTo(2)  // 高度\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"4-撸下时间工具\"><a href=\"#4-撸下时间工具\" class=\"headerlink\" title=\"4 撸下时间工具\"></a>4 撸下时间工具</h2><p>这个只是个单纯工具，不必重复造轮子。</p>\n<pre><code class=\"line-numbers language-Swift\">class YSDateTool &#123;\n    // MARK: - 当前时间组件\n    static func currentDateCom(date: Date = Date()) -&gt; DateComponents&#123;\n        let calendar = Calendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com\n    &#125;\n    // MARK: - 今年\n    static func currentYear(date: Date = Date()) -&gt; Int &#123;\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com.year!\n    &#125;\n  \n    // MARK: - 今月\n    static func currentMonth(date: Date = Date()) -&gt; Int &#123;\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com.month!\n    &#125;\n  \n    // MARK: - 今日\n    static func currentDay(date: Date = Date()) -&gt; Int &#123;\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com.day!\n    &#125;\n    \n    // MARK: - 今天星期几\n    static func currentWeekDay(date: Date = Date()) -&gt; Int &#123;\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.weekday], from: date)\n        return com.weekday!\n    &#125;\n    \n    // MARK: - 农历今年\n    static func currentChineseYear(date: Date = Date()) -&gt; String &#123;\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.year], from: date)\n        return numberToChina(yearNum: (com?.year)!) + &quot;年&quot;\n    &#125;\n    \n    // MARK: - 农历今月\n    static func currentChineseMonth(date: Date = Date()) -&gt; String &#123;\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.month], from: date)\n        return numberToChina(monthNum: (com?.month)!)\n    &#125;\n\n    // MARK: - 农历今日\n    static func currentChineseDay(date: Date = Date()) -&gt; String &#123;\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.day], from: date)\n        return numberToChina(dayNum: (com?.day)!)\n    &#125;\n    \n    // MARK: - 农历今日\n    static func currentChineseDayInt(date: Date = Date()) -&gt; Int &#123;\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.day], from: date)\n        return (com?.day)!\n    &#125;\n    \n    // MARK: - 农历星期\n    static func currentChineseWeekYear(date: Date = Date()) -&gt; String &#123;\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.weekday], from: date)\n        return numberToChina(weekNum: (com?.weekday)!)\n    &#125;\n  \n    // MARK: - 下个月\n    static func nextMonth(date: Date = Date()) -&gt; Date &#123;\n        let calendar = NSCalendar.current\n        let nDate = calendar.date(byAdding: DateComponents(month: 1), to: date)\n        return nDate!\n    &#125;\n    \n    // MARK: - 上个月\n    static func lastMonth(date: Date = Date()) -&gt; Date &#123;\n        let calendar = NSCalendar.current\n        let lDate = calendar.date(byAdding: DateComponents(month: -1), to: date)\n        return lDate!\n    &#125;\n    \n    // MARK: - 下一天\n    static func lastDay(date: Date = Date()) -&gt; Date&#123;\n        let calendar = NSCalendar.current\n        let lDate = calendar.date(byAdding: DateComponents(day: 1), to: date)\n        return lDate!\n    &#125;\n  \n    // MARK: - 本月天数\n    static func countOfDaysInCurrentMonth(date: Date = Date()) -&gt; Int &#123;\n        let calendar = Calendar(identifier: Calendar.Identifier.gregorian)\n        let range = (calendar as NSCalendar?)?.range(of: NSCalendar.Unit.day, in: NSCalendar.Unit.month, for: date)\n        return (range?.length)!\n    &#125;\n \n    // MARK: - 当月第一天是星期几\n    static func firstWeekDayInCurrentMonth(date: Date = Date()) -&gt; Int &#123;\n        // 星期和数字一一对应 星期日：7\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = &quot;yyyy-MM&quot;\n        let date = dateFormatter.date(from: String(date.xj.year)+&quot;-&quot;+String(date.xj.month))\n        let calender = Calendar(identifier: Calendar.Identifier.gregorian)\n        let comps = (calender as NSCalendar?)?.components(NSCalendar.Unit.weekday, from: date!)\n        var week = comps?.weekday\n        if week == 1 &#123;\n            week = 8\n        &#125;\n        return week! - 1\n    &#125;\n\n    // MARK: - - 获取指定日期各种值\n    // 根据年月得到某月天数\n    static func getCountOfDaysInMonth(year: Int, month: Int) -&gt; Int&#123;\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = &quot;yyyy-MM&quot;\n        let date = dateFormatter.date(from: String(year)+&quot;-&quot;+String(month))\n        let calendar = Calendar(identifier: Calendar.Identifier.gregorian)\n        let range = (calendar as NSCalendar?)?.range(of: NSCalendar.Unit.day, in: NSCalendar.Unit.month, for: date!)\n        return (range?.length)!\n    &#125;\n    \n    // MARK: - 根据年月得到某月第一天是周几\n    static func getfirstWeekDayInMonth(year: Int, month: Int) -&gt; Int&#123;\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = &quot;yyyy-MM&quot;\n        let date = dateFormatter.date(from: String(year)+&quot;-&quot;+String(month))\n        let calendar = Calendar(identifier: Calendar.Identifier.gregorian)\n        let comps = (calendar as NSCalendar?)?.components(NSCalendar.Unit.weekday, from: date!)\n        let week = comps?.weekday\n        return week! - 1\n    &#125;\n\n    // MARK: - date转日期字符串\n    static func dateToDateString(_ date: Date, dateFormat: String) -&gt; String &#123;\n        let timeZone = NSTimeZone.default\n        let formatter = DateFormatter()\n        formatter.timeZone = timeZone\n        formatter.dateFormat = dateFormat\n        let date = formatter.string(from: date)\n        return date\n    &#125;\n\n    // MARK: - 日期字符串转date\n    static func dateStringToDate(_ dateStr: String) -&gt; Date &#123;\n        let dateFormatter = DateFormatter()\n        dateFormatter.timeZone = TimeZone(abbreviation: &quot;UTC+8&quot;)\n        dateFormatter.dateFormat = &quot;yyyy-MM-dd&quot;\n        let date = dateFormatter.date(from: dateStr)\n        return date!\n    &#125;\n    \n    // MARK: - 时间字符串转date\n    static func timeStringToDate(_ dateStr: String) -&gt; Date &#123;\n        let dateFormatter = DateFormatter()\n        dateFormatter.timeZone = TimeZone(abbreviation: &quot;UTC+8&quot;)\n        dateFormatter.dateFormat = &quot;yyyy-MM-dd HH:mm:ss&quot;\n        let date = dateFormatter.date(from: dateStr)\n        return date!\n    &#125;\n\n    // MARK: - 计算天数差\n    static func dateDifference(_ dateA: Date, from dateB: Date) -&gt; Double &#123;\n        let interval = dateA.timeIntervalSince(dateB)\n        return interval/86400\n    &#125;\n\n    // MARK: - 比较时间先后\n    static func compareOneDay(oneDay: Date, withAnotherDay anotherDay: Date) -&gt; Int &#123;\n        let dateFormatter: DateFormatter = DateFormatter()\n        dateFormatter.dateFormat = &quot;yyyy-MM-dd&quot;\n        let oneDayStr: String = dateFormatter.string(from: oneDay)\n        let anotherDayStr: String = dateFormatter.string(from: anotherDay)\n        let dateA = dateFormatter.date(from: oneDayStr)\n        let dateB = dateFormatter.date(from: anotherDayStr)\n        let result: ComparisonResult = (dateA?.compare(dateB!))!\n        // Date1 is in the future\n        if(result == ComparisonResult.orderedDescending ) &#123;\n            return 1\n        &#125;\n        // Date1 is in the past\n        else if(result == ComparisonResult.orderedAscending) &#123;\n            return 2\n        &#125;\n            // Both dates are the same\n        else &#123;\n            return 0\n        &#125;\n    &#125;\n\n    // MARK: - 时间与时间戳之间的转化\n    // 将时间转换为时间戳\n    static func stringToTimeStamp(_ stringTime: String) -&gt; Int &#123;\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat = &quot;yyyy-MM-dd HH: mm: ss&quot;\n        dfmatter.locale = Locale.current\n        let date = dfmatter.date(from: stringTime)\n        let dateStamp: TimeInterval = date!.timeIntervalSince1970\n        let dateSt: Int = Int(dateStamp)\n        return dateSt\n    &#125;\n    \n    // 将时间戳转换为年月日\n    static func timeStampToString(_ timeStamp: String) -&gt; String &#123;\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=&quot;yyyy年MM月dd日&quot;\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    &#125;\n    \n    // 将时间戳转换为具体时间\n    static func timeStampToStringDetail(_ timeStamp: String) -&gt; String &#123;\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=&quot;yyyy年MM月dd日HH: mm: ss&quot;\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    &#125;\n    \n    // 将时间戳转换为时分秒\n    static func timeStampToHHMMSS(_ timeStamp: String) -&gt; String &#123;\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=&quot;HH: mm: ss&quot;\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    &#125;\n    \n    // 将时间戳转换为时分\n    static func timeStampToHHMM(_ timeStamp: String) -&gt; String &#123;\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=&quot;HH: mm&quot;\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    &#125;\n    \n    // 获取系统的当前时间戳\n    static func getStamp(date: Date = Date()) -&gt; Int&#123;\n        // 获取当前时间戳\n        let timeInterval: Int = Int(date.timeIntervalSince1970)\n        return timeInterval\n    &#125;\n    \n    // 日数字转汉字\n    static func numberToChina(yearNum: Int) -&gt; String &#123;\n        // 以一个天干和一个地支相配，排列起来，天干在前，地支在后，天干由甲起，地支由子起，阳干对阳支，阴干对阴支（阳干不配阴支，阴干不配阳支）\n        // 就会得到六十年一周期的甲子回圈，一般称为“六十甲子”或“花甲子”\n        // 十天干： 甲（jiǎ）、乙（yǐ）、丙（bǐng）、丁（dīng）、戊（wù）、己（jǐ）、庚（gēng）、辛（xīn）、壬（rén）、癸（guǐ）\n        // 十二地支： 子（zǐ）、丑（chǒu）、寅（yín）、卯（mǎo）、辰（chén）、巳（sì）、午（wǔ）、未（wèi）、申（shēn）、酉（yǒu）、戌（xū）、亥（hài）\n        let ChinaArray = [ &quot;甲子&quot;, &quot;乙丑&quot;, &quot;丙寅&quot;, &quot;丁卯&quot;, &quot;戊辰&quot;, &quot;己巳&quot;, &quot;庚午&quot;, &quot;辛未&quot;, &quot;壬申&quot;, &quot;癸酉&quot;,\n                         &quot;甲戌&quot;, &quot;乙亥&quot;, &quot;丙子&quot;, &quot;丁丑&quot;, &quot;戊寅&quot;, &quot;己卯&quot;, &quot;庚辰&quot;, &quot;辛己&quot;, &quot;壬午&quot;, &quot;癸未&quot;,\n                         &quot;甲申&quot;, &quot;乙酉&quot;, &quot;丙戌&quot;, &quot;丁亥&quot;, &quot;戊子&quot;, &quot;己丑&quot;, &quot;庚寅&quot;, &quot;辛卯&quot;, &quot;壬辰&quot;, &quot;癸巳&quot;,\n                         &quot;甲午&quot;, &quot;乙未&quot;, &quot;丙申&quot;, &quot;丁酉&quot;, &quot;戊戌&quot;, &quot;己亥&quot;, &quot;庚子&quot;, &quot;辛丑&quot;, &quot;壬寅&quot;, &quot;癸丑&quot;,\n                         &quot;甲辰&quot;, &quot;乙巳&quot;, &quot;丙午&quot;, &quot;丁未&quot;, &quot;戊申&quot;, &quot;己酉&quot;, &quot;庚戌&quot;, &quot;辛亥&quot;, &quot;壬子&quot;, &quot;癸丑&quot;,\n                         &quot;甲寅&quot;, &quot;乙卯&quot;, &quot;丙辰&quot;, &quot;丁巳&quot;, &quot;戊午&quot;, &quot;己未&quot;, &quot;庚申&quot;, &quot;辛酉&quot;, &quot;壬戌&quot;, &quot;癸亥&quot;]\n        let ChinaStr: String = ChinaArray[yearNum - 1]\n        return ChinaStr\n    &#125;\n    \n    // 月份数字转汉字\n    static func numberToChina(monthNum: Int) -&gt; String &#123;\n        let ChinaArray = [&quot;一月&quot;, &quot;二月&quot;, &quot;三月&quot;, &quot;四月&quot;, &quot;五月&quot;, &quot;六月&quot;, &quot;七月&quot;, &quot;八月&quot;, &quot;九月&quot;, &quot;十月&quot;, &quot;十一月&quot;, &quot;十二月&quot;]\n        let ChinaStr: String = ChinaArray[monthNum - 1]\n        return ChinaStr\n    &#125;\n    \n    // 日数字转汉字\n    static func numberToChina(dayNum: Int) -&gt; String &#123;\n        let ChinaArray = [ &quot;初一&quot;, &quot;初二&quot;, &quot;初三&quot;, &quot;初四&quot;, &quot;初五&quot;, &quot;初六&quot;, &quot;初七&quot;, &quot;初八&quot;, &quot;初九&quot;, &quot;初十&quot;,\n                         &quot;十一&quot;, &quot;十二&quot;, &quot;十三&quot;, &quot;十四&quot;, &quot;十五&quot;, &quot;十六&quot;, &quot;十七&quot;, &quot;十八&quot;, &quot;十九&quot;, &quot;二十&quot;,\n                         &quot;廿一&quot;, &quot;廿二&quot;, &quot;廿三&quot;, &quot;廿四&quot;, &quot;廿五&quot;, &quot;廿六&quot;, &quot;廿七&quot;, &quot;廿八&quot;, &quot;廿九&quot;, &quot;三十&quot;]\n        let ChinaStr: String = ChinaArray[dayNum - 1]\n        return ChinaStr\n    &#125;\n      \n    // 星期数字转汉字\n    static func numberToChina(weekNum: Int) -&gt; String &#123;\n        let ChinaArray = [&quot;一月&quot;, &quot;二月&quot;, &quot;三月&quot;, &quot;四月&quot;, &quot;五月&quot;, &quot;六月&quot;, &quot;七月&quot;, &quot;八月&quot;, &quot;九月&quot;, &quot;十月&quot;, &quot;十一月&quot;, &quot;十二月&quot;]\n        let ChinaStr: String = ChinaArray[weekNum - 1]\n        return ChinaStr\n    &#125;\n    \n    // MARK: - 数字前补0\n    static func add0BeforeNumber(_ number: Int) -&gt; String &#123;\n        if number &gt;= 10 &#123;\n            return String(number)\n        &#125;else&#123;\n            return &quot;0&quot; + String(number)\n        &#125;\n    &#125;\n    \n    static func getCurrentSystemDate() -&gt; Date&#123;\n        let date = Date() // 获得时间对象\n        let zone = NSTimeZone.system // 获得系统的时区\n        let time = zone.secondsFromGMT(for: date)// 以秒为单位返回当前时间与系统格林尼治时间的差\n        return date.addingTimeInterval(TimeInterval(time))// 然后把差的时间加上,就是当前系统准确的时间\n    &#125;\n    \n    static func date(_ date: String?, dateFormat: String = &quot;yyyy-MM-dd&quot;) -&gt; Date? &#123;\n        guard let date = date else &#123;\n            return nil\n        &#125;\n        let dateformatter = DateFormatter()\n        dateformatter.timeZone = TimeZone.init(secondsFromGMT: 0)\n        dateformatter.dateFormat = dateFormat\n        return dateformatter.date(from: date)\n    &#125;\n\n    // MARK: - 将时间显示为（几分钟前，几小时前，几天前）\n    static func compareCurrentTime(str: String) -&gt; String &#123;\n        //let currentDateStr = dateToDateString(Date(), dateFormat: &quot;yyyy-MM-dd hh:mm:ss&quot;)\n        let currentDate = getCurrentSystemDate()\n        let sendTimeDate = date(str,dateFormat: &quot;yyyy-MM-dd HH:mm:ss&quot;)!//self.timeStringToDate(str)\n        let sendTimeInterval = Double(getStamp(date: sendTimeDate))\n        let timeInterval = currentDate.timeIntervalSince(sendTimeDate)\n\n        var todayStr = dateToDateString(Date(), dateFormat: &quot;yyyy-MM-dd&quot;)\n        todayStr = todayStr+&quot; 00:00&quot;\n        let todayTimeInterval = Double(Date().stringToSecondTimeStamp(todayStr)) ?? 0\n        let yestDayTimeInterval = Double(todayTimeInterval - 86400)\n        let nextDayTimeInterval = Double(todayTimeInterval + 86400)\n\n        var temp: Double = 0\n        var result: String = &quot;&quot;\n        if timeInterval/60 &lt; 1 &#123;\n            result = &quot;刚刚&quot;\n        &#125;else if (timeInterval/60) &lt; 60&#123;\n            temp = timeInterval/60\n            result = &quot;\\(Int(temp))分钟前&quot;\n        &#125;else if sendTimeInterval &gt; todayTimeInterval &amp;&amp; sendTimeInterval &lt; nextDayTimeInterval&#123;\n\n            //let interval = nextDayTimeInterval - sendTimeInterval\n            temp = timeInterval/60/60\n            result = &quot;\\(Int(temp))小时前&quot;\n        &#125;else if sendTimeInterval &gt; yestDayTimeInterval &amp;&amp; sendTimeInterval &lt; todayTimeInterval&#123;\n            //let str = timeStampToHHMM(String.init(format: &quot;%d&quot;, sendTimeInterval))\n            let timeStr = str.components(separatedBy: &quot; &quot;).last ?? &quot;&quot;\n            let str = timeStr.prefix(5)\n            result = &quot;昨天\\(str)&quot;\n        &#125;else&#123;\n            let timeStr = str.components(separatedBy: &quot; &quot;).first ?? &quot;&quot;\n            let timeArr = timeStr.components(separatedBy: &quot;-&quot;)\n            if !timeArr.isEmpty &#123;\n                result = &quot;\\(timeArr[0])年\\(timeArr[1])月\\(timeArr[2])日&quot;\n            &#125;\n            //result = timeStampToString(String.init(format: &quot;%d&quot;, sendTimeInterval))\n        &#125;\n        \n//        else if timeInterval/(30 * 24 * 60 * 60) &lt; 12 &#123;\n//            temp = timeInterval/(30 * 24 * 60 * 60)\n//            result = &quot;\\(Int(temp))个月前&quot;\n//        &#125;else&#123;\n//            temp = timeInterval/(12 * 30 * 24 * 60 * 60)\n//            result = &quot;\\(Int(temp))年前&quot;\n//        &#125;\n        return result\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"5-撸下最后的日历Cell\"><a href=\"#5-撸下最后的日历Cell\" class=\"headerlink\" title=\"5 撸下最后的日历Cell\"></a>5 撸下最后的日历Cell</h2><p>这个就是日历里面的item，还是相当简单的。</p>\n<h3 id=\"5-1-全局变量\"><a href=\"#5-1-全局变量\" class=\"headerlink\" title=\"5.1 全局变量\"></a>5.1 全局变量</h3><pre><code class=\"line-numbers language-Swift\">class CalendarCell: UICollectionViewCell &#123;\n    \n    static var identifier = &quot;UICollectionViewCell&quot;\n    \n    var isGreaterThan: Bool = false     //是否取大于今天的值\n    \n    var isShowPassTime: Int = 0         //是否设定禁选\n    \n    var model:TimeModel?&#123;\n        didSet&#123;\n            guard let _model = model else &#123;return&#125;\n            if _model.day != 0 &#123;\n                titleLab.text = &quot;\\(_model.day)&quot;\n            &#125;else&#123;\n                titleLab.text = &quot;&quot; // 为0，啥也不显示\n            &#125;\n            \n            let com = YSDateTool.currentDateCom()\n            \n            // 是否是选中的日子\n            if com.year == _model.year &amp;&amp; com.month == _model.month &amp;&amp; com.day == _model.day &#123;\n                titleLab.textColor = UIColor.init(hex: &quot;#409EFF&quot;)\n            &#125;else&#123;\n                titleLab.textColor = UIColor.init(hex: &quot;#323233&quot;)\n            &#125;\n            \n            // 禁用还是可用\n            if isShowPassTime == 0 &#123;\n                if isGreaterThan &#123;\n                    if (com.year == _model.year &amp;&amp; com.month == _model.month &amp;&amp; _model.day &gt; com.day!) || (_model.year == com.year! &amp;&amp; _model.month &gt; com.month!) || (_model.year &gt; com.year!)&#123;\n                        titleLab.textColor = UIColor.init(hex: &quot;#C8C9CC&quot;)\n                    &#125;\n                &#125;else&#123;\n                    // 如果要大于今天，那么前面的时间就的置灰了 前一个月的点不过去，不考虑了\n                    if com.year == _model.year &amp;&amp; com.month == _model.month &amp;&amp; _model.day &lt; com.day!&#123;\n                        titleLab.textColor = UIColor.init(hex: &quot;#C8C9CC&quot;)\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    \n    // 选中的item，背景颜色高亮\n    var selectedModel: TimeModel?&#123;\n        didSet&#123;\n            guard let _model = selectedModel else&#123;return&#125;\n            if _model.year == model?.year &amp;&amp; _model.month == model?.month &amp;&amp; _model.day == model?.day&#123;\n                titleLab.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n                titleLab.textColor = UIColor.white\n            &#125;else&#123;\n                titleLab.backgroundColor = UIColor.clear\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>比较重要的是model，表示当前时间实体类。这里监听变量改变，利用didSet实现动态改变文案效果。</p>\n<p>另外一个是selectedModel，这个是当前选中的item，会比对item是否为选中，选中样式会有所不同。</p>\n<h3 id=\"5-2-UI子View\"><a href=\"#5-2-UI子View\" class=\"headerlink\" title=\"5.2 UI子View\"></a>5.2 UI子View</h3><p>这里只用到一个子View。</p>\n<pre><code class=\"line-numbers language-Swift\">var titleLab: UILabel = &#123;\n        let lan = UILabel()\n        lan.font = .pingFangRegular(size: 16)\n        lan.textAlignment = .center\n        lan.textColor = UIColor.init(hex: &quot;#323233&quot;)\n        \n        lan.layer.cornerRadius = 4\n        lan.layer.masksToBounds = true\n        return lan\n    &#125;()\n</code></pre>\n<h3 id=\"5-3-生命周期函数\"><a href=\"#5-3-生命周期函数\" class=\"headerlink\" title=\"5.3 生命周期函数\"></a>5.3 生命周期函数</h3><pre><code class=\"line-numbers language-Swift\">override init(frame: CGRect) &#123;\n        super.init(frame: frame)\n        contentView.backgroundColor = .clear\n        contentView.addSubview(titleLab)\n        titleLab.snp.makeConstraints&#123;make in\n            make.top.bottom.leading.trailing.equalToSuperview()\n        &#125;\n    &#125;\n    \n    required init?(coder aDecoder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n</code></pre>\n<p>把那个子View添加到Cell里面去了。</p>\n<p>大概就是这样子。</p>\n<h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6 总结\"></a>6 总结</h2><ul>\n<li><p>如果UI图有那种Tab页，就可以考虑使用多种方案来实现，iOS直接用简单的Button也是可以实现的，分割线也是可以用最简单的UIView来实现，不一定要用封装好的框架，谁用挖掘机来搬小石头呢，大材小用了。</p>\n</li>\n<li><p>分页效果可以使用UIScrollView来实现，把它宽度设置为屏幕的n倍，这样最有滑动可以很好控制的，不要动画也可以设置的，办法总是就很多的。</p>\n</li>\n<li><p>日历效果可以用UICollectionView来实现，看着很复杂，其实很简单，主要逻辑也不复杂，控制好数据刷新就好了。UICollectionView可以实现类似网格的效果，我们只需要在Cell里面绘制一个一个Cell，空的部分，我们啥不展示就好了。</p>\n</li>\n<li><p>系统的UIPickerView设置分割线很简单，利用UIPickerView下有一个subViews，这里寻找高度为item高度大小的，然后给view设置一个Layer即可。</p>\n</li>\n</ul>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-需求分析\"><a href=\"#1-需求分析\" class=\"headerlink\" title=\"1 需求分析\"></a>1 需求分析</h2><p>当我们选择购买一个东西时，有时需要预约发货，这时候需要用户手动选择某一天某一个时间，ui给的方案是这样的：<br>预约日期：<br><img src=%E9%A2%84%E7%BA%A6%E6%97%A5%E6%9C%9F.png></p>\n<p>预约时间：<br><img src=%E9%A2%84%E7%BA%A6%E6%97%B6%E9%97%B4.png><br>这里是间隔了2个小时一个时间。</p>\n<p>可以看到这个日期是以日历形式展现，可以选择未来某个日期；时间是以滚轮的方式展现，可以上下滑动到目标时间点。</p>\n<p>对于这个需求，我们要如何实现呢？‘</p>\n<p>答案当然是自定义View了。</p>\n<h2 id=\"2-结构分析\"><a href=\"#2-结构分析\" class=\"headerlink\" title=\"2 结构分析\"></a>2 结构分析</h2><p>显而易见，这个因为设计到分页，我们可以考虑分页区域使用一个UIScrollView，水平滑动，宽度设置为屏幕的2倍，一半用来展示日历，一半用来展示预约时间的UIPickerView。</p>\n<p>所以需要我们自定义一个UIView，这里面先绘制顶部分割线，再绘制标题，“预约日期”和“预约时间”和“取消”的文案。</p>\n<p>然后是一个显示日历操作栏，包括左右箭头和中间的月份显示，这个要放到UIScrollView的左半边，包括星期视图和日历的UICollectionView的集合View，这里日历我们采用这个集合View很容易实现的。</p>\n<p>然后右侧就是一个UIPickerView,这个系统封装好了，使用很方便，我们主要负责填充数据。</p>\n<p>那这个结构大体出来了，一个是整个自定义View，暂且把它叫做CalenderView，还有一个就是日历内部的Cell，暂且叫做CalenderCell。</p>\n<h2 id=\"3-撸下CalenderView\"><a href=\"#3-撸下CalenderView\" class=\"headerlink\" title=\"3 撸下CalenderView\"></a>3 撸下CalenderView</h2><h3 id=\"3-1-全局变量\"><a href=\"#3-1-全局变量\" class=\"headerlink\" title=\"3.1 全局变量\"></a>3.1 全局变量</h3><pre><code class=\"line-numbers language-Swift\">class CalendarView: UIView &#123;\n    \n    /// 传出去给调用者\n    typealias DoneBlock = (TimeModel)-&gt;()\n    var doneHandle: DoneBlock!\n    \n    // 当月日期Model\n    var modelArr: [TimeModel] = []\n    \n    // 动态调整上下月的时间变量\n    var dynamicDate = Date()\n    \n    //默认选中的日期\n    var timeModel: TimeModel = TimeModel()\n    \n    //时间时短数据\n    static let range: String = &quot;                      &quot;\n    private var timeArr: [String] = [&quot;08:00\\(range)10:00&quot;,\n                                   &quot;10:00\\(range)12:00&quot;,\n                                   &quot;12:00\\(range)14:00&quot;,\n                                   &quot;14:00\\(range)16:00&quot;,\n                                   &quot;16:00\\(range)18:00&quot;,\n                                   &quot;18:00\\(range)20:00&quot;,\n                                   &quot;20:00\\(range)22:00&quot;]\n    private var selectIndex = 0\n    \n</code></pre>\n<p>这里定义了一个闭包返回，主要是用户选择后，回调给外部。</p>\n<p>然后有一个TimeModel的数组， 也就是填充我们的日历视图。</p>\n<p>timeModel是我们选择的日期，会高亮显示。</p>\n<p>timeArr是我们右侧使用的UIPickerView要用的数据。</p>\n<h3 id=\"3-2-UI定义\"><a href=\"#3-2-UI定义\" class=\"headerlink\" title=\"3.2 UI定义\"></a>3.2 UI定义</h3><p>这里我们大致会用到这些视图。</p>\n<pre><code class=\"line-numbers language-Swift\">//白色背景底 整个半屏的视图\nprivate lazy var acView: UIView = &#123;\n    let view = UIView()\n    view.backgroundColor = .white\n    return view\n&#125;()\n\n//选中条\nprivate lazy var lineView: UIView = &#123;\n    let view = UIView()\n    view.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n    return view\n&#125;()\n\n/// 预约日期按钮\nprivate lazy var dateBtn: UIButton = &#123;\n    let btn = UIButton()\n    btn.setTitle(&quot;预约日期&quot;, for: .normal)\n    btn.titleFont = .pingFangMedium(size: 16)\n    btn.setTitleColor(UIColor.lightGray, for: .normal)\n    btn.setTitleColor(UIColor.black, for: .selected)\n    btn.addTarget(self, action: #selector(actionForChooseDate), for: .touchUpInside)\n    btn.isSelected = true\n    return btn\n&#125;()\n\n/// 预约时间按钮\nprivate lazy var timeBtn: UIButton = &#123;\n    let btn = UIButton()\n    btn.setTitle(&quot;预约时间&quot;, for: .normal)\n    btn.titleFont = .pingFangMedium(size: 16)\n    btn.setTitleColor(UIColor.lightGray, for: .normal)\n    btn.setTitleColor(UIColor.black, for: .selected)\n    btn.addTarget(self, action: #selector(actionForChooseTime), for: .touchUpInside)\n    return btn\n&#125;()\n\n/// 取消按钮\nprivate lazy var cancelBtn: UIButton = &#123;\n    let btn = UIButton()\n    btn.setTitle(&quot;取消&quot;, for: .normal)\n    btn.setTitleColor(UIColor.init(hex: &quot;#409EFF&quot;), for: .normal)\n    btn.titleFont = .pingFangRegular(size: 16)\n    btn.addTarget(self, action: #selector(actionForCancel), for: .touchUpInside)\n    return btn\n&#125;()\n\n//日历工具条\nprivate lazy var dateToolView: UIView = &#123;\n    let view = UIView()\n    return view\n&#125;()\n\n//日历工具条显示当前月份标签\nprivate lazy var monthLb: UILabel = &#123;\n    let lab = UILabel()\n    lab.font = .pingFangMedium(size: 16)\n    lab.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n    lab.text = &quot;&quot;\n    lab.textAlignment = .center\n    return lab\n&#125;()\n\n//日历工具条左箭头\nprivate lazy var toolLeftBtn: UIButton = &#123;\n    let btn = UIButton()\n    btn.setImage(UIImage.init(named: &quot;日历_左箭头&quot;), for: .normal)\n    btn.addTarget(self, action: #selector(actionForLeftEvent), for: .touchUpInside)\n    btn.isHidden = true\n    return btn\n&#125;()\n\n//日历工具条右箭头\nprivate lazy var toolRightBtn: UIButton =  &#123;\n    let btn = UIButton()\n    btn.setImage(UIImage.init(named: &quot;日历_右箭头&quot;), for: .normal)\n    btn.addTarget(self, action: #selector(actionForRightEvent), for: .touchUpInside)\n    return btn\n&#125;()\n\n//星期X显示条\nprivate lazy var weeksView: UIView = &#123;\n    let view = UIView()\n    view.backgroundColor = .white\n    view.layer.shadowColor = UIColor.init(hex: &quot;#7D7E80&quot;).cgColor\n    view.layer.shadowOffset = CGSize.init(width: 0, height: 2)\n    view.layer.shadowRadius = 10\n    view.layer.shadowOpacity = 0.16\n    return view\n&#125;()\n\n//滚动视图 左右滚动\nprivate lazy var scrollView: UIScrollView = &#123;\n    let _scrollView = UIScrollView()\n    _scrollView.contentSize = CGSize.init(width: ScreenWidth*2, height: _scrollView.size.height)\n    _scrollView.bounces = false\n    _scrollView.isScrollEnabled = true\n    _scrollView.isPagingEnabled = true\n    _scrollView.showsVerticalScrollIndicator = false\n    _scrollView.showsHorizontalScrollIndicator = false\n    return _scrollView\n&#125;()\n\n//月份水印背景\nprivate lazy var watermarkView: CalendarWatermark = &#123;\n    let view = CalendarWatermark()\n    view.backgroundColor = .white\n    view.isHidden = true  //当前版本隐藏水印\n    return view\n&#125;()\n\n//日历展示表\n    private lazy var collectionView: UICollectionView = &#123;\n        let layout = UICollectionViewFlowLayout()\n        layout.scrollDirection = .vertical\n        let collection = UICollectionView(frame: CGRect.init(x: 0, y: 34+40, width: ScreenWidth, height: ScreenHeight*0.57*0.57), collectionViewLayout: layout)\n        collection.backgroundColor = .clear\n        collection.delegate = self\n        collection.dataSource = self\n        collection.isPagingEnabled = true\n        collection.showsHorizontalScrollIndicator = false\n        collection.bounces = false\n        collection.register(CalendarCell.self, forCellWithReuseIdentifier: CalendarCell.identifier)\n        return collection\n&#125;()\n\n//时间选择器 x轴以 屏幕宽度为起点，刚好在第二屏了\nprivate lazy var pickerView: UIPickerView = &#123;\n    let picker = UIPickerView.init(frame: CGRect.init(x: ScreenWidth, y: 0, width: ScreenWidth, height: ScreenHeight*0.57*0.57+34+40))\n    picker.delegate = self\n    picker.dataSource = self\n    return picker\n&#125;()\n</code></pre>\n<p>这些需要用代理和数据源的都设置self，后面再具体实现。</p>\n<p>这里可以认为是我们搭建房子用到的一些素材。先写好，后期再拼接下。</p>\n<h3 id=\"3-3-生命周期函数\"><a href=\"#3-3-生命周期函数\" class=\"headerlink\" title=\"3.3 生命周期函数\"></a>3.3 生命周期函数</h3><p>初始化看下，应该要先设置一个蒙层。</p>\n<pre><code class=\"line-numbers language-Swift\">override init(frame: CGRect)&#123;\n        super.init(frame: frame)\n        /// 这里应该是蒙层\n        self.backgroundColor = UIColor.init(r: 100, g: 1, b: 1, a: 0.3)\n        self.alpha = 0\n        \n        let lastDyaDate = YSDateTool.lastDay()\n        let com = YSDateTool.currentDateCom(date: lastDyaDate)\n        watermarkView.monthStr = &quot;\\(com.month!)&quot;\n    &#125;\n    \n    required init?(coder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n</code></pre>\n<p>确实如此，这里就只加了个颜色。</p>\n<h3 id=\"3-4-定义方法，展示和隐藏选择器\"><a href=\"#3-4-定义方法，展示和隐藏选择器\" class=\"headerlink\" title=\"3.4 定义方法，展示和隐藏选择器\"></a>3.4 定义方法，展示和隐藏选择器</h3><pre><code class=\"line-numbers language-Swift\">extension CalendarView&#123;\n    /// 显示弹窗\n    public func showAlertView() &#123;\n        let str = &quot;\\(timeModel.startTime)\\(CalendarView.range)\\(timeModel.endTime)&quot;\n        selectIndex = timeArr.firstIndex(of:str) ?? 0\n        let timeStr = &quot;\\(timeModel.year)-\\(timeModel.month)-\\(timeModel.day)&quot;\n        let date = YSDateTool.dateStringToDate(timeStr)\n        self.setDate(date: date)\n        self.setUI()\n        pickerView.selectRow(selectIndex, inComponent: 0, animated: false)\n        UIView.animate(withDuration: 0.25) &#123;\n            self.alpha = 1\n        &#125;\n    &#125;\n\n    /// 隐藏弹窗\n    public func dismissAlertView() &#123;\n        self.animate(duration: 0.25) &#123;\n            self.alpha = 0\n        &#125; completion: &#123; finish in\n            self.removeFromSuperview()\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这个方法很重要，主要提供给外部使用，这里帮助外部设置数据，因为外部调用者可能不知道内部细节，所以我们最好在这个类里面实现展示弹框的方法。</p>\n<h3 id=\"3-5-设置初始化日期\"><a href=\"#3-5-设置初始化日期\" class=\"headerlink\" title=\"3.5 设置初始化日期\"></a>3.5 设置初始化日期</h3><p>外部可能有选择好的日期，所以我们必须提供一个方法，设置数据。</p>\n<pre><code class=\"line-numbers language-Swift\">extension CalendarView&#123;\n    /// 按照这个date获取这个月的数据\n    func setDate(date: Date = Date())&#123;\n        modelArr.removeAll()\n        let count = YSDateTool.countOfDaysInCurrentMonth(date: date)    //当月天数\n        for i in 0..&lt;count&#123;\n            let model = self.initializeModel(date: date, day: i+1)\n            modelArr.append(model)\n        &#125;\n        let firstWeekDay = YSDateTool.firstWeekDayInCurrentMonth(date: date)    //当月第一天周几\n        \n        //头部空缺数据填充 插入一个空的model\n        if firstWeekDay != 7 &#123;\n            for _ in 0 ..&lt; firstWeekDay&#123;\n                let model = self.initializeModel(date: date, day: 0)\n                modelArr.insert(model, at: 0)\n            &#125;\n        &#125;\n        //尾部空缺数据填充,插入一个空的model\n        if modelArr.count &lt; 35&#123;\n            for _ in modelArr.count ..&lt; 35&#123;\n                let model = self.initializeModel(date: date, day: 0)\n                modelArr.append(model)\n            &#125;\n        &#125;\n        \n        collectionView.reloadData()\n    &#125;\n    \n    /// 初始化数据，返回\n    func initializeModel(date: Date, day: Int)-&gt;TimeModel&#123;\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        let model = TimeModel()\n        model.year = com.year!\n        model.month = com.month!\n        model.day = day\n        \n        // model指代当前时间\n        let monthStr = com.month! &lt; 10 ? &quot;0\\(model.month)&quot; : &quot;\\(model.month)&quot;\n        let dayStr = com.day! &lt; 10 ? &quot;0\\(model.day)&quot; : &quot;\\(model.day)&quot;\n        model.dateStr = &quot;\\(com.year!)-\\(monthStr)-\\(dayStr)&quot;\n        return model\n    &#125;\n&#125;\n</code></pre>\n<p>这里也搞了2个扩展函数，会根据目标日期，获取到该日期的一个月的数据，然后会填充第一天非星期天的情况的数据，也会填最后几天空白区域的数据。</p>\n<h3 id=\"3-6-设置UI\"><a href=\"#3-6-设置UI\" class=\"headerlink\" title=\"3.6 设置UI\"></a>3.6 设置UI</h3><p>有了日期就可以设置UI了，所以我们看下如何填充视图的。</p>\n<pre><code class=\"line-numbers language-Swift\">extension CalendarView &#123;\n    func setUI() &#123;\n        \n        //日历顶部按钮布局\n        self.addSubview(acView)\n        acView.snp.makeConstraints&#123;make in\n            make.leading.trailing.bottom.equalTo(0)\n            make.height.equalTo(ScreenHeight*0.57)\n        &#125;\n        \n        // 加顶部横线 左上角默认位置\n        acView.addSubview(lineView)\n        self.lineViewLayout()\n        \n        // 加预约日期\n        acView.addSubview(dateBtn)\n        dateBtn.snp.makeConstraints&#123;make in\n            make.top.equalTo(11)\n            make.leading.equalTo(28)\n            make.width.equalTo(66)\n            make.height.equalTo(22)\n        &#125;\n        \n        // 预约时间\n        acView.addSubview(timeBtn)\n        timeBtn.snp.makeConstraints&#123;make in\n            make.top.equalTo(11)\n            make.centerX.equalToSuperview()\n            make.width.equalTo(66)\n            make.height.equalTo(22)\n        &#125;\n        \n        // 加取消按钮\n        acView.addSubview(cancelBtn)\n        cancelBtn.snp.makeConstraints&#123;make in\n            make.top.equalTo(11)\n            make.trailing.equalTo(-16)\n            make.width.equalTo(66)\n            make.height.equalTo(22)\n        &#125;\n        \n        \n        // 继续加滚动视图\n        acView.addSubview(scrollView)\n        scrollView.snp.makeConstraints&#123;make in\n            make.top.equalTo(dateBtn.snp.bottom).offset(10)\n            make.leading.trailing.equalToSuperview()\n            make.bottom.equalToSuperview()\n        &#125;\n        \n        // acView添加完毕，现在到内部ScrollView层级了--------------\n    \n        // 加个集合View 集合View因为初始化确定了y轴高度，这里无需重复布局\n        scrollView.addSubview(collectionView)\n        \n        // 再加个pickerView 时间滚轮，这里直接加到ScrollView里面了，也无需布局，直接覆盖到上层的\n        scrollView.addSubview(pickerView)\n        \n        // 先加工具栏\n        scrollView.addSubview(dateToolView)\n        dateToolView.snp.makeConstraints&#123;make in\n            make.top.leading.equalTo(0)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(40)\n        &#125;\n        \n        // 滚动视图再加星期视图\n        scrollView.addSubview(weeksView)\n        weeksView.snp.makeConstraints&#123;make in\n            make.top.equalTo(dateToolView.snp.bottom).offset(4)\n            make.leading.equalTo(0)\n            make.width.equalTo(ScreenWidth)\n            make.height.equalTo(30)\n        &#125;\n        \n        \n        // 处理下工具栏内部布局\n        dateToolView.addSubview(monthLb)\n        monthLb.snp.makeConstraints&#123;make in\n            make.centerY.equalToSuperview()\n            make.centerX.equalToSuperview()\n            make.width.equalTo(100)\n            make.height.equalTo(20)\n        &#125;\n        \n        // 日历工具条加左按钮\n        dateToolView.addSubview(toolLeftBtn)\n        toolLeftBtn.snp.makeConstraints&#123;make in\n            make.centerY.equalToSuperview()\n            make.width.height.equalTo(40)\n            make.leading.equalTo(16)\n        &#125;\n\n        // 日历工具条加右侧箭头\n        dateToolView.addSubview(toolRightBtn)\n        toolRightBtn.snp.makeConstraints&#123;make in\n            make.centerY.equalToSuperview()\n            make.width.height.equalTo(40)\n            make.trailing.equalTo(-16)\n        &#125;\n        \n        // 设置星期几内部布局\n        setWeekUiInner()\n        \n        // 地址底部按钮\n        addBottomUI()\n    \n    &#125;\n</code></pre>\n<p>中规中矩，老老实实从上到下，从左到右布局。</p>\n<p>内部星期几看下如何布局的：</p>\n<pre><code class=\"line-numbers language-Swift\">func setWeekUiInner() &#123;\n        let arr = [&quot;日&quot;,&quot;一&quot;,&quot;二&quot;,&quot;三&quot;,&quot;四&quot;,&quot;五&quot;,&quot;六&quot;]\n\n        for i in 0 ..&lt; arr.count &#123;\n            let width = ScreenWidth/7\n            let lab = UILabel()\n            lab.text = arr[i]\n            lab.textColor = UIColor.init(hex: &quot;#323233&quot;)\n            lab.font = .pingFangRegular(size: 12)\n            lab.textAlignment = .center\n            weeksView.addSubview(lab)\n            lab.snp.makeConstraints&#123;make in\n                make.leading.equalTo(width*CGFloat(i))\n                make.centerY.equalToSuperview()\n                make.width.equalTo(width)\n                make.height.equalTo(20)\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>还有底部的下一步和完成：</p>\n<pre><code class=\"line-numbers language-Swift\">func addBottomUI() &#123;\n        let nextBtn: UIButton = UIButton.init(type: .custom)\n        nextBtn.frame = CGRect.init(x: 16, y: ScreenHeight*0.57*0.57+8+34+40, width: (ScreenWidth-32), height: 44)\n        nextBtn.titleFont = .pingFangMedium(size: 16)\n        nextBtn.setTitleColor(.white, for: .normal)\n        nextBtn.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n        nextBtn.setTitle(&quot;下一步&quot;, for: .normal)\n        nextBtn.layer.cornerRadius = 22\n        nextBtn.addTarget(self, action: #selector(actionForNext), for: .touchUpInside)\n        scrollView.addSubview(nextBtn)\n        \n        let doneBtn: UIButton = UIButton.init(type: .custom)\n        doneBtn.frame = CGRect.init(x: ScreenWidth+16, y: ScreenHeight*0.57*0.57+8+34+40, width: (ScreenWidth-32), height: 44)\n        doneBtn.titleFont = .pingFangMedium(size: 16)\n        doneBtn.setTitleColor(.white, for: .normal)\n        doneBtn.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n        doneBtn.setTitle(&quot;完成&quot;, for: .normal)\n        doneBtn.layer.cornerRadius = 22\n        doneBtn.addTarget(self, action: #selector(actionForDone), for: .touchUpInside)\n        scrollView.addSubview(doneBtn)\n    &#125;\n</code></pre>\n<h3 id=\"3-7-填充数据\"><a href=\"#3-7-填充数据\" class=\"headerlink\" title=\"3.7 填充数据\"></a>3.7 填充数据</h3><p>这里先看下日历数据如何使用代理和数据源的：</p>\n<pre><code class=\"line-numbers language-Swift\">extension CalendarView: UICollectionViewDelegate,UICollectionViewDataSource,UICollectionViewDelegateFlowLayout&#123;\n    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123;\n        return modelArr.count\n    &#125;\n    \n    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123;\n        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: CalendarCell.identifier, for: indexPath) as! CalendarCell\n        cell.model = modelArr[indexPath.item]\n        cell.selectedModel = timeModel\n        return cell\n    &#125;\n\n    // 定义每个Cell的大小\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -&gt; CGSize &#123;\n        let width = ScreenWidth/7\n        let height = modelArr.count &gt; 35 ? (ScreenHeight*0.57*0.57)/6 : (ScreenHeight*0.57*0.57)/5\n        return CGSize(width: width-2, height: height-1)\n    &#125;\n    \n    // 定义每个Section的四边间距\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -&gt; UIEdgeInsets &#123;\n        return UIEdgeInsets(top: 0, left: 3.5, bottom: 0, right: 0)\n    &#125;\n    \n    // 这个是两行cell之间的间距（上下行cell的间距）\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -&gt; CGFloat &#123;\n        return 1.0\n    &#125;\n    \n    // 两个cell之间的间距（同一行的cell的间距）\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Int) -&gt; CGFloat &#123;\n        return 1.0\n    &#125;\n    \n    // 选中某个ietm\n    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) &#123;\n        let model = modelArr[indexPath.item]\n        let com = YSDateTool.currentDateCom()\n        if com.year == model.year &amp;&amp; com.month == model.month &amp;&amp; model.day &lt;= com.day! || model.day == 0&#123;\n            return\n        &#125;\n\n        timeModel.year = model.year\n        timeModel.month = model.month\n        timeModel.day = model.day\n        collectionView.reloadData()\n    &#125;\n&#125;\n</code></pre>\n<p>主要逻辑委托给Cell来实现了。后面再看下。</p>\n<h3 id=\"3-8-UIPickerView数据填充\"><a href=\"#3-8-UIPickerView数据填充\" class=\"headerlink\" title=\"3.8 UIPickerView数据填充\"></a>3.8 UIPickerView数据填充</h3><p>然后看下预约时间如何填充数据的。</p>\n<pre><code class=\"line-numbers language-Swift\">extension CalendarView:UIPickerViewDelegate,UIPickerViewDataSource &#123;\n\n    func numberOfComponents(in pickerView: UIPickerView) -&gt; Int &#123;\n        return 1\n    &#125;\n    \n    func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -&gt; Int &#123;\n        return timeArr.count\n    &#125;\n\n    func pickerView(_ pickerView: UIPickerView, widthForComponent component: Int) -&gt; CGFloat &#123;\n        return ScreenWidth\n    &#125;\n    \n    func pickerView(_ pickerView: UIPickerView, rowHeightForComponent component: Int) -&gt; CGFloat &#123;\n        44\n    &#125;\n    \n    func pickerView(_ pickerView: UIPickerView, viewForRow row: Int, forComponent component: Int, reusing view: UIView?) -&gt; UIView &#123;\n        \n        //设置分割线 pickerView的subvews的第二个一般用来做分割线 subviews会有2个view\n        for view in pickerView.subviews &#123;\n            print(&quot;view.height=\\(view.size.height) 长度为：\\(pickerView.subviews.count)&quot;)\n            if view.size.height &lt;= 50 &#123;\n                view.backgroundColor = .clear\n                //自定义分割线\n                let toplayer = CALayer()\n                toplayer.frame = CGRect.init(x: 0, y: 0, width: ScreenWidth, height: 1)\n                toplayer.backgroundColor = UIColor.init(hex: &quot;#EBEDF0&quot;).cgColor\n                view.layer.addSublayer(toplayer)\n\n                let bottomlayer = CALayer()\n                bottomlayer.frame = CGRect.init(x: 0, y: 44-1, width: ScreenWidth, height: 1)\n                bottomlayer.backgroundColor = UIColor.init(hex: &quot;#EBEDF0&quot;).cgColor\n                view.layer.addSublayer(bottomlayer)\n               \n            &#125;else&#123;\n                view.backgroundColor = .clear\n            &#125;\n        &#125;\n        \n        //设置内容样式\n        var label = view as? UILabel\n        if label == nil &#123;\n            label = UILabel.init()\n            label?.backgroundColor = .clear\n            label?.frame = CGRect.init(x: 0, y: 0, width:ScreenWidth, height:44)\n        &#125;\n        if row == selectIndex &#123;\n            label?.textColor = UIColor.init(hex: &quot;#409EFF&quot;)\n        &#125;else&#123;\n            label?.textColor = UIColor.init(hex: &quot;#3B4058&quot;)\n        &#125;\n        label?.textAlignment = .center\n        label?.font = .pingFangRegular(size: 16)\n        //label?.minimumScaleFactor = 0.5\n        //label?.adjustsFontSizeToFitWidth = true\n        label?.text = timeArr[row]\n        return label!\n    &#125;\n    \n    func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) &#123;\n        selectIndex = row\n        pickerView.reloadAllComponents()\n    &#125;\n&#125;\n</code></pre>\n<p>主要逻辑是viewForRow覆写的方法里面。<br>交代了如何绘制分割线和选中高亮显示。<br>这里有个点要注意，这个分割线用到了 UIPickerView的subViews，这里通常设置分割线都要用到这个东西，具体细节我不是很清楚，预测这个subViews第二个就是居中的item。第一个item很长，不能用来分割线。</p>\n<p>然后就是didSelectRow用来响应用户点击事件，需要刷新下components。</p>\n<h3 id=\"3-9-交互事件\"><a href=\"#3-9-交互事件\" class=\"headerlink\" title=\"3.9 交互事件\"></a>3.9 交互事件</h3><p>这里交互事件统一用一个扩展类来实现。</p>\n<pre><code class=\"line-numbers language-Swift\">extension CalendarView &#123;\n    \n    @objc func actionForChooseDate()&#123;\n        self.lineViewLayout()\n        self.scrollDate()\n    &#125;\n    \n    @objc func actionForChooseTime()&#123;\n        self.lineViewLayout(leading: 1)\n        self.scrollTime()\n    &#125;\n    \n    @objc func actionForCancel()&#123;\n        self.dismissAlertView()\n    &#125;\n    \n    @objc func actionForLeftEvent()&#123;\n        dynamicDate = YSDateTool.lastMonth(date: dynamicDate)\n        self.isRefrenshMonth()\n    &#125;\n    \n    @objc func actionForRightEvent()&#123;\n        dynamicDate = YSDateTool.nextMonth(date: dynamicDate)\n        self.isRefrenshMonth()\n    &#125;\n    \n    @objc func actionForNext()&#123;\n        self.lineViewLayout(leading: 1)\n        self.scrollTime()\n    &#125;\n    \n    @objc func actionForDone()&#123;\n        if doneHandle != nil &#123;\n            let str = timeArr[selectIndex]\n            let arr = str.components(separatedBy: CalendarView.range)\n            timeModel.startTime = arr[0]\n            timeModel.endTime = arr[1]\n            \n            let monthStr = timeModel.month &lt; 10 ? &quot;0\\(timeModel.month)&quot; : &quot;\\(timeModel.month)&quot;\n            let dayStr = timeModel.day &lt; 10 ? &quot;0\\(timeModel.day)&quot; : &quot;\\(timeModel.day)&quot;\n            timeModel.dateStr = &quot;\\(timeModel.year)-\\(monthStr)-\\(dayStr)&quot;\n            \n            doneHandle(timeModel)\n        &#125;\n        self.dismissAlertView()\n    &#125;\n    \n    // 滑动到日期\n    func scrollDate()&#123;\n        dateBtn.isSelected = true\n        timeBtn.isSelected = false\n        scrollView.setContentOffset(CGPoint.init(x: 0, y: 0), animated: true)\n    &#125;\n    \n    // 滑动到时间\n    func scrollTime()&#123;\n        dateBtn.isSelected = false\n        timeBtn.isSelected = true\n        scrollView.setContentOffset(CGPoint.init(x: ScreenWidth, y: 0), animated: true)\n    &#125;\n    \n    func isRefrenshMonth()&#123;\n        self.setDate(date: dynamicDate)\n        let com = YSDateTool.currentDateCom(date: dynamicDate)\n        monthLb.text = &quot;\\(com.year!)年\\(com.month!)月&quot;\n        watermarkView.monthStr = &quot;\\(com.month!)&quot;\n        \n        let currentCom = YSDateTool.currentDateCom()\n        if (com.year! == currentCom.year!  &amp;&amp; com.month! &gt; currentCom.month!) || (com.year! &gt; currentCom.year!)&#123;\n            toolLeftBtn.isHidden = false\n        &#125;else&#123;\n            toolLeftBtn.isHidden = true\n        &#125;\n    &#125;\n    \n    func lineViewLayout(leading: Int = 0)&#123;\n        lineView.snp.remakeConstraints&#123;make in\n            make.top.equalTo(0)\n            if leading == 0 &#123;\n                make.leading.equalTo(leading)\n            &#125;else&#123;\n                make.centerX.equalToSuperview() // 居中了\n            &#125;\n            make.width.equalTo(66+56) // 宽度\n            make.height.equalTo(2)  // 高度\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"4-撸下时间工具\"><a href=\"#4-撸下时间工具\" class=\"headerlink\" title=\"4 撸下时间工具\"></a>4 撸下时间工具</h2><p>这个只是个单纯工具，不必重复造轮子。</p>\n<pre><code class=\"line-numbers language-Swift\">class YSDateTool &#123;\n    // MARK: - 当前时间组件\n    static func currentDateCom(date: Date = Date()) -&gt; DateComponents&#123;\n        let calendar = Calendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com\n    &#125;\n    // MARK: - 今年\n    static func currentYear(date: Date = Date()) -&gt; Int &#123;\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com.year!\n    &#125;\n  \n    // MARK: - 今月\n    static func currentMonth(date: Date = Date()) -&gt; Int &#123;\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com.month!\n    &#125;\n  \n    // MARK: - 今日\n    static func currentDay(date: Date = Date()) -&gt; Int &#123;\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.year, .month, .day], from: date)\n        return com.day!\n    &#125;\n    \n    // MARK: - 今天星期几\n    static func currentWeekDay(date: Date = Date()) -&gt; Int &#123;\n        let calendar = NSCalendar.current\n        let com = calendar.dateComponents([.weekday], from: date)\n        return com.weekday!\n    &#125;\n    \n    // MARK: - 农历今年\n    static func currentChineseYear(date: Date = Date()) -&gt; String &#123;\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.year], from: date)\n        return numberToChina(yearNum: (com?.year)!) + &quot;年&quot;\n    &#125;\n    \n    // MARK: - 农历今月\n    static func currentChineseMonth(date: Date = Date()) -&gt; String &#123;\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.month], from: date)\n        return numberToChina(monthNum: (com?.month)!)\n    &#125;\n\n    // MARK: - 农历今日\n    static func currentChineseDay(date: Date = Date()) -&gt; String &#123;\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.day], from: date)\n        return numberToChina(dayNum: (com?.day)!)\n    &#125;\n    \n    // MARK: - 农历今日\n    static func currentChineseDayInt(date: Date = Date()) -&gt; Int &#123;\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.day], from: date)\n        return (com?.day)!\n    &#125;\n    \n    // MARK: - 农历星期\n    static func currentChineseWeekYear(date: Date = Date()) -&gt; String &#123;\n        let calendar = NSCalendar.init(calendarIdentifier: .chinese)\n        let com = calendar?.components([.weekday], from: date)\n        return numberToChina(weekNum: (com?.weekday)!)\n    &#125;\n  \n    // MARK: - 下个月\n    static func nextMonth(date: Date = Date()) -&gt; Date &#123;\n        let calendar = NSCalendar.current\n        let nDate = calendar.date(byAdding: DateComponents(month: 1), to: date)\n        return nDate!\n    &#125;\n    \n    // MARK: - 上个月\n    static func lastMonth(date: Date = Date()) -&gt; Date &#123;\n        let calendar = NSCalendar.current\n        let lDate = calendar.date(byAdding: DateComponents(month: -1), to: date)\n        return lDate!\n    &#125;\n    \n    // MARK: - 下一天\n    static func lastDay(date: Date = Date()) -&gt; Date&#123;\n        let calendar = NSCalendar.current\n        let lDate = calendar.date(byAdding: DateComponents(day: 1), to: date)\n        return lDate!\n    &#125;\n  \n    // MARK: - 本月天数\n    static func countOfDaysInCurrentMonth(date: Date = Date()) -&gt; Int &#123;\n        let calendar = Calendar(identifier: Calendar.Identifier.gregorian)\n        let range = (calendar as NSCalendar?)?.range(of: NSCalendar.Unit.day, in: NSCalendar.Unit.month, for: date)\n        return (range?.length)!\n    &#125;\n \n    // MARK: - 当月第一天是星期几\n    static func firstWeekDayInCurrentMonth(date: Date = Date()) -&gt; Int &#123;\n        // 星期和数字一一对应 星期日：7\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = &quot;yyyy-MM&quot;\n        let date = dateFormatter.date(from: String(date.xj.year)+&quot;-&quot;+String(date.xj.month))\n        let calender = Calendar(identifier: Calendar.Identifier.gregorian)\n        let comps = (calender as NSCalendar?)?.components(NSCalendar.Unit.weekday, from: date!)\n        var week = comps?.weekday\n        if week == 1 &#123;\n            week = 8\n        &#125;\n        return week! - 1\n    &#125;\n\n    // MARK: - - 获取指定日期各种值\n    // 根据年月得到某月天数\n    static func getCountOfDaysInMonth(year: Int, month: Int) -&gt; Int&#123;\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = &quot;yyyy-MM&quot;\n        let date = dateFormatter.date(from: String(year)+&quot;-&quot;+String(month))\n        let calendar = Calendar(identifier: Calendar.Identifier.gregorian)\n        let range = (calendar as NSCalendar?)?.range(of: NSCalendar.Unit.day, in: NSCalendar.Unit.month, for: date!)\n        return (range?.length)!\n    &#125;\n    \n    // MARK: - 根据年月得到某月第一天是周几\n    static func getfirstWeekDayInMonth(year: Int, month: Int) -&gt; Int&#123;\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = &quot;yyyy-MM&quot;\n        let date = dateFormatter.date(from: String(year)+&quot;-&quot;+String(month))\n        let calendar = Calendar(identifier: Calendar.Identifier.gregorian)\n        let comps = (calendar as NSCalendar?)?.components(NSCalendar.Unit.weekday, from: date!)\n        let week = comps?.weekday\n        return week! - 1\n    &#125;\n\n    // MARK: - date转日期字符串\n    static func dateToDateString(_ date: Date, dateFormat: String) -&gt; String &#123;\n        let timeZone = NSTimeZone.default\n        let formatter = DateFormatter()\n        formatter.timeZone = timeZone\n        formatter.dateFormat = dateFormat\n        let date = formatter.string(from: date)\n        return date\n    &#125;\n\n    // MARK: - 日期字符串转date\n    static func dateStringToDate(_ dateStr: String) -&gt; Date &#123;\n        let dateFormatter = DateFormatter()\n        dateFormatter.timeZone = TimeZone(abbreviation: &quot;UTC+8&quot;)\n        dateFormatter.dateFormat = &quot;yyyy-MM-dd&quot;\n        let date = dateFormatter.date(from: dateStr)\n        return date!\n    &#125;\n    \n    // MARK: - 时间字符串转date\n    static func timeStringToDate(_ dateStr: String) -&gt; Date &#123;\n        let dateFormatter = DateFormatter()\n        dateFormatter.timeZone = TimeZone(abbreviation: &quot;UTC+8&quot;)\n        dateFormatter.dateFormat = &quot;yyyy-MM-dd HH:mm:ss&quot;\n        let date = dateFormatter.date(from: dateStr)\n        return date!\n    &#125;\n\n    // MARK: - 计算天数差\n    static func dateDifference(_ dateA: Date, from dateB: Date) -&gt; Double &#123;\n        let interval = dateA.timeIntervalSince(dateB)\n        return interval/86400\n    &#125;\n\n    // MARK: - 比较时间先后\n    static func compareOneDay(oneDay: Date, withAnotherDay anotherDay: Date) -&gt; Int &#123;\n        let dateFormatter: DateFormatter = DateFormatter()\n        dateFormatter.dateFormat = &quot;yyyy-MM-dd&quot;\n        let oneDayStr: String = dateFormatter.string(from: oneDay)\n        let anotherDayStr: String = dateFormatter.string(from: anotherDay)\n        let dateA = dateFormatter.date(from: oneDayStr)\n        let dateB = dateFormatter.date(from: anotherDayStr)\n        let result: ComparisonResult = (dateA?.compare(dateB!))!\n        // Date1 is in the future\n        if(result == ComparisonResult.orderedDescending ) &#123;\n            return 1\n        &#125;\n        // Date1 is in the past\n        else if(result == ComparisonResult.orderedAscending) &#123;\n            return 2\n        &#125;\n            // Both dates are the same\n        else &#123;\n            return 0\n        &#125;\n    &#125;\n\n    // MARK: - 时间与时间戳之间的转化\n    // 将时间转换为时间戳\n    static func stringToTimeStamp(_ stringTime: String) -&gt; Int &#123;\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat = &quot;yyyy-MM-dd HH: mm: ss&quot;\n        dfmatter.locale = Locale.current\n        let date = dfmatter.date(from: stringTime)\n        let dateStamp: TimeInterval = date!.timeIntervalSince1970\n        let dateSt: Int = Int(dateStamp)\n        return dateSt\n    &#125;\n    \n    // 将时间戳转换为年月日\n    static func timeStampToString(_ timeStamp: String) -&gt; String &#123;\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=&quot;yyyy年MM月dd日&quot;\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    &#125;\n    \n    // 将时间戳转换为具体时间\n    static func timeStampToStringDetail(_ timeStamp: String) -&gt; String &#123;\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=&quot;yyyy年MM月dd日HH: mm: ss&quot;\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    &#125;\n    \n    // 将时间戳转换为时分秒\n    static func timeStampToHHMMSS(_ timeStamp: String) -&gt; String &#123;\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=&quot;HH: mm: ss&quot;\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    &#125;\n    \n    // 将时间戳转换为时分\n    static func timeStampToHHMM(_ timeStamp: String) -&gt; String &#123;\n        let string = NSString(string: timeStamp)\n        let timeSta: TimeInterval = string.doubleValue\n        let dfmatter = DateFormatter()\n        dfmatter.dateFormat=&quot;HH: mm&quot;\n        let date = Date(timeIntervalSince1970: timeSta)\n        return dfmatter.string(from: date)\n    &#125;\n    \n    // 获取系统的当前时间戳\n    static func getStamp(date: Date = Date()) -&gt; Int&#123;\n        // 获取当前时间戳\n        let timeInterval: Int = Int(date.timeIntervalSince1970)\n        return timeInterval\n    &#125;\n    \n    // 日数字转汉字\n    static func numberToChina(yearNum: Int) -&gt; String &#123;\n        // 以一个天干和一个地支相配，排列起来，天干在前，地支在后，天干由甲起，地支由子起，阳干对阳支，阴干对阴支（阳干不配阴支，阴干不配阳支）\n        // 就会得到六十年一周期的甲子回圈，一般称为“六十甲子”或“花甲子”\n        // 十天干： 甲（jiǎ）、乙（yǐ）、丙（bǐng）、丁（dīng）、戊（wù）、己（jǐ）、庚（gēng）、辛（xīn）、壬（rén）、癸（guǐ）\n        // 十二地支： 子（zǐ）、丑（chǒu）、寅（yín）、卯（mǎo）、辰（chén）、巳（sì）、午（wǔ）、未（wèi）、申（shēn）、酉（yǒu）、戌（xū）、亥（hài）\n        let ChinaArray = [ &quot;甲子&quot;, &quot;乙丑&quot;, &quot;丙寅&quot;, &quot;丁卯&quot;, &quot;戊辰&quot;, &quot;己巳&quot;, &quot;庚午&quot;, &quot;辛未&quot;, &quot;壬申&quot;, &quot;癸酉&quot;,\n                         &quot;甲戌&quot;, &quot;乙亥&quot;, &quot;丙子&quot;, &quot;丁丑&quot;, &quot;戊寅&quot;, &quot;己卯&quot;, &quot;庚辰&quot;, &quot;辛己&quot;, &quot;壬午&quot;, &quot;癸未&quot;,\n                         &quot;甲申&quot;, &quot;乙酉&quot;, &quot;丙戌&quot;, &quot;丁亥&quot;, &quot;戊子&quot;, &quot;己丑&quot;, &quot;庚寅&quot;, &quot;辛卯&quot;, &quot;壬辰&quot;, &quot;癸巳&quot;,\n                         &quot;甲午&quot;, &quot;乙未&quot;, &quot;丙申&quot;, &quot;丁酉&quot;, &quot;戊戌&quot;, &quot;己亥&quot;, &quot;庚子&quot;, &quot;辛丑&quot;, &quot;壬寅&quot;, &quot;癸丑&quot;,\n                         &quot;甲辰&quot;, &quot;乙巳&quot;, &quot;丙午&quot;, &quot;丁未&quot;, &quot;戊申&quot;, &quot;己酉&quot;, &quot;庚戌&quot;, &quot;辛亥&quot;, &quot;壬子&quot;, &quot;癸丑&quot;,\n                         &quot;甲寅&quot;, &quot;乙卯&quot;, &quot;丙辰&quot;, &quot;丁巳&quot;, &quot;戊午&quot;, &quot;己未&quot;, &quot;庚申&quot;, &quot;辛酉&quot;, &quot;壬戌&quot;, &quot;癸亥&quot;]\n        let ChinaStr: String = ChinaArray[yearNum - 1]\n        return ChinaStr\n    &#125;\n    \n    // 月份数字转汉字\n    static func numberToChina(monthNum: Int) -&gt; String &#123;\n        let ChinaArray = [&quot;一月&quot;, &quot;二月&quot;, &quot;三月&quot;, &quot;四月&quot;, &quot;五月&quot;, &quot;六月&quot;, &quot;七月&quot;, &quot;八月&quot;, &quot;九月&quot;, &quot;十月&quot;, &quot;十一月&quot;, &quot;十二月&quot;]\n        let ChinaStr: String = ChinaArray[monthNum - 1]\n        return ChinaStr\n    &#125;\n    \n    // 日数字转汉字\n    static func numberToChina(dayNum: Int) -&gt; String &#123;\n        let ChinaArray = [ &quot;初一&quot;, &quot;初二&quot;, &quot;初三&quot;, &quot;初四&quot;, &quot;初五&quot;, &quot;初六&quot;, &quot;初七&quot;, &quot;初八&quot;, &quot;初九&quot;, &quot;初十&quot;,\n                         &quot;十一&quot;, &quot;十二&quot;, &quot;十三&quot;, &quot;十四&quot;, &quot;十五&quot;, &quot;十六&quot;, &quot;十七&quot;, &quot;十八&quot;, &quot;十九&quot;, &quot;二十&quot;,\n                         &quot;廿一&quot;, &quot;廿二&quot;, &quot;廿三&quot;, &quot;廿四&quot;, &quot;廿五&quot;, &quot;廿六&quot;, &quot;廿七&quot;, &quot;廿八&quot;, &quot;廿九&quot;, &quot;三十&quot;]\n        let ChinaStr: String = ChinaArray[dayNum - 1]\n        return ChinaStr\n    &#125;\n      \n    // 星期数字转汉字\n    static func numberToChina(weekNum: Int) -&gt; String &#123;\n        let ChinaArray = [&quot;一月&quot;, &quot;二月&quot;, &quot;三月&quot;, &quot;四月&quot;, &quot;五月&quot;, &quot;六月&quot;, &quot;七月&quot;, &quot;八月&quot;, &quot;九月&quot;, &quot;十月&quot;, &quot;十一月&quot;, &quot;十二月&quot;]\n        let ChinaStr: String = ChinaArray[weekNum - 1]\n        return ChinaStr\n    &#125;\n    \n    // MARK: - 数字前补0\n    static func add0BeforeNumber(_ number: Int) -&gt; String &#123;\n        if number &gt;= 10 &#123;\n            return String(number)\n        &#125;else&#123;\n            return &quot;0&quot; + String(number)\n        &#125;\n    &#125;\n    \n    static func getCurrentSystemDate() -&gt; Date&#123;\n        let date = Date() // 获得时间对象\n        let zone = NSTimeZone.system // 获得系统的时区\n        let time = zone.secondsFromGMT(for: date)// 以秒为单位返回当前时间与系统格林尼治时间的差\n        return date.addingTimeInterval(TimeInterval(time))// 然后把差的时间加上,就是当前系统准确的时间\n    &#125;\n    \n    static func date(_ date: String?, dateFormat: String = &quot;yyyy-MM-dd&quot;) -&gt; Date? &#123;\n        guard let date = date else &#123;\n            return nil\n        &#125;\n        let dateformatter = DateFormatter()\n        dateformatter.timeZone = TimeZone.init(secondsFromGMT: 0)\n        dateformatter.dateFormat = dateFormat\n        return dateformatter.date(from: date)\n    &#125;\n\n    // MARK: - 将时间显示为（几分钟前，几小时前，几天前）\n    static func compareCurrentTime(str: String) -&gt; String &#123;\n        //let currentDateStr = dateToDateString(Date(), dateFormat: &quot;yyyy-MM-dd hh:mm:ss&quot;)\n        let currentDate = getCurrentSystemDate()\n        let sendTimeDate = date(str,dateFormat: &quot;yyyy-MM-dd HH:mm:ss&quot;)!//self.timeStringToDate(str)\n        let sendTimeInterval = Double(getStamp(date: sendTimeDate))\n        let timeInterval = currentDate.timeIntervalSince(sendTimeDate)\n\n        var todayStr = dateToDateString(Date(), dateFormat: &quot;yyyy-MM-dd&quot;)\n        todayStr = todayStr+&quot; 00:00&quot;\n        let todayTimeInterval = Double(Date().stringToSecondTimeStamp(todayStr)) ?? 0\n        let yestDayTimeInterval = Double(todayTimeInterval - 86400)\n        let nextDayTimeInterval = Double(todayTimeInterval + 86400)\n\n        var temp: Double = 0\n        var result: String = &quot;&quot;\n        if timeInterval/60 &lt; 1 &#123;\n            result = &quot;刚刚&quot;\n        &#125;else if (timeInterval/60) &lt; 60&#123;\n            temp = timeInterval/60\n            result = &quot;\\(Int(temp))分钟前&quot;\n        &#125;else if sendTimeInterval &gt; todayTimeInterval &amp;&amp; sendTimeInterval &lt; nextDayTimeInterval&#123;\n\n            //let interval = nextDayTimeInterval - sendTimeInterval\n            temp = timeInterval/60/60\n            result = &quot;\\(Int(temp))小时前&quot;\n        &#125;else if sendTimeInterval &gt; yestDayTimeInterval &amp;&amp; sendTimeInterval &lt; todayTimeInterval&#123;\n            //let str = timeStampToHHMM(String.init(format: &quot;%d&quot;, sendTimeInterval))\n            let timeStr = str.components(separatedBy: &quot; &quot;).last ?? &quot;&quot;\n            let str = timeStr.prefix(5)\n            result = &quot;昨天\\(str)&quot;\n        &#125;else&#123;\n            let timeStr = str.components(separatedBy: &quot; &quot;).first ?? &quot;&quot;\n            let timeArr = timeStr.components(separatedBy: &quot;-&quot;)\n            if !timeArr.isEmpty &#123;\n                result = &quot;\\(timeArr[0])年\\(timeArr[1])月\\(timeArr[2])日&quot;\n            &#125;\n            //result = timeStampToString(String.init(format: &quot;%d&quot;, sendTimeInterval))\n        &#125;\n        \n//        else if timeInterval/(30 * 24 * 60 * 60) &lt; 12 &#123;\n//            temp = timeInterval/(30 * 24 * 60 * 60)\n//            result = &quot;\\(Int(temp))个月前&quot;\n//        &#125;else&#123;\n//            temp = timeInterval/(12 * 30 * 24 * 60 * 60)\n//            result = &quot;\\(Int(temp))年前&quot;\n//        &#125;\n        return result\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"5-撸下最后的日历Cell\"><a href=\"#5-撸下最后的日历Cell\" class=\"headerlink\" title=\"5 撸下最后的日历Cell\"></a>5 撸下最后的日历Cell</h2><p>这个就是日历里面的item，还是相当简单的。</p>\n<h3 id=\"5-1-全局变量\"><a href=\"#5-1-全局变量\" class=\"headerlink\" title=\"5.1 全局变量\"></a>5.1 全局变量</h3><pre><code class=\"line-numbers language-Swift\">class CalendarCell: UICollectionViewCell &#123;\n    \n    static var identifier = &quot;UICollectionViewCell&quot;\n    \n    var isGreaterThan: Bool = false     //是否取大于今天的值\n    \n    var isShowPassTime: Int = 0         //是否设定禁选\n    \n    var model:TimeModel?&#123;\n        didSet&#123;\n            guard let _model = model else &#123;return&#125;\n            if _model.day != 0 &#123;\n                titleLab.text = &quot;\\(_model.day)&quot;\n            &#125;else&#123;\n                titleLab.text = &quot;&quot; // 为0，啥也不显示\n            &#125;\n            \n            let com = YSDateTool.currentDateCom()\n            \n            // 是否是选中的日子\n            if com.year == _model.year &amp;&amp; com.month == _model.month &amp;&amp; com.day == _model.day &#123;\n                titleLab.textColor = UIColor.init(hex: &quot;#409EFF&quot;)\n            &#125;else&#123;\n                titleLab.textColor = UIColor.init(hex: &quot;#323233&quot;)\n            &#125;\n            \n            // 禁用还是可用\n            if isShowPassTime == 0 &#123;\n                if isGreaterThan &#123;\n                    if (com.year == _model.year &amp;&amp; com.month == _model.month &amp;&amp; _model.day &gt; com.day!) || (_model.year == com.year! &amp;&amp; _model.month &gt; com.month!) || (_model.year &gt; com.year!)&#123;\n                        titleLab.textColor = UIColor.init(hex: &quot;#C8C9CC&quot;)\n                    &#125;\n                &#125;else&#123;\n                    // 如果要大于今天，那么前面的时间就的置灰了 前一个月的点不过去，不考虑了\n                    if com.year == _model.year &amp;&amp; com.month == _model.month &amp;&amp; _model.day &lt; com.day!&#123;\n                        titleLab.textColor = UIColor.init(hex: &quot;#C8C9CC&quot;)\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    \n    // 选中的item，背景颜色高亮\n    var selectedModel: TimeModel?&#123;\n        didSet&#123;\n            guard let _model = selectedModel else&#123;return&#125;\n            if _model.year == model?.year &amp;&amp; _model.month == model?.month &amp;&amp; _model.day == model?.day&#123;\n                titleLab.backgroundColor = UIColor.init(hex: &quot;#409EFF&quot;)\n                titleLab.textColor = UIColor.white\n            &#125;else&#123;\n                titleLab.backgroundColor = UIColor.clear\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>比较重要的是model，表示当前时间实体类。这里监听变量改变，利用didSet实现动态改变文案效果。</p>\n<p>另外一个是selectedModel，这个是当前选中的item，会比对item是否为选中，选中样式会有所不同。</p>\n<h3 id=\"5-2-UI子View\"><a href=\"#5-2-UI子View\" class=\"headerlink\" title=\"5.2 UI子View\"></a>5.2 UI子View</h3><p>这里只用到一个子View。</p>\n<pre><code class=\"line-numbers language-Swift\">var titleLab: UILabel = &#123;\n        let lan = UILabel()\n        lan.font = .pingFangRegular(size: 16)\n        lan.textAlignment = .center\n        lan.textColor = UIColor.init(hex: &quot;#323233&quot;)\n        \n        lan.layer.cornerRadius = 4\n        lan.layer.masksToBounds = true\n        return lan\n    &#125;()\n</code></pre>\n<h3 id=\"5-3-生命周期函数\"><a href=\"#5-3-生命周期函数\" class=\"headerlink\" title=\"5.3 生命周期函数\"></a>5.3 生命周期函数</h3><pre><code class=\"line-numbers language-Swift\">override init(frame: CGRect) &#123;\n        super.init(frame: frame)\n        contentView.backgroundColor = .clear\n        contentView.addSubview(titleLab)\n        titleLab.snp.makeConstraints&#123;make in\n            make.top.bottom.leading.trailing.equalToSuperview()\n        &#125;\n    &#125;\n    \n    required init?(coder aDecoder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n</code></pre>\n<p>把那个子View添加到Cell里面去了。</p>\n<p>大概就是这样子。</p>\n<h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6 总结\"></a>6 总结</h2><ul>\n<li><p>如果UI图有那种Tab页，就可以考虑使用多种方案来实现，iOS直接用简单的Button也是可以实现的，分割线也是可以用最简单的UIView来实现，不一定要用封装好的框架，谁用挖掘机来搬小石头呢，大材小用了。</p>\n</li>\n<li><p>分页效果可以使用UIScrollView来实现，把它宽度设置为屏幕的n倍，这样最有滑动可以很好控制的，不要动画也可以设置的，办法总是就很多的。</p>\n</li>\n<li><p>日历效果可以用UICollectionView来实现，看着很复杂，其实很简单，主要逻辑也不复杂，控制好数据刷新就好了。UICollectionView可以实现类似网格的效果，我们只需要在Cell里面绘制一个一个Cell，空的部分，我们啥不展示就好了。</p>\n</li>\n<li><p>系统的UIPickerView设置分割线很简单，利用UIPickerView下有一个subViews，这里寻找高度为item高度大小的，然后给view设置一个Layer即可。</p>\n</li>\n</ul>\n"},{"title":"iOS 学习导航","date":"2023-01-22T23:38:41.000Z","top":true,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 知识体系\n\n### 1.1 Swift相关\n> [https://github.com/CocoaChina-editors/Welcome-to-Swift](https://github.com/CocoaChina-editors/Welcome-to-Swift)\n\n### 1.2 SwiftUI自学站点\n> [https://www.openswiftui.com/](https://www.openswiftui.com/)\n\n### 1.3 Swift编程语言中文教程\n> [https://swift.bootcss.com/](https://swift.bootcss.com/)\n\n## 2 优秀站点\n\n### 2.1 国外世界级iOS讨论\n> [https://www.objc.io/](https://www.objc.io/)\n\n### 2.2 Nshipster示例代码\n> [https://nshipster.com/](https://nshipster.com/)\n\n### 2.3 iOS周报\n> [https://iosdevweekly.com/](https://iosdevweekly.com/)\n\n### 2.4 Appcode\n> [https://www.appcoda.com/](https://www.appcoda.com/)\n\n### 2.5 简书\n> [https://www.jianshu.com/c/3233d1a249ca](https://www.jianshu.com/c/3233d1a249ca)\n\n### 2.6 掘金\n> [https://juejin.cn/ios](https://juejin.cn/ios)\n\n### 2.7 CSDN\n> [https://blog.csdn.net/nav/mobile/ios](https://blog.csdn.net/nav/mobile/ios)\n\n### 2.8 Bbsmax\n> [https://www.bbsmax.com/search/IOS/](https://www.bbsmax.com/search/IOS/)\n\n### 2.9 github 上swift每周趋势\n> [https://github.com/trending/swift?since=daily](https://github.com/trending/swift?since=weekly)\n\n### 2.10 github 上iOS话题\n> [https://github.com/topics/ios](https://github.com/topics/ios)\n\n\n\n## 3 公众号\n\n### 3.1 iOS开发\n<img src=iOSkaifa.jpeg>\n\n[https://open.weixin.qq.com/qr/code?username=DS3589](https://open.weixin.qq.com/qr/code?username=DS3589)\n\n### 3.2 移动端Android和iOS开发技术分享\n<img src=mobile_tech_share.jpeg>\n\n[https://open.weixin.qq.com/qr/code?username=mobile_tech_share](https://open.weixin.qq.com/qr/code?username=mobile_tech_share)\n\n\n## 4 大神博客\n\n### 4.1 学良大哥\n> [https://ficowshen.com/](https://ficowshen.com/)\n\n\n## 5 优秀三方库\n\n### 5.1 常用三方库，插件，知名博客\n> [https://github.com/Tim9Liu9/TimLiu-iOS](https://github.com/Tim9Liu9/TimLiu-iOS)\n\n### 5.2 awesome-ios\n> 记录了很多关于iOS的三方库 [https://github.com/vsouza/awesome-ios](https://github.com/vsouza/awesome-ios)\n\n### 5.3 AFnetworking\n> [https://github.com/AFNetworking/AFNetworking](https://github.com/AFNetworking/AFNetworking)\n\n### 5.4 RxSwift\n> 参考博客《麻烦给我的爱人来一杯RxSwift》 [https://juejin.cn/post/6844904191161286670](https://juejin.cn/post/6844904191161286670)\n\n\n\n## 6 项目推荐\n\n### 6.1 NextCloud\n> [https://github.com/nextcloud/ios](https://github.com/nextcloud/ios)\n\n### 6.2 github 开源项目\n> [https://github.com/panbin/panbin-ios/blob/master/Swift.md](https://github.com/panbin/panbin-ios/blob/master/Swift.md)\n\n### 6.3 gitee仓库中的swift项目\n> [https://gitee.com/explore/all?lang=Swift](https://gitee.com/explore/all?lang=Swift)\n\n### 6.4 gitee客户端SwiftUI\n> [https://gitee.com/open-gitee/gitee_ios](https://gitee.com/open-gitee/gitee_ios)\n\n## 7 其它\n\n### 7.1 面试相关\n\n### 7.2 开发工具相关\n\n","source":"_posts/iOS-学习导航.md","raw":"---\ntitle: iOS 学习导航\ndate: 2023-01-23 07:38:41\ntop: true\ncover: false\ntoc: true\nmathjax: true\ntags:\n- iOS\ncategories:\n- iOS\n---\n\n## 1 知识体系\n\n### 1.1 Swift相关\n> [https://github.com/CocoaChina-editors/Welcome-to-Swift](https://github.com/CocoaChina-editors/Welcome-to-Swift)\n\n### 1.2 SwiftUI自学站点\n> [https://www.openswiftui.com/](https://www.openswiftui.com/)\n\n### 1.3 Swift编程语言中文教程\n> [https://swift.bootcss.com/](https://swift.bootcss.com/)\n\n## 2 优秀站点\n\n### 2.1 国外世界级iOS讨论\n> [https://www.objc.io/](https://www.objc.io/)\n\n### 2.2 Nshipster示例代码\n> [https://nshipster.com/](https://nshipster.com/)\n\n### 2.3 iOS周报\n> [https://iosdevweekly.com/](https://iosdevweekly.com/)\n\n### 2.4 Appcode\n> [https://www.appcoda.com/](https://www.appcoda.com/)\n\n### 2.5 简书\n> [https://www.jianshu.com/c/3233d1a249ca](https://www.jianshu.com/c/3233d1a249ca)\n\n### 2.6 掘金\n> [https://juejin.cn/ios](https://juejin.cn/ios)\n\n### 2.7 CSDN\n> [https://blog.csdn.net/nav/mobile/ios](https://blog.csdn.net/nav/mobile/ios)\n\n### 2.8 Bbsmax\n> [https://www.bbsmax.com/search/IOS/](https://www.bbsmax.com/search/IOS/)\n\n### 2.9 github 上swift每周趋势\n> [https://github.com/trending/swift?since=daily](https://github.com/trending/swift?since=weekly)\n\n### 2.10 github 上iOS话题\n> [https://github.com/topics/ios](https://github.com/topics/ios)\n\n\n\n## 3 公众号\n\n### 3.1 iOS开发\n<img src=iOSkaifa.jpeg>\n\n[https://open.weixin.qq.com/qr/code?username=DS3589](https://open.weixin.qq.com/qr/code?username=DS3589)\n\n### 3.2 移动端Android和iOS开发技术分享\n<img src=mobile_tech_share.jpeg>\n\n[https://open.weixin.qq.com/qr/code?username=mobile_tech_share](https://open.weixin.qq.com/qr/code?username=mobile_tech_share)\n\n\n## 4 大神博客\n\n### 4.1 学良大哥\n> [https://ficowshen.com/](https://ficowshen.com/)\n\n\n## 5 优秀三方库\n\n### 5.1 常用三方库，插件，知名博客\n> [https://github.com/Tim9Liu9/TimLiu-iOS](https://github.com/Tim9Liu9/TimLiu-iOS)\n\n### 5.2 awesome-ios\n> 记录了很多关于iOS的三方库 [https://github.com/vsouza/awesome-ios](https://github.com/vsouza/awesome-ios)\n\n### 5.3 AFnetworking\n> [https://github.com/AFNetworking/AFNetworking](https://github.com/AFNetworking/AFNetworking)\n\n### 5.4 RxSwift\n> 参考博客《麻烦给我的爱人来一杯RxSwift》 [https://juejin.cn/post/6844904191161286670](https://juejin.cn/post/6844904191161286670)\n\n\n\n## 6 项目推荐\n\n### 6.1 NextCloud\n> [https://github.com/nextcloud/ios](https://github.com/nextcloud/ios)\n\n### 6.2 github 开源项目\n> [https://github.com/panbin/panbin-ios/blob/master/Swift.md](https://github.com/panbin/panbin-ios/blob/master/Swift.md)\n\n### 6.3 gitee仓库中的swift项目\n> [https://gitee.com/explore/all?lang=Swift](https://gitee.com/explore/all?lang=Swift)\n\n### 6.4 gitee客户端SwiftUI\n> [https://gitee.com/open-gitee/gitee_ios](https://gitee.com/open-gitee/gitee_ios)\n\n## 7 其它\n\n### 7.1 面试相关\n\n### 7.2 开发工具相关\n\n","slug":"iOS-学习导航","published":1,"updated":"2023-02-06T07:38:05.623Z","_id":"cldlhfhyw001pivv7acg9clnq","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-知识体系\"><a href=\"#1-知识体系\" class=\"headerlink\" title=\"1 知识体系\"></a>1 知识体系</h2><h3 id=\"1-1-Swift相关\"><a href=\"#1-1-Swift相关\" class=\"headerlink\" title=\"1.1 Swift相关\"></a>1.1 Swift相关</h3><blockquote>\n<p><a href=\"https://github.com/CocoaChina-editors/Welcome-to-Swift\">https://github.com/CocoaChina-editors/Welcome-to-Swift</a></p>\n</blockquote>\n<h3 id=\"1-2-SwiftUI自学站点\"><a href=\"#1-2-SwiftUI自学站点\" class=\"headerlink\" title=\"1.2 SwiftUI自学站点\"></a>1.2 SwiftUI自学站点</h3><blockquote>\n<p><a href=\"https://www.openswiftui.com/\">https://www.openswiftui.com/</a></p>\n</blockquote>\n<h3 id=\"1-3-Swift编程语言中文教程\"><a href=\"#1-3-Swift编程语言中文教程\" class=\"headerlink\" title=\"1.3 Swift编程语言中文教程\"></a>1.3 Swift编程语言中文教程</h3><blockquote>\n<p><a href=\"https://swift.bootcss.com/\">https://swift.bootcss.com/</a></p>\n</blockquote>\n<h2 id=\"2-优秀站点\"><a href=\"#2-优秀站点\" class=\"headerlink\" title=\"2 优秀站点\"></a>2 优秀站点</h2><h3 id=\"2-1-国外世界级iOS讨论\"><a href=\"#2-1-国外世界级iOS讨论\" class=\"headerlink\" title=\"2.1 国外世界级iOS讨论\"></a>2.1 国外世界级iOS讨论</h3><blockquote>\n<p><a href=\"https://www.objc.io/\">https://www.objc.io/</a></p>\n</blockquote>\n<h3 id=\"2-2-Nshipster示例代码\"><a href=\"#2-2-Nshipster示例代码\" class=\"headerlink\" title=\"2.2 Nshipster示例代码\"></a>2.2 Nshipster示例代码</h3><blockquote>\n<p><a href=\"https://nshipster.com/\">https://nshipster.com/</a></p>\n</blockquote>\n<h3 id=\"2-3-iOS周报\"><a href=\"#2-3-iOS周报\" class=\"headerlink\" title=\"2.3 iOS周报\"></a>2.3 iOS周报</h3><blockquote>\n<p><a href=\"https://iosdevweekly.com/\">https://iosdevweekly.com/</a></p>\n</blockquote>\n<h3 id=\"2-4-Appcode\"><a href=\"#2-4-Appcode\" class=\"headerlink\" title=\"2.4 Appcode\"></a>2.4 Appcode</h3><blockquote>\n<p><a href=\"https://www.appcoda.com/\">https://www.appcoda.com/</a></p>\n</blockquote>\n<h3 id=\"2-5-简书\"><a href=\"#2-5-简书\" class=\"headerlink\" title=\"2.5 简书\"></a>2.5 简书</h3><blockquote>\n<p><a href=\"https://www.jianshu.com/c/3233d1a249ca\">https://www.jianshu.com/c/3233d1a249ca</a></p>\n</blockquote>\n<h3 id=\"2-6-掘金\"><a href=\"#2-6-掘金\" class=\"headerlink\" title=\"2.6 掘金\"></a>2.6 掘金</h3><blockquote>\n<p><a href=\"https://juejin.cn/ios\">https://juejin.cn/ios</a></p>\n</blockquote>\n<h3 id=\"2-7-CSDN\"><a href=\"#2-7-CSDN\" class=\"headerlink\" title=\"2.7 CSDN\"></a>2.7 CSDN</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/nav/mobile/ios\">https://blog.csdn.net/nav/mobile/ios</a></p>\n</blockquote>\n<h3 id=\"2-8-Bbsmax\"><a href=\"#2-8-Bbsmax\" class=\"headerlink\" title=\"2.8 Bbsmax\"></a>2.8 Bbsmax</h3><blockquote>\n<p><a href=\"https://www.bbsmax.com/search/IOS/\">https://www.bbsmax.com/search/IOS/</a></p>\n</blockquote>\n<h3 id=\"2-9-github-上swift每周趋势\"><a href=\"#2-9-github-上swift每周趋势\" class=\"headerlink\" title=\"2.9 github 上swift每周趋势\"></a>2.9 github 上swift每周趋势</h3><blockquote>\n<p><a href=\"https://github.com/trending/swift?since=weekly\">https://github.com/trending/swift?since=daily</a></p>\n</blockquote>\n<h3 id=\"2-10-github-上iOS话题\"><a href=\"#2-10-github-上iOS话题\" class=\"headerlink\" title=\"2.10 github 上iOS话题\"></a>2.10 github 上iOS话题</h3><blockquote>\n<p><a href=\"https://github.com/topics/ios\">https://github.com/topics/ios</a></p>\n</blockquote>\n<h2 id=\"3-公众号\"><a href=\"#3-公众号\" class=\"headerlink\" title=\"3 公众号\"></a>3 公众号</h2><h3 id=\"3-1-iOS开发\"><a href=\"#3-1-iOS开发\" class=\"headerlink\" title=\"3.1 iOS开发\"></a>3.1 iOS开发</h3><img src=iOSkaifa.jpeg>\n\n<p><a href=\"https://open.weixin.qq.com/qr/code?username=DS3589\">https://open.weixin.qq.com/qr/code?username=DS3589</a></p>\n<h3 id=\"3-2-移动端Android和iOS开发技术分享\"><a href=\"#3-2-移动端Android和iOS开发技术分享\" class=\"headerlink\" title=\"3.2 移动端Android和iOS开发技术分享\"></a>3.2 移动端Android和iOS开发技术分享</h3><img src=mobile_tech_share.jpeg>\n\n<p><a href=\"https://open.weixin.qq.com/qr/code?username=mobile_tech_share\">https://open.weixin.qq.com/qr/code?username=mobile_tech_share</a></p>\n<h2 id=\"4-大神博客\"><a href=\"#4-大神博客\" class=\"headerlink\" title=\"4 大神博客\"></a>4 大神博客</h2><h3 id=\"4-1-学良大哥\"><a href=\"#4-1-学良大哥\" class=\"headerlink\" title=\"4.1 学良大哥\"></a>4.1 学良大哥</h3><blockquote>\n<p><a href=\"https://ficowshen.com/\">https://ficowshen.com/</a></p>\n</blockquote>\n<h2 id=\"5-优秀三方库\"><a href=\"#5-优秀三方库\" class=\"headerlink\" title=\"5 优秀三方库\"></a>5 优秀三方库</h2><h3 id=\"5-1-常用三方库，插件，知名博客\"><a href=\"#5-1-常用三方库，插件，知名博客\" class=\"headerlink\" title=\"5.1 常用三方库，插件，知名博客\"></a>5.1 常用三方库，插件，知名博客</h3><blockquote>\n<p><a href=\"https://github.com/Tim9Liu9/TimLiu-iOS\">https://github.com/Tim9Liu9/TimLiu-iOS</a></p>\n</blockquote>\n<h3 id=\"5-2-awesome-ios\"><a href=\"#5-2-awesome-ios\" class=\"headerlink\" title=\"5.2 awesome-ios\"></a>5.2 awesome-ios</h3><blockquote>\n<p>记录了很多关于iOS的三方库 <a href=\"https://github.com/vsouza/awesome-ios\">https://github.com/vsouza/awesome-ios</a></p>\n</blockquote>\n<h3 id=\"5-3-AFnetworking\"><a href=\"#5-3-AFnetworking\" class=\"headerlink\" title=\"5.3 AFnetworking\"></a>5.3 AFnetworking</h3><blockquote>\n<p><a href=\"https://github.com/AFNetworking/AFNetworking\">https://github.com/AFNetworking/AFNetworking</a></p>\n</blockquote>\n<h3 id=\"5-4-RxSwift\"><a href=\"#5-4-RxSwift\" class=\"headerlink\" title=\"5.4 RxSwift\"></a>5.4 RxSwift</h3><blockquote>\n<p>参考博客《麻烦给我的爱人来一杯RxSwift》 <a href=\"https://juejin.cn/post/6844904191161286670\">https://juejin.cn/post/6844904191161286670</a></p>\n</blockquote>\n<h2 id=\"6-项目推荐\"><a href=\"#6-项目推荐\" class=\"headerlink\" title=\"6 项目推荐\"></a>6 项目推荐</h2><h3 id=\"6-1-NextCloud\"><a href=\"#6-1-NextCloud\" class=\"headerlink\" title=\"6.1 NextCloud\"></a>6.1 NextCloud</h3><blockquote>\n<p><a href=\"https://github.com/nextcloud/ios\">https://github.com/nextcloud/ios</a></p>\n</blockquote>\n<h3 id=\"6-2-github-开源项目\"><a href=\"#6-2-github-开源项目\" class=\"headerlink\" title=\"6.2 github 开源项目\"></a>6.2 github 开源项目</h3><blockquote>\n<p><a href=\"https://github.com/panbin/panbin-ios/blob/master/Swift.md\">https://github.com/panbin/panbin-ios/blob/master/Swift.md</a></p>\n</blockquote>\n<h3 id=\"6-3-gitee仓库中的swift项目\"><a href=\"#6-3-gitee仓库中的swift项目\" class=\"headerlink\" title=\"6.3 gitee仓库中的swift项目\"></a>6.3 gitee仓库中的swift项目</h3><blockquote>\n<p><a href=\"https://gitee.com/explore/all?lang=Swift\">https://gitee.com/explore/all?lang=Swift</a></p>\n</blockquote>\n<h3 id=\"6-4-gitee客户端SwiftUI\"><a href=\"#6-4-gitee客户端SwiftUI\" class=\"headerlink\" title=\"6.4 gitee客户端SwiftUI\"></a>6.4 gitee客户端SwiftUI</h3><blockquote>\n<p><a href=\"https://gitee.com/open-gitee/gitee_ios\">https://gitee.com/open-gitee/gitee_ios</a></p>\n</blockquote>\n<h2 id=\"7-其它\"><a href=\"#7-其它\" class=\"headerlink\" title=\"7 其它\"></a>7 其它</h2><h3 id=\"7-1-面试相关\"><a href=\"#7-1-面试相关\" class=\"headerlink\" title=\"7.1 面试相关\"></a>7.1 面试相关</h3><h3 id=\"7-2-开发工具相关\"><a href=\"#7-2-开发工具相关\" class=\"headerlink\" title=\"7.2 开发工具相关\"></a>7.2 开发工具相关</h3>","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-知识体系\"><a href=\"#1-知识体系\" class=\"headerlink\" title=\"1 知识体系\"></a>1 知识体系</h2><h3 id=\"1-1-Swift相关\"><a href=\"#1-1-Swift相关\" class=\"headerlink\" title=\"1.1 Swift相关\"></a>1.1 Swift相关</h3><blockquote>\n<p><a href=\"https://github.com/CocoaChina-editors/Welcome-to-Swift\">https://github.com/CocoaChina-editors/Welcome-to-Swift</a></p>\n</blockquote>\n<h3 id=\"1-2-SwiftUI自学站点\"><a href=\"#1-2-SwiftUI自学站点\" class=\"headerlink\" title=\"1.2 SwiftUI自学站点\"></a>1.2 SwiftUI自学站点</h3><blockquote>\n<p><a href=\"https://www.openswiftui.com/\">https://www.openswiftui.com/</a></p>\n</blockquote>\n<h3 id=\"1-3-Swift编程语言中文教程\"><a href=\"#1-3-Swift编程语言中文教程\" class=\"headerlink\" title=\"1.3 Swift编程语言中文教程\"></a>1.3 Swift编程语言中文教程</h3><blockquote>\n<p><a href=\"https://swift.bootcss.com/\">https://swift.bootcss.com/</a></p>\n</blockquote>\n<h2 id=\"2-优秀站点\"><a href=\"#2-优秀站点\" class=\"headerlink\" title=\"2 优秀站点\"></a>2 优秀站点</h2><h3 id=\"2-1-国外世界级iOS讨论\"><a href=\"#2-1-国外世界级iOS讨论\" class=\"headerlink\" title=\"2.1 国外世界级iOS讨论\"></a>2.1 国外世界级iOS讨论</h3><blockquote>\n<p><a href=\"https://www.objc.io/\">https://www.objc.io/</a></p>\n</blockquote>\n<h3 id=\"2-2-Nshipster示例代码\"><a href=\"#2-2-Nshipster示例代码\" class=\"headerlink\" title=\"2.2 Nshipster示例代码\"></a>2.2 Nshipster示例代码</h3><blockquote>\n<p><a href=\"https://nshipster.com/\">https://nshipster.com/</a></p>\n</blockquote>\n<h3 id=\"2-3-iOS周报\"><a href=\"#2-3-iOS周报\" class=\"headerlink\" title=\"2.3 iOS周报\"></a>2.3 iOS周报</h3><blockquote>\n<p><a href=\"https://iosdevweekly.com/\">https://iosdevweekly.com/</a></p>\n</blockquote>\n<h3 id=\"2-4-Appcode\"><a href=\"#2-4-Appcode\" class=\"headerlink\" title=\"2.4 Appcode\"></a>2.4 Appcode</h3><blockquote>\n<p><a href=\"https://www.appcoda.com/\">https://www.appcoda.com/</a></p>\n</blockquote>\n<h3 id=\"2-5-简书\"><a href=\"#2-5-简书\" class=\"headerlink\" title=\"2.5 简书\"></a>2.5 简书</h3><blockquote>\n<p><a href=\"https://www.jianshu.com/c/3233d1a249ca\">https://www.jianshu.com/c/3233d1a249ca</a></p>\n</blockquote>\n<h3 id=\"2-6-掘金\"><a href=\"#2-6-掘金\" class=\"headerlink\" title=\"2.6 掘金\"></a>2.6 掘金</h3><blockquote>\n<p><a href=\"https://juejin.cn/ios\">https://juejin.cn/ios</a></p>\n</blockquote>\n<h3 id=\"2-7-CSDN\"><a href=\"#2-7-CSDN\" class=\"headerlink\" title=\"2.7 CSDN\"></a>2.7 CSDN</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/nav/mobile/ios\">https://blog.csdn.net/nav/mobile/ios</a></p>\n</blockquote>\n<h3 id=\"2-8-Bbsmax\"><a href=\"#2-8-Bbsmax\" class=\"headerlink\" title=\"2.8 Bbsmax\"></a>2.8 Bbsmax</h3><blockquote>\n<p><a href=\"https://www.bbsmax.com/search/IOS/\">https://www.bbsmax.com/search/IOS/</a></p>\n</blockquote>\n<h3 id=\"2-9-github-上swift每周趋势\"><a href=\"#2-9-github-上swift每周趋势\" class=\"headerlink\" title=\"2.9 github 上swift每周趋势\"></a>2.9 github 上swift每周趋势</h3><blockquote>\n<p><a href=\"https://github.com/trending/swift?since=weekly\">https://github.com/trending/swift?since=daily</a></p>\n</blockquote>\n<h3 id=\"2-10-github-上iOS话题\"><a href=\"#2-10-github-上iOS话题\" class=\"headerlink\" title=\"2.10 github 上iOS话题\"></a>2.10 github 上iOS话题</h3><blockquote>\n<p><a href=\"https://github.com/topics/ios\">https://github.com/topics/ios</a></p>\n</blockquote>\n<h2 id=\"3-公众号\"><a href=\"#3-公众号\" class=\"headerlink\" title=\"3 公众号\"></a>3 公众号</h2><h3 id=\"3-1-iOS开发\"><a href=\"#3-1-iOS开发\" class=\"headerlink\" title=\"3.1 iOS开发\"></a>3.1 iOS开发</h3><img src=iOSkaifa.jpeg>\n\n<p><a href=\"https://open.weixin.qq.com/qr/code?username=DS3589\">https://open.weixin.qq.com/qr/code?username=DS3589</a></p>\n<h3 id=\"3-2-移动端Android和iOS开发技术分享\"><a href=\"#3-2-移动端Android和iOS开发技术分享\" class=\"headerlink\" title=\"3.2 移动端Android和iOS开发技术分享\"></a>3.2 移动端Android和iOS开发技术分享</h3><img src=mobile_tech_share.jpeg>\n\n<p><a href=\"https://open.weixin.qq.com/qr/code?username=mobile_tech_share\">https://open.weixin.qq.com/qr/code?username=mobile_tech_share</a></p>\n<h2 id=\"4-大神博客\"><a href=\"#4-大神博客\" class=\"headerlink\" title=\"4 大神博客\"></a>4 大神博客</h2><h3 id=\"4-1-学良大哥\"><a href=\"#4-1-学良大哥\" class=\"headerlink\" title=\"4.1 学良大哥\"></a>4.1 学良大哥</h3><blockquote>\n<p><a href=\"https://ficowshen.com/\">https://ficowshen.com/</a></p>\n</blockquote>\n<h2 id=\"5-优秀三方库\"><a href=\"#5-优秀三方库\" class=\"headerlink\" title=\"5 优秀三方库\"></a>5 优秀三方库</h2><h3 id=\"5-1-常用三方库，插件，知名博客\"><a href=\"#5-1-常用三方库，插件，知名博客\" class=\"headerlink\" title=\"5.1 常用三方库，插件，知名博客\"></a>5.1 常用三方库，插件，知名博客</h3><blockquote>\n<p><a href=\"https://github.com/Tim9Liu9/TimLiu-iOS\">https://github.com/Tim9Liu9/TimLiu-iOS</a></p>\n</blockquote>\n<h3 id=\"5-2-awesome-ios\"><a href=\"#5-2-awesome-ios\" class=\"headerlink\" title=\"5.2 awesome-ios\"></a>5.2 awesome-ios</h3><blockquote>\n<p>记录了很多关于iOS的三方库 <a href=\"https://github.com/vsouza/awesome-ios\">https://github.com/vsouza/awesome-ios</a></p>\n</blockquote>\n<h3 id=\"5-3-AFnetworking\"><a href=\"#5-3-AFnetworking\" class=\"headerlink\" title=\"5.3 AFnetworking\"></a>5.3 AFnetworking</h3><blockquote>\n<p><a href=\"https://github.com/AFNetworking/AFNetworking\">https://github.com/AFNetworking/AFNetworking</a></p>\n</blockquote>\n<h3 id=\"5-4-RxSwift\"><a href=\"#5-4-RxSwift\" class=\"headerlink\" title=\"5.4 RxSwift\"></a>5.4 RxSwift</h3><blockquote>\n<p>参考博客《麻烦给我的爱人来一杯RxSwift》 <a href=\"https://juejin.cn/post/6844904191161286670\">https://juejin.cn/post/6844904191161286670</a></p>\n</blockquote>\n<h2 id=\"6-项目推荐\"><a href=\"#6-项目推荐\" class=\"headerlink\" title=\"6 项目推荐\"></a>6 项目推荐</h2><h3 id=\"6-1-NextCloud\"><a href=\"#6-1-NextCloud\" class=\"headerlink\" title=\"6.1 NextCloud\"></a>6.1 NextCloud</h3><blockquote>\n<p><a href=\"https://github.com/nextcloud/ios\">https://github.com/nextcloud/ios</a></p>\n</blockquote>\n<h3 id=\"6-2-github-开源项目\"><a href=\"#6-2-github-开源项目\" class=\"headerlink\" title=\"6.2 github 开源项目\"></a>6.2 github 开源项目</h3><blockquote>\n<p><a href=\"https://github.com/panbin/panbin-ios/blob/master/Swift.md\">https://github.com/panbin/panbin-ios/blob/master/Swift.md</a></p>\n</blockquote>\n<h3 id=\"6-3-gitee仓库中的swift项目\"><a href=\"#6-3-gitee仓库中的swift项目\" class=\"headerlink\" title=\"6.3 gitee仓库中的swift项目\"></a>6.3 gitee仓库中的swift项目</h3><blockquote>\n<p><a href=\"https://gitee.com/explore/all?lang=Swift\">https://gitee.com/explore/all?lang=Swift</a></p>\n</blockquote>\n<h3 id=\"6-4-gitee客户端SwiftUI\"><a href=\"#6-4-gitee客户端SwiftUI\" class=\"headerlink\" title=\"6.4 gitee客户端SwiftUI\"></a>6.4 gitee客户端SwiftUI</h3><blockquote>\n<p><a href=\"https://gitee.com/open-gitee/gitee_ios\">https://gitee.com/open-gitee/gitee_ios</a></p>\n</blockquote>\n<h2 id=\"7-其它\"><a href=\"#7-其它\" class=\"headerlink\" title=\"7 其它\"></a>7 其它</h2><h3 id=\"7-1-面试相关\"><a href=\"#7-1-面试相关\" class=\"headerlink\" title=\"7.1 面试相关\"></a>7.1 面试相关</h3><h3 id=\"7-2-开发工具相关\"><a href=\"#7-2-开发工具相关\" class=\"headerlink\" title=\"7.2 开发工具相关\"></a>7.2 开发工具相关</h3>"},{"title":"玩Android Compose版本 项目分析","date":"2023-01-17T03:23:20.000Z","top":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n> 玩Android(compose版本)项目地址：[https://github.com/yellowhai/PlayAndroid](https://github.com/yellowhai/PlayAndroid)\n\n### 1.项目settings.gradle\n\n```groovy\ndependencyResolutionManagement {\n    /**\n     * 原文中说默认情况下，项目中的存储库会覆盖设置中的存储库 ，可以通过设置模式来更改这种行为\n     设置存储库的方法：\n     repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n     存储库模式：\n     PREFER_PROJECT(true)--首选项目存储库\n     PREFER_SETTINGS(false)--首选设置存储库\n     FAIL_ON_PROJECT_REPOS(false)--强制设置存储库\n     */\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories {\n        google()\n        mavenCentral()\n        maven { url \"https://jitpack.io\" }\n        maven {\n            url 'https://maven.aliyun.com/repository/public/'\n        }\n        maven { url 'https://maven.aliyun.com/repository/public' }\n        maven { url 'https://maven.aliyun.com/repository/central' }\n        maven { url 'https://maven.aliyun.com/repository/google' }\n        maven { url 'https://maven.aliyun.com/repository/public' }\n        maven { url 'https://maven.aliyun.com/repository/gradle-plugin' }\n    }\n}\nrootProject.name = \"PlayAndroid\"\ninclude ':app'\ninclude ':common'\ninclude ':h_mine'\ninclude ':toolkit'\n```\n\n还是很容易理解的，repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)这个是新增的，简单看下就行。\n引入了app模块(主模块)，common模块（通用模块，用于通用组件相关）,h_mine模块（我的模块，可以单独编译）。\n\n### 2.config.gradle\n这个文件相信大家都有用过的，配置远程依赖的一个文件，统一管理。\n```groovy\next{\n    isRelease = true\n\n    //android构建配置\n    android_models = [\n            compileSdk : 32,\n            minSdk : 23,\n            targetSdk : 32,\n            versionCode : 1,\n            versionName : \"1.0\"\n    ]\n    \n    app_id = [\n            mine      : 'com.hh.mine',\n    ]\n\n    core_ktx_version = '1.7.0'\n    appcompat_version = '1.4.0'\n    lifecycle_version = '2.4.0'\n    material_version = '1.4.0'\n    work_version = '2.7.1'\n    gson_version = '2.8.9'\n    litepal_version = '3.2.3'\n    landscapist_version = '1.4.5'\n    retrofit_version = '2.9.0'\n    okhttp_version = '4.9.3'\n    startup_version = '1.1.0'\n    XXPermissions_version = '13.2'\n    datastore_version = '1.0.0'\n    materialDialog_version = '0.6.2'\n    accompanist_version = '0.25.0'\n\n\n    jetpack_compose = [\n            material : \"androidx.compose.material:material:$compose_version\",\n            activity : \"androidx.activity:activity-compose:$appcompat_version\",\n    ]\n\n    commonApi = [\n            ktx_core        : \"androidx.core:core-ktx:$core_ktx_version\",\n            lifecycle       : \"androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version\",\n            appcompat       : \"androidx.appcompat:appcompat:$appcompat_version\",\n            material        : \"com.google.android.material:material:$material_version\",\n            //数据存储\n            datastore       : \"androidx.datastore:datastore-preferences:$datastore_version\",\n            //权限处理\n            XXPermissions   : \"com.github.getActivity:XXPermissions:$XXPermissions_version\",\n    ]\n\n    net = [\n            retrofit    : \"com.squareup.retrofit2:retrofit:$retrofit_version\",\n            converter   : \"com.squareup.retrofit2:converter-gson:$retrofit_version\",\n            okhttp      : \"com.squareup.okhttp3:logging-interceptor:$okhttp_version\",\n            gson        : \"com.google.code.gson:gson:$gson_version\"\n    ]\n\n    accompanist_ui = [\n            insets_ui    : \"com.google.accompanist:accompanist-insets-ui:$accompanist_version\",\n            navigation   : \"com.google.accompanist:accompanist-navigation-animation:$accompanist_version\",\n            pager        : \"com.google.accompanist:accompanist-pager:$accompanist_version\",\n            swiperefresh : \"com.google.accompanist:accompanist-swiperefresh:$accompanist_version\",\n            flowlayout   : \"com.google.accompanist:accompanist-flowlayout:$accompanist_version\",\n            systemUi     : \"com.google.accompanist:accompanist-systemuicontroller:$accompanist_version\",\n            webview      : \"com.google.accompanist:accompanist-webview:$accompanist_version\"\n    ]\n\n    database =[\n            litepal :  \"org.litepal.guolindev:core:$litepal_version\"\n    ]\n\n    skydoves_coil = [\n            landscapist_coil :  \"com.github.skydoves:landscapist-coil:$landscapist_version\"\n    ]\n\n    workManager = [\n            // Kotlin + coroutines\n            work = \"androidx.work:work-runtime-ktx:$work_version\"\n    ]\n\n    material_dialog = [\n            color : \"io.github.vanpra.compose-material-dialogs:color:$materialDialog_version\",\n            core  : \"io.github.vanpra.compose-material-dialogs:core:$materialDialog_version\",\n            datetime  : \"io.github.vanpra.compose-material-dialogs:datetime:$materialDialog_version\"\n    ]\n\n    paging = \"androidx.paging:paging-compose:1.0.0-alpha14\"\n\n    jetpackComposeLibs = jetpack_compose.values()\n    commonApiLibs = commonApi.values()\n    netLibs = net.values()\n    materialDialogLibs = material_dialog.values()\n}\n```\n层次还是比较清晰，对于同一组单独建立数组存储，模块中只需要引入一个就将这组全部引入进去了。\n\n### 3.app模块下的build.gradle\n\n显示引入com.android.application+kotlin-android的插件。\n下面配置android闭包，很简单。\n\n其它关于compose的也需要配置下：\n```groovy\n compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n    buildFeatures {\n        compose true\n    }\n    composeOptions {\n        kotlinCompilerExtensionVersion compose_version\n        kotlinCompilerVersion kotlin_version\n    }\n```\n\n然后是远程依赖：\n```groovy\ndependencies {\n    // 如果是release模式，就把我的模块加进来\n    if(isRelease){\n        implementation project(':h_mine')\n    }\n\n    // 初始化组件\n    implementation \"androidx.startup:startup-runtime:$startup_version\"\n    implementation project(':common')\n\n    // 测试相关\n    testImplementation 'junit:junit:4.13.2'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.3'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'\n    androidTestImplementation \"androidx.compose.ui:ui-test-junit4:$compose_version\"\n    androidTestImplementation \"androidx.compose.ui:ui-test-junit4:$compose_version\"\n    debugImplementation \"androidx.compose.ui:ui-tooling:$compose_version\"\n\n}\n```\n\nisRelease定义在 config.gradle的顶部。如果是集成编译就为true，单独编译为false。\n\n### 4.app模块的AndroidManifest.xml\n* 配置Application\n* 配置主页\n* 配置provider，用于初始化sdk\n    ```xml\n      <!--  用provider初始化sdk-->\n        <provider\n            android:name=\"androidx.startup.InitializationProvider\"\n            android:authorities=\"${applicationId}.androidx-startup\"\n            android:exported=\"false\"\n            tools:node=\"merge\">\n            <meta-data\n                android:name=\"com.hh.playandroid.base.BaseInitializer\"\n                android:value=\"androidx.startup\" />\n        </provider>\n    ```\n\n### 5.自定义Application\n ```\n class HhfApp : YshhApplication()\n ```   \n 依赖common模块：\n ```Kotlin\n open class YshhApplication : Application() {\n\n    lateinit var okbuilder: OkHttpClient\n\n    companion object {\n        /**\n         * application context.\n         */\n        @SuppressLint(\"StaticFieldLeak\")\n        lateinit var context: Context\n\n        @SuppressLint(\"StaticFieldLeak\")\n        lateinit var instance: YshhApplication\n\n        /**\n         * application级别的协程\n         * 有时我们需要在协程上下文中定义多个元素，组合协程上下文中的元素，使用 + 操作符来创建 CoroutineScope .\n         */\n        val applicationScope = CoroutineScope(SupervisorJob() + Dispatchers.Main)\n    }\n ```\n 这里懒加载OkHttpClient\n 定义了全局的协程，静态变量。\n\n ```Kotlin\n   override fun onCreate() {\n        super.onCreate()\n        context = applicationContext\n        instance = this\n        initRetrofit()\n    }\n ```\n 初始化Retrofit：\n ```Kotlin\n  /**\n     * 初始化Retrofit\n     */\n    private fun initRetrofit(token : String = \"\"): OkHttpClient {\n        //请求头\n        val headerInterceptor = Interceptor { chain: Interceptor.Chain ->\n            val orignaRequest = chain.request()\n            val request = orignaRequest.newBuilder()\n                .header(\"Authorization\", \"Bearer $token\")\n                .method(orignaRequest.method, orignaRequest.body)\n                .build()\n            chain.proceed(request)\n        }\n        val logInterceptor = LogInterceptor {\n//            it.logE()\n        }\n        // 日志类别\n        logInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);\n        // 缓存相关\n        val cacheFile =\n            File(getExternalFilesDir(Environment.DIRECTORY_PICTURES).toString() + \"http_cache\")\n        val cache = Cache(cacheFile, 104857600L) // 指定缓存大小100Mb\n        val builder = OkHttpClient.Builder()\n        //        builder.addInterceptor(addQueryParameterInterceptor);\n        builder.addInterceptor(headerInterceptor)\n        builder.cache(cache)\n        builder.addNetworkInterceptor(logInterceptor)\n        builder.cookieJar(cookieJar)\n        builder.readTimeout(60000, TimeUnit.MILLISECONDS)\n        //全局的写入超时时间60s\n        builder.writeTimeout(60000, TimeUnit.MILLISECONDS)\n        //全局的连接超时时间30s\n        builder.connectTimeout(30000, TimeUnit.MILLISECONDS)\n        okbuilder = builder.build()\n        return builder.build()\n    }\n\n    private val cookieJar: PersistentCookieJar by lazy {\n        PersistentCookieJar(SetCookieCache(), SharedPrefsCookiePersistor(context))\n    }\n    \n    fun getOkBuilder(): OkHttpClient {\n        return okbuilder\n    }\n ```\n\n ### 6.首页 MainActivity\n 继承BaseActivity:\n ```Kotlin\n\n/**\n * 基类Activity 设置非沉浸式，因为要设置导航栏和状态栏颜色\n */\nabstract class BaseActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        WindowCompat.setDecorFitsSystemWindows(window, false)\n    }\n\n}\n ```\n\nonCreate生命周期：\n```Kotlin\n @Suppress(\"DEPRECATED_IDENTITY_EQUALS\")\n    @OptIn(ExperimentalAnimationApi::class)\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        // 动画渐变\n        overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out)\n        // 设置内容\n        setContent {\n            Log.e(\"TEST##\", \"开始setContent了\")\n            // 顶层为自定义主题\n            HhfTheme(\n                // 是否暗色或亮色，跟随系统，如果用户主动设置，跟随用户\n                theme = if (isSystemInDarkTheme() || isNight) HhfTheme.Theme.Dark else HhfTheme.Theme.Light,\n                // 用户自行设置的颜色主题\n                colorTheme = appTheme\n            ) {\n                // 创建一个MainViewModel\n                val viewModel : MainViewModel = viewModel()\n\n                // 如果isSplash为true,就展示SplashView 启动页\n                if (viewModel.isSplash) {\n                    Log.e(\"TEST##\", \"加载闪屏了\")\n                    SplashView { viewModel.isSplash = false }\n                } else {\n                    Log.e(\"TEST##\", \"加载首页了\")\n                    // 全局静态变量存 底部控制器\n                    CpNavigation.navHostController = rememberAnimatedNavController()\n                    // 主页面\n                    HhfNavigation()\n                    // 进度条\n                    DialogProgress()\n                }\n                // 是否纪念日，将App置灰\n                if(isMourningDay()){\n                    Canvas(modifier = Modifier.fillMaxSize()){\n                        drawRect(color = Color.White,blendMode = BlendMode.Saturation)\n                    }\n                }\n            }\n        }\n        addCallback()\n    }\n```\n因为这个app就一个Activity，setContent中的内容就是展现给用户可以看到的所有东西了。\n顶层是一个自定义主题：\n```Kotlin\n@Composable\nfun HhfTheme(\n    theme: HhfTheme.Theme = HhfTheme.Theme.Light,\n    colorTheme: Color? = null,\n    content: @Composable () -> Unit\n) {\n    val targetColors = if (theme == HhfTheme.Theme.Dark) {\n        colorTheme?.let {\n            rememberSystemUiController().setNavigationBarColor(colorTheme)\n            DarkColorPalette.apply {\n                themeColor = it\n            }\n        }?:DarkColorPalette\n    } else {\n        colorTheme?.let {\n            rememberSystemUiController().setNavigationBarColor(colorTheme)\n            LightColorPalette.apply {\n                themeColor = it\n            }\n        }?:LightColorPalette\n    }\n    val themeColor = animateColorAsState(targetColors.themeColor, TweenSpec(600))\n    val textColor = animateColorAsState(targetColors.textColor, TweenSpec(600))\n    val background = animateColorAsState(targetColors.background,TweenSpec(600))\n    val listItem =  animateColorAsState(targetColors.listItem,TweenSpec(600))\n    val bottomBar =  animateColorAsState(targetColors.bottomBar,TweenSpec(600))\n    val divider =  animateColorAsState(targetColors.divider,TweenSpec(600))\n    val textFieldBackground =  animateColorAsState(targetColors.textFieldBackground,TweenSpec(600))\n    val colors = HhfColors(themeColor.value,\n        textColor.value,\n        background = background.value,\n        listItem = listItem.value,\n        bottomBar = bottomBar.value,\n        divider = divider.value,\n        textFieldBackground = textFieldBackground.value,\n        )\n    CompositionLocalProvider(LocalHhfColors provides colors) {\n        MaterialTheme(\n            shapes = Shapes,\n            typography = typography\n        ) {\n            content.invoke()\n        }\n    }\n}\n```\n这里用到了一个 CompositionLocalProvider，具体用法可以参考 [https://juejin.cn/post/7097890697721675813](https://juejin.cn/post/7097890697721675813)\n\n在Compose函数里，如果要用到函数外提供的值，一般都要通过函数定义好参数，外部调用时传入进去。\n这种方法表面看没啥问题，但在一些场景下就不是很方便。比如一个函数A嵌套一个函数B，函数B嵌套函数C，并且这A、B、C的函数都用到这个参数，那对三个函数来说都需要定义这个参数，就不是那么方便。\n那用个全局变量不就可以解决需要重复定义参数，确实可以。但全局变量有个副作用就是影响的范围比较大。本身我们定义的参数只会影响到函数内部。这个时候我们就可以使用CompositionLocal：它具有穿透函数功能的局部变量\nCompositionLocal适用场景：用来提供上下文数据，不扩大影响范围。\n\n然后最终主题呈现是用了 MaterialTheme这个类展现。\n\n回到首页，内容区：\n* 闪屏页展示逻辑\n    通过一个变量：`  var isSplash by mutableStateOf(true)` 实现控制是否显示\n*  加载首页\n    先 展示主页面，覆盖一层 进度条\n* 是否纪念日\n    app置灰处理    \n* 添加二次点击返回退出app逻辑\n\n首页逻辑基本就这么多了。\n\n### 7.闪屏ui -> SplashView\n看下效果先：\n<img src=%E9%97%AA%E5%B1%8F%E9%A1%B5.gif width = 50%>\n\n可以看到进入app后有个启动页面，中间是logo。\n那这个页面有个渐变动画，淡入淡出效果。\n\n具体ui是这样的：\n```Kotlin\n@Composable\nfun SplashView(startMain: () -> Unit) {\n    /**\n     * 辅助文字颜色变化 建立的一个mutableState包装的变量，实际上就是bool值\n     */\n    var enabled by remember { mutableStateOf(false) }\n\n    /**\n     * 背景颜色，从0.3alpha主题色变为纯主题色，2s的时间\n     */\n    val bgColor: Color by animateColorAsState(\n        if (enabled) HhfTheme.colors.themeColor\n        else HhfTheme.colors.themeColor.copy(alpha = 0.3f),\n        animationSpec = tween(durationMillis = 2000)\n    )\n\n    /**\n     * 中间文字颜色动画，如果enable为false，0.3alpha的颜色 到纯白色 2s的时间\n     */\n    val textColor: Color by animateColorAsState(\n        if (enabled) Color.White\n        else Color.White.copy(alpha = 0.3f),\n        animationSpec = tween(durationMillis = 2000)\n    )\n\n    // 外层一个Box+中间一个Text\n    Box(\n        Modifier\n            .fillMaxSize()\n            .background(bgColor),\n        contentAlignment = Alignment.Center\n    ) {\n        Text(text = \"PlayAndroid\", color = textColor,style = MaterialTheme.typography.h5)\n    }\n\n    // 开启协程 可以看出Compose里面开启协程的方法\n    LaunchedEffect(Unit) {\n        enabled = true\n        delay(2000)\n        // 2s后，设置 mutableStateOf 包装的bool变量 为false 会通知首页重新走setContent方法\n        startMain.invoke()\n    }\n}\n```\n\n这里需要理解 animateColorAsState 是官方提供的一个动画，支持颜色变化的一个composable方法。\n\n然后这里开启了2s延迟，怎么开延迟的，调用LaunchedEffect方法里面的delay，可以实现延迟效果。然后执行startMain回调。\n\n这个回调很简单：viewModel.isSplash = false\n\n虽然很简单，但实际上走了很多流程的。\n\n```Kotlin\nclass MainViewModel : ViewModel() {\n    var isSplash by mutableStateOf(true)\n}\n```\n这里使用mutableStateOf包装了一个布尔值。 上面触发这改变时，会刷新composable注解声明的方法体。这里应该就是刷新MainActivity整个内容区了。\n\n\n### 8.主页面外部架构\n```Kotlin\n@ExperimentalAnimationApi\n@OptIn(ExperimentalPagerApi::class)\n@Composable\nfun HhfNavigation() {\n    AnimatedNavHost(navController = CpNavigation.navHostController,\n        /**\n         * 首页默认页面\n         */\n        startDestination = ModelPath.Main.route,\n        enterTransition = { fadeIn(animationSpec = tween(700), initialAlpha = 0f) },\n        exitTransition = { fadeOut(animationSpec = tween(700), targetAlpha = 0f) }) {\n\n        /**\n         * 定义接收到 main 路由消息后->展示MainContent视图\n         */\n        composable(ModelPath.Main.route) {\n            MainContent()\n        }\n\n        /**\n         * 接收到 setting 路由消息后 -> 设置页面\n         */\n        composable(ModelPath.Setting.route) {\n            CpSetting(Modifier.fillMaxSize())\n        }\n        ...\n```\n\n这里使用了一个AnimatedNavHost，这个类是官方提供的。\n这个类里面定义了所有我们需要跳转的页面和初始页。\n然后这个 需要传一个参数，也就是控制器：\n` CpNavigation.navHostController = rememberAnimatedNavController()`\n这里也是官方提供的remember包装的一个控制器。\n\n这里的初始页为：`  startDestination = ModelPath.Main.route,`\n本质上就是一个string，首页的路由。\n\n这样会默认展示首页，怎么展示首页呢？\n```Kotlin\ncomposable(ModelPath.Main.route) {\n            MainContent()\n        }\n```\n那么这个MainContent就是我们的首页。\n\n其它composable里面都是首页可能去哪些页面的路由定义。\n\n那这个比如跳转到设置页面，怎么处理呢？\n* 首先在这个AnimatedNavHost里面定义一个composable闭包\n```Kotlin\n composable(ModelPath.Setting.route) {\n            CpSetting(Modifier.fillMaxSize())\n        }\n```\n\n* 然后再需要跳转的地方调用\n`navHostController.navigate(“setting”)`\n这个navHostController就是我们之前定义的那个控制器，setting就是路由名称。\n这样子就可以跳转到设置页面了。\n\n### 9.主页内部架构框\n首先看下主页效果图\n<img src=%E9%A6%96%E9%A1%B5.jpeg width=50%>\n轮播图+中间列表+底部bar\n轮播图+中间列表可以看成一个整体，那就是内容区+底部bar\n\n架构怎么搭建呢？\n```Kotlin\n   Scaffold(bottomBar = {\n        AnimatedVisibility(\n            visible = bottomSwitch,\n            enter = expandVertically() + fadeIn(), // 操作符重载了，第一个为空，就用第二个\n            exit = shrinkVertically() + fadeOut()  // 操作符重载了，第一个为空，就用第二个\n        ) {\n            // 实际的底部bar 高度使用 固有特性测量 可以参考：https://juejin.cn/post/7068164264363556872\n            MainBottomBar(\n                Modifier\n                    .fillMaxWidth()\n                    .height(IntrinsicSize.Max),pagerState = pagerState) {\n                pagerState.reenableScrolling(coroutineScope, it)\n            }\n        }\n    }) {\n        内容区...\n```\n最外层一个Scafffold脚手架包裹，有点像Flutter了啊。\n然后是一个AnimatedVisibility，这个控制显示隐藏的动画组件。重点看里面的MainBottomBar，就找到了我们的底部bar了。\n\n这个看起来像自定义的，具体怎么实现的呢？\n```Kotlin\n/**\n * App底部bar\n */\n@OptIn(ExperimentalPagerApi::class)\n@Composable\nprivate fun MainBottomBar(\n    modifier: Modifier = Modifier,\n    pagerState: PagerState,\n    currentChanged: (Int) -> Unit\n) {\n    /**\n     * 这个BottomAppBar是官方的\n     */\n    BottomAppBar(\n        modifier.navigationBarsPadding(),\n        cutoutShape = CircleShape,\n        backgroundColor = HhfTheme.colors.bottomBar,\n        elevation = 5.dp\n    ) {\n        // 遍历4个tab\n        bottomList.forEachIndexed { index, item ->\n            // item单独设置 官方组件\n            BottomNavigationItem(\n                selected = pagerState.currentPage == index, onClick = {\n                    /**\n                     * item点击事件回调给上层\n                     */\n                    currentChanged(index)\n                }, icon = {\n                    /**\n                     * icon为官方组件\n                     */\n                    Icon(\n                        item.dashboardState.icon,\n                        contentDescription = item.name,\n                        tint = if (pagerState.currentPage == index) {\n                            HhfTheme.colors.themeColor\n                        } else {\n                            LocalContentColor.current.copy(alpha = LocalContentAlpha.current)\n                        }, modifier = Modifier.size(24.dp)\n                    )\n                }, label = {\n                    Text(\n                        text = item.name,\n                        color = if (pagerState.currentPage == index) {\n                            HhfTheme.colors.themeColor\n                        } else {\n                            LocalContentColor.current.copy(alpha = LocalContentAlpha.current)\n                        },\n                        fontSize = 12.sp\n                    )\n                },\n                unselectedContentColor = LocalContentColor.current.copy(alpha = LocalContentAlpha.current),\n                selectedContentColor = HhfTheme.colors.themeColor,\n                alwaysShowLabel = true\n\n            )\n        }\n    }\n}\n```\n这里看出底部bar就是用了官方的BottomAppBar。\n里面具体内容是我们开发者自行设定的，这里遍历了bottomList，这个集合就是我们自己定义的一个集合：\n```Kotlin\n/**\n * 底部List集合 这里定义了4块\n * 首页，项目，公众号，我的\n */\nval bottomList = listOf(\n    BottomBean(\n        DashboardState.Home,\n        YshhApplication.context.stringResource(R.string.main_title_home)\n    ),\n    BottomBean(\n        DashboardState.Project,\n        YshhApplication.context.stringResource(R.string.main_title_project)\n    ),\n    BottomBean(\n        DashboardState.PubAccount,\n        YshhApplication.context.stringResource(R.string.main_title_account)\n    ),\n    BottomBean(\n        DashboardState.Mine,\n        YshhApplication.context.stringResource(R.string.main_title_mine)\n    )\n)\n```\n就这几个模块。\n\n底部bar的item就是 BottomNavigationitem里面的了，可以看到是一个icon+label构成。有个onClick的参数就是点击事件回调了，这里调用了 回调函数，传递给上层了，传出去的参数就一个int，表示第几页。\n\n回调到哪里呢？\n```Kotlin\n // 实际的底部bar 高度使用 固有特性测量 可以参考：https://juejin.cn/post/7068164264363556872\n            MainBottomBar(\n                Modifier\n                    .fillMaxWidth()\n                    .height(IntrinsicSize.Max),pagerState = pagerState) {\n                pagerState.reenableScrolling(coroutineScope, it)\n            }\n```\n这里通过调用rememberPagerState这个对象的`  pagerState.reenableScrolling(coroutineScope, it)`这个方法实现滚动到目标tab下。也就实现了页面切换。\n最为关键的就是这个pagerState，同步页面数据和底部bar。\n\n等下分析内容区也会用到。\n\n```Kotlin\n // 水平分页\n            HorizontalPager(\n                count = bottomList.size,\n                modifier.weight(1f), pagerState, userScrollEnabled = true\n            ) { page ->\n                when (page) {\n                    // 首页tab\n                    0 -> HomeView(\n                        Modifier\n                            .fillMaxSize()\n                            .background(HhfTheme.colors.background)\n                            .align(Alignment.CenterHorizontally)\n                    )\n                    // 项目tab\n                    1 -> ProjectView(\n                        Modifier\n                            .fillMaxSize()\n                            .align(Alignment.CenterHorizontally)\n                    )\n                    // 公众号tab\n                    2 -> AccountView(\n                        Modifier\n                            .fillMaxSize()\n                            .background(HhfTheme.colors.background)\n                            .align(Alignment.CenterHorizontally)\n                    )\n                    // 我的tab\n                    3 -> {\n//                        if (isLogin) {\n                            Mine(\n                                Modifier\n                                    .fillMaxSize()\n                                    .background(HhfTheme.colors.background)\n                                    .align(Alignment.CenterHorizontally)\n                            )\n//                        } else {\n//                            ErrorBox(\n//                                Modifier.fillMaxSize(),\n//                                title = stringResource(id = R.string.sign_in)\n//                            )\n//                            { CpNavigation.to(ModelPath.Login) }\n//                        }\n                    }\n                }\n            }\n```\n这里是中间内容区。通过使用水平分页得以实现。可以看到传入了一个参数，也就是上面底部bar用到的一个pagerState，定义了不同索引下，中间内容区展示的内容。\n\n* 首页Tab 对应 HomeView\n* 项目Tab 对应 ProjectView\n* 公众号Tab 对应 AccountView\n* 我的Tab 对应 Mine\n\n### 10.首页Tab-HomeView\n首页效果图就是上面的那个效果。\n这里再拆分下，就是轮播图+列表。\n对应 HomeView。\n\n```Kotlin\n@CompoKotlinsable\nfun HomeView(modifier: Modifier = Modifier) {\n    val viewModel: HomeViewModel = viewModel()\n    ColumnTopBarMain(modifier\n        .background(HhfTheme.colors.background),\n        stringResource(R.string.app_name)) {\n        // 内容区域，传入HomeViewModel对象\n        HomeContent(viewModel = viewModel)\n    }\n}\n```\n最外层是由顶部bar+内容区构成。\n\nColumnTabBarMain是自定义通用的一个App的组件，用于上面展示toolbar，中间区域自定义。\n```Kotlin\n@Composable\nfun ColumnTopBarMain(\n    modifier: Modifier = Modifier,\n    title: String,\n    content: @Composable ColumnScope.() -> Unit\n) {\n    Column(\n        modifier.navigationBarsPadding(),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        CpTopBar(\n            Modifier.fillMaxWidth(),\n            HhfTheme.colors.themeColor,\n            title = title,\n            actions = {\n                IconButton(onClick = {\n                    CpNavigation.to(ModelPath.Search)\n                }) {\n                    Icon(Icons.Filled.Search, contentDescription = \"search\", tint = Color.White)\n                }\n            },\n        )\n        content.invoke(this)\n    }\n}\n```\n这里具体是一个Column+CpTopBar构成\n\nCpTopBar是这样的：\n```Kotlin\n\n@Composable\nfun CpTopBar(\n    modifier: Modifier = Modifier,\n    backgroundColor: Color = Color.Transparent,\n    title: String,\n    actions: @Composable RowScope.() -> Unit = {},\n    back: (() -> Unit)? = null\n) {\n    HhTopAppBar(\n        {\n            Text(title, color = Color.White)\n        },\n        modifier = modifier,\n        backgroundColor = backgroundColor,\n        contentPadding = WindowInsets.statusBars.only(WindowInsetsSides.Horizontal + WindowInsetsSides.Top).asPaddingValues(),\n        navigationIcon = back?.run {\n            {\n                IconButton(\n                    onClick = {\n                        invoke()\n                    }\n                ) {\n                    Icon(Icons.Filled.ArrowBack, contentDescription = \"back\", tint = Color.White)\n                }\n            }\n        },\n        actions = actions,\n        elevation = 2.dp,\n    )\n}\n```\n\n里面还有自定义的HhTopAppBar\n```Kotlin\n\n@Composable\nfun HhTopAppBar(\n    title: @Composable () -> Unit,\n    modifier: Modifier = Modifier,\n    contentPadding: PaddingValues = PaddingValues(0.dp),\n    navigationIcon: @Composable (() -> Unit)? = null,\n    actions: @Composable RowScope.() -> Unit = {},\n    backgroundColor: Color = MaterialTheme.colors.primarySurface,\n    contentColor: Color = contentColorFor(backgroundColor),\n    elevation: Dp = AppBarDefaults.TopAppBarElevation,\n) {\n    TopAppBarSurface(\n        modifier = modifier,\n        backgroundColor = backgroundColor,\n        contentColor = contentColor,\n        elevation = elevation\n    ) {\n        TopAppBarContent(\n            title = title,\n            navigationIcon = navigationIcon,\n            actions = actions,\n            modifier = Modifier.padding(contentPadding)\n        )\n    }\n}\n```\n\n竟然还有自定义层：Surface是官方提供的了\n```Kotlin\n@Composable\nfun TopAppBarSurface(\n    modifier: Modifier = Modifier,\n    backgroundColor: Color = MaterialTheme.colors.primarySurface,\n    contentColor: Color = contentColorFor(backgroundColor),\n    elevation: Dp = AppBarDefaults.TopAppBarElevation,\n    content: @Composable () -> Unit,\n) {\n    Surface(\n        color = backgroundColor,\n        contentColor = contentColor,\n        elevation = elevation,\n        modifier = modifier,\n        content = content\n    )\n}\n```\n还有标题栏内容区： 这个TopAppBar是官方提供的了\n```Kotlin\n@Composable\nfun TopAppBarContent(\n    title: @Composable () -> Unit,\n    modifier: Modifier = Modifier,\n    navigationIcon: @Composable (() -> Unit)? = null,\n    actions: @Composable RowScope.() -> Unit = {},\n) {\n    TopAppBar(\n        title = title,\n        navigationIcon = navigationIcon,\n        actions = actions,\n        backgroundColor = Color.Transparent,\n        elevation = 0.dp,\n        modifier = modifier\n    )\n}\n```\n\n标题栏看完了，那就到内容区了。\n\n```Kotlin\n\n/**\n * 首页内容区\n */\n@Composable\nfun HomeContent(modifier: Modifier = Modifier, viewModel: HomeViewModel) {\n\n    /**\n     * list 为首页文章 列表数据；系统会对所有列表项进行组合和布局，无论它们是否可见，\n     * 因此如果您需要显示大量列表项（或长度未知的列表），则使用 Column 等布局可能会导致性能问题。\n     * Compose 提供了一组组件，这些组件只会对在组件视口中可见的列表项进行组合和布局。\n     */\n    val list = viewModel.viewStates.homeList.collectAsLazyPagingItems()\n\n    /**\n     * 下拉刷新组件\n     */\n    SwipeRefresh(\n        /**\n         * 状态，是否正在刷新\n         */\n        state = rememberSwipeRefreshState(viewModel.viewStates.isRefresh),\n        /**\n         * 下拉刷新回调，需要更新轮播+列表\n         */\n        onRefresh = {\n            viewModel.dispatch(HomeAction.GetBanner)\n            list.refresh()\n        }) {\n        // 内容区 使用LazyItem包裹\n        PagingItem(modifier, list = list,\n            errorBlock = {},\n            successBlock = {},\n            errorAndSuccessClick = {\n                /**\n                 * 错误后点击回调\n                 */\n                list.refresh()\n            }) {\n            /**\n             * 仅组成和放置 当前可见项 的竖直滚动列表。它允许您放置不同类型的子级内容。\n             * 例如，您可以使用LazyListScope.item添加单个项目，然后使用LazyListScope.items或者LazyListScope.itemsIndexed添加项目列表，后者有当前列表项的索引值。\n             */\n            LazyColumn{\n                /**\n                 * 单个item\n                 */\n                item {\n                    BannerPager(Modifier.height(160.dp), viewModel = viewModel)\n                }\n                /**\n                 * items集合\n                 */\n                items(it) { homeBean ->\n                    homeBean?.apply {\n                        /**\n                         * 首页文字item\n                         */\n                        HomeListItem(homeBean = this) {\n                            /**\n                             * 处理点击收藏图标 触发viewModel层调用接口\n                             */\n                            if(CacheUtils.isLogin){\n                                viewModel.dispatch(HomeAction.Collect(homeBean.id, it))\n                            }\n                            else{\n                                CpNavigation.to(ModelPath.Login)\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```\nlist 是专门用于懒加载列表，这个是存放可视区的列表。\n\n数据来源是ViewModel层的viewStates实例。\n\n```Kotlin\n/**\n * 首页状态，包装首页需要的数据\n */\ndata class HomeState(\n    /**\n     * 是否正在刷新\n     */\n    val isRefresh : Boolean = false,\n\n    /**\n     * 轮播列表，数据源\n     */\n    val bannerList: List<BannerResponse> = listOf(),\n\n    /**\n     * 首页数据\n     */\n    val homeList: Flow<PagingData<ArticleBean>> = Pager(\n        PagingConfig(PAGE_SIZE),\n        pagingSourceFactory = { HomeSource() }).flow,\n)\n```\n这个是存放到ViewModel层的首页动态数据。\n\n```Kotlin\n // 首页数据监听 通过 mutableStateOf包装 HomeState\n    var viewStates by mutableStateOf(\n        HomeState(\n            homeList = Pager(\n                PagingConfig(PAGE_SIZE),\n                pagingSourceFactory = { HomeSource() }).flow.cachedIn(viewModelScope)))\n        private set\n```\n这里用一个mutableStateof包装下。\n\n\n下面继续回到首页内容区：\n然后是一个SwipeRefresh组件,官方提供的。\n```Kotlin\n    SwipeRefresh(\n        /**\n         * 状态，是否正在刷新\n         */\n        state = rememberSwipeRefreshState(viewModel.viewStates.isRefresh),\n        /**\n         * 下拉刷新回调，需要更新轮播+列表\n         */\n        onRefresh = {\n            viewModel.dispatch(HomeAction.GetBanner)\n            list.refresh()\n        }) {\n```\n定义好下拉刷新触发事件。\n注意这个list，实际上走的是LazyPagingItems里面的一个refresh方法。\n我们在HomeState中定义的homeList是一个Flow包装列表集合。通过调用Flow中扩展的一个collectAsLazyPagingItems函数，就变成LazyPagingItems对象了。\n\n这个list我们放在PagingItem里面。\n\n然后首页内容区里面用了一个 LazyColumn，应该也是配合懒加载和复用官方实现的一个类。\n然后里面第一个item就是我们的轮播图了。\n\n```Kotlin\n/**\n * 顶部轮播图\n */\n@OptIn(ExperimentalPagerApi::class)\n@Composable\nfun BannerPager(modifier: Modifier = Modifier, viewModel: HomeViewModel) {\n    val pagerState = rememberPagerState()\n\n    /**\n     * 开启协程 内部的闭包是协程 目的是获取轮播图数据\n     */\n    LaunchedEffect(viewModel){\n        viewModel.dispatch(HomeAction.GetBanner)\n    }\n\n    /**\n     * 如需了解来自父项的约束条件并相应地设计布局，您可以使用 BoxWithConstraints。\n     * 就是外部传过来的modifier 决定子View 空间\n     */\n    BoxWithConstraints(modifier) {\n\n        /**\n         * 水平分页\n         */\n        HorizontalPager(\n            count = viewModel.viewStates.bannerList.size, // 轮播总数\n            state = pagerState // 轮播状态\n        ) { page ->\n            //  页面索引\n            when (page) {\n                viewModel.viewStates.bannerList[page].id -> {\n                    /**\n                     * 轮播图item\n                     */\n                    BannerItem(\n                        Modifier\n                            .height(maxHeight)\n                            .fillMaxWidth(), viewModel.viewStates.bannerList[page]\n                    )\n                }\n            }\n        }\n\n        /**\n         * 轮播指示器\n         */\n        if (viewModel.viewStates.bannerList.isNotEmpty()) {\n            BannerIndicator(\n                Modifier\n                    .align(Alignment.BottomCenter)\n                    .fillMaxWidth()\n                    .background(Color.Black.copy(0.2f))\n                    .padding(8.dp),viewModel, pagerState )\n        }\n\n\n    }\n}\n```\n这个轮播图里面开了个协程去获取轮播图数据，只会走一次。\n然后一个水平分页里面存放所有轮播图，轮播item为BannerItem,这个是自定义的\n```Kotlin\n@Composable\nfun BannerItem(modifier: Modifier = Modifier, data: BannerResponse) {\n    data.apply {\n        Box(modifier.clickable {\n            /**\n             * 点击图片，触发跳转WebView，通过bundle传递数据\n             */\n            CpNavigation.toBundle(ModelPath.WebView, Bundle().apply {\n                putString(webTitle, data.title)\n                putString(webUrl, data.url)\n                putBoolean(webIsCollect, false)\n                putInt(webCollectId, data.id)\n                putInt(webCollectType, 1)\n            })\n        }) {\n            /**\n             * 自定义网络图片\n             */\n            NetworkImage(\n                imagePath,\n                Modifier.fillMaxWidth(),\n                contentScale = ContentScale.FillBounds,\n                defaultImg = R.mipmap.ic_default_round\n            )\n        }\n    }\n}\n```\n\n轮播完了，就是文章item了。\n主要是为了实现这种效果\n![](./%E7%8E%A9Android-Compose%E7%89%88%E6%9C%AC-%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90/home_item.jpeg)\n\n```Kotlin\n /**\n   * items集合\n   */\nitems(it) { homeBean ->\n    homeBean?.apply {\n        /**\n        * 首页文字item\n        */\n        HomeListItem(homeBean = this) {\n            /**\n            * 处理点击收藏图标 触发viewModel层调用接口\n            */\n            if(CacheUtils.isLogin){\n                viewModel.dispatch(HomeAction.Collect(homeBean.id, it))\n            }\n            else{\n                CpNavigation.to(ModelPath.Login)\n            }\n        }\n    }\n}\n```\n这里用了items，然后遍历了 list,每个item对应一个 HomeListItem\n这里定义了一个函数，说明了点击收藏图标后的逻辑。\n\n```Kotlin\n  /**\n     * 是否收藏了，用remember包装一下bool值\n     */\n    var isCollect by remember{ mutableStateOf(homeBean.collect)}\n\n    /**\n     * 卡片布局\n     */\n    Card(\n        modifier\n            .padding(8.dp) // 内padding 8个dp\n            .clickable {\n                /**\n                 * 卡片点击事件，触发跳转webView\n                 */\n                CpNavigation.toBundle(ModelPath.WebView, Bundle().apply {\n                    putString(webTitle, homeBean.title)\n                    putString(webUrl, homeBean.link)\n                    putBoolean(webIsCollect, isCollect)\n                    putInt(webCollectId, homeBean.id)\n                    putInt(webCollectType, 0)\n                })\n            },\n        backgroundColor = HhfTheme.colors.listItem,\n        elevation = 5.dp\n    ) {\n```\n这里外层是用了Card,定义了点击item的逻辑。\n\n里面是这样的：\n```Kotlin\n Column(Modifier.padding(8.dp)) {\n                /**\n                 * 第一行 水平布局\n                 */\n                Row(verticalAlignment = Alignment.CenterVertically) {\n                    /**\n                     * 分享者没名字\n                     */\n                    Text(\n                        text = if (author.isNotEmpty()) author else shareUser,\n                        fontSize = 13.sp,\n                        color = HhfTheme.colors.textColor\n                    )\n                    /**\n                     * 显示标签\n                     */\n                    if(isShowLabel){\n                        if (type == 1) {\n                            Box(\n                                Modifier\n                                    .padding(start = 6.dp)\n                                    .border(1.dp, Color.Red, RoundedCornerShape(5.dp))\n                                    .padding(4.dp)\n                            ) {\n                                Text(stringResource(id = R.string.istop), Modifier, Color.Red, 10.sp)\n                            }\n                        }\n                        if (fresh) {\n                            Box(\n                                Modifier\n                                    .padding(start = 6.dp)\n                                    .border(1.dp, Color.Red, RoundedCornerShape(5.dp))\n                                    .padding(4.dp)\n                            ) {\n                                Text(stringResource(id = R.string.neww), Modifier, Color.Red, 10.sp)\n                            }\n                        }\n                        if (tags.isNotEmpty()) {\n                            Box(\n                                Modifier\n                                    .padding(start = 6.dp)\n                                    .border(1.dp, Color(0xFF66BB6A), RoundedCornerShape(5.dp))\n                                    .padding(4.dp)\n                            ) {\n                                Text(tags[0].name, Modifier, Color(0xFF66BB6A), 10.sp)\n                            }\n                        }\n                    }\n                    /**\n                     * 发布日期\n                     */\n                    Text(\n                        niceDate,\n                        Modifier\n                            .weight(1f)\n                            .wrapContentWidth(\n                                Alignment.End\n                            )\n                            .align(Alignment.CenterVertically),\n                        HhfTheme.colors.textColor.copy(0.6f),\n                        fontSize = 13.sp,\n                    )\n                }\n                /**\n                 * 有没有封面图\n                 */\n                if (TextUtils.isEmpty(envelopePic)) {\n                    // 没有封面图\n                    Text(\n                        title.filterHtml(),\n                        Modifier.padding(top = 12.dp),\n                        HhfTheme.colors.textColor,\n                        fontSize = 14.sp,\n                        fontWeight = FontWeight.Bold\n                    )\n                } else {\n                    // 有封面图时，中间区域展示\n                    Row(Modifier.padding(top = 12.dp)) {\n                        // 网络图片\n                        NetworkImage(\n                            envelopePic,\n                            Modifier.size(100.dp),\n                            contentScale = ContentScale.Crop,\n                            defaultImg = R.mipmap.ic_default_round\n                        )\n                        // 垂直布局\n                        Column(Modifier.padding(start = 8.dp)) {\n                            // 标题\n                            Text(\n                                title.filterHtml(),\n                                color = HhfTheme.colors.textColor,\n                                fontSize = 14.sp,\n                                maxLines = 3,\n                                style = TextStyle(fontWeight = FontWeight.Bold)\n                            )\n                            // 摘要描述\n                            Text(\n                                desc,\n                                color = HhfTheme.colors.textInactiveColor,\n                                fontSize = 13.sp,\n                                maxLines = 3,\n                                overflow = TextOverflow.Ellipsis\n                            )\n                        }\n                    }\n                }\n                // 底部水平布局\n                Row {\n                    // 文本\n                    Text(\n                        \"$superChapterName / $chapterName\",\n                        Modifier.padding(top = 12.dp),\n                        HhfTheme.colors.textColor,\n                        fontSize = 13.sp\n                    )\n                    // 图标，是否收藏了\n                    Icon(\n                        if(isCollect) Icons.Filled.Favorite else Icons.Filled.FavoriteBorder, contentDescription = \"\",\n                        Modifier\n                            .wrapContentWidth(\n                                Alignment.End\n                            )\n                            .weight(1f)\n                            .clickable {\n                                /**\n                                 * 点击收藏，触发请求\n                                 */\n                                favoriteAction(isCollect)\n                                isCollect = !isCollect\n                            },\n                        tint = HhfTheme.colors.themeColor\n                    )\n                }\n            }\n```\n\n### 11.我的Tab-Mine\n因为项目和公众号和首页基本一样，这里就不重复分析了。\n看下我的页面的效果图：\n<img src=mine.jpeg width=50%>\n要实现这样的效果，怎么处理呢？\n\n首先开启一个协程，获取用户sp数据，转成UserInfo对象\n```Kotlin\n   /**\n     * 开启协程，只走一次\n     */\n    LaunchedEffect(CacheUtils.userInfo) {\n        if (CacheUtils.userInfo != \"\") {\n            /**\n             * 根据sp文件，生产一个UserInfo对象，设置给这个我的页面使用\n             */\n            mineViewModel.dispatch(\n                MineViewEvent.SetUserInfo(\n                    Gson().fromJson(\n                        CacheUtils.userInfo, // sp文件\n                        UserInfo::class.java\n                    )\n                )\n            )\n            /**\n             * 获取积分和排名\n             */\n            mineViewModel.dispatch(MineViewEvent.GetIntegral)\n        }\n    }\n```\n这里获取积分和排名是需要走接口的\n这里会走到ViewModel层这个函数：\n```Kotlin\n    private fun getIntegral() {\n        viewModelScope.launch {\n            flow {\n                emit(\n                    TaskApi.create(ApiService::class.java).getIntegral()\n                )\n            }.map {\n                if (it.errorCode == 0) {\n                    it.data\n                        ?: throw Exception(\"data null\")\n                } else {\n                    throw Exception(it.errorMsg)\n                }\n            }.onEach {\n                viewStates = viewStates.copy(integral = it)\n            }.catch {\n                viewStates = viewStates.copy(integral = null)\n            }.collect()\n        }\n    }\n```\n这个retrofit中是这样定义的：\n```Kotlin\ninterface ApiService {\n    /**\n     * 获取当前账户的个人积分\n     */\n    @GET(\"lg/coin/userinfo/json\")\n    suspend fun getIntegral(): ApiResponse<Integral>\n```\n这个就是一个suspend挂起函数。\n\n顶层为Column:\n```Kotlin\n    /**\n     * 顶层为列表视图\n     */\n    Column(modifier) {\n        /**\n         * 顶部👤\n         */\n        MineTopAvatar(\n            Modifier\n                .fillMaxWidth()\n                .height(320.dp)\n                .clip(QureytoImageShapes(160f)),\n            mineViewModel.viewStates.userInfo?.run {\n                nickname\n            } ?: \"avatar\"\n        ) {\n```\n\n头像区域，点击后可以弹pop，但是需要先获取权限，这样获取：\n```Kotlin\n// 图片点击事件 会去申请下权限\n            XXPermissions\n                .with(context)\n                .permission(Permission.CAMERA)\n                .permission(Permission.MANAGE_EXTERNAL_STORAGE)\n                .request(object : OnPermissionCallback {\n                    override fun onGranted(\n                        granted: List<String>,\n                        all: Boolean\n                    ) {\n                        if (all) {\n                            if(isLogin){\n                                mineViewModel.dispatch(MineViewEvent.ChangePopupState(true))\n                            }\n                            else{\n                                CpNavigation.to(ModelPath.Login)\n                            }\n                        }\n                    }\n\n                    override fun onDenied(\n                        denied: List<String>,\n                        never: Boolean\n                    ) {\n                        if (never) {\n                            context.showToast(context.stringResource(R.string.permissions_cm_error))\n                            XXPermissions.startPermissionActivity(\n                                context,\n                                denied\n                            )\n                        } else {\n                            context.showToast(context.stringResource(R.string.permissions_camera_error))\n                        }\n                    }\n                })\n```\n用了一个三方库实现。\n\n中间操作栏这样实现：\n```Kotlin\n  // 操作栏 有个外边框，包裹菜单项，底部有阴影\n        Surface(\n            Modifier\n                .padding(start = 20.dp, end = 20.dp)\n                .fillMaxWidth()\n                .background(HhfTheme.colors.background),\n            elevation = 2.dp,\n            shape = RoundedCornerShape(8.dp),\n            color = MaterialTheme.colors.surface, // color will be adjusted for elevation\n        ) {\n```\n\n具体的菜单项也是用懒加载实现：\n```Kotlin\nLazyColumn(Modifier.background(HhfTheme.colors.listItem)) {\n                itemsIndexed(list) { i, bean ->\n\n                    /**\n                     * 我的页面遍历菜单项\n                     */\n                    MineItem(\n                        Modifier\n                            .fillMaxWidth()\n                            .clickable {\n                                /**\n                                 * 分发开发者行为\n                                 */\n                                mineViewModel.dispatch(MineViewEvent.ToComposable(bean.id))\n                            }\n                            .height(45.dp), bean.name, HhfTheme.colors.themeColor,\n                        bean.icon)\n                    if (i < list.size - 1) {\n                        /**\n                         * 非最后一行显示分割线\n                         */\n                        Divider(\n                            modifier = Modifier\n                                .fillMaxWidth()\n                                .padding(start = 10.dp, end = 10.dp)\n                        )\n                    }\n                }\n            }\n```\n\n具体的菜单item,有图标+文字+右侧箭头实现：\n```Kotlin\n\n@Composable\nfun MineItem(\n    modifier: Modifier = Modifier, textName: String, iconColor: Color, icon: ImageVector\n) {\n    Row(\n        modifier,\n        verticalAlignment = Alignment.CenterVertically,\n    ) {\n        Icon(\n            icon, \"$textName icon\",\n            Modifier\n                .size(28.dp)\n                .padding(start = 10.dp), iconColor\n        )\n        Text(\n            textName,\n            Modifier.padding(start = 10.dp),\n            fontSize = 14.sp,\n            fontFamily = FontFamily.Serif,\n            color = HhfTheme.colors.textColor\n        )\n        Icon(\n            Icons.Filled.KeyboardArrowRight, textName,\n            Modifier\n                .weight(1f)\n                .padding(end = 10.dp)\n                .wrapContentWidth(Alignment.End),\n            tint = HhfTheme.colors.textColor\n        )\n    }\n}\n```\n\nUI搞定了，跳转逻辑怎么处理呢？\n答案是viewModel层实现。\n\n这里有个clickable点击闭包：\n` mineViewModel.dispatch(MineViewEvent.ToComposable(bean.id))`\n\n\n会委托给mineViewModel处理：\n```Kotlin\n    /**\n     * 分发开发者行为\n     */\n    fun dispatch(action: MineViewEvent) {\n        when (action) {\n            is MineViewEvent.Blur -> bitmapBlur(action.s)\n            /**\n             * 用户点击菜单项\n             */\n            is MineViewEvent.ToComposable -> toComposable(action.type)\n            is MineViewEvent.ChangePopupState -> {\n                Log.e(\"TEST##\", \"这里触发了viewStates中 isShowpopup 变更为：${action.flag}\")\n                viewStates = viewStates.copy(isShowPopup = action.flag)\n            }\n            is MineViewEvent.SetUserInfo -> viewStates = viewStates.copy(userInfo = action.userInfo)\n            is MineViewEvent.GetIntegral -> getIntegral()\n        }\n    }\n```\n这里分发开发者行为，其实更像用户行为，有可能不是用户触发，所以我这里称之为开发者行为。\n\n点击菜单项继续分发：\n```Kotlin\nprivate fun toComposable(type: Int) {\n        if(isLogin){\n            when (type) {\n                0 -> CpNavigation.to(ModelPath.Integral)\n                1 -> CpNavigation.to(ModelPath.Collect)\n                2 -> CpNavigation.to(ModelPath.Share)\n                3 -> CpNavigation.to(ModelPath.Todo)\n                4 -> CpNavigation.toBundle(ModelPath.WebView, Bundle().apply {\n                    putString(webTitle, \"PlayAndroid\")\n                    putString(webUrl, \"https://github.com/yellowhai/PlayAndroid\")\n                    putBoolean(webIsCollect, false)\n                    putInt(webCollectId, 998)\n                    putInt(webCollectType, 1)\n                })\n                5 -> CpNavigation.to(ModelPath.Setting)\n            }\n        }\n        else{\n            when (type) {\n                4 -> CpNavigation.toBundle(ModelPath.WebView, Bundle().apply {\n                    putString(webTitle, \"PlayAndroid\")\n                    putString(webUrl, \"https://github.com/yellowhai/PlayAndroid\")\n                    putBoolean(webIsCollect, false)\n                    putInt(webCollectId, 998)\n                    putInt(webCollectType, 1)\n                })\n                5 -> CpNavigation.to(ModelPath.Setting)\n                else -> CpNavigation.to(ModelPath.Login)\n            }\n        }\n    }\n```\n这里定义了跳转逻辑，这里有回到 第8点主页外部架构 中的导航定义了。\n实现跳转到其它页面了，这更像是在布局上叠加，不算是跳转吧。\n\n这个项目还有很多细节值得一探究竟，不过对于初始compose，也差不多了，了解到这个程度也算入门了吧。\n\n\n","source":"_posts/玩Android-Compose版本-项目分析.md","raw":"---\ntitle: 玩Android Compose版本 项目分析\ndate: 2023-01-17 11:23:20\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- Android\ncategories:\n- Android\n---\n\n> 玩Android(compose版本)项目地址：[https://github.com/yellowhai/PlayAndroid](https://github.com/yellowhai/PlayAndroid)\n\n### 1.项目settings.gradle\n\n```groovy\ndependencyResolutionManagement {\n    /**\n     * 原文中说默认情况下，项目中的存储库会覆盖设置中的存储库 ，可以通过设置模式来更改这种行为\n     设置存储库的方法：\n     repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n     存储库模式：\n     PREFER_PROJECT(true)--首选项目存储库\n     PREFER_SETTINGS(false)--首选设置存储库\n     FAIL_ON_PROJECT_REPOS(false)--强制设置存储库\n     */\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories {\n        google()\n        mavenCentral()\n        maven { url \"https://jitpack.io\" }\n        maven {\n            url 'https://maven.aliyun.com/repository/public/'\n        }\n        maven { url 'https://maven.aliyun.com/repository/public' }\n        maven { url 'https://maven.aliyun.com/repository/central' }\n        maven { url 'https://maven.aliyun.com/repository/google' }\n        maven { url 'https://maven.aliyun.com/repository/public' }\n        maven { url 'https://maven.aliyun.com/repository/gradle-plugin' }\n    }\n}\nrootProject.name = \"PlayAndroid\"\ninclude ':app'\ninclude ':common'\ninclude ':h_mine'\ninclude ':toolkit'\n```\n\n还是很容易理解的，repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)这个是新增的，简单看下就行。\n引入了app模块(主模块)，common模块（通用模块，用于通用组件相关）,h_mine模块（我的模块，可以单独编译）。\n\n### 2.config.gradle\n这个文件相信大家都有用过的，配置远程依赖的一个文件，统一管理。\n```groovy\next{\n    isRelease = true\n\n    //android构建配置\n    android_models = [\n            compileSdk : 32,\n            minSdk : 23,\n            targetSdk : 32,\n            versionCode : 1,\n            versionName : \"1.0\"\n    ]\n    \n    app_id = [\n            mine      : 'com.hh.mine',\n    ]\n\n    core_ktx_version = '1.7.0'\n    appcompat_version = '1.4.0'\n    lifecycle_version = '2.4.0'\n    material_version = '1.4.0'\n    work_version = '2.7.1'\n    gson_version = '2.8.9'\n    litepal_version = '3.2.3'\n    landscapist_version = '1.4.5'\n    retrofit_version = '2.9.0'\n    okhttp_version = '4.9.3'\n    startup_version = '1.1.0'\n    XXPermissions_version = '13.2'\n    datastore_version = '1.0.0'\n    materialDialog_version = '0.6.2'\n    accompanist_version = '0.25.0'\n\n\n    jetpack_compose = [\n            material : \"androidx.compose.material:material:$compose_version\",\n            activity : \"androidx.activity:activity-compose:$appcompat_version\",\n    ]\n\n    commonApi = [\n            ktx_core        : \"androidx.core:core-ktx:$core_ktx_version\",\n            lifecycle       : \"androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version\",\n            appcompat       : \"androidx.appcompat:appcompat:$appcompat_version\",\n            material        : \"com.google.android.material:material:$material_version\",\n            //数据存储\n            datastore       : \"androidx.datastore:datastore-preferences:$datastore_version\",\n            //权限处理\n            XXPermissions   : \"com.github.getActivity:XXPermissions:$XXPermissions_version\",\n    ]\n\n    net = [\n            retrofit    : \"com.squareup.retrofit2:retrofit:$retrofit_version\",\n            converter   : \"com.squareup.retrofit2:converter-gson:$retrofit_version\",\n            okhttp      : \"com.squareup.okhttp3:logging-interceptor:$okhttp_version\",\n            gson        : \"com.google.code.gson:gson:$gson_version\"\n    ]\n\n    accompanist_ui = [\n            insets_ui    : \"com.google.accompanist:accompanist-insets-ui:$accompanist_version\",\n            navigation   : \"com.google.accompanist:accompanist-navigation-animation:$accompanist_version\",\n            pager        : \"com.google.accompanist:accompanist-pager:$accompanist_version\",\n            swiperefresh : \"com.google.accompanist:accompanist-swiperefresh:$accompanist_version\",\n            flowlayout   : \"com.google.accompanist:accompanist-flowlayout:$accompanist_version\",\n            systemUi     : \"com.google.accompanist:accompanist-systemuicontroller:$accompanist_version\",\n            webview      : \"com.google.accompanist:accompanist-webview:$accompanist_version\"\n    ]\n\n    database =[\n            litepal :  \"org.litepal.guolindev:core:$litepal_version\"\n    ]\n\n    skydoves_coil = [\n            landscapist_coil :  \"com.github.skydoves:landscapist-coil:$landscapist_version\"\n    ]\n\n    workManager = [\n            // Kotlin + coroutines\n            work = \"androidx.work:work-runtime-ktx:$work_version\"\n    ]\n\n    material_dialog = [\n            color : \"io.github.vanpra.compose-material-dialogs:color:$materialDialog_version\",\n            core  : \"io.github.vanpra.compose-material-dialogs:core:$materialDialog_version\",\n            datetime  : \"io.github.vanpra.compose-material-dialogs:datetime:$materialDialog_version\"\n    ]\n\n    paging = \"androidx.paging:paging-compose:1.0.0-alpha14\"\n\n    jetpackComposeLibs = jetpack_compose.values()\n    commonApiLibs = commonApi.values()\n    netLibs = net.values()\n    materialDialogLibs = material_dialog.values()\n}\n```\n层次还是比较清晰，对于同一组单独建立数组存储，模块中只需要引入一个就将这组全部引入进去了。\n\n### 3.app模块下的build.gradle\n\n显示引入com.android.application+kotlin-android的插件。\n下面配置android闭包，很简单。\n\n其它关于compose的也需要配置下：\n```groovy\n compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n    buildFeatures {\n        compose true\n    }\n    composeOptions {\n        kotlinCompilerExtensionVersion compose_version\n        kotlinCompilerVersion kotlin_version\n    }\n```\n\n然后是远程依赖：\n```groovy\ndependencies {\n    // 如果是release模式，就把我的模块加进来\n    if(isRelease){\n        implementation project(':h_mine')\n    }\n\n    // 初始化组件\n    implementation \"androidx.startup:startup-runtime:$startup_version\"\n    implementation project(':common')\n\n    // 测试相关\n    testImplementation 'junit:junit:4.13.2'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.3'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'\n    androidTestImplementation \"androidx.compose.ui:ui-test-junit4:$compose_version\"\n    androidTestImplementation \"androidx.compose.ui:ui-test-junit4:$compose_version\"\n    debugImplementation \"androidx.compose.ui:ui-tooling:$compose_version\"\n\n}\n```\n\nisRelease定义在 config.gradle的顶部。如果是集成编译就为true，单独编译为false。\n\n### 4.app模块的AndroidManifest.xml\n* 配置Application\n* 配置主页\n* 配置provider，用于初始化sdk\n    ```xml\n      <!--  用provider初始化sdk-->\n        <provider\n            android:name=\"androidx.startup.InitializationProvider\"\n            android:authorities=\"${applicationId}.androidx-startup\"\n            android:exported=\"false\"\n            tools:node=\"merge\">\n            <meta-data\n                android:name=\"com.hh.playandroid.base.BaseInitializer\"\n                android:value=\"androidx.startup\" />\n        </provider>\n    ```\n\n### 5.自定义Application\n ```\n class HhfApp : YshhApplication()\n ```   \n 依赖common模块：\n ```Kotlin\n open class YshhApplication : Application() {\n\n    lateinit var okbuilder: OkHttpClient\n\n    companion object {\n        /**\n         * application context.\n         */\n        @SuppressLint(\"StaticFieldLeak\")\n        lateinit var context: Context\n\n        @SuppressLint(\"StaticFieldLeak\")\n        lateinit var instance: YshhApplication\n\n        /**\n         * application级别的协程\n         * 有时我们需要在协程上下文中定义多个元素，组合协程上下文中的元素，使用 + 操作符来创建 CoroutineScope .\n         */\n        val applicationScope = CoroutineScope(SupervisorJob() + Dispatchers.Main)\n    }\n ```\n 这里懒加载OkHttpClient\n 定义了全局的协程，静态变量。\n\n ```Kotlin\n   override fun onCreate() {\n        super.onCreate()\n        context = applicationContext\n        instance = this\n        initRetrofit()\n    }\n ```\n 初始化Retrofit：\n ```Kotlin\n  /**\n     * 初始化Retrofit\n     */\n    private fun initRetrofit(token : String = \"\"): OkHttpClient {\n        //请求头\n        val headerInterceptor = Interceptor { chain: Interceptor.Chain ->\n            val orignaRequest = chain.request()\n            val request = orignaRequest.newBuilder()\n                .header(\"Authorization\", \"Bearer $token\")\n                .method(orignaRequest.method, orignaRequest.body)\n                .build()\n            chain.proceed(request)\n        }\n        val logInterceptor = LogInterceptor {\n//            it.logE()\n        }\n        // 日志类别\n        logInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);\n        // 缓存相关\n        val cacheFile =\n            File(getExternalFilesDir(Environment.DIRECTORY_PICTURES).toString() + \"http_cache\")\n        val cache = Cache(cacheFile, 104857600L) // 指定缓存大小100Mb\n        val builder = OkHttpClient.Builder()\n        //        builder.addInterceptor(addQueryParameterInterceptor);\n        builder.addInterceptor(headerInterceptor)\n        builder.cache(cache)\n        builder.addNetworkInterceptor(logInterceptor)\n        builder.cookieJar(cookieJar)\n        builder.readTimeout(60000, TimeUnit.MILLISECONDS)\n        //全局的写入超时时间60s\n        builder.writeTimeout(60000, TimeUnit.MILLISECONDS)\n        //全局的连接超时时间30s\n        builder.connectTimeout(30000, TimeUnit.MILLISECONDS)\n        okbuilder = builder.build()\n        return builder.build()\n    }\n\n    private val cookieJar: PersistentCookieJar by lazy {\n        PersistentCookieJar(SetCookieCache(), SharedPrefsCookiePersistor(context))\n    }\n    \n    fun getOkBuilder(): OkHttpClient {\n        return okbuilder\n    }\n ```\n\n ### 6.首页 MainActivity\n 继承BaseActivity:\n ```Kotlin\n\n/**\n * 基类Activity 设置非沉浸式，因为要设置导航栏和状态栏颜色\n */\nabstract class BaseActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        WindowCompat.setDecorFitsSystemWindows(window, false)\n    }\n\n}\n ```\n\nonCreate生命周期：\n```Kotlin\n @Suppress(\"DEPRECATED_IDENTITY_EQUALS\")\n    @OptIn(ExperimentalAnimationApi::class)\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        // 动画渐变\n        overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out)\n        // 设置内容\n        setContent {\n            Log.e(\"TEST##\", \"开始setContent了\")\n            // 顶层为自定义主题\n            HhfTheme(\n                // 是否暗色或亮色，跟随系统，如果用户主动设置，跟随用户\n                theme = if (isSystemInDarkTheme() || isNight) HhfTheme.Theme.Dark else HhfTheme.Theme.Light,\n                // 用户自行设置的颜色主题\n                colorTheme = appTheme\n            ) {\n                // 创建一个MainViewModel\n                val viewModel : MainViewModel = viewModel()\n\n                // 如果isSplash为true,就展示SplashView 启动页\n                if (viewModel.isSplash) {\n                    Log.e(\"TEST##\", \"加载闪屏了\")\n                    SplashView { viewModel.isSplash = false }\n                } else {\n                    Log.e(\"TEST##\", \"加载首页了\")\n                    // 全局静态变量存 底部控制器\n                    CpNavigation.navHostController = rememberAnimatedNavController()\n                    // 主页面\n                    HhfNavigation()\n                    // 进度条\n                    DialogProgress()\n                }\n                // 是否纪念日，将App置灰\n                if(isMourningDay()){\n                    Canvas(modifier = Modifier.fillMaxSize()){\n                        drawRect(color = Color.White,blendMode = BlendMode.Saturation)\n                    }\n                }\n            }\n        }\n        addCallback()\n    }\n```\n因为这个app就一个Activity，setContent中的内容就是展现给用户可以看到的所有东西了。\n顶层是一个自定义主题：\n```Kotlin\n@Composable\nfun HhfTheme(\n    theme: HhfTheme.Theme = HhfTheme.Theme.Light,\n    colorTheme: Color? = null,\n    content: @Composable () -> Unit\n) {\n    val targetColors = if (theme == HhfTheme.Theme.Dark) {\n        colorTheme?.let {\n            rememberSystemUiController().setNavigationBarColor(colorTheme)\n            DarkColorPalette.apply {\n                themeColor = it\n            }\n        }?:DarkColorPalette\n    } else {\n        colorTheme?.let {\n            rememberSystemUiController().setNavigationBarColor(colorTheme)\n            LightColorPalette.apply {\n                themeColor = it\n            }\n        }?:LightColorPalette\n    }\n    val themeColor = animateColorAsState(targetColors.themeColor, TweenSpec(600))\n    val textColor = animateColorAsState(targetColors.textColor, TweenSpec(600))\n    val background = animateColorAsState(targetColors.background,TweenSpec(600))\n    val listItem =  animateColorAsState(targetColors.listItem,TweenSpec(600))\n    val bottomBar =  animateColorAsState(targetColors.bottomBar,TweenSpec(600))\n    val divider =  animateColorAsState(targetColors.divider,TweenSpec(600))\n    val textFieldBackground =  animateColorAsState(targetColors.textFieldBackground,TweenSpec(600))\n    val colors = HhfColors(themeColor.value,\n        textColor.value,\n        background = background.value,\n        listItem = listItem.value,\n        bottomBar = bottomBar.value,\n        divider = divider.value,\n        textFieldBackground = textFieldBackground.value,\n        )\n    CompositionLocalProvider(LocalHhfColors provides colors) {\n        MaterialTheme(\n            shapes = Shapes,\n            typography = typography\n        ) {\n            content.invoke()\n        }\n    }\n}\n```\n这里用到了一个 CompositionLocalProvider，具体用法可以参考 [https://juejin.cn/post/7097890697721675813](https://juejin.cn/post/7097890697721675813)\n\n在Compose函数里，如果要用到函数外提供的值，一般都要通过函数定义好参数，外部调用时传入进去。\n这种方法表面看没啥问题，但在一些场景下就不是很方便。比如一个函数A嵌套一个函数B，函数B嵌套函数C，并且这A、B、C的函数都用到这个参数，那对三个函数来说都需要定义这个参数，就不是那么方便。\n那用个全局变量不就可以解决需要重复定义参数，确实可以。但全局变量有个副作用就是影响的范围比较大。本身我们定义的参数只会影响到函数内部。这个时候我们就可以使用CompositionLocal：它具有穿透函数功能的局部变量\nCompositionLocal适用场景：用来提供上下文数据，不扩大影响范围。\n\n然后最终主题呈现是用了 MaterialTheme这个类展现。\n\n回到首页，内容区：\n* 闪屏页展示逻辑\n    通过一个变量：`  var isSplash by mutableStateOf(true)` 实现控制是否显示\n*  加载首页\n    先 展示主页面，覆盖一层 进度条\n* 是否纪念日\n    app置灰处理    \n* 添加二次点击返回退出app逻辑\n\n首页逻辑基本就这么多了。\n\n### 7.闪屏ui -> SplashView\n看下效果先：\n<img src=%E9%97%AA%E5%B1%8F%E9%A1%B5.gif width = 50%>\n\n可以看到进入app后有个启动页面，中间是logo。\n那这个页面有个渐变动画，淡入淡出效果。\n\n具体ui是这样的：\n```Kotlin\n@Composable\nfun SplashView(startMain: () -> Unit) {\n    /**\n     * 辅助文字颜色变化 建立的一个mutableState包装的变量，实际上就是bool值\n     */\n    var enabled by remember { mutableStateOf(false) }\n\n    /**\n     * 背景颜色，从0.3alpha主题色变为纯主题色，2s的时间\n     */\n    val bgColor: Color by animateColorAsState(\n        if (enabled) HhfTheme.colors.themeColor\n        else HhfTheme.colors.themeColor.copy(alpha = 0.3f),\n        animationSpec = tween(durationMillis = 2000)\n    )\n\n    /**\n     * 中间文字颜色动画，如果enable为false，0.3alpha的颜色 到纯白色 2s的时间\n     */\n    val textColor: Color by animateColorAsState(\n        if (enabled) Color.White\n        else Color.White.copy(alpha = 0.3f),\n        animationSpec = tween(durationMillis = 2000)\n    )\n\n    // 外层一个Box+中间一个Text\n    Box(\n        Modifier\n            .fillMaxSize()\n            .background(bgColor),\n        contentAlignment = Alignment.Center\n    ) {\n        Text(text = \"PlayAndroid\", color = textColor,style = MaterialTheme.typography.h5)\n    }\n\n    // 开启协程 可以看出Compose里面开启协程的方法\n    LaunchedEffect(Unit) {\n        enabled = true\n        delay(2000)\n        // 2s后，设置 mutableStateOf 包装的bool变量 为false 会通知首页重新走setContent方法\n        startMain.invoke()\n    }\n}\n```\n\n这里需要理解 animateColorAsState 是官方提供的一个动画，支持颜色变化的一个composable方法。\n\n然后这里开启了2s延迟，怎么开延迟的，调用LaunchedEffect方法里面的delay，可以实现延迟效果。然后执行startMain回调。\n\n这个回调很简单：viewModel.isSplash = false\n\n虽然很简单，但实际上走了很多流程的。\n\n```Kotlin\nclass MainViewModel : ViewModel() {\n    var isSplash by mutableStateOf(true)\n}\n```\n这里使用mutableStateOf包装了一个布尔值。 上面触发这改变时，会刷新composable注解声明的方法体。这里应该就是刷新MainActivity整个内容区了。\n\n\n### 8.主页面外部架构\n```Kotlin\n@ExperimentalAnimationApi\n@OptIn(ExperimentalPagerApi::class)\n@Composable\nfun HhfNavigation() {\n    AnimatedNavHost(navController = CpNavigation.navHostController,\n        /**\n         * 首页默认页面\n         */\n        startDestination = ModelPath.Main.route,\n        enterTransition = { fadeIn(animationSpec = tween(700), initialAlpha = 0f) },\n        exitTransition = { fadeOut(animationSpec = tween(700), targetAlpha = 0f) }) {\n\n        /**\n         * 定义接收到 main 路由消息后->展示MainContent视图\n         */\n        composable(ModelPath.Main.route) {\n            MainContent()\n        }\n\n        /**\n         * 接收到 setting 路由消息后 -> 设置页面\n         */\n        composable(ModelPath.Setting.route) {\n            CpSetting(Modifier.fillMaxSize())\n        }\n        ...\n```\n\n这里使用了一个AnimatedNavHost，这个类是官方提供的。\n这个类里面定义了所有我们需要跳转的页面和初始页。\n然后这个 需要传一个参数，也就是控制器：\n` CpNavigation.navHostController = rememberAnimatedNavController()`\n这里也是官方提供的remember包装的一个控制器。\n\n这里的初始页为：`  startDestination = ModelPath.Main.route,`\n本质上就是一个string，首页的路由。\n\n这样会默认展示首页，怎么展示首页呢？\n```Kotlin\ncomposable(ModelPath.Main.route) {\n            MainContent()\n        }\n```\n那么这个MainContent就是我们的首页。\n\n其它composable里面都是首页可能去哪些页面的路由定义。\n\n那这个比如跳转到设置页面，怎么处理呢？\n* 首先在这个AnimatedNavHost里面定义一个composable闭包\n```Kotlin\n composable(ModelPath.Setting.route) {\n            CpSetting(Modifier.fillMaxSize())\n        }\n```\n\n* 然后再需要跳转的地方调用\n`navHostController.navigate(“setting”)`\n这个navHostController就是我们之前定义的那个控制器，setting就是路由名称。\n这样子就可以跳转到设置页面了。\n\n### 9.主页内部架构框\n首先看下主页效果图\n<img src=%E9%A6%96%E9%A1%B5.jpeg width=50%>\n轮播图+中间列表+底部bar\n轮播图+中间列表可以看成一个整体，那就是内容区+底部bar\n\n架构怎么搭建呢？\n```Kotlin\n   Scaffold(bottomBar = {\n        AnimatedVisibility(\n            visible = bottomSwitch,\n            enter = expandVertically() + fadeIn(), // 操作符重载了，第一个为空，就用第二个\n            exit = shrinkVertically() + fadeOut()  // 操作符重载了，第一个为空，就用第二个\n        ) {\n            // 实际的底部bar 高度使用 固有特性测量 可以参考：https://juejin.cn/post/7068164264363556872\n            MainBottomBar(\n                Modifier\n                    .fillMaxWidth()\n                    .height(IntrinsicSize.Max),pagerState = pagerState) {\n                pagerState.reenableScrolling(coroutineScope, it)\n            }\n        }\n    }) {\n        内容区...\n```\n最外层一个Scafffold脚手架包裹，有点像Flutter了啊。\n然后是一个AnimatedVisibility，这个控制显示隐藏的动画组件。重点看里面的MainBottomBar，就找到了我们的底部bar了。\n\n这个看起来像自定义的，具体怎么实现的呢？\n```Kotlin\n/**\n * App底部bar\n */\n@OptIn(ExperimentalPagerApi::class)\n@Composable\nprivate fun MainBottomBar(\n    modifier: Modifier = Modifier,\n    pagerState: PagerState,\n    currentChanged: (Int) -> Unit\n) {\n    /**\n     * 这个BottomAppBar是官方的\n     */\n    BottomAppBar(\n        modifier.navigationBarsPadding(),\n        cutoutShape = CircleShape,\n        backgroundColor = HhfTheme.colors.bottomBar,\n        elevation = 5.dp\n    ) {\n        // 遍历4个tab\n        bottomList.forEachIndexed { index, item ->\n            // item单独设置 官方组件\n            BottomNavigationItem(\n                selected = pagerState.currentPage == index, onClick = {\n                    /**\n                     * item点击事件回调给上层\n                     */\n                    currentChanged(index)\n                }, icon = {\n                    /**\n                     * icon为官方组件\n                     */\n                    Icon(\n                        item.dashboardState.icon,\n                        contentDescription = item.name,\n                        tint = if (pagerState.currentPage == index) {\n                            HhfTheme.colors.themeColor\n                        } else {\n                            LocalContentColor.current.copy(alpha = LocalContentAlpha.current)\n                        }, modifier = Modifier.size(24.dp)\n                    )\n                }, label = {\n                    Text(\n                        text = item.name,\n                        color = if (pagerState.currentPage == index) {\n                            HhfTheme.colors.themeColor\n                        } else {\n                            LocalContentColor.current.copy(alpha = LocalContentAlpha.current)\n                        },\n                        fontSize = 12.sp\n                    )\n                },\n                unselectedContentColor = LocalContentColor.current.copy(alpha = LocalContentAlpha.current),\n                selectedContentColor = HhfTheme.colors.themeColor,\n                alwaysShowLabel = true\n\n            )\n        }\n    }\n}\n```\n这里看出底部bar就是用了官方的BottomAppBar。\n里面具体内容是我们开发者自行设定的，这里遍历了bottomList，这个集合就是我们自己定义的一个集合：\n```Kotlin\n/**\n * 底部List集合 这里定义了4块\n * 首页，项目，公众号，我的\n */\nval bottomList = listOf(\n    BottomBean(\n        DashboardState.Home,\n        YshhApplication.context.stringResource(R.string.main_title_home)\n    ),\n    BottomBean(\n        DashboardState.Project,\n        YshhApplication.context.stringResource(R.string.main_title_project)\n    ),\n    BottomBean(\n        DashboardState.PubAccount,\n        YshhApplication.context.stringResource(R.string.main_title_account)\n    ),\n    BottomBean(\n        DashboardState.Mine,\n        YshhApplication.context.stringResource(R.string.main_title_mine)\n    )\n)\n```\n就这几个模块。\n\n底部bar的item就是 BottomNavigationitem里面的了，可以看到是一个icon+label构成。有个onClick的参数就是点击事件回调了，这里调用了 回调函数，传递给上层了，传出去的参数就一个int，表示第几页。\n\n回调到哪里呢？\n```Kotlin\n // 实际的底部bar 高度使用 固有特性测量 可以参考：https://juejin.cn/post/7068164264363556872\n            MainBottomBar(\n                Modifier\n                    .fillMaxWidth()\n                    .height(IntrinsicSize.Max),pagerState = pagerState) {\n                pagerState.reenableScrolling(coroutineScope, it)\n            }\n```\n这里通过调用rememberPagerState这个对象的`  pagerState.reenableScrolling(coroutineScope, it)`这个方法实现滚动到目标tab下。也就实现了页面切换。\n最为关键的就是这个pagerState，同步页面数据和底部bar。\n\n等下分析内容区也会用到。\n\n```Kotlin\n // 水平分页\n            HorizontalPager(\n                count = bottomList.size,\n                modifier.weight(1f), pagerState, userScrollEnabled = true\n            ) { page ->\n                when (page) {\n                    // 首页tab\n                    0 -> HomeView(\n                        Modifier\n                            .fillMaxSize()\n                            .background(HhfTheme.colors.background)\n                            .align(Alignment.CenterHorizontally)\n                    )\n                    // 项目tab\n                    1 -> ProjectView(\n                        Modifier\n                            .fillMaxSize()\n                            .align(Alignment.CenterHorizontally)\n                    )\n                    // 公众号tab\n                    2 -> AccountView(\n                        Modifier\n                            .fillMaxSize()\n                            .background(HhfTheme.colors.background)\n                            .align(Alignment.CenterHorizontally)\n                    )\n                    // 我的tab\n                    3 -> {\n//                        if (isLogin) {\n                            Mine(\n                                Modifier\n                                    .fillMaxSize()\n                                    .background(HhfTheme.colors.background)\n                                    .align(Alignment.CenterHorizontally)\n                            )\n//                        } else {\n//                            ErrorBox(\n//                                Modifier.fillMaxSize(),\n//                                title = stringResource(id = R.string.sign_in)\n//                            )\n//                            { CpNavigation.to(ModelPath.Login) }\n//                        }\n                    }\n                }\n            }\n```\n这里是中间内容区。通过使用水平分页得以实现。可以看到传入了一个参数，也就是上面底部bar用到的一个pagerState，定义了不同索引下，中间内容区展示的内容。\n\n* 首页Tab 对应 HomeView\n* 项目Tab 对应 ProjectView\n* 公众号Tab 对应 AccountView\n* 我的Tab 对应 Mine\n\n### 10.首页Tab-HomeView\n首页效果图就是上面的那个效果。\n这里再拆分下，就是轮播图+列表。\n对应 HomeView。\n\n```Kotlin\n@CompoKotlinsable\nfun HomeView(modifier: Modifier = Modifier) {\n    val viewModel: HomeViewModel = viewModel()\n    ColumnTopBarMain(modifier\n        .background(HhfTheme.colors.background),\n        stringResource(R.string.app_name)) {\n        // 内容区域，传入HomeViewModel对象\n        HomeContent(viewModel = viewModel)\n    }\n}\n```\n最外层是由顶部bar+内容区构成。\n\nColumnTabBarMain是自定义通用的一个App的组件，用于上面展示toolbar，中间区域自定义。\n```Kotlin\n@Composable\nfun ColumnTopBarMain(\n    modifier: Modifier = Modifier,\n    title: String,\n    content: @Composable ColumnScope.() -> Unit\n) {\n    Column(\n        modifier.navigationBarsPadding(),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        CpTopBar(\n            Modifier.fillMaxWidth(),\n            HhfTheme.colors.themeColor,\n            title = title,\n            actions = {\n                IconButton(onClick = {\n                    CpNavigation.to(ModelPath.Search)\n                }) {\n                    Icon(Icons.Filled.Search, contentDescription = \"search\", tint = Color.White)\n                }\n            },\n        )\n        content.invoke(this)\n    }\n}\n```\n这里具体是一个Column+CpTopBar构成\n\nCpTopBar是这样的：\n```Kotlin\n\n@Composable\nfun CpTopBar(\n    modifier: Modifier = Modifier,\n    backgroundColor: Color = Color.Transparent,\n    title: String,\n    actions: @Composable RowScope.() -> Unit = {},\n    back: (() -> Unit)? = null\n) {\n    HhTopAppBar(\n        {\n            Text(title, color = Color.White)\n        },\n        modifier = modifier,\n        backgroundColor = backgroundColor,\n        contentPadding = WindowInsets.statusBars.only(WindowInsetsSides.Horizontal + WindowInsetsSides.Top).asPaddingValues(),\n        navigationIcon = back?.run {\n            {\n                IconButton(\n                    onClick = {\n                        invoke()\n                    }\n                ) {\n                    Icon(Icons.Filled.ArrowBack, contentDescription = \"back\", tint = Color.White)\n                }\n            }\n        },\n        actions = actions,\n        elevation = 2.dp,\n    )\n}\n```\n\n里面还有自定义的HhTopAppBar\n```Kotlin\n\n@Composable\nfun HhTopAppBar(\n    title: @Composable () -> Unit,\n    modifier: Modifier = Modifier,\n    contentPadding: PaddingValues = PaddingValues(0.dp),\n    navigationIcon: @Composable (() -> Unit)? = null,\n    actions: @Composable RowScope.() -> Unit = {},\n    backgroundColor: Color = MaterialTheme.colors.primarySurface,\n    contentColor: Color = contentColorFor(backgroundColor),\n    elevation: Dp = AppBarDefaults.TopAppBarElevation,\n) {\n    TopAppBarSurface(\n        modifier = modifier,\n        backgroundColor = backgroundColor,\n        contentColor = contentColor,\n        elevation = elevation\n    ) {\n        TopAppBarContent(\n            title = title,\n            navigationIcon = navigationIcon,\n            actions = actions,\n            modifier = Modifier.padding(contentPadding)\n        )\n    }\n}\n```\n\n竟然还有自定义层：Surface是官方提供的了\n```Kotlin\n@Composable\nfun TopAppBarSurface(\n    modifier: Modifier = Modifier,\n    backgroundColor: Color = MaterialTheme.colors.primarySurface,\n    contentColor: Color = contentColorFor(backgroundColor),\n    elevation: Dp = AppBarDefaults.TopAppBarElevation,\n    content: @Composable () -> Unit,\n) {\n    Surface(\n        color = backgroundColor,\n        contentColor = contentColor,\n        elevation = elevation,\n        modifier = modifier,\n        content = content\n    )\n}\n```\n还有标题栏内容区： 这个TopAppBar是官方提供的了\n```Kotlin\n@Composable\nfun TopAppBarContent(\n    title: @Composable () -> Unit,\n    modifier: Modifier = Modifier,\n    navigationIcon: @Composable (() -> Unit)? = null,\n    actions: @Composable RowScope.() -> Unit = {},\n) {\n    TopAppBar(\n        title = title,\n        navigationIcon = navigationIcon,\n        actions = actions,\n        backgroundColor = Color.Transparent,\n        elevation = 0.dp,\n        modifier = modifier\n    )\n}\n```\n\n标题栏看完了，那就到内容区了。\n\n```Kotlin\n\n/**\n * 首页内容区\n */\n@Composable\nfun HomeContent(modifier: Modifier = Modifier, viewModel: HomeViewModel) {\n\n    /**\n     * list 为首页文章 列表数据；系统会对所有列表项进行组合和布局，无论它们是否可见，\n     * 因此如果您需要显示大量列表项（或长度未知的列表），则使用 Column 等布局可能会导致性能问题。\n     * Compose 提供了一组组件，这些组件只会对在组件视口中可见的列表项进行组合和布局。\n     */\n    val list = viewModel.viewStates.homeList.collectAsLazyPagingItems()\n\n    /**\n     * 下拉刷新组件\n     */\n    SwipeRefresh(\n        /**\n         * 状态，是否正在刷新\n         */\n        state = rememberSwipeRefreshState(viewModel.viewStates.isRefresh),\n        /**\n         * 下拉刷新回调，需要更新轮播+列表\n         */\n        onRefresh = {\n            viewModel.dispatch(HomeAction.GetBanner)\n            list.refresh()\n        }) {\n        // 内容区 使用LazyItem包裹\n        PagingItem(modifier, list = list,\n            errorBlock = {},\n            successBlock = {},\n            errorAndSuccessClick = {\n                /**\n                 * 错误后点击回调\n                 */\n                list.refresh()\n            }) {\n            /**\n             * 仅组成和放置 当前可见项 的竖直滚动列表。它允许您放置不同类型的子级内容。\n             * 例如，您可以使用LazyListScope.item添加单个项目，然后使用LazyListScope.items或者LazyListScope.itemsIndexed添加项目列表，后者有当前列表项的索引值。\n             */\n            LazyColumn{\n                /**\n                 * 单个item\n                 */\n                item {\n                    BannerPager(Modifier.height(160.dp), viewModel = viewModel)\n                }\n                /**\n                 * items集合\n                 */\n                items(it) { homeBean ->\n                    homeBean?.apply {\n                        /**\n                         * 首页文字item\n                         */\n                        HomeListItem(homeBean = this) {\n                            /**\n                             * 处理点击收藏图标 触发viewModel层调用接口\n                             */\n                            if(CacheUtils.isLogin){\n                                viewModel.dispatch(HomeAction.Collect(homeBean.id, it))\n                            }\n                            else{\n                                CpNavigation.to(ModelPath.Login)\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```\nlist 是专门用于懒加载列表，这个是存放可视区的列表。\n\n数据来源是ViewModel层的viewStates实例。\n\n```Kotlin\n/**\n * 首页状态，包装首页需要的数据\n */\ndata class HomeState(\n    /**\n     * 是否正在刷新\n     */\n    val isRefresh : Boolean = false,\n\n    /**\n     * 轮播列表，数据源\n     */\n    val bannerList: List<BannerResponse> = listOf(),\n\n    /**\n     * 首页数据\n     */\n    val homeList: Flow<PagingData<ArticleBean>> = Pager(\n        PagingConfig(PAGE_SIZE),\n        pagingSourceFactory = { HomeSource() }).flow,\n)\n```\n这个是存放到ViewModel层的首页动态数据。\n\n```Kotlin\n // 首页数据监听 通过 mutableStateOf包装 HomeState\n    var viewStates by mutableStateOf(\n        HomeState(\n            homeList = Pager(\n                PagingConfig(PAGE_SIZE),\n                pagingSourceFactory = { HomeSource() }).flow.cachedIn(viewModelScope)))\n        private set\n```\n这里用一个mutableStateof包装下。\n\n\n下面继续回到首页内容区：\n然后是一个SwipeRefresh组件,官方提供的。\n```Kotlin\n    SwipeRefresh(\n        /**\n         * 状态，是否正在刷新\n         */\n        state = rememberSwipeRefreshState(viewModel.viewStates.isRefresh),\n        /**\n         * 下拉刷新回调，需要更新轮播+列表\n         */\n        onRefresh = {\n            viewModel.dispatch(HomeAction.GetBanner)\n            list.refresh()\n        }) {\n```\n定义好下拉刷新触发事件。\n注意这个list，实际上走的是LazyPagingItems里面的一个refresh方法。\n我们在HomeState中定义的homeList是一个Flow包装列表集合。通过调用Flow中扩展的一个collectAsLazyPagingItems函数，就变成LazyPagingItems对象了。\n\n这个list我们放在PagingItem里面。\n\n然后首页内容区里面用了一个 LazyColumn，应该也是配合懒加载和复用官方实现的一个类。\n然后里面第一个item就是我们的轮播图了。\n\n```Kotlin\n/**\n * 顶部轮播图\n */\n@OptIn(ExperimentalPagerApi::class)\n@Composable\nfun BannerPager(modifier: Modifier = Modifier, viewModel: HomeViewModel) {\n    val pagerState = rememberPagerState()\n\n    /**\n     * 开启协程 内部的闭包是协程 目的是获取轮播图数据\n     */\n    LaunchedEffect(viewModel){\n        viewModel.dispatch(HomeAction.GetBanner)\n    }\n\n    /**\n     * 如需了解来自父项的约束条件并相应地设计布局，您可以使用 BoxWithConstraints。\n     * 就是外部传过来的modifier 决定子View 空间\n     */\n    BoxWithConstraints(modifier) {\n\n        /**\n         * 水平分页\n         */\n        HorizontalPager(\n            count = viewModel.viewStates.bannerList.size, // 轮播总数\n            state = pagerState // 轮播状态\n        ) { page ->\n            //  页面索引\n            when (page) {\n                viewModel.viewStates.bannerList[page].id -> {\n                    /**\n                     * 轮播图item\n                     */\n                    BannerItem(\n                        Modifier\n                            .height(maxHeight)\n                            .fillMaxWidth(), viewModel.viewStates.bannerList[page]\n                    )\n                }\n            }\n        }\n\n        /**\n         * 轮播指示器\n         */\n        if (viewModel.viewStates.bannerList.isNotEmpty()) {\n            BannerIndicator(\n                Modifier\n                    .align(Alignment.BottomCenter)\n                    .fillMaxWidth()\n                    .background(Color.Black.copy(0.2f))\n                    .padding(8.dp),viewModel, pagerState )\n        }\n\n\n    }\n}\n```\n这个轮播图里面开了个协程去获取轮播图数据，只会走一次。\n然后一个水平分页里面存放所有轮播图，轮播item为BannerItem,这个是自定义的\n```Kotlin\n@Composable\nfun BannerItem(modifier: Modifier = Modifier, data: BannerResponse) {\n    data.apply {\n        Box(modifier.clickable {\n            /**\n             * 点击图片，触发跳转WebView，通过bundle传递数据\n             */\n            CpNavigation.toBundle(ModelPath.WebView, Bundle().apply {\n                putString(webTitle, data.title)\n                putString(webUrl, data.url)\n                putBoolean(webIsCollect, false)\n                putInt(webCollectId, data.id)\n                putInt(webCollectType, 1)\n            })\n        }) {\n            /**\n             * 自定义网络图片\n             */\n            NetworkImage(\n                imagePath,\n                Modifier.fillMaxWidth(),\n                contentScale = ContentScale.FillBounds,\n                defaultImg = R.mipmap.ic_default_round\n            )\n        }\n    }\n}\n```\n\n轮播完了，就是文章item了。\n主要是为了实现这种效果\n![](./%E7%8E%A9Android-Compose%E7%89%88%E6%9C%AC-%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90/home_item.jpeg)\n\n```Kotlin\n /**\n   * items集合\n   */\nitems(it) { homeBean ->\n    homeBean?.apply {\n        /**\n        * 首页文字item\n        */\n        HomeListItem(homeBean = this) {\n            /**\n            * 处理点击收藏图标 触发viewModel层调用接口\n            */\n            if(CacheUtils.isLogin){\n                viewModel.dispatch(HomeAction.Collect(homeBean.id, it))\n            }\n            else{\n                CpNavigation.to(ModelPath.Login)\n            }\n        }\n    }\n}\n```\n这里用了items，然后遍历了 list,每个item对应一个 HomeListItem\n这里定义了一个函数，说明了点击收藏图标后的逻辑。\n\n```Kotlin\n  /**\n     * 是否收藏了，用remember包装一下bool值\n     */\n    var isCollect by remember{ mutableStateOf(homeBean.collect)}\n\n    /**\n     * 卡片布局\n     */\n    Card(\n        modifier\n            .padding(8.dp) // 内padding 8个dp\n            .clickable {\n                /**\n                 * 卡片点击事件，触发跳转webView\n                 */\n                CpNavigation.toBundle(ModelPath.WebView, Bundle().apply {\n                    putString(webTitle, homeBean.title)\n                    putString(webUrl, homeBean.link)\n                    putBoolean(webIsCollect, isCollect)\n                    putInt(webCollectId, homeBean.id)\n                    putInt(webCollectType, 0)\n                })\n            },\n        backgroundColor = HhfTheme.colors.listItem,\n        elevation = 5.dp\n    ) {\n```\n这里外层是用了Card,定义了点击item的逻辑。\n\n里面是这样的：\n```Kotlin\n Column(Modifier.padding(8.dp)) {\n                /**\n                 * 第一行 水平布局\n                 */\n                Row(verticalAlignment = Alignment.CenterVertically) {\n                    /**\n                     * 分享者没名字\n                     */\n                    Text(\n                        text = if (author.isNotEmpty()) author else shareUser,\n                        fontSize = 13.sp,\n                        color = HhfTheme.colors.textColor\n                    )\n                    /**\n                     * 显示标签\n                     */\n                    if(isShowLabel){\n                        if (type == 1) {\n                            Box(\n                                Modifier\n                                    .padding(start = 6.dp)\n                                    .border(1.dp, Color.Red, RoundedCornerShape(5.dp))\n                                    .padding(4.dp)\n                            ) {\n                                Text(stringResource(id = R.string.istop), Modifier, Color.Red, 10.sp)\n                            }\n                        }\n                        if (fresh) {\n                            Box(\n                                Modifier\n                                    .padding(start = 6.dp)\n                                    .border(1.dp, Color.Red, RoundedCornerShape(5.dp))\n                                    .padding(4.dp)\n                            ) {\n                                Text(stringResource(id = R.string.neww), Modifier, Color.Red, 10.sp)\n                            }\n                        }\n                        if (tags.isNotEmpty()) {\n                            Box(\n                                Modifier\n                                    .padding(start = 6.dp)\n                                    .border(1.dp, Color(0xFF66BB6A), RoundedCornerShape(5.dp))\n                                    .padding(4.dp)\n                            ) {\n                                Text(tags[0].name, Modifier, Color(0xFF66BB6A), 10.sp)\n                            }\n                        }\n                    }\n                    /**\n                     * 发布日期\n                     */\n                    Text(\n                        niceDate,\n                        Modifier\n                            .weight(1f)\n                            .wrapContentWidth(\n                                Alignment.End\n                            )\n                            .align(Alignment.CenterVertically),\n                        HhfTheme.colors.textColor.copy(0.6f),\n                        fontSize = 13.sp,\n                    )\n                }\n                /**\n                 * 有没有封面图\n                 */\n                if (TextUtils.isEmpty(envelopePic)) {\n                    // 没有封面图\n                    Text(\n                        title.filterHtml(),\n                        Modifier.padding(top = 12.dp),\n                        HhfTheme.colors.textColor,\n                        fontSize = 14.sp,\n                        fontWeight = FontWeight.Bold\n                    )\n                } else {\n                    // 有封面图时，中间区域展示\n                    Row(Modifier.padding(top = 12.dp)) {\n                        // 网络图片\n                        NetworkImage(\n                            envelopePic,\n                            Modifier.size(100.dp),\n                            contentScale = ContentScale.Crop,\n                            defaultImg = R.mipmap.ic_default_round\n                        )\n                        // 垂直布局\n                        Column(Modifier.padding(start = 8.dp)) {\n                            // 标题\n                            Text(\n                                title.filterHtml(),\n                                color = HhfTheme.colors.textColor,\n                                fontSize = 14.sp,\n                                maxLines = 3,\n                                style = TextStyle(fontWeight = FontWeight.Bold)\n                            )\n                            // 摘要描述\n                            Text(\n                                desc,\n                                color = HhfTheme.colors.textInactiveColor,\n                                fontSize = 13.sp,\n                                maxLines = 3,\n                                overflow = TextOverflow.Ellipsis\n                            )\n                        }\n                    }\n                }\n                // 底部水平布局\n                Row {\n                    // 文本\n                    Text(\n                        \"$superChapterName / $chapterName\",\n                        Modifier.padding(top = 12.dp),\n                        HhfTheme.colors.textColor,\n                        fontSize = 13.sp\n                    )\n                    // 图标，是否收藏了\n                    Icon(\n                        if(isCollect) Icons.Filled.Favorite else Icons.Filled.FavoriteBorder, contentDescription = \"\",\n                        Modifier\n                            .wrapContentWidth(\n                                Alignment.End\n                            )\n                            .weight(1f)\n                            .clickable {\n                                /**\n                                 * 点击收藏，触发请求\n                                 */\n                                favoriteAction(isCollect)\n                                isCollect = !isCollect\n                            },\n                        tint = HhfTheme.colors.themeColor\n                    )\n                }\n            }\n```\n\n### 11.我的Tab-Mine\n因为项目和公众号和首页基本一样，这里就不重复分析了。\n看下我的页面的效果图：\n<img src=mine.jpeg width=50%>\n要实现这样的效果，怎么处理呢？\n\n首先开启一个协程，获取用户sp数据，转成UserInfo对象\n```Kotlin\n   /**\n     * 开启协程，只走一次\n     */\n    LaunchedEffect(CacheUtils.userInfo) {\n        if (CacheUtils.userInfo != \"\") {\n            /**\n             * 根据sp文件，生产一个UserInfo对象，设置给这个我的页面使用\n             */\n            mineViewModel.dispatch(\n                MineViewEvent.SetUserInfo(\n                    Gson().fromJson(\n                        CacheUtils.userInfo, // sp文件\n                        UserInfo::class.java\n                    )\n                )\n            )\n            /**\n             * 获取积分和排名\n             */\n            mineViewModel.dispatch(MineViewEvent.GetIntegral)\n        }\n    }\n```\n这里获取积分和排名是需要走接口的\n这里会走到ViewModel层这个函数：\n```Kotlin\n    private fun getIntegral() {\n        viewModelScope.launch {\n            flow {\n                emit(\n                    TaskApi.create(ApiService::class.java).getIntegral()\n                )\n            }.map {\n                if (it.errorCode == 0) {\n                    it.data\n                        ?: throw Exception(\"data null\")\n                } else {\n                    throw Exception(it.errorMsg)\n                }\n            }.onEach {\n                viewStates = viewStates.copy(integral = it)\n            }.catch {\n                viewStates = viewStates.copy(integral = null)\n            }.collect()\n        }\n    }\n```\n这个retrofit中是这样定义的：\n```Kotlin\ninterface ApiService {\n    /**\n     * 获取当前账户的个人积分\n     */\n    @GET(\"lg/coin/userinfo/json\")\n    suspend fun getIntegral(): ApiResponse<Integral>\n```\n这个就是一个suspend挂起函数。\n\n顶层为Column:\n```Kotlin\n    /**\n     * 顶层为列表视图\n     */\n    Column(modifier) {\n        /**\n         * 顶部👤\n         */\n        MineTopAvatar(\n            Modifier\n                .fillMaxWidth()\n                .height(320.dp)\n                .clip(QureytoImageShapes(160f)),\n            mineViewModel.viewStates.userInfo?.run {\n                nickname\n            } ?: \"avatar\"\n        ) {\n```\n\n头像区域，点击后可以弹pop，但是需要先获取权限，这样获取：\n```Kotlin\n// 图片点击事件 会去申请下权限\n            XXPermissions\n                .with(context)\n                .permission(Permission.CAMERA)\n                .permission(Permission.MANAGE_EXTERNAL_STORAGE)\n                .request(object : OnPermissionCallback {\n                    override fun onGranted(\n                        granted: List<String>,\n                        all: Boolean\n                    ) {\n                        if (all) {\n                            if(isLogin){\n                                mineViewModel.dispatch(MineViewEvent.ChangePopupState(true))\n                            }\n                            else{\n                                CpNavigation.to(ModelPath.Login)\n                            }\n                        }\n                    }\n\n                    override fun onDenied(\n                        denied: List<String>,\n                        never: Boolean\n                    ) {\n                        if (never) {\n                            context.showToast(context.stringResource(R.string.permissions_cm_error))\n                            XXPermissions.startPermissionActivity(\n                                context,\n                                denied\n                            )\n                        } else {\n                            context.showToast(context.stringResource(R.string.permissions_camera_error))\n                        }\n                    }\n                })\n```\n用了一个三方库实现。\n\n中间操作栏这样实现：\n```Kotlin\n  // 操作栏 有个外边框，包裹菜单项，底部有阴影\n        Surface(\n            Modifier\n                .padding(start = 20.dp, end = 20.dp)\n                .fillMaxWidth()\n                .background(HhfTheme.colors.background),\n            elevation = 2.dp,\n            shape = RoundedCornerShape(8.dp),\n            color = MaterialTheme.colors.surface, // color will be adjusted for elevation\n        ) {\n```\n\n具体的菜单项也是用懒加载实现：\n```Kotlin\nLazyColumn(Modifier.background(HhfTheme.colors.listItem)) {\n                itemsIndexed(list) { i, bean ->\n\n                    /**\n                     * 我的页面遍历菜单项\n                     */\n                    MineItem(\n                        Modifier\n                            .fillMaxWidth()\n                            .clickable {\n                                /**\n                                 * 分发开发者行为\n                                 */\n                                mineViewModel.dispatch(MineViewEvent.ToComposable(bean.id))\n                            }\n                            .height(45.dp), bean.name, HhfTheme.colors.themeColor,\n                        bean.icon)\n                    if (i < list.size - 1) {\n                        /**\n                         * 非最后一行显示分割线\n                         */\n                        Divider(\n                            modifier = Modifier\n                                .fillMaxWidth()\n                                .padding(start = 10.dp, end = 10.dp)\n                        )\n                    }\n                }\n            }\n```\n\n具体的菜单item,有图标+文字+右侧箭头实现：\n```Kotlin\n\n@Composable\nfun MineItem(\n    modifier: Modifier = Modifier, textName: String, iconColor: Color, icon: ImageVector\n) {\n    Row(\n        modifier,\n        verticalAlignment = Alignment.CenterVertically,\n    ) {\n        Icon(\n            icon, \"$textName icon\",\n            Modifier\n                .size(28.dp)\n                .padding(start = 10.dp), iconColor\n        )\n        Text(\n            textName,\n            Modifier.padding(start = 10.dp),\n            fontSize = 14.sp,\n            fontFamily = FontFamily.Serif,\n            color = HhfTheme.colors.textColor\n        )\n        Icon(\n            Icons.Filled.KeyboardArrowRight, textName,\n            Modifier\n                .weight(1f)\n                .padding(end = 10.dp)\n                .wrapContentWidth(Alignment.End),\n            tint = HhfTheme.colors.textColor\n        )\n    }\n}\n```\n\nUI搞定了，跳转逻辑怎么处理呢？\n答案是viewModel层实现。\n\n这里有个clickable点击闭包：\n` mineViewModel.dispatch(MineViewEvent.ToComposable(bean.id))`\n\n\n会委托给mineViewModel处理：\n```Kotlin\n    /**\n     * 分发开发者行为\n     */\n    fun dispatch(action: MineViewEvent) {\n        when (action) {\n            is MineViewEvent.Blur -> bitmapBlur(action.s)\n            /**\n             * 用户点击菜单项\n             */\n            is MineViewEvent.ToComposable -> toComposable(action.type)\n            is MineViewEvent.ChangePopupState -> {\n                Log.e(\"TEST##\", \"这里触发了viewStates中 isShowpopup 变更为：${action.flag}\")\n                viewStates = viewStates.copy(isShowPopup = action.flag)\n            }\n            is MineViewEvent.SetUserInfo -> viewStates = viewStates.copy(userInfo = action.userInfo)\n            is MineViewEvent.GetIntegral -> getIntegral()\n        }\n    }\n```\n这里分发开发者行为，其实更像用户行为，有可能不是用户触发，所以我这里称之为开发者行为。\n\n点击菜单项继续分发：\n```Kotlin\nprivate fun toComposable(type: Int) {\n        if(isLogin){\n            when (type) {\n                0 -> CpNavigation.to(ModelPath.Integral)\n                1 -> CpNavigation.to(ModelPath.Collect)\n                2 -> CpNavigation.to(ModelPath.Share)\n                3 -> CpNavigation.to(ModelPath.Todo)\n                4 -> CpNavigation.toBundle(ModelPath.WebView, Bundle().apply {\n                    putString(webTitle, \"PlayAndroid\")\n                    putString(webUrl, \"https://github.com/yellowhai/PlayAndroid\")\n                    putBoolean(webIsCollect, false)\n                    putInt(webCollectId, 998)\n                    putInt(webCollectType, 1)\n                })\n                5 -> CpNavigation.to(ModelPath.Setting)\n            }\n        }\n        else{\n            when (type) {\n                4 -> CpNavigation.toBundle(ModelPath.WebView, Bundle().apply {\n                    putString(webTitle, \"PlayAndroid\")\n                    putString(webUrl, \"https://github.com/yellowhai/PlayAndroid\")\n                    putBoolean(webIsCollect, false)\n                    putInt(webCollectId, 998)\n                    putInt(webCollectType, 1)\n                })\n                5 -> CpNavigation.to(ModelPath.Setting)\n                else -> CpNavigation.to(ModelPath.Login)\n            }\n        }\n    }\n```\n这里定义了跳转逻辑，这里有回到 第8点主页外部架构 中的导航定义了。\n实现跳转到其它页面了，这更像是在布局上叠加，不算是跳转吧。\n\n这个项目还有很多细节值得一探究竟，不过对于初始compose，也差不多了，了解到这个程度也算入门了吧。\n\n\n","slug":"玩Android-Compose版本-项目分析","published":1,"updated":"2023-02-01T07:17:16.383Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlhfhyw001tivv741r7eu8e","content":"<blockquote>\n<p>玩Android(compose版本)项目地址：<a href=\"https://github.com/yellowhai/PlayAndroid\">https://github.com/yellowhai/PlayAndroid</a></p>\n</blockquote>\n<h3 id=\"1-项目settings-gradle\"><a href=\"#1-项目settings-gradle\" class=\"headerlink\" title=\"1.项目settings.gradle\"></a>1.项目settings.gradle</h3><pre><code class=\"line-numbers language-groovy\">dependencyResolutionManagement &#123;\n    /**\n     * 原文中说默认情况下，项目中的存储库会覆盖设置中的存储库 ，可以通过设置模式来更改这种行为\n     设置存储库的方法：\n     repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n     存储库模式：\n     PREFER_PROJECT(true)--首选项目存储库\n     PREFER_SETTINGS(false)--首选设置存储库\n     FAIL_ON_PROJECT_REPOS(false)--强制设置存储库\n     */\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories &#123;\n        google()\n        mavenCentral()\n        maven &#123; url &quot;https://jitpack.io&quot; &#125;\n        maven &#123;\n            url &#39;https://maven.aliyun.com/repository/public/&#39;\n        &#125;\n        maven &#123; url &#39;https://maven.aliyun.com/repository/public&#39; &#125;\n        maven &#123; url &#39;https://maven.aliyun.com/repository/central&#39; &#125;\n        maven &#123; url &#39;https://maven.aliyun.com/repository/google&#39; &#125;\n        maven &#123; url &#39;https://maven.aliyun.com/repository/public&#39; &#125;\n        maven &#123; url &#39;https://maven.aliyun.com/repository/gradle-plugin&#39; &#125;\n    &#125;\n&#125;\nrootProject.name = &quot;PlayAndroid&quot;\ninclude &#39;:app&#39;\ninclude &#39;:common&#39;\ninclude &#39;:h_mine&#39;\ninclude &#39;:toolkit&#39;\n</code></pre>\n<p>还是很容易理解的，repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)这个是新增的，简单看下就行。<br>引入了app模块(主模块)，common模块（通用模块，用于通用组件相关）,h_mine模块（我的模块，可以单独编译）。</p>\n<h3 id=\"2-config-gradle\"><a href=\"#2-config-gradle\" class=\"headerlink\" title=\"2.config.gradle\"></a>2.config.gradle</h3><p>这个文件相信大家都有用过的，配置远程依赖的一个文件，统一管理。</p>\n<pre><code class=\"line-numbers language-groovy\">ext&#123;\n    isRelease = true\n\n    //android构建配置\n    android_models = [\n            compileSdk : 32,\n            minSdk : 23,\n            targetSdk : 32,\n            versionCode : 1,\n            versionName : &quot;1.0&quot;\n    ]\n    \n    app_id = [\n            mine      : &#39;com.hh.mine&#39;,\n    ]\n\n    core_ktx_version = &#39;1.7.0&#39;\n    appcompat_version = &#39;1.4.0&#39;\n    lifecycle_version = &#39;2.4.0&#39;\n    material_version = &#39;1.4.0&#39;\n    work_version = &#39;2.7.1&#39;\n    gson_version = &#39;2.8.9&#39;\n    litepal_version = &#39;3.2.3&#39;\n    landscapist_version = &#39;1.4.5&#39;\n    retrofit_version = &#39;2.9.0&#39;\n    okhttp_version = &#39;4.9.3&#39;\n    startup_version = &#39;1.1.0&#39;\n    XXPermissions_version = &#39;13.2&#39;\n    datastore_version = &#39;1.0.0&#39;\n    materialDialog_version = &#39;0.6.2&#39;\n    accompanist_version = &#39;0.25.0&#39;\n\n\n    jetpack_compose = [\n            material : &quot;androidx.compose.material:material:$compose_version&quot;,\n            activity : &quot;androidx.activity:activity-compose:$appcompat_version&quot;,\n    ]\n\n    commonApi = [\n            ktx_core        : &quot;androidx.core:core-ktx:$core_ktx_version&quot;,\n            lifecycle       : &quot;androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version&quot;,\n            appcompat       : &quot;androidx.appcompat:appcompat:$appcompat_version&quot;,\n            material        : &quot;com.google.android.material:material:$material_version&quot;,\n            //数据存储\n            datastore       : &quot;androidx.datastore:datastore-preferences:$datastore_version&quot;,\n            //权限处理\n            XXPermissions   : &quot;com.github.getActivity:XXPermissions:$XXPermissions_version&quot;,\n    ]\n\n    net = [\n            retrofit    : &quot;com.squareup.retrofit2:retrofit:$retrofit_version&quot;,\n            converter   : &quot;com.squareup.retrofit2:converter-gson:$retrofit_version&quot;,\n            okhttp      : &quot;com.squareup.okhttp3:logging-interceptor:$okhttp_version&quot;,\n            gson        : &quot;com.google.code.gson:gson:$gson_version&quot;\n    ]\n\n    accompanist_ui = [\n            insets_ui    : &quot;com.google.accompanist:accompanist-insets-ui:$accompanist_version&quot;,\n            navigation   : &quot;com.google.accompanist:accompanist-navigation-animation:$accompanist_version&quot;,\n            pager        : &quot;com.google.accompanist:accompanist-pager:$accompanist_version&quot;,\n            swiperefresh : &quot;com.google.accompanist:accompanist-swiperefresh:$accompanist_version&quot;,\n            flowlayout   : &quot;com.google.accompanist:accompanist-flowlayout:$accompanist_version&quot;,\n            systemUi     : &quot;com.google.accompanist:accompanist-systemuicontroller:$accompanist_version&quot;,\n            webview      : &quot;com.google.accompanist:accompanist-webview:$accompanist_version&quot;\n    ]\n\n    database =[\n            litepal :  &quot;org.litepal.guolindev:core:$litepal_version&quot;\n    ]\n\n    skydoves_coil = [\n            landscapist_coil :  &quot;com.github.skydoves:landscapist-coil:$landscapist_version&quot;\n    ]\n\n    workManager = [\n            // Kotlin + coroutines\n            work = &quot;androidx.work:work-runtime-ktx:$work_version&quot;\n    ]\n\n    material_dialog = [\n            color : &quot;io.github.vanpra.compose-material-dialogs:color:$materialDialog_version&quot;,\n            core  : &quot;io.github.vanpra.compose-material-dialogs:core:$materialDialog_version&quot;,\n            datetime  : &quot;io.github.vanpra.compose-material-dialogs:datetime:$materialDialog_version&quot;\n    ]\n\n    paging = &quot;androidx.paging:paging-compose:1.0.0-alpha14&quot;\n\n    jetpackComposeLibs = jetpack_compose.values()\n    commonApiLibs = commonApi.values()\n    netLibs = net.values()\n    materialDialogLibs = material_dialog.values()\n&#125;\n</code></pre>\n<p>层次还是比较清晰，对于同一组单独建立数组存储，模块中只需要引入一个就将这组全部引入进去了。</p>\n<h3 id=\"3-app模块下的build-gradle\"><a href=\"#3-app模块下的build-gradle\" class=\"headerlink\" title=\"3.app模块下的build.gradle\"></a>3.app模块下的build.gradle</h3><p>显示引入com.android.application+kotlin-android的插件。<br>下面配置android闭包，很简单。</p>\n<p>其它关于compose的也需要配置下：</p>\n<pre><code class=\"line-numbers language-groovy\"> compileOptions &#123;\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    &#125;\n    buildFeatures &#123;\n        compose true\n    &#125;\n    composeOptions &#123;\n        kotlinCompilerExtensionVersion compose_version\n        kotlinCompilerVersion kotlin_version\n    &#125;\n</code></pre>\n<p>然后是远程依赖：</p>\n<pre><code class=\"line-numbers language-groovy\">dependencies &#123;\n    // 如果是release模式，就把我的模块加进来\n    if(isRelease)&#123;\n        implementation project(&#39;:h_mine&#39;)\n    &#125;\n\n    // 初始化组件\n    implementation &quot;androidx.startup:startup-runtime:$startup_version&quot;\n    implementation project(&#39;:common&#39;)\n\n    // 测试相关\n    testImplementation &#39;junit:junit:4.13.2&#39;\n    androidTestImplementation &#39;androidx.test.ext:junit:1.1.3&#39;\n    androidTestImplementation &#39;androidx.test.espresso:espresso-core:3.4.0&#39;\n    androidTestImplementation &quot;androidx.compose.ui:ui-test-junit4:$compose_version&quot;\n    androidTestImplementation &quot;androidx.compose.ui:ui-test-junit4:$compose_version&quot;\n    debugImplementation &quot;androidx.compose.ui:ui-tooling:$compose_version&quot;\n\n&#125;\n</code></pre>\n<p>isRelease定义在 config.gradle的顶部。如果是集成编译就为true，单独编译为false。</p>\n<h3 id=\"4-app模块的AndroidManifest-xml\"><a href=\"#4-app模块的AndroidManifest-xml\" class=\"headerlink\" title=\"4.app模块的AndroidManifest.xml\"></a>4.app模块的AndroidManifest.xml</h3><ul>\n<li>配置Application</li>\n<li>配置主页</li>\n<li>配置provider，用于初始化sdk<pre><code class=\"line-numbers language-xml\">  &lt;!--  用provider初始化sdk--&gt;\n    &lt;provider\n        android:name=&quot;androidx.startup.InitializationProvider&quot;\n        android:authorities=&quot;$&#123;applicationId&#125;.androidx-startup&quot;\n        android:exported=&quot;false&quot;\n        tools:node=&quot;merge&quot;&gt;\n        &lt;meta-data\n            android:name=&quot;com.hh.playandroid.base.BaseInitializer&quot;\n            android:value=&quot;androidx.startup&quot; /&gt;\n    &lt;/provider&gt;\n</code></pre>\n</li>\n</ul>\n<h3 id=\"5-自定义Application\"><a href=\"#5-自定义Application\" class=\"headerlink\" title=\"5.自定义Application\"></a>5.自定义Application</h3><pre><code>class HhfApp : YshhApplication()\n</code></pre>\n<p> 依赖common模块：</p>\n<pre><code class=\"line-numbers language-Kotlin\">open class YshhApplication : Application() &#123;\n\n   lateinit var okbuilder: OkHttpClient\n\n   companion object &#123;\n       /**\n        * application context.\n        */\n       @SuppressLint(&quot;StaticFieldLeak&quot;)\n       lateinit var context: Context\n\n       @SuppressLint(&quot;StaticFieldLeak&quot;)\n       lateinit var instance: YshhApplication\n\n       /**\n        * application级别的协程\n        * 有时我们需要在协程上下文中定义多个元素，组合协程上下文中的元素，使用 + 操作符来创建 CoroutineScope .\n        */\n       val applicationScope = CoroutineScope(SupervisorJob() + Dispatchers.Main)\n   &#125;\n</code></pre>\n<p> 这里懒加载OkHttpClient<br> 定义了全局的协程，静态变量。</p>\n<pre><code class=\"line-numbers language-Kotlin\">  override fun onCreate() &#123;\n       super.onCreate()\n       context = applicationContext\n       instance = this\n       initRetrofit()\n   &#125;\n</code></pre>\n<p> 初始化Retrofit：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n    * 初始化Retrofit\n    */\n   private fun initRetrofit(token : String = &quot;&quot;): OkHttpClient &#123;\n       //请求头\n       val headerInterceptor = Interceptor &#123; chain: Interceptor.Chain -&gt;\n           val orignaRequest = chain.request()\n           val request = orignaRequest.newBuilder()\n               .header(&quot;Authorization&quot;, &quot;Bearer $token&quot;)\n               .method(orignaRequest.method, orignaRequest.body)\n               .build()\n           chain.proceed(request)\n       &#125;\n       val logInterceptor = LogInterceptor &#123;\n//            it.logE()\n       &#125;\n       // 日志类别\n       logInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);\n       // 缓存相关\n       val cacheFile =\n           File(getExternalFilesDir(Environment.DIRECTORY_PICTURES).toString() + &quot;http_cache&quot;)\n       val cache = Cache(cacheFile, 104857600L) // 指定缓存大小100Mb\n       val builder = OkHttpClient.Builder()\n       //        builder.addInterceptor(addQueryParameterInterceptor);\n       builder.addInterceptor(headerInterceptor)\n       builder.cache(cache)\n       builder.addNetworkInterceptor(logInterceptor)\n       builder.cookieJar(cookieJar)\n       builder.readTimeout(60000, TimeUnit.MILLISECONDS)\n       //全局的写入超时时间60s\n       builder.writeTimeout(60000, TimeUnit.MILLISECONDS)\n       //全局的连接超时时间30s\n       builder.connectTimeout(30000, TimeUnit.MILLISECONDS)\n       okbuilder = builder.build()\n       return builder.build()\n   &#125;\n\n   private val cookieJar: PersistentCookieJar by lazy &#123;\n       PersistentCookieJar(SetCookieCache(), SharedPrefsCookiePersistor(context))\n   &#125;\n   \n   fun getOkBuilder(): OkHttpClient &#123;\n       return okbuilder\n   &#125;\n</code></pre>\n<h3 id=\"6-首页-MainActivity\"><a href=\"#6-首页-MainActivity\" class=\"headerlink\" title=\"6.首页 MainActivity\"></a>6.首页 MainActivity</h3><p> 继承BaseActivity:</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n/**\n* 基类Activity 设置非沉浸式，因为要设置导航栏和状态栏颜色\n*/\nabstract class BaseActivity : AppCompatActivity() &#123;\n\n   override fun onCreate(savedInstanceState: Bundle?) &#123;\n       super.onCreate(savedInstanceState)\n       WindowCompat.setDecorFitsSystemWindows(window, false)\n   &#125;\n\n&#125;\n</code></pre>\n<p>onCreate生命周期：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> @Suppress(&quot;DEPRECATED_IDENTITY_EQUALS&quot;)\n    @OptIn(ExperimentalAnimationApi::class)\n    override fun onCreate(savedInstanceState: Bundle?) &#123;\n        super.onCreate(savedInstanceState)\n        // 动画渐变\n        overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out)\n        // 设置内容\n        setContent &#123;\n            Log.e(&quot;TEST##&quot;, &quot;开始setContent了&quot;)\n            // 顶层为自定义主题\n            HhfTheme(\n                // 是否暗色或亮色，跟随系统，如果用户主动设置，跟随用户\n                theme = if (isSystemInDarkTheme() || isNight) HhfTheme.Theme.Dark else HhfTheme.Theme.Light,\n                // 用户自行设置的颜色主题\n                colorTheme = appTheme\n            ) &#123;\n                // 创建一个MainViewModel\n                val viewModel : MainViewModel = viewModel()\n\n                // 如果isSplash为true,就展示SplashView 启动页\n                if (viewModel.isSplash) &#123;\n                    Log.e(&quot;TEST##&quot;, &quot;加载闪屏了&quot;)\n                    SplashView &#123; viewModel.isSplash = false &#125;\n                &#125; else &#123;\n                    Log.e(&quot;TEST##&quot;, &quot;加载首页了&quot;)\n                    // 全局静态变量存 底部控制器\n                    CpNavigation.navHostController = rememberAnimatedNavController()\n                    // 主页面\n                    HhfNavigation()\n                    // 进度条\n                    DialogProgress()\n                &#125;\n                // 是否纪念日，将App置灰\n                if(isMourningDay())&#123;\n                    Canvas(modifier = Modifier.fillMaxSize())&#123;\n                        drawRect(color = Color.White,blendMode = BlendMode.Saturation)\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        addCallback()\n    &#125;\n</code></pre>\n<p>因为这个app就一个Activity，setContent中的内容就是展现给用户可以看到的所有东西了。<br>顶层是一个自定义主题：</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun HhfTheme(\n    theme: HhfTheme.Theme = HhfTheme.Theme.Light,\n    colorTheme: Color? = null,\n    content: @Composable () -&gt; Unit\n) &#123;\n    val targetColors = if (theme == HhfTheme.Theme.Dark) &#123;\n        colorTheme?.let &#123;\n            rememberSystemUiController().setNavigationBarColor(colorTheme)\n            DarkColorPalette.apply &#123;\n                themeColor = it\n            &#125;\n        &#125;?:DarkColorPalette\n    &#125; else &#123;\n        colorTheme?.let &#123;\n            rememberSystemUiController().setNavigationBarColor(colorTheme)\n            LightColorPalette.apply &#123;\n                themeColor = it\n            &#125;\n        &#125;?:LightColorPalette\n    &#125;\n    val themeColor = animateColorAsState(targetColors.themeColor, TweenSpec(600))\n    val textColor = animateColorAsState(targetColors.textColor, TweenSpec(600))\n    val background = animateColorAsState(targetColors.background,TweenSpec(600))\n    val listItem =  animateColorAsState(targetColors.listItem,TweenSpec(600))\n    val bottomBar =  animateColorAsState(targetColors.bottomBar,TweenSpec(600))\n    val divider =  animateColorAsState(targetColors.divider,TweenSpec(600))\n    val textFieldBackground =  animateColorAsState(targetColors.textFieldBackground,TweenSpec(600))\n    val colors = HhfColors(themeColor.value,\n        textColor.value,\n        background = background.value,\n        listItem = listItem.value,\n        bottomBar = bottomBar.value,\n        divider = divider.value,\n        textFieldBackground = textFieldBackground.value,\n        )\n    CompositionLocalProvider(LocalHhfColors provides colors) &#123;\n        MaterialTheme(\n            shapes = Shapes,\n            typography = typography\n        ) &#123;\n            content.invoke()\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里用到了一个 CompositionLocalProvider，具体用法可以参考 <a href=\"https://juejin.cn/post/7097890697721675813\">https://juejin.cn/post/7097890697721675813</a></p>\n<p>在Compose函数里，如果要用到函数外提供的值，一般都要通过函数定义好参数，外部调用时传入进去。<br>这种方法表面看没啥问题，但在一些场景下就不是很方便。比如一个函数A嵌套一个函数B，函数B嵌套函数C，并且这A、B、C的函数都用到这个参数，那对三个函数来说都需要定义这个参数，就不是那么方便。<br>那用个全局变量不就可以解决需要重复定义参数，确实可以。但全局变量有个副作用就是影响的范围比较大。本身我们定义的参数只会影响到函数内部。这个时候我们就可以使用CompositionLocal：它具有穿透函数功能的局部变量<br>CompositionLocal适用场景：用来提供上下文数据，不扩大影响范围。</p>\n<p>然后最终主题呈现是用了 MaterialTheme这个类展现。</p>\n<p>回到首页，内容区：</p>\n<ul>\n<li>闪屏页展示逻辑<br>  通过一个变量：<code>  var isSplash by mutableStateOf(true)</code> 实现控制是否显示</li>\n<li>加载首页<br> 先 展示主页面，覆盖一层 进度条</li>\n<li>是否纪念日<br>  app置灰处理    </li>\n<li>添加二次点击返回退出app逻辑</li>\n</ul>\n<p>首页逻辑基本就这么多了。</p>\n<h3 id=\"7-闪屏ui-gt-SplashView\"><a href=\"#7-闪屏ui-gt-SplashView\" class=\"headerlink\" title=\"7.闪屏ui -&gt; SplashView\"></a>7.闪屏ui -&gt; SplashView</h3><p>看下效果先：<br><img src=%E9%97%AA%E5%B1%8F%E9%A1%B5.gif width = 50%></p>\n<p>可以看到进入app后有个启动页面，中间是logo。<br>那这个页面有个渐变动画，淡入淡出效果。</p>\n<p>具体ui是这样的：</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun SplashView(startMain: () -&gt; Unit) &#123;\n    /**\n     * 辅助文字颜色变化 建立的一个mutableState包装的变量，实际上就是bool值\n     */\n    var enabled by remember &#123; mutableStateOf(false) &#125;\n\n    /**\n     * 背景颜色，从0.3alpha主题色变为纯主题色，2s的时间\n     */\n    val bgColor: Color by animateColorAsState(\n        if (enabled) HhfTheme.colors.themeColor\n        else HhfTheme.colors.themeColor.copy(alpha = 0.3f),\n        animationSpec = tween(durationMillis = 2000)\n    )\n\n    /**\n     * 中间文字颜色动画，如果enable为false，0.3alpha的颜色 到纯白色 2s的时间\n     */\n    val textColor: Color by animateColorAsState(\n        if (enabled) Color.White\n        else Color.White.copy(alpha = 0.3f),\n        animationSpec = tween(durationMillis = 2000)\n    )\n\n    // 外层一个Box+中间一个Text\n    Box(\n        Modifier\n            .fillMaxSize()\n            .background(bgColor),\n        contentAlignment = Alignment.Center\n    ) &#123;\n        Text(text = &quot;PlayAndroid&quot;, color = textColor,style = MaterialTheme.typography.h5)\n    &#125;\n\n    // 开启协程 可以看出Compose里面开启协程的方法\n    LaunchedEffect(Unit) &#123;\n        enabled = true\n        delay(2000)\n        // 2s后，设置 mutableStateOf 包装的bool变量 为false 会通知首页重新走setContent方法\n        startMain.invoke()\n    &#125;\n&#125;\n</code></pre>\n<p>这里需要理解 animateColorAsState 是官方提供的一个动画，支持颜色变化的一个composable方法。</p>\n<p>然后这里开启了2s延迟，怎么开延迟的，调用LaunchedEffect方法里面的delay，可以实现延迟效果。然后执行startMain回调。</p>\n<p>这个回调很简单：viewModel.isSplash &#x3D; false</p>\n<p>虽然很简单，但实际上走了很多流程的。</p>\n<pre><code class=\"line-numbers language-Kotlin\">class MainViewModel : ViewModel() &#123;\n    var isSplash by mutableStateOf(true)\n&#125;\n</code></pre>\n<p>这里使用mutableStateOf包装了一个布尔值。 上面触发这改变时，会刷新composable注解声明的方法体。这里应该就是刷新MainActivity整个内容区了。</p>\n<h3 id=\"8-主页面外部架构\"><a href=\"#8-主页面外部架构\" class=\"headerlink\" title=\"8.主页面外部架构\"></a>8.主页面外部架构</h3><pre><code class=\"line-numbers language-Kotlin\">@ExperimentalAnimationApi\n@OptIn(ExperimentalPagerApi::class)\n@Composable\nfun HhfNavigation() &#123;\n    AnimatedNavHost(navController = CpNavigation.navHostController,\n        /**\n         * 首页默认页面\n         */\n        startDestination = ModelPath.Main.route,\n        enterTransition = &#123; fadeIn(animationSpec = tween(700), initialAlpha = 0f) &#125;,\n        exitTransition = &#123; fadeOut(animationSpec = tween(700), targetAlpha = 0f) &#125;) &#123;\n\n        /**\n         * 定义接收到 main 路由消息后-&gt;展示MainContent视图\n         */\n        composable(ModelPath.Main.route) &#123;\n            MainContent()\n        &#125;\n\n        /**\n         * 接收到 setting 路由消息后 -&gt; 设置页面\n         */\n        composable(ModelPath.Setting.route) &#123;\n            CpSetting(Modifier.fillMaxSize())\n        &#125;\n        ...\n</code></pre>\n<p>这里使用了一个AnimatedNavHost，这个类是官方提供的。<br>这个类里面定义了所有我们需要跳转的页面和初始页。<br>然后这个 需要传一个参数，也就是控制器：<br><code> CpNavigation.navHostController = rememberAnimatedNavController()</code><br>这里也是官方提供的remember包装的一个控制器。</p>\n<p>这里的初始页为：<code>  startDestination = ModelPath.Main.route,</code><br>本质上就是一个string，首页的路由。</p>\n<p>这样会默认展示首页，怎么展示首页呢？</p>\n<pre><code class=\"line-numbers language-Kotlin\">composable(ModelPath.Main.route) &#123;\n            MainContent()\n        &#125;\n</code></pre>\n<p>那么这个MainContent就是我们的首页。</p>\n<p>其它composable里面都是首页可能去哪些页面的路由定义。</p>\n<p>那这个比如跳转到设置页面，怎么处理呢？</p>\n<ul>\n<li>首先在这个AnimatedNavHost里面定义一个composable闭包</li>\n</ul>\n<pre><code class=\"line-numbers language-Kotlin\"> composable(ModelPath.Setting.route) &#123;\n            CpSetting(Modifier.fillMaxSize())\n        &#125;\n</code></pre>\n<ul>\n<li>然后再需要跳转的地方调用<br><code>navHostController.navigate(“setting”)</code><br>这个navHostController就是我们之前定义的那个控制器，setting就是路由名称。<br>这样子就可以跳转到设置页面了。</li>\n</ul>\n<h3 id=\"9-主页内部架构框\"><a href=\"#9-主页内部架构框\" class=\"headerlink\" title=\"9.主页内部架构框\"></a>9.主页内部架构框</h3><p>首先看下主页效果图<br><img src=%E9%A6%96%E9%A1%B5.jpeg width=50%><br>轮播图+中间列表+底部bar<br>轮播图+中间列表可以看成一个整体，那就是内容区+底部bar</p>\n<p>架构怎么搭建呢？</p>\n<pre><code class=\"line-numbers language-Kotlin\">   Scaffold(bottomBar = &#123;\n        AnimatedVisibility(\n            visible = bottomSwitch,\n            enter = expandVertically() + fadeIn(), // 操作符重载了，第一个为空，就用第二个\n            exit = shrinkVertically() + fadeOut()  // 操作符重载了，第一个为空，就用第二个\n        ) &#123;\n            // 实际的底部bar 高度使用 固有特性测量 可以参考：https://juejin.cn/post/7068164264363556872\n            MainBottomBar(\n                Modifier\n                    .fillMaxWidth()\n                    .height(IntrinsicSize.Max),pagerState = pagerState) &#123;\n                pagerState.reenableScrolling(coroutineScope, it)\n            &#125;\n        &#125;\n    &#125;) &#123;\n        内容区...\n</code></pre>\n<p>最外层一个Scafffold脚手架包裹，有点像Flutter了啊。<br>然后是一个AnimatedVisibility，这个控制显示隐藏的动画组件。重点看里面的MainBottomBar，就找到了我们的底部bar了。</p>\n<p>这个看起来像自定义的，具体怎么实现的呢？</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * App底部bar\n */\n@OptIn(ExperimentalPagerApi::class)\n@Composable\nprivate fun MainBottomBar(\n    modifier: Modifier = Modifier,\n    pagerState: PagerState,\n    currentChanged: (Int) -&gt; Unit\n) &#123;\n    /**\n     * 这个BottomAppBar是官方的\n     */\n    BottomAppBar(\n        modifier.navigationBarsPadding(),\n        cutoutShape = CircleShape,\n        backgroundColor = HhfTheme.colors.bottomBar,\n        elevation = 5.dp\n    ) &#123;\n        // 遍历4个tab\n        bottomList.forEachIndexed &#123; index, item -&gt;\n            // item单独设置 官方组件\n            BottomNavigationItem(\n                selected = pagerState.currentPage == index, onClick = &#123;\n                    /**\n                     * item点击事件回调给上层\n                     */\n                    currentChanged(index)\n                &#125;, icon = &#123;\n                    /**\n                     * icon为官方组件\n                     */\n                    Icon(\n                        item.dashboardState.icon,\n                        contentDescription = item.name,\n                        tint = if (pagerState.currentPage == index) &#123;\n                            HhfTheme.colors.themeColor\n                        &#125; else &#123;\n                            LocalContentColor.current.copy(alpha = LocalContentAlpha.current)\n                        &#125;, modifier = Modifier.size(24.dp)\n                    )\n                &#125;, label = &#123;\n                    Text(\n                        text = item.name,\n                        color = if (pagerState.currentPage == index) &#123;\n                            HhfTheme.colors.themeColor\n                        &#125; else &#123;\n                            LocalContentColor.current.copy(alpha = LocalContentAlpha.current)\n                        &#125;,\n                        fontSize = 12.sp\n                    )\n                &#125;,\n                unselectedContentColor = LocalContentColor.current.copy(alpha = LocalContentAlpha.current),\n                selectedContentColor = HhfTheme.colors.themeColor,\n                alwaysShowLabel = true\n\n            )\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里看出底部bar就是用了官方的BottomAppBar。<br>里面具体内容是我们开发者自行设定的，这里遍历了bottomList，这个集合就是我们自己定义的一个集合：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * 底部List集合 这里定义了4块\n * 首页，项目，公众号，我的\n */\nval bottomList = listOf(\n    BottomBean(\n        DashboardState.Home,\n        YshhApplication.context.stringResource(R.string.main_title_home)\n    ),\n    BottomBean(\n        DashboardState.Project,\n        YshhApplication.context.stringResource(R.string.main_title_project)\n    ),\n    BottomBean(\n        DashboardState.PubAccount,\n        YshhApplication.context.stringResource(R.string.main_title_account)\n    ),\n    BottomBean(\n        DashboardState.Mine,\n        YshhApplication.context.stringResource(R.string.main_title_mine)\n    )\n)\n</code></pre>\n<p>就这几个模块。</p>\n<p>底部bar的item就是 BottomNavigationitem里面的了，可以看到是一个icon+label构成。有个onClick的参数就是点击事件回调了，这里调用了 回调函数，传递给上层了，传出去的参数就一个int，表示第几页。</p>\n<p>回调到哪里呢？</p>\n<pre><code class=\"line-numbers language-Kotlin\"> // 实际的底部bar 高度使用 固有特性测量 可以参考：https://juejin.cn/post/7068164264363556872\n            MainBottomBar(\n                Modifier\n                    .fillMaxWidth()\n                    .height(IntrinsicSize.Max),pagerState = pagerState) &#123;\n                pagerState.reenableScrolling(coroutineScope, it)\n            &#125;\n</code></pre>\n<p>这里通过调用rememberPagerState这个对象的<code>  pagerState.reenableScrolling(coroutineScope, it)</code>这个方法实现滚动到目标tab下。也就实现了页面切换。<br>最为关键的就是这个pagerState，同步页面数据和底部bar。</p>\n<p>等下分析内容区也会用到。</p>\n<pre><code class=\"line-numbers language-Kotlin\"> // 水平分页\n            HorizontalPager(\n                count = bottomList.size,\n                modifier.weight(1f), pagerState, userScrollEnabled = true\n            ) &#123; page -&gt;\n                when (page) &#123;\n                    // 首页tab\n                    0 -&gt; HomeView(\n                        Modifier\n                            .fillMaxSize()\n                            .background(HhfTheme.colors.background)\n                            .align(Alignment.CenterHorizontally)\n                    )\n                    // 项目tab\n                    1 -&gt; ProjectView(\n                        Modifier\n                            .fillMaxSize()\n                            .align(Alignment.CenterHorizontally)\n                    )\n                    // 公众号tab\n                    2 -&gt; AccountView(\n                        Modifier\n                            .fillMaxSize()\n                            .background(HhfTheme.colors.background)\n                            .align(Alignment.CenterHorizontally)\n                    )\n                    // 我的tab\n                    3 -&gt; &#123;\n//                        if (isLogin) &#123;\n                            Mine(\n                                Modifier\n                                    .fillMaxSize()\n                                    .background(HhfTheme.colors.background)\n                                    .align(Alignment.CenterHorizontally)\n                            )\n//                        &#125; else &#123;\n//                            ErrorBox(\n//                                Modifier.fillMaxSize(),\n//                                title = stringResource(id = R.string.sign_in)\n//                            )\n//                            &#123; CpNavigation.to(ModelPath.Login) &#125;\n//                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n</code></pre>\n<p>这里是中间内容区。通过使用水平分页得以实现。可以看到传入了一个参数，也就是上面底部bar用到的一个pagerState，定义了不同索引下，中间内容区展示的内容。</p>\n<ul>\n<li>首页Tab 对应 HomeView</li>\n<li>项目Tab 对应 ProjectView</li>\n<li>公众号Tab 对应 AccountView</li>\n<li>我的Tab 对应 Mine</li>\n</ul>\n<h3 id=\"10-首页Tab-HomeView\"><a href=\"#10-首页Tab-HomeView\" class=\"headerlink\" title=\"10.首页Tab-HomeView\"></a>10.首页Tab-HomeView</h3><p>首页效果图就是上面的那个效果。<br>这里再拆分下，就是轮播图+列表。<br>对应 HomeView。</p>\n<pre><code class=\"line-numbers language-Kotlin\">@CompoKotlinsable\nfun HomeView(modifier: Modifier = Modifier) &#123;\n    val viewModel: HomeViewModel = viewModel()\n    ColumnTopBarMain(modifier\n        .background(HhfTheme.colors.background),\n        stringResource(R.string.app_name)) &#123;\n        // 内容区域，传入HomeViewModel对象\n        HomeContent(viewModel = viewModel)\n    &#125;\n&#125;\n</code></pre>\n<p>最外层是由顶部bar+内容区构成。</p>\n<p>ColumnTabBarMain是自定义通用的一个App的组件，用于上面展示toolbar，中间区域自定义。</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun ColumnTopBarMain(\n    modifier: Modifier = Modifier,\n    title: String,\n    content: @Composable ColumnScope.() -&gt; Unit\n) &#123;\n    Column(\n        modifier.navigationBarsPadding(),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) &#123;\n        CpTopBar(\n            Modifier.fillMaxWidth(),\n            HhfTheme.colors.themeColor,\n            title = title,\n            actions = &#123;\n                IconButton(onClick = &#123;\n                    CpNavigation.to(ModelPath.Search)\n                &#125;) &#123;\n                    Icon(Icons.Filled.Search, contentDescription = &quot;search&quot;, tint = Color.White)\n                &#125;\n            &#125;,\n        )\n        content.invoke(this)\n    &#125;\n&#125;\n</code></pre>\n<p>这里具体是一个Column+CpTopBar构成</p>\n<p>CpTopBar是这样的：</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n@Composable\nfun CpTopBar(\n    modifier: Modifier = Modifier,\n    backgroundColor: Color = Color.Transparent,\n    title: String,\n    actions: @Composable RowScope.() -&gt; Unit = &#123;&#125;,\n    back: (() -&gt; Unit)? = null\n) &#123;\n    HhTopAppBar(\n        &#123;\n            Text(title, color = Color.White)\n        &#125;,\n        modifier = modifier,\n        backgroundColor = backgroundColor,\n        contentPadding = WindowInsets.statusBars.only(WindowInsetsSides.Horizontal + WindowInsetsSides.Top).asPaddingValues(),\n        navigationIcon = back?.run &#123;\n            &#123;\n                IconButton(\n                    onClick = &#123;\n                        invoke()\n                    &#125;\n                ) &#123;\n                    Icon(Icons.Filled.ArrowBack, contentDescription = &quot;back&quot;, tint = Color.White)\n                &#125;\n            &#125;\n        &#125;,\n        actions = actions,\n        elevation = 2.dp,\n    )\n&#125;\n</code></pre>\n<p>里面还有自定义的HhTopAppBar</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n@Composable\nfun HhTopAppBar(\n    title: @Composable () -&gt; Unit,\n    modifier: Modifier = Modifier,\n    contentPadding: PaddingValues = PaddingValues(0.dp),\n    navigationIcon: @Composable (() -&gt; Unit)? = null,\n    actions: @Composable RowScope.() -&gt; Unit = &#123;&#125;,\n    backgroundColor: Color = MaterialTheme.colors.primarySurface,\n    contentColor: Color = contentColorFor(backgroundColor),\n    elevation: Dp = AppBarDefaults.TopAppBarElevation,\n) &#123;\n    TopAppBarSurface(\n        modifier = modifier,\n        backgroundColor = backgroundColor,\n        contentColor = contentColor,\n        elevation = elevation\n    ) &#123;\n        TopAppBarContent(\n            title = title,\n            navigationIcon = navigationIcon,\n            actions = actions,\n            modifier = Modifier.padding(contentPadding)\n        )\n    &#125;\n&#125;\n</code></pre>\n<p>竟然还有自定义层：Surface是官方提供的了</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun TopAppBarSurface(\n    modifier: Modifier = Modifier,\n    backgroundColor: Color = MaterialTheme.colors.primarySurface,\n    contentColor: Color = contentColorFor(backgroundColor),\n    elevation: Dp = AppBarDefaults.TopAppBarElevation,\n    content: @Composable () -&gt; Unit,\n) &#123;\n    Surface(\n        color = backgroundColor,\n        contentColor = contentColor,\n        elevation = elevation,\n        modifier = modifier,\n        content = content\n    )\n&#125;\n</code></pre>\n<p>还有标题栏内容区： 这个TopAppBar是官方提供的了</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun TopAppBarContent(\n    title: @Composable () -&gt; Unit,\n    modifier: Modifier = Modifier,\n    navigationIcon: @Composable (() -&gt; Unit)? = null,\n    actions: @Composable RowScope.() -&gt; Unit = &#123;&#125;,\n) &#123;\n    TopAppBar(\n        title = title,\n        navigationIcon = navigationIcon,\n        actions = actions,\n        backgroundColor = Color.Transparent,\n        elevation = 0.dp,\n        modifier = modifier\n    )\n&#125;\n</code></pre>\n<p>标题栏看完了，那就到内容区了。</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n/**\n * 首页内容区\n */\n@Composable\nfun HomeContent(modifier: Modifier = Modifier, viewModel: HomeViewModel) &#123;\n\n    /**\n     * list 为首页文章 列表数据；系统会对所有列表项进行组合和布局，无论它们是否可见，\n     * 因此如果您需要显示大量列表项（或长度未知的列表），则使用 Column 等布局可能会导致性能问题。\n     * Compose 提供了一组组件，这些组件只会对在组件视口中可见的列表项进行组合和布局。\n     */\n    val list = viewModel.viewStates.homeList.collectAsLazyPagingItems()\n\n    /**\n     * 下拉刷新组件\n     */\n    SwipeRefresh(\n        /**\n         * 状态，是否正在刷新\n         */\n        state = rememberSwipeRefreshState(viewModel.viewStates.isRefresh),\n        /**\n         * 下拉刷新回调，需要更新轮播+列表\n         */\n        onRefresh = &#123;\n            viewModel.dispatch(HomeAction.GetBanner)\n            list.refresh()\n        &#125;) &#123;\n        // 内容区 使用LazyItem包裹\n        PagingItem(modifier, list = list,\n            errorBlock = &#123;&#125;,\n            successBlock = &#123;&#125;,\n            errorAndSuccessClick = &#123;\n                /**\n                 * 错误后点击回调\n                 */\n                list.refresh()\n            &#125;) &#123;\n            /**\n             * 仅组成和放置 当前可见项 的竖直滚动列表。它允许您放置不同类型的子级内容。\n             * 例如，您可以使用LazyListScope.item添加单个项目，然后使用LazyListScope.items或者LazyListScope.itemsIndexed添加项目列表，后者有当前列表项的索引值。\n             */\n            LazyColumn&#123;\n                /**\n                 * 单个item\n                 */\n                item &#123;\n                    BannerPager(Modifier.height(160.dp), viewModel = viewModel)\n                &#125;\n                /**\n                 * items集合\n                 */\n                items(it) &#123; homeBean -&gt;\n                    homeBean?.apply &#123;\n                        /**\n                         * 首页文字item\n                         */\n                        HomeListItem(homeBean = this) &#123;\n                            /**\n                             * 处理点击收藏图标 触发viewModel层调用接口\n                             */\n                            if(CacheUtils.isLogin)&#123;\n                                viewModel.dispatch(HomeAction.Collect(homeBean.id, it))\n                            &#125;\n                            else&#123;\n                                CpNavigation.to(ModelPath.Login)\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>list 是专门用于懒加载列表，这个是存放可视区的列表。</p>\n<p>数据来源是ViewModel层的viewStates实例。</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * 首页状态，包装首页需要的数据\n */\ndata class HomeState(\n    /**\n     * 是否正在刷新\n     */\n    val isRefresh : Boolean = false,\n\n    /**\n     * 轮播列表，数据源\n     */\n    val bannerList: List&lt;BannerResponse&gt; = listOf(),\n\n    /**\n     * 首页数据\n     */\n    val homeList: Flow&lt;PagingData&lt;ArticleBean&gt;&gt; = Pager(\n        PagingConfig(PAGE_SIZE),\n        pagingSourceFactory = &#123; HomeSource() &#125;).flow,\n)\n</code></pre>\n<p>这个是存放到ViewModel层的首页动态数据。</p>\n<pre><code class=\"line-numbers language-Kotlin\"> // 首页数据监听 通过 mutableStateOf包装 HomeState\n    var viewStates by mutableStateOf(\n        HomeState(\n            homeList = Pager(\n                PagingConfig(PAGE_SIZE),\n                pagingSourceFactory = &#123; HomeSource() &#125;).flow.cachedIn(viewModelScope)))\n        private set\n</code></pre>\n<p>这里用一个mutableStateof包装下。</p>\n<p>下面继续回到首页内容区：<br>然后是一个SwipeRefresh组件,官方提供的。</p>\n<pre><code class=\"line-numbers language-Kotlin\">    SwipeRefresh(\n        /**\n         * 状态，是否正在刷新\n         */\n        state = rememberSwipeRefreshState(viewModel.viewStates.isRefresh),\n        /**\n         * 下拉刷新回调，需要更新轮播+列表\n         */\n        onRefresh = &#123;\n            viewModel.dispatch(HomeAction.GetBanner)\n            list.refresh()\n        &#125;) &#123;\n</code></pre>\n<p>定义好下拉刷新触发事件。<br>注意这个list，实际上走的是LazyPagingItems里面的一个refresh方法。<br>我们在HomeState中定义的homeList是一个Flow包装列表集合。通过调用Flow中扩展的一个collectAsLazyPagingItems函数，就变成LazyPagingItems对象了。</p>\n<p>这个list我们放在PagingItem里面。</p>\n<p>然后首页内容区里面用了一个 LazyColumn，应该也是配合懒加载和复用官方实现的一个类。<br>然后里面第一个item就是我们的轮播图了。</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * 顶部轮播图\n */\n@OptIn(ExperimentalPagerApi::class)\n@Composable\nfun BannerPager(modifier: Modifier = Modifier, viewModel: HomeViewModel) &#123;\n    val pagerState = rememberPagerState()\n\n    /**\n     * 开启协程 内部的闭包是协程 目的是获取轮播图数据\n     */\n    LaunchedEffect(viewModel)&#123;\n        viewModel.dispatch(HomeAction.GetBanner)\n    &#125;\n\n    /**\n     * 如需了解来自父项的约束条件并相应地设计布局，您可以使用 BoxWithConstraints。\n     * 就是外部传过来的modifier 决定子View 空间\n     */\n    BoxWithConstraints(modifier) &#123;\n\n        /**\n         * 水平分页\n         */\n        HorizontalPager(\n            count = viewModel.viewStates.bannerList.size, // 轮播总数\n            state = pagerState // 轮播状态\n        ) &#123; page -&gt;\n            //  页面索引\n            when (page) &#123;\n                viewModel.viewStates.bannerList[page].id -&gt; &#123;\n                    /**\n                     * 轮播图item\n                     */\n                    BannerItem(\n                        Modifier\n                            .height(maxHeight)\n                            .fillMaxWidth(), viewModel.viewStates.bannerList[page]\n                    )\n                &#125;\n            &#125;\n        &#125;\n\n        /**\n         * 轮播指示器\n         */\n        if (viewModel.viewStates.bannerList.isNotEmpty()) &#123;\n            BannerIndicator(\n                Modifier\n                    .align(Alignment.BottomCenter)\n                    .fillMaxWidth()\n                    .background(Color.Black.copy(0.2f))\n                    .padding(8.dp),viewModel, pagerState )\n        &#125;\n\n\n    &#125;\n&#125;\n</code></pre>\n<p>这个轮播图里面开了个协程去获取轮播图数据，只会走一次。<br>然后一个水平分页里面存放所有轮播图，轮播item为BannerItem,这个是自定义的</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun BannerItem(modifier: Modifier = Modifier, data: BannerResponse) &#123;\n    data.apply &#123;\n        Box(modifier.clickable &#123;\n            /**\n             * 点击图片，触发跳转WebView，通过bundle传递数据\n             */\n            CpNavigation.toBundle(ModelPath.WebView, Bundle().apply &#123;\n                putString(webTitle, data.title)\n                putString(webUrl, data.url)\n                putBoolean(webIsCollect, false)\n                putInt(webCollectId, data.id)\n                putInt(webCollectType, 1)\n            &#125;)\n        &#125;) &#123;\n            /**\n             * 自定义网络图片\n             */\n            NetworkImage(\n                imagePath,\n                Modifier.fillMaxWidth(),\n                contentScale = ContentScale.FillBounds,\n                defaultImg = R.mipmap.ic_default_round\n            )\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>轮播完了，就是文章item了。<br>主要是为了实现这种效果<br><img src=\"/./%E7%8E%A9Android-Compose%E7%89%88%E6%9C%AC-%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90/home_item.jpeg\"></p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n   * items集合\n   */\nitems(it) &#123; homeBean -&gt;\n    homeBean?.apply &#123;\n        /**\n        * 首页文字item\n        */\n        HomeListItem(homeBean = this) &#123;\n            /**\n            * 处理点击收藏图标 触发viewModel层调用接口\n            */\n            if(CacheUtils.isLogin)&#123;\n                viewModel.dispatch(HomeAction.Collect(homeBean.id, it))\n            &#125;\n            else&#123;\n                CpNavigation.to(ModelPath.Login)\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里用了items，然后遍历了 list,每个item对应一个 HomeListItem<br>这里定义了一个函数，说明了点击收藏图标后的逻辑。</p>\n<pre><code class=\"line-numbers language-Kotlin\">  /**\n     * 是否收藏了，用remember包装一下bool值\n     */\n    var isCollect by remember&#123; mutableStateOf(homeBean.collect)&#125;\n\n    /**\n     * 卡片布局\n     */\n    Card(\n        modifier\n            .padding(8.dp) // 内padding 8个dp\n            .clickable &#123;\n                /**\n                 * 卡片点击事件，触发跳转webView\n                 */\n                CpNavigation.toBundle(ModelPath.WebView, Bundle().apply &#123;\n                    putString(webTitle, homeBean.title)\n                    putString(webUrl, homeBean.link)\n                    putBoolean(webIsCollect, isCollect)\n                    putInt(webCollectId, homeBean.id)\n                    putInt(webCollectType, 0)\n                &#125;)\n            &#125;,\n        backgroundColor = HhfTheme.colors.listItem,\n        elevation = 5.dp\n    ) &#123;\n</code></pre>\n<p>这里外层是用了Card,定义了点击item的逻辑。</p>\n<p>里面是这样的：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> Column(Modifier.padding(8.dp)) &#123;\n                /**\n                 * 第一行 水平布局\n                 */\n                Row(verticalAlignment = Alignment.CenterVertically) &#123;\n                    /**\n                     * 分享者没名字\n                     */\n                    Text(\n                        text = if (author.isNotEmpty()) author else shareUser,\n                        fontSize = 13.sp,\n                        color = HhfTheme.colors.textColor\n                    )\n                    /**\n                     * 显示标签\n                     */\n                    if(isShowLabel)&#123;\n                        if (type == 1) &#123;\n                            Box(\n                                Modifier\n                                    .padding(start = 6.dp)\n                                    .border(1.dp, Color.Red, RoundedCornerShape(5.dp))\n                                    .padding(4.dp)\n                            ) &#123;\n                                Text(stringResource(id = R.string.istop), Modifier, Color.Red, 10.sp)\n                            &#125;\n                        &#125;\n                        if (fresh) &#123;\n                            Box(\n                                Modifier\n                                    .padding(start = 6.dp)\n                                    .border(1.dp, Color.Red, RoundedCornerShape(5.dp))\n                                    .padding(4.dp)\n                            ) &#123;\n                                Text(stringResource(id = R.string.neww), Modifier, Color.Red, 10.sp)\n                            &#125;\n                        &#125;\n                        if (tags.isNotEmpty()) &#123;\n                            Box(\n                                Modifier\n                                    .padding(start = 6.dp)\n                                    .border(1.dp, Color(0xFF66BB6A), RoundedCornerShape(5.dp))\n                                    .padding(4.dp)\n                            ) &#123;\n                                Text(tags[0].name, Modifier, Color(0xFF66BB6A), 10.sp)\n                            &#125;\n                        &#125;\n                    &#125;\n                    /**\n                     * 发布日期\n                     */\n                    Text(\n                        niceDate,\n                        Modifier\n                            .weight(1f)\n                            .wrapContentWidth(\n                                Alignment.End\n                            )\n                            .align(Alignment.CenterVertically),\n                        HhfTheme.colors.textColor.copy(0.6f),\n                        fontSize = 13.sp,\n                    )\n                &#125;\n                /**\n                 * 有没有封面图\n                 */\n                if (TextUtils.isEmpty(envelopePic)) &#123;\n                    // 没有封面图\n                    Text(\n                        title.filterHtml(),\n                        Modifier.padding(top = 12.dp),\n                        HhfTheme.colors.textColor,\n                        fontSize = 14.sp,\n                        fontWeight = FontWeight.Bold\n                    )\n                &#125; else &#123;\n                    // 有封面图时，中间区域展示\n                    Row(Modifier.padding(top = 12.dp)) &#123;\n                        // 网络图片\n                        NetworkImage(\n                            envelopePic,\n                            Modifier.size(100.dp),\n                            contentScale = ContentScale.Crop,\n                            defaultImg = R.mipmap.ic_default_round\n                        )\n                        // 垂直布局\n                        Column(Modifier.padding(start = 8.dp)) &#123;\n                            // 标题\n                            Text(\n                                title.filterHtml(),\n                                color = HhfTheme.colors.textColor,\n                                fontSize = 14.sp,\n                                maxLines = 3,\n                                style = TextStyle(fontWeight = FontWeight.Bold)\n                            )\n                            // 摘要描述\n                            Text(\n                                desc,\n                                color = HhfTheme.colors.textInactiveColor,\n                                fontSize = 13.sp,\n                                maxLines = 3,\n                                overflow = TextOverflow.Ellipsis\n                            )\n                        &#125;\n                    &#125;\n                &#125;\n                // 底部水平布局\n                Row &#123;\n                    // 文本\n                    Text(\n                        &quot;$superChapterName / $chapterName&quot;,\n                        Modifier.padding(top = 12.dp),\n                        HhfTheme.colors.textColor,\n                        fontSize = 13.sp\n                    )\n                    // 图标，是否收藏了\n                    Icon(\n                        if(isCollect) Icons.Filled.Favorite else Icons.Filled.FavoriteBorder, contentDescription = &quot;&quot;,\n                        Modifier\n                            .wrapContentWidth(\n                                Alignment.End\n                            )\n                            .weight(1f)\n                            .clickable &#123;\n                                /**\n                                 * 点击收藏，触发请求\n                                 */\n                                favoriteAction(isCollect)\n                                isCollect = !isCollect\n                            &#125;,\n                        tint = HhfTheme.colors.themeColor\n                    )\n                &#125;\n            &#125;\n</code></pre>\n<h3 id=\"11-我的Tab-Mine\"><a href=\"#11-我的Tab-Mine\" class=\"headerlink\" title=\"11.我的Tab-Mine\"></a>11.我的Tab-Mine</h3><p>因为项目和公众号和首页基本一样，这里就不重复分析了。<br>看下我的页面的效果图：<br><img src=mine.jpeg width=50%><br>要实现这样的效果，怎么处理呢？</p>\n<p>首先开启一个协程，获取用户sp数据，转成UserInfo对象</p>\n<pre><code class=\"line-numbers language-Kotlin\">   /**\n     * 开启协程，只走一次\n     */\n    LaunchedEffect(CacheUtils.userInfo) &#123;\n        if (CacheUtils.userInfo != &quot;&quot;) &#123;\n            /**\n             * 根据sp文件，生产一个UserInfo对象，设置给这个我的页面使用\n             */\n            mineViewModel.dispatch(\n                MineViewEvent.SetUserInfo(\n                    Gson().fromJson(\n                        CacheUtils.userInfo, // sp文件\n                        UserInfo::class.java\n                    )\n                )\n            )\n            /**\n             * 获取积分和排名\n             */\n            mineViewModel.dispatch(MineViewEvent.GetIntegral)\n        &#125;\n    &#125;\n</code></pre>\n<p>这里获取积分和排名是需要走接口的<br>这里会走到ViewModel层这个函数：</p>\n<pre><code class=\"line-numbers language-Kotlin\">    private fun getIntegral() &#123;\n        viewModelScope.launch &#123;\n            flow &#123;\n                emit(\n                    TaskApi.create(ApiService::class.java).getIntegral()\n                )\n            &#125;.map &#123;\n                if (it.errorCode == 0) &#123;\n                    it.data\n                        ?: throw Exception(&quot;data null&quot;)\n                &#125; else &#123;\n                    throw Exception(it.errorMsg)\n                &#125;\n            &#125;.onEach &#123;\n                viewStates = viewStates.copy(integral = it)\n            &#125;.catch &#123;\n                viewStates = viewStates.copy(integral = null)\n            &#125;.collect()\n        &#125;\n    &#125;\n</code></pre>\n<p>这个retrofit中是这样定义的：</p>\n<pre><code class=\"line-numbers language-Kotlin\">interface ApiService &#123;\n    /**\n     * 获取当前账户的个人积分\n     */\n    @GET(&quot;lg/coin/userinfo/json&quot;)\n    suspend fun getIntegral(): ApiResponse&lt;Integral&gt;\n</code></pre>\n<p>这个就是一个suspend挂起函数。</p>\n<p>顶层为Column:</p>\n<pre><code class=\"line-numbers language-Kotlin\">    /**\n     * 顶层为列表视图\n     */\n    Column(modifier) &#123;\n        /**\n         * 顶部👤\n         */\n        MineTopAvatar(\n            Modifier\n                .fillMaxWidth()\n                .height(320.dp)\n                .clip(QureytoImageShapes(160f)),\n            mineViewModel.viewStates.userInfo?.run &#123;\n                nickname\n            &#125; ?: &quot;avatar&quot;\n        ) &#123;\n</code></pre>\n<p>头像区域，点击后可以弹pop，但是需要先获取权限，这样获取：</p>\n<pre><code class=\"line-numbers language-Kotlin\">// 图片点击事件 会去申请下权限\n            XXPermissions\n                .with(context)\n                .permission(Permission.CAMERA)\n                .permission(Permission.MANAGE_EXTERNAL_STORAGE)\n                .request(object : OnPermissionCallback &#123;\n                    override fun onGranted(\n                        granted: List&lt;String&gt;,\n                        all: Boolean\n                    ) &#123;\n                        if (all) &#123;\n                            if(isLogin)&#123;\n                                mineViewModel.dispatch(MineViewEvent.ChangePopupState(true))\n                            &#125;\n                            else&#123;\n                                CpNavigation.to(ModelPath.Login)\n                            &#125;\n                        &#125;\n                    &#125;\n\n                    override fun onDenied(\n                        denied: List&lt;String&gt;,\n                        never: Boolean\n                    ) &#123;\n                        if (never) &#123;\n                            context.showToast(context.stringResource(R.string.permissions_cm_error))\n                            XXPermissions.startPermissionActivity(\n                                context,\n                                denied\n                            )\n                        &#125; else &#123;\n                            context.showToast(context.stringResource(R.string.permissions_camera_error))\n                        &#125;\n                    &#125;\n                &#125;)\n</code></pre>\n<p>用了一个三方库实现。</p>\n<p>中间操作栏这样实现：</p>\n<pre><code class=\"line-numbers language-Kotlin\">  // 操作栏 有个外边框，包裹菜单项，底部有阴影\n        Surface(\n            Modifier\n                .padding(start = 20.dp, end = 20.dp)\n                .fillMaxWidth()\n                .background(HhfTheme.colors.background),\n            elevation = 2.dp,\n            shape = RoundedCornerShape(8.dp),\n            color = MaterialTheme.colors.surface, // color will be adjusted for elevation\n        ) &#123;\n</code></pre>\n<p>具体的菜单项也是用懒加载实现：</p>\n<pre><code class=\"line-numbers language-Kotlin\">LazyColumn(Modifier.background(HhfTheme.colors.listItem)) &#123;\n                itemsIndexed(list) &#123; i, bean -&gt;\n\n                    /**\n                     * 我的页面遍历菜单项\n                     */\n                    MineItem(\n                        Modifier\n                            .fillMaxWidth()\n                            .clickable &#123;\n                                /**\n                                 * 分发开发者行为\n                                 */\n                                mineViewModel.dispatch(MineViewEvent.ToComposable(bean.id))\n                            &#125;\n                            .height(45.dp), bean.name, HhfTheme.colors.themeColor,\n                        bean.icon)\n                    if (i &lt; list.size - 1) &#123;\n                        /**\n                         * 非最后一行显示分割线\n                         */\n                        Divider(\n                            modifier = Modifier\n                                .fillMaxWidth()\n                                .padding(start = 10.dp, end = 10.dp)\n                        )\n                    &#125;\n                &#125;\n            &#125;\n</code></pre>\n<p>具体的菜单item,有图标+文字+右侧箭头实现：</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n@Composable\nfun MineItem(\n    modifier: Modifier = Modifier, textName: String, iconColor: Color, icon: ImageVector\n) &#123;\n    Row(\n        modifier,\n        verticalAlignment = Alignment.CenterVertically,\n    ) &#123;\n        Icon(\n            icon, &quot;$textName icon&quot;,\n            Modifier\n                .size(28.dp)\n                .padding(start = 10.dp), iconColor\n        )\n        Text(\n            textName,\n            Modifier.padding(start = 10.dp),\n            fontSize = 14.sp,\n            fontFamily = FontFamily.Serif,\n            color = HhfTheme.colors.textColor\n        )\n        Icon(\n            Icons.Filled.KeyboardArrowRight, textName,\n            Modifier\n                .weight(1f)\n                .padding(end = 10.dp)\n                .wrapContentWidth(Alignment.End),\n            tint = HhfTheme.colors.textColor\n        )\n    &#125;\n&#125;\n</code></pre>\n<p>UI搞定了，跳转逻辑怎么处理呢？<br>答案是viewModel层实现。</p>\n<p>这里有个clickable点击闭包：<br><code> mineViewModel.dispatch(MineViewEvent.ToComposable(bean.id))</code></p>\n<p>会委托给mineViewModel处理：</p>\n<pre><code class=\"line-numbers language-Kotlin\">    /**\n     * 分发开发者行为\n     */\n    fun dispatch(action: MineViewEvent) &#123;\n        when (action) &#123;\n            is MineViewEvent.Blur -&gt; bitmapBlur(action.s)\n            /**\n             * 用户点击菜单项\n             */\n            is MineViewEvent.ToComposable -&gt; toComposable(action.type)\n            is MineViewEvent.ChangePopupState -&gt; &#123;\n                Log.e(&quot;TEST##&quot;, &quot;这里触发了viewStates中 isShowpopup 变更为：$&#123;action.flag&#125;&quot;)\n                viewStates = viewStates.copy(isShowPopup = action.flag)\n            &#125;\n            is MineViewEvent.SetUserInfo -&gt; viewStates = viewStates.copy(userInfo = action.userInfo)\n            is MineViewEvent.GetIntegral -&gt; getIntegral()\n        &#125;\n    &#125;\n</code></pre>\n<p>这里分发开发者行为，其实更像用户行为，有可能不是用户触发，所以我这里称之为开发者行为。</p>\n<p>点击菜单项继续分发：</p>\n<pre><code class=\"line-numbers language-Kotlin\">private fun toComposable(type: Int) &#123;\n        if(isLogin)&#123;\n            when (type) &#123;\n                0 -&gt; CpNavigation.to(ModelPath.Integral)\n                1 -&gt; CpNavigation.to(ModelPath.Collect)\n                2 -&gt; CpNavigation.to(ModelPath.Share)\n                3 -&gt; CpNavigation.to(ModelPath.Todo)\n                4 -&gt; CpNavigation.toBundle(ModelPath.WebView, Bundle().apply &#123;\n                    putString(webTitle, &quot;PlayAndroid&quot;)\n                    putString(webUrl, &quot;https://github.com/yellowhai/PlayAndroid&quot;)\n                    putBoolean(webIsCollect, false)\n                    putInt(webCollectId, 998)\n                    putInt(webCollectType, 1)\n                &#125;)\n                5 -&gt; CpNavigation.to(ModelPath.Setting)\n            &#125;\n        &#125;\n        else&#123;\n            when (type) &#123;\n                4 -&gt; CpNavigation.toBundle(ModelPath.WebView, Bundle().apply &#123;\n                    putString(webTitle, &quot;PlayAndroid&quot;)\n                    putString(webUrl, &quot;https://github.com/yellowhai/PlayAndroid&quot;)\n                    putBoolean(webIsCollect, false)\n                    putInt(webCollectId, 998)\n                    putInt(webCollectType, 1)\n                &#125;)\n                5 -&gt; CpNavigation.to(ModelPath.Setting)\n                else -&gt; CpNavigation.to(ModelPath.Login)\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>这里定义了跳转逻辑，这里有回到 第8点主页外部架构 中的导航定义了。<br>实现跳转到其它页面了，这更像是在布局上叠加，不算是跳转吧。</p>\n<p>这个项目还有很多细节值得一探究竟，不过对于初始compose，也差不多了，了解到这个程度也算入门了吧。</p>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<blockquote>\n<p>玩Android(compose版本)项目地址：<a href=\"https://github.com/yellowhai/PlayAndroid\">https://github.com/yellowhai/PlayAndroid</a></p>\n</blockquote>\n<h3 id=\"1-项目settings-gradle\"><a href=\"#1-项目settings-gradle\" class=\"headerlink\" title=\"1.项目settings.gradle\"></a>1.项目settings.gradle</h3><pre><code class=\"line-numbers language-groovy\">dependencyResolutionManagement &#123;\n    /**\n     * 原文中说默认情况下，项目中的存储库会覆盖设置中的存储库 ，可以通过设置模式来更改这种行为\n     设置存储库的方法：\n     repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n     存储库模式：\n     PREFER_PROJECT(true)--首选项目存储库\n     PREFER_SETTINGS(false)--首选设置存储库\n     FAIL_ON_PROJECT_REPOS(false)--强制设置存储库\n     */\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories &#123;\n        google()\n        mavenCentral()\n        maven &#123; url &quot;https://jitpack.io&quot; &#125;\n        maven &#123;\n            url &#39;https://maven.aliyun.com/repository/public/&#39;\n        &#125;\n        maven &#123; url &#39;https://maven.aliyun.com/repository/public&#39; &#125;\n        maven &#123; url &#39;https://maven.aliyun.com/repository/central&#39; &#125;\n        maven &#123; url &#39;https://maven.aliyun.com/repository/google&#39; &#125;\n        maven &#123; url &#39;https://maven.aliyun.com/repository/public&#39; &#125;\n        maven &#123; url &#39;https://maven.aliyun.com/repository/gradle-plugin&#39; &#125;\n    &#125;\n&#125;\nrootProject.name = &quot;PlayAndroid&quot;\ninclude &#39;:app&#39;\ninclude &#39;:common&#39;\ninclude &#39;:h_mine&#39;\ninclude &#39;:toolkit&#39;\n</code></pre>\n<p>还是很容易理解的，repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)这个是新增的，简单看下就行。<br>引入了app模块(主模块)，common模块（通用模块，用于通用组件相关）,h_mine模块（我的模块，可以单独编译）。</p>\n<h3 id=\"2-config-gradle\"><a href=\"#2-config-gradle\" class=\"headerlink\" title=\"2.config.gradle\"></a>2.config.gradle</h3><p>这个文件相信大家都有用过的，配置远程依赖的一个文件，统一管理。</p>\n<pre><code class=\"line-numbers language-groovy\">ext&#123;\n    isRelease = true\n\n    //android构建配置\n    android_models = [\n            compileSdk : 32,\n            minSdk : 23,\n            targetSdk : 32,\n            versionCode : 1,\n            versionName : &quot;1.0&quot;\n    ]\n    \n    app_id = [\n            mine      : &#39;com.hh.mine&#39;,\n    ]\n\n    core_ktx_version = &#39;1.7.0&#39;\n    appcompat_version = &#39;1.4.0&#39;\n    lifecycle_version = &#39;2.4.0&#39;\n    material_version = &#39;1.4.0&#39;\n    work_version = &#39;2.7.1&#39;\n    gson_version = &#39;2.8.9&#39;\n    litepal_version = &#39;3.2.3&#39;\n    landscapist_version = &#39;1.4.5&#39;\n    retrofit_version = &#39;2.9.0&#39;\n    okhttp_version = &#39;4.9.3&#39;\n    startup_version = &#39;1.1.0&#39;\n    XXPermissions_version = &#39;13.2&#39;\n    datastore_version = &#39;1.0.0&#39;\n    materialDialog_version = &#39;0.6.2&#39;\n    accompanist_version = &#39;0.25.0&#39;\n\n\n    jetpack_compose = [\n            material : &quot;androidx.compose.material:material:$compose_version&quot;,\n            activity : &quot;androidx.activity:activity-compose:$appcompat_version&quot;,\n    ]\n\n    commonApi = [\n            ktx_core        : &quot;androidx.core:core-ktx:$core_ktx_version&quot;,\n            lifecycle       : &quot;androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version&quot;,\n            appcompat       : &quot;androidx.appcompat:appcompat:$appcompat_version&quot;,\n            material        : &quot;com.google.android.material:material:$material_version&quot;,\n            //数据存储\n            datastore       : &quot;androidx.datastore:datastore-preferences:$datastore_version&quot;,\n            //权限处理\n            XXPermissions   : &quot;com.github.getActivity:XXPermissions:$XXPermissions_version&quot;,\n    ]\n\n    net = [\n            retrofit    : &quot;com.squareup.retrofit2:retrofit:$retrofit_version&quot;,\n            converter   : &quot;com.squareup.retrofit2:converter-gson:$retrofit_version&quot;,\n            okhttp      : &quot;com.squareup.okhttp3:logging-interceptor:$okhttp_version&quot;,\n            gson        : &quot;com.google.code.gson:gson:$gson_version&quot;\n    ]\n\n    accompanist_ui = [\n            insets_ui    : &quot;com.google.accompanist:accompanist-insets-ui:$accompanist_version&quot;,\n            navigation   : &quot;com.google.accompanist:accompanist-navigation-animation:$accompanist_version&quot;,\n            pager        : &quot;com.google.accompanist:accompanist-pager:$accompanist_version&quot;,\n            swiperefresh : &quot;com.google.accompanist:accompanist-swiperefresh:$accompanist_version&quot;,\n            flowlayout   : &quot;com.google.accompanist:accompanist-flowlayout:$accompanist_version&quot;,\n            systemUi     : &quot;com.google.accompanist:accompanist-systemuicontroller:$accompanist_version&quot;,\n            webview      : &quot;com.google.accompanist:accompanist-webview:$accompanist_version&quot;\n    ]\n\n    database =[\n            litepal :  &quot;org.litepal.guolindev:core:$litepal_version&quot;\n    ]\n\n    skydoves_coil = [\n            landscapist_coil :  &quot;com.github.skydoves:landscapist-coil:$landscapist_version&quot;\n    ]\n\n    workManager = [\n            // Kotlin + coroutines\n            work = &quot;androidx.work:work-runtime-ktx:$work_version&quot;\n    ]\n\n    material_dialog = [\n            color : &quot;io.github.vanpra.compose-material-dialogs:color:$materialDialog_version&quot;,\n            core  : &quot;io.github.vanpra.compose-material-dialogs:core:$materialDialog_version&quot;,\n            datetime  : &quot;io.github.vanpra.compose-material-dialogs:datetime:$materialDialog_version&quot;\n    ]\n\n    paging = &quot;androidx.paging:paging-compose:1.0.0-alpha14&quot;\n\n    jetpackComposeLibs = jetpack_compose.values()\n    commonApiLibs = commonApi.values()\n    netLibs = net.values()\n    materialDialogLibs = material_dialog.values()\n&#125;\n</code></pre>\n<p>层次还是比较清晰，对于同一组单独建立数组存储，模块中只需要引入一个就将这组全部引入进去了。</p>\n<h3 id=\"3-app模块下的build-gradle\"><a href=\"#3-app模块下的build-gradle\" class=\"headerlink\" title=\"3.app模块下的build.gradle\"></a>3.app模块下的build.gradle</h3><p>显示引入com.android.application+kotlin-android的插件。<br>下面配置android闭包，很简单。</p>\n<p>其它关于compose的也需要配置下：</p>\n<pre><code class=\"line-numbers language-groovy\"> compileOptions &#123;\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    &#125;\n    buildFeatures &#123;\n        compose true\n    &#125;\n    composeOptions &#123;\n        kotlinCompilerExtensionVersion compose_version\n        kotlinCompilerVersion kotlin_version\n    &#125;\n</code></pre>\n<p>然后是远程依赖：</p>\n<pre><code class=\"line-numbers language-groovy\">dependencies &#123;\n    // 如果是release模式，就把我的模块加进来\n    if(isRelease)&#123;\n        implementation project(&#39;:h_mine&#39;)\n    &#125;\n\n    // 初始化组件\n    implementation &quot;androidx.startup:startup-runtime:$startup_version&quot;\n    implementation project(&#39;:common&#39;)\n\n    // 测试相关\n    testImplementation &#39;junit:junit:4.13.2&#39;\n    androidTestImplementation &#39;androidx.test.ext:junit:1.1.3&#39;\n    androidTestImplementation &#39;androidx.test.espresso:espresso-core:3.4.0&#39;\n    androidTestImplementation &quot;androidx.compose.ui:ui-test-junit4:$compose_version&quot;\n    androidTestImplementation &quot;androidx.compose.ui:ui-test-junit4:$compose_version&quot;\n    debugImplementation &quot;androidx.compose.ui:ui-tooling:$compose_version&quot;\n\n&#125;\n</code></pre>\n<p>isRelease定义在 config.gradle的顶部。如果是集成编译就为true，单独编译为false。</p>\n<h3 id=\"4-app模块的AndroidManifest-xml\"><a href=\"#4-app模块的AndroidManifest-xml\" class=\"headerlink\" title=\"4.app模块的AndroidManifest.xml\"></a>4.app模块的AndroidManifest.xml</h3><ul>\n<li>配置Application</li>\n<li>配置主页</li>\n<li>配置provider，用于初始化sdk<pre><code class=\"line-numbers language-xml\">  &lt;!--  用provider初始化sdk--&gt;\n    &lt;provider\n        android:name=&quot;androidx.startup.InitializationProvider&quot;\n        android:authorities=&quot;$&#123;applicationId&#125;.androidx-startup&quot;\n        android:exported=&quot;false&quot;\n        tools:node=&quot;merge&quot;&gt;\n        &lt;meta-data\n            android:name=&quot;com.hh.playandroid.base.BaseInitializer&quot;\n            android:value=&quot;androidx.startup&quot; /&gt;\n    &lt;/provider&gt;\n</code></pre>\n</li>\n</ul>\n<h3 id=\"5-自定义Application\"><a href=\"#5-自定义Application\" class=\"headerlink\" title=\"5.自定义Application\"></a>5.自定义Application</h3><pre><code>class HhfApp : YshhApplication()\n</code></pre>\n<p> 依赖common模块：</p>\n<pre><code class=\"line-numbers language-Kotlin\">open class YshhApplication : Application() &#123;\n\n   lateinit var okbuilder: OkHttpClient\n\n   companion object &#123;\n       /**\n        * application context.\n        */\n       @SuppressLint(&quot;StaticFieldLeak&quot;)\n       lateinit var context: Context\n\n       @SuppressLint(&quot;StaticFieldLeak&quot;)\n       lateinit var instance: YshhApplication\n\n       /**\n        * application级别的协程\n        * 有时我们需要在协程上下文中定义多个元素，组合协程上下文中的元素，使用 + 操作符来创建 CoroutineScope .\n        */\n       val applicationScope = CoroutineScope(SupervisorJob() + Dispatchers.Main)\n   &#125;\n</code></pre>\n<p> 这里懒加载OkHttpClient<br> 定义了全局的协程，静态变量。</p>\n<pre><code class=\"line-numbers language-Kotlin\">  override fun onCreate() &#123;\n       super.onCreate()\n       context = applicationContext\n       instance = this\n       initRetrofit()\n   &#125;\n</code></pre>\n<p> 初始化Retrofit：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n    * 初始化Retrofit\n    */\n   private fun initRetrofit(token : String = &quot;&quot;): OkHttpClient &#123;\n       //请求头\n       val headerInterceptor = Interceptor &#123; chain: Interceptor.Chain -&gt;\n           val orignaRequest = chain.request()\n           val request = orignaRequest.newBuilder()\n               .header(&quot;Authorization&quot;, &quot;Bearer $token&quot;)\n               .method(orignaRequest.method, orignaRequest.body)\n               .build()\n           chain.proceed(request)\n       &#125;\n       val logInterceptor = LogInterceptor &#123;\n//            it.logE()\n       &#125;\n       // 日志类别\n       logInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);\n       // 缓存相关\n       val cacheFile =\n           File(getExternalFilesDir(Environment.DIRECTORY_PICTURES).toString() + &quot;http_cache&quot;)\n       val cache = Cache(cacheFile, 104857600L) // 指定缓存大小100Mb\n       val builder = OkHttpClient.Builder()\n       //        builder.addInterceptor(addQueryParameterInterceptor);\n       builder.addInterceptor(headerInterceptor)\n       builder.cache(cache)\n       builder.addNetworkInterceptor(logInterceptor)\n       builder.cookieJar(cookieJar)\n       builder.readTimeout(60000, TimeUnit.MILLISECONDS)\n       //全局的写入超时时间60s\n       builder.writeTimeout(60000, TimeUnit.MILLISECONDS)\n       //全局的连接超时时间30s\n       builder.connectTimeout(30000, TimeUnit.MILLISECONDS)\n       okbuilder = builder.build()\n       return builder.build()\n   &#125;\n\n   private val cookieJar: PersistentCookieJar by lazy &#123;\n       PersistentCookieJar(SetCookieCache(), SharedPrefsCookiePersistor(context))\n   &#125;\n   \n   fun getOkBuilder(): OkHttpClient &#123;\n       return okbuilder\n   &#125;\n</code></pre>\n<h3 id=\"6-首页-MainActivity\"><a href=\"#6-首页-MainActivity\" class=\"headerlink\" title=\"6.首页 MainActivity\"></a>6.首页 MainActivity</h3><p> 继承BaseActivity:</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n/**\n* 基类Activity 设置非沉浸式，因为要设置导航栏和状态栏颜色\n*/\nabstract class BaseActivity : AppCompatActivity() &#123;\n\n   override fun onCreate(savedInstanceState: Bundle?) &#123;\n       super.onCreate(savedInstanceState)\n       WindowCompat.setDecorFitsSystemWindows(window, false)\n   &#125;\n\n&#125;\n</code></pre>\n<p>onCreate生命周期：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> @Suppress(&quot;DEPRECATED_IDENTITY_EQUALS&quot;)\n    @OptIn(ExperimentalAnimationApi::class)\n    override fun onCreate(savedInstanceState: Bundle?) &#123;\n        super.onCreate(savedInstanceState)\n        // 动画渐变\n        overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out)\n        // 设置内容\n        setContent &#123;\n            Log.e(&quot;TEST##&quot;, &quot;开始setContent了&quot;)\n            // 顶层为自定义主题\n            HhfTheme(\n                // 是否暗色或亮色，跟随系统，如果用户主动设置，跟随用户\n                theme = if (isSystemInDarkTheme() || isNight) HhfTheme.Theme.Dark else HhfTheme.Theme.Light,\n                // 用户自行设置的颜色主题\n                colorTheme = appTheme\n            ) &#123;\n                // 创建一个MainViewModel\n                val viewModel : MainViewModel = viewModel()\n\n                // 如果isSplash为true,就展示SplashView 启动页\n                if (viewModel.isSplash) &#123;\n                    Log.e(&quot;TEST##&quot;, &quot;加载闪屏了&quot;)\n                    SplashView &#123; viewModel.isSplash = false &#125;\n                &#125; else &#123;\n                    Log.e(&quot;TEST##&quot;, &quot;加载首页了&quot;)\n                    // 全局静态变量存 底部控制器\n                    CpNavigation.navHostController = rememberAnimatedNavController()\n                    // 主页面\n                    HhfNavigation()\n                    // 进度条\n                    DialogProgress()\n                &#125;\n                // 是否纪念日，将App置灰\n                if(isMourningDay())&#123;\n                    Canvas(modifier = Modifier.fillMaxSize())&#123;\n                        drawRect(color = Color.White,blendMode = BlendMode.Saturation)\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        addCallback()\n    &#125;\n</code></pre>\n<p>因为这个app就一个Activity，setContent中的内容就是展现给用户可以看到的所有东西了。<br>顶层是一个自定义主题：</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun HhfTheme(\n    theme: HhfTheme.Theme = HhfTheme.Theme.Light,\n    colorTheme: Color? = null,\n    content: @Composable () -&gt; Unit\n) &#123;\n    val targetColors = if (theme == HhfTheme.Theme.Dark) &#123;\n        colorTheme?.let &#123;\n            rememberSystemUiController().setNavigationBarColor(colorTheme)\n            DarkColorPalette.apply &#123;\n                themeColor = it\n            &#125;\n        &#125;?:DarkColorPalette\n    &#125; else &#123;\n        colorTheme?.let &#123;\n            rememberSystemUiController().setNavigationBarColor(colorTheme)\n            LightColorPalette.apply &#123;\n                themeColor = it\n            &#125;\n        &#125;?:LightColorPalette\n    &#125;\n    val themeColor = animateColorAsState(targetColors.themeColor, TweenSpec(600))\n    val textColor = animateColorAsState(targetColors.textColor, TweenSpec(600))\n    val background = animateColorAsState(targetColors.background,TweenSpec(600))\n    val listItem =  animateColorAsState(targetColors.listItem,TweenSpec(600))\n    val bottomBar =  animateColorAsState(targetColors.bottomBar,TweenSpec(600))\n    val divider =  animateColorAsState(targetColors.divider,TweenSpec(600))\n    val textFieldBackground =  animateColorAsState(targetColors.textFieldBackground,TweenSpec(600))\n    val colors = HhfColors(themeColor.value,\n        textColor.value,\n        background = background.value,\n        listItem = listItem.value,\n        bottomBar = bottomBar.value,\n        divider = divider.value,\n        textFieldBackground = textFieldBackground.value,\n        )\n    CompositionLocalProvider(LocalHhfColors provides colors) &#123;\n        MaterialTheme(\n            shapes = Shapes,\n            typography = typography\n        ) &#123;\n            content.invoke()\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里用到了一个 CompositionLocalProvider，具体用法可以参考 <a href=\"https://juejin.cn/post/7097890697721675813\">https://juejin.cn/post/7097890697721675813</a></p>\n<p>在Compose函数里，如果要用到函数外提供的值，一般都要通过函数定义好参数，外部调用时传入进去。<br>这种方法表面看没啥问题，但在一些场景下就不是很方便。比如一个函数A嵌套一个函数B，函数B嵌套函数C，并且这A、B、C的函数都用到这个参数，那对三个函数来说都需要定义这个参数，就不是那么方便。<br>那用个全局变量不就可以解决需要重复定义参数，确实可以。但全局变量有个副作用就是影响的范围比较大。本身我们定义的参数只会影响到函数内部。这个时候我们就可以使用CompositionLocal：它具有穿透函数功能的局部变量<br>CompositionLocal适用场景：用来提供上下文数据，不扩大影响范围。</p>\n<p>然后最终主题呈现是用了 MaterialTheme这个类展现。</p>\n<p>回到首页，内容区：</p>\n<ul>\n<li>闪屏页展示逻辑<br>  通过一个变量：<code>  var isSplash by mutableStateOf(true)</code> 实现控制是否显示</li>\n<li>加载首页<br> 先 展示主页面，覆盖一层 进度条</li>\n<li>是否纪念日<br>  app置灰处理    </li>\n<li>添加二次点击返回退出app逻辑</li>\n</ul>\n<p>首页逻辑基本就这么多了。</p>\n<h3 id=\"7-闪屏ui-gt-SplashView\"><a href=\"#7-闪屏ui-gt-SplashView\" class=\"headerlink\" title=\"7.闪屏ui -&gt; SplashView\"></a>7.闪屏ui -&gt; SplashView</h3><p>看下效果先：<br><img src=%E9%97%AA%E5%B1%8F%E9%A1%B5.gif width = 50%></p>\n<p>可以看到进入app后有个启动页面，中间是logo。<br>那这个页面有个渐变动画，淡入淡出效果。</p>\n<p>具体ui是这样的：</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun SplashView(startMain: () -&gt; Unit) &#123;\n    /**\n     * 辅助文字颜色变化 建立的一个mutableState包装的变量，实际上就是bool值\n     */\n    var enabled by remember &#123; mutableStateOf(false) &#125;\n\n    /**\n     * 背景颜色，从0.3alpha主题色变为纯主题色，2s的时间\n     */\n    val bgColor: Color by animateColorAsState(\n        if (enabled) HhfTheme.colors.themeColor\n        else HhfTheme.colors.themeColor.copy(alpha = 0.3f),\n        animationSpec = tween(durationMillis = 2000)\n    )\n\n    /**\n     * 中间文字颜色动画，如果enable为false，0.3alpha的颜色 到纯白色 2s的时间\n     */\n    val textColor: Color by animateColorAsState(\n        if (enabled) Color.White\n        else Color.White.copy(alpha = 0.3f),\n        animationSpec = tween(durationMillis = 2000)\n    )\n\n    // 外层一个Box+中间一个Text\n    Box(\n        Modifier\n            .fillMaxSize()\n            .background(bgColor),\n        contentAlignment = Alignment.Center\n    ) &#123;\n        Text(text = &quot;PlayAndroid&quot;, color = textColor,style = MaterialTheme.typography.h5)\n    &#125;\n\n    // 开启协程 可以看出Compose里面开启协程的方法\n    LaunchedEffect(Unit) &#123;\n        enabled = true\n        delay(2000)\n        // 2s后，设置 mutableStateOf 包装的bool变量 为false 会通知首页重新走setContent方法\n        startMain.invoke()\n    &#125;\n&#125;\n</code></pre>\n<p>这里需要理解 animateColorAsState 是官方提供的一个动画，支持颜色变化的一个composable方法。</p>\n<p>然后这里开启了2s延迟，怎么开延迟的，调用LaunchedEffect方法里面的delay，可以实现延迟效果。然后执行startMain回调。</p>\n<p>这个回调很简单：viewModel.isSplash &#x3D; false</p>\n<p>虽然很简单，但实际上走了很多流程的。</p>\n<pre><code class=\"line-numbers language-Kotlin\">class MainViewModel : ViewModel() &#123;\n    var isSplash by mutableStateOf(true)\n&#125;\n</code></pre>\n<p>这里使用mutableStateOf包装了一个布尔值。 上面触发这改变时，会刷新composable注解声明的方法体。这里应该就是刷新MainActivity整个内容区了。</p>\n<h3 id=\"8-主页面外部架构\"><a href=\"#8-主页面外部架构\" class=\"headerlink\" title=\"8.主页面外部架构\"></a>8.主页面外部架构</h3><pre><code class=\"line-numbers language-Kotlin\">@ExperimentalAnimationApi\n@OptIn(ExperimentalPagerApi::class)\n@Composable\nfun HhfNavigation() &#123;\n    AnimatedNavHost(navController = CpNavigation.navHostController,\n        /**\n         * 首页默认页面\n         */\n        startDestination = ModelPath.Main.route,\n        enterTransition = &#123; fadeIn(animationSpec = tween(700), initialAlpha = 0f) &#125;,\n        exitTransition = &#123; fadeOut(animationSpec = tween(700), targetAlpha = 0f) &#125;) &#123;\n\n        /**\n         * 定义接收到 main 路由消息后-&gt;展示MainContent视图\n         */\n        composable(ModelPath.Main.route) &#123;\n            MainContent()\n        &#125;\n\n        /**\n         * 接收到 setting 路由消息后 -&gt; 设置页面\n         */\n        composable(ModelPath.Setting.route) &#123;\n            CpSetting(Modifier.fillMaxSize())\n        &#125;\n        ...\n</code></pre>\n<p>这里使用了一个AnimatedNavHost，这个类是官方提供的。<br>这个类里面定义了所有我们需要跳转的页面和初始页。<br>然后这个 需要传一个参数，也就是控制器：<br><code> CpNavigation.navHostController = rememberAnimatedNavController()</code><br>这里也是官方提供的remember包装的一个控制器。</p>\n<p>这里的初始页为：<code>  startDestination = ModelPath.Main.route,</code><br>本质上就是一个string，首页的路由。</p>\n<p>这样会默认展示首页，怎么展示首页呢？</p>\n<pre><code class=\"line-numbers language-Kotlin\">composable(ModelPath.Main.route) &#123;\n            MainContent()\n        &#125;\n</code></pre>\n<p>那么这个MainContent就是我们的首页。</p>\n<p>其它composable里面都是首页可能去哪些页面的路由定义。</p>\n<p>那这个比如跳转到设置页面，怎么处理呢？</p>\n<ul>\n<li>首先在这个AnimatedNavHost里面定义一个composable闭包</li>\n</ul>\n<pre><code class=\"line-numbers language-Kotlin\"> composable(ModelPath.Setting.route) &#123;\n            CpSetting(Modifier.fillMaxSize())\n        &#125;\n</code></pre>\n<ul>\n<li>然后再需要跳转的地方调用<br><code>navHostController.navigate(“setting”)</code><br>这个navHostController就是我们之前定义的那个控制器，setting就是路由名称。<br>这样子就可以跳转到设置页面了。</li>\n</ul>\n<h3 id=\"9-主页内部架构框\"><a href=\"#9-主页内部架构框\" class=\"headerlink\" title=\"9.主页内部架构框\"></a>9.主页内部架构框</h3><p>首先看下主页效果图<br><img src=%E9%A6%96%E9%A1%B5.jpeg width=50%><br>轮播图+中间列表+底部bar<br>轮播图+中间列表可以看成一个整体，那就是内容区+底部bar</p>\n<p>架构怎么搭建呢？</p>\n<pre><code class=\"line-numbers language-Kotlin\">   Scaffold(bottomBar = &#123;\n        AnimatedVisibility(\n            visible = bottomSwitch,\n            enter = expandVertically() + fadeIn(), // 操作符重载了，第一个为空，就用第二个\n            exit = shrinkVertically() + fadeOut()  // 操作符重载了，第一个为空，就用第二个\n        ) &#123;\n            // 实际的底部bar 高度使用 固有特性测量 可以参考：https://juejin.cn/post/7068164264363556872\n            MainBottomBar(\n                Modifier\n                    .fillMaxWidth()\n                    .height(IntrinsicSize.Max),pagerState = pagerState) &#123;\n                pagerState.reenableScrolling(coroutineScope, it)\n            &#125;\n        &#125;\n    &#125;) &#123;\n        内容区...\n</code></pre>\n<p>最外层一个Scafffold脚手架包裹，有点像Flutter了啊。<br>然后是一个AnimatedVisibility，这个控制显示隐藏的动画组件。重点看里面的MainBottomBar，就找到了我们的底部bar了。</p>\n<p>这个看起来像自定义的，具体怎么实现的呢？</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * App底部bar\n */\n@OptIn(ExperimentalPagerApi::class)\n@Composable\nprivate fun MainBottomBar(\n    modifier: Modifier = Modifier,\n    pagerState: PagerState,\n    currentChanged: (Int) -&gt; Unit\n) &#123;\n    /**\n     * 这个BottomAppBar是官方的\n     */\n    BottomAppBar(\n        modifier.navigationBarsPadding(),\n        cutoutShape = CircleShape,\n        backgroundColor = HhfTheme.colors.bottomBar,\n        elevation = 5.dp\n    ) &#123;\n        // 遍历4个tab\n        bottomList.forEachIndexed &#123; index, item -&gt;\n            // item单独设置 官方组件\n            BottomNavigationItem(\n                selected = pagerState.currentPage == index, onClick = &#123;\n                    /**\n                     * item点击事件回调给上层\n                     */\n                    currentChanged(index)\n                &#125;, icon = &#123;\n                    /**\n                     * icon为官方组件\n                     */\n                    Icon(\n                        item.dashboardState.icon,\n                        contentDescription = item.name,\n                        tint = if (pagerState.currentPage == index) &#123;\n                            HhfTheme.colors.themeColor\n                        &#125; else &#123;\n                            LocalContentColor.current.copy(alpha = LocalContentAlpha.current)\n                        &#125;, modifier = Modifier.size(24.dp)\n                    )\n                &#125;, label = &#123;\n                    Text(\n                        text = item.name,\n                        color = if (pagerState.currentPage == index) &#123;\n                            HhfTheme.colors.themeColor\n                        &#125; else &#123;\n                            LocalContentColor.current.copy(alpha = LocalContentAlpha.current)\n                        &#125;,\n                        fontSize = 12.sp\n                    )\n                &#125;,\n                unselectedContentColor = LocalContentColor.current.copy(alpha = LocalContentAlpha.current),\n                selectedContentColor = HhfTheme.colors.themeColor,\n                alwaysShowLabel = true\n\n            )\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里看出底部bar就是用了官方的BottomAppBar。<br>里面具体内容是我们开发者自行设定的，这里遍历了bottomList，这个集合就是我们自己定义的一个集合：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * 底部List集合 这里定义了4块\n * 首页，项目，公众号，我的\n */\nval bottomList = listOf(\n    BottomBean(\n        DashboardState.Home,\n        YshhApplication.context.stringResource(R.string.main_title_home)\n    ),\n    BottomBean(\n        DashboardState.Project,\n        YshhApplication.context.stringResource(R.string.main_title_project)\n    ),\n    BottomBean(\n        DashboardState.PubAccount,\n        YshhApplication.context.stringResource(R.string.main_title_account)\n    ),\n    BottomBean(\n        DashboardState.Mine,\n        YshhApplication.context.stringResource(R.string.main_title_mine)\n    )\n)\n</code></pre>\n<p>就这几个模块。</p>\n<p>底部bar的item就是 BottomNavigationitem里面的了，可以看到是一个icon+label构成。有个onClick的参数就是点击事件回调了，这里调用了 回调函数，传递给上层了，传出去的参数就一个int，表示第几页。</p>\n<p>回调到哪里呢？</p>\n<pre><code class=\"line-numbers language-Kotlin\"> // 实际的底部bar 高度使用 固有特性测量 可以参考：https://juejin.cn/post/7068164264363556872\n            MainBottomBar(\n                Modifier\n                    .fillMaxWidth()\n                    .height(IntrinsicSize.Max),pagerState = pagerState) &#123;\n                pagerState.reenableScrolling(coroutineScope, it)\n            &#125;\n</code></pre>\n<p>这里通过调用rememberPagerState这个对象的<code>  pagerState.reenableScrolling(coroutineScope, it)</code>这个方法实现滚动到目标tab下。也就实现了页面切换。<br>最为关键的就是这个pagerState，同步页面数据和底部bar。</p>\n<p>等下分析内容区也会用到。</p>\n<pre><code class=\"line-numbers language-Kotlin\"> // 水平分页\n            HorizontalPager(\n                count = bottomList.size,\n                modifier.weight(1f), pagerState, userScrollEnabled = true\n            ) &#123; page -&gt;\n                when (page) &#123;\n                    // 首页tab\n                    0 -&gt; HomeView(\n                        Modifier\n                            .fillMaxSize()\n                            .background(HhfTheme.colors.background)\n                            .align(Alignment.CenterHorizontally)\n                    )\n                    // 项目tab\n                    1 -&gt; ProjectView(\n                        Modifier\n                            .fillMaxSize()\n                            .align(Alignment.CenterHorizontally)\n                    )\n                    // 公众号tab\n                    2 -&gt; AccountView(\n                        Modifier\n                            .fillMaxSize()\n                            .background(HhfTheme.colors.background)\n                            .align(Alignment.CenterHorizontally)\n                    )\n                    // 我的tab\n                    3 -&gt; &#123;\n//                        if (isLogin) &#123;\n                            Mine(\n                                Modifier\n                                    .fillMaxSize()\n                                    .background(HhfTheme.colors.background)\n                                    .align(Alignment.CenterHorizontally)\n                            )\n//                        &#125; else &#123;\n//                            ErrorBox(\n//                                Modifier.fillMaxSize(),\n//                                title = stringResource(id = R.string.sign_in)\n//                            )\n//                            &#123; CpNavigation.to(ModelPath.Login) &#125;\n//                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n</code></pre>\n<p>这里是中间内容区。通过使用水平分页得以实现。可以看到传入了一个参数，也就是上面底部bar用到的一个pagerState，定义了不同索引下，中间内容区展示的内容。</p>\n<ul>\n<li>首页Tab 对应 HomeView</li>\n<li>项目Tab 对应 ProjectView</li>\n<li>公众号Tab 对应 AccountView</li>\n<li>我的Tab 对应 Mine</li>\n</ul>\n<h3 id=\"10-首页Tab-HomeView\"><a href=\"#10-首页Tab-HomeView\" class=\"headerlink\" title=\"10.首页Tab-HomeView\"></a>10.首页Tab-HomeView</h3><p>首页效果图就是上面的那个效果。<br>这里再拆分下，就是轮播图+列表。<br>对应 HomeView。</p>\n<pre><code class=\"line-numbers language-Kotlin\">@CompoKotlinsable\nfun HomeView(modifier: Modifier = Modifier) &#123;\n    val viewModel: HomeViewModel = viewModel()\n    ColumnTopBarMain(modifier\n        .background(HhfTheme.colors.background),\n        stringResource(R.string.app_name)) &#123;\n        // 内容区域，传入HomeViewModel对象\n        HomeContent(viewModel = viewModel)\n    &#125;\n&#125;\n</code></pre>\n<p>最外层是由顶部bar+内容区构成。</p>\n<p>ColumnTabBarMain是自定义通用的一个App的组件，用于上面展示toolbar，中间区域自定义。</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun ColumnTopBarMain(\n    modifier: Modifier = Modifier,\n    title: String,\n    content: @Composable ColumnScope.() -&gt; Unit\n) &#123;\n    Column(\n        modifier.navigationBarsPadding(),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) &#123;\n        CpTopBar(\n            Modifier.fillMaxWidth(),\n            HhfTheme.colors.themeColor,\n            title = title,\n            actions = &#123;\n                IconButton(onClick = &#123;\n                    CpNavigation.to(ModelPath.Search)\n                &#125;) &#123;\n                    Icon(Icons.Filled.Search, contentDescription = &quot;search&quot;, tint = Color.White)\n                &#125;\n            &#125;,\n        )\n        content.invoke(this)\n    &#125;\n&#125;\n</code></pre>\n<p>这里具体是一个Column+CpTopBar构成</p>\n<p>CpTopBar是这样的：</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n@Composable\nfun CpTopBar(\n    modifier: Modifier = Modifier,\n    backgroundColor: Color = Color.Transparent,\n    title: String,\n    actions: @Composable RowScope.() -&gt; Unit = &#123;&#125;,\n    back: (() -&gt; Unit)? = null\n) &#123;\n    HhTopAppBar(\n        &#123;\n            Text(title, color = Color.White)\n        &#125;,\n        modifier = modifier,\n        backgroundColor = backgroundColor,\n        contentPadding = WindowInsets.statusBars.only(WindowInsetsSides.Horizontal + WindowInsetsSides.Top).asPaddingValues(),\n        navigationIcon = back?.run &#123;\n            &#123;\n                IconButton(\n                    onClick = &#123;\n                        invoke()\n                    &#125;\n                ) &#123;\n                    Icon(Icons.Filled.ArrowBack, contentDescription = &quot;back&quot;, tint = Color.White)\n                &#125;\n            &#125;\n        &#125;,\n        actions = actions,\n        elevation = 2.dp,\n    )\n&#125;\n</code></pre>\n<p>里面还有自定义的HhTopAppBar</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n@Composable\nfun HhTopAppBar(\n    title: @Composable () -&gt; Unit,\n    modifier: Modifier = Modifier,\n    contentPadding: PaddingValues = PaddingValues(0.dp),\n    navigationIcon: @Composable (() -&gt; Unit)? = null,\n    actions: @Composable RowScope.() -&gt; Unit = &#123;&#125;,\n    backgroundColor: Color = MaterialTheme.colors.primarySurface,\n    contentColor: Color = contentColorFor(backgroundColor),\n    elevation: Dp = AppBarDefaults.TopAppBarElevation,\n) &#123;\n    TopAppBarSurface(\n        modifier = modifier,\n        backgroundColor = backgroundColor,\n        contentColor = contentColor,\n        elevation = elevation\n    ) &#123;\n        TopAppBarContent(\n            title = title,\n            navigationIcon = navigationIcon,\n            actions = actions,\n            modifier = Modifier.padding(contentPadding)\n        )\n    &#125;\n&#125;\n</code></pre>\n<p>竟然还有自定义层：Surface是官方提供的了</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun TopAppBarSurface(\n    modifier: Modifier = Modifier,\n    backgroundColor: Color = MaterialTheme.colors.primarySurface,\n    contentColor: Color = contentColorFor(backgroundColor),\n    elevation: Dp = AppBarDefaults.TopAppBarElevation,\n    content: @Composable () -&gt; Unit,\n) &#123;\n    Surface(\n        color = backgroundColor,\n        contentColor = contentColor,\n        elevation = elevation,\n        modifier = modifier,\n        content = content\n    )\n&#125;\n</code></pre>\n<p>还有标题栏内容区： 这个TopAppBar是官方提供的了</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun TopAppBarContent(\n    title: @Composable () -&gt; Unit,\n    modifier: Modifier = Modifier,\n    navigationIcon: @Composable (() -&gt; Unit)? = null,\n    actions: @Composable RowScope.() -&gt; Unit = &#123;&#125;,\n) &#123;\n    TopAppBar(\n        title = title,\n        navigationIcon = navigationIcon,\n        actions = actions,\n        backgroundColor = Color.Transparent,\n        elevation = 0.dp,\n        modifier = modifier\n    )\n&#125;\n</code></pre>\n<p>标题栏看完了，那就到内容区了。</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n/**\n * 首页内容区\n */\n@Composable\nfun HomeContent(modifier: Modifier = Modifier, viewModel: HomeViewModel) &#123;\n\n    /**\n     * list 为首页文章 列表数据；系统会对所有列表项进行组合和布局，无论它们是否可见，\n     * 因此如果您需要显示大量列表项（或长度未知的列表），则使用 Column 等布局可能会导致性能问题。\n     * Compose 提供了一组组件，这些组件只会对在组件视口中可见的列表项进行组合和布局。\n     */\n    val list = viewModel.viewStates.homeList.collectAsLazyPagingItems()\n\n    /**\n     * 下拉刷新组件\n     */\n    SwipeRefresh(\n        /**\n         * 状态，是否正在刷新\n         */\n        state = rememberSwipeRefreshState(viewModel.viewStates.isRefresh),\n        /**\n         * 下拉刷新回调，需要更新轮播+列表\n         */\n        onRefresh = &#123;\n            viewModel.dispatch(HomeAction.GetBanner)\n            list.refresh()\n        &#125;) &#123;\n        // 内容区 使用LazyItem包裹\n        PagingItem(modifier, list = list,\n            errorBlock = &#123;&#125;,\n            successBlock = &#123;&#125;,\n            errorAndSuccessClick = &#123;\n                /**\n                 * 错误后点击回调\n                 */\n                list.refresh()\n            &#125;) &#123;\n            /**\n             * 仅组成和放置 当前可见项 的竖直滚动列表。它允许您放置不同类型的子级内容。\n             * 例如，您可以使用LazyListScope.item添加单个项目，然后使用LazyListScope.items或者LazyListScope.itemsIndexed添加项目列表，后者有当前列表项的索引值。\n             */\n            LazyColumn&#123;\n                /**\n                 * 单个item\n                 */\n                item &#123;\n                    BannerPager(Modifier.height(160.dp), viewModel = viewModel)\n                &#125;\n                /**\n                 * items集合\n                 */\n                items(it) &#123; homeBean -&gt;\n                    homeBean?.apply &#123;\n                        /**\n                         * 首页文字item\n                         */\n                        HomeListItem(homeBean = this) &#123;\n                            /**\n                             * 处理点击收藏图标 触发viewModel层调用接口\n                             */\n                            if(CacheUtils.isLogin)&#123;\n                                viewModel.dispatch(HomeAction.Collect(homeBean.id, it))\n                            &#125;\n                            else&#123;\n                                CpNavigation.to(ModelPath.Login)\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>list 是专门用于懒加载列表，这个是存放可视区的列表。</p>\n<p>数据来源是ViewModel层的viewStates实例。</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * 首页状态，包装首页需要的数据\n */\ndata class HomeState(\n    /**\n     * 是否正在刷新\n     */\n    val isRefresh : Boolean = false,\n\n    /**\n     * 轮播列表，数据源\n     */\n    val bannerList: List&lt;BannerResponse&gt; = listOf(),\n\n    /**\n     * 首页数据\n     */\n    val homeList: Flow&lt;PagingData&lt;ArticleBean&gt;&gt; = Pager(\n        PagingConfig(PAGE_SIZE),\n        pagingSourceFactory = &#123; HomeSource() &#125;).flow,\n)\n</code></pre>\n<p>这个是存放到ViewModel层的首页动态数据。</p>\n<pre><code class=\"line-numbers language-Kotlin\"> // 首页数据监听 通过 mutableStateOf包装 HomeState\n    var viewStates by mutableStateOf(\n        HomeState(\n            homeList = Pager(\n                PagingConfig(PAGE_SIZE),\n                pagingSourceFactory = &#123; HomeSource() &#125;).flow.cachedIn(viewModelScope)))\n        private set\n</code></pre>\n<p>这里用一个mutableStateof包装下。</p>\n<p>下面继续回到首页内容区：<br>然后是一个SwipeRefresh组件,官方提供的。</p>\n<pre><code class=\"line-numbers language-Kotlin\">    SwipeRefresh(\n        /**\n         * 状态，是否正在刷新\n         */\n        state = rememberSwipeRefreshState(viewModel.viewStates.isRefresh),\n        /**\n         * 下拉刷新回调，需要更新轮播+列表\n         */\n        onRefresh = &#123;\n            viewModel.dispatch(HomeAction.GetBanner)\n            list.refresh()\n        &#125;) &#123;\n</code></pre>\n<p>定义好下拉刷新触发事件。<br>注意这个list，实际上走的是LazyPagingItems里面的一个refresh方法。<br>我们在HomeState中定义的homeList是一个Flow包装列表集合。通过调用Flow中扩展的一个collectAsLazyPagingItems函数，就变成LazyPagingItems对象了。</p>\n<p>这个list我们放在PagingItem里面。</p>\n<p>然后首页内容区里面用了一个 LazyColumn，应该也是配合懒加载和复用官方实现的一个类。<br>然后里面第一个item就是我们的轮播图了。</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n * 顶部轮播图\n */\n@OptIn(ExperimentalPagerApi::class)\n@Composable\nfun BannerPager(modifier: Modifier = Modifier, viewModel: HomeViewModel) &#123;\n    val pagerState = rememberPagerState()\n\n    /**\n     * 开启协程 内部的闭包是协程 目的是获取轮播图数据\n     */\n    LaunchedEffect(viewModel)&#123;\n        viewModel.dispatch(HomeAction.GetBanner)\n    &#125;\n\n    /**\n     * 如需了解来自父项的约束条件并相应地设计布局，您可以使用 BoxWithConstraints。\n     * 就是外部传过来的modifier 决定子View 空间\n     */\n    BoxWithConstraints(modifier) &#123;\n\n        /**\n         * 水平分页\n         */\n        HorizontalPager(\n            count = viewModel.viewStates.bannerList.size, // 轮播总数\n            state = pagerState // 轮播状态\n        ) &#123; page -&gt;\n            //  页面索引\n            when (page) &#123;\n                viewModel.viewStates.bannerList[page].id -&gt; &#123;\n                    /**\n                     * 轮播图item\n                     */\n                    BannerItem(\n                        Modifier\n                            .height(maxHeight)\n                            .fillMaxWidth(), viewModel.viewStates.bannerList[page]\n                    )\n                &#125;\n            &#125;\n        &#125;\n\n        /**\n         * 轮播指示器\n         */\n        if (viewModel.viewStates.bannerList.isNotEmpty()) &#123;\n            BannerIndicator(\n                Modifier\n                    .align(Alignment.BottomCenter)\n                    .fillMaxWidth()\n                    .background(Color.Black.copy(0.2f))\n                    .padding(8.dp),viewModel, pagerState )\n        &#125;\n\n\n    &#125;\n&#125;\n</code></pre>\n<p>这个轮播图里面开了个协程去获取轮播图数据，只会走一次。<br>然后一个水平分页里面存放所有轮播图，轮播item为BannerItem,这个是自定义的</p>\n<pre><code class=\"line-numbers language-Kotlin\">@Composable\nfun BannerItem(modifier: Modifier = Modifier, data: BannerResponse) &#123;\n    data.apply &#123;\n        Box(modifier.clickable &#123;\n            /**\n             * 点击图片，触发跳转WebView，通过bundle传递数据\n             */\n            CpNavigation.toBundle(ModelPath.WebView, Bundle().apply &#123;\n                putString(webTitle, data.title)\n                putString(webUrl, data.url)\n                putBoolean(webIsCollect, false)\n                putInt(webCollectId, data.id)\n                putInt(webCollectType, 1)\n            &#125;)\n        &#125;) &#123;\n            /**\n             * 自定义网络图片\n             */\n            NetworkImage(\n                imagePath,\n                Modifier.fillMaxWidth(),\n                contentScale = ContentScale.FillBounds,\n                defaultImg = R.mipmap.ic_default_round\n            )\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>轮播完了，就是文章item了。<br>主要是为了实现这种效果<br><img src=\"/./%E7%8E%A9Android-Compose%E7%89%88%E6%9C%AC-%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90/home_item.jpeg\"></p>\n<pre><code class=\"line-numbers language-Kotlin\"> /**\n   * items集合\n   */\nitems(it) &#123; homeBean -&gt;\n    homeBean?.apply &#123;\n        /**\n        * 首页文字item\n        */\n        HomeListItem(homeBean = this) &#123;\n            /**\n            * 处理点击收藏图标 触发viewModel层调用接口\n            */\n            if(CacheUtils.isLogin)&#123;\n                viewModel.dispatch(HomeAction.Collect(homeBean.id, it))\n            &#125;\n            else&#123;\n                CpNavigation.to(ModelPath.Login)\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里用了items，然后遍历了 list,每个item对应一个 HomeListItem<br>这里定义了一个函数，说明了点击收藏图标后的逻辑。</p>\n<pre><code class=\"line-numbers language-Kotlin\">  /**\n     * 是否收藏了，用remember包装一下bool值\n     */\n    var isCollect by remember&#123; mutableStateOf(homeBean.collect)&#125;\n\n    /**\n     * 卡片布局\n     */\n    Card(\n        modifier\n            .padding(8.dp) // 内padding 8个dp\n            .clickable &#123;\n                /**\n                 * 卡片点击事件，触发跳转webView\n                 */\n                CpNavigation.toBundle(ModelPath.WebView, Bundle().apply &#123;\n                    putString(webTitle, homeBean.title)\n                    putString(webUrl, homeBean.link)\n                    putBoolean(webIsCollect, isCollect)\n                    putInt(webCollectId, homeBean.id)\n                    putInt(webCollectType, 0)\n                &#125;)\n            &#125;,\n        backgroundColor = HhfTheme.colors.listItem,\n        elevation = 5.dp\n    ) &#123;\n</code></pre>\n<p>这里外层是用了Card,定义了点击item的逻辑。</p>\n<p>里面是这样的：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> Column(Modifier.padding(8.dp)) &#123;\n                /**\n                 * 第一行 水平布局\n                 */\n                Row(verticalAlignment = Alignment.CenterVertically) &#123;\n                    /**\n                     * 分享者没名字\n                     */\n                    Text(\n                        text = if (author.isNotEmpty()) author else shareUser,\n                        fontSize = 13.sp,\n                        color = HhfTheme.colors.textColor\n                    )\n                    /**\n                     * 显示标签\n                     */\n                    if(isShowLabel)&#123;\n                        if (type == 1) &#123;\n                            Box(\n                                Modifier\n                                    .padding(start = 6.dp)\n                                    .border(1.dp, Color.Red, RoundedCornerShape(5.dp))\n                                    .padding(4.dp)\n                            ) &#123;\n                                Text(stringResource(id = R.string.istop), Modifier, Color.Red, 10.sp)\n                            &#125;\n                        &#125;\n                        if (fresh) &#123;\n                            Box(\n                                Modifier\n                                    .padding(start = 6.dp)\n                                    .border(1.dp, Color.Red, RoundedCornerShape(5.dp))\n                                    .padding(4.dp)\n                            ) &#123;\n                                Text(stringResource(id = R.string.neww), Modifier, Color.Red, 10.sp)\n                            &#125;\n                        &#125;\n                        if (tags.isNotEmpty()) &#123;\n                            Box(\n                                Modifier\n                                    .padding(start = 6.dp)\n                                    .border(1.dp, Color(0xFF66BB6A), RoundedCornerShape(5.dp))\n                                    .padding(4.dp)\n                            ) &#123;\n                                Text(tags[0].name, Modifier, Color(0xFF66BB6A), 10.sp)\n                            &#125;\n                        &#125;\n                    &#125;\n                    /**\n                     * 发布日期\n                     */\n                    Text(\n                        niceDate,\n                        Modifier\n                            .weight(1f)\n                            .wrapContentWidth(\n                                Alignment.End\n                            )\n                            .align(Alignment.CenterVertically),\n                        HhfTheme.colors.textColor.copy(0.6f),\n                        fontSize = 13.sp,\n                    )\n                &#125;\n                /**\n                 * 有没有封面图\n                 */\n                if (TextUtils.isEmpty(envelopePic)) &#123;\n                    // 没有封面图\n                    Text(\n                        title.filterHtml(),\n                        Modifier.padding(top = 12.dp),\n                        HhfTheme.colors.textColor,\n                        fontSize = 14.sp,\n                        fontWeight = FontWeight.Bold\n                    )\n                &#125; else &#123;\n                    // 有封面图时，中间区域展示\n                    Row(Modifier.padding(top = 12.dp)) &#123;\n                        // 网络图片\n                        NetworkImage(\n                            envelopePic,\n                            Modifier.size(100.dp),\n                            contentScale = ContentScale.Crop,\n                            defaultImg = R.mipmap.ic_default_round\n                        )\n                        // 垂直布局\n                        Column(Modifier.padding(start = 8.dp)) &#123;\n                            // 标题\n                            Text(\n                                title.filterHtml(),\n                                color = HhfTheme.colors.textColor,\n                                fontSize = 14.sp,\n                                maxLines = 3,\n                                style = TextStyle(fontWeight = FontWeight.Bold)\n                            )\n                            // 摘要描述\n                            Text(\n                                desc,\n                                color = HhfTheme.colors.textInactiveColor,\n                                fontSize = 13.sp,\n                                maxLines = 3,\n                                overflow = TextOverflow.Ellipsis\n                            )\n                        &#125;\n                    &#125;\n                &#125;\n                // 底部水平布局\n                Row &#123;\n                    // 文本\n                    Text(\n                        &quot;$superChapterName / $chapterName&quot;,\n                        Modifier.padding(top = 12.dp),\n                        HhfTheme.colors.textColor,\n                        fontSize = 13.sp\n                    )\n                    // 图标，是否收藏了\n                    Icon(\n                        if(isCollect) Icons.Filled.Favorite else Icons.Filled.FavoriteBorder, contentDescription = &quot;&quot;,\n                        Modifier\n                            .wrapContentWidth(\n                                Alignment.End\n                            )\n                            .weight(1f)\n                            .clickable &#123;\n                                /**\n                                 * 点击收藏，触发请求\n                                 */\n                                favoriteAction(isCollect)\n                                isCollect = !isCollect\n                            &#125;,\n                        tint = HhfTheme.colors.themeColor\n                    )\n                &#125;\n            &#125;\n</code></pre>\n<h3 id=\"11-我的Tab-Mine\"><a href=\"#11-我的Tab-Mine\" class=\"headerlink\" title=\"11.我的Tab-Mine\"></a>11.我的Tab-Mine</h3><p>因为项目和公众号和首页基本一样，这里就不重复分析了。<br>看下我的页面的效果图：<br><img src=mine.jpeg width=50%><br>要实现这样的效果，怎么处理呢？</p>\n<p>首先开启一个协程，获取用户sp数据，转成UserInfo对象</p>\n<pre><code class=\"line-numbers language-Kotlin\">   /**\n     * 开启协程，只走一次\n     */\n    LaunchedEffect(CacheUtils.userInfo) &#123;\n        if (CacheUtils.userInfo != &quot;&quot;) &#123;\n            /**\n             * 根据sp文件，生产一个UserInfo对象，设置给这个我的页面使用\n             */\n            mineViewModel.dispatch(\n                MineViewEvent.SetUserInfo(\n                    Gson().fromJson(\n                        CacheUtils.userInfo, // sp文件\n                        UserInfo::class.java\n                    )\n                )\n            )\n            /**\n             * 获取积分和排名\n             */\n            mineViewModel.dispatch(MineViewEvent.GetIntegral)\n        &#125;\n    &#125;\n</code></pre>\n<p>这里获取积分和排名是需要走接口的<br>这里会走到ViewModel层这个函数：</p>\n<pre><code class=\"line-numbers language-Kotlin\">    private fun getIntegral() &#123;\n        viewModelScope.launch &#123;\n            flow &#123;\n                emit(\n                    TaskApi.create(ApiService::class.java).getIntegral()\n                )\n            &#125;.map &#123;\n                if (it.errorCode == 0) &#123;\n                    it.data\n                        ?: throw Exception(&quot;data null&quot;)\n                &#125; else &#123;\n                    throw Exception(it.errorMsg)\n                &#125;\n            &#125;.onEach &#123;\n                viewStates = viewStates.copy(integral = it)\n            &#125;.catch &#123;\n                viewStates = viewStates.copy(integral = null)\n            &#125;.collect()\n        &#125;\n    &#125;\n</code></pre>\n<p>这个retrofit中是这样定义的：</p>\n<pre><code class=\"line-numbers language-Kotlin\">interface ApiService &#123;\n    /**\n     * 获取当前账户的个人积分\n     */\n    @GET(&quot;lg/coin/userinfo/json&quot;)\n    suspend fun getIntegral(): ApiResponse&lt;Integral&gt;\n</code></pre>\n<p>这个就是一个suspend挂起函数。</p>\n<p>顶层为Column:</p>\n<pre><code class=\"line-numbers language-Kotlin\">    /**\n     * 顶层为列表视图\n     */\n    Column(modifier) &#123;\n        /**\n         * 顶部👤\n         */\n        MineTopAvatar(\n            Modifier\n                .fillMaxWidth()\n                .height(320.dp)\n                .clip(QureytoImageShapes(160f)),\n            mineViewModel.viewStates.userInfo?.run &#123;\n                nickname\n            &#125; ?: &quot;avatar&quot;\n        ) &#123;\n</code></pre>\n<p>头像区域，点击后可以弹pop，但是需要先获取权限，这样获取：</p>\n<pre><code class=\"line-numbers language-Kotlin\">// 图片点击事件 会去申请下权限\n            XXPermissions\n                .with(context)\n                .permission(Permission.CAMERA)\n                .permission(Permission.MANAGE_EXTERNAL_STORAGE)\n                .request(object : OnPermissionCallback &#123;\n                    override fun onGranted(\n                        granted: List&lt;String&gt;,\n                        all: Boolean\n                    ) &#123;\n                        if (all) &#123;\n                            if(isLogin)&#123;\n                                mineViewModel.dispatch(MineViewEvent.ChangePopupState(true))\n                            &#125;\n                            else&#123;\n                                CpNavigation.to(ModelPath.Login)\n                            &#125;\n                        &#125;\n                    &#125;\n\n                    override fun onDenied(\n                        denied: List&lt;String&gt;,\n                        never: Boolean\n                    ) &#123;\n                        if (never) &#123;\n                            context.showToast(context.stringResource(R.string.permissions_cm_error))\n                            XXPermissions.startPermissionActivity(\n                                context,\n                                denied\n                            )\n                        &#125; else &#123;\n                            context.showToast(context.stringResource(R.string.permissions_camera_error))\n                        &#125;\n                    &#125;\n                &#125;)\n</code></pre>\n<p>用了一个三方库实现。</p>\n<p>中间操作栏这样实现：</p>\n<pre><code class=\"line-numbers language-Kotlin\">  // 操作栏 有个外边框，包裹菜单项，底部有阴影\n        Surface(\n            Modifier\n                .padding(start = 20.dp, end = 20.dp)\n                .fillMaxWidth()\n                .background(HhfTheme.colors.background),\n            elevation = 2.dp,\n            shape = RoundedCornerShape(8.dp),\n            color = MaterialTheme.colors.surface, // color will be adjusted for elevation\n        ) &#123;\n</code></pre>\n<p>具体的菜单项也是用懒加载实现：</p>\n<pre><code class=\"line-numbers language-Kotlin\">LazyColumn(Modifier.background(HhfTheme.colors.listItem)) &#123;\n                itemsIndexed(list) &#123; i, bean -&gt;\n\n                    /**\n                     * 我的页面遍历菜单项\n                     */\n                    MineItem(\n                        Modifier\n                            .fillMaxWidth()\n                            .clickable &#123;\n                                /**\n                                 * 分发开发者行为\n                                 */\n                                mineViewModel.dispatch(MineViewEvent.ToComposable(bean.id))\n                            &#125;\n                            .height(45.dp), bean.name, HhfTheme.colors.themeColor,\n                        bean.icon)\n                    if (i &lt; list.size - 1) &#123;\n                        /**\n                         * 非最后一行显示分割线\n                         */\n                        Divider(\n                            modifier = Modifier\n                                .fillMaxWidth()\n                                .padding(start = 10.dp, end = 10.dp)\n                        )\n                    &#125;\n                &#125;\n            &#125;\n</code></pre>\n<p>具体的菜单item,有图标+文字+右侧箭头实现：</p>\n<pre><code class=\"line-numbers language-Kotlin\">\n@Composable\nfun MineItem(\n    modifier: Modifier = Modifier, textName: String, iconColor: Color, icon: ImageVector\n) &#123;\n    Row(\n        modifier,\n        verticalAlignment = Alignment.CenterVertically,\n    ) &#123;\n        Icon(\n            icon, &quot;$textName icon&quot;,\n            Modifier\n                .size(28.dp)\n                .padding(start = 10.dp), iconColor\n        )\n        Text(\n            textName,\n            Modifier.padding(start = 10.dp),\n            fontSize = 14.sp,\n            fontFamily = FontFamily.Serif,\n            color = HhfTheme.colors.textColor\n        )\n        Icon(\n            Icons.Filled.KeyboardArrowRight, textName,\n            Modifier\n                .weight(1f)\n                .padding(end = 10.dp)\n                .wrapContentWidth(Alignment.End),\n            tint = HhfTheme.colors.textColor\n        )\n    &#125;\n&#125;\n</code></pre>\n<p>UI搞定了，跳转逻辑怎么处理呢？<br>答案是viewModel层实现。</p>\n<p>这里有个clickable点击闭包：<br><code> mineViewModel.dispatch(MineViewEvent.ToComposable(bean.id))</code></p>\n<p>会委托给mineViewModel处理：</p>\n<pre><code class=\"line-numbers language-Kotlin\">    /**\n     * 分发开发者行为\n     */\n    fun dispatch(action: MineViewEvent) &#123;\n        when (action) &#123;\n            is MineViewEvent.Blur -&gt; bitmapBlur(action.s)\n            /**\n             * 用户点击菜单项\n             */\n            is MineViewEvent.ToComposable -&gt; toComposable(action.type)\n            is MineViewEvent.ChangePopupState -&gt; &#123;\n                Log.e(&quot;TEST##&quot;, &quot;这里触发了viewStates中 isShowpopup 变更为：$&#123;action.flag&#125;&quot;)\n                viewStates = viewStates.copy(isShowPopup = action.flag)\n            &#125;\n            is MineViewEvent.SetUserInfo -&gt; viewStates = viewStates.copy(userInfo = action.userInfo)\n            is MineViewEvent.GetIntegral -&gt; getIntegral()\n        &#125;\n    &#125;\n</code></pre>\n<p>这里分发开发者行为，其实更像用户行为，有可能不是用户触发，所以我这里称之为开发者行为。</p>\n<p>点击菜单项继续分发：</p>\n<pre><code class=\"line-numbers language-Kotlin\">private fun toComposable(type: Int) &#123;\n        if(isLogin)&#123;\n            when (type) &#123;\n                0 -&gt; CpNavigation.to(ModelPath.Integral)\n                1 -&gt; CpNavigation.to(ModelPath.Collect)\n                2 -&gt; CpNavigation.to(ModelPath.Share)\n                3 -&gt; CpNavigation.to(ModelPath.Todo)\n                4 -&gt; CpNavigation.toBundle(ModelPath.WebView, Bundle().apply &#123;\n                    putString(webTitle, &quot;PlayAndroid&quot;)\n                    putString(webUrl, &quot;https://github.com/yellowhai/PlayAndroid&quot;)\n                    putBoolean(webIsCollect, false)\n                    putInt(webCollectId, 998)\n                    putInt(webCollectType, 1)\n                &#125;)\n                5 -&gt; CpNavigation.to(ModelPath.Setting)\n            &#125;\n        &#125;\n        else&#123;\n            when (type) &#123;\n                4 -&gt; CpNavigation.toBundle(ModelPath.WebView, Bundle().apply &#123;\n                    putString(webTitle, &quot;PlayAndroid&quot;)\n                    putString(webUrl, &quot;https://github.com/yellowhai/PlayAndroid&quot;)\n                    putBoolean(webIsCollect, false)\n                    putInt(webCollectId, 998)\n                    putInt(webCollectType, 1)\n                &#125;)\n                5 -&gt; CpNavigation.to(ModelPath.Setting)\n                else -&gt; CpNavigation.to(ModelPath.Login)\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>这里定义了跳转逻辑，这里有回到 第8点主页外部架构 中的导航定义了。<br>实现跳转到其它页面了，这更像是在布局上叠加，不算是跳转吧。</p>\n<p>这个项目还有很多细节值得一探究竟，不过对于初始compose，也差不多了，了解到这个程度也算入门了吧。</p>\n"},{"title":"iOS swift 3天30个Swift项目之第一天","date":"2023-02-03T01:44:26.000Z","op":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n> 参考项目：https://github.com/soapyigu/Swift-30-Projects \n\n## 1 计时器\n\n首先看下效果吧。\n<img src=01.gif>\n\n### 1.1 主要功能\n点击播放按钮，数字开始增加；\n点击暂停按钮，数字停止增加；\n点击“Reset”，数值置为0；\n\n### 1.2 UI\n这里UI采用storyboard来实现。因为比较简单，就4个控件，拖进去故事版即可。\n<img src=1.2.png>\n\n### 1.3 功能实现\n\nui声明，故事版可以直接拖进相关类中，自动生成：\n```Swift\n@IBOutlet weak var playBtn: UIButton!\n@IBOutlet weak var pauseBtn: UIButton!\n@IBOutlet weak var timeLabel: UILabel!\n```\n显示的数字声明：\n```Swift\n // 浮点数默认是Double类型，若要使用Float，需要显示声明\n    // var counter: Float = 0.0\n    var counter: Float = 0.0 {\n        // 属性观察器 \n        didSet {\n            timeLabel.text = String(format: \"%.1f\", counter)\n        }\n    }\n```\n这里的属性观察器是监听这个值变更情况，如果某个地方变更了这个值，那么会走里面的didSet回调。\n\n```Swift\n    // 知识点：存储属性和计算属性\n    override var preferredStatusBarStyle: UIStatusBarStyle {\n        // 只读计算属性，可以去掉get和花括号\n//        get {\n//            return UIStatusBarStyle.lightContent\n//        }\n        return UIStatusBarStyle.lightContent\n    }\n```\n上面的代码是控制状态栏图标颜色为亮色（白色），默认是黑色。\n\n\n```Swift\n  // 给予timer一个默认值，这样timer就不会为Optional,\n    // 后续可以不用再解包\n    // var timer = Timer()\n    \n    // 这样定义可以在不用timer时回收内存\n    var timer: Timer? = Timer()\n    var isPlaying = false\n```\n这里定义了定时器，和定时器Flag。\n\n```Swift\noverride func viewDidLoad() {\n        super.viewDidLoad()\n        // 符合LosslessStringConvertible协议的，\n        // 都可以直接初始化一个String对象\n        // timeLabel.text = String(counter)\n        \n        // 改成使用属性观察器监控和响应属性值的变化\n        counter = 0.0\n    }\n```\n这里在初始化时设置数值为0.0。\n\n```Swift\n  @IBAction func resetButtonDidTouch(_ sender: UIButton) {\n        if let timerTemp = timer {\n            timerTemp.invalidate()\n        }\n        timer = nil\n        isPlaying = false\n        counter = 0\n        playBtn.isEnabled = true\n        pauseBtn.isEnabled = true\n    }\n```\n上面是重置按钮点击事件。\n\n这个可以在故事版中右键视图，在Touch up inside中拖动到代码里面自动生成方法，具体实现逻辑由我们自行添加。这里是将定时器置为nil，然后将播放和暂停状态都设置为可点击状态。\n\n```Swift\n@IBAction func playButtonDidTouch(_ sender: UIButton) {\n        playBtn.isEnabled = false\n        pauseBtn.isEnabled = true\n        // 调用实例的方法时建议用self.UpdateTimer,\n        // 不建议使用ViewController.UpdateTimer\n        // 因为若方法定义成了类方法，第二种方式编译器不会报错。\n        timer = Timer.scheduledTimer(timeInterval: 0.1, target:self, selector: #selector(self.UpdateTimer), userInfo: nil, repeats: true)\n        isPlaying = true\n    }\n```\n这里是播放按钮的实现逻辑，这里面相当于new了一个Timer。间隔0.1s后刷新，然后会走一个selector里面的updateTimer方法更新数值。\n\n```\n   @objc func UpdateTimer() {\n        counter = counter + 0.1\n    }\n```\n这里变更数字，然后数值变化引起前面定义的didSet刷新，导致Lable数值更新。\n\n```Swift\n @IBAction func pauseButtonDidTouch(_ sender: UIButton) {\n        playBtn.isEnabled = true\n        pauseBtn.isEnabled = false\n        if let timerTemp = timer {\n            timerTemp.invalidate()\n        }\n        timer = nil\n        isPlaying = false\n        \n    }\n```\n这里是暂停按钮实现逻辑，将按钮置灰，定时器invalidate，然后定时器置空。\n\n## 2 自定义字体\n\n### 2.1 效果\n\n<img src=Customfont.gif>\n\n### 2.2 字体文件\n\n首先放置在根目录下：\n<img src=02_1.png>\n\n这里XCode会自动识别出字体文件：\n<img src=02_2.png>\n\n### 2.3 实现细节\n\n控制器可直接实现UITableViewDelegate, UITableViewDataSource,也可以扩展，最好是扩展，可读性好一点。\n```Swift\nclass ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource {\n    \n    static let identifier = \"FontCell\"\n```\n\n然后定义下数据和字体名称：\n```Swift\n   var data = [\"MFTongXin 30 Days Swift\", \"MFJinHei 这些字体特别适合打「奋斗」和「理想」\",\n                \"MFZhiHei 谢谢「造字工房」，本案例不涉及商业使用\", \"Zapfino 使用到造字工房劲黑体，致黑体，童心体\",\n                \"Gaspar呵呵，再见🤗 See you next Project\", \"微博 @Allen朝辉\",\n                \"测试测试测试测试测试测试\", \"123\", \"Alex\", \"@@@@@@\"]\n    \n    var fontNames = [\"MFTongXin_Noncommercial-Regular\",\n                     \"MFJinHei_Noncommercial-Regular\",\n                     \"MFZhiHei_Noncommercial-Regular\",\n                     \"Zapfino\",\n                     \"Gaspar Regular\"]\n```\n\n然后定义下UI：\n```Swift\n  @IBOutlet weak var changeFontLabel: UILabel!\n    @IBOutlet weak var fontTableView: UITableView!\n```\n\n然后定义下选择字体索引：\n```\n var fontRowIndex = 0\n```\n\n生命周期初始化：\n```Swift\n   \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // 在storyboard中直接设置了\n        // fontTableView.dataSource = self\n        // fontTableView.delegate = self\n        \n        // 使用手势加Label替换button\n        changeFontLabel.layer.cornerRadius = 50\n        changeFontLabel.layer.masksToBounds = true\n        // 设置为true才能响应手势\n        changeFontLabel.isUserInteractionEnabled = true\n        let gesture = UITapGestureRecognizer(target: self,\n                                             action: #selector(changeFontDidTouch(_:)))\n        changeFontLabel.addGestureRecognizer(gesture)\n    }\n\n     @objc func changeFontDidTouch(_ sender: AnyObject) {\n        \n        fontRowIndex = (fontRowIndex + 1) % 5\n        print(fontNames[fontRowIndex])\n        fontTableView.reloadData()\n        \n    }\n```\n这里主要是给一个按钮添加了手势，手势设置了action，然后相当于给按钮添加点击事件，方法有很多，可以直接故事版添加事件，也可以这种手势添加点击事件。\n\n下面是TableView的协议实现，这里Cell用了默认的，无需新建Cell。\n```Swift\n func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n        return 35\n    }\n    \n    func numberOfSections(in tableView: UITableView) -> Int {\n        return 1\n    }\n    \n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n//        let cell = fontTableView.dequeueReusableCell(withIdentifier: ViewController.identifier)\n        let cell = fontTableView.dequeueReusableCell(withIdentifier: ViewController.identifier, for: indexPath)\n        let text = data[indexPath.row]\n       \n        cell.textLabel?.text = text\n        cell.textLabel?.textColor = indexPath.row != fontRowIndex ? UIColor.white : UIColor.blue\n        cell.textLabel?.font = UIFont(name: self.fontNames[fontRowIndex], size:16)\n        \n        return cell\n    \n    }\n\n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        return data.count\n    }\n```\n主要是在cellForRowAt显示了具体item效果，根据前面选择的字体索引，这里设置给cell了。\n\n## 3 播放本地视频\n\n### 3.1 效果\n<img src=playvideo.gif>\n\n### 3.2 本地视频\n\n直接将mp4文件放置在根目录下。 \nXcode可自动识别到Movie文件夹下。\n\n### 3.3 Core Data\n这里播放本地视频并不依赖这个。\n因为demo中有部分代码是这个，当然也是可以学习下的。\n关于Core Data实际上是一个数据存储框架，类似Realm。\nFicow写的这篇文章还不错：\n [了解和采用 CoreData 框架 —— Ficow 陪你学 CoreData](https://blog.ficowshen.com/page/post/52)\n\n ### 3.4 UI定义\n\n ```Swift\n  // Swift中mark的使用方式，效果等同OC重的 #pragma mark -\n    //MARK:- Variables\n    @IBOutlet weak var videoTableView: UITableView!\n ```\n\n 这里就一个UITableView，展示一个列表。\n\n```Swift   \n  var playViewController = AVPlayerViewController()\n  var playerView = AVPlayer()\n```\n然后这里定义并且初始化了视频播放关键类。\nAVPlayerViewController是一个系统的控制器，用来播放视频的，这里播放本地视频其实也是跳转到系统默认的播放器来播放。\n\n```Swift\nvar data = [\n        // 给项目编译后属于同一个module，所以Video不需要import就可以使用\n        Video(image: \"videoScreenshot01\",\n              title: \"Introduce 3DS Mario\",\n              source: \"Youtube - 06:32\"),\n        Video(image: \"videoScreenshot02\",\n              title: \"Emoji Among Us\",\n              source: \"Vimeo - 3:34\"),\n        Video(image: \"videoScreenshot03\",\n              title: \"Seals Documentary\",\n              source: \"Vine - 00:06\"),\n        Video(image: \"videoScreenshot04\",\n              title: \"Adventure Time\",\n              source: \"Youtube - 02:39\"),\n        Video(image: \"videoScreenshot05\",\n              title: \"Facebook HQ\",\n              source: \"Facebook - 10:20\"),\n        Video(image: \"videoScreenshot06\",\n              title: \"Lijiang Lugu Lake\",\n              source: \"Allen - 20:30\")\n    ]\n```\n上面是列表页数据定义。\n\n```Swift\n //MARK:- View Life Cycle\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        videoTableView.dataSource = self\n        videoTableView.delegate = self\n        \n    }\n```\n初始化里面设置了数据源和代理。\n\n```Swift\n\n//MARK:- UIViewTableView DataSource & Delegate\n// 知识点：扩展\n// 扩展和 Objective-C 中的分类类似，但没有名称\n// 扩展可以为一个类型添加新的功能，但是不能重写已有的功能。\n// 扩展可以添加新的计算型属性，但是不可以添加存储型属性，也不可以为已有属性添加属性观察器。\nextension ViewController: UITableViewDataSource, UITableViewDelegate {\n    // Extensions must not contain stored properties\n    //var a = 1\n    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n    return 220\n    }\n\n    func numberOfSections(in tableView: UITableView) -> Int {\n    return 2\n    }\n\n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n    return data.count\n    }\n\n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n\n    // 知识点：向下转型\n    // as! 强制类型转换，无法转换时会抛出运行时异常\n    // as？可选类型转换，无法转换时返回nil\n    let cell = videoTableView.dequeueReusableCell(withIdentifier: \"VideoCell\", for: indexPath) as! VideoCell\n    let video = data[indexPath.row]\n\n    cell.videoScreenshot.image = UIImage(named: video.image)\n    cell.videoTitleLabel.text = video.title\n    cell.videoSourceLabel.text = video.source\n\n    return cell\n\n    }\n}\n```\n这里扩展实现了UITableView的代理和数据源。\n\n这里用到了一个Cell需要自定义。\n```Swift\n\n// 定义Video的结构体，属性初始化后不能被改变，因为结构体时值类型。\n// 在你每次定义一个新类或者结构体的时候，实际上你是定义了一个新的 Swift 类型。\n// 因此请使用UpperCamelCase这种方式来命名\nstruct Video {\n    let image: String\n    let title: String\n    let source: String\n}\n\nclass VideoCell: UITableViewCell {\n\n    @IBOutlet weak var videoScreenshot: UIImageView!\n    @IBOutlet weak var videoTitleLabel: UILabel!\n    @IBOutlet weak var videoSourceLabel: UILabel!\n    \n    override func awakeFromNib() {\n        super.awakeFromNib()\n        // Initialization code\n    }\n\n    override func setSelected(_ selected: Bool, animated: Bool) {\n        super.setSelected(selected, animated: animated)\n\n        // Configure the view for the selected state\n    }\n\n}\n```\n这个VideoCell是怎么添加视图的呢，当然也是故事版的作用了。\n全局搜索了下VideoCell，发现Main.storyboard里面用到了这个VideoCell，这里关联到了故事版。\n<img src=03_1.png>\n这里注意到右上角是一个Custom Class，说明故事版是可以关联自定义类的，这里就把Cell关联进来了。\n\n然后还是在Main.storyboard中，给cell里面的botton添加了一个点击事件给控制器：\n```Swift\n@IBAction func playVideoButtonDidTouch(_ sender: AnyObject) {\n        let path = Bundle.main.path(forResource: \"emoji zone\", ofType: \"mp4\")\n        \n        playerView = AVPlayer(url: URL(fileURLWithPath: path!))\n        \n        playViewController.player = playerView\n        \n        // 知识点：尾随闭包\n        // 在使用尾随闭包时，你不用写出它的参数标签\n        // 如果闭包表达式是函数或方法的唯一参数，则当你使用尾随闭包时，你甚至可以把 () 省略掉\n        // 完整形式如下：\n        //self.present(playViewController, animated: true, completion: {\n        //    self.playViewController.player?.play()\n        //})\n        self.present(playViewController, animated: true) {\n            self.playViewController.player?.play()\n        }\n    }\n }\n```\n这里给系统的控制器设置了一个AVPlayer，AVPlayer里面设置了URL，这样实现了播放视频效果。\n\n## 4 摄像头\n\n### 4.1 效果预览\n\n<img src=snapchatmenu.gif>\n\n### 4.2 UI\n这里主要是一个横滑的UIScrollView。\n长度设置了屏幕的3倍，第一块放置一个UIImageView，中间放置摄像头，最后一块也放置了一个UIImageView。\n\n这里左侧的视图，采用了xib的方式来创建。\n我个人理解，xib的方式有点类似Android的xml，因为我本身是学Android，希望大家原谅我这样比喻。xib也是很直观,可以看到效果，而且也可以挂载到某个具体的UIView上。\n\n左侧的xib是这样的：\n<img src=04_1.png>\n\n右侧的xib是这样的：\n<img src=04_2.png>\n\n中间的就是一个控制器来的,当然这个控制器也是可以关联xib的。\n如何关联的？\n这里有一个CameraView.xib，它的File's Owner是CameraView，这样就关联起来了。所以再CameraView.swift里面操作的都是针对这个xib的逻辑处理。\n\n重点看下如何显示摄像头的吧：\n首先是UI关联：\n```\n@IBOutlet weak var cameraView: UIView!\n```\n这个应该是拖进来的。\n\n然后就是几个关键的类：\n```Swift\n var captureSession : AVCaptureSession?\n var stillImageOutput : AVCaptureStillImageOutput?\n var previewLayer : AVCaptureVideoPreviewLayer?\n```\n\n然后是将要显示的时候逻辑处理：\n```Swift\noverride func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n        \n        captureSession = AVCaptureSession()\n        // 已经不能再使用了\n        // captureSession?.sessionPreset = AVCaptureSessionPreset1920x1080\n        captureSession?.sessionPreset = AVCaptureSession.Preset.hd1920x1080\n        let backCamera = AVCaptureDevice.devices(for: .video).first!\n        // 已经不能再使用了\n        // let backCamera = AVCaptureDevice.defaultDevice(withMediaType: AVMediaTypeVideo)\n        var error : NSError?\n        var input: AVCaptureDeviceInput!\n        \n        do {\n            input = try AVCaptureDeviceInput(device: backCamera) }\n        catch let error1 as NSError {\n            error = error1\n            input = nil\n        }\n        \n        if (error == nil && captureSession?.canAddInput(input) != nil) {\n            \n                captureSession?.addInput(input)\n                \n                stillImageOutput = AVCaptureStillImageOutput()\n                stillImageOutput?.outputSettings = [AVVideoCodecKey : AVVideoCodecJPEG]\n                \n            if let stillImageOutputTemp = stillImageOutput {\n                if captureSession?.canAddOutput(stillImageOutputTemp) != nil {\n                    captureSession?.addOutput(stillImageOutputTemp)\n                    if let captureSessionTemp = captureSession {\n                        previewLayer = AVCaptureVideoPreviewLayer(session: captureSessionTemp)\n                        previewLayer?.videoGravity = AVLayerVideoGravity.resizeAspect\n                        // 已经废弃不用了\n                        // previewLayer?.videoGravity = AVLayerVideoGravityResizeAspect\n                        previewLayer?.connection?.videoOrientation = AVCaptureVideoOrientation.portrait\n                        cameraView.layer.addSublayer(previewLayer!)\n                        captureSession?.startRunning()\n                    }\n                }\n            }\n        }\n        \n    }\n```\n主要是初始化了一个AVCaptureSession，然后又创建了一个AVCaptureDeviceInput来接收输入流，这样利用session.addInput，将输入流给input，然后搞一个输出流AVCaptureStillImageOutput，来接收captureSession.addOutPut，这样最后我们再创建一个 预览类叫做AVCaptureVideoPreviewLayer，里面放session，这样就得到一个Layer了。\n\n这个Layer我们就可以加到普通的UIView上了。\n\n### 4.3 根控制器\n\n先定义一个UIScollView:\n```Swift\n\nclass ViewController: UIViewController {\n    \n\n    @IBOutlet weak var scrollView: UIScrollView!\n```\n初始化添加子View，3块布局给它add进去：\n```Swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    \n    // 已经废弃了，使用prefersStatusBarHidden属性返回设置的值\n    // UIApplication.shared.isStatusBarHidden = true\n    \n    let screenWidth = UIScreen.main.bounds.width\n    let screenHeight = UIScreen.main.bounds.height\n    let leftView: UIViewController = UINib(nibName: \"LeftView\", bundle: nil).instantiate(withOwner: nil, options: nil)[0] as! UIViewController\n    let centerView: CameraView = CameraView(nibName: \"CameraView\", bundle: nil)\n    let rightView: RightView = RightView(nibName: \"RightView\", bundle: nil)\n    \n    leftView.view.frame = CGRect(x: 0, y: 0, width: screenWidth-200, height: screenHeight)\n    centerView.view.frame = CGRect(x: screenWidth, y: 0, width: screenWidth, height: screenHeight)\n    rightView.view.frame = CGRect(x: 2*screenWidth, y: 0, width: screenWidth, height: screenHeight)\n\n    self.scrollView.addSubview(leftView.view)\n    self.scrollView.addSubview(rightView.view)\n    self.scrollView.addSubview(centerView.view)\n    self.scrollView.contentSize = CGSize(width: screenWidth * 3, height: screenHeight)\n}\n```\nframe要对应好屏幕坐标。\nscrollView的contentSize刚好对应3个屏幕大小。\n\n这里可以直接创建一个UINib作为控制器，传xib的名称给它就可以的。\n\n另外这里用到了相机，需要相机的权限声明哦：\n在info.plist文件下配置：\nPrivacy - Camera Usage Description \n\n然后Value自己随便填下就好了。\n\n## 5 传送带效果\n\n### 5.1 效果\n<img src=Carousel.gif>\n\n### 5.2 故事版关联\n\n<img src=5_1.png>\n首先Main.storyboard是在info.plist中注册的。\n然后这个首页故事版配置的控制器的Class就是代码区域表示的控制器了。\n层层关联环环相扣。\n\n### 5.3 UI\n\n这里其实就一个背景图片+一个UICollectionView。\n```Swift\nclass HomeViewController: UIViewController {\n\n    \n    @IBOutlet weak var backgroundImageView: UIImageView!\n    @IBOutlet weak var collectionView: UICollectionView!\n```\n\n### 5.4 Data\n```Swift\n// 访问权限分物种：private，fileprivate，internal，public 和 open\n    // private：只能在本类的作用域且在当前文件内能访问\n    // fileprivate：只能在当前文件内能访问\n    // internal：本module内能访问\n    // public：跨module访问但不能重写或继承\n    // open：跨module访问并且能重写或继承\n    fileprivate var interests = Interest.createInterests()\n```\n\n```Swift\nclass Interest\n{\n    // MARK: - Public API\n    var title = \"\"\n    var description = \"\"\n    var numberOfMembers = 0\n    var numberOfPosts = 0\n    var featuredImage: UIImage!\n    \n    init(title: String, description: String, featuredImage: UIImage!)\n    {\n        self.title = title\n        self.description = description\n        self.featuredImage = featuredImage\n        numberOfMembers = 1\n        numberOfPosts = 1\n    }\n    \n    // MARK: - Private\n    // dummy data\n    static func createInterests() -> [Interest]\n    {\n        return [\n            Interest(title: \"Hello there, i miss u.\", description: \"We love backpack and adventures! We walked to Antartica yesterday, and camped with some cute pinguines, and talked about this wonderful app idea. 🐧⛺️✨\", featuredImage: UIImage(named: \"hello\")!),\n            Interest(title: \"🐳🐳🐳🐳🐳\", description: \"We love romantic stories. We walked to Antartica yesterday, and camped with some cute pinguines, and talked about this wonderful app idea. 🐧⛺️✨\", featuredImage: UIImage(named: \"dudu\")!),\n            Interest(title: \"Training like this, #bodyline\", description: \"Create beautiful apps. We walked to Antartica yesterday, and camped with some cute pinguines, and talked about this wonderful app idea. 🐧⛺️✨\", featuredImage: UIImage(named: \"bodyline\")!),\n            Interest(title: \"I'm hungry, indeed.\", description: \"Cars and aircrafts and boats and sky. We walked to Antartica yesterday, and camped with some cute pinguines, and talked about this wonderful app idea. 🐧⛺️✨\", featuredImage: UIImage(named: \"wave\")!),\n            Interest(title: \"Dark Varder, #emoji\", description: \"Meet life with full presence. We walked to Antartica yesterday, and camped with some cute pinguines, and talked about this wonderful app idea. 🐧⛺️✨\", featuredImage: UIImage(named: \"darkvarder\")!),\n            Interest(title: \"I have no idea, bitch\", description: \"Get up to date with breaking-news. We walked to Antartica yesterday, and camped with some cute pinguines, and talked about this wonderful app idea. 🐧⛺️✨\", featuredImage: UIImage(named: \"hhhhh\")!),\n        ]\n    }\n}\n```\n这里创建了一个静态函数，就是数据定义了。\n\n### 5.5 绑定数据\n```Swift\nextension HomeViewController : UICollectionViewDataSource {\n    \n    func numberOfSections(in collectionView: UICollectionView) -> Int {\n        return 1\n    }\n    \n    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {\n        return interests.count\n    }\n    \n    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: Storyboard.CellIdentifier, for: indexPath) as! InterestCollectionViewCell\n        \n        cell.interest = self.interests[indexPath.item]\n        \n        return cell\n        \n    }\n}\n```\n这里就是UICollectionView的数据源了。\n对应的Cell为InterestCollectionViewCell\n> 这里注意到这个UICollectionView好像没有设置dataSource和delegate，这里看了下Main.storyboard里面，果然在右侧看到Outlets设置了dataSource和delegate都给了控制器。所以说在故事版里面是可以设置数据源和代理的。\n\n如下：\n```Swift\nclass InterestCollectionViewCell: UICollectionViewCell {\n    \n    \n    var interest: Interest! {\n        didSet {\n            updateUI()\n        }\n    }\n    \n    @IBOutlet weak var featuredImageView: UIImageView!\n    @IBOutlet weak var interestTitleLabel: UILabel!\n    \n    fileprivate func updateUI() {\n        interestTitleLabel?.text! = interest.title\n        featuredImageView?.image! = interest.featuredImage\n    }\n    \n    override func layoutSubviews() {\n        super.layoutSubviews()\n        \n        self.layer.cornerRadius = 5.0\n        self.clipsToBounds = true\n    }\n}\n```\n因为在Main.storyboard的已经关联了这个Cell，所以布局相关的都无需重新addView。\n\n上面这些代码就可以实现一个传送带效果。\n\n但是我们想要左滑，它自己能够刚好滑动到下一个屏幕，体验效果好一点的话要怎么办呢？\n\n我们想到第一个优化点：\n一张图能不能刚好占一个屏幕，增大一点padding。\n\n可以的。\n\n利用UICollectionView提供的另外一个协议可以实现。答案就是：UICollectionViewDelegateFlowLayout。\n\n```Swift\nextension HomeViewController : UICollectionViewDelegateFlowLayout {\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {\n        return CGSize(width: UIScreen.main.bounds.width - 2 * Storyboard.CellPadding, height: 450)\n    }\n\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -> CGFloat {\n        return 2 * Storyboard.CellPadding\n    }\n\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -> UIEdgeInsets {\n        return UIEdgeInsetsMake(0, Storyboard.CellPadding, 0, Storyboard.CellPadding)\n    }\n}\n```\n这里第一个sizeForItemAt方法：单个item的大小，长度为屏幕宽度-左右两个padding，高度写死450。\n这里第二个方法minimumLine: collectionView的滚动方向为水平时，这个就是item之间的最小水平间距。\n这里的第三个方法insetForSectionAt: 单个item的padding，设置上，左，右，下。\n\n第二个优化点：当滑动到一半多，自动切下一张，不足一半，切回上一张。\n也好办。\n\n```Swift\nextension HomeViewController : UIScrollViewDelegate {\n    func scrollViewWillEndDragging(_ scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer<CGPoint>) {\n        let originPoint = targetContentOffset.pointee;\n        var index = Int(originPoint.x / UIScreen.main.bounds.width)\n        let offset = Int(originPoint.x) % Int(UIScreen.main.bounds.width)\n        index += (offset > Int(UIScreen.main.bounds.width/2) ? 1 : 0)\n        targetContentOffset.pointee = CGPoint(x: index * Int(UIScreen.main.bounds.width) , y: 0)\n    }\n}\n```\n继续扩展下这个控制器，这里面，判断了offset在停止滑动后的逻辑。\n\n## 6 定位\n\n### 6.1 效果\n<img src=mylocation.gif>\n\n### 6.2 UI\n这个UI比较简单，一个UILabel，一个按钮。\n\n这个按钮的点击事件直接通过故事版链接到了控制器，所以控制器无需有这个UIView，有这个点击事件就行了。\n<img src=06_1.png>\n\n### 6.3 如何定位\n首先声明一个全局变量：\n```Swift\n  // 强制自动解包，可以赋值为nil，为nil后再调用会报错\n    // 建议定义为：\n    // var locationManager: CLLocationManager\n    var locationManager: CLLocationManager!\n```\n\n开始定位：\n```Swift\n@IBAction func myLocationButtonDidTouch(_ sender: AnyObject) { \n    locationManager = CLLocationManager()\n    locationManager.delegate = self\n    locationManager.desiredAccuracy = kCLLocationAccuracyBest\n    locationManager.requestAlwaysAuthorization()\n    locationManager.startUpdatingLocation()   \n}\n```\n\n因为这里引入了CLLocationManager，那么在项目层级发现CoreLocation.framework自动引入进来了。\n\n直接这样还不够，还需要设置下协议才行。因为这里我们delegate设置了self。\n这里我们同样可以新建一个Delegate，本质上扩展控制器，当然也可以直接写在控制器里面，都可以，最好是分一个文件，可读性会强一点。\n\n```Swift\nimport Foundation\nimport CoreLocation\n\nextension ViewController : CLLocationManagerDelegate {\n    \n    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {\n        \n        self.locationLabel.text = \"Error while updating location \" + error.localizedDescription\n        \n    }\n    \n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        CLGeocoder().reverseGeocodeLocation(locations.first!) { (placemarks, error) in\n            guard error == nil else {\n                self.locationLabel.text = \"Reverse geocoder failed with error\" + error!.localizedDescription\n                return\n            }\n            if placemarks!.count > 0 {\n                let pm = placemarks!.first\n                self.displayLocationInfo(pm)\n            } else {\n                self.locationLabel.text = \"Problem with the data received from geocoder\"\n            }\n        }\n    }\n    \n    func displayLocationInfo(_ placemark: CLPlacemark?) {\n        if let containsPlacemark = placemark {\n            //stop updating location to save battery life\n            locationManager.stopUpdatingLocation()\n            \n            let locality = (containsPlacemark.locality != nil) ? containsPlacemark.locality : \"\"\n            let postalCode = (containsPlacemark.postalCode != nil) ? containsPlacemark.postalCode : \"\"\n            let administrativeArea = (containsPlacemark.administrativeArea != nil) ? containsPlacemark.administrativeArea : \"\"\n            let country = (containsPlacemark.country != nil) ? containsPlacemark.country : \"\"\n            \n            self.locationLabel.text = postalCode! + \" \" + locality!\n            \n            self.locationLabel.text?.append(\"\\n\" + administrativeArea! + \", \" + country!)\n        }\n        \n    }\n}\n```\n\n## 7 下拉刷新\n\n### 7.1 效果\n<img src=07.gif>\n\n### 7.2 变量声明\n```Swift\nclass ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate {\n    \n    var index = 0\n    let cellIdentifer = \"NewCellIdentifier\"\n    \n    let favoriteEmoji = [\"🤗🤗🤗🤗🤗\", \"😅😅😅😅😅\", \"😆😆😆😆😆\"]\n    let newFavoriteEmoji = [\"🏃🏃🏃🏃🏃\", \"💩💩💩💩💩\", \"👸👸👸👸👸\", \"🤗🤗🤗🤗🤗\", \"😅😅😅😅😅\", \"😆😆😆😆😆\" ]\n    var emojiData = [String]()\n    var tableView: UITableView!\n    \n    var refreshControl = UIRefreshControl()\n    var navBar: UINavigationBar = UINavigationBar(frame: CGRect(x: 0, y: 0, width: 375, height: 64))\n```\n这里继承了UIViewController，然后再Main.storyboard中配置了首页的控制器就是这个，这样就直接启动这个控制器了。\n\n这里定义了初始化数据3条，更新后的6条。\n模拟刷新后的数据变化。\n\n这里不是再故事版里面加视图，直接在代码里面new了。\n\n### 7.3 viewDidLoad初始化\n```Swift\n override func viewDidLoad() {\n        super.viewDidLoad()\n        // 这里new一个UITableView\n        tableView = UITableView(frame: self.view.bounds, style: .plain)\n        \n        // 初始数据\n        emojiData = favoriteEmoji\n        let emojiTableView = tableView\n        \n        // 数据源设置，注册Cell，这里的Cell比较简单，直接用了UITableViewCell可满足\n        emojiTableView?.backgroundColor = UIColor(red:0.092, green:0.096, blue:0.116, alpha:1)\n        emojiTableView?.dataSource = self\n        emojiTableView?.register(UITableViewCell.self, forCellReuseIdentifier: cellIdentifer)\n        \n        // 因为TableView是UIScrollViw，这里也有这个refreshControl的属性\n        tableView.refreshControl = self.refreshControl\n        self.refreshControl.addTarget(self, action: #selector(ViewController.didRoadEmoji), for: .valueChanged)\n        \n        // 自定义刷新器 这里的loading效果猜测是refreshControl自带的\n        self.refreshControl.backgroundColor = UIColor(red:0.113, green:0.113, blue:0.145, alpha:1)\n        let attributes = [NSAttributedStringKey.foregroundColor: UIColor.white]\n        // 这里是loading下方的文案\n        self.refreshControl.attributedTitle = NSAttributedString(string: \"Last updated on \\(Date())\", attributes: attributes)\n        self.refreshControl.tintColor = UIColor.white\n        \n        self.title = \"emoji\"\n        self.navBar.barStyle = UIBarStyle.blackTranslucent\n        \n        emojiTableView?.rowHeight = UITableViewAutomaticDimension\n        emojiTableView?.estimatedRowHeight = 60.0\n        emojiTableView?.tableFooterView = UIView(frame: CGRect.zero)\n        emojiTableView?.separatorStyle = UITableViewCellSeparatorStyle.none\n        \n        // 代码add子View\n        self.view.addSubview(emojiTableView!)\n        self.view.addSubview(navBar)\n    }\n```\n这里通过在代码里面new一个UITableView方式，也是可以实现UI效果。\n\n### 7.4 设置代理和数据源\n\n```Swift\nfunc tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        return emojiData.count\n    }\n    \nfunc numberOfSections(in tableView: UITableView) -> Int {\n    return 1\n}\n\n\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifer)! as UITableViewCell\n    cell.textLabel!.text = self.emojiData[indexPath.row]\n    cell.textLabel!.textAlignment = NSTextAlignment.center\n    cell.textLabel!.font = UIFont.systemFont(ofSize: 50)\n    cell.backgroundColor = UIColor.clear\n    cell.selectionStyle = UITableViewCellSelectionStyle.none\n\n    return cell\n}\n```\n这里给Cell设置数据了。\n\n### 7.5 下拉监听\n\n```Swift\n@objc func didRoadEmoji() {\n    DispatchQueue.main.asyncAfter(deadline:DispatchTime.now() + 3 ) {\n        self.emojiData = [self.newFavoriteEmoji,self.favoriteEmoji][self.index]\n        self.tableView.reloadData()\n        self.refreshControl.endRefreshing()\n        self.index = (self.index + 1) % 2\n    }\n}\n```\nDispatchQueue.main.asyncAfter： 主线程执行延迟任务方法。\n这里延迟3s后，去更新数据。然后控制器取消刷新。\n\n## 8 炫彩音乐\n\n### 8.1 效果\n\n<img src=randomMusicColor.gif>\n\n### 8.2 全局变量定义\n\n```Swift\nvar audioPlayer = AVAudioPlayer()\n    \nlet gradientLayer = CAGradientLayer()\n\nvar timer : Timer?\n\nvar backgroundColor: (red: CGFloat, green: CGFloat,blue: CGFloat,alpha: CGFloat)! {\n    didSet {\n        let color1 = UIColor(red: backgroundColor.blue,\n                                green: backgroundColor.green,\n                                blue: 0,\n                                alpha: backgroundColor.alpha).cgColor\n        let color2 = UIColor(red: backgroundColor.red,\n                                green: backgroundColor.green,\n                                blue: backgroundColor.blue,\n                                alpha: backgroundColor.alpha).cgColor\n        gradientLayer.colors = [color1, color2]\n    }\n}\n```\n这里第一个是AVAudioPlayer，负责音频播放。\n这里第二个类是CAGradientLayer，负责渐变色渲染。\ntimer是定时器。\nbackgroundColor背景色，如果任何地方更改后，触发渐变色颜色变化。\n\n### 8.3 播放音乐\n```Swift\n@IBAction func playMusicButtonDidTouch(_ sender: AnyObject) {\n        \n    //play bg music\n    let bgMusic = URL(fileURLWithPath: Bundle.main.path(forResource: \"Ecstasy\", ofType: \"mp3\")!)\n    \n    do {\n        try AVAudioSession.sharedInstance().setCategory(AVAudioSessionCategoryPlayback)\n        try AVAudioSession.sharedInstance().setActive(true)\n        try audioPlayer = AVAudioPlayer(contentsOf: bgMusic)\n        \n        audioPlayer.prepareToPlay()\n        audioPlayer.play()\n        \n    }\n    catch let audioError as NSError {\n        print(audioError)\n    }\n    \n    if (timer == nil) {\n        timer = Timer.scheduledTimer(timeInterval: 0.2, target: self, selector: #selector(ViewController.randomColor), userInfo: nil, repeats: true)\n    }\n    \n    let redValue = CGFloat(drand48())\n    let blueValue =  CGFloat(drand48())\n    let greenValue = CGFloat(drand48())\n    \n    self.view.backgroundColor = UIColor(red: redValue, green: greenValue, blue: blueValue, alpha: 1.0)\n    \n    //graditent color\n    gradientLayer.frame = view.bounds\n    gradientLayer.startPoint = CGPoint(x: 0, y: 0)\n    gradientLayer.endPoint = CGPoint(x: 1, y: 1)\n    \n    self.view.layer.addSublayer(gradientLayer)\n    \n}\n```\n这里先利用AVAudioSession的单例类设置Active，然后利用AVAudioPlayer播放本地音乐。\n\n然后后面搞了0.2s刷新的周期定时器。每次会执行这个函数：\n```Swift\n@objc func randomColor() {\n    \n    let redValue = CGFloat(drand48())\n    let blueValue =  CGFloat(drand48())\n    let greenValue = CGFloat(drand48())\n    \n    \n    backgroundColor = (redValue, blueValue, greenValue, 1)\n    \n}\n```\n这里红蓝绿会随机获取一个值，生成一个颜色值。同时会更新渐变层变更，这样背景就随机变化了。\n\n## 9 图片缩放效果\n\n### 9.1 效果\n<img src=09.gif>\n\n### 9.2 布局构造\n这里看了下Main.storyboard\n貌似是在ScrollView里面放了一个ImageView哦。\n\n这里有个细节，就是背景有点毛玻璃效果。\n其实是这样的，它在Main.storyboard底部设置了一张UIImageView，其实就是这张图片。\n然后再搞了一个UIVisualEffectView覆盖再上面，就形成了一种毛玻璃效果。\n\n回到控制器里面，这里无非就是两个视图，并且把这个Constraint约束也加进来了，有4个约束，顶部约束，头部约束，底部约束和尾部约束。\n\n```Swift\n@IBOutlet weak var scrollView: UIScrollView!\n@IBOutlet weak var imageView: UIImageView!\n@IBOutlet weak var imageViewTopConstraint: NSLayoutConstraint!\n@IBOutlet weak var imageViewTrailingConstraint: NSLayoutConstraint!\n@IBOutlet weak var imageViewBottomConstraint: NSLayoutConstraint!\n@IBOutlet weak var imageViewLeadingConstraint: NSLayoutConstraint!\n```\n\n### 9.3 代码实现\n\n首先在初始化里面配置了一个mask:\n```Swift\n scrollView.autoresizingMask = [.flexibleWidth, .flexibleHeight]\n```\n这个是自动调整尺寸设置。\n\n其实ScrollView本来就支持缩放的：\n> 在iOS中，滚动视图UIScrollView用于查看大于屏幕的内容。Scroll View有两个主要目的：\n让用户拖动视图以显示更多内容区域。\n让用户使用捏合手势放大或缩小所显示的内容。\n\n这里需要关注一个生命周期函数：viewWillLayoutSubviews\n> 有以下几种情况会调用（init初始化不会触发layoutSubviews）\n1、addSubview会触发viewWillLayoutSubviews\n2、设置self.view及子视图的frame.size会触发layoutSubviews，当然前提是frame.size的值设置前后发生了变化,注意，此处不是origin，呼应官方文档上的边界发生变化\n3、滚动一个UIScrollView(该scrollview有子视图的时候)会触发layoutSubviews\n4、横竖屏幕切换会触发\n\n这里最为关键的就是这个 viewWillLayoutSubviews函数和viewForZooming了,如果没有这个代码，无法支持缩放效果!\n```Swift\n//每次控制器更新其子视图时，更新最小缩放比例\noverride func viewWillLayoutSubviews() {\n    super.viewWillLayoutSubviews()\n    updateMinZoomScaleForSize(view.bounds.size)\n}\n\n//计算scrollView的缩放比例，缩放比例为1表示内容以正常大小显示；缩放比例小于1表示容器内的内容缩小，缩放比例大于1表示放大容器内的内容\nfileprivate func updateMinZoomScaleForSize(_ size: CGSize)\n{\n    //要获得最小的缩放比例，首先计算所需的缩放比例，以便根据其宽度在scrollView中紧贴imageView\n    let widthScale = size.width / imageView.bounds.width\n    let heightScale = size.height / imageView.bounds.height\n    //选取宽度和高度比例中最小的那个,设置为minimumZoomScale\n    let minScale = min(widthScale,heightScale)\n    \n    scrollView.minimumZoomScale = minScale\n    scrollView.maximumZoomScale = 3.0\n    scrollView.zoomScale = minScale\n}\n```\n这样ScrollView就有一个最小和最大缩放比例了。\n\n另外还有一个协议：\n```Swift\nfunc viewForZooming(in scrollView: UIScrollView) -> UIView? {\n    //当手势动作发生时，scrollView告诉控制器要放大或缩小子视图imageView\n    return imageView\n}\n```\n必须要有viewForZooming，这个作用就是谁可以放大或缩小。\n\nviewForZooming+viewWillLayoutSubviews，两者结合才能实现子View缩放效果。\n\n两位还有一个scrollViewDidZoom方法, 当scrollView缩放时调用,在缩放过程中会被多次调用：\n```Swift\nfunc scrollViewDidZoom(_ scrollView: UIScrollView) {\n    updateConstraintsForSize(view.bounds.size)\n}\n\n//当scrollView的内容大小小于边界时，内容将放置在左上角而不是中心，updateConstraintForSize方法处理这个问题；通过调整图像视图的布局约束。\nfileprivate func updateConstraintsForSize(_ size: CGSize) {\n    \n    ////将图像垂直居中，从视图高度减去imageView的高度并分成两半，这个值用作顶部和底部imageView的约束\n    let yOffset = max(0, (size.height - imageView.frame.height) / 2)\n    imageViewTopConstraint.constant = yOffset\n    imageViewBottomConstraint.constant = yOffset\n    \n    ////根据宽度计算imageView前后约束的偏移量\n    let xOffset = max(0, (size.width - imageView.frame.width) / 2)\n    imageViewLeadingConstraint.constant = xOffset\n    imageViewTrailingConstraint.constant = xOffset\n    \n    view.layoutIfNeeded()\n}\n```\n\n另外还有其它的代理方法如下：\n> func scrollViewDidScroll(_ scrollView: UIScrollView)\nscrollView滚动时调用，在滚动过程中会多次调用\n\n> func scrollViewWillBeginDragging(_ scrollView: UIScrollView)\n将要开始拖拽时调用\n\n> func scrollViewWillEndDragging(_ scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer<CGPoint>)\n将要停止拖拽时 velocity:加速度 向左滑动 x为负值，否则为正值 向上滚动为y为负值否则为正值；targetContentOffset:滚动停止时的ContentOffset\n\n> func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool)\n停止拖拽时调用， willDecelerate:停止拖拽时是否要减速，若值为false表示已经停止减速，也就意味着滚动已停止，此时不会调用scrollViewWillBeginDecelerating和scrollViewDidEndDecelerating;若值为true，则代表scrollView正在减速滚动\n\n> func scrollViewWillBeginDecelerating(_ scrollView: UIScrollView)\n开始减速的时候调用(也就是松开手指时)，在拖拽滚动的时候，如果松手时已经停止滚动则不会调用\n\n> func scrollViewDidEndDecelerating(_ scrollView: UIScrollView)\n停止减速的时候调用（也就是停止滚动的时候调用），在拖拽滚动的时候，如果松手时已经停止滚动则不会调用\n\n> func scrollViewDidEndScrollingAnimation(_ scrollView: UIScrollView)\n当调用setContentOffset(_ contentOffset: CGPoint, animated: Bool)/scrollRectToVisible(_ rect: CGRect, animated: Bool)API并且animated参数为true时,会在scrollView滚动结束时调用。若是UITableView或者UICollectionView,调用scrollToRow也和上面一样\n\n> func viewForZooming(in scrollView: UIScrollView) -> UIView?\n放回要缩放的view，此view必须是scrollView的subview\n\n> func scrollViewDidZoom(_ scrollView: UIScrollView)\n当scrollView缩放时调用,在缩放过程中会被多次调用\n\n> func scrollViewWillBeginZooming(_ scrollView: UIScrollView, with view: UIView?)\nscrollView开始缩放时调用\n\n> func scrollViewDidEndZooming(_ scrollView: UIScrollView, with view: UIView?, atScale scale: CGFloat)\nscrollView结束缩放时调用\n\n> func scrollViewShouldScrollToTop(_ scrollView: UIScrollView) -> Bool\n是否允许点击scrollview的头部，让其滚动到最上面,若不实现此代理，则默认为true\n\n> func scrollViewDidScrollToTop(_ scrollView: UIScrollView)\n当滚动到最上面时调用\n\n## 10 视频背景\n\n### 10.1 效果\n<img src=videobg.gif>\n\n### 10.2 定义一个基类播放控制器\n\n```Swift\npublic enum ScalingMode {\n  case resize\n  case resizeAspect\n  case resizeAspectFill\n}\n```\n定义了3种缩放模式。\n\n再定义有关视频的属性：\n```Swift\n// 视频播放器\nfileprivate let moviePlayer = AVPlayerViewController()\n     \n  // 声音   \n  fileprivate var moviePlayerSoundLevel: Float = 1.0\n\n   // 播放url  \n   var contentURL: URL? {\n    didSet {\n      if let _contentURL = contentURL {\n      setMoviePlayer(_contentURL)\n      }\n    }\n  }\n\n   var videoFrame: CGRect = CGRect()\n   var startTime: CGFloat = 0.0\n   var duration: CGFloat = 0.0\n\n   // 背景\n   var backgroundColor: UIColor = UIColor.black {\n    didSet {\n      view.backgroundColor = backgroundColor\n    }\n  }\n\n  // 声音\n   var sound: Bool = true {\n    didSet {\n      if sound {\n        moviePlayerSoundLevel = 1.0\n      }else{\n        moviePlayerSoundLevel = 0.0\n      }\n    }\n  }\n  \n  // alpha\n   var alpha: CGFloat = CGFloat() {\n    didSet {\n      moviePlayer.view.alpha = alpha\n    }\n  }\n\n  // 是否重复 这里发送一个全局通知\n   var alwaysRepeat: Bool = true {\n    didSet {\n      if alwaysRepeat {\n        NotificationCenter.default.addObserver(self,\n          selector: #selector(VideoSplashViewController.playerItemDidReachEnd),\n          name: NSNotification.Name.AVPlayerItemDidPlayToEndTime,\n          object: moviePlayer.player?.currentItem)\n      }\n    }\n  }\n\n  // 填充模式\n   var fillMode: ScalingMode = .resizeAspectFill {\n    didSet {\n      switch fillMode {\n      case .resize:\n          moviePlayer.videoGravity = AVLayerVideoGravity.resize.rawValue\n      case .resizeAspect:\n          moviePlayer.videoGravity = AVLayerVideoGravity.resizeAspect.rawValue\n      case .resizeAspectFill:\n          moviePlayer.videoGravity = AVLayerVideoGravity.resizeAspectFill.rawValue\n      }\n    }\n  }\n```\n\n生命周期已经显示,添加子View和视频view：\n```Swift\n  override func viewDidAppear(_ animated: Bool) {\n    moviePlayer.view.frame = videoFrame\n    moviePlayer.showsPlaybackControls = false\n    view.addSubview(moviePlayer.view)\n    view.sendSubview(toBack: moviePlayer.view)\n  }\n```\n\n生命周期将要消失，移除通知：\n```Swift\n  override func viewWillDisappear(_ animated: Bool) {\n    super.viewDidDisappear(animated)\n    NotificationCenter.default.removeObserver(self)\n  }\n```\n\n设置播放器：\n```Swift\n fileprivate func setMoviePlayer(_ url: URL){\n    let videoCutter = VideoCutter()\n    videoCutter.cropVideoWithUrl(videoUrl: url, startTime: startTime, duration: duration) { (videoPath, error) -> Void in\n      if let path = videoPath as URL? {\n        DispatchQueue.main.async {\n            self.moviePlayer.player = AVPlayer(url: path)\n            self.moviePlayer.player?.play()\n            self.moviePlayer.player?.volume = self.moviePlayerSoundLevel\n        }\n      }\n    }\n  }\n```\n\n播放视频，前面监听视频播放完成消息，然后走这个方法，可实现重复播放效果：\n```Swift\n  @objc func playerItemDidReachEnd() {\n    moviePlayer.player?.seek(to: kCMTimeZero)\n    moviePlayer.player?.play()\n  }\n```\n\n### 10.3 实现视频背景效果控制器\n\n```Swift\n @IBOutlet weak var loginButton: UIButton!\n    @IBOutlet weak var signupButton: UIButton!\n```\n这里搞2个View。\n\n```Swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    setupVideoBackground()\n    \n    loginButton.layer.cornerRadius = 4\n    signupButton.layer.cornerRadius = 4\n    \n}\n\nfunc setupVideoBackground() {\n    \n    let url = URL(fileURLWithPath: Bundle.main.path(forResource: \"moments\", ofType: \"mp4\")!)\n    \n    videoFrame = view.frame\n    fillMode = .resizeAspectFill\n    alwaysRepeat = true\n    sound = true\n    startTime = 2.0\n    alpha = 0.8\n    \n    contentURL = url\n    // view.isUserInteractionEnabled = false\n    \n}\n```\n这里初始化，设置视频背景，设置按钮圆角。\n\n### 10.4 视频剪切工具\n前面设置播放器，用到了一个VideoCutter类，\n这里：\n```Swift\n fileprivate func setMoviePlayer(_ url: URL){\n    let videoCutter = VideoCutter()\n    videoCutter.cropVideoWithUrl(videoUrl: url, startTime: startTime, duration: duration) { (videoPath, error) -> Void in\n      if let path = videoPath as URL? {\n        DispatchQueue.main.async {\n            self.moviePlayer.player = AVPlayer(url: path)\n            self.moviePlayer.player?.play()\n            self.moviePlayer.player?.volume = self.moviePlayerSoundLevel\n        }\n      }\n    }\n  }\n```\n这里其实是根据startTime和duration来剪切目标视频url，返回一个新的videoPath，这里再重新播放的。\n\n需要看下如何剪切的：\n```Swift\nextension String {\n  var convert: NSString { return (self as NSString) }\n}\n\n class VideoCutter: NSObject {\n\n  /**\n  Block based method for crop video url\n  \n  @param videoUrl Video url\n  @param startTime The starting point of the video segments\n  @param duration Total time, video length\n\n  */\n   func cropVideoWithUrl(videoUrl url: URL, startTime: CGFloat, duration: CGFloat, completion: ((_ videoPath: URL?, _ error: NSError?) -> Void)?) {\n    DispatchQueue.global(qos: DispatchQoS.QoSClass.default).async {\n        let asset = AVURLAsset(url: url, options: nil)\n        let exportSession = AVAssetExportSession(asset: asset, presetName: \"AVAssetExportPresetHighestQuality\")\n        let paths: NSArray = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true) as NSArray\n        var outputURL = paths.object(at: 0) as! String\n        let manager = FileManager.default\n        // 异常处理：\n        // try?: 将错误转化成可选异常,有错误发生时返回nil\n        // try!: 禁用错误传递，当确认无异常发生时使用，否则可能会发生运行时异常\n        // defer: 在即将离开当前代码块时执行一系列语句,延迟执行的语句不能包含任何控制转移语句，例如break、return语句，或是抛出一个错误。\n        // defer语句是从后往前执行\n        do {\n            try manager.createDirectory(atPath: outputURL, withIntermediateDirectories: true, attributes: nil)\n        } catch _ {\n        }\n        outputURL = outputURL.convert.appendingPathComponent(\"output.mp4\")\n        do {\n            try manager.removeItem(atPath: outputURL)\n        } catch _ {\n        }\n        if let exportSession = exportSession as AVAssetExportSession? {\n            exportSession.outputURL = URL(fileURLWithPath: outputURL)\n            exportSession.shouldOptimizeForNetworkUse = true\n            exportSession.outputFileType = AVFileType.mp4\n            let start = CMTimeMakeWithSeconds(Float64(startTime), 600)\n            let duration = CMTimeMakeWithSeconds(Float64(duration), 600)\n            let range = CMTimeRangeMake(start, duration)\n            exportSession.timeRange = range\n           \n            exportSession.exportAsynchronously {\n                switch exportSession.status {\n                case AVAssetExportSessionStatus.completed:\n                    completion?(exportSession.outputURL, nil)\n                case AVAssetExportSessionStatus.failed:\n                    print(\"Failed: \\(String(describing: exportSession.error))\")\n                case AVAssetExportSessionStatus.cancelled:\n                    print(\"Failed: \\(String(describing: exportSession.error))\")\n                default:\n                    print(\"default case\")\n                }\n            }\n        }\n    }\n  }\n}\n```\n这是个工具，简单看下就行。\n\n\n## 11 总结\n* 1.第一个是计时器demo，界面很简单，主要学会Timer用法，每次继续其实也是new了一个Timer，Timer的作用只是更新，数值是我们自己记录的。\n* 2.第二个改变字体，主要学会字体文件放在根目录，xCode会自动识别，然后设置字体可以通过UILabel的Font属性，其次学会UiTableView用法，懂得设置数据源和代理。\n* 3.本地视频，当然就是学会AVPlayer的用法，还要用到系统的一个控制器。\n* 4.摄像头，主要学会Session用法，input，outPut设置，通过设置AV预览图设置给UIView，达成预览效果，另外学会水平ScrollView可实现类似分页效果，当然坐标要按照屏幕宽度设置下。\n* 5.传送带效果，学会设置UICollectionView和UIScrollView的代理，做到良好的用户体验效果，滑动到半屏和不足半屏的考虑。另外学会了xib布局方式，可以绑定控制器。\n* 6.定位，学会使用系统提供的定位Api，在代理里面处理自己的逻辑。\n* 7.下拉刷新，是UIScrollView里面的refreshControl提供的功能，自带了loading效果，可以自行添加文案。\n* 8.炫彩音乐，主要学会音频播放，以及随机函数的用法，还有渐变色调用方式。\n* 9.图片缩放效果，这个主要是UIScrollView的子View这种方式提供的缩放效果，主要还是针对代理方法做一些调整。\n* 10.视频背景，这个主要就是学会构造一个基类控制器，可实现播放视频效果，通过配置不同参数丰富这个基类，然后另外就是学会视频剪切。\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/iOS-swift-3天30个Swift项目之第一天.md","raw":"---\ntitle: iOS swift 3天30个Swift项目之第一天\ndate: 2023-02-03 09:44:26\nop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- 30个Swift项目\ncategories:\n- iOS\n---\n\n> 参考项目：https://github.com/soapyigu/Swift-30-Projects \n\n## 1 计时器\n\n首先看下效果吧。\n<img src=01.gif>\n\n### 1.1 主要功能\n点击播放按钮，数字开始增加；\n点击暂停按钮，数字停止增加；\n点击“Reset”，数值置为0；\n\n### 1.2 UI\n这里UI采用storyboard来实现。因为比较简单，就4个控件，拖进去故事版即可。\n<img src=1.2.png>\n\n### 1.3 功能实现\n\nui声明，故事版可以直接拖进相关类中，自动生成：\n```Swift\n@IBOutlet weak var playBtn: UIButton!\n@IBOutlet weak var pauseBtn: UIButton!\n@IBOutlet weak var timeLabel: UILabel!\n```\n显示的数字声明：\n```Swift\n // 浮点数默认是Double类型，若要使用Float，需要显示声明\n    // var counter: Float = 0.0\n    var counter: Float = 0.0 {\n        // 属性观察器 \n        didSet {\n            timeLabel.text = String(format: \"%.1f\", counter)\n        }\n    }\n```\n这里的属性观察器是监听这个值变更情况，如果某个地方变更了这个值，那么会走里面的didSet回调。\n\n```Swift\n    // 知识点：存储属性和计算属性\n    override var preferredStatusBarStyle: UIStatusBarStyle {\n        // 只读计算属性，可以去掉get和花括号\n//        get {\n//            return UIStatusBarStyle.lightContent\n//        }\n        return UIStatusBarStyle.lightContent\n    }\n```\n上面的代码是控制状态栏图标颜色为亮色（白色），默认是黑色。\n\n\n```Swift\n  // 给予timer一个默认值，这样timer就不会为Optional,\n    // 后续可以不用再解包\n    // var timer = Timer()\n    \n    // 这样定义可以在不用timer时回收内存\n    var timer: Timer? = Timer()\n    var isPlaying = false\n```\n这里定义了定时器，和定时器Flag。\n\n```Swift\noverride func viewDidLoad() {\n        super.viewDidLoad()\n        // 符合LosslessStringConvertible协议的，\n        // 都可以直接初始化一个String对象\n        // timeLabel.text = String(counter)\n        \n        // 改成使用属性观察器监控和响应属性值的变化\n        counter = 0.0\n    }\n```\n这里在初始化时设置数值为0.0。\n\n```Swift\n  @IBAction func resetButtonDidTouch(_ sender: UIButton) {\n        if let timerTemp = timer {\n            timerTemp.invalidate()\n        }\n        timer = nil\n        isPlaying = false\n        counter = 0\n        playBtn.isEnabled = true\n        pauseBtn.isEnabled = true\n    }\n```\n上面是重置按钮点击事件。\n\n这个可以在故事版中右键视图，在Touch up inside中拖动到代码里面自动生成方法，具体实现逻辑由我们自行添加。这里是将定时器置为nil，然后将播放和暂停状态都设置为可点击状态。\n\n```Swift\n@IBAction func playButtonDidTouch(_ sender: UIButton) {\n        playBtn.isEnabled = false\n        pauseBtn.isEnabled = true\n        // 调用实例的方法时建议用self.UpdateTimer,\n        // 不建议使用ViewController.UpdateTimer\n        // 因为若方法定义成了类方法，第二种方式编译器不会报错。\n        timer = Timer.scheduledTimer(timeInterval: 0.1, target:self, selector: #selector(self.UpdateTimer), userInfo: nil, repeats: true)\n        isPlaying = true\n    }\n```\n这里是播放按钮的实现逻辑，这里面相当于new了一个Timer。间隔0.1s后刷新，然后会走一个selector里面的updateTimer方法更新数值。\n\n```\n   @objc func UpdateTimer() {\n        counter = counter + 0.1\n    }\n```\n这里变更数字，然后数值变化引起前面定义的didSet刷新，导致Lable数值更新。\n\n```Swift\n @IBAction func pauseButtonDidTouch(_ sender: UIButton) {\n        playBtn.isEnabled = true\n        pauseBtn.isEnabled = false\n        if let timerTemp = timer {\n            timerTemp.invalidate()\n        }\n        timer = nil\n        isPlaying = false\n        \n    }\n```\n这里是暂停按钮实现逻辑，将按钮置灰，定时器invalidate，然后定时器置空。\n\n## 2 自定义字体\n\n### 2.1 效果\n\n<img src=Customfont.gif>\n\n### 2.2 字体文件\n\n首先放置在根目录下：\n<img src=02_1.png>\n\n这里XCode会自动识别出字体文件：\n<img src=02_2.png>\n\n### 2.3 实现细节\n\n控制器可直接实现UITableViewDelegate, UITableViewDataSource,也可以扩展，最好是扩展，可读性好一点。\n```Swift\nclass ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource {\n    \n    static let identifier = \"FontCell\"\n```\n\n然后定义下数据和字体名称：\n```Swift\n   var data = [\"MFTongXin 30 Days Swift\", \"MFJinHei 这些字体特别适合打「奋斗」和「理想」\",\n                \"MFZhiHei 谢谢「造字工房」，本案例不涉及商业使用\", \"Zapfino 使用到造字工房劲黑体，致黑体，童心体\",\n                \"Gaspar呵呵，再见🤗 See you next Project\", \"微博 @Allen朝辉\",\n                \"测试测试测试测试测试测试\", \"123\", \"Alex\", \"@@@@@@\"]\n    \n    var fontNames = [\"MFTongXin_Noncommercial-Regular\",\n                     \"MFJinHei_Noncommercial-Regular\",\n                     \"MFZhiHei_Noncommercial-Regular\",\n                     \"Zapfino\",\n                     \"Gaspar Regular\"]\n```\n\n然后定义下UI：\n```Swift\n  @IBOutlet weak var changeFontLabel: UILabel!\n    @IBOutlet weak var fontTableView: UITableView!\n```\n\n然后定义下选择字体索引：\n```\n var fontRowIndex = 0\n```\n\n生命周期初始化：\n```Swift\n   \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // 在storyboard中直接设置了\n        // fontTableView.dataSource = self\n        // fontTableView.delegate = self\n        \n        // 使用手势加Label替换button\n        changeFontLabel.layer.cornerRadius = 50\n        changeFontLabel.layer.masksToBounds = true\n        // 设置为true才能响应手势\n        changeFontLabel.isUserInteractionEnabled = true\n        let gesture = UITapGestureRecognizer(target: self,\n                                             action: #selector(changeFontDidTouch(_:)))\n        changeFontLabel.addGestureRecognizer(gesture)\n    }\n\n     @objc func changeFontDidTouch(_ sender: AnyObject) {\n        \n        fontRowIndex = (fontRowIndex + 1) % 5\n        print(fontNames[fontRowIndex])\n        fontTableView.reloadData()\n        \n    }\n```\n这里主要是给一个按钮添加了手势，手势设置了action，然后相当于给按钮添加点击事件，方法有很多，可以直接故事版添加事件，也可以这种手势添加点击事件。\n\n下面是TableView的协议实现，这里Cell用了默认的，无需新建Cell。\n```Swift\n func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n        return 35\n    }\n    \n    func numberOfSections(in tableView: UITableView) -> Int {\n        return 1\n    }\n    \n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n//        let cell = fontTableView.dequeueReusableCell(withIdentifier: ViewController.identifier)\n        let cell = fontTableView.dequeueReusableCell(withIdentifier: ViewController.identifier, for: indexPath)\n        let text = data[indexPath.row]\n       \n        cell.textLabel?.text = text\n        cell.textLabel?.textColor = indexPath.row != fontRowIndex ? UIColor.white : UIColor.blue\n        cell.textLabel?.font = UIFont(name: self.fontNames[fontRowIndex], size:16)\n        \n        return cell\n    \n    }\n\n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        return data.count\n    }\n```\n主要是在cellForRowAt显示了具体item效果，根据前面选择的字体索引，这里设置给cell了。\n\n## 3 播放本地视频\n\n### 3.1 效果\n<img src=playvideo.gif>\n\n### 3.2 本地视频\n\n直接将mp4文件放置在根目录下。 \nXcode可自动识别到Movie文件夹下。\n\n### 3.3 Core Data\n这里播放本地视频并不依赖这个。\n因为demo中有部分代码是这个，当然也是可以学习下的。\n关于Core Data实际上是一个数据存储框架，类似Realm。\nFicow写的这篇文章还不错：\n [了解和采用 CoreData 框架 —— Ficow 陪你学 CoreData](https://blog.ficowshen.com/page/post/52)\n\n ### 3.4 UI定义\n\n ```Swift\n  // Swift中mark的使用方式，效果等同OC重的 #pragma mark -\n    //MARK:- Variables\n    @IBOutlet weak var videoTableView: UITableView!\n ```\n\n 这里就一个UITableView，展示一个列表。\n\n```Swift   \n  var playViewController = AVPlayerViewController()\n  var playerView = AVPlayer()\n```\n然后这里定义并且初始化了视频播放关键类。\nAVPlayerViewController是一个系统的控制器，用来播放视频的，这里播放本地视频其实也是跳转到系统默认的播放器来播放。\n\n```Swift\nvar data = [\n        // 给项目编译后属于同一个module，所以Video不需要import就可以使用\n        Video(image: \"videoScreenshot01\",\n              title: \"Introduce 3DS Mario\",\n              source: \"Youtube - 06:32\"),\n        Video(image: \"videoScreenshot02\",\n              title: \"Emoji Among Us\",\n              source: \"Vimeo - 3:34\"),\n        Video(image: \"videoScreenshot03\",\n              title: \"Seals Documentary\",\n              source: \"Vine - 00:06\"),\n        Video(image: \"videoScreenshot04\",\n              title: \"Adventure Time\",\n              source: \"Youtube - 02:39\"),\n        Video(image: \"videoScreenshot05\",\n              title: \"Facebook HQ\",\n              source: \"Facebook - 10:20\"),\n        Video(image: \"videoScreenshot06\",\n              title: \"Lijiang Lugu Lake\",\n              source: \"Allen - 20:30\")\n    ]\n```\n上面是列表页数据定义。\n\n```Swift\n //MARK:- View Life Cycle\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        videoTableView.dataSource = self\n        videoTableView.delegate = self\n        \n    }\n```\n初始化里面设置了数据源和代理。\n\n```Swift\n\n//MARK:- UIViewTableView DataSource & Delegate\n// 知识点：扩展\n// 扩展和 Objective-C 中的分类类似，但没有名称\n// 扩展可以为一个类型添加新的功能，但是不能重写已有的功能。\n// 扩展可以添加新的计算型属性，但是不可以添加存储型属性，也不可以为已有属性添加属性观察器。\nextension ViewController: UITableViewDataSource, UITableViewDelegate {\n    // Extensions must not contain stored properties\n    //var a = 1\n    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n    return 220\n    }\n\n    func numberOfSections(in tableView: UITableView) -> Int {\n    return 2\n    }\n\n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n    return data.count\n    }\n\n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n\n    // 知识点：向下转型\n    // as! 强制类型转换，无法转换时会抛出运行时异常\n    // as？可选类型转换，无法转换时返回nil\n    let cell = videoTableView.dequeueReusableCell(withIdentifier: \"VideoCell\", for: indexPath) as! VideoCell\n    let video = data[indexPath.row]\n\n    cell.videoScreenshot.image = UIImage(named: video.image)\n    cell.videoTitleLabel.text = video.title\n    cell.videoSourceLabel.text = video.source\n\n    return cell\n\n    }\n}\n```\n这里扩展实现了UITableView的代理和数据源。\n\n这里用到了一个Cell需要自定义。\n```Swift\n\n// 定义Video的结构体，属性初始化后不能被改变，因为结构体时值类型。\n// 在你每次定义一个新类或者结构体的时候，实际上你是定义了一个新的 Swift 类型。\n// 因此请使用UpperCamelCase这种方式来命名\nstruct Video {\n    let image: String\n    let title: String\n    let source: String\n}\n\nclass VideoCell: UITableViewCell {\n\n    @IBOutlet weak var videoScreenshot: UIImageView!\n    @IBOutlet weak var videoTitleLabel: UILabel!\n    @IBOutlet weak var videoSourceLabel: UILabel!\n    \n    override func awakeFromNib() {\n        super.awakeFromNib()\n        // Initialization code\n    }\n\n    override func setSelected(_ selected: Bool, animated: Bool) {\n        super.setSelected(selected, animated: animated)\n\n        // Configure the view for the selected state\n    }\n\n}\n```\n这个VideoCell是怎么添加视图的呢，当然也是故事版的作用了。\n全局搜索了下VideoCell，发现Main.storyboard里面用到了这个VideoCell，这里关联到了故事版。\n<img src=03_1.png>\n这里注意到右上角是一个Custom Class，说明故事版是可以关联自定义类的，这里就把Cell关联进来了。\n\n然后还是在Main.storyboard中，给cell里面的botton添加了一个点击事件给控制器：\n```Swift\n@IBAction func playVideoButtonDidTouch(_ sender: AnyObject) {\n        let path = Bundle.main.path(forResource: \"emoji zone\", ofType: \"mp4\")\n        \n        playerView = AVPlayer(url: URL(fileURLWithPath: path!))\n        \n        playViewController.player = playerView\n        \n        // 知识点：尾随闭包\n        // 在使用尾随闭包时，你不用写出它的参数标签\n        // 如果闭包表达式是函数或方法的唯一参数，则当你使用尾随闭包时，你甚至可以把 () 省略掉\n        // 完整形式如下：\n        //self.present(playViewController, animated: true, completion: {\n        //    self.playViewController.player?.play()\n        //})\n        self.present(playViewController, animated: true) {\n            self.playViewController.player?.play()\n        }\n    }\n }\n```\n这里给系统的控制器设置了一个AVPlayer，AVPlayer里面设置了URL，这样实现了播放视频效果。\n\n## 4 摄像头\n\n### 4.1 效果预览\n\n<img src=snapchatmenu.gif>\n\n### 4.2 UI\n这里主要是一个横滑的UIScrollView。\n长度设置了屏幕的3倍，第一块放置一个UIImageView，中间放置摄像头，最后一块也放置了一个UIImageView。\n\n这里左侧的视图，采用了xib的方式来创建。\n我个人理解，xib的方式有点类似Android的xml，因为我本身是学Android，希望大家原谅我这样比喻。xib也是很直观,可以看到效果，而且也可以挂载到某个具体的UIView上。\n\n左侧的xib是这样的：\n<img src=04_1.png>\n\n右侧的xib是这样的：\n<img src=04_2.png>\n\n中间的就是一个控制器来的,当然这个控制器也是可以关联xib的。\n如何关联的？\n这里有一个CameraView.xib，它的File's Owner是CameraView，这样就关联起来了。所以再CameraView.swift里面操作的都是针对这个xib的逻辑处理。\n\n重点看下如何显示摄像头的吧：\n首先是UI关联：\n```\n@IBOutlet weak var cameraView: UIView!\n```\n这个应该是拖进来的。\n\n然后就是几个关键的类：\n```Swift\n var captureSession : AVCaptureSession?\n var stillImageOutput : AVCaptureStillImageOutput?\n var previewLayer : AVCaptureVideoPreviewLayer?\n```\n\n然后是将要显示的时候逻辑处理：\n```Swift\noverride func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n        \n        captureSession = AVCaptureSession()\n        // 已经不能再使用了\n        // captureSession?.sessionPreset = AVCaptureSessionPreset1920x1080\n        captureSession?.sessionPreset = AVCaptureSession.Preset.hd1920x1080\n        let backCamera = AVCaptureDevice.devices(for: .video).first!\n        // 已经不能再使用了\n        // let backCamera = AVCaptureDevice.defaultDevice(withMediaType: AVMediaTypeVideo)\n        var error : NSError?\n        var input: AVCaptureDeviceInput!\n        \n        do {\n            input = try AVCaptureDeviceInput(device: backCamera) }\n        catch let error1 as NSError {\n            error = error1\n            input = nil\n        }\n        \n        if (error == nil && captureSession?.canAddInput(input) != nil) {\n            \n                captureSession?.addInput(input)\n                \n                stillImageOutput = AVCaptureStillImageOutput()\n                stillImageOutput?.outputSettings = [AVVideoCodecKey : AVVideoCodecJPEG]\n                \n            if let stillImageOutputTemp = stillImageOutput {\n                if captureSession?.canAddOutput(stillImageOutputTemp) != nil {\n                    captureSession?.addOutput(stillImageOutputTemp)\n                    if let captureSessionTemp = captureSession {\n                        previewLayer = AVCaptureVideoPreviewLayer(session: captureSessionTemp)\n                        previewLayer?.videoGravity = AVLayerVideoGravity.resizeAspect\n                        // 已经废弃不用了\n                        // previewLayer?.videoGravity = AVLayerVideoGravityResizeAspect\n                        previewLayer?.connection?.videoOrientation = AVCaptureVideoOrientation.portrait\n                        cameraView.layer.addSublayer(previewLayer!)\n                        captureSession?.startRunning()\n                    }\n                }\n            }\n        }\n        \n    }\n```\n主要是初始化了一个AVCaptureSession，然后又创建了一个AVCaptureDeviceInput来接收输入流，这样利用session.addInput，将输入流给input，然后搞一个输出流AVCaptureStillImageOutput，来接收captureSession.addOutPut，这样最后我们再创建一个 预览类叫做AVCaptureVideoPreviewLayer，里面放session，这样就得到一个Layer了。\n\n这个Layer我们就可以加到普通的UIView上了。\n\n### 4.3 根控制器\n\n先定义一个UIScollView:\n```Swift\n\nclass ViewController: UIViewController {\n    \n\n    @IBOutlet weak var scrollView: UIScrollView!\n```\n初始化添加子View，3块布局给它add进去：\n```Swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    \n    // 已经废弃了，使用prefersStatusBarHidden属性返回设置的值\n    // UIApplication.shared.isStatusBarHidden = true\n    \n    let screenWidth = UIScreen.main.bounds.width\n    let screenHeight = UIScreen.main.bounds.height\n    let leftView: UIViewController = UINib(nibName: \"LeftView\", bundle: nil).instantiate(withOwner: nil, options: nil)[0] as! UIViewController\n    let centerView: CameraView = CameraView(nibName: \"CameraView\", bundle: nil)\n    let rightView: RightView = RightView(nibName: \"RightView\", bundle: nil)\n    \n    leftView.view.frame = CGRect(x: 0, y: 0, width: screenWidth-200, height: screenHeight)\n    centerView.view.frame = CGRect(x: screenWidth, y: 0, width: screenWidth, height: screenHeight)\n    rightView.view.frame = CGRect(x: 2*screenWidth, y: 0, width: screenWidth, height: screenHeight)\n\n    self.scrollView.addSubview(leftView.view)\n    self.scrollView.addSubview(rightView.view)\n    self.scrollView.addSubview(centerView.view)\n    self.scrollView.contentSize = CGSize(width: screenWidth * 3, height: screenHeight)\n}\n```\nframe要对应好屏幕坐标。\nscrollView的contentSize刚好对应3个屏幕大小。\n\n这里可以直接创建一个UINib作为控制器，传xib的名称给它就可以的。\n\n另外这里用到了相机，需要相机的权限声明哦：\n在info.plist文件下配置：\nPrivacy - Camera Usage Description \n\n然后Value自己随便填下就好了。\n\n## 5 传送带效果\n\n### 5.1 效果\n<img src=Carousel.gif>\n\n### 5.2 故事版关联\n\n<img src=5_1.png>\n首先Main.storyboard是在info.plist中注册的。\n然后这个首页故事版配置的控制器的Class就是代码区域表示的控制器了。\n层层关联环环相扣。\n\n### 5.3 UI\n\n这里其实就一个背景图片+一个UICollectionView。\n```Swift\nclass HomeViewController: UIViewController {\n\n    \n    @IBOutlet weak var backgroundImageView: UIImageView!\n    @IBOutlet weak var collectionView: UICollectionView!\n```\n\n### 5.4 Data\n```Swift\n// 访问权限分物种：private，fileprivate，internal，public 和 open\n    // private：只能在本类的作用域且在当前文件内能访问\n    // fileprivate：只能在当前文件内能访问\n    // internal：本module内能访问\n    // public：跨module访问但不能重写或继承\n    // open：跨module访问并且能重写或继承\n    fileprivate var interests = Interest.createInterests()\n```\n\n```Swift\nclass Interest\n{\n    // MARK: - Public API\n    var title = \"\"\n    var description = \"\"\n    var numberOfMembers = 0\n    var numberOfPosts = 0\n    var featuredImage: UIImage!\n    \n    init(title: String, description: String, featuredImage: UIImage!)\n    {\n        self.title = title\n        self.description = description\n        self.featuredImage = featuredImage\n        numberOfMembers = 1\n        numberOfPosts = 1\n    }\n    \n    // MARK: - Private\n    // dummy data\n    static func createInterests() -> [Interest]\n    {\n        return [\n            Interest(title: \"Hello there, i miss u.\", description: \"We love backpack and adventures! We walked to Antartica yesterday, and camped with some cute pinguines, and talked about this wonderful app idea. 🐧⛺️✨\", featuredImage: UIImage(named: \"hello\")!),\n            Interest(title: \"🐳🐳🐳🐳🐳\", description: \"We love romantic stories. We walked to Antartica yesterday, and camped with some cute pinguines, and talked about this wonderful app idea. 🐧⛺️✨\", featuredImage: UIImage(named: \"dudu\")!),\n            Interest(title: \"Training like this, #bodyline\", description: \"Create beautiful apps. We walked to Antartica yesterday, and camped with some cute pinguines, and talked about this wonderful app idea. 🐧⛺️✨\", featuredImage: UIImage(named: \"bodyline\")!),\n            Interest(title: \"I'm hungry, indeed.\", description: \"Cars and aircrafts and boats and sky. We walked to Antartica yesterday, and camped with some cute pinguines, and talked about this wonderful app idea. 🐧⛺️✨\", featuredImage: UIImage(named: \"wave\")!),\n            Interest(title: \"Dark Varder, #emoji\", description: \"Meet life with full presence. We walked to Antartica yesterday, and camped with some cute pinguines, and talked about this wonderful app idea. 🐧⛺️✨\", featuredImage: UIImage(named: \"darkvarder\")!),\n            Interest(title: \"I have no idea, bitch\", description: \"Get up to date with breaking-news. We walked to Antartica yesterday, and camped with some cute pinguines, and talked about this wonderful app idea. 🐧⛺️✨\", featuredImage: UIImage(named: \"hhhhh\")!),\n        ]\n    }\n}\n```\n这里创建了一个静态函数，就是数据定义了。\n\n### 5.5 绑定数据\n```Swift\nextension HomeViewController : UICollectionViewDataSource {\n    \n    func numberOfSections(in collectionView: UICollectionView) -> Int {\n        return 1\n    }\n    \n    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {\n        return interests.count\n    }\n    \n    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: Storyboard.CellIdentifier, for: indexPath) as! InterestCollectionViewCell\n        \n        cell.interest = self.interests[indexPath.item]\n        \n        return cell\n        \n    }\n}\n```\n这里就是UICollectionView的数据源了。\n对应的Cell为InterestCollectionViewCell\n> 这里注意到这个UICollectionView好像没有设置dataSource和delegate，这里看了下Main.storyboard里面，果然在右侧看到Outlets设置了dataSource和delegate都给了控制器。所以说在故事版里面是可以设置数据源和代理的。\n\n如下：\n```Swift\nclass InterestCollectionViewCell: UICollectionViewCell {\n    \n    \n    var interest: Interest! {\n        didSet {\n            updateUI()\n        }\n    }\n    \n    @IBOutlet weak var featuredImageView: UIImageView!\n    @IBOutlet weak var interestTitleLabel: UILabel!\n    \n    fileprivate func updateUI() {\n        interestTitleLabel?.text! = interest.title\n        featuredImageView?.image! = interest.featuredImage\n    }\n    \n    override func layoutSubviews() {\n        super.layoutSubviews()\n        \n        self.layer.cornerRadius = 5.0\n        self.clipsToBounds = true\n    }\n}\n```\n因为在Main.storyboard的已经关联了这个Cell，所以布局相关的都无需重新addView。\n\n上面这些代码就可以实现一个传送带效果。\n\n但是我们想要左滑，它自己能够刚好滑动到下一个屏幕，体验效果好一点的话要怎么办呢？\n\n我们想到第一个优化点：\n一张图能不能刚好占一个屏幕，增大一点padding。\n\n可以的。\n\n利用UICollectionView提供的另外一个协议可以实现。答案就是：UICollectionViewDelegateFlowLayout。\n\n```Swift\nextension HomeViewController : UICollectionViewDelegateFlowLayout {\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {\n        return CGSize(width: UIScreen.main.bounds.width - 2 * Storyboard.CellPadding, height: 450)\n    }\n\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -> CGFloat {\n        return 2 * Storyboard.CellPadding\n    }\n\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -> UIEdgeInsets {\n        return UIEdgeInsetsMake(0, Storyboard.CellPadding, 0, Storyboard.CellPadding)\n    }\n}\n```\n这里第一个sizeForItemAt方法：单个item的大小，长度为屏幕宽度-左右两个padding，高度写死450。\n这里第二个方法minimumLine: collectionView的滚动方向为水平时，这个就是item之间的最小水平间距。\n这里的第三个方法insetForSectionAt: 单个item的padding，设置上，左，右，下。\n\n第二个优化点：当滑动到一半多，自动切下一张，不足一半，切回上一张。\n也好办。\n\n```Swift\nextension HomeViewController : UIScrollViewDelegate {\n    func scrollViewWillEndDragging(_ scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer<CGPoint>) {\n        let originPoint = targetContentOffset.pointee;\n        var index = Int(originPoint.x / UIScreen.main.bounds.width)\n        let offset = Int(originPoint.x) % Int(UIScreen.main.bounds.width)\n        index += (offset > Int(UIScreen.main.bounds.width/2) ? 1 : 0)\n        targetContentOffset.pointee = CGPoint(x: index * Int(UIScreen.main.bounds.width) , y: 0)\n    }\n}\n```\n继续扩展下这个控制器，这里面，判断了offset在停止滑动后的逻辑。\n\n## 6 定位\n\n### 6.1 效果\n<img src=mylocation.gif>\n\n### 6.2 UI\n这个UI比较简单，一个UILabel，一个按钮。\n\n这个按钮的点击事件直接通过故事版链接到了控制器，所以控制器无需有这个UIView，有这个点击事件就行了。\n<img src=06_1.png>\n\n### 6.3 如何定位\n首先声明一个全局变量：\n```Swift\n  // 强制自动解包，可以赋值为nil，为nil后再调用会报错\n    // 建议定义为：\n    // var locationManager: CLLocationManager\n    var locationManager: CLLocationManager!\n```\n\n开始定位：\n```Swift\n@IBAction func myLocationButtonDidTouch(_ sender: AnyObject) { \n    locationManager = CLLocationManager()\n    locationManager.delegate = self\n    locationManager.desiredAccuracy = kCLLocationAccuracyBest\n    locationManager.requestAlwaysAuthorization()\n    locationManager.startUpdatingLocation()   \n}\n```\n\n因为这里引入了CLLocationManager，那么在项目层级发现CoreLocation.framework自动引入进来了。\n\n直接这样还不够，还需要设置下协议才行。因为这里我们delegate设置了self。\n这里我们同样可以新建一个Delegate，本质上扩展控制器，当然也可以直接写在控制器里面，都可以，最好是分一个文件，可读性会强一点。\n\n```Swift\nimport Foundation\nimport CoreLocation\n\nextension ViewController : CLLocationManagerDelegate {\n    \n    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {\n        \n        self.locationLabel.text = \"Error while updating location \" + error.localizedDescription\n        \n    }\n    \n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        CLGeocoder().reverseGeocodeLocation(locations.first!) { (placemarks, error) in\n            guard error == nil else {\n                self.locationLabel.text = \"Reverse geocoder failed with error\" + error!.localizedDescription\n                return\n            }\n            if placemarks!.count > 0 {\n                let pm = placemarks!.first\n                self.displayLocationInfo(pm)\n            } else {\n                self.locationLabel.text = \"Problem with the data received from geocoder\"\n            }\n        }\n    }\n    \n    func displayLocationInfo(_ placemark: CLPlacemark?) {\n        if let containsPlacemark = placemark {\n            //stop updating location to save battery life\n            locationManager.stopUpdatingLocation()\n            \n            let locality = (containsPlacemark.locality != nil) ? containsPlacemark.locality : \"\"\n            let postalCode = (containsPlacemark.postalCode != nil) ? containsPlacemark.postalCode : \"\"\n            let administrativeArea = (containsPlacemark.administrativeArea != nil) ? containsPlacemark.administrativeArea : \"\"\n            let country = (containsPlacemark.country != nil) ? containsPlacemark.country : \"\"\n            \n            self.locationLabel.text = postalCode! + \" \" + locality!\n            \n            self.locationLabel.text?.append(\"\\n\" + administrativeArea! + \", \" + country!)\n        }\n        \n    }\n}\n```\n\n## 7 下拉刷新\n\n### 7.1 效果\n<img src=07.gif>\n\n### 7.2 变量声明\n```Swift\nclass ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate {\n    \n    var index = 0\n    let cellIdentifer = \"NewCellIdentifier\"\n    \n    let favoriteEmoji = [\"🤗🤗🤗🤗🤗\", \"😅😅😅😅😅\", \"😆😆😆😆😆\"]\n    let newFavoriteEmoji = [\"🏃🏃🏃🏃🏃\", \"💩💩💩💩💩\", \"👸👸👸👸👸\", \"🤗🤗🤗🤗🤗\", \"😅😅😅😅😅\", \"😆😆😆😆😆\" ]\n    var emojiData = [String]()\n    var tableView: UITableView!\n    \n    var refreshControl = UIRefreshControl()\n    var navBar: UINavigationBar = UINavigationBar(frame: CGRect(x: 0, y: 0, width: 375, height: 64))\n```\n这里继承了UIViewController，然后再Main.storyboard中配置了首页的控制器就是这个，这样就直接启动这个控制器了。\n\n这里定义了初始化数据3条，更新后的6条。\n模拟刷新后的数据变化。\n\n这里不是再故事版里面加视图，直接在代码里面new了。\n\n### 7.3 viewDidLoad初始化\n```Swift\n override func viewDidLoad() {\n        super.viewDidLoad()\n        // 这里new一个UITableView\n        tableView = UITableView(frame: self.view.bounds, style: .plain)\n        \n        // 初始数据\n        emojiData = favoriteEmoji\n        let emojiTableView = tableView\n        \n        // 数据源设置，注册Cell，这里的Cell比较简单，直接用了UITableViewCell可满足\n        emojiTableView?.backgroundColor = UIColor(red:0.092, green:0.096, blue:0.116, alpha:1)\n        emojiTableView?.dataSource = self\n        emojiTableView?.register(UITableViewCell.self, forCellReuseIdentifier: cellIdentifer)\n        \n        // 因为TableView是UIScrollViw，这里也有这个refreshControl的属性\n        tableView.refreshControl = self.refreshControl\n        self.refreshControl.addTarget(self, action: #selector(ViewController.didRoadEmoji), for: .valueChanged)\n        \n        // 自定义刷新器 这里的loading效果猜测是refreshControl自带的\n        self.refreshControl.backgroundColor = UIColor(red:0.113, green:0.113, blue:0.145, alpha:1)\n        let attributes = [NSAttributedStringKey.foregroundColor: UIColor.white]\n        // 这里是loading下方的文案\n        self.refreshControl.attributedTitle = NSAttributedString(string: \"Last updated on \\(Date())\", attributes: attributes)\n        self.refreshControl.tintColor = UIColor.white\n        \n        self.title = \"emoji\"\n        self.navBar.barStyle = UIBarStyle.blackTranslucent\n        \n        emojiTableView?.rowHeight = UITableViewAutomaticDimension\n        emojiTableView?.estimatedRowHeight = 60.0\n        emojiTableView?.tableFooterView = UIView(frame: CGRect.zero)\n        emojiTableView?.separatorStyle = UITableViewCellSeparatorStyle.none\n        \n        // 代码add子View\n        self.view.addSubview(emojiTableView!)\n        self.view.addSubview(navBar)\n    }\n```\n这里通过在代码里面new一个UITableView方式，也是可以实现UI效果。\n\n### 7.4 设置代理和数据源\n\n```Swift\nfunc tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        return emojiData.count\n    }\n    \nfunc numberOfSections(in tableView: UITableView) -> Int {\n    return 1\n}\n\n\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifer)! as UITableViewCell\n    cell.textLabel!.text = self.emojiData[indexPath.row]\n    cell.textLabel!.textAlignment = NSTextAlignment.center\n    cell.textLabel!.font = UIFont.systemFont(ofSize: 50)\n    cell.backgroundColor = UIColor.clear\n    cell.selectionStyle = UITableViewCellSelectionStyle.none\n\n    return cell\n}\n```\n这里给Cell设置数据了。\n\n### 7.5 下拉监听\n\n```Swift\n@objc func didRoadEmoji() {\n    DispatchQueue.main.asyncAfter(deadline:DispatchTime.now() + 3 ) {\n        self.emojiData = [self.newFavoriteEmoji,self.favoriteEmoji][self.index]\n        self.tableView.reloadData()\n        self.refreshControl.endRefreshing()\n        self.index = (self.index + 1) % 2\n    }\n}\n```\nDispatchQueue.main.asyncAfter： 主线程执行延迟任务方法。\n这里延迟3s后，去更新数据。然后控制器取消刷新。\n\n## 8 炫彩音乐\n\n### 8.1 效果\n\n<img src=randomMusicColor.gif>\n\n### 8.2 全局变量定义\n\n```Swift\nvar audioPlayer = AVAudioPlayer()\n    \nlet gradientLayer = CAGradientLayer()\n\nvar timer : Timer?\n\nvar backgroundColor: (red: CGFloat, green: CGFloat,blue: CGFloat,alpha: CGFloat)! {\n    didSet {\n        let color1 = UIColor(red: backgroundColor.blue,\n                                green: backgroundColor.green,\n                                blue: 0,\n                                alpha: backgroundColor.alpha).cgColor\n        let color2 = UIColor(red: backgroundColor.red,\n                                green: backgroundColor.green,\n                                blue: backgroundColor.blue,\n                                alpha: backgroundColor.alpha).cgColor\n        gradientLayer.colors = [color1, color2]\n    }\n}\n```\n这里第一个是AVAudioPlayer，负责音频播放。\n这里第二个类是CAGradientLayer，负责渐变色渲染。\ntimer是定时器。\nbackgroundColor背景色，如果任何地方更改后，触发渐变色颜色变化。\n\n### 8.3 播放音乐\n```Swift\n@IBAction func playMusicButtonDidTouch(_ sender: AnyObject) {\n        \n    //play bg music\n    let bgMusic = URL(fileURLWithPath: Bundle.main.path(forResource: \"Ecstasy\", ofType: \"mp3\")!)\n    \n    do {\n        try AVAudioSession.sharedInstance().setCategory(AVAudioSessionCategoryPlayback)\n        try AVAudioSession.sharedInstance().setActive(true)\n        try audioPlayer = AVAudioPlayer(contentsOf: bgMusic)\n        \n        audioPlayer.prepareToPlay()\n        audioPlayer.play()\n        \n    }\n    catch let audioError as NSError {\n        print(audioError)\n    }\n    \n    if (timer == nil) {\n        timer = Timer.scheduledTimer(timeInterval: 0.2, target: self, selector: #selector(ViewController.randomColor), userInfo: nil, repeats: true)\n    }\n    \n    let redValue = CGFloat(drand48())\n    let blueValue =  CGFloat(drand48())\n    let greenValue = CGFloat(drand48())\n    \n    self.view.backgroundColor = UIColor(red: redValue, green: greenValue, blue: blueValue, alpha: 1.0)\n    \n    //graditent color\n    gradientLayer.frame = view.bounds\n    gradientLayer.startPoint = CGPoint(x: 0, y: 0)\n    gradientLayer.endPoint = CGPoint(x: 1, y: 1)\n    \n    self.view.layer.addSublayer(gradientLayer)\n    \n}\n```\n这里先利用AVAudioSession的单例类设置Active，然后利用AVAudioPlayer播放本地音乐。\n\n然后后面搞了0.2s刷新的周期定时器。每次会执行这个函数：\n```Swift\n@objc func randomColor() {\n    \n    let redValue = CGFloat(drand48())\n    let blueValue =  CGFloat(drand48())\n    let greenValue = CGFloat(drand48())\n    \n    \n    backgroundColor = (redValue, blueValue, greenValue, 1)\n    \n}\n```\n这里红蓝绿会随机获取一个值，生成一个颜色值。同时会更新渐变层变更，这样背景就随机变化了。\n\n## 9 图片缩放效果\n\n### 9.1 效果\n<img src=09.gif>\n\n### 9.2 布局构造\n这里看了下Main.storyboard\n貌似是在ScrollView里面放了一个ImageView哦。\n\n这里有个细节，就是背景有点毛玻璃效果。\n其实是这样的，它在Main.storyboard底部设置了一张UIImageView，其实就是这张图片。\n然后再搞了一个UIVisualEffectView覆盖再上面，就形成了一种毛玻璃效果。\n\n回到控制器里面，这里无非就是两个视图，并且把这个Constraint约束也加进来了，有4个约束，顶部约束，头部约束，底部约束和尾部约束。\n\n```Swift\n@IBOutlet weak var scrollView: UIScrollView!\n@IBOutlet weak var imageView: UIImageView!\n@IBOutlet weak var imageViewTopConstraint: NSLayoutConstraint!\n@IBOutlet weak var imageViewTrailingConstraint: NSLayoutConstraint!\n@IBOutlet weak var imageViewBottomConstraint: NSLayoutConstraint!\n@IBOutlet weak var imageViewLeadingConstraint: NSLayoutConstraint!\n```\n\n### 9.3 代码实现\n\n首先在初始化里面配置了一个mask:\n```Swift\n scrollView.autoresizingMask = [.flexibleWidth, .flexibleHeight]\n```\n这个是自动调整尺寸设置。\n\n其实ScrollView本来就支持缩放的：\n> 在iOS中，滚动视图UIScrollView用于查看大于屏幕的内容。Scroll View有两个主要目的：\n让用户拖动视图以显示更多内容区域。\n让用户使用捏合手势放大或缩小所显示的内容。\n\n这里需要关注一个生命周期函数：viewWillLayoutSubviews\n> 有以下几种情况会调用（init初始化不会触发layoutSubviews）\n1、addSubview会触发viewWillLayoutSubviews\n2、设置self.view及子视图的frame.size会触发layoutSubviews，当然前提是frame.size的值设置前后发生了变化,注意，此处不是origin，呼应官方文档上的边界发生变化\n3、滚动一个UIScrollView(该scrollview有子视图的时候)会触发layoutSubviews\n4、横竖屏幕切换会触发\n\n这里最为关键的就是这个 viewWillLayoutSubviews函数和viewForZooming了,如果没有这个代码，无法支持缩放效果!\n```Swift\n//每次控制器更新其子视图时，更新最小缩放比例\noverride func viewWillLayoutSubviews() {\n    super.viewWillLayoutSubviews()\n    updateMinZoomScaleForSize(view.bounds.size)\n}\n\n//计算scrollView的缩放比例，缩放比例为1表示内容以正常大小显示；缩放比例小于1表示容器内的内容缩小，缩放比例大于1表示放大容器内的内容\nfileprivate func updateMinZoomScaleForSize(_ size: CGSize)\n{\n    //要获得最小的缩放比例，首先计算所需的缩放比例，以便根据其宽度在scrollView中紧贴imageView\n    let widthScale = size.width / imageView.bounds.width\n    let heightScale = size.height / imageView.bounds.height\n    //选取宽度和高度比例中最小的那个,设置为minimumZoomScale\n    let minScale = min(widthScale,heightScale)\n    \n    scrollView.minimumZoomScale = minScale\n    scrollView.maximumZoomScale = 3.0\n    scrollView.zoomScale = minScale\n}\n```\n这样ScrollView就有一个最小和最大缩放比例了。\n\n另外还有一个协议：\n```Swift\nfunc viewForZooming(in scrollView: UIScrollView) -> UIView? {\n    //当手势动作发生时，scrollView告诉控制器要放大或缩小子视图imageView\n    return imageView\n}\n```\n必须要有viewForZooming，这个作用就是谁可以放大或缩小。\n\nviewForZooming+viewWillLayoutSubviews，两者结合才能实现子View缩放效果。\n\n两位还有一个scrollViewDidZoom方法, 当scrollView缩放时调用,在缩放过程中会被多次调用：\n```Swift\nfunc scrollViewDidZoom(_ scrollView: UIScrollView) {\n    updateConstraintsForSize(view.bounds.size)\n}\n\n//当scrollView的内容大小小于边界时，内容将放置在左上角而不是中心，updateConstraintForSize方法处理这个问题；通过调整图像视图的布局约束。\nfileprivate func updateConstraintsForSize(_ size: CGSize) {\n    \n    ////将图像垂直居中，从视图高度减去imageView的高度并分成两半，这个值用作顶部和底部imageView的约束\n    let yOffset = max(0, (size.height - imageView.frame.height) / 2)\n    imageViewTopConstraint.constant = yOffset\n    imageViewBottomConstraint.constant = yOffset\n    \n    ////根据宽度计算imageView前后约束的偏移量\n    let xOffset = max(0, (size.width - imageView.frame.width) / 2)\n    imageViewLeadingConstraint.constant = xOffset\n    imageViewTrailingConstraint.constant = xOffset\n    \n    view.layoutIfNeeded()\n}\n```\n\n另外还有其它的代理方法如下：\n> func scrollViewDidScroll(_ scrollView: UIScrollView)\nscrollView滚动时调用，在滚动过程中会多次调用\n\n> func scrollViewWillBeginDragging(_ scrollView: UIScrollView)\n将要开始拖拽时调用\n\n> func scrollViewWillEndDragging(_ scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer<CGPoint>)\n将要停止拖拽时 velocity:加速度 向左滑动 x为负值，否则为正值 向上滚动为y为负值否则为正值；targetContentOffset:滚动停止时的ContentOffset\n\n> func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool)\n停止拖拽时调用， willDecelerate:停止拖拽时是否要减速，若值为false表示已经停止减速，也就意味着滚动已停止，此时不会调用scrollViewWillBeginDecelerating和scrollViewDidEndDecelerating;若值为true，则代表scrollView正在减速滚动\n\n> func scrollViewWillBeginDecelerating(_ scrollView: UIScrollView)\n开始减速的时候调用(也就是松开手指时)，在拖拽滚动的时候，如果松手时已经停止滚动则不会调用\n\n> func scrollViewDidEndDecelerating(_ scrollView: UIScrollView)\n停止减速的时候调用（也就是停止滚动的时候调用），在拖拽滚动的时候，如果松手时已经停止滚动则不会调用\n\n> func scrollViewDidEndScrollingAnimation(_ scrollView: UIScrollView)\n当调用setContentOffset(_ contentOffset: CGPoint, animated: Bool)/scrollRectToVisible(_ rect: CGRect, animated: Bool)API并且animated参数为true时,会在scrollView滚动结束时调用。若是UITableView或者UICollectionView,调用scrollToRow也和上面一样\n\n> func viewForZooming(in scrollView: UIScrollView) -> UIView?\n放回要缩放的view，此view必须是scrollView的subview\n\n> func scrollViewDidZoom(_ scrollView: UIScrollView)\n当scrollView缩放时调用,在缩放过程中会被多次调用\n\n> func scrollViewWillBeginZooming(_ scrollView: UIScrollView, with view: UIView?)\nscrollView开始缩放时调用\n\n> func scrollViewDidEndZooming(_ scrollView: UIScrollView, with view: UIView?, atScale scale: CGFloat)\nscrollView结束缩放时调用\n\n> func scrollViewShouldScrollToTop(_ scrollView: UIScrollView) -> Bool\n是否允许点击scrollview的头部，让其滚动到最上面,若不实现此代理，则默认为true\n\n> func scrollViewDidScrollToTop(_ scrollView: UIScrollView)\n当滚动到最上面时调用\n\n## 10 视频背景\n\n### 10.1 效果\n<img src=videobg.gif>\n\n### 10.2 定义一个基类播放控制器\n\n```Swift\npublic enum ScalingMode {\n  case resize\n  case resizeAspect\n  case resizeAspectFill\n}\n```\n定义了3种缩放模式。\n\n再定义有关视频的属性：\n```Swift\n// 视频播放器\nfileprivate let moviePlayer = AVPlayerViewController()\n     \n  // 声音   \n  fileprivate var moviePlayerSoundLevel: Float = 1.0\n\n   // 播放url  \n   var contentURL: URL? {\n    didSet {\n      if let _contentURL = contentURL {\n      setMoviePlayer(_contentURL)\n      }\n    }\n  }\n\n   var videoFrame: CGRect = CGRect()\n   var startTime: CGFloat = 0.0\n   var duration: CGFloat = 0.0\n\n   // 背景\n   var backgroundColor: UIColor = UIColor.black {\n    didSet {\n      view.backgroundColor = backgroundColor\n    }\n  }\n\n  // 声音\n   var sound: Bool = true {\n    didSet {\n      if sound {\n        moviePlayerSoundLevel = 1.0\n      }else{\n        moviePlayerSoundLevel = 0.0\n      }\n    }\n  }\n  \n  // alpha\n   var alpha: CGFloat = CGFloat() {\n    didSet {\n      moviePlayer.view.alpha = alpha\n    }\n  }\n\n  // 是否重复 这里发送一个全局通知\n   var alwaysRepeat: Bool = true {\n    didSet {\n      if alwaysRepeat {\n        NotificationCenter.default.addObserver(self,\n          selector: #selector(VideoSplashViewController.playerItemDidReachEnd),\n          name: NSNotification.Name.AVPlayerItemDidPlayToEndTime,\n          object: moviePlayer.player?.currentItem)\n      }\n    }\n  }\n\n  // 填充模式\n   var fillMode: ScalingMode = .resizeAspectFill {\n    didSet {\n      switch fillMode {\n      case .resize:\n          moviePlayer.videoGravity = AVLayerVideoGravity.resize.rawValue\n      case .resizeAspect:\n          moviePlayer.videoGravity = AVLayerVideoGravity.resizeAspect.rawValue\n      case .resizeAspectFill:\n          moviePlayer.videoGravity = AVLayerVideoGravity.resizeAspectFill.rawValue\n      }\n    }\n  }\n```\n\n生命周期已经显示,添加子View和视频view：\n```Swift\n  override func viewDidAppear(_ animated: Bool) {\n    moviePlayer.view.frame = videoFrame\n    moviePlayer.showsPlaybackControls = false\n    view.addSubview(moviePlayer.view)\n    view.sendSubview(toBack: moviePlayer.view)\n  }\n```\n\n生命周期将要消失，移除通知：\n```Swift\n  override func viewWillDisappear(_ animated: Bool) {\n    super.viewDidDisappear(animated)\n    NotificationCenter.default.removeObserver(self)\n  }\n```\n\n设置播放器：\n```Swift\n fileprivate func setMoviePlayer(_ url: URL){\n    let videoCutter = VideoCutter()\n    videoCutter.cropVideoWithUrl(videoUrl: url, startTime: startTime, duration: duration) { (videoPath, error) -> Void in\n      if let path = videoPath as URL? {\n        DispatchQueue.main.async {\n            self.moviePlayer.player = AVPlayer(url: path)\n            self.moviePlayer.player?.play()\n            self.moviePlayer.player?.volume = self.moviePlayerSoundLevel\n        }\n      }\n    }\n  }\n```\n\n播放视频，前面监听视频播放完成消息，然后走这个方法，可实现重复播放效果：\n```Swift\n  @objc func playerItemDidReachEnd() {\n    moviePlayer.player?.seek(to: kCMTimeZero)\n    moviePlayer.player?.play()\n  }\n```\n\n### 10.3 实现视频背景效果控制器\n\n```Swift\n @IBOutlet weak var loginButton: UIButton!\n    @IBOutlet weak var signupButton: UIButton!\n```\n这里搞2个View。\n\n```Swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    setupVideoBackground()\n    \n    loginButton.layer.cornerRadius = 4\n    signupButton.layer.cornerRadius = 4\n    \n}\n\nfunc setupVideoBackground() {\n    \n    let url = URL(fileURLWithPath: Bundle.main.path(forResource: \"moments\", ofType: \"mp4\")!)\n    \n    videoFrame = view.frame\n    fillMode = .resizeAspectFill\n    alwaysRepeat = true\n    sound = true\n    startTime = 2.0\n    alpha = 0.8\n    \n    contentURL = url\n    // view.isUserInteractionEnabled = false\n    \n}\n```\n这里初始化，设置视频背景，设置按钮圆角。\n\n### 10.4 视频剪切工具\n前面设置播放器，用到了一个VideoCutter类，\n这里：\n```Swift\n fileprivate func setMoviePlayer(_ url: URL){\n    let videoCutter = VideoCutter()\n    videoCutter.cropVideoWithUrl(videoUrl: url, startTime: startTime, duration: duration) { (videoPath, error) -> Void in\n      if let path = videoPath as URL? {\n        DispatchQueue.main.async {\n            self.moviePlayer.player = AVPlayer(url: path)\n            self.moviePlayer.player?.play()\n            self.moviePlayer.player?.volume = self.moviePlayerSoundLevel\n        }\n      }\n    }\n  }\n```\n这里其实是根据startTime和duration来剪切目标视频url，返回一个新的videoPath，这里再重新播放的。\n\n需要看下如何剪切的：\n```Swift\nextension String {\n  var convert: NSString { return (self as NSString) }\n}\n\n class VideoCutter: NSObject {\n\n  /**\n  Block based method for crop video url\n  \n  @param videoUrl Video url\n  @param startTime The starting point of the video segments\n  @param duration Total time, video length\n\n  */\n   func cropVideoWithUrl(videoUrl url: URL, startTime: CGFloat, duration: CGFloat, completion: ((_ videoPath: URL?, _ error: NSError?) -> Void)?) {\n    DispatchQueue.global(qos: DispatchQoS.QoSClass.default).async {\n        let asset = AVURLAsset(url: url, options: nil)\n        let exportSession = AVAssetExportSession(asset: asset, presetName: \"AVAssetExportPresetHighestQuality\")\n        let paths: NSArray = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true) as NSArray\n        var outputURL = paths.object(at: 0) as! String\n        let manager = FileManager.default\n        // 异常处理：\n        // try?: 将错误转化成可选异常,有错误发生时返回nil\n        // try!: 禁用错误传递，当确认无异常发生时使用，否则可能会发生运行时异常\n        // defer: 在即将离开当前代码块时执行一系列语句,延迟执行的语句不能包含任何控制转移语句，例如break、return语句，或是抛出一个错误。\n        // defer语句是从后往前执行\n        do {\n            try manager.createDirectory(atPath: outputURL, withIntermediateDirectories: true, attributes: nil)\n        } catch _ {\n        }\n        outputURL = outputURL.convert.appendingPathComponent(\"output.mp4\")\n        do {\n            try manager.removeItem(atPath: outputURL)\n        } catch _ {\n        }\n        if let exportSession = exportSession as AVAssetExportSession? {\n            exportSession.outputURL = URL(fileURLWithPath: outputURL)\n            exportSession.shouldOptimizeForNetworkUse = true\n            exportSession.outputFileType = AVFileType.mp4\n            let start = CMTimeMakeWithSeconds(Float64(startTime), 600)\n            let duration = CMTimeMakeWithSeconds(Float64(duration), 600)\n            let range = CMTimeRangeMake(start, duration)\n            exportSession.timeRange = range\n           \n            exportSession.exportAsynchronously {\n                switch exportSession.status {\n                case AVAssetExportSessionStatus.completed:\n                    completion?(exportSession.outputURL, nil)\n                case AVAssetExportSessionStatus.failed:\n                    print(\"Failed: \\(String(describing: exportSession.error))\")\n                case AVAssetExportSessionStatus.cancelled:\n                    print(\"Failed: \\(String(describing: exportSession.error))\")\n                default:\n                    print(\"default case\")\n                }\n            }\n        }\n    }\n  }\n}\n```\n这是个工具，简单看下就行。\n\n\n## 11 总结\n* 1.第一个是计时器demo，界面很简单，主要学会Timer用法，每次继续其实也是new了一个Timer，Timer的作用只是更新，数值是我们自己记录的。\n* 2.第二个改变字体，主要学会字体文件放在根目录，xCode会自动识别，然后设置字体可以通过UILabel的Font属性，其次学会UiTableView用法，懂得设置数据源和代理。\n* 3.本地视频，当然就是学会AVPlayer的用法，还要用到系统的一个控制器。\n* 4.摄像头，主要学会Session用法，input，outPut设置，通过设置AV预览图设置给UIView，达成预览效果，另外学会水平ScrollView可实现类似分页效果，当然坐标要按照屏幕宽度设置下。\n* 5.传送带效果，学会设置UICollectionView和UIScrollView的代理，做到良好的用户体验效果，滑动到半屏和不足半屏的考虑。另外学会了xib布局方式，可以绑定控制器。\n* 6.定位，学会使用系统提供的定位Api，在代理里面处理自己的逻辑。\n* 7.下拉刷新，是UIScrollView里面的refreshControl提供的功能，自带了loading效果，可以自行添加文案。\n* 8.炫彩音乐，主要学会音频播放，以及随机函数的用法，还有渐变色调用方式。\n* 9.图片缩放效果，这个主要是UIScrollView的子View这种方式提供的缩放效果，主要还是针对代理方法做一些调整。\n* 10.视频背景，这个主要就是学会构造一个基类控制器，可实现播放视频效果，通过配置不同参数丰富这个基类，然后另外就是学会视频剪切。\n\n\n\n\n\n\n\n\n\n\n","slug":"iOS-swift-3天30个Swift项目之第一天","published":1,"updated":"2023-02-05T13:12:36.613Z","_id":"cldofhihg0000crv73g4d6in5","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>参考项目：<a href=\"https://github.com/soapyigu/Swift-30-Projects\">https://github.com/soapyigu/Swift-30-Projects</a> </p>\n</blockquote>\n<h2 id=\"1-计时器\"><a href=\"#1-计时器\" class=\"headerlink\" title=\"1 计时器\"></a>1 计时器</h2><p>首先看下效果吧。<br><img src=01.gif></p>\n<h3 id=\"1-1-主要功能\"><a href=\"#1-1-主要功能\" class=\"headerlink\" title=\"1.1 主要功能\"></a>1.1 主要功能</h3><p>点击播放按钮，数字开始增加；<br>点击暂停按钮，数字停止增加；<br>点击“Reset”，数值置为0；</p>\n<h3 id=\"1-2-UI\"><a href=\"#1-2-UI\" class=\"headerlink\" title=\"1.2 UI\"></a>1.2 UI</h3><p>这里UI采用storyboard来实现。因为比较简单，就4个控件，拖进去故事版即可。<br><img src=1.2.png></p>\n<h3 id=\"1-3-功能实现\"><a href=\"#1-3-功能实现\" class=\"headerlink\" title=\"1.3 功能实现\"></a>1.3 功能实现</h3><p>ui声明，故事版可以直接拖进相关类中，自动生成：</p>\n<pre><code class=\"line-numbers language-Swift\">@IBOutlet weak var playBtn: UIButton!\n@IBOutlet weak var pauseBtn: UIButton!\n@IBOutlet weak var timeLabel: UILabel!\n</code></pre>\n<p>显示的数字声明：</p>\n<pre><code class=\"line-numbers language-Swift\"> // 浮点数默认是Double类型，若要使用Float，需要显示声明\n    // var counter: Float = 0.0\n    var counter: Float = 0.0 &#123;\n        // 属性观察器 \n        didSet &#123;\n            timeLabel.text = String(format: &quot;%.1f&quot;, counter)\n        &#125;\n    &#125;\n</code></pre>\n<p>这里的属性观察器是监听这个值变更情况，如果某个地方变更了这个值，那么会走里面的didSet回调。</p>\n<pre><code class=\"line-numbers language-Swift\">    // 知识点：存储属性和计算属性\n    override var preferredStatusBarStyle: UIStatusBarStyle &#123;\n        // 只读计算属性，可以去掉get和花括号\n//        get &#123;\n//            return UIStatusBarStyle.lightContent\n//        &#125;\n        return UIStatusBarStyle.lightContent\n    &#125;\n</code></pre>\n<p>上面的代码是控制状态栏图标颜色为亮色（白色），默认是黑色。</p>\n<pre><code class=\"line-numbers language-Swift\">  // 给予timer一个默认值，这样timer就不会为Optional,\n    // 后续可以不用再解包\n    // var timer = Timer()\n    \n    // 这样定义可以在不用timer时回收内存\n    var timer: Timer? = Timer()\n    var isPlaying = false\n</code></pre>\n<p>这里定义了定时器，和定时器Flag。</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        // 符合LosslessStringConvertible协议的，\n        // 都可以直接初始化一个String对象\n        // timeLabel.text = String(counter)\n        \n        // 改成使用属性观察器监控和响应属性值的变化\n        counter = 0.0\n    &#125;\n</code></pre>\n<p>这里在初始化时设置数值为0.0。</p>\n<pre><code class=\"line-numbers language-Swift\">  @IBAction func resetButtonDidTouch(_ sender: UIButton) &#123;\n        if let timerTemp = timer &#123;\n            timerTemp.invalidate()\n        &#125;\n        timer = nil\n        isPlaying = false\n        counter = 0\n        playBtn.isEnabled = true\n        pauseBtn.isEnabled = true\n    &#125;\n</code></pre>\n<p>上面是重置按钮点击事件。</p>\n<p>这个可以在故事版中右键视图，在Touch up inside中拖动到代码里面自动生成方法，具体实现逻辑由我们自行添加。这里是将定时器置为nil，然后将播放和暂停状态都设置为可点击状态。</p>\n<pre><code class=\"line-numbers language-Swift\">@IBAction func playButtonDidTouch(_ sender: UIButton) &#123;\n        playBtn.isEnabled = false\n        pauseBtn.isEnabled = true\n        // 调用实例的方法时建议用self.UpdateTimer,\n        // 不建议使用ViewController.UpdateTimer\n        // 因为若方法定义成了类方法，第二种方式编译器不会报错。\n        timer = Timer.scheduledTimer(timeInterval: 0.1, target:self, selector: #selector(self.UpdateTimer), userInfo: nil, repeats: true)\n        isPlaying = true\n    &#125;\n</code></pre>\n<p>这里是播放按钮的实现逻辑，这里面相当于new了一个Timer。间隔0.1s后刷新，然后会走一个selector里面的updateTimer方法更新数值。</p>\n<pre><code>   @objc func UpdateTimer() &#123;\n        counter = counter + 0.1\n    &#125;\n</code></pre>\n<p>这里变更数字，然后数值变化引起前面定义的didSet刷新，导致Lable数值更新。</p>\n<pre><code class=\"line-numbers language-Swift\"> @IBAction func pauseButtonDidTouch(_ sender: UIButton) &#123;\n        playBtn.isEnabled = true\n        pauseBtn.isEnabled = false\n        if let timerTemp = timer &#123;\n            timerTemp.invalidate()\n        &#125;\n        timer = nil\n        isPlaying = false\n        \n    &#125;\n</code></pre>\n<p>这里是暂停按钮实现逻辑，将按钮置灰，定时器invalidate，然后定时器置空。</p>\n<h2 id=\"2-自定义字体\"><a href=\"#2-自定义字体\" class=\"headerlink\" title=\"2 自定义字体\"></a>2 自定义字体</h2><h3 id=\"2-1-效果\"><a href=\"#2-1-效果\" class=\"headerlink\" title=\"2.1 效果\"></a>2.1 效果</h3><img src=Customfont.gif>\n\n<h3 id=\"2-2-字体文件\"><a href=\"#2-2-字体文件\" class=\"headerlink\" title=\"2.2 字体文件\"></a>2.2 字体文件</h3><p>首先放置在根目录下：<br><img src=02_1.png></p>\n<p>这里XCode会自动识别出字体文件：<br><img src=02_2.png></p>\n<h3 id=\"2-3-实现细节\"><a href=\"#2-3-实现细节\" class=\"headerlink\" title=\"2.3 实现细节\"></a>2.3 实现细节</h3><p>控制器可直接实现UITableViewDelegate, UITableViewDataSource,也可以扩展，最好是扩展，可读性好一点。</p>\n<pre><code class=\"line-numbers language-Swift\">class ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource &#123;\n    \n    static let identifier = &quot;FontCell&quot;\n</code></pre>\n<p>然后定义下数据和字体名称：</p>\n<pre><code class=\"line-numbers language-Swift\">   var data = [&quot;MFTongXin 30 Days Swift&quot;, &quot;MFJinHei 这些字体特别适合打「奋斗」和「理想」&quot;,\n                &quot;MFZhiHei 谢谢「造字工房」，本案例不涉及商业使用&quot;, &quot;Zapfino 使用到造字工房劲黑体，致黑体，童心体&quot;,\n                &quot;Gaspar呵呵，再见🤗 See you next Project&quot;, &quot;微博 @Allen朝辉&quot;,\n                &quot;测试测试测试测试测试测试&quot;, &quot;123&quot;, &quot;Alex&quot;, &quot;@@@@@@&quot;]\n    \n    var fontNames = [&quot;MFTongXin_Noncommercial-Regular&quot;,\n                     &quot;MFJinHei_Noncommercial-Regular&quot;,\n                     &quot;MFZhiHei_Noncommercial-Regular&quot;,\n                     &quot;Zapfino&quot;,\n                     &quot;Gaspar Regular&quot;]\n</code></pre>\n<p>然后定义下UI：</p>\n<pre><code class=\"line-numbers language-Swift\">  @IBOutlet weak var changeFontLabel: UILabel!\n    @IBOutlet weak var fontTableView: UITableView!\n</code></pre>\n<p>然后定义下选择字体索引：</p>\n<pre><code> var fontRowIndex = 0\n</code></pre>\n<p>生命周期初始化：</p>\n<pre><code class=\"line-numbers language-Swift\">   \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        // 在storyboard中直接设置了\n        // fontTableView.dataSource = self\n        // fontTableView.delegate = self\n        \n        // 使用手势加Label替换button\n        changeFontLabel.layer.cornerRadius = 50\n        changeFontLabel.layer.masksToBounds = true\n        // 设置为true才能响应手势\n        changeFontLabel.isUserInteractionEnabled = true\n        let gesture = UITapGestureRecognizer(target: self,\n                                             action: #selector(changeFontDidTouch(_:)))\n        changeFontLabel.addGestureRecognizer(gesture)\n    &#125;\n\n     @objc func changeFontDidTouch(_ sender: AnyObject) &#123;\n        \n        fontRowIndex = (fontRowIndex + 1) % 5\n        print(fontNames[fontRowIndex])\n        fontTableView.reloadData()\n        \n    &#125;\n</code></pre>\n<p>这里主要是给一个按钮添加了手势，手势设置了action，然后相当于给按钮添加点击事件，方法有很多，可以直接故事版添加事件，也可以这种手势添加点击事件。</p>\n<p>下面是TableView的协议实现，这里Cell用了默认的，无需新建Cell。</p>\n<pre><code class=\"line-numbers language-Swift\"> func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n        return 35\n    &#125;\n    \n    func numberOfSections(in tableView: UITableView) -&gt; Int &#123;\n        return 1\n    &#125;\n    \n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n//        let cell = fontTableView.dequeueReusableCell(withIdentifier: ViewController.identifier)\n        let cell = fontTableView.dequeueReusableCell(withIdentifier: ViewController.identifier, for: indexPath)\n        let text = data[indexPath.row]\n       \n        cell.textLabel?.text = text\n        cell.textLabel?.textColor = indexPath.row != fontRowIndex ? UIColor.white : UIColor.blue\n        cell.textLabel?.font = UIFont(name: self.fontNames[fontRowIndex], size:16)\n        \n        return cell\n    \n    &#125;\n\n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n        return data.count\n    &#125;\n</code></pre>\n<p>主要是在cellForRowAt显示了具体item效果，根据前面选择的字体索引，这里设置给cell了。</p>\n<h2 id=\"3-播放本地视频\"><a href=\"#3-播放本地视频\" class=\"headerlink\" title=\"3 播放本地视频\"></a>3 播放本地视频</h2><h3 id=\"3-1-效果\"><a href=\"#3-1-效果\" class=\"headerlink\" title=\"3.1 效果\"></a>3.1 效果</h3><img src=playvideo.gif>\n\n<h3 id=\"3-2-本地视频\"><a href=\"#3-2-本地视频\" class=\"headerlink\" title=\"3.2 本地视频\"></a>3.2 本地视频</h3><p>直接将mp4文件放置在根目录下。<br>Xcode可自动识别到Movie文件夹下。</p>\n<h3 id=\"3-3-Core-Data\"><a href=\"#3-3-Core-Data\" class=\"headerlink\" title=\"3.3 Core Data\"></a>3.3 Core Data</h3><p>这里播放本地视频并不依赖这个。<br>因为demo中有部分代码是这个，当然也是可以学习下的。<br>关于Core Data实际上是一个数据存储框架，类似Realm。<br>Ficow写的这篇文章还不错：<br> <a href=\"https://blog.ficowshen.com/page/post/52\">了解和采用 CoreData 框架 —— Ficow 陪你学 CoreData</a></p>\n<h3 id=\"3-4-UI定义\"><a href=\"#3-4-UI定义\" class=\"headerlink\" title=\"3.4 UI定义\"></a>3.4 UI定义</h3><pre><code class=\"line-numbers language-Swift\"> // Swift中mark的使用方式，效果等同OC重的 #pragma mark -\n   //MARK:- Variables\n   @IBOutlet weak var videoTableView: UITableView!\n</code></pre>\n<p> 这里就一个UITableView，展示一个列表。</p>\n<pre><code class=\"line-numbers language-Swift\">  var playViewController = AVPlayerViewController()\n  var playerView = AVPlayer()\n</code></pre>\n<p>然后这里定义并且初始化了视频播放关键类。<br>AVPlayerViewController是一个系统的控制器，用来播放视频的，这里播放本地视频其实也是跳转到系统默认的播放器来播放。</p>\n<pre><code class=\"line-numbers language-Swift\">var data = [\n        // 给项目编译后属于同一个module，所以Video不需要import就可以使用\n        Video(image: &quot;videoScreenshot01&quot;,\n              title: &quot;Introduce 3DS Mario&quot;,\n              source: &quot;Youtube - 06:32&quot;),\n        Video(image: &quot;videoScreenshot02&quot;,\n              title: &quot;Emoji Among Us&quot;,\n              source: &quot;Vimeo - 3:34&quot;),\n        Video(image: &quot;videoScreenshot03&quot;,\n              title: &quot;Seals Documentary&quot;,\n              source: &quot;Vine - 00:06&quot;),\n        Video(image: &quot;videoScreenshot04&quot;,\n              title: &quot;Adventure Time&quot;,\n              source: &quot;Youtube - 02:39&quot;),\n        Video(image: &quot;videoScreenshot05&quot;,\n              title: &quot;Facebook HQ&quot;,\n              source: &quot;Facebook - 10:20&quot;),\n        Video(image: &quot;videoScreenshot06&quot;,\n              title: &quot;Lijiang Lugu Lake&quot;,\n              source: &quot;Allen - 20:30&quot;)\n    ]\n</code></pre>\n<p>上面是列表页数据定义。</p>\n<pre><code class=\"line-numbers language-Swift\"> //MARK:- View Life Cycle\n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        \n        videoTableView.dataSource = self\n        videoTableView.delegate = self\n        \n    &#125;\n</code></pre>\n<p>初始化里面设置了数据源和代理。</p>\n<pre><code class=\"line-numbers language-Swift\">\n//MARK:- UIViewTableView DataSource &amp; Delegate\n// 知识点：扩展\n// 扩展和 Objective-C 中的分类类似，但没有名称\n// 扩展可以为一个类型添加新的功能，但是不能重写已有的功能。\n// 扩展可以添加新的计算型属性，但是不可以添加存储型属性，也不可以为已有属性添加属性观察器。\nextension ViewController: UITableViewDataSource, UITableViewDelegate &#123;\n    // Extensions must not contain stored properties\n    //var a = 1\n    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n    return 220\n    &#125;\n\n    func numberOfSections(in tableView: UITableView) -&gt; Int &#123;\n    return 2\n    &#125;\n\n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n    return data.count\n    &#125;\n\n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n\n    // 知识点：向下转型\n    // as! 强制类型转换，无法转换时会抛出运行时异常\n    // as？可选类型转换，无法转换时返回nil\n    let cell = videoTableView.dequeueReusableCell(withIdentifier: &quot;VideoCell&quot;, for: indexPath) as! VideoCell\n    let video = data[indexPath.row]\n\n    cell.videoScreenshot.image = UIImage(named: video.image)\n    cell.videoTitleLabel.text = video.title\n    cell.videoSourceLabel.text = video.source\n\n    return cell\n\n    &#125;\n&#125;\n</code></pre>\n<p>这里扩展实现了UITableView的代理和数据源。</p>\n<p>这里用到了一个Cell需要自定义。</p>\n<pre><code class=\"line-numbers language-Swift\">\n// 定义Video的结构体，属性初始化后不能被改变，因为结构体时值类型。\n// 在你每次定义一个新类或者结构体的时候，实际上你是定义了一个新的 Swift 类型。\n// 因此请使用UpperCamelCase这种方式来命名\nstruct Video &#123;\n    let image: String\n    let title: String\n    let source: String\n&#125;\n\nclass VideoCell: UITableViewCell &#123;\n\n    @IBOutlet weak var videoScreenshot: UIImageView!\n    @IBOutlet weak var videoTitleLabel: UILabel!\n    @IBOutlet weak var videoSourceLabel: UILabel!\n    \n    override func awakeFromNib() &#123;\n        super.awakeFromNib()\n        // Initialization code\n    &#125;\n\n    override func setSelected(_ selected: Bool, animated: Bool) &#123;\n        super.setSelected(selected, animated: animated)\n\n        // Configure the view for the selected state\n    &#125;\n\n&#125;\n</code></pre>\n<p>这个VideoCell是怎么添加视图的呢，当然也是故事版的作用了。<br>全局搜索了下VideoCell，发现Main.storyboard里面用到了这个VideoCell，这里关联到了故事版。<br><img src=03_1.png><br>这里注意到右上角是一个Custom Class，说明故事版是可以关联自定义类的，这里就把Cell关联进来了。</p>\n<p>然后还是在Main.storyboard中，给cell里面的botton添加了一个点击事件给控制器：</p>\n<pre><code class=\"line-numbers language-Swift\">@IBAction func playVideoButtonDidTouch(_ sender: AnyObject) &#123;\n        let path = Bundle.main.path(forResource: &quot;emoji zone&quot;, ofType: &quot;mp4&quot;)\n        \n        playerView = AVPlayer(url: URL(fileURLWithPath: path!))\n        \n        playViewController.player = playerView\n        \n        // 知识点：尾随闭包\n        // 在使用尾随闭包时，你不用写出它的参数标签\n        // 如果闭包表达式是函数或方法的唯一参数，则当你使用尾随闭包时，你甚至可以把 () 省略掉\n        // 完整形式如下：\n        //self.present(playViewController, animated: true, completion: &#123;\n        //    self.playViewController.player?.play()\n        //&#125;)\n        self.present(playViewController, animated: true) &#123;\n            self.playViewController.player?.play()\n        &#125;\n    &#125;\n &#125;\n</code></pre>\n<p>这里给系统的控制器设置了一个AVPlayer，AVPlayer里面设置了URL，这样实现了播放视频效果。</p>\n<h2 id=\"4-摄像头\"><a href=\"#4-摄像头\" class=\"headerlink\" title=\"4 摄像头\"></a>4 摄像头</h2><h3 id=\"4-1-效果预览\"><a href=\"#4-1-效果预览\" class=\"headerlink\" title=\"4.1 效果预览\"></a>4.1 效果预览</h3><img src=snapchatmenu.gif>\n\n<h3 id=\"4-2-UI\"><a href=\"#4-2-UI\" class=\"headerlink\" title=\"4.2 UI\"></a>4.2 UI</h3><p>这里主要是一个横滑的UIScrollView。<br>长度设置了屏幕的3倍，第一块放置一个UIImageView，中间放置摄像头，最后一块也放置了一个UIImageView。</p>\n<p>这里左侧的视图，采用了xib的方式来创建。<br>我个人理解，xib的方式有点类似Android的xml，因为我本身是学Android，希望大家原谅我这样比喻。xib也是很直观,可以看到效果，而且也可以挂载到某个具体的UIView上。</p>\n<p>左侧的xib是这样的：<br><img src=04_1.png></p>\n<p>右侧的xib是这样的：<br><img src=04_2.png></p>\n<p>中间的就是一个控制器来的,当然这个控制器也是可以关联xib的。<br>如何关联的？<br>这里有一个CameraView.xib，它的File’s Owner是CameraView，这样就关联起来了。所以再CameraView.swift里面操作的都是针对这个xib的逻辑处理。</p>\n<p>重点看下如何显示摄像头的吧：<br>首先是UI关联：</p>\n<pre><code>@IBOutlet weak var cameraView: UIView!\n</code></pre>\n<p>这个应该是拖进来的。</p>\n<p>然后就是几个关键的类：</p>\n<pre><code class=\"line-numbers language-Swift\"> var captureSession : AVCaptureSession?\n var stillImageOutput : AVCaptureStillImageOutput?\n var previewLayer : AVCaptureVideoPreviewLayer?\n</code></pre>\n<p>然后是将要显示的时候逻辑处理：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewWillAppear(_ animated: Bool) &#123;\n        super.viewWillAppear(animated)\n        \n        captureSession = AVCaptureSession()\n        // 已经不能再使用了\n        // captureSession?.sessionPreset = AVCaptureSessionPreset1920x1080\n        captureSession?.sessionPreset = AVCaptureSession.Preset.hd1920x1080\n        let backCamera = AVCaptureDevice.devices(for: .video).first!\n        // 已经不能再使用了\n        // let backCamera = AVCaptureDevice.defaultDevice(withMediaType: AVMediaTypeVideo)\n        var error : NSError?\n        var input: AVCaptureDeviceInput!\n        \n        do &#123;\n            input = try AVCaptureDeviceInput(device: backCamera) &#125;\n        catch let error1 as NSError &#123;\n            error = error1\n            input = nil\n        &#125;\n        \n        if (error == nil &amp;&amp; captureSession?.canAddInput(input) != nil) &#123;\n            \n                captureSession?.addInput(input)\n                \n                stillImageOutput = AVCaptureStillImageOutput()\n                stillImageOutput?.outputSettings = [AVVideoCodecKey : AVVideoCodecJPEG]\n                \n            if let stillImageOutputTemp = stillImageOutput &#123;\n                if captureSession?.canAddOutput(stillImageOutputTemp) != nil &#123;\n                    captureSession?.addOutput(stillImageOutputTemp)\n                    if let captureSessionTemp = captureSession &#123;\n                        previewLayer = AVCaptureVideoPreviewLayer(session: captureSessionTemp)\n                        previewLayer?.videoGravity = AVLayerVideoGravity.resizeAspect\n                        // 已经废弃不用了\n                        // previewLayer?.videoGravity = AVLayerVideoGravityResizeAspect\n                        previewLayer?.connection?.videoOrientation = AVCaptureVideoOrientation.portrait\n                        cameraView.layer.addSublayer(previewLayer!)\n                        captureSession?.startRunning()\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        \n    &#125;\n</code></pre>\n<p>主要是初始化了一个AVCaptureSession，然后又创建了一个AVCaptureDeviceInput来接收输入流，这样利用session.addInput，将输入流给input，然后搞一个输出流AVCaptureStillImageOutput，来接收captureSession.addOutPut，这样最后我们再创建一个 预览类叫做AVCaptureVideoPreviewLayer，里面放session，这样就得到一个Layer了。</p>\n<p>这个Layer我们就可以加到普通的UIView上了。</p>\n<h3 id=\"4-3-根控制器\"><a href=\"#4-3-根控制器\" class=\"headerlink\" title=\"4.3 根控制器\"></a>4.3 根控制器</h3><p>先定义一个UIScollView:</p>\n<pre><code class=\"line-numbers language-Swift\">\nclass ViewController: UIViewController &#123;\n    \n\n    @IBOutlet weak var scrollView: UIScrollView!\n</code></pre>\n<p>初始化添加子View，3块布局给它add进去：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n    super.viewDidLoad()\n    \n    // 已经废弃了，使用prefersStatusBarHidden属性返回设置的值\n    // UIApplication.shared.isStatusBarHidden = true\n    \n    let screenWidth = UIScreen.main.bounds.width\n    let screenHeight = UIScreen.main.bounds.height\n    let leftView: UIViewController = UINib(nibName: &quot;LeftView&quot;, bundle: nil).instantiate(withOwner: nil, options: nil)[0] as! UIViewController\n    let centerView: CameraView = CameraView(nibName: &quot;CameraView&quot;, bundle: nil)\n    let rightView: RightView = RightView(nibName: &quot;RightView&quot;, bundle: nil)\n    \n    leftView.view.frame = CGRect(x: 0, y: 0, width: screenWidth-200, height: screenHeight)\n    centerView.view.frame = CGRect(x: screenWidth, y: 0, width: screenWidth, height: screenHeight)\n    rightView.view.frame = CGRect(x: 2*screenWidth, y: 0, width: screenWidth, height: screenHeight)\n\n    self.scrollView.addSubview(leftView.view)\n    self.scrollView.addSubview(rightView.view)\n    self.scrollView.addSubview(centerView.view)\n    self.scrollView.contentSize = CGSize(width: screenWidth * 3, height: screenHeight)\n&#125;\n</code></pre>\n<p>frame要对应好屏幕坐标。<br>scrollView的contentSize刚好对应3个屏幕大小。</p>\n<p>这里可以直接创建一个UINib作为控制器，传xib的名称给它就可以的。</p>\n<p>另外这里用到了相机，需要相机的权限声明哦：<br>在info.plist文件下配置：<br>Privacy - Camera Usage Description </p>\n<p>然后Value自己随便填下就好了。</p>\n<h2 id=\"5-传送带效果\"><a href=\"#5-传送带效果\" class=\"headerlink\" title=\"5 传送带效果\"></a>5 传送带效果</h2><h3 id=\"5-1-效果\"><a href=\"#5-1-效果\" class=\"headerlink\" title=\"5.1 效果\"></a>5.1 效果</h3><img src=Carousel.gif>\n\n<h3 id=\"5-2-故事版关联\"><a href=\"#5-2-故事版关联\" class=\"headerlink\" title=\"5.2 故事版关联\"></a>5.2 故事版关联</h3><img src=5_1.png>\n首先Main.storyboard是在info.plist中注册的。\n然后这个首页故事版配置的控制器的Class就是代码区域表示的控制器了。\n层层关联环环相扣。\n\n<h3 id=\"5-3-UI\"><a href=\"#5-3-UI\" class=\"headerlink\" title=\"5.3 UI\"></a>5.3 UI</h3><p>这里其实就一个背景图片+一个UICollectionView。</p>\n<pre><code class=\"line-numbers language-Swift\">class HomeViewController: UIViewController &#123;\n\n    \n    @IBOutlet weak var backgroundImageView: UIImageView!\n    @IBOutlet weak var collectionView: UICollectionView!\n</code></pre>\n<h3 id=\"5-4-Data\"><a href=\"#5-4-Data\" class=\"headerlink\" title=\"5.4 Data\"></a>5.4 Data</h3><pre><code class=\"line-numbers language-Swift\">// 访问权限分物种：private，fileprivate，internal，public 和 open\n    // private：只能在本类的作用域且在当前文件内能访问\n    // fileprivate：只能在当前文件内能访问\n    // internal：本module内能访问\n    // public：跨module访问但不能重写或继承\n    // open：跨module访问并且能重写或继承\n    fileprivate var interests = Interest.createInterests()\n</code></pre>\n<pre><code class=\"line-numbers language-Swift\">class Interest\n&#123;\n    // MARK: - Public API\n    var title = &quot;&quot;\n    var description = &quot;&quot;\n    var numberOfMembers = 0\n    var numberOfPosts = 0\n    var featuredImage: UIImage!\n    \n    init(title: String, description: String, featuredImage: UIImage!)\n    &#123;\n        self.title = title\n        self.description = description\n        self.featuredImage = featuredImage\n        numberOfMembers = 1\n        numberOfPosts = 1\n    &#125;\n    \n    // MARK: - Private\n    // dummy data\n    static func createInterests() -&gt; [Interest]\n    &#123;\n        return [\n            Interest(title: &quot;Hello there, i miss u.&quot;, description: &quot;We love backpack and adventures! We walked to Antartica yesterday, and camped with some cute pinguines, and talked about this wonderful app idea. 🐧⛺️✨&quot;, featuredImage: UIImage(named: &quot;hello&quot;)!),\n            Interest(title: &quot;🐳🐳🐳🐳🐳&quot;, description: &quot;We love romantic stories. We walked to Antartica yesterday, and camped with some cute pinguines, and talked about this wonderful app idea. 🐧⛺️✨&quot;, featuredImage: UIImage(named: &quot;dudu&quot;)!),\n            Interest(title: &quot;Training like this, #bodyline&quot;, description: &quot;Create beautiful apps. We walked to Antartica yesterday, and camped with some cute pinguines, and talked about this wonderful app idea. 🐧⛺️✨&quot;, featuredImage: UIImage(named: &quot;bodyline&quot;)!),\n            Interest(title: &quot;I&#39;m hungry, indeed.&quot;, description: &quot;Cars and aircrafts and boats and sky. We walked to Antartica yesterday, and camped with some cute pinguines, and talked about this wonderful app idea. 🐧⛺️✨&quot;, featuredImage: UIImage(named: &quot;wave&quot;)!),\n            Interest(title: &quot;Dark Varder, #emoji&quot;, description: &quot;Meet life with full presence. We walked to Antartica yesterday, and camped with some cute pinguines, and talked about this wonderful app idea. 🐧⛺️✨&quot;, featuredImage: UIImage(named: &quot;darkvarder&quot;)!),\n            Interest(title: &quot;I have no idea, bitch&quot;, description: &quot;Get up to date with breaking-news. We walked to Antartica yesterday, and camped with some cute pinguines, and talked about this wonderful app idea. 🐧⛺️✨&quot;, featuredImage: UIImage(named: &quot;hhhhh&quot;)!),\n        ]\n    &#125;\n&#125;\n</code></pre>\n<p>这里创建了一个静态函数，就是数据定义了。</p>\n<h3 id=\"5-5-绑定数据\"><a href=\"#5-5-绑定数据\" class=\"headerlink\" title=\"5.5 绑定数据\"></a>5.5 绑定数据</h3><pre><code class=\"line-numbers language-Swift\">extension HomeViewController : UICollectionViewDataSource &#123;\n    \n    func numberOfSections(in collectionView: UICollectionView) -&gt; Int &#123;\n        return 1\n    &#125;\n    \n    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123;\n        return interests.count\n    &#125;\n    \n    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123;\n        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: Storyboard.CellIdentifier, for: indexPath) as! InterestCollectionViewCell\n        \n        cell.interest = self.interests[indexPath.item]\n        \n        return cell\n        \n    &#125;\n&#125;\n</code></pre>\n<p>这里就是UICollectionView的数据源了。<br>对应的Cell为InterestCollectionViewCell</p>\n<blockquote>\n<p>这里注意到这个UICollectionView好像没有设置dataSource和delegate，这里看了下Main.storyboard里面，果然在右侧看到Outlets设置了dataSource和delegate都给了控制器。所以说在故事版里面是可以设置数据源和代理的。</p>\n</blockquote>\n<p>如下：</p>\n<pre><code class=\"line-numbers language-Swift\">class InterestCollectionViewCell: UICollectionViewCell &#123;\n    \n    \n    var interest: Interest! &#123;\n        didSet &#123;\n            updateUI()\n        &#125;\n    &#125;\n    \n    @IBOutlet weak var featuredImageView: UIImageView!\n    @IBOutlet weak var interestTitleLabel: UILabel!\n    \n    fileprivate func updateUI() &#123;\n        interestTitleLabel?.text! = interest.title\n        featuredImageView?.image! = interest.featuredImage\n    &#125;\n    \n    override func layoutSubviews() &#123;\n        super.layoutSubviews()\n        \n        self.layer.cornerRadius = 5.0\n        self.clipsToBounds = true\n    &#125;\n&#125;\n</code></pre>\n<p>因为在Main.storyboard的已经关联了这个Cell，所以布局相关的都无需重新addView。</p>\n<p>上面这些代码就可以实现一个传送带效果。</p>\n<p>但是我们想要左滑，它自己能够刚好滑动到下一个屏幕，体验效果好一点的话要怎么办呢？</p>\n<p>我们想到第一个优化点：<br>一张图能不能刚好占一个屏幕，增大一点padding。</p>\n<p>可以的。</p>\n<p>利用UICollectionView提供的另外一个协议可以实现。答案就是：UICollectionViewDelegateFlowLayout。</p>\n<pre><code class=\"line-numbers language-Swift\">extension HomeViewController : UICollectionViewDelegateFlowLayout &#123;\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -&gt; CGSize &#123;\n        return CGSize(width: UIScreen.main.bounds.width - 2 * Storyboard.CellPadding, height: 450)\n    &#125;\n\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -&gt; CGFloat &#123;\n        return 2 * Storyboard.CellPadding\n    &#125;\n\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -&gt; UIEdgeInsets &#123;\n        return UIEdgeInsetsMake(0, Storyboard.CellPadding, 0, Storyboard.CellPadding)\n    &#125;\n&#125;\n</code></pre>\n<p>这里第一个sizeForItemAt方法：单个item的大小，长度为屏幕宽度-左右两个padding，高度写死450。<br>这里第二个方法minimumLine: collectionView的滚动方向为水平时，这个就是item之间的最小水平间距。<br>这里的第三个方法insetForSectionAt: 单个item的padding，设置上，左，右，下。</p>\n<p>第二个优化点：当滑动到一半多，自动切下一张，不足一半，切回上一张。<br>也好办。</p>\n<pre><code class=\"line-numbers language-Swift\">extension HomeViewController : UIScrollViewDelegate &#123;\n    func scrollViewWillEndDragging(_ scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer&lt;CGPoint&gt;) &#123;\n        let originPoint = targetContentOffset.pointee;\n        var index = Int(originPoint.x / UIScreen.main.bounds.width)\n        let offset = Int(originPoint.x) % Int(UIScreen.main.bounds.width)\n        index += (offset &gt; Int(UIScreen.main.bounds.width/2) ? 1 : 0)\n        targetContentOffset.pointee = CGPoint(x: index * Int(UIScreen.main.bounds.width) , y: 0)\n    &#125;\n&#125;\n</code></pre>\n<p>继续扩展下这个控制器，这里面，判断了offset在停止滑动后的逻辑。</p>\n<h2 id=\"6-定位\"><a href=\"#6-定位\" class=\"headerlink\" title=\"6 定位\"></a>6 定位</h2><h3 id=\"6-1-效果\"><a href=\"#6-1-效果\" class=\"headerlink\" title=\"6.1 效果\"></a>6.1 效果</h3><img src=mylocation.gif>\n\n<h3 id=\"6-2-UI\"><a href=\"#6-2-UI\" class=\"headerlink\" title=\"6.2 UI\"></a>6.2 UI</h3><p>这个UI比较简单，一个UILabel，一个按钮。</p>\n<p>这个按钮的点击事件直接通过故事版链接到了控制器，所以控制器无需有这个UIView，有这个点击事件就行了。<br><img src=06_1.png></p>\n<h3 id=\"6-3-如何定位\"><a href=\"#6-3-如何定位\" class=\"headerlink\" title=\"6.3 如何定位\"></a>6.3 如何定位</h3><p>首先声明一个全局变量：</p>\n<pre><code class=\"line-numbers language-Swift\">  // 强制自动解包，可以赋值为nil，为nil后再调用会报错\n    // 建议定义为：\n    // var locationManager: CLLocationManager\n    var locationManager: CLLocationManager!\n</code></pre>\n<p>开始定位：</p>\n<pre><code class=\"line-numbers language-Swift\">@IBAction func myLocationButtonDidTouch(_ sender: AnyObject) &#123; \n    locationManager = CLLocationManager()\n    locationManager.delegate = self\n    locationManager.desiredAccuracy = kCLLocationAccuracyBest\n    locationManager.requestAlwaysAuthorization()\n    locationManager.startUpdatingLocation()   \n&#125;\n</code></pre>\n<p>因为这里引入了CLLocationManager，那么在项目层级发现CoreLocation.framework自动引入进来了。</p>\n<p>直接这样还不够，还需要设置下协议才行。因为这里我们delegate设置了self。<br>这里我们同样可以新建一个Delegate，本质上扩展控制器，当然也可以直接写在控制器里面，都可以，最好是分一个文件，可读性会强一点。</p>\n<pre><code class=\"line-numbers language-Swift\">import Foundation\nimport CoreLocation\n\nextension ViewController : CLLocationManagerDelegate &#123;\n    \n    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) &#123;\n        \n        self.locationLabel.text = &quot;Error while updating location &quot; + error.localizedDescription\n        \n    &#125;\n    \n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) &#123;\n        CLGeocoder().reverseGeocodeLocation(locations.first!) &#123; (placemarks, error) in\n            guard error == nil else &#123;\n                self.locationLabel.text = &quot;Reverse geocoder failed with error&quot; + error!.localizedDescription\n                return\n            &#125;\n            if placemarks!.count &gt; 0 &#123;\n                let pm = placemarks!.first\n                self.displayLocationInfo(pm)\n            &#125; else &#123;\n                self.locationLabel.text = &quot;Problem with the data received from geocoder&quot;\n            &#125;\n        &#125;\n    &#125;\n    \n    func displayLocationInfo(_ placemark: CLPlacemark?) &#123;\n        if let containsPlacemark = placemark &#123;\n            //stop updating location to save battery life\n            locationManager.stopUpdatingLocation()\n            \n            let locality = (containsPlacemark.locality != nil) ? containsPlacemark.locality : &quot;&quot;\n            let postalCode = (containsPlacemark.postalCode != nil) ? containsPlacemark.postalCode : &quot;&quot;\n            let administrativeArea = (containsPlacemark.administrativeArea != nil) ? containsPlacemark.administrativeArea : &quot;&quot;\n            let country = (containsPlacemark.country != nil) ? containsPlacemark.country : &quot;&quot;\n            \n            self.locationLabel.text = postalCode! + &quot; &quot; + locality!\n            \n            self.locationLabel.text?.append(&quot;\\n&quot; + administrativeArea! + &quot;, &quot; + country!)\n        &#125;\n        \n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"7-下拉刷新\"><a href=\"#7-下拉刷新\" class=\"headerlink\" title=\"7 下拉刷新\"></a>7 下拉刷新</h2><h3 id=\"7-1-效果\"><a href=\"#7-1-效果\" class=\"headerlink\" title=\"7.1 效果\"></a>7.1 效果</h3><img src=07.gif>\n\n<h3 id=\"7-2-变量声明\"><a href=\"#7-2-变量声明\" class=\"headerlink\" title=\"7.2 变量声明\"></a>7.2 变量声明</h3><pre><code class=\"line-numbers language-Swift\">class ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate &#123;\n    \n    var index = 0\n    let cellIdentifer = &quot;NewCellIdentifier&quot;\n    \n    let favoriteEmoji = [&quot;🤗🤗🤗🤗🤗&quot;, &quot;😅😅😅😅😅&quot;, &quot;😆😆😆😆😆&quot;]\n    let newFavoriteEmoji = [&quot;🏃🏃🏃🏃🏃&quot;, &quot;💩💩💩💩💩&quot;, &quot;👸👸👸👸👸&quot;, &quot;🤗🤗🤗🤗🤗&quot;, &quot;😅😅😅😅😅&quot;, &quot;😆😆😆😆😆&quot; ]\n    var emojiData = [String]()\n    var tableView: UITableView!\n    \n    var refreshControl = UIRefreshControl()\n    var navBar: UINavigationBar = UINavigationBar(frame: CGRect(x: 0, y: 0, width: 375, height: 64))\n</code></pre>\n<p>这里继承了UIViewController，然后再Main.storyboard中配置了首页的控制器就是这个，这样就直接启动这个控制器了。</p>\n<p>这里定义了初始化数据3条，更新后的6条。<br>模拟刷新后的数据变化。</p>\n<p>这里不是再故事版里面加视图，直接在代码里面new了。</p>\n<h3 id=\"7-3-viewDidLoad初始化\"><a href=\"#7-3-viewDidLoad初始化\" class=\"headerlink\" title=\"7.3 viewDidLoad初始化\"></a>7.3 viewDidLoad初始化</h3><pre><code class=\"line-numbers language-Swift\"> override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        // 这里new一个UITableView\n        tableView = UITableView(frame: self.view.bounds, style: .plain)\n        \n        // 初始数据\n        emojiData = favoriteEmoji\n        let emojiTableView = tableView\n        \n        // 数据源设置，注册Cell，这里的Cell比较简单，直接用了UITableViewCell可满足\n        emojiTableView?.backgroundColor = UIColor(red:0.092, green:0.096, blue:0.116, alpha:1)\n        emojiTableView?.dataSource = self\n        emojiTableView?.register(UITableViewCell.self, forCellReuseIdentifier: cellIdentifer)\n        \n        // 因为TableView是UIScrollViw，这里也有这个refreshControl的属性\n        tableView.refreshControl = self.refreshControl\n        self.refreshControl.addTarget(self, action: #selector(ViewController.didRoadEmoji), for: .valueChanged)\n        \n        // 自定义刷新器 这里的loading效果猜测是refreshControl自带的\n        self.refreshControl.backgroundColor = UIColor(red:0.113, green:0.113, blue:0.145, alpha:1)\n        let attributes = [NSAttributedStringKey.foregroundColor: UIColor.white]\n        // 这里是loading下方的文案\n        self.refreshControl.attributedTitle = NSAttributedString(string: &quot;Last updated on \\(Date())&quot;, attributes: attributes)\n        self.refreshControl.tintColor = UIColor.white\n        \n        self.title = &quot;emoji&quot;\n        self.navBar.barStyle = UIBarStyle.blackTranslucent\n        \n        emojiTableView?.rowHeight = UITableViewAutomaticDimension\n        emojiTableView?.estimatedRowHeight = 60.0\n        emojiTableView?.tableFooterView = UIView(frame: CGRect.zero)\n        emojiTableView?.separatorStyle = UITableViewCellSeparatorStyle.none\n        \n        // 代码add子View\n        self.view.addSubview(emojiTableView!)\n        self.view.addSubview(navBar)\n    &#125;\n</code></pre>\n<p>这里通过在代码里面new一个UITableView方式，也是可以实现UI效果。</p>\n<h3 id=\"7-4-设置代理和数据源\"><a href=\"#7-4-设置代理和数据源\" class=\"headerlink\" title=\"7.4 设置代理和数据源\"></a>7.4 设置代理和数据源</h3><pre><code class=\"line-numbers language-Swift\">func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n        return emojiData.count\n    &#125;\n    \nfunc numberOfSections(in tableView: UITableView) -&gt; Int &#123;\n    return 1\n&#125;\n\n\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n    let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifer)! as UITableViewCell\n    cell.textLabel!.text = self.emojiData[indexPath.row]\n    cell.textLabel!.textAlignment = NSTextAlignment.center\n    cell.textLabel!.font = UIFont.systemFont(ofSize: 50)\n    cell.backgroundColor = UIColor.clear\n    cell.selectionStyle = UITableViewCellSelectionStyle.none\n\n    return cell\n&#125;\n</code></pre>\n<p>这里给Cell设置数据了。</p>\n<h3 id=\"7-5-下拉监听\"><a href=\"#7-5-下拉监听\" class=\"headerlink\" title=\"7.5 下拉监听\"></a>7.5 下拉监听</h3><pre><code class=\"line-numbers language-Swift\">@objc func didRoadEmoji() &#123;\n    DispatchQueue.main.asyncAfter(deadline:DispatchTime.now() + 3 ) &#123;\n        self.emojiData = [self.newFavoriteEmoji,self.favoriteEmoji][self.index]\n        self.tableView.reloadData()\n        self.refreshControl.endRefreshing()\n        self.index = (self.index + 1) % 2\n    &#125;\n&#125;\n</code></pre>\n<p>DispatchQueue.main.asyncAfter： 主线程执行延迟任务方法。<br>这里延迟3s后，去更新数据。然后控制器取消刷新。</p>\n<h2 id=\"8-炫彩音乐\"><a href=\"#8-炫彩音乐\" class=\"headerlink\" title=\"8 炫彩音乐\"></a>8 炫彩音乐</h2><h3 id=\"8-1-效果\"><a href=\"#8-1-效果\" class=\"headerlink\" title=\"8.1 效果\"></a>8.1 效果</h3><img src=randomMusicColor.gif>\n\n<h3 id=\"8-2-全局变量定义\"><a href=\"#8-2-全局变量定义\" class=\"headerlink\" title=\"8.2 全局变量定义\"></a>8.2 全局变量定义</h3><pre><code class=\"line-numbers language-Swift\">var audioPlayer = AVAudioPlayer()\n    \nlet gradientLayer = CAGradientLayer()\n\nvar timer : Timer?\n\nvar backgroundColor: (red: CGFloat, green: CGFloat,blue: CGFloat,alpha: CGFloat)! &#123;\n    didSet &#123;\n        let color1 = UIColor(red: backgroundColor.blue,\n                                green: backgroundColor.green,\n                                blue: 0,\n                                alpha: backgroundColor.alpha).cgColor\n        let color2 = UIColor(red: backgroundColor.red,\n                                green: backgroundColor.green,\n                                blue: backgroundColor.blue,\n                                alpha: backgroundColor.alpha).cgColor\n        gradientLayer.colors = [color1, color2]\n    &#125;\n&#125;\n</code></pre>\n<p>这里第一个是AVAudioPlayer，负责音频播放。<br>这里第二个类是CAGradientLayer，负责渐变色渲染。<br>timer是定时器。<br>backgroundColor背景色，如果任何地方更改后，触发渐变色颜色变化。</p>\n<h3 id=\"8-3-播放音乐\"><a href=\"#8-3-播放音乐\" class=\"headerlink\" title=\"8.3 播放音乐\"></a>8.3 播放音乐</h3><pre><code class=\"line-numbers language-Swift\">@IBAction func playMusicButtonDidTouch(_ sender: AnyObject) &#123;\n        \n    //play bg music\n    let bgMusic = URL(fileURLWithPath: Bundle.main.path(forResource: &quot;Ecstasy&quot;, ofType: &quot;mp3&quot;)!)\n    \n    do &#123;\n        try AVAudioSession.sharedInstance().setCategory(AVAudioSessionCategoryPlayback)\n        try AVAudioSession.sharedInstance().setActive(true)\n        try audioPlayer = AVAudioPlayer(contentsOf: bgMusic)\n        \n        audioPlayer.prepareToPlay()\n        audioPlayer.play()\n        \n    &#125;\n    catch let audioError as NSError &#123;\n        print(audioError)\n    &#125;\n    \n    if (timer == nil) &#123;\n        timer = Timer.scheduledTimer(timeInterval: 0.2, target: self, selector: #selector(ViewController.randomColor), userInfo: nil, repeats: true)\n    &#125;\n    \n    let redValue = CGFloat(drand48())\n    let blueValue =  CGFloat(drand48())\n    let greenValue = CGFloat(drand48())\n    \n    self.view.backgroundColor = UIColor(red: redValue, green: greenValue, blue: blueValue, alpha: 1.0)\n    \n    //graditent color\n    gradientLayer.frame = view.bounds\n    gradientLayer.startPoint = CGPoint(x: 0, y: 0)\n    gradientLayer.endPoint = CGPoint(x: 1, y: 1)\n    \n    self.view.layer.addSublayer(gradientLayer)\n    \n&#125;\n</code></pre>\n<p>这里先利用AVAudioSession的单例类设置Active，然后利用AVAudioPlayer播放本地音乐。</p>\n<p>然后后面搞了0.2s刷新的周期定时器。每次会执行这个函数：</p>\n<pre><code class=\"line-numbers language-Swift\">@objc func randomColor() &#123;\n    \n    let redValue = CGFloat(drand48())\n    let blueValue =  CGFloat(drand48())\n    let greenValue = CGFloat(drand48())\n    \n    \n    backgroundColor = (redValue, blueValue, greenValue, 1)\n    \n&#125;\n</code></pre>\n<p>这里红蓝绿会随机获取一个值，生成一个颜色值。同时会更新渐变层变更，这样背景就随机变化了。</p>\n<h2 id=\"9-图片缩放效果\"><a href=\"#9-图片缩放效果\" class=\"headerlink\" title=\"9 图片缩放效果\"></a>9 图片缩放效果</h2><h3 id=\"9-1-效果\"><a href=\"#9-1-效果\" class=\"headerlink\" title=\"9.1 效果\"></a>9.1 效果</h3><img src=09.gif>\n\n<h3 id=\"9-2-布局构造\"><a href=\"#9-2-布局构造\" class=\"headerlink\" title=\"9.2 布局构造\"></a>9.2 布局构造</h3><p>这里看了下Main.storyboard<br>貌似是在ScrollView里面放了一个ImageView哦。</p>\n<p>这里有个细节，就是背景有点毛玻璃效果。<br>其实是这样的，它在Main.storyboard底部设置了一张UIImageView，其实就是这张图片。<br>然后再搞了一个UIVisualEffectView覆盖再上面，就形成了一种毛玻璃效果。</p>\n<p>回到控制器里面，这里无非就是两个视图，并且把这个Constraint约束也加进来了，有4个约束，顶部约束，头部约束，底部约束和尾部约束。</p>\n<pre><code class=\"line-numbers language-Swift\">@IBOutlet weak var scrollView: UIScrollView!\n@IBOutlet weak var imageView: UIImageView!\n@IBOutlet weak var imageViewTopConstraint: NSLayoutConstraint!\n@IBOutlet weak var imageViewTrailingConstraint: NSLayoutConstraint!\n@IBOutlet weak var imageViewBottomConstraint: NSLayoutConstraint!\n@IBOutlet weak var imageViewLeadingConstraint: NSLayoutConstraint!\n</code></pre>\n<h3 id=\"9-3-代码实现\"><a href=\"#9-3-代码实现\" class=\"headerlink\" title=\"9.3 代码实现\"></a>9.3 代码实现</h3><p>首先在初始化里面配置了一个mask:</p>\n<pre><code class=\"line-numbers language-Swift\"> scrollView.autoresizingMask = [.flexibleWidth, .flexibleHeight]\n</code></pre>\n<p>这个是自动调整尺寸设置。</p>\n<p>其实ScrollView本来就支持缩放的：</p>\n<blockquote>\n<p>在iOS中，滚动视图UIScrollView用于查看大于屏幕的内容。Scroll View有两个主要目的：<br>让用户拖动视图以显示更多内容区域。<br>让用户使用捏合手势放大或缩小所显示的内容。</p>\n</blockquote>\n<p>这里需要关注一个生命周期函数：viewWillLayoutSubviews</p>\n<blockquote>\n<p>有以下几种情况会调用（init初始化不会触发layoutSubviews）<br>1、addSubview会触发viewWillLayoutSubviews<br>2、设置self.view及子视图的frame.size会触发layoutSubviews，当然前提是frame.size的值设置前后发生了变化,注意，此处不是origin，呼应官方文档上的边界发生变化<br>3、滚动一个UIScrollView(该scrollview有子视图的时候)会触发layoutSubviews<br>4、横竖屏幕切换会触发</p>\n</blockquote>\n<p>这里最为关键的就是这个 viewWillLayoutSubviews函数和viewForZooming了,如果没有这个代码，无法支持缩放效果!</p>\n<pre><code class=\"line-numbers language-Swift\">//每次控制器更新其子视图时，更新最小缩放比例\noverride func viewWillLayoutSubviews() &#123;\n    super.viewWillLayoutSubviews()\n    updateMinZoomScaleForSize(view.bounds.size)\n&#125;\n\n//计算scrollView的缩放比例，缩放比例为1表示内容以正常大小显示；缩放比例小于1表示容器内的内容缩小，缩放比例大于1表示放大容器内的内容\nfileprivate func updateMinZoomScaleForSize(_ size: CGSize)\n&#123;\n    //要获得最小的缩放比例，首先计算所需的缩放比例，以便根据其宽度在scrollView中紧贴imageView\n    let widthScale = size.width / imageView.bounds.width\n    let heightScale = size.height / imageView.bounds.height\n    //选取宽度和高度比例中最小的那个,设置为minimumZoomScale\n    let minScale = min(widthScale,heightScale)\n    \n    scrollView.minimumZoomScale = minScale\n    scrollView.maximumZoomScale = 3.0\n    scrollView.zoomScale = minScale\n&#125;\n</code></pre>\n<p>这样ScrollView就有一个最小和最大缩放比例了。</p>\n<p>另外还有一个协议：</p>\n<pre><code class=\"line-numbers language-Swift\">func viewForZooming(in scrollView: UIScrollView) -&gt; UIView? &#123;\n    //当手势动作发生时，scrollView告诉控制器要放大或缩小子视图imageView\n    return imageView\n&#125;\n</code></pre>\n<p>必须要有viewForZooming，这个作用就是谁可以放大或缩小。</p>\n<p>viewForZooming+viewWillLayoutSubviews，两者结合才能实现子View缩放效果。</p>\n<p>两位还有一个scrollViewDidZoom方法, 当scrollView缩放时调用,在缩放过程中会被多次调用：</p>\n<pre><code class=\"line-numbers language-Swift\">func scrollViewDidZoom(_ scrollView: UIScrollView) &#123;\n    updateConstraintsForSize(view.bounds.size)\n&#125;\n\n//当scrollView的内容大小小于边界时，内容将放置在左上角而不是中心，updateConstraintForSize方法处理这个问题；通过调整图像视图的布局约束。\nfileprivate func updateConstraintsForSize(_ size: CGSize) &#123;\n    \n    ////将图像垂直居中，从视图高度减去imageView的高度并分成两半，这个值用作顶部和底部imageView的约束\n    let yOffset = max(0, (size.height - imageView.frame.height) / 2)\n    imageViewTopConstraint.constant = yOffset\n    imageViewBottomConstraint.constant = yOffset\n    \n    ////根据宽度计算imageView前后约束的偏移量\n    let xOffset = max(0, (size.width - imageView.frame.width) / 2)\n    imageViewLeadingConstraint.constant = xOffset\n    imageViewTrailingConstraint.constant = xOffset\n    \n    view.layoutIfNeeded()\n&#125;\n</code></pre>\n<p>另外还有其它的代理方法如下：</p>\n<blockquote>\n<p>func scrollViewDidScroll(_ scrollView: UIScrollView)<br>scrollView滚动时调用，在滚动过程中会多次调用</p>\n</blockquote>\n<blockquote>\n<p>func scrollViewWillBeginDragging(_ scrollView: UIScrollView)<br>将要开始拖拽时调用</p>\n</blockquote>\n<blockquote>\n<p>func scrollViewWillEndDragging(_ scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer<CGPoint>)<br>将要停止拖拽时 velocity:加速度 向左滑动 x为负值，否则为正值 向上滚动为y为负值否则为正值；targetContentOffset:滚动停止时的ContentOffset</p>\n</blockquote>\n<blockquote>\n<p>func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool)<br>停止拖拽时调用， willDecelerate:停止拖拽时是否要减速，若值为false表示已经停止减速，也就意味着滚动已停止，此时不会调用scrollViewWillBeginDecelerating和scrollViewDidEndDecelerating;若值为true，则代表scrollView正在减速滚动</p>\n</blockquote>\n<blockquote>\n<p>func scrollViewWillBeginDecelerating(_ scrollView: UIScrollView)<br>开始减速的时候调用(也就是松开手指时)，在拖拽滚动的时候，如果松手时已经停止滚动则不会调用</p>\n</blockquote>\n<blockquote>\n<p>func scrollViewDidEndDecelerating(_ scrollView: UIScrollView)<br>停止减速的时候调用（也就是停止滚动的时候调用），在拖拽滚动的时候，如果松手时已经停止滚动则不会调用</p>\n</blockquote>\n<blockquote>\n<p>func scrollViewDidEndScrollingAnimation(_ scrollView: UIScrollView)<br>当调用setContentOffset(_ contentOffset: CGPoint, animated: Bool)&#x2F;scrollRectToVisible(_ rect: CGRect, animated: Bool)API并且animated参数为true时,会在scrollView滚动结束时调用。若是UITableView或者UICollectionView,调用scrollToRow也和上面一样</p>\n</blockquote>\n<blockquote>\n<p>func viewForZooming(in scrollView: UIScrollView) -&gt; UIView?<br>放回要缩放的view，此view必须是scrollView的subview</p>\n</blockquote>\n<blockquote>\n<p>func scrollViewDidZoom(_ scrollView: UIScrollView)<br>当scrollView缩放时调用,在缩放过程中会被多次调用</p>\n</blockquote>\n<blockquote>\n<p>func scrollViewWillBeginZooming(_ scrollView: UIScrollView, with view: UIView?)<br>scrollView开始缩放时调用</p>\n</blockquote>\n<blockquote>\n<p>func scrollViewDidEndZooming(_ scrollView: UIScrollView, with view: UIView?, atScale scale: CGFloat)<br>scrollView结束缩放时调用</p>\n</blockquote>\n<blockquote>\n<p>func scrollViewShouldScrollToTop(_ scrollView: UIScrollView) -&gt; Bool<br>是否允许点击scrollview的头部，让其滚动到最上面,若不实现此代理，则默认为true</p>\n</blockquote>\n<blockquote>\n<p>func scrollViewDidScrollToTop(_ scrollView: UIScrollView)<br>当滚动到最上面时调用</p>\n</blockquote>\n<h2 id=\"10-视频背景\"><a href=\"#10-视频背景\" class=\"headerlink\" title=\"10 视频背景\"></a>10 视频背景</h2><h3 id=\"10-1-效果\"><a href=\"#10-1-效果\" class=\"headerlink\" title=\"10.1 效果\"></a>10.1 效果</h3><img src=videobg.gif>\n\n<h3 id=\"10-2-定义一个基类播放控制器\"><a href=\"#10-2-定义一个基类播放控制器\" class=\"headerlink\" title=\"10.2 定义一个基类播放控制器\"></a>10.2 定义一个基类播放控制器</h3><pre><code class=\"line-numbers language-Swift\">public enum ScalingMode &#123;\n  case resize\n  case resizeAspect\n  case resizeAspectFill\n&#125;\n</code></pre>\n<p>定义了3种缩放模式。</p>\n<p>再定义有关视频的属性：</p>\n<pre><code class=\"line-numbers language-Swift\">// 视频播放器\nfileprivate let moviePlayer = AVPlayerViewController()\n     \n  // 声音   \n  fileprivate var moviePlayerSoundLevel: Float = 1.0\n\n   // 播放url  \n   var contentURL: URL? &#123;\n    didSet &#123;\n      if let _contentURL = contentURL &#123;\n      setMoviePlayer(_contentURL)\n      &#125;\n    &#125;\n  &#125;\n\n   var videoFrame: CGRect = CGRect()\n   var startTime: CGFloat = 0.0\n   var duration: CGFloat = 0.0\n\n   // 背景\n   var backgroundColor: UIColor = UIColor.black &#123;\n    didSet &#123;\n      view.backgroundColor = backgroundColor\n    &#125;\n  &#125;\n\n  // 声音\n   var sound: Bool = true &#123;\n    didSet &#123;\n      if sound &#123;\n        moviePlayerSoundLevel = 1.0\n      &#125;else&#123;\n        moviePlayerSoundLevel = 0.0\n      &#125;\n    &#125;\n  &#125;\n  \n  // alpha\n   var alpha: CGFloat = CGFloat() &#123;\n    didSet &#123;\n      moviePlayer.view.alpha = alpha\n    &#125;\n  &#125;\n\n  // 是否重复 这里发送一个全局通知\n   var alwaysRepeat: Bool = true &#123;\n    didSet &#123;\n      if alwaysRepeat &#123;\n        NotificationCenter.default.addObserver(self,\n          selector: #selector(VideoSplashViewController.playerItemDidReachEnd),\n          name: NSNotification.Name.AVPlayerItemDidPlayToEndTime,\n          object: moviePlayer.player?.currentItem)\n      &#125;\n    &#125;\n  &#125;\n\n  // 填充模式\n   var fillMode: ScalingMode = .resizeAspectFill &#123;\n    didSet &#123;\n      switch fillMode &#123;\n      case .resize:\n          moviePlayer.videoGravity = AVLayerVideoGravity.resize.rawValue\n      case .resizeAspect:\n          moviePlayer.videoGravity = AVLayerVideoGravity.resizeAspect.rawValue\n      case .resizeAspectFill:\n          moviePlayer.videoGravity = AVLayerVideoGravity.resizeAspectFill.rawValue\n      &#125;\n    &#125;\n  &#125;\n</code></pre>\n<p>生命周期已经显示,添加子View和视频view：</p>\n<pre><code class=\"line-numbers language-Swift\">  override func viewDidAppear(_ animated: Bool) &#123;\n    moviePlayer.view.frame = videoFrame\n    moviePlayer.showsPlaybackControls = false\n    view.addSubview(moviePlayer.view)\n    view.sendSubview(toBack: moviePlayer.view)\n  &#125;\n</code></pre>\n<p>生命周期将要消失，移除通知：</p>\n<pre><code class=\"line-numbers language-Swift\">  override func viewWillDisappear(_ animated: Bool) &#123;\n    super.viewDidDisappear(animated)\n    NotificationCenter.default.removeObserver(self)\n  &#125;\n</code></pre>\n<p>设置播放器：</p>\n<pre><code class=\"line-numbers language-Swift\"> fileprivate func setMoviePlayer(_ url: URL)&#123;\n    let videoCutter = VideoCutter()\n    videoCutter.cropVideoWithUrl(videoUrl: url, startTime: startTime, duration: duration) &#123; (videoPath, error) -&gt; Void in\n      if let path = videoPath as URL? &#123;\n        DispatchQueue.main.async &#123;\n            self.moviePlayer.player = AVPlayer(url: path)\n            self.moviePlayer.player?.play()\n            self.moviePlayer.player?.volume = self.moviePlayerSoundLevel\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n</code></pre>\n<p>播放视频，前面监听视频播放完成消息，然后走这个方法，可实现重复播放效果：</p>\n<pre><code class=\"line-numbers language-Swift\">  @objc func playerItemDidReachEnd() &#123;\n    moviePlayer.player?.seek(to: kCMTimeZero)\n    moviePlayer.player?.play()\n  &#125;\n</code></pre>\n<h3 id=\"10-3-实现视频背景效果控制器\"><a href=\"#10-3-实现视频背景效果控制器\" class=\"headerlink\" title=\"10.3 实现视频背景效果控制器\"></a>10.3 实现视频背景效果控制器</h3><pre><code class=\"line-numbers language-Swift\"> @IBOutlet weak var loginButton: UIButton!\n    @IBOutlet weak var signupButton: UIButton!\n</code></pre>\n<p>这里搞2个View。</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n    super.viewDidLoad()\n    setupVideoBackground()\n    \n    loginButton.layer.cornerRadius = 4\n    signupButton.layer.cornerRadius = 4\n    \n&#125;\n\nfunc setupVideoBackground() &#123;\n    \n    let url = URL(fileURLWithPath: Bundle.main.path(forResource: &quot;moments&quot;, ofType: &quot;mp4&quot;)!)\n    \n    videoFrame = view.frame\n    fillMode = .resizeAspectFill\n    alwaysRepeat = true\n    sound = true\n    startTime = 2.0\n    alpha = 0.8\n    \n    contentURL = url\n    // view.isUserInteractionEnabled = false\n    \n&#125;\n</code></pre>\n<p>这里初始化，设置视频背景，设置按钮圆角。</p>\n<h3 id=\"10-4-视频剪切工具\"><a href=\"#10-4-视频剪切工具\" class=\"headerlink\" title=\"10.4 视频剪切工具\"></a>10.4 视频剪切工具</h3><p>前面设置播放器，用到了一个VideoCutter类，<br>这里：</p>\n<pre><code class=\"line-numbers language-Swift\"> fileprivate func setMoviePlayer(_ url: URL)&#123;\n    let videoCutter = VideoCutter()\n    videoCutter.cropVideoWithUrl(videoUrl: url, startTime: startTime, duration: duration) &#123; (videoPath, error) -&gt; Void in\n      if let path = videoPath as URL? &#123;\n        DispatchQueue.main.async &#123;\n            self.moviePlayer.player = AVPlayer(url: path)\n            self.moviePlayer.player?.play()\n            self.moviePlayer.player?.volume = self.moviePlayerSoundLevel\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n</code></pre>\n<p>这里其实是根据startTime和duration来剪切目标视频url，返回一个新的videoPath，这里再重新播放的。</p>\n<p>需要看下如何剪切的：</p>\n<pre><code class=\"line-numbers language-Swift\">extension String &#123;\n  var convert: NSString &#123; return (self as NSString) &#125;\n&#125;\n\n class VideoCutter: NSObject &#123;\n\n  /**\n  Block based method for crop video url\n  \n  @param videoUrl Video url\n  @param startTime The starting point of the video segments\n  @param duration Total time, video length\n\n  */\n   func cropVideoWithUrl(videoUrl url: URL, startTime: CGFloat, duration: CGFloat, completion: ((_ videoPath: URL?, _ error: NSError?) -&gt; Void)?) &#123;\n    DispatchQueue.global(qos: DispatchQoS.QoSClass.default).async &#123;\n        let asset = AVURLAsset(url: url, options: nil)\n        let exportSession = AVAssetExportSession(asset: asset, presetName: &quot;AVAssetExportPresetHighestQuality&quot;)\n        let paths: NSArray = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true) as NSArray\n        var outputURL = paths.object(at: 0) as! String\n        let manager = FileManager.default\n        // 异常处理：\n        // try?: 将错误转化成可选异常,有错误发生时返回nil\n        // try!: 禁用错误传递，当确认无异常发生时使用，否则可能会发生运行时异常\n        // defer: 在即将离开当前代码块时执行一系列语句,延迟执行的语句不能包含任何控制转移语句，例如break、return语句，或是抛出一个错误。\n        // defer语句是从后往前执行\n        do &#123;\n            try manager.createDirectory(atPath: outputURL, withIntermediateDirectories: true, attributes: nil)\n        &#125; catch _ &#123;\n        &#125;\n        outputURL = outputURL.convert.appendingPathComponent(&quot;output.mp4&quot;)\n        do &#123;\n            try manager.removeItem(atPath: outputURL)\n        &#125; catch _ &#123;\n        &#125;\n        if let exportSession = exportSession as AVAssetExportSession? &#123;\n            exportSession.outputURL = URL(fileURLWithPath: outputURL)\n            exportSession.shouldOptimizeForNetworkUse = true\n            exportSession.outputFileType = AVFileType.mp4\n            let start = CMTimeMakeWithSeconds(Float64(startTime), 600)\n            let duration = CMTimeMakeWithSeconds(Float64(duration), 600)\n            let range = CMTimeRangeMake(start, duration)\n            exportSession.timeRange = range\n           \n            exportSession.exportAsynchronously &#123;\n                switch exportSession.status &#123;\n                case AVAssetExportSessionStatus.completed:\n                    completion?(exportSession.outputURL, nil)\n                case AVAssetExportSessionStatus.failed:\n                    print(&quot;Failed: \\(String(describing: exportSession.error))&quot;)\n                case AVAssetExportSessionStatus.cancelled:\n                    print(&quot;Failed: \\(String(describing: exportSession.error))&quot;)\n                default:\n                    print(&quot;default case&quot;)\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<p>这是个工具，简单看下就行。</p>\n<h2 id=\"11-总结\"><a href=\"#11-总结\" class=\"headerlink\" title=\"11 总结\"></a>11 总结</h2><ul>\n<li>1.第一个是计时器demo，界面很简单，主要学会Timer用法，每次继续其实也是new了一个Timer，Timer的作用只是更新，数值是我们自己记录的。</li>\n<li>2.第二个改变字体，主要学会字体文件放在根目录，xCode会自动识别，然后设置字体可以通过UILabel的Font属性，其次学会UiTableView用法，懂得设置数据源和代理。</li>\n<li>3.本地视频，当然就是学会AVPlayer的用法，还要用到系统的一个控制器。</li>\n<li>4.摄像头，主要学会Session用法，input，outPut设置，通过设置AV预览图设置给UIView，达成预览效果，另外学会水平ScrollView可实现类似分页效果，当然坐标要按照屏幕宽度设置下。</li>\n<li>5.传送带效果，学会设置UICollectionView和UIScrollView的代理，做到良好的用户体验效果，滑动到半屏和不足半屏的考虑。另外学会了xib布局方式，可以绑定控制器。</li>\n<li>6.定位，学会使用系统提供的定位Api，在代理里面处理自己的逻辑。</li>\n<li>7.下拉刷新，是UIScrollView里面的refreshControl提供的功能，自带了loading效果，可以自行添加文案。</li>\n<li>8.炫彩音乐，主要学会音频播放，以及随机函数的用法，还有渐变色调用方式。</li>\n<li>9.图片缩放效果，这个主要是UIScrollView的子View这种方式提供的缩放效果，主要还是针对代理方法做一些调整。</li>\n<li>10.视频背景，这个主要就是学会构造一个基类控制器，可实现播放视频效果，通过配置不同参数丰富这个基类，然后另外就是学会视频剪切。</li>\n</ul>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<blockquote>\n<p>参考项目：<a href=\"https://github.com/soapyigu/Swift-30-Projects\">https://github.com/soapyigu/Swift-30-Projects</a> </p>\n</blockquote>\n<h2 id=\"1-计时器\"><a href=\"#1-计时器\" class=\"headerlink\" title=\"1 计时器\"></a>1 计时器</h2><p>首先看下效果吧。<br><img src=01.gif></p>\n<h3 id=\"1-1-主要功能\"><a href=\"#1-1-主要功能\" class=\"headerlink\" title=\"1.1 主要功能\"></a>1.1 主要功能</h3><p>点击播放按钮，数字开始增加；<br>点击暂停按钮，数字停止增加；<br>点击“Reset”，数值置为0；</p>\n<h3 id=\"1-2-UI\"><a href=\"#1-2-UI\" class=\"headerlink\" title=\"1.2 UI\"></a>1.2 UI</h3><p>这里UI采用storyboard来实现。因为比较简单，就4个控件，拖进去故事版即可。<br><img src=1.2.png></p>\n<h3 id=\"1-3-功能实现\"><a href=\"#1-3-功能实现\" class=\"headerlink\" title=\"1.3 功能实现\"></a>1.3 功能实现</h3><p>ui声明，故事版可以直接拖进相关类中，自动生成：</p>\n<pre><code class=\"line-numbers language-Swift\">@IBOutlet weak var playBtn: UIButton!\n@IBOutlet weak var pauseBtn: UIButton!\n@IBOutlet weak var timeLabel: UILabel!\n</code></pre>\n<p>显示的数字声明：</p>\n<pre><code class=\"line-numbers language-Swift\"> // 浮点数默认是Double类型，若要使用Float，需要显示声明\n    // var counter: Float = 0.0\n    var counter: Float = 0.0 &#123;\n        // 属性观察器 \n        didSet &#123;\n            timeLabel.text = String(format: &quot;%.1f&quot;, counter)\n        &#125;\n    &#125;\n</code></pre>\n<p>这里的属性观察器是监听这个值变更情况，如果某个地方变更了这个值，那么会走里面的didSet回调。</p>\n<pre><code class=\"line-numbers language-Swift\">    // 知识点：存储属性和计算属性\n    override var preferredStatusBarStyle: UIStatusBarStyle &#123;\n        // 只读计算属性，可以去掉get和花括号\n//        get &#123;\n//            return UIStatusBarStyle.lightContent\n//        &#125;\n        return UIStatusBarStyle.lightContent\n    &#125;\n</code></pre>\n<p>上面的代码是控制状态栏图标颜色为亮色（白色），默认是黑色。</p>\n<pre><code class=\"line-numbers language-Swift\">  // 给予timer一个默认值，这样timer就不会为Optional,\n    // 后续可以不用再解包\n    // var timer = Timer()\n    \n    // 这样定义可以在不用timer时回收内存\n    var timer: Timer? = Timer()\n    var isPlaying = false\n</code></pre>\n<p>这里定义了定时器，和定时器Flag。</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        // 符合LosslessStringConvertible协议的，\n        // 都可以直接初始化一个String对象\n        // timeLabel.text = String(counter)\n        \n        // 改成使用属性观察器监控和响应属性值的变化\n        counter = 0.0\n    &#125;\n</code></pre>\n<p>这里在初始化时设置数值为0.0。</p>\n<pre><code class=\"line-numbers language-Swift\">  @IBAction func resetButtonDidTouch(_ sender: UIButton) &#123;\n        if let timerTemp = timer &#123;\n            timerTemp.invalidate()\n        &#125;\n        timer = nil\n        isPlaying = false\n        counter = 0\n        playBtn.isEnabled = true\n        pauseBtn.isEnabled = true\n    &#125;\n</code></pre>\n<p>上面是重置按钮点击事件。</p>\n<p>这个可以在故事版中右键视图，在Touch up inside中拖动到代码里面自动生成方法，具体实现逻辑由我们自行添加。这里是将定时器置为nil，然后将播放和暂停状态都设置为可点击状态。</p>\n<pre><code class=\"line-numbers language-Swift\">@IBAction func playButtonDidTouch(_ sender: UIButton) &#123;\n        playBtn.isEnabled = false\n        pauseBtn.isEnabled = true\n        // 调用实例的方法时建议用self.UpdateTimer,\n        // 不建议使用ViewController.UpdateTimer\n        // 因为若方法定义成了类方法，第二种方式编译器不会报错。\n        timer = Timer.scheduledTimer(timeInterval: 0.1, target:self, selector: #selector(self.UpdateTimer), userInfo: nil, repeats: true)\n        isPlaying = true\n    &#125;\n</code></pre>\n<p>这里是播放按钮的实现逻辑，这里面相当于new了一个Timer。间隔0.1s后刷新，然后会走一个selector里面的updateTimer方法更新数值。</p>\n<pre><code>   @objc func UpdateTimer() &#123;\n        counter = counter + 0.1\n    &#125;\n</code></pre>\n<p>这里变更数字，然后数值变化引起前面定义的didSet刷新，导致Lable数值更新。</p>\n<pre><code class=\"line-numbers language-Swift\"> @IBAction func pauseButtonDidTouch(_ sender: UIButton) &#123;\n        playBtn.isEnabled = true\n        pauseBtn.isEnabled = false\n        if let timerTemp = timer &#123;\n            timerTemp.invalidate()\n        &#125;\n        timer = nil\n        isPlaying = false\n        \n    &#125;\n</code></pre>\n<p>这里是暂停按钮实现逻辑，将按钮置灰，定时器invalidate，然后定时器置空。</p>\n<h2 id=\"2-自定义字体\"><a href=\"#2-自定义字体\" class=\"headerlink\" title=\"2 自定义字体\"></a>2 自定义字体</h2><h3 id=\"2-1-效果\"><a href=\"#2-1-效果\" class=\"headerlink\" title=\"2.1 效果\"></a>2.1 效果</h3><img src=Customfont.gif>\n\n<h3 id=\"2-2-字体文件\"><a href=\"#2-2-字体文件\" class=\"headerlink\" title=\"2.2 字体文件\"></a>2.2 字体文件</h3><p>首先放置在根目录下：<br><img src=02_1.png></p>\n<p>这里XCode会自动识别出字体文件：<br><img src=02_2.png></p>\n<h3 id=\"2-3-实现细节\"><a href=\"#2-3-实现细节\" class=\"headerlink\" title=\"2.3 实现细节\"></a>2.3 实现细节</h3><p>控制器可直接实现UITableViewDelegate, UITableViewDataSource,也可以扩展，最好是扩展，可读性好一点。</p>\n<pre><code class=\"line-numbers language-Swift\">class ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource &#123;\n    \n    static let identifier = &quot;FontCell&quot;\n</code></pre>\n<p>然后定义下数据和字体名称：</p>\n<pre><code class=\"line-numbers language-Swift\">   var data = [&quot;MFTongXin 30 Days Swift&quot;, &quot;MFJinHei 这些字体特别适合打「奋斗」和「理想」&quot;,\n                &quot;MFZhiHei 谢谢「造字工房」，本案例不涉及商业使用&quot;, &quot;Zapfino 使用到造字工房劲黑体，致黑体，童心体&quot;,\n                &quot;Gaspar呵呵，再见🤗 See you next Project&quot;, &quot;微博 @Allen朝辉&quot;,\n                &quot;测试测试测试测试测试测试&quot;, &quot;123&quot;, &quot;Alex&quot;, &quot;@@@@@@&quot;]\n    \n    var fontNames = [&quot;MFTongXin_Noncommercial-Regular&quot;,\n                     &quot;MFJinHei_Noncommercial-Regular&quot;,\n                     &quot;MFZhiHei_Noncommercial-Regular&quot;,\n                     &quot;Zapfino&quot;,\n                     &quot;Gaspar Regular&quot;]\n</code></pre>\n<p>然后定义下UI：</p>\n<pre><code class=\"line-numbers language-Swift\">  @IBOutlet weak var changeFontLabel: UILabel!\n    @IBOutlet weak var fontTableView: UITableView!\n</code></pre>\n<p>然后定义下选择字体索引：</p>\n<pre><code> var fontRowIndex = 0\n</code></pre>\n<p>生命周期初始化：</p>\n<pre><code class=\"line-numbers language-Swift\">   \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        // 在storyboard中直接设置了\n        // fontTableView.dataSource = self\n        // fontTableView.delegate = self\n        \n        // 使用手势加Label替换button\n        changeFontLabel.layer.cornerRadius = 50\n        changeFontLabel.layer.masksToBounds = true\n        // 设置为true才能响应手势\n        changeFontLabel.isUserInteractionEnabled = true\n        let gesture = UITapGestureRecognizer(target: self,\n                                             action: #selector(changeFontDidTouch(_:)))\n        changeFontLabel.addGestureRecognizer(gesture)\n    &#125;\n\n     @objc func changeFontDidTouch(_ sender: AnyObject) &#123;\n        \n        fontRowIndex = (fontRowIndex + 1) % 5\n        print(fontNames[fontRowIndex])\n        fontTableView.reloadData()\n        \n    &#125;\n</code></pre>\n<p>这里主要是给一个按钮添加了手势，手势设置了action，然后相当于给按钮添加点击事件，方法有很多，可以直接故事版添加事件，也可以这种手势添加点击事件。</p>\n<p>下面是TableView的协议实现，这里Cell用了默认的，无需新建Cell。</p>\n<pre><code class=\"line-numbers language-Swift\"> func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n        return 35\n    &#125;\n    \n    func numberOfSections(in tableView: UITableView) -&gt; Int &#123;\n        return 1\n    &#125;\n    \n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n//        let cell = fontTableView.dequeueReusableCell(withIdentifier: ViewController.identifier)\n        let cell = fontTableView.dequeueReusableCell(withIdentifier: ViewController.identifier, for: indexPath)\n        let text = data[indexPath.row]\n       \n        cell.textLabel?.text = text\n        cell.textLabel?.textColor = indexPath.row != fontRowIndex ? UIColor.white : UIColor.blue\n        cell.textLabel?.font = UIFont(name: self.fontNames[fontRowIndex], size:16)\n        \n        return cell\n    \n    &#125;\n\n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n        return data.count\n    &#125;\n</code></pre>\n<p>主要是在cellForRowAt显示了具体item效果，根据前面选择的字体索引，这里设置给cell了。</p>\n<h2 id=\"3-播放本地视频\"><a href=\"#3-播放本地视频\" class=\"headerlink\" title=\"3 播放本地视频\"></a>3 播放本地视频</h2><h3 id=\"3-1-效果\"><a href=\"#3-1-效果\" class=\"headerlink\" title=\"3.1 效果\"></a>3.1 效果</h3><img src=playvideo.gif>\n\n<h3 id=\"3-2-本地视频\"><a href=\"#3-2-本地视频\" class=\"headerlink\" title=\"3.2 本地视频\"></a>3.2 本地视频</h3><p>直接将mp4文件放置在根目录下。<br>Xcode可自动识别到Movie文件夹下。</p>\n<h3 id=\"3-3-Core-Data\"><a href=\"#3-3-Core-Data\" class=\"headerlink\" title=\"3.3 Core Data\"></a>3.3 Core Data</h3><p>这里播放本地视频并不依赖这个。<br>因为demo中有部分代码是这个，当然也是可以学习下的。<br>关于Core Data实际上是一个数据存储框架，类似Realm。<br>Ficow写的这篇文章还不错：<br> <a href=\"https://blog.ficowshen.com/page/post/52\">了解和采用 CoreData 框架 —— Ficow 陪你学 CoreData</a></p>\n<h3 id=\"3-4-UI定义\"><a href=\"#3-4-UI定义\" class=\"headerlink\" title=\"3.4 UI定义\"></a>3.4 UI定义</h3><pre><code class=\"line-numbers language-Swift\"> // Swift中mark的使用方式，效果等同OC重的 #pragma mark -\n   //MARK:- Variables\n   @IBOutlet weak var videoTableView: UITableView!\n</code></pre>\n<p> 这里就一个UITableView，展示一个列表。</p>\n<pre><code class=\"line-numbers language-Swift\">  var playViewController = AVPlayerViewController()\n  var playerView = AVPlayer()\n</code></pre>\n<p>然后这里定义并且初始化了视频播放关键类。<br>AVPlayerViewController是一个系统的控制器，用来播放视频的，这里播放本地视频其实也是跳转到系统默认的播放器来播放。</p>\n<pre><code class=\"line-numbers language-Swift\">var data = [\n        // 给项目编译后属于同一个module，所以Video不需要import就可以使用\n        Video(image: &quot;videoScreenshot01&quot;,\n              title: &quot;Introduce 3DS Mario&quot;,\n              source: &quot;Youtube - 06:32&quot;),\n        Video(image: &quot;videoScreenshot02&quot;,\n              title: &quot;Emoji Among Us&quot;,\n              source: &quot;Vimeo - 3:34&quot;),\n        Video(image: &quot;videoScreenshot03&quot;,\n              title: &quot;Seals Documentary&quot;,\n              source: &quot;Vine - 00:06&quot;),\n        Video(image: &quot;videoScreenshot04&quot;,\n              title: &quot;Adventure Time&quot;,\n              source: &quot;Youtube - 02:39&quot;),\n        Video(image: &quot;videoScreenshot05&quot;,\n              title: &quot;Facebook HQ&quot;,\n              source: &quot;Facebook - 10:20&quot;),\n        Video(image: &quot;videoScreenshot06&quot;,\n              title: &quot;Lijiang Lugu Lake&quot;,\n              source: &quot;Allen - 20:30&quot;)\n    ]\n</code></pre>\n<p>上面是列表页数据定义。</p>\n<pre><code class=\"line-numbers language-Swift\"> //MARK:- View Life Cycle\n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        \n        videoTableView.dataSource = self\n        videoTableView.delegate = self\n        \n    &#125;\n</code></pre>\n<p>初始化里面设置了数据源和代理。</p>\n<pre><code class=\"line-numbers language-Swift\">\n//MARK:- UIViewTableView DataSource &amp; Delegate\n// 知识点：扩展\n// 扩展和 Objective-C 中的分类类似，但没有名称\n// 扩展可以为一个类型添加新的功能，但是不能重写已有的功能。\n// 扩展可以添加新的计算型属性，但是不可以添加存储型属性，也不可以为已有属性添加属性观察器。\nextension ViewController: UITableViewDataSource, UITableViewDelegate &#123;\n    // Extensions must not contain stored properties\n    //var a = 1\n    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n    return 220\n    &#125;\n\n    func numberOfSections(in tableView: UITableView) -&gt; Int &#123;\n    return 2\n    &#125;\n\n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n    return data.count\n    &#125;\n\n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n\n    // 知识点：向下转型\n    // as! 强制类型转换，无法转换时会抛出运行时异常\n    // as？可选类型转换，无法转换时返回nil\n    let cell = videoTableView.dequeueReusableCell(withIdentifier: &quot;VideoCell&quot;, for: indexPath) as! VideoCell\n    let video = data[indexPath.row]\n\n    cell.videoScreenshot.image = UIImage(named: video.image)\n    cell.videoTitleLabel.text = video.title\n    cell.videoSourceLabel.text = video.source\n\n    return cell\n\n    &#125;\n&#125;\n</code></pre>\n<p>这里扩展实现了UITableView的代理和数据源。</p>\n<p>这里用到了一个Cell需要自定义。</p>\n<pre><code class=\"line-numbers language-Swift\">\n// 定义Video的结构体，属性初始化后不能被改变，因为结构体时值类型。\n// 在你每次定义一个新类或者结构体的时候，实际上你是定义了一个新的 Swift 类型。\n// 因此请使用UpperCamelCase这种方式来命名\nstruct Video &#123;\n    let image: String\n    let title: String\n    let source: String\n&#125;\n\nclass VideoCell: UITableViewCell &#123;\n\n    @IBOutlet weak var videoScreenshot: UIImageView!\n    @IBOutlet weak var videoTitleLabel: UILabel!\n    @IBOutlet weak var videoSourceLabel: UILabel!\n    \n    override func awakeFromNib() &#123;\n        super.awakeFromNib()\n        // Initialization code\n    &#125;\n\n    override func setSelected(_ selected: Bool, animated: Bool) &#123;\n        super.setSelected(selected, animated: animated)\n\n        // Configure the view for the selected state\n    &#125;\n\n&#125;\n</code></pre>\n<p>这个VideoCell是怎么添加视图的呢，当然也是故事版的作用了。<br>全局搜索了下VideoCell，发现Main.storyboard里面用到了这个VideoCell，这里关联到了故事版。<br><img src=03_1.png><br>这里注意到右上角是一个Custom Class，说明故事版是可以关联自定义类的，这里就把Cell关联进来了。</p>\n<p>然后还是在Main.storyboard中，给cell里面的botton添加了一个点击事件给控制器：</p>\n<pre><code class=\"line-numbers language-Swift\">@IBAction func playVideoButtonDidTouch(_ sender: AnyObject) &#123;\n        let path = Bundle.main.path(forResource: &quot;emoji zone&quot;, ofType: &quot;mp4&quot;)\n        \n        playerView = AVPlayer(url: URL(fileURLWithPath: path!))\n        \n        playViewController.player = playerView\n        \n        // 知识点：尾随闭包\n        // 在使用尾随闭包时，你不用写出它的参数标签\n        // 如果闭包表达式是函数或方法的唯一参数，则当你使用尾随闭包时，你甚至可以把 () 省略掉\n        // 完整形式如下：\n        //self.present(playViewController, animated: true, completion: &#123;\n        //    self.playViewController.player?.play()\n        //&#125;)\n        self.present(playViewController, animated: true) &#123;\n            self.playViewController.player?.play()\n        &#125;\n    &#125;\n &#125;\n</code></pre>\n<p>这里给系统的控制器设置了一个AVPlayer，AVPlayer里面设置了URL，这样实现了播放视频效果。</p>\n<h2 id=\"4-摄像头\"><a href=\"#4-摄像头\" class=\"headerlink\" title=\"4 摄像头\"></a>4 摄像头</h2><h3 id=\"4-1-效果预览\"><a href=\"#4-1-效果预览\" class=\"headerlink\" title=\"4.1 效果预览\"></a>4.1 效果预览</h3><img src=snapchatmenu.gif>\n\n<h3 id=\"4-2-UI\"><a href=\"#4-2-UI\" class=\"headerlink\" title=\"4.2 UI\"></a>4.2 UI</h3><p>这里主要是一个横滑的UIScrollView。<br>长度设置了屏幕的3倍，第一块放置一个UIImageView，中间放置摄像头，最后一块也放置了一个UIImageView。</p>\n<p>这里左侧的视图，采用了xib的方式来创建。<br>我个人理解，xib的方式有点类似Android的xml，因为我本身是学Android，希望大家原谅我这样比喻。xib也是很直观,可以看到效果，而且也可以挂载到某个具体的UIView上。</p>\n<p>左侧的xib是这样的：<br><img src=04_1.png></p>\n<p>右侧的xib是这样的：<br><img src=04_2.png></p>\n<p>中间的就是一个控制器来的,当然这个控制器也是可以关联xib的。<br>如何关联的？<br>这里有一个CameraView.xib，它的File’s Owner是CameraView，这样就关联起来了。所以再CameraView.swift里面操作的都是针对这个xib的逻辑处理。</p>\n<p>重点看下如何显示摄像头的吧：<br>首先是UI关联：</p>\n<pre><code>@IBOutlet weak var cameraView: UIView!\n</code></pre>\n<p>这个应该是拖进来的。</p>\n<p>然后就是几个关键的类：</p>\n<pre><code class=\"line-numbers language-Swift\"> var captureSession : AVCaptureSession?\n var stillImageOutput : AVCaptureStillImageOutput?\n var previewLayer : AVCaptureVideoPreviewLayer?\n</code></pre>\n<p>然后是将要显示的时候逻辑处理：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewWillAppear(_ animated: Bool) &#123;\n        super.viewWillAppear(animated)\n        \n        captureSession = AVCaptureSession()\n        // 已经不能再使用了\n        // captureSession?.sessionPreset = AVCaptureSessionPreset1920x1080\n        captureSession?.sessionPreset = AVCaptureSession.Preset.hd1920x1080\n        let backCamera = AVCaptureDevice.devices(for: .video).first!\n        // 已经不能再使用了\n        // let backCamera = AVCaptureDevice.defaultDevice(withMediaType: AVMediaTypeVideo)\n        var error : NSError?\n        var input: AVCaptureDeviceInput!\n        \n        do &#123;\n            input = try AVCaptureDeviceInput(device: backCamera) &#125;\n        catch let error1 as NSError &#123;\n            error = error1\n            input = nil\n        &#125;\n        \n        if (error == nil &amp;&amp; captureSession?.canAddInput(input) != nil) &#123;\n            \n                captureSession?.addInput(input)\n                \n                stillImageOutput = AVCaptureStillImageOutput()\n                stillImageOutput?.outputSettings = [AVVideoCodecKey : AVVideoCodecJPEG]\n                \n            if let stillImageOutputTemp = stillImageOutput &#123;\n                if captureSession?.canAddOutput(stillImageOutputTemp) != nil &#123;\n                    captureSession?.addOutput(stillImageOutputTemp)\n                    if let captureSessionTemp = captureSession &#123;\n                        previewLayer = AVCaptureVideoPreviewLayer(session: captureSessionTemp)\n                        previewLayer?.videoGravity = AVLayerVideoGravity.resizeAspect\n                        // 已经废弃不用了\n                        // previewLayer?.videoGravity = AVLayerVideoGravityResizeAspect\n                        previewLayer?.connection?.videoOrientation = AVCaptureVideoOrientation.portrait\n                        cameraView.layer.addSublayer(previewLayer!)\n                        captureSession?.startRunning()\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        \n    &#125;\n</code></pre>\n<p>主要是初始化了一个AVCaptureSession，然后又创建了一个AVCaptureDeviceInput来接收输入流，这样利用session.addInput，将输入流给input，然后搞一个输出流AVCaptureStillImageOutput，来接收captureSession.addOutPut，这样最后我们再创建一个 预览类叫做AVCaptureVideoPreviewLayer，里面放session，这样就得到一个Layer了。</p>\n<p>这个Layer我们就可以加到普通的UIView上了。</p>\n<h3 id=\"4-3-根控制器\"><a href=\"#4-3-根控制器\" class=\"headerlink\" title=\"4.3 根控制器\"></a>4.3 根控制器</h3><p>先定义一个UIScollView:</p>\n<pre><code class=\"line-numbers language-Swift\">\nclass ViewController: UIViewController &#123;\n    \n\n    @IBOutlet weak var scrollView: UIScrollView!\n</code></pre>\n<p>初始化添加子View，3块布局给它add进去：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n    super.viewDidLoad()\n    \n    // 已经废弃了，使用prefersStatusBarHidden属性返回设置的值\n    // UIApplication.shared.isStatusBarHidden = true\n    \n    let screenWidth = UIScreen.main.bounds.width\n    let screenHeight = UIScreen.main.bounds.height\n    let leftView: UIViewController = UINib(nibName: &quot;LeftView&quot;, bundle: nil).instantiate(withOwner: nil, options: nil)[0] as! UIViewController\n    let centerView: CameraView = CameraView(nibName: &quot;CameraView&quot;, bundle: nil)\n    let rightView: RightView = RightView(nibName: &quot;RightView&quot;, bundle: nil)\n    \n    leftView.view.frame = CGRect(x: 0, y: 0, width: screenWidth-200, height: screenHeight)\n    centerView.view.frame = CGRect(x: screenWidth, y: 0, width: screenWidth, height: screenHeight)\n    rightView.view.frame = CGRect(x: 2*screenWidth, y: 0, width: screenWidth, height: screenHeight)\n\n    self.scrollView.addSubview(leftView.view)\n    self.scrollView.addSubview(rightView.view)\n    self.scrollView.addSubview(centerView.view)\n    self.scrollView.contentSize = CGSize(width: screenWidth * 3, height: screenHeight)\n&#125;\n</code></pre>\n<p>frame要对应好屏幕坐标。<br>scrollView的contentSize刚好对应3个屏幕大小。</p>\n<p>这里可以直接创建一个UINib作为控制器，传xib的名称给它就可以的。</p>\n<p>另外这里用到了相机，需要相机的权限声明哦：<br>在info.plist文件下配置：<br>Privacy - Camera Usage Description </p>\n<p>然后Value自己随便填下就好了。</p>\n<h2 id=\"5-传送带效果\"><a href=\"#5-传送带效果\" class=\"headerlink\" title=\"5 传送带效果\"></a>5 传送带效果</h2><h3 id=\"5-1-效果\"><a href=\"#5-1-效果\" class=\"headerlink\" title=\"5.1 效果\"></a>5.1 效果</h3><img src=Carousel.gif>\n\n<h3 id=\"5-2-故事版关联\"><a href=\"#5-2-故事版关联\" class=\"headerlink\" title=\"5.2 故事版关联\"></a>5.2 故事版关联</h3><img src=5_1.png>\n首先Main.storyboard是在info.plist中注册的。\n然后这个首页故事版配置的控制器的Class就是代码区域表示的控制器了。\n层层关联环环相扣。\n\n<h3 id=\"5-3-UI\"><a href=\"#5-3-UI\" class=\"headerlink\" title=\"5.3 UI\"></a>5.3 UI</h3><p>这里其实就一个背景图片+一个UICollectionView。</p>\n<pre><code class=\"line-numbers language-Swift\">class HomeViewController: UIViewController &#123;\n\n    \n    @IBOutlet weak var backgroundImageView: UIImageView!\n    @IBOutlet weak var collectionView: UICollectionView!\n</code></pre>\n<h3 id=\"5-4-Data\"><a href=\"#5-4-Data\" class=\"headerlink\" title=\"5.4 Data\"></a>5.4 Data</h3><pre><code class=\"line-numbers language-Swift\">// 访问权限分物种：private，fileprivate，internal，public 和 open\n    // private：只能在本类的作用域且在当前文件内能访问\n    // fileprivate：只能在当前文件内能访问\n    // internal：本module内能访问\n    // public：跨module访问但不能重写或继承\n    // open：跨module访问并且能重写或继承\n    fileprivate var interests = Interest.createInterests()\n</code></pre>\n<pre><code class=\"line-numbers language-Swift\">class Interest\n&#123;\n    // MARK: - Public API\n    var title = &quot;&quot;\n    var description = &quot;&quot;\n    var numberOfMembers = 0\n    var numberOfPosts = 0\n    var featuredImage: UIImage!\n    \n    init(title: String, description: String, featuredImage: UIImage!)\n    &#123;\n        self.title = title\n        self.description = description\n        self.featuredImage = featuredImage\n        numberOfMembers = 1\n        numberOfPosts = 1\n    &#125;\n    \n    // MARK: - Private\n    // dummy data\n    static func createInterests() -&gt; [Interest]\n    &#123;\n        return [\n            Interest(title: &quot;Hello there, i miss u.&quot;, description: &quot;We love backpack and adventures! We walked to Antartica yesterday, and camped with some cute pinguines, and talked about this wonderful app idea. 🐧⛺️✨&quot;, featuredImage: UIImage(named: &quot;hello&quot;)!),\n            Interest(title: &quot;🐳🐳🐳🐳🐳&quot;, description: &quot;We love romantic stories. We walked to Antartica yesterday, and camped with some cute pinguines, and talked about this wonderful app idea. 🐧⛺️✨&quot;, featuredImage: UIImage(named: &quot;dudu&quot;)!),\n            Interest(title: &quot;Training like this, #bodyline&quot;, description: &quot;Create beautiful apps. We walked to Antartica yesterday, and camped with some cute pinguines, and talked about this wonderful app idea. 🐧⛺️✨&quot;, featuredImage: UIImage(named: &quot;bodyline&quot;)!),\n            Interest(title: &quot;I&#39;m hungry, indeed.&quot;, description: &quot;Cars and aircrafts and boats and sky. We walked to Antartica yesterday, and camped with some cute pinguines, and talked about this wonderful app idea. 🐧⛺️✨&quot;, featuredImage: UIImage(named: &quot;wave&quot;)!),\n            Interest(title: &quot;Dark Varder, #emoji&quot;, description: &quot;Meet life with full presence. We walked to Antartica yesterday, and camped with some cute pinguines, and talked about this wonderful app idea. 🐧⛺️✨&quot;, featuredImage: UIImage(named: &quot;darkvarder&quot;)!),\n            Interest(title: &quot;I have no idea, bitch&quot;, description: &quot;Get up to date with breaking-news. We walked to Antartica yesterday, and camped with some cute pinguines, and talked about this wonderful app idea. 🐧⛺️✨&quot;, featuredImage: UIImage(named: &quot;hhhhh&quot;)!),\n        ]\n    &#125;\n&#125;\n</code></pre>\n<p>这里创建了一个静态函数，就是数据定义了。</p>\n<h3 id=\"5-5-绑定数据\"><a href=\"#5-5-绑定数据\" class=\"headerlink\" title=\"5.5 绑定数据\"></a>5.5 绑定数据</h3><pre><code class=\"line-numbers language-Swift\">extension HomeViewController : UICollectionViewDataSource &#123;\n    \n    func numberOfSections(in collectionView: UICollectionView) -&gt; Int &#123;\n        return 1\n    &#125;\n    \n    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123;\n        return interests.count\n    &#125;\n    \n    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123;\n        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: Storyboard.CellIdentifier, for: indexPath) as! InterestCollectionViewCell\n        \n        cell.interest = self.interests[indexPath.item]\n        \n        return cell\n        \n    &#125;\n&#125;\n</code></pre>\n<p>这里就是UICollectionView的数据源了。<br>对应的Cell为InterestCollectionViewCell</p>\n<blockquote>\n<p>这里注意到这个UICollectionView好像没有设置dataSource和delegate，这里看了下Main.storyboard里面，果然在右侧看到Outlets设置了dataSource和delegate都给了控制器。所以说在故事版里面是可以设置数据源和代理的。</p>\n</blockquote>\n<p>如下：</p>\n<pre><code class=\"line-numbers language-Swift\">class InterestCollectionViewCell: UICollectionViewCell &#123;\n    \n    \n    var interest: Interest! &#123;\n        didSet &#123;\n            updateUI()\n        &#125;\n    &#125;\n    \n    @IBOutlet weak var featuredImageView: UIImageView!\n    @IBOutlet weak var interestTitleLabel: UILabel!\n    \n    fileprivate func updateUI() &#123;\n        interestTitleLabel?.text! = interest.title\n        featuredImageView?.image! = interest.featuredImage\n    &#125;\n    \n    override func layoutSubviews() &#123;\n        super.layoutSubviews()\n        \n        self.layer.cornerRadius = 5.0\n        self.clipsToBounds = true\n    &#125;\n&#125;\n</code></pre>\n<p>因为在Main.storyboard的已经关联了这个Cell，所以布局相关的都无需重新addView。</p>\n<p>上面这些代码就可以实现一个传送带效果。</p>\n<p>但是我们想要左滑，它自己能够刚好滑动到下一个屏幕，体验效果好一点的话要怎么办呢？</p>\n<p>我们想到第一个优化点：<br>一张图能不能刚好占一个屏幕，增大一点padding。</p>\n<p>可以的。</p>\n<p>利用UICollectionView提供的另外一个协议可以实现。答案就是：UICollectionViewDelegateFlowLayout。</p>\n<pre><code class=\"line-numbers language-Swift\">extension HomeViewController : UICollectionViewDelegateFlowLayout &#123;\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -&gt; CGSize &#123;\n        return CGSize(width: UIScreen.main.bounds.width - 2 * Storyboard.CellPadding, height: 450)\n    &#125;\n\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -&gt; CGFloat &#123;\n        return 2 * Storyboard.CellPadding\n    &#125;\n\n    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -&gt; UIEdgeInsets &#123;\n        return UIEdgeInsetsMake(0, Storyboard.CellPadding, 0, Storyboard.CellPadding)\n    &#125;\n&#125;\n</code></pre>\n<p>这里第一个sizeForItemAt方法：单个item的大小，长度为屏幕宽度-左右两个padding，高度写死450。<br>这里第二个方法minimumLine: collectionView的滚动方向为水平时，这个就是item之间的最小水平间距。<br>这里的第三个方法insetForSectionAt: 单个item的padding，设置上，左，右，下。</p>\n<p>第二个优化点：当滑动到一半多，自动切下一张，不足一半，切回上一张。<br>也好办。</p>\n<pre><code class=\"line-numbers language-Swift\">extension HomeViewController : UIScrollViewDelegate &#123;\n    func scrollViewWillEndDragging(_ scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer&lt;CGPoint&gt;) &#123;\n        let originPoint = targetContentOffset.pointee;\n        var index = Int(originPoint.x / UIScreen.main.bounds.width)\n        let offset = Int(originPoint.x) % Int(UIScreen.main.bounds.width)\n        index += (offset &gt; Int(UIScreen.main.bounds.width/2) ? 1 : 0)\n        targetContentOffset.pointee = CGPoint(x: index * Int(UIScreen.main.bounds.width) , y: 0)\n    &#125;\n&#125;\n</code></pre>\n<p>继续扩展下这个控制器，这里面，判断了offset在停止滑动后的逻辑。</p>\n<h2 id=\"6-定位\"><a href=\"#6-定位\" class=\"headerlink\" title=\"6 定位\"></a>6 定位</h2><h3 id=\"6-1-效果\"><a href=\"#6-1-效果\" class=\"headerlink\" title=\"6.1 效果\"></a>6.1 效果</h3><img src=mylocation.gif>\n\n<h3 id=\"6-2-UI\"><a href=\"#6-2-UI\" class=\"headerlink\" title=\"6.2 UI\"></a>6.2 UI</h3><p>这个UI比较简单，一个UILabel，一个按钮。</p>\n<p>这个按钮的点击事件直接通过故事版链接到了控制器，所以控制器无需有这个UIView，有这个点击事件就行了。<br><img src=06_1.png></p>\n<h3 id=\"6-3-如何定位\"><a href=\"#6-3-如何定位\" class=\"headerlink\" title=\"6.3 如何定位\"></a>6.3 如何定位</h3><p>首先声明一个全局变量：</p>\n<pre><code class=\"line-numbers language-Swift\">  // 强制自动解包，可以赋值为nil，为nil后再调用会报错\n    // 建议定义为：\n    // var locationManager: CLLocationManager\n    var locationManager: CLLocationManager!\n</code></pre>\n<p>开始定位：</p>\n<pre><code class=\"line-numbers language-Swift\">@IBAction func myLocationButtonDidTouch(_ sender: AnyObject) &#123; \n    locationManager = CLLocationManager()\n    locationManager.delegate = self\n    locationManager.desiredAccuracy = kCLLocationAccuracyBest\n    locationManager.requestAlwaysAuthorization()\n    locationManager.startUpdatingLocation()   \n&#125;\n</code></pre>\n<p>因为这里引入了CLLocationManager，那么在项目层级发现CoreLocation.framework自动引入进来了。</p>\n<p>直接这样还不够，还需要设置下协议才行。因为这里我们delegate设置了self。<br>这里我们同样可以新建一个Delegate，本质上扩展控制器，当然也可以直接写在控制器里面，都可以，最好是分一个文件，可读性会强一点。</p>\n<pre><code class=\"line-numbers language-Swift\">import Foundation\nimport CoreLocation\n\nextension ViewController : CLLocationManagerDelegate &#123;\n    \n    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) &#123;\n        \n        self.locationLabel.text = &quot;Error while updating location &quot; + error.localizedDescription\n        \n    &#125;\n    \n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) &#123;\n        CLGeocoder().reverseGeocodeLocation(locations.first!) &#123; (placemarks, error) in\n            guard error == nil else &#123;\n                self.locationLabel.text = &quot;Reverse geocoder failed with error&quot; + error!.localizedDescription\n                return\n            &#125;\n            if placemarks!.count &gt; 0 &#123;\n                let pm = placemarks!.first\n                self.displayLocationInfo(pm)\n            &#125; else &#123;\n                self.locationLabel.text = &quot;Problem with the data received from geocoder&quot;\n            &#125;\n        &#125;\n    &#125;\n    \n    func displayLocationInfo(_ placemark: CLPlacemark?) &#123;\n        if let containsPlacemark = placemark &#123;\n            //stop updating location to save battery life\n            locationManager.stopUpdatingLocation()\n            \n            let locality = (containsPlacemark.locality != nil) ? containsPlacemark.locality : &quot;&quot;\n            let postalCode = (containsPlacemark.postalCode != nil) ? containsPlacemark.postalCode : &quot;&quot;\n            let administrativeArea = (containsPlacemark.administrativeArea != nil) ? containsPlacemark.administrativeArea : &quot;&quot;\n            let country = (containsPlacemark.country != nil) ? containsPlacemark.country : &quot;&quot;\n            \n            self.locationLabel.text = postalCode! + &quot; &quot; + locality!\n            \n            self.locationLabel.text?.append(&quot;\\n&quot; + administrativeArea! + &quot;, &quot; + country!)\n        &#125;\n        \n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"7-下拉刷新\"><a href=\"#7-下拉刷新\" class=\"headerlink\" title=\"7 下拉刷新\"></a>7 下拉刷新</h2><h3 id=\"7-1-效果\"><a href=\"#7-1-效果\" class=\"headerlink\" title=\"7.1 效果\"></a>7.1 效果</h3><img src=07.gif>\n\n<h3 id=\"7-2-变量声明\"><a href=\"#7-2-变量声明\" class=\"headerlink\" title=\"7.2 变量声明\"></a>7.2 变量声明</h3><pre><code class=\"line-numbers language-Swift\">class ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate &#123;\n    \n    var index = 0\n    let cellIdentifer = &quot;NewCellIdentifier&quot;\n    \n    let favoriteEmoji = [&quot;🤗🤗🤗🤗🤗&quot;, &quot;😅😅😅😅😅&quot;, &quot;😆😆😆😆😆&quot;]\n    let newFavoriteEmoji = [&quot;🏃🏃🏃🏃🏃&quot;, &quot;💩💩💩💩💩&quot;, &quot;👸👸👸👸👸&quot;, &quot;🤗🤗🤗🤗🤗&quot;, &quot;😅😅😅😅😅&quot;, &quot;😆😆😆😆😆&quot; ]\n    var emojiData = [String]()\n    var tableView: UITableView!\n    \n    var refreshControl = UIRefreshControl()\n    var navBar: UINavigationBar = UINavigationBar(frame: CGRect(x: 0, y: 0, width: 375, height: 64))\n</code></pre>\n<p>这里继承了UIViewController，然后再Main.storyboard中配置了首页的控制器就是这个，这样就直接启动这个控制器了。</p>\n<p>这里定义了初始化数据3条，更新后的6条。<br>模拟刷新后的数据变化。</p>\n<p>这里不是再故事版里面加视图，直接在代码里面new了。</p>\n<h3 id=\"7-3-viewDidLoad初始化\"><a href=\"#7-3-viewDidLoad初始化\" class=\"headerlink\" title=\"7.3 viewDidLoad初始化\"></a>7.3 viewDidLoad初始化</h3><pre><code class=\"line-numbers language-Swift\"> override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        // 这里new一个UITableView\n        tableView = UITableView(frame: self.view.bounds, style: .plain)\n        \n        // 初始数据\n        emojiData = favoriteEmoji\n        let emojiTableView = tableView\n        \n        // 数据源设置，注册Cell，这里的Cell比较简单，直接用了UITableViewCell可满足\n        emojiTableView?.backgroundColor = UIColor(red:0.092, green:0.096, blue:0.116, alpha:1)\n        emojiTableView?.dataSource = self\n        emojiTableView?.register(UITableViewCell.self, forCellReuseIdentifier: cellIdentifer)\n        \n        // 因为TableView是UIScrollViw，这里也有这个refreshControl的属性\n        tableView.refreshControl = self.refreshControl\n        self.refreshControl.addTarget(self, action: #selector(ViewController.didRoadEmoji), for: .valueChanged)\n        \n        // 自定义刷新器 这里的loading效果猜测是refreshControl自带的\n        self.refreshControl.backgroundColor = UIColor(red:0.113, green:0.113, blue:0.145, alpha:1)\n        let attributes = [NSAttributedStringKey.foregroundColor: UIColor.white]\n        // 这里是loading下方的文案\n        self.refreshControl.attributedTitle = NSAttributedString(string: &quot;Last updated on \\(Date())&quot;, attributes: attributes)\n        self.refreshControl.tintColor = UIColor.white\n        \n        self.title = &quot;emoji&quot;\n        self.navBar.barStyle = UIBarStyle.blackTranslucent\n        \n        emojiTableView?.rowHeight = UITableViewAutomaticDimension\n        emojiTableView?.estimatedRowHeight = 60.0\n        emojiTableView?.tableFooterView = UIView(frame: CGRect.zero)\n        emojiTableView?.separatorStyle = UITableViewCellSeparatorStyle.none\n        \n        // 代码add子View\n        self.view.addSubview(emojiTableView!)\n        self.view.addSubview(navBar)\n    &#125;\n</code></pre>\n<p>这里通过在代码里面new一个UITableView方式，也是可以实现UI效果。</p>\n<h3 id=\"7-4-设置代理和数据源\"><a href=\"#7-4-设置代理和数据源\" class=\"headerlink\" title=\"7.4 设置代理和数据源\"></a>7.4 设置代理和数据源</h3><pre><code class=\"line-numbers language-Swift\">func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n        return emojiData.count\n    &#125;\n    \nfunc numberOfSections(in tableView: UITableView) -&gt; Int &#123;\n    return 1\n&#125;\n\n\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n    let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifer)! as UITableViewCell\n    cell.textLabel!.text = self.emojiData[indexPath.row]\n    cell.textLabel!.textAlignment = NSTextAlignment.center\n    cell.textLabel!.font = UIFont.systemFont(ofSize: 50)\n    cell.backgroundColor = UIColor.clear\n    cell.selectionStyle = UITableViewCellSelectionStyle.none\n\n    return cell\n&#125;\n</code></pre>\n<p>这里给Cell设置数据了。</p>\n<h3 id=\"7-5-下拉监听\"><a href=\"#7-5-下拉监听\" class=\"headerlink\" title=\"7.5 下拉监听\"></a>7.5 下拉监听</h3><pre><code class=\"line-numbers language-Swift\">@objc func didRoadEmoji() &#123;\n    DispatchQueue.main.asyncAfter(deadline:DispatchTime.now() + 3 ) &#123;\n        self.emojiData = [self.newFavoriteEmoji,self.favoriteEmoji][self.index]\n        self.tableView.reloadData()\n        self.refreshControl.endRefreshing()\n        self.index = (self.index + 1) % 2\n    &#125;\n&#125;\n</code></pre>\n<p>DispatchQueue.main.asyncAfter： 主线程执行延迟任务方法。<br>这里延迟3s后，去更新数据。然后控制器取消刷新。</p>\n<h2 id=\"8-炫彩音乐\"><a href=\"#8-炫彩音乐\" class=\"headerlink\" title=\"8 炫彩音乐\"></a>8 炫彩音乐</h2><h3 id=\"8-1-效果\"><a href=\"#8-1-效果\" class=\"headerlink\" title=\"8.1 效果\"></a>8.1 效果</h3><img src=randomMusicColor.gif>\n\n<h3 id=\"8-2-全局变量定义\"><a href=\"#8-2-全局变量定义\" class=\"headerlink\" title=\"8.2 全局变量定义\"></a>8.2 全局变量定义</h3><pre><code class=\"line-numbers language-Swift\">var audioPlayer = AVAudioPlayer()\n    \nlet gradientLayer = CAGradientLayer()\n\nvar timer : Timer?\n\nvar backgroundColor: (red: CGFloat, green: CGFloat,blue: CGFloat,alpha: CGFloat)! &#123;\n    didSet &#123;\n        let color1 = UIColor(red: backgroundColor.blue,\n                                green: backgroundColor.green,\n                                blue: 0,\n                                alpha: backgroundColor.alpha).cgColor\n        let color2 = UIColor(red: backgroundColor.red,\n                                green: backgroundColor.green,\n                                blue: backgroundColor.blue,\n                                alpha: backgroundColor.alpha).cgColor\n        gradientLayer.colors = [color1, color2]\n    &#125;\n&#125;\n</code></pre>\n<p>这里第一个是AVAudioPlayer，负责音频播放。<br>这里第二个类是CAGradientLayer，负责渐变色渲染。<br>timer是定时器。<br>backgroundColor背景色，如果任何地方更改后，触发渐变色颜色变化。</p>\n<h3 id=\"8-3-播放音乐\"><a href=\"#8-3-播放音乐\" class=\"headerlink\" title=\"8.3 播放音乐\"></a>8.3 播放音乐</h3><pre><code class=\"line-numbers language-Swift\">@IBAction func playMusicButtonDidTouch(_ sender: AnyObject) &#123;\n        \n    //play bg music\n    let bgMusic = URL(fileURLWithPath: Bundle.main.path(forResource: &quot;Ecstasy&quot;, ofType: &quot;mp3&quot;)!)\n    \n    do &#123;\n        try AVAudioSession.sharedInstance().setCategory(AVAudioSessionCategoryPlayback)\n        try AVAudioSession.sharedInstance().setActive(true)\n        try audioPlayer = AVAudioPlayer(contentsOf: bgMusic)\n        \n        audioPlayer.prepareToPlay()\n        audioPlayer.play()\n        \n    &#125;\n    catch let audioError as NSError &#123;\n        print(audioError)\n    &#125;\n    \n    if (timer == nil) &#123;\n        timer = Timer.scheduledTimer(timeInterval: 0.2, target: self, selector: #selector(ViewController.randomColor), userInfo: nil, repeats: true)\n    &#125;\n    \n    let redValue = CGFloat(drand48())\n    let blueValue =  CGFloat(drand48())\n    let greenValue = CGFloat(drand48())\n    \n    self.view.backgroundColor = UIColor(red: redValue, green: greenValue, blue: blueValue, alpha: 1.0)\n    \n    //graditent color\n    gradientLayer.frame = view.bounds\n    gradientLayer.startPoint = CGPoint(x: 0, y: 0)\n    gradientLayer.endPoint = CGPoint(x: 1, y: 1)\n    \n    self.view.layer.addSublayer(gradientLayer)\n    \n&#125;\n</code></pre>\n<p>这里先利用AVAudioSession的单例类设置Active，然后利用AVAudioPlayer播放本地音乐。</p>\n<p>然后后面搞了0.2s刷新的周期定时器。每次会执行这个函数：</p>\n<pre><code class=\"line-numbers language-Swift\">@objc func randomColor() &#123;\n    \n    let redValue = CGFloat(drand48())\n    let blueValue =  CGFloat(drand48())\n    let greenValue = CGFloat(drand48())\n    \n    \n    backgroundColor = (redValue, blueValue, greenValue, 1)\n    \n&#125;\n</code></pre>\n<p>这里红蓝绿会随机获取一个值，生成一个颜色值。同时会更新渐变层变更，这样背景就随机变化了。</p>\n<h2 id=\"9-图片缩放效果\"><a href=\"#9-图片缩放效果\" class=\"headerlink\" title=\"9 图片缩放效果\"></a>9 图片缩放效果</h2><h3 id=\"9-1-效果\"><a href=\"#9-1-效果\" class=\"headerlink\" title=\"9.1 效果\"></a>9.1 效果</h3><img src=09.gif>\n\n<h3 id=\"9-2-布局构造\"><a href=\"#9-2-布局构造\" class=\"headerlink\" title=\"9.2 布局构造\"></a>9.2 布局构造</h3><p>这里看了下Main.storyboard<br>貌似是在ScrollView里面放了一个ImageView哦。</p>\n<p>这里有个细节，就是背景有点毛玻璃效果。<br>其实是这样的，它在Main.storyboard底部设置了一张UIImageView，其实就是这张图片。<br>然后再搞了一个UIVisualEffectView覆盖再上面，就形成了一种毛玻璃效果。</p>\n<p>回到控制器里面，这里无非就是两个视图，并且把这个Constraint约束也加进来了，有4个约束，顶部约束，头部约束，底部约束和尾部约束。</p>\n<pre><code class=\"line-numbers language-Swift\">@IBOutlet weak var scrollView: UIScrollView!\n@IBOutlet weak var imageView: UIImageView!\n@IBOutlet weak var imageViewTopConstraint: NSLayoutConstraint!\n@IBOutlet weak var imageViewTrailingConstraint: NSLayoutConstraint!\n@IBOutlet weak var imageViewBottomConstraint: NSLayoutConstraint!\n@IBOutlet weak var imageViewLeadingConstraint: NSLayoutConstraint!\n</code></pre>\n<h3 id=\"9-3-代码实现\"><a href=\"#9-3-代码实现\" class=\"headerlink\" title=\"9.3 代码实现\"></a>9.3 代码实现</h3><p>首先在初始化里面配置了一个mask:</p>\n<pre><code class=\"line-numbers language-Swift\"> scrollView.autoresizingMask = [.flexibleWidth, .flexibleHeight]\n</code></pre>\n<p>这个是自动调整尺寸设置。</p>\n<p>其实ScrollView本来就支持缩放的：</p>\n<blockquote>\n<p>在iOS中，滚动视图UIScrollView用于查看大于屏幕的内容。Scroll View有两个主要目的：<br>让用户拖动视图以显示更多内容区域。<br>让用户使用捏合手势放大或缩小所显示的内容。</p>\n</blockquote>\n<p>这里需要关注一个生命周期函数：viewWillLayoutSubviews</p>\n<blockquote>\n<p>有以下几种情况会调用（init初始化不会触发layoutSubviews）<br>1、addSubview会触发viewWillLayoutSubviews<br>2、设置self.view及子视图的frame.size会触发layoutSubviews，当然前提是frame.size的值设置前后发生了变化,注意，此处不是origin，呼应官方文档上的边界发生变化<br>3、滚动一个UIScrollView(该scrollview有子视图的时候)会触发layoutSubviews<br>4、横竖屏幕切换会触发</p>\n</blockquote>\n<p>这里最为关键的就是这个 viewWillLayoutSubviews函数和viewForZooming了,如果没有这个代码，无法支持缩放效果!</p>\n<pre><code class=\"line-numbers language-Swift\">//每次控制器更新其子视图时，更新最小缩放比例\noverride func viewWillLayoutSubviews() &#123;\n    super.viewWillLayoutSubviews()\n    updateMinZoomScaleForSize(view.bounds.size)\n&#125;\n\n//计算scrollView的缩放比例，缩放比例为1表示内容以正常大小显示；缩放比例小于1表示容器内的内容缩小，缩放比例大于1表示放大容器内的内容\nfileprivate func updateMinZoomScaleForSize(_ size: CGSize)\n&#123;\n    //要获得最小的缩放比例，首先计算所需的缩放比例，以便根据其宽度在scrollView中紧贴imageView\n    let widthScale = size.width / imageView.bounds.width\n    let heightScale = size.height / imageView.bounds.height\n    //选取宽度和高度比例中最小的那个,设置为minimumZoomScale\n    let minScale = min(widthScale,heightScale)\n    \n    scrollView.minimumZoomScale = minScale\n    scrollView.maximumZoomScale = 3.0\n    scrollView.zoomScale = minScale\n&#125;\n</code></pre>\n<p>这样ScrollView就有一个最小和最大缩放比例了。</p>\n<p>另外还有一个协议：</p>\n<pre><code class=\"line-numbers language-Swift\">func viewForZooming(in scrollView: UIScrollView) -&gt; UIView? &#123;\n    //当手势动作发生时，scrollView告诉控制器要放大或缩小子视图imageView\n    return imageView\n&#125;\n</code></pre>\n<p>必须要有viewForZooming，这个作用就是谁可以放大或缩小。</p>\n<p>viewForZooming+viewWillLayoutSubviews，两者结合才能实现子View缩放效果。</p>\n<p>两位还有一个scrollViewDidZoom方法, 当scrollView缩放时调用,在缩放过程中会被多次调用：</p>\n<pre><code class=\"line-numbers language-Swift\">func scrollViewDidZoom(_ scrollView: UIScrollView) &#123;\n    updateConstraintsForSize(view.bounds.size)\n&#125;\n\n//当scrollView的内容大小小于边界时，内容将放置在左上角而不是中心，updateConstraintForSize方法处理这个问题；通过调整图像视图的布局约束。\nfileprivate func updateConstraintsForSize(_ size: CGSize) &#123;\n    \n    ////将图像垂直居中，从视图高度减去imageView的高度并分成两半，这个值用作顶部和底部imageView的约束\n    let yOffset = max(0, (size.height - imageView.frame.height) / 2)\n    imageViewTopConstraint.constant = yOffset\n    imageViewBottomConstraint.constant = yOffset\n    \n    ////根据宽度计算imageView前后约束的偏移量\n    let xOffset = max(0, (size.width - imageView.frame.width) / 2)\n    imageViewLeadingConstraint.constant = xOffset\n    imageViewTrailingConstraint.constant = xOffset\n    \n    view.layoutIfNeeded()\n&#125;\n</code></pre>\n<p>另外还有其它的代理方法如下：</p>\n<blockquote>\n<p>func scrollViewDidScroll(_ scrollView: UIScrollView)<br>scrollView滚动时调用，在滚动过程中会多次调用</p>\n</blockquote>\n<blockquote>\n<p>func scrollViewWillBeginDragging(_ scrollView: UIScrollView)<br>将要开始拖拽时调用</p>\n</blockquote>\n<blockquote>\n<p>func scrollViewWillEndDragging(_ scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer<CGPoint>)<br>将要停止拖拽时 velocity:加速度 向左滑动 x为负值，否则为正值 向上滚动为y为负值否则为正值；targetContentOffset:滚动停止时的ContentOffset</p>\n</blockquote>\n<blockquote>\n<p>func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool)<br>停止拖拽时调用， willDecelerate:停止拖拽时是否要减速，若值为false表示已经停止减速，也就意味着滚动已停止，此时不会调用scrollViewWillBeginDecelerating和scrollViewDidEndDecelerating;若值为true，则代表scrollView正在减速滚动</p>\n</blockquote>\n<blockquote>\n<p>func scrollViewWillBeginDecelerating(_ scrollView: UIScrollView)<br>开始减速的时候调用(也就是松开手指时)，在拖拽滚动的时候，如果松手时已经停止滚动则不会调用</p>\n</blockquote>\n<blockquote>\n<p>func scrollViewDidEndDecelerating(_ scrollView: UIScrollView)<br>停止减速的时候调用（也就是停止滚动的时候调用），在拖拽滚动的时候，如果松手时已经停止滚动则不会调用</p>\n</blockquote>\n<blockquote>\n<p>func scrollViewDidEndScrollingAnimation(_ scrollView: UIScrollView)<br>当调用setContentOffset(_ contentOffset: CGPoint, animated: Bool)&#x2F;scrollRectToVisible(_ rect: CGRect, animated: Bool)API并且animated参数为true时,会在scrollView滚动结束时调用。若是UITableView或者UICollectionView,调用scrollToRow也和上面一样</p>\n</blockquote>\n<blockquote>\n<p>func viewForZooming(in scrollView: UIScrollView) -&gt; UIView?<br>放回要缩放的view，此view必须是scrollView的subview</p>\n</blockquote>\n<blockquote>\n<p>func scrollViewDidZoom(_ scrollView: UIScrollView)<br>当scrollView缩放时调用,在缩放过程中会被多次调用</p>\n</blockquote>\n<blockquote>\n<p>func scrollViewWillBeginZooming(_ scrollView: UIScrollView, with view: UIView?)<br>scrollView开始缩放时调用</p>\n</blockquote>\n<blockquote>\n<p>func scrollViewDidEndZooming(_ scrollView: UIScrollView, with view: UIView?, atScale scale: CGFloat)<br>scrollView结束缩放时调用</p>\n</blockquote>\n<blockquote>\n<p>func scrollViewShouldScrollToTop(_ scrollView: UIScrollView) -&gt; Bool<br>是否允许点击scrollview的头部，让其滚动到最上面,若不实现此代理，则默认为true</p>\n</blockquote>\n<blockquote>\n<p>func scrollViewDidScrollToTop(_ scrollView: UIScrollView)<br>当滚动到最上面时调用</p>\n</blockquote>\n<h2 id=\"10-视频背景\"><a href=\"#10-视频背景\" class=\"headerlink\" title=\"10 视频背景\"></a>10 视频背景</h2><h3 id=\"10-1-效果\"><a href=\"#10-1-效果\" class=\"headerlink\" title=\"10.1 效果\"></a>10.1 效果</h3><img src=videobg.gif>\n\n<h3 id=\"10-2-定义一个基类播放控制器\"><a href=\"#10-2-定义一个基类播放控制器\" class=\"headerlink\" title=\"10.2 定义一个基类播放控制器\"></a>10.2 定义一个基类播放控制器</h3><pre><code class=\"line-numbers language-Swift\">public enum ScalingMode &#123;\n  case resize\n  case resizeAspect\n  case resizeAspectFill\n&#125;\n</code></pre>\n<p>定义了3种缩放模式。</p>\n<p>再定义有关视频的属性：</p>\n<pre><code class=\"line-numbers language-Swift\">// 视频播放器\nfileprivate let moviePlayer = AVPlayerViewController()\n     \n  // 声音   \n  fileprivate var moviePlayerSoundLevel: Float = 1.0\n\n   // 播放url  \n   var contentURL: URL? &#123;\n    didSet &#123;\n      if let _contentURL = contentURL &#123;\n      setMoviePlayer(_contentURL)\n      &#125;\n    &#125;\n  &#125;\n\n   var videoFrame: CGRect = CGRect()\n   var startTime: CGFloat = 0.0\n   var duration: CGFloat = 0.0\n\n   // 背景\n   var backgroundColor: UIColor = UIColor.black &#123;\n    didSet &#123;\n      view.backgroundColor = backgroundColor\n    &#125;\n  &#125;\n\n  // 声音\n   var sound: Bool = true &#123;\n    didSet &#123;\n      if sound &#123;\n        moviePlayerSoundLevel = 1.0\n      &#125;else&#123;\n        moviePlayerSoundLevel = 0.0\n      &#125;\n    &#125;\n  &#125;\n  \n  // alpha\n   var alpha: CGFloat = CGFloat() &#123;\n    didSet &#123;\n      moviePlayer.view.alpha = alpha\n    &#125;\n  &#125;\n\n  // 是否重复 这里发送一个全局通知\n   var alwaysRepeat: Bool = true &#123;\n    didSet &#123;\n      if alwaysRepeat &#123;\n        NotificationCenter.default.addObserver(self,\n          selector: #selector(VideoSplashViewController.playerItemDidReachEnd),\n          name: NSNotification.Name.AVPlayerItemDidPlayToEndTime,\n          object: moviePlayer.player?.currentItem)\n      &#125;\n    &#125;\n  &#125;\n\n  // 填充模式\n   var fillMode: ScalingMode = .resizeAspectFill &#123;\n    didSet &#123;\n      switch fillMode &#123;\n      case .resize:\n          moviePlayer.videoGravity = AVLayerVideoGravity.resize.rawValue\n      case .resizeAspect:\n          moviePlayer.videoGravity = AVLayerVideoGravity.resizeAspect.rawValue\n      case .resizeAspectFill:\n          moviePlayer.videoGravity = AVLayerVideoGravity.resizeAspectFill.rawValue\n      &#125;\n    &#125;\n  &#125;\n</code></pre>\n<p>生命周期已经显示,添加子View和视频view：</p>\n<pre><code class=\"line-numbers language-Swift\">  override func viewDidAppear(_ animated: Bool) &#123;\n    moviePlayer.view.frame = videoFrame\n    moviePlayer.showsPlaybackControls = false\n    view.addSubview(moviePlayer.view)\n    view.sendSubview(toBack: moviePlayer.view)\n  &#125;\n</code></pre>\n<p>生命周期将要消失，移除通知：</p>\n<pre><code class=\"line-numbers language-Swift\">  override func viewWillDisappear(_ animated: Bool) &#123;\n    super.viewDidDisappear(animated)\n    NotificationCenter.default.removeObserver(self)\n  &#125;\n</code></pre>\n<p>设置播放器：</p>\n<pre><code class=\"line-numbers language-Swift\"> fileprivate func setMoviePlayer(_ url: URL)&#123;\n    let videoCutter = VideoCutter()\n    videoCutter.cropVideoWithUrl(videoUrl: url, startTime: startTime, duration: duration) &#123; (videoPath, error) -&gt; Void in\n      if let path = videoPath as URL? &#123;\n        DispatchQueue.main.async &#123;\n            self.moviePlayer.player = AVPlayer(url: path)\n            self.moviePlayer.player?.play()\n            self.moviePlayer.player?.volume = self.moviePlayerSoundLevel\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n</code></pre>\n<p>播放视频，前面监听视频播放完成消息，然后走这个方法，可实现重复播放效果：</p>\n<pre><code class=\"line-numbers language-Swift\">  @objc func playerItemDidReachEnd() &#123;\n    moviePlayer.player?.seek(to: kCMTimeZero)\n    moviePlayer.player?.play()\n  &#125;\n</code></pre>\n<h3 id=\"10-3-实现视频背景效果控制器\"><a href=\"#10-3-实现视频背景效果控制器\" class=\"headerlink\" title=\"10.3 实现视频背景效果控制器\"></a>10.3 实现视频背景效果控制器</h3><pre><code class=\"line-numbers language-Swift\"> @IBOutlet weak var loginButton: UIButton!\n    @IBOutlet weak var signupButton: UIButton!\n</code></pre>\n<p>这里搞2个View。</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n    super.viewDidLoad()\n    setupVideoBackground()\n    \n    loginButton.layer.cornerRadius = 4\n    signupButton.layer.cornerRadius = 4\n    \n&#125;\n\nfunc setupVideoBackground() &#123;\n    \n    let url = URL(fileURLWithPath: Bundle.main.path(forResource: &quot;moments&quot;, ofType: &quot;mp4&quot;)!)\n    \n    videoFrame = view.frame\n    fillMode = .resizeAspectFill\n    alwaysRepeat = true\n    sound = true\n    startTime = 2.0\n    alpha = 0.8\n    \n    contentURL = url\n    // view.isUserInteractionEnabled = false\n    \n&#125;\n</code></pre>\n<p>这里初始化，设置视频背景，设置按钮圆角。</p>\n<h3 id=\"10-4-视频剪切工具\"><a href=\"#10-4-视频剪切工具\" class=\"headerlink\" title=\"10.4 视频剪切工具\"></a>10.4 视频剪切工具</h3><p>前面设置播放器，用到了一个VideoCutter类，<br>这里：</p>\n<pre><code class=\"line-numbers language-Swift\"> fileprivate func setMoviePlayer(_ url: URL)&#123;\n    let videoCutter = VideoCutter()\n    videoCutter.cropVideoWithUrl(videoUrl: url, startTime: startTime, duration: duration) &#123; (videoPath, error) -&gt; Void in\n      if let path = videoPath as URL? &#123;\n        DispatchQueue.main.async &#123;\n            self.moviePlayer.player = AVPlayer(url: path)\n            self.moviePlayer.player?.play()\n            self.moviePlayer.player?.volume = self.moviePlayerSoundLevel\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n</code></pre>\n<p>这里其实是根据startTime和duration来剪切目标视频url，返回一个新的videoPath，这里再重新播放的。</p>\n<p>需要看下如何剪切的：</p>\n<pre><code class=\"line-numbers language-Swift\">extension String &#123;\n  var convert: NSString &#123; return (self as NSString) &#125;\n&#125;\n\n class VideoCutter: NSObject &#123;\n\n  /**\n  Block based method for crop video url\n  \n  @param videoUrl Video url\n  @param startTime The starting point of the video segments\n  @param duration Total time, video length\n\n  */\n   func cropVideoWithUrl(videoUrl url: URL, startTime: CGFloat, duration: CGFloat, completion: ((_ videoPath: URL?, _ error: NSError?) -&gt; Void)?) &#123;\n    DispatchQueue.global(qos: DispatchQoS.QoSClass.default).async &#123;\n        let asset = AVURLAsset(url: url, options: nil)\n        let exportSession = AVAssetExportSession(asset: asset, presetName: &quot;AVAssetExportPresetHighestQuality&quot;)\n        let paths: NSArray = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true) as NSArray\n        var outputURL = paths.object(at: 0) as! String\n        let manager = FileManager.default\n        // 异常处理：\n        // try?: 将错误转化成可选异常,有错误发生时返回nil\n        // try!: 禁用错误传递，当确认无异常发生时使用，否则可能会发生运行时异常\n        // defer: 在即将离开当前代码块时执行一系列语句,延迟执行的语句不能包含任何控制转移语句，例如break、return语句，或是抛出一个错误。\n        // defer语句是从后往前执行\n        do &#123;\n            try manager.createDirectory(atPath: outputURL, withIntermediateDirectories: true, attributes: nil)\n        &#125; catch _ &#123;\n        &#125;\n        outputURL = outputURL.convert.appendingPathComponent(&quot;output.mp4&quot;)\n        do &#123;\n            try manager.removeItem(atPath: outputURL)\n        &#125; catch _ &#123;\n        &#125;\n        if let exportSession = exportSession as AVAssetExportSession? &#123;\n            exportSession.outputURL = URL(fileURLWithPath: outputURL)\n            exportSession.shouldOptimizeForNetworkUse = true\n            exportSession.outputFileType = AVFileType.mp4\n            let start = CMTimeMakeWithSeconds(Float64(startTime), 600)\n            let duration = CMTimeMakeWithSeconds(Float64(duration), 600)\n            let range = CMTimeRangeMake(start, duration)\n            exportSession.timeRange = range\n           \n            exportSession.exportAsynchronously &#123;\n                switch exportSession.status &#123;\n                case AVAssetExportSessionStatus.completed:\n                    completion?(exportSession.outputURL, nil)\n                case AVAssetExportSessionStatus.failed:\n                    print(&quot;Failed: \\(String(describing: exportSession.error))&quot;)\n                case AVAssetExportSessionStatus.cancelled:\n                    print(&quot;Failed: \\(String(describing: exportSession.error))&quot;)\n                default:\n                    print(&quot;default case&quot;)\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<p>这是个工具，简单看下就行。</p>\n<h2 id=\"11-总结\"><a href=\"#11-总结\" class=\"headerlink\" title=\"11 总结\"></a>11 总结</h2><ul>\n<li>1.第一个是计时器demo，界面很简单，主要学会Timer用法，每次继续其实也是new了一个Timer，Timer的作用只是更新，数值是我们自己记录的。</li>\n<li>2.第二个改变字体，主要学会字体文件放在根目录，xCode会自动识别，然后设置字体可以通过UILabel的Font属性，其次学会UiTableView用法，懂得设置数据源和代理。</li>\n<li>3.本地视频，当然就是学会AVPlayer的用法，还要用到系统的一个控制器。</li>\n<li>4.摄像头，主要学会Session用法，input，outPut设置，通过设置AV预览图设置给UIView，达成预览效果，另外学会水平ScrollView可实现类似分页效果，当然坐标要按照屏幕宽度设置下。</li>\n<li>5.传送带效果，学会设置UICollectionView和UIScrollView的代理，做到良好的用户体验效果，滑动到半屏和不足半屏的考虑。另外学会了xib布局方式，可以绑定控制器。</li>\n<li>6.定位，学会使用系统提供的定位Api，在代理里面处理自己的逻辑。</li>\n<li>7.下拉刷新，是UIScrollView里面的refreshControl提供的功能，自带了loading效果，可以自行添加文案。</li>\n<li>8.炫彩音乐，主要学会音频播放，以及随机函数的用法，还有渐变色调用方式。</li>\n<li>9.图片缩放效果，这个主要是UIScrollView的子View这种方式提供的缩放效果，主要还是针对代理方法做一些调整。</li>\n<li>10.视频背景，这个主要就是学会构造一个基类控制器，可实现播放视频效果，通过配置不同参数丰富这个基类，然后另外就是学会视频剪切。</li>\n</ul>\n"},{"title":"iOS swift 3天30个swift项目之第二天","date":"2023-02-04T01:49:09.000Z","op":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 渐变TableView\n\n### 1.1 效果\n<img src=cleartableviewcell.gif>\n\n### 1.2 代码实现\n\n直接是继承了UITableViewController这个控制器，这个应该是自带了一个列表。内部有一个tableView。\n```\nclass ClearTableViewController: UITableViewController {\n```\n\n初始化：\n```Swift\noverride func viewDidLoad() {\n        super.viewDidLoad()\n\n        self.view.backgroundColor = UIColor.black\n        self.tableView.separatorStyle = UITableViewCellSeparatorStyle.none\n        self.tableView.tableFooterView = UIView(frame: CGRect.zero)\n        self.tableView.register(TableViewCell.self, forCellReuseIdentifier: \"tableCell\")        \n}\n```\n\n这里绑定了TableViewCell。\n```Swift\nclass TableViewCell: UITableViewCell {\n\n    let gradientLayer = CAGradientLayer()\n    \n    override func awakeFromNib() {\n        super.awakeFromNib()\n    }\n    \n    override func setSelected(_ selected: Bool, animated: Bool) {\n        super.setSelected(selected, animated: animated)\n    }\n    \n    override init(style: UITableViewCellStyle, reuseIdentifier: String?) {\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        \n        gradientLayer.frame = self.bounds\n        let color1 = UIColor(white: 1.0, alpha: 0.2).cgColor\n        let color2 = UIColor(white: 1.0, alpha: 0.1).cgColor\n        let color3 = UIColor.clear.cgColor\n        let color4 = UIColor(white: 0.0, alpha: 0.05).cgColor\n        \n        gradientLayer.colors = [color1, color2, color3, color4]\n        gradientLayer.locations = [0.0, 0.04, 0.95, 1.0]\n    }\n    \n    override func layoutSubviews() {\n        super.layoutSubviews()\n        gradientLayer.frame = self.bounds\n    }\n\n    required init?(coder aDecoder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n}\n```\n这里把UITableViewCell的bounds给到了一个渐变层CAGradientLayer。\n\n数据绑定：\n```Swift\n var tableData = [\"Read 3 article on Medium\", \"Cleanup bedroom\", \"Go for a run\", \"Hit the gym\", \"Build another swift project\", \"Movement training\", \"Fix the layout problem of a client project\", \"Write the experience of #30daysSwift\", \"Inbox Zero\", \"Booking the ticket to Chengdu\", \"Test the Adobe Project Comet\", \"Hop on a call to mom\"]\n```\n\n然后因为这个是UITableViewController，就无需重复设置代理了：\n```Swift\noverride func numberOfSections(in tableView: UITableView) -> Int {\n        return 1\n    }\n    \n    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        return tableData.count\n    }\n    \n    override func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n        return 60\n    }\n    \n    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n        \n        let cell = tableView.dequeueReusableCell(withIdentifier: \"tableCell\", for: indexPath) as! TableViewCell\n        \n        cell.textLabel?.text = tableData[indexPath.row]\n        cell.textLabel?.textColor = UIColor.white\n        cell.textLabel?.backgroundColor = UIColor.clear\n        cell.textLabel?.font = UIFont(name: \"Avenir Next\", size: 18)\n        cell.selectionStyle = UITableViewCellSelectionStyle.none\n        return cell\n    }\n    \n    override func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {\n        cell.backgroundColor = colorforIndex(index: indexPath.row)\n    }\n    \n    func colorforIndex(index: Int) -> UIColor {\n        \n        let itemCount = tableData.count - 1\n        let color = (CGFloat(index) / CGFloat(itemCount)) * 0.6\n        return UIColor(red: 1.0, green: color, blue: 0.0, alpha: 1.0)\n    }\n```\n重点实现下这几个代理方法即可。颜色设置主要是通过willDisplay这个方法设置进去了。\n\n## 2 登录动画\n\n### 2.1 效果\n<img src=simple%20login%20animation.gif>\n\n### 2.2 故事版关系\n<img src=21_1.png>\n这里是有两个场景Scene，每个Scene绑定了一个类，也就是左侧的两个Controller。\n这里学会了不用代码，直接用storyboard直接实现控制器的跳转。\n\n可以参考下这篇文章：[Xcode新建View Controller Scene并实现界面间跳转的方法](https://blog.csdn.net/Sherlooock/article/details/106825134)。\n\n### 2.3 启动页\n```Swift\nclass SplasViewController: UIViewController {\n    \n    @IBOutlet weak var signupButton: UIButton!\n    @IBOutlet weak var loginButton: UIButton!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        signupButton.layer.cornerRadius = 5\n        loginButton.layer.cornerRadius = 5 \n    }\n    \n    override var preferredStatusBarStyle: UIStatusBarStyle {\n        return UIStatusBarStyle.lightContent\n    }\n}\n这里设置了按钮圆角。\n```\n\n### 2.4 登录页\nUI定义：\n```Swift\n@IBOutlet weak var uesernameTextField: UITextField!\n@IBOutlet weak var passwordTextField: UITextField!\n\n@IBOutlet weak var centerAlignUsername: NSLayoutConstraint!\n@IBOutlet weak var centerAlignPassword: NSLayoutConstraint!\n\n@IBOutlet weak var loginButton: UIButton!\n```\n\n初始化：\n```Swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    \n    uesernameTextField.layer.cornerRadius = 5\n    passwordTextField.layer.cornerRadius = 5\n    uesernameTextField.delegate = self\n    passwordTextField.delegate = self\n    loginButton.layer.cornerRadius = 5\n}\n```\n这里设置编辑框代理，设置按钮圆角。\n\n将要显示：\n```Swift\noverride func viewWillAppear(_ animated: Bool) {\n    super.viewWillAppear(animated)\n    \n    centerAlignUsername.constant -= view.bounds.width\n    centerAlignPassword.constant -= view.bounds.width\n    loginButton.alpha = 0\n}\n```\n这里设置刚进页面x轴减去控件宽度，实现效果就是从左边滑出来。\n\n已经显示了：\n```Swift\noverride func viewDidAppear(_ animated: Bool) {\n    super.viewDidAppear(animated)\n    \n    UIView.animate(withDuration: 0.5, delay: 0.00, options: .curveEaseOut, animations: {\n        \n        self.centerAlignUsername.constant += self.view.bounds.width\n        self.view.layoutIfNeeded()\n    \n        }, completion: nil)\n    \n    UIView.animate(withDuration: 0.5, delay: 0.10, options: .curveEaseOut, animations: {\n        \n        self.centerAlignPassword.constant += self.view.bounds.width\n        self.view.layoutIfNeeded()\n        \n        }, completion: nil)\n    \n    UIView.animate(withDuration: 0.5, delay: 0.20, options: .curveEaseOut, animations: {\n        \n        self.loginButton.alpha = 1\n        \n        }, completion: nil)\n\n}\n```\n这是设置3个动画，将三个视图从左边滑出。\n\n## 3 列表动画\n\n### 3.1 效果\n<img src=AnimateTabel.gif>\n\n### 3.2 第一个列表\n初始化：\n```Swift\noverride func viewDidLoad() {\n    super.viewDidLoad()    \n    self.view.backgroundColor = UIColor.black\n    self.tableView.separatorStyle = UITableViewCellSeparatorStyle.none\n    self.tableView.tableFooterView = UIView(frame: CGRect.zero)\n    self.tableView.register(FirstTableCell.self, forCellReuseIdentifier: \"tableCell\")\n}\n```\n这里绑定了第一个Table的Cell：\n```Swift\nclass FirstTableCell: UITableViewCell {\n\n    let gradientLayer = CAGradientLayer()\n    \n    override func awakeFromNib() {\n        super.awakeFromNib()\n    }\n    \n    override func setSelected(_ selected: Bool, animated: Bool) {\n        super.setSelected(selected, animated: animated)\n    }\n    \n    \n    override init(style: UITableViewCellStyle, reuseIdentifier: String?) {\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        \n        gradientLayer.frame = self.bounds\n        let color1 = UIColor(white: 1.0, alpha: 0.2).cgColor as CGColor\n        let color2 = UIColor(white: 1.0, alpha: 0.1).cgColor as CGColor\n        let color3 = UIColor.clear.cgColor as CGColor\n        let color4 = UIColor(white: 0.0, alpha: 0.05).cgColor as CGColor\n        \n        gradientLayer.colors = [color1, color2, color3, color4]\n        gradientLayer.locations = [0.0, 0.04, 0.95, 1.0]\n        layer.insertSublayer(gradientLayer, at: 0)\n    }\n    \n    override func layoutSubviews() {\n        super.layoutSubviews()\n        gradientLayer.frame = self.bounds\n    }\n    \n    required init?(coder aDecoder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n}\n```\n这里跟前面类似，设置了渐变背景。通过layer层insertSublayer设置了渐变层实现。\n\n如何实现动画呢？\n继续看第一个控制器。\n\n将要的生命周期：\n```Swift\noverride func viewWillAppear(_ animated: Bool) {\n    animateTable()\n}\n\nfunc animateTable() {\n        self.tableView.reloadData()\n        let cells = tableView.visibleCells\n        let tableHeight: CGFloat = tableView.bounds.size.height\n        \n        for i in cells {\n            let cell: UITableViewCell = i as UITableViewCell\n            cell.transform = CGAffineTransform(translationX: 0, y: tableHeight)\n        }\n        \n        var index = 0\n        for a in cells {\n            \n            let cell: UITableViewCell = a as UITableViewCell\n            \n            UIView.animate(withDuration: 1.5, delay: 0.05 * Double(index), usingSpringWithDamping: 0.8, initialSpringVelocity: 0, options: [], animations: {\n                \n                cell.transform = CGAffineTransform(translationX: 0, y: 0);\n                \n            }, completion: nil)\n            \n            index += 1\n        }\n    }\n```\n这里一个设置了Cell的transform，第一个是从底部初始位置，第二个循环是恢复到目标位置。\n\n第一个table绑定的代理和数据源：\n```Swift\noverride func numberOfSections(in tableView: UITableView) -> Int {\n        return 1\n    }\n    \noverride func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n    return tableData.count\n}\n\noverride func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n    return 60\n}\n\noverride func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    \n    let cell = tableView.dequeueReusableCell(withIdentifier: \"tableCell\", for: indexPath)\n    \n    cell.textLabel?.text = tableData[indexPath.row]\n    cell.textLabel?.textColor = UIColor.white\n    cell.textLabel?.backgroundColor = UIColor.clear\n    cell.textLabel?.font = UIFont(name: \"Avenir Next\", size: 18)\n    cell.selectionStyle = UITableViewCellSelectionStyle.none\n    return cell\n}\n\noverride func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {\n    cell.backgroundColor =  colorforIndex(indexPath.row)\n}\n\noverride func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n    performSegue(withIdentifier: \"ShowAnimateTableViewController\", sender: nil)\n}\n\nfunc colorforIndex(_ index: Int) -> UIColor {\n    let itemCount = tableData.count - 1\n    let color = (CGFloat(index) / CGFloat(itemCount)) * 0.6\n    return UIColor(red: color, green: 0.0, blue: 1.0, alpha: 1.0)\n}\n```\n这里设置了渐变色，和前面一样。\n\n### 3.3 第2个列表\n\n继承UITableViewController:\n```Swift\nclass AnimateTableViewController: UITableViewController {\n```\n\n初始化：\n```Swift\n override func viewDidLoad() {\n    super.viewDidLoad()\n    \n    self.view.backgroundColor = UIColor.black\n    self.tableView.separatorStyle = UITableViewCellSeparatorStyle.none\n    self.tableView.tableFooterView = UIView(frame: CGRect.zero)\n    self.tableView.register(SecondTableCell.self, forCellReuseIdentifier: \"SecondTableCell\")\n}\n```\n\n将要显示：\n```Swift\noverride func viewWillAppear(_ animated: Bool) {\n    animateTable()\n}\n    \nfunc animateTable() {\n    \n    self.tableView.reloadData()\n    \n    let cells = tableView.visibleCells\n    let tableHeight: CGFloat = tableView.bounds.size.height\n    \n    for (index, cell) in cells.enumerated() {\n        cell.transform = CGAffineTransform(translationX: 0, y: tableHeight)\n        UIView.animate(withDuration: 1.0, delay: 0.05 * Double(index), usingSpringWithDamping: 0.8, initialSpringVelocity: 0, options: [], animations: {\n                cell.transform = CGAffineTransform(translationX: 0, y: 0);\n            }, completion: nil)\n    }\n}\n```\n这里设置了显示动画，从底部弹出效果。\n\n```Swift\noverride func numberOfSections(in tableView: UITableView) -> Int {\n        return 1\n    }\n    \noverride func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n    return tableData.count\n}\n\noverride func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n    return 60\n}\n\noverride func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    \n    let cell = tableView.dequeueReusableCell(withIdentifier: \"SecondTableCell\", for: indexPath)\n    \n    cell.textLabel?.text = tableData[indexPath.row]\n    cell.textLabel?.textColor = UIColor.white\n    cell.textLabel?.backgroundColor = UIColor.clear\n    cell.textLabel?.font = UIFont(name: \"Avenir Next\", size: 18)\n    cell.selectionStyle = UITableViewCellSelectionStyle.none\n    return cell\n    \n}\n\noverride func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {\n    cell.backgroundColor =  colorforIndex(indexPath.row)\n}\n\nfunc colorforIndex(_ index: Int) -> UIColor {\n    let itemCount = tableData.count - 1\n    let color = (CGFloat(index) / CGFloat(itemCount)) * 0.6\n    return UIColor(red: 1.0, green: color, blue: 0.0, alpha: 1.0)\n}\n```\n这里数据源绑定。还需要一个Cell支持下。\nSecondTableCell:\n```Swift\nclass SecondTableCell: UITableViewCell {\n    \n    let gradientLayer = CAGradientLayer()\n    \n    override func awakeFromNib() {\n        super.awakeFromNib()\n    }\n    \n    override func setSelected(_ selected: Bool, animated: Bool) {\n        super.setSelected(selected, animated: animated)\n    }\n\n    override init(style: UITableViewCellStyle, reuseIdentifier: String?) {\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        \n        gradientLayer.frame = self.bounds\n        let color1 = UIColor(white: 1.0, alpha: 0.2).cgColor as CGColor\n        let color2 = UIColor(white: 1.0, alpha: 0.1).cgColor as CGColor\n        let color3 = UIColor.clear.cgColor as CGColor\n        let color4 = UIColor(white: 0.0, alpha: 0.05).cgColor as CGColor\n        \n        gradientLayer.colors = [color1, color2, color3, color4]\n        gradientLayer.locations = [0.0, 0.04, 0.95, 1.0]\n        layer.insertSublayer(gradientLayer, at: 0)\n    }\n    \n    override func layoutSubviews() {\n        super.layoutSubviews()\n        gradientLayer.frame = self.bounds\n    }\n    \n    required init?(coder aDecoder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n}\n```\n这里和第一个Cell类似。\n\n## 4 游戏抽奖滚动图案\n\n### 4.1 效果\n<img src=emoji%20spin.gif>\n\n### 4.2 UI\n这里一个背景图片\ngo按钮\n中间是UIPickerView，有点像时间滚动条\n底部模式，结果文案。\n\n直接在故事版里面拖好了。\n\n然后拖动3个View到控制器：\n```Swift\nclass ViewController: UIViewController {\n\n    @IBOutlet weak var emojiPickerView: UIPickerView!\n    @IBOutlet weak var goButton: UIButton!\n    @IBOutlet weak var resultLabel: UILabel!\n```\n\n### 4.3 Data\n```Swift\n var imageArray = [String]()\n    var dataArray1 = [Int]()\n    var dataArray2 = [Int]()\n    var dataArray3 = [Int]()\n    var amazingFlag = false\n    var bounds: CGRect = CGRect.zero\n```\n变量声明，等下作为UIPickerView的数据。\n\n### 4.3 生命周期之viewDidLoad\n```Swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    \n    bounds = goButton.bounds\n    imageArray = [\"👻\",\"👸\",\"💩\",\"😘\",\"🍔\",\"🤖\",\"🍟\",\"🐼\",\"🚖\",\"🐷\"]\n    \n    for _ in 0...100 {\n        self.dataArray1.append((Int)(arc4random() % 10 ))\n        self.dataArray2.append((Int)(arc4random() % 10 ))\n        self.dataArray3.append((Int)(arc4random() % 10 ))\n    }\n    \n    resultLabel.text = \"\"\n    \n    emojiPickerView.delegate = self\n    emojiPickerView.dataSource = self\n    \n    goButton.layer.cornerRadius = 6\n    goButton.layer.masksToBounds = true\n}\n```\n这里生成长度为100的3个数组。本质上存放的0到9个数字。\n\n### 4.4 将要可见\n```Swift\noverride func viewWillAppear(_ animated: Bool) {\n    super.viewWillAppear(animated)\n    \n    goButton.alpha = 0   \n}\n```\n\n### 4.5 已经可见\n```Swift\noverride func viewDidAppear(_ animated: Bool) {\n    super.viewDidAppear(animated)\n    \n    UIView.animate(withDuration: 0.5, delay: 0.3, options: .curveEaseOut, animations: {\n        \n        self.goButton.alpha = 1\n        \n        }, completion: nil)\n}\n```\n底部按钮逐渐显示。\n\n### 4.6 点击事件\n```Swift\n@IBAction func amazingButtonDidTouch(_ sender: UIButton) {\n    amazingFlag = !amazingFlag;\n    sender.setTitle(amazingFlag ? \"开挂模式\":\"常规模式\", for: .normal)\n}\n\n@IBAction func goButtoDidTouch(_ sender: AnyObject) {\n    let index1: Int\n    let index2: Int\n    let index3: Int\n    if amazingFlag {\n        index1 = Int(arc4random()) % 90 + 3\n        index2 = dataArray2.firstIndex(of: dataArray1[index1])!\n        index3 = dataArray3.lastIndex(of: dataArray1[index1])!\n    } else {\n        index1 = Int(arc4random()) % 90 + 3\n        index2 = Int(arc4random()) % 90 + 3\n        index3 = Int(arc4random()) % 90 + 3\n    }\n    \n    /// 下次多少行，开启动画效果\n    emojiPickerView.selectRow(index1, inComponent: 0, animated: true)\n    emojiPickerView.selectRow(index2, inComponent: 1, animated: true)\n    emojiPickerView.selectRow(index3, inComponent: 2, animated: true)\n    \n    /// 结果显示\n    if(dataArray1[emojiPickerView.selectedRow(inComponent: 0)] == dataArray2[emojiPickerView.selectedRow(inComponent: 1)] && dataArray2[emojiPickerView.selectedRow(inComponent: 1)] == dataArray3[emojiPickerView.selectedRow(inComponent: 2)]) {\n        \n        resultLabel.text = \"Bingo!\"\n        \n    } else {\n        resultLabel.text = \"💔\"\n    }\n    \n    /// 底部Go抖动效果\n    UIView.animate(withDuration: 0.5, delay: 0.0, usingSpringWithDamping: 0.1, initialSpringVelocity: 5, options: .curveLinear, animations: {\n        \n        self.goButton.bounds = CGRect(x: self.bounds.origin.x, y: self.bounds.origin.y, width: self.bounds.size.width - 20, height: self.bounds.size.height)\n        \n    }, completion: { (compelete: Bool) in\n        \n        UIView.animate(withDuration: 0.1, delay: 0.0, options: UIViewAnimationOptions(), animations: {\n            \n            self.goButton.bounds = CGRect(x: self.bounds.origin.x, y: self.bounds.origin.y, width: self.bounds.size.width, height: self.bounds.size.height)\n            \n        }, completion: nil)\n        \n    })\n}\n```\n\n## 5 启动动画\n\n### 5.1 效果\n<img src=splash.gif>\n\n### 5.2 启动页\n启动页需要再info.plist中配置\n如下：\n<img src=25_1.png>\n\n这里我们在LaunchScreen.storyboard中设置了一个背景图片。\n这里面设置了一张白色的🕊没有效果哦。但是之前有，不知道为啥。\n\n### 5.3 首页\n首页其实加了一个同启动页的蓝色背景，中间减掉一个白鸽，然后白鸽再扩展的动画。\n这个背景是在故事版的View右侧属性里面的Background中设置的。\n\n设置蒙层：\n```Swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    // Do any additional setup after loading the view, typically from a nib.\n    \n    self.mask = CALayer()\n    self.mask!.contents = UIImage(named: \"twitter\")?.cgImage\n    self.mask!.contentsGravity = kCAGravityResizeAspect\n    self.mask!.bounds = CGRect(x: 0, y: 0, width: 100, height: 81)\n    self.mask!.anchorPoint = CGPoint(x: 0.5, y: 0.5)\n    self.imageView.setNeedsLayout()\n    self.imageView.layoutIfNeeded()\n    self.mask!.position = CGPoint(x: self.imageView.frame.size.width / 2, y: self.imageView.frame.size.height / 2)\n    self.imageView.layer.mask = mask\n    \n    animateMask()\n}\n```\n这里给到imageView的layer的mask，这样就相当于在蓝色背景中镂空可以看到里面的东西了。\n\n```Swift\nfunc animateMask() {\n    let keyFrameAnimation = CAKeyframeAnimation(keyPath: \"bounds\")\n    keyFrameAnimation.delegate = self\n    keyFrameAnimation.duration = 0.6\n    keyFrameAnimation.beginTime = CACurrentMediaTime() + 0.5\n    keyFrameAnimation.timingFunctions = [CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut), CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut)]\n    do {\n        // 动画需要加上这段代码，否则会造成页面闪一下\n        keyFrameAnimation.fillMode = kCAFillModeForwards\n        keyFrameAnimation.isRemovedOnCompletion = false\n    }\n    let initalBounds = NSValue(cgRect: mask!.bounds)\n    let secondBounds = NSValue(cgRect: CGRect(x: 0, y: 0, width: 90*0.9, height: 73*0.9))\n    let finalBounds = NSValue(cgRect: CGRect(x: 0, y: 0, width: 1600, height: 1300))\n    keyFrameAnimation.values = [initalBounds, secondBounds, finalBounds]\n    keyFrameAnimation.keyTimes = [0, 0.3, 1]\n    self.mask!.add(keyFrameAnimation, forKey: \"bounds\")\n}\n```\n这个动画的作用是将镂空效果爆炸，显示出主页面。\n\n动画停止后需要去除蒙层哦：\n```Swift\nextension ViewController : CAAnimationDelegate {\n    func animationDidStop(_ anim: CAAnimation, finished flag: Bool) {\n        self.imageView.layer.mask = nil\n    }\n}\n```\n动画结束，需要将蒙层去掉，不然屏幕上方会多出一块多余的遮挡视图。\n\n## 6 滑动菜单\n\n### 6.1 效果\n<img src=SlideMenu.gif>\n\n### 6.2 首页\n```Swift\nclass NewsTableViewController: BaseTableViewController {\n    let menuTransitionManager = MenuTransitionManager()\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        self.title = \"Everyday Moments\"\n        self.view.backgroundColor = UIColor(red:0.062, green:0.062, blue:0.07, alpha:1)\n    }\n    \n    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {\n        let menuTableViewController = segue.destination as! MenuTableViewController\n        menuTableViewController.currentItem = self.title!\n        menuTableViewController.transitioningDelegate = menuTransitionManager\n        menuTransitionManager.delegate = self\n    }\n}\n```\n这里有一个prepare方法，实际上是跳转到其它页面前会执行。\n我们在故事版里面定义了跳转关系，这里就可以通过prepare方法拿到跳转的目标控制器了。\n\n这是一个新闻的列表页。\n这里首先继承了BaseTableViewController:\n```Swift\nclass BaseTableViewController: UITableViewController {\n    \n    override var preferredStatusBarStyle: UIStatusBarStyle {\n        return UIStatusBarStyle.lightContent\n    }\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        self.tableView.separatorStyle = UITableViewCellSeparatorStyle.none\n    }\n}\n```\n\n然后这里有一个MenuTransitionManager,是我们自定义的一个类：\n个人猜测这个Transition相关的应该是为了实现一个转场动画，实现菜单能够丝滑地顶下来吧。\n里面放了一个自己定义的协议MenuTransitionManagerDelegate:\n```Swift\n@objc protocol MenuTransitionManagerDelegate {\n    func dismiss()\n}\n\nclass MenuTransitionManager: NSObject {\n    var duration = 0.5\n    var isPresenting = false\n    var delegate:MenuTransitionManagerDelegate?\n    var snapshot:UIView? {\n        didSet {\n            if let _delegate = delegate {\n                let tapGestureRecognizer = UITapGestureRecognizer(target: _delegate, action: #selector(MenuTransitionManagerDelegate.dismiss))\n                snapshot?.addGestureRecognizer(tapGestureRecognizer)\n            }\n        }\n    }\n}\n```\n\n然后扩展了一个UIViewControllerAnimatedTransitioning，\n这个应该是系统的协议：\n```Swift\nextension MenuTransitionManager : UIViewControllerAnimatedTransitioning {\n    func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -> TimeInterval {\n        return duration\n    }\n    \n    func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {\n        let fromView = transitionContext.view(forKey: .from)!\n        let toView = transitionContext.view(forKey: .to)!\n        let container = transitionContext.containerView\n        let moveLeft = CGAffineTransform(translationX: 250, y: 0)\n        let moveRight = CGAffineTransform(translationX: 0, y: 0)\n        \n        if isPresenting {\n            snapshot = fromView.snapshotView(afterScreenUpdates: true)\n            container.addSubview(toView)\n            container.addSubview(snapshot!)\n        }\n        \n        UIView.animate(withDuration: duration, delay: 0.0, usingSpringWithDamping: 0.9, initialSpringVelocity: 0.3, options: .curveEaseInOut, animations: {\n            if self.isPresenting {\n                self.snapshot?.transform = moveLeft\n                toView.transform = .identity\n            } else {\n                self.snapshot?.transform = .identity\n                fromView.transform = moveRight\n            }\n            \n        }, completion: { finished in\n            transitionContext.completeTransition(true)\n            if !self.isPresenting {\n                self.snapshot?.removeFromSuperview()\n            }\n        })\n    }\n}\n```\n同时也扩展了UIViewControllerTransitioningDelegate,也是系统的：\n```Swift\nextension MenuTransitionManager : UIViewControllerTransitioningDelegate {\n    func animationController(forDismissed dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n        isPresenting = false\n        return self\n    }\n    \n    func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n        isPresenting = true\n        return self\n    }\n}\n```\n\n再看下首页新闻展示的代理和数据源：\n```Swift\nextension NewsTableViewController {\n    // MARK: UITableViewDataSource\n    override func numberOfSections(in tableView: UITableView) -> Int {\n        return 3\n    }\n    \n    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        return 4\n    }\n    \n    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n        let cell = tableView.dequeueReusableCell(withIdentifier: \"Cell\", for: indexPath) as! NewsTableViewCell\n        cell.backgroundColor = UIColor.clear\n        \n        if indexPath.row == 0 {\n            cell.postImageView.image = UIImage(named: \"1\")\n            cell.postTitle.text = \"Love mountain.\"\n            cell.postAuthor.text = \"Allen Wang\"\n            cell.authorImageView.image = UIImage(named: \"a\")\n            \n        } else if indexPath.row == 1 {\n            cell.postImageView.image = UIImage(named: \"2\")\n            cell.postTitle.text = \"New graphic design - LIVE FREE\"\n            cell.postAuthor.text = \"Cole\"\n            cell.authorImageView.image = UIImage(named: \"b\")\n            \n        } else if indexPath.row == 2 {\n            cell.postImageView.image = UIImage(named: \"3\")\n            cell.postTitle.text = \"Summer sand\"\n            cell.postAuthor.text = \"Daniel Hooper\"\n            cell.authorImageView.image = UIImage(named: \"c\")\n            \n        } else {\n            cell.postImageView.image = UIImage(named: \"4\")\n            cell.postTitle.text = \"Seeking for signal\"\n            cell.postAuthor.text = \"Noby-Wan Kenobi\"\n            cell.authorImageView.image = UIImage(named: \"d\")\n            \n        }\n        \n        return cell\n    }\n}\n```\n这里每行能够正常展示了。Cell用了自定义的NewsTableViewCell:\n```Swift\nclass NewsTableViewCell: UITableViewCell {\n    @IBOutlet weak var postImageView:UIImageView!\n    @IBOutlet weak var postTitle:UILabel!\n    @IBOutlet weak var postAuthor:UILabel!\n    @IBOutlet weak var authorImageView:UIImageView!\n\n    override func awakeFromNib() {\n        super.awakeFromNib()\n        authorImageView.layer.cornerRadius = authorImageView.frame.width / 2\n        authorImageView.layer.masksToBounds = true\n    }\n\n    override func setSelected(_ selected: Bool, animated: Bool) {\n        super.setSelected(selected, animated: animated)\n\n        // Configure the view for the selected state\n    }\n}\n```\n具体布局还是故事版里面处理的布局。\n\n然后让首页也实现我们自定义的MenuTransitionManagerDelegate 转场代理吧：\n```Swift\nextension NewsTableViewController : MenuTransitionManagerDelegate {\n    func dismiss() {\n        dismiss(animated: true, completion: nil)\n    }\n}\n```\n这里猜测是点击空白区域，菜单dismiss吧。\n\n### 6.3 菜单控制器\n```Swift\nclass MenuTableViewController: BaseTableViewController {\n    var menuItems = [\"Everyday Moments\", \"Popular\", \"Editors\", \"Upcoming\", \"Fresh\", \"Stock-photos\", \"Trending\"]\n    var currentItem = \"Everyday Moments\"\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        self.view.backgroundColor = UIColor(red:0.109, green:0.114, blue:0.128, alpha:1)\n    }\n    \n    // 这里prepare去掉效果一样\n    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {\n        let menuTableViewController = segue.source as! MenuTableViewController\n        \n        if let selectedRow = menuTableViewController.tableView.indexPathForSelectedRow?.row {\n            currentItem = menuItems[selectedRow]\n        }\n    }\n}\n\nextension MenuTableViewController {\n    // MARK: UITableViewDataSource\n    override func numberOfSections(in tableView: UITableView) -> Int {\n        return 1\n    }\n    \n    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        return menuItems.count\n    }\n    \n    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n        let cell = tableView.dequeueReusableCell(withIdentifier: \"Cell\", for: indexPath) as! MenuTableViewCell\n        \n        cell.titleLabel.text = menuItems[indexPath.row]\n        cell.titleLabel.textColor = (menuItems[indexPath.row] == currentItem) ? UIColor.white : UIColor.gray\n        cell.backgroundColor = UIColor.clear\n        return cell\n    }\n}\n```\n这里实现了菜单列表显示。\n\n菜单Cell如下：\n```Swift\nclass MenuTableViewCell: UITableViewCell {\n\n    @IBOutlet weak var titleLabel:UILabel!\n    \n    override func awakeFromNib() {\n        super.awakeFromNib()\n        // Initialization code\n    }\n\n    override func setSelected(_ selected: Bool, animated: Bool) {\n        super.setSelected(selected, animated: animated)\n\n        // Configure the view for the selected state\n    }\n\n}\n```\n\n## 7 酷炫左右缩放菜单\n\n### 7.1 效果\n<img src=TumblrMenu.gif>\n\n### 7.2 首页\n```Swift\nclass MainViewController: BaseViewController {\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        self.navigationController?.isNavigationBarHidden = true\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n    \n    @IBAction func unwindToMainViewController (_ sender: UIStoryboardSegue){\n        self.dismiss(animated: true, completion: nil)\n    }\n}\n```\n这里的unwindToMainViewController 是我们自行在故事版拖进来的，这样子在这个控制器里面的点击事件也可以处理的。\n这里就是dismiss弹框。\n其它ui是我们自己拖到故事版里面的。\n\n### 7.3 菜单页\n菜单页是由一个UIVisualEffectView的父布局包裹的。\n这个故事版的Scene绑定的class为MenuViewController。\n```Swift\nclass MenuViewController: BaseViewController {\n    \n    let transitionManager = MenuTransitionManager()\n    \n    @IBOutlet weak var textButton: UIButton!\n    @IBOutlet weak var textLabel: UILabel!\n    \n    @IBOutlet weak var photoButton: UIButton!\n    @IBOutlet weak var photoLabel: UILabel!\n    \n    @IBOutlet weak var quoteButton: UIButton!\n    @IBOutlet weak var quoteLabel: UILabel!\n    \n    @IBOutlet weak var linkButton: UIButton!\n    @IBOutlet weak var linkLabel: UILabel!\n    \n    @IBOutlet weak var chatButton: UIButton!\n    @IBOutlet weak var chatLabel: UILabel!\n    \n    @IBOutlet weak var audioButton: UIButton!\n    @IBOutlet weak var audioLabel: UILabel!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        self.transitioningDelegate = self.transitionManager\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n}\n```\n这里声明了，布局效果在故事版里面拖动的。\n\n注意了这里self的transitiningDelegate设置了转场动画。\n\n也是我们自己定义的一个类：\n```Swift\n\nclass MenuTransitionManager: NSObject {\n\n    private var presenting = false\n\n    func offstage(_ amount: CGFloat) -> CGAffineTransform {\n        return CGAffineTransform(translationX: amount, y: 0)\n    }\n    \n    func offStageMenuController(_ menuViewController: MenuViewController) {\n        if !presenting{\n            menuViewController.view.alpha = 0\n        }\n        let topRowOffset  : CGFloat = 300\n        let middleRowOffset : CGFloat = 150\n        let bottomRowOffset  : CGFloat = 50\n        \n        menuViewController.textButton.transform = self.offstage(-topRowOffset)\n        menuViewController.textLabel.transform = self.offstage(-topRowOffset)\n        \n        menuViewController.quoteButton.transform = self.offstage(-middleRowOffset)\n        menuViewController.quoteLabel.transform = self.offstage(-middleRowOffset)\n        \n        menuViewController.chatButton.transform = self.offstage(-bottomRowOffset)\n        menuViewController.chatLabel.transform = self.offstage(-bottomRowOffset)\n        \n        menuViewController.photoButton.transform = self.offstage(topRowOffset)\n        menuViewController.photoLabel.transform = self.offstage(topRowOffset)\n        \n        menuViewController.linkButton.transform = self.offstage(middleRowOffset)\n        menuViewController.linkLabel.transform = self.offstage(middleRowOffset)\n        \n        menuViewController.audioButton.transform = self.offstage(bottomRowOffset)\n        menuViewController.audioLabel.transform = self.offstage(bottomRowOffset)\n        \n    }\n    \n    func onStageMenuController(_ menuViewController: MenuViewController) {\n        menuViewController.view.alpha = 1\n        \n        menuViewController.textButton.transform = .identity\n        menuViewController.textLabel.transform = .identity\n        menuViewController.quoteButton.transform = .identity\n        menuViewController.quoteLabel.transform = .identity\n        menuViewController.chatButton.transform = .identity\n        menuViewController.chatLabel.transform = .identity\n        menuViewController.photoButton.transform = .identity\n        menuViewController.photoLabel.transform = .identity\n        menuViewController.linkButton.transform = .identity\n        menuViewController.linkLabel.transform = .identity\n        menuViewController.audioButton.transform = .identity\n        menuViewController.audioLabel.transform = .identity\n        \n    }\n}\n```\n可以看到这里主要是针对里面控制器的ui的transform做了一些配置。\n\n然后这个管理员实现了UIViewControllerTransitioningDelegate代理：\n```Swift\nextension MenuTransitionManager : UIViewControllerTransitioningDelegate {\n    func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n        self.presenting = true\n        return self\n    }\n    \n    func animationController(forDismissed dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n        self.presenting = false\n        return self\n    }\n}\n```\n\n同样也实现了UIViewControllerAnimatedTransitioning这个协议：\n```Swift\nextension MenuTransitionManager : UIViewControllerAnimatedTransitioning {\n    \n    func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -> TimeInterval {\n        return 0.5\n    }\n    \n    func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {\n        let container = transitionContext.containerView\n        let screens: (from:UIViewController, to:UIViewController) = (transitionContext.viewController(forKey: .from)!, transitionContext.viewController(forKey: .to)!)\n        \n        let menuViewController = !self.presenting ? screens.from as! MenuViewController : screens.to as! MenuViewController\n        let bottomViewController = !self.presenting ? screens.to as UIViewController : screens.from as UIViewController\n        \n        let menuView: UIView! = menuViewController.view\n        let bottomView: UIView! = bottomViewController.view\n        \n        if (self.presenting) {\n             self.offStageMenuController(menuViewController)\n        }\n        container.addSubview(bottomView)\n        container.addSubview(menuView)\n        \n        let duration = self.transitionDuration(using: transitionContext)\n        \n        UIView.animate(withDuration: duration, delay: 0.0, usingSpringWithDamping: 0.7, initialSpringVelocity: 0.8, options: [], animations: {\n            if (self.presenting) {\n                 self.onStageMenuController(menuViewController)\n            } else {\n                self.offStageMenuController(menuViewController)\n            }\n        }, completion: { finished in\n            transitionContext.completeTransition(true)\n            UIApplication.shared.keyWindow!.addSubview(screens.to.view)\n        })\n    }\n}\n```\n主要是动画执行的时候，走了self.onStageMenuController方法或者self.offStageMenuController这个方法实现动画效果。\n\n## 8 限制字符串\n\n### 8.1 效果\n<img src=Limit.gif>\n\n### 8.2 UI\n这里也是先构造一个故事版。\n左上角：Close按钮。\n右上角：Tweet按钮。\n头像：Avatar Image VIew。\n底部View: 4个Button\n编辑框：UITextView\n\n<img src=18_1.png>\n\n控制器要用的：\n```Swift\nclass ViewController: UIViewController {\n\n    @IBOutlet weak var tweetTextView: UITextView!\n    @IBOutlet weak var bottomUIView: UIView!\n    @IBOutlet weak var avatarImageView: UIImageView!\n    @IBOutlet weak var characterCountLabel: UILabel!\n```\n\n初始化生命周期：\n```Swift\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        tweetTextView.delegate = self\n        avatarImageView.layer.cornerRadius = avatarImageView.frame.width / 2\n        tweetTextView.backgroundColor = UIColor.clear\n        \n        NotificationCenter.default.addObserver(self, selector:#selector(ViewController.keyBoardWillShow(_:)), name:UIResponder.keyboardWillShowNotification, object: nil)\n        NotificationCenter.default.addObserver(self, selector:#selector(ViewController.keyBoardWillHide(_:)), name:UIResponder.keyboardWillHideNotification, object: nil)\n    }\n```\n这里配置了UITextView的代理为自己，后面一定会实现相关方法的。\n\n然后这里监听了键盘显示和隐藏哦。\n主要是将底部的控制栏跟随键盘上下顶起来。\n\n```Swift\n@objc func keyBoardWillShow(_ note:NSNotification) {\n    let userInfo  = note.userInfo\n    let keyBoardBounds = (userInfo![UIResponder.keyboardFrameEndUserInfoKey] as! NSValue).cgRectValue\n    let duration = (userInfo![UIResponder.keyboardAnimationDurationUserInfoKey] as! NSNumber).doubleValue\n    let deltaY = keyBoardBounds.size.height\n    let animations = {\n        self.bottomUIView.transform = CGAffineTransform(translationX: 0, y: -deltaY)\n    }\n    \n    if duration > 0 {\n        // 莫名其妙的一段代码, 左移16位能看出来是个啥值吗\n        // let options = UIView.AnimationOptions(rawValue: UInt((userInfo![UIResponder.keyboardAnimationCurveUserInfoKey] as! NSNumber).intValue << 16))\n        UIView.animate(withDuration: duration, delay: 0, options:[.beginFromCurrentState, .curveLinear], animations: animations, completion: nil)\n    }else {\n        animations()\n    }\n}\n```\n上面的代码是为了在键盘弹出的时候，底部bottomUIView跟随键盘顶起来。\n\n```Swift\n@objc func keyBoardWillHide(_ note:NSNotification) {\n    let userInfo  = note.userInfo\n    let duration = (userInfo![UIResponder.keyboardAnimationDurationUserInfoKey] as! NSNumber).doubleValue\n    \n    let animations = {\n        self.bottomUIView.transform = .identity\n    }\n    \n    if duration > 0 {\n        // let options = UIView.AnimationOptions(rawValue: UInt((userInfo![UIResponder.keyboardAnimationCurveUserInfoKey] as! NSNumber).intValue << 16))\n        UIView.animate(withDuration: duration, delay: 0, options:[.beginFromCurrentState, .curveLinear], animations: animations, completion: nil)\n    }else{\n        animations()\n    }\n    \n}\n```\n上面的代码是为了在键盘隐藏的时候，底部bottomUIView也随之落下去。\n\n然后编辑框的代理如下：\n```Swift\nextension ViewController : UITextViewDelegate {\n    // MARK:UITextViewDelegate\n    func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {\n        let inputTextLength = text.count - range.length + tweetTextView.text.count\n        if inputTextLength > 140 {\n            return false\n        }\n        characterCountLabel.text = \"\\(140 - inputTextLength)\"\n        return true\n    }\n}\n```\n这里是为了统计当前剩余字符，如果不足，则无法继续输入。\n\n## 9 自定义下拉刷新\n\n### 9.1 效果\n<img src=CustomPullToRefresh.gif>\n\n### 9.2 变量定义\n```Swift\n    var refreshController: UIRefreshControl!\n    var customView: UIView!\n    var labelsArray: Array<UILabel> = []\n    var isAnimating = false\n    var currentColorIndex = 0\n    var currentLabelIndex = 0\n    var timer: Timer!\n    var dataArray: Array<String> = [\"😂\", \"🤗\", \"😳\", \"😌\", \"😊\"]\n```\n这里第一个就是刷新控制器了，应该主要就是往这里面加逻辑。\n\n### 9.3 初始化\n```Swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    \n    tblDemo.delegate = self\n    tblDemo.dataSource = self\n    refreshController = UIRefreshControl()\n    refreshController.backgroundColor = UIColor.clear\n    refreshController.tintColor = UIColor.clear\n    tblDemo.addSubview(refreshController)\n    \n    loadCustomRefreshContents()\n}\n```\n这里设置了代理和数据源，new了一个刷新控制器，清空背景，给tableView添加了一个子View。\n\n下面加载自定义xib文件：\n```Swift\n func loadCustomRefreshContents() {\n        \n    let refreshContents = Bundle.main.loadNibNamed(\"RefreshContents\", owner: self, options: nil)\n    \n    customView = refreshContents![0] as? UIView\n    customView.frame = refreshController.bounds\n    \n    for i in 0..<customView.subviews.count {\n        labelsArray.append(customView.viewWithTag(i + 1) as! UILabel)\n    }\n    \n    refreshController.addSubview(customView)\n}\n```\n这个布局里面主要是存放了我们自定义头部的View。\n\n### 9.4 数据源和代理\n```Swift\nextension ViewController : UITableViewDelegate {\n    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n        \n    }\n    \n    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n        return 80\n    }\n}\n\nextension ViewController : UITableViewDataSource {\n    \n    func numberOfSectionsInTableView(tableView: UITableView) -> Int {\n        return 1\n    }\n    \n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        return dataArray.count\n    }\n    \n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n        let cell = tableView.dequeueReusableCell(withIdentifier: \"idCell\", for: indexPath)\n        \n        cell.textLabel!.text = dataArray[indexPath.row]\n        cell.textLabel!.font = UIFont(name: \"Apple Color Emoji\", size: 40)\n        cell.textLabel!.textAlignment = .center\n        \n        return cell\n    }\n}\n```\n这里cell用默认的。\n\n### 9.5 下拉动画实现\n首先实现UIScrollViewDelegate代理：\n```Swift\nextension ViewController : UIScrollViewDelegate {\n    func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {\n        if refreshController.isRefreshing {\n            if !isAnimating {\n                doSomething()\n                animateRefreshStep1()\n            }\n        }\n    }\n}\n```\n如果没有在刷新中，没有在动画中，就做点失去，然后走动画第一步。\n\n```Swift \nfunc doSomething() {\n    timer = Timer.scheduledTimer(timeInterval: 5, target: self, selector: #selector(ViewController.endedOfWork), userInfo: nil, repeats: true)\n}\n```\n这里开启定时器，5s后才走endedofWork。\n```Swift\n@objc func endedOfWork() {\n    refreshController.endRefreshing()\n    timer.invalidate()\n    timer = nil\n}\n```\n这里停止刷新，定时器结束。\n说明上面的doSomething只是开启一个定时器，模拟进行网络请求，然后加载动画而已。\n\n动画第一步：\n```Swift\nfunc animateRefreshStep1() {\n    isAnimating = true\n    \n    UIView.animate(withDuration: 0.1, delay: 0.0, options: .curveLinear, animations: {\n        self.labelsArray[self.currentLabelIndex].transform = CGAffineTransform(rotationAngle: CGFloat(Double.pi/4))\n        self.labelsArray[self.currentLabelIndex].textColor = self.getNextColor()\n        }, completion: { _ in\n            UIView.animate(withDuration: 0.05, delay: 0.0, options: .curveLinear, animations: {\n                self.labelsArray[self.currentLabelIndex].transform = .identity\n                self.labelsArray[self.currentLabelIndex].textColor = UIColor.black\n                }, completion: { _ in\n                    self.currentLabelIndex += 1\n                    if self.currentLabelIndex < self.labelsArray.count {\n                        self.animateRefreshStep1()\n                    }else {\n                        self.animateRefreshStep2()\n                    }\n            })\n    })\n}\n\nfunc getNextColor() -> UIColor {\n    var colorsArray: Array<UIColor> = [.magenta, .brown, .yellow,\n                                        .red, .green, .blue, .orange]\n    if currentColorIndex == colorsArray.count {\n        currentColorIndex = 0\n    }\n    let returnColor = colorsArray[currentColorIndex]\n    currentColorIndex += 1\n    return returnColor\n}\n```\n这里开启动画了，给子View配置transform和textColor。\n递归走每一个子View动画，走完后走动画第二步：\n```Swift\nfunc animateRefreshStep2() {\n    UIView.animate(withDuration: 0.40, delay: 0.0, options: .curveLinear, animations: {\n        let scale = CGAffineTransform(scaleX: 1.5, y: 1.5)\n        self.labelsArray[1].transform = scale\n        self.labelsArray[2].transform = scale\n        self.labelsArray[3].transform = scale\n        self.labelsArray[4].transform = scale\n        self.labelsArray[5].transform = scale\n        self.labelsArray[6].transform = scale\n        self.labelsArray[7].transform = scale\n        self.labelsArray[8].transform = scale\n        self.labelsArray[9].transform = scale\n        self.labelsArray[10].transform = scale\n        self.labelsArray[11].transform = scale\n        \n        }, completion: { _ in\n            UIView.animate(withDuration: 0.25, delay: 0.0, options: .curveLinear, animations: {\n                self.labelsArray[0].transform = .identity\n                self.labelsArray[1].transform = .identity\n                self.labelsArray[2].transform = .identity\n                self.labelsArray[3].transform = .identity\n                self.labelsArray[4].transform = .identity\n                self.labelsArray[5].transform = .identity\n                self.labelsArray[6].transform = .identity\n                self.labelsArray[7].transform = .identity\n                self.labelsArray[8].transform = .identity\n                self.labelsArray[9].transform = .identity\n                self.labelsArray[10].transform = .identity\n                self.labelsArray[11].transform = .identity\n                \n                }, completion: { _ in\n                    if self.refreshController.isRefreshing {\n                        self.currentLabelIndex = 0\n                        self.animateRefreshStep1()\n                    } else {\n                        self.isAnimating = false\n                        self.currentLabelIndex = 0\n                        for i in 0 ..< self.labelsArray.count {\n                            self.labelsArray[i].textColor = UIColor.black\n                            self.labelsArray[i].transform = .identity\n                        }\n                    }\n            })\n    })\n}\n```\n\n## 10 CollectionView动画\n\n### 10.1 效果\n<img src=CollectionViewAnimation.gif>\n\n### 10.2 首页\nMain.storyboard里面放置了一个UICollectionView。\n\n里面放置了2个结构体：\n```Swift\nprivate struct Storyboard {\n    static let CellIdentifier = \"AnimationCollectionViewCell\"\n    static let NibName = \"AnimationCollectionViewCell\"\n}\n    \nprivate struct Constants {\n    static let AnimationDuration: Double = 0.5\n    static let AnimationDelay: Double = 0.0\n    static let AnimationSpringDamping: CGFloat = 1.0\n    static let AnimationInitialSpringVelocity: CGFloat = 1.0\n}\n```\n\n成员定义：\n```Swift\n@IBOutlet var testCollectionView: UICollectionView!\n\nvar imageCollection: AnimationImageCollection!\n```\n第一个是拖过来的，第二个是自定义的：\n```Swift\nstruct AnimationImageCollection {\n    private let imagePaths = [\"1\", \"2\", \"3\", \"4\", \"5\"]\n    var images: [AnimationCellModel]\n    \n    init() {\n        images = imagePaths.map { AnimationCellModel(imagePath: $0) }\n    }\n}\n```\n这个是一个结构体，里面的实体是这个：\n```Swift\nstruct AnimationCellModel {\n    let imagePath: String\n    \n    init(imagePath: String?) {\n        self.imagePath = imagePath ?? \"\"\n    }\n}\n```\n很简单，放置了一个图片路径而已。\n\n回到第一个控制器：\n```Swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    \n    imageCollection = AnimationImageCollection()\n    testCollectionView.register(UINib(nibName: Storyboard.NibName, bundle: nil), forCellWithReuseIdentifier: Storyboard.CellIdentifier)\n}\n```\n这里集合View注册了一个Cell，这个Cell是我们建立的xib文件，名称叫做AnimationCollectionViewCell.\n\n### 10.3 子item\n应该就是这个itemCell了，还是看下吧：\n```Swift\nclass AnimationCollectionViewCell: UICollectionViewCell {\n    \n    @IBOutlet weak var backButton: UIButton!\n    @IBOutlet weak var animationImageView: UIImageView!\n    @IBOutlet weak var animationTextView: UITextView!\n    \n    var backButtonTapped: (() -> Void)?\n    \n    func prepareCell(_ viewModel: AnimationCellModel) {\n        animationImageView.image = UIImage(named: viewModel.imagePath)\n        animationTextView.isScrollEnabled = false\n        backButton.isHidden = true\n        addTapEventHandler()\n    }\n    \n    func handleCellSelected() {\n        animationTextView.isScrollEnabled = false\n        backButton.isHidden = false\n        self.superview?.bringSubview(toFront: self)\n    }\n    \n    private func addTapEventHandler() {\n        backButton.addTarget(self, action: #selector(backButtonDidTouch(_:)), for: .touchUpInside)\n    }\n    \n    @objc func backButtonDidTouch(_ sender: UIGestureRecognizer) {\n        backButtonTapped?()\n    }\n}\n```\nitem布局就是返回按钮，图片，和文案。\n这个返回按钮默认应该是隐藏的，选中才给它显示。选中的时候走handleCellSelected方法，\n这里走了一个\n```\n  self.superview?.bringSubview(toFront: self)\n```\n这个作用应该就是把item移动到最前面了。\n\n```Swift\n private func addTapEventHandler() {\n    backButton.addTarget(self, action: #selector(backButtonDidTouch(_:)), for: .touchUpInside)\n}\n\n@objc func backButtonDidTouch(_ sender: UIGestureRecognizer) {\n    backButtonTapped?()\n}\n```\n这里将返回的点击事件暴露出去了。\n\n回调给首页里面了：\n```Swift\n// MARK: 按钮事件\nfunc backButtonDidTouch() {\n    guard let indexPaths = self.collectionView!.indexPathsForSelectedItems else {\n        return\n    }\n\n    collectionView!.isScrollEnabled = true\n    collectionView!.reloadItems(at: indexPaths)\n}\n```\n\n### 10.4 代理设置和数据绑定\n```Swift\n // MARK: UICollectionViewDataSource\noverride func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n    \n    guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: Storyboard.CellIdentifier, for: indexPath) as? AnimationCollectionViewCell,\n        let viewModel = imageCollection.images.safeIndex(indexPath.item) else {\n        return UICollectionViewCell()\n    }\n    // 这里是自己定义的方法哦\n    cell.prepareCell(viewModel)\n    return cell\n}\n\noverride func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {\n    return imageCollection.images.count\n}\n\n// MARK: UICollectionViewDelegate\noverride func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {\n    guard let cell = collectionView.cellForItem(at: indexPath) as? AnimationCollectionViewCell else {\n        return\n    }\n    \n    self.handleAnimationCellSelected(collectionView, cell: cell)\n}\n```\n这里选中的时候走了handleAnimationCellSelected这个方法，才实现动画效果的：\n```Swift\nprivate func handleAnimationCellSelected(_ collectionView: UICollectionView, cell: AnimationCollectionViewCell) {\n        \n    cell.handleCellSelected()\n    cell.backButtonTapped = self.backButtonDidTouch\n    \n    let animations = {\n        cell.frame = self.view.bounds\n    }\n\n    let completion: (_ finished: Bool) -> () = { _ in\n        collectionView.isScrollEnabled = false\n    }\n\n    UIView.animate(withDuration: Constants.AnimationDuration, delay: Constants.AnimationDelay, usingSpringWithDamping: Constants.AnimationSpringDamping, initialSpringVelocity: Constants.AnimationInitialSpringVelocity, options: [], animations: animations, completion: completion)\n}\n```\n动画主要是设置了cell的frame吧。\n\n\n## 11 总结\n* 1. 渐变TableView主要实现的是每个cell颜色不同，实现渐变效果，主要是在Cell里面定义了一个CAGradientlayer，在tableView的代理方法为willDisplay中给cell设置了背景色。背景色+渐变层实现了这种效果。\n\n* 2. 登录动画的实现方案，就是在视图将要可见，将左侧约束减掉视图宽度，然后已经可见再走UIView的动画函数，再恢复约束，实现动画效果。\n\n* 3. 列表动画，主要也是在将要可见的生命周期，遍历cell，修改cell的transform为CGAffineTransform，改变y值初始值为整个tableView的高度，然后动画设置恢复，从而实现进入动画效果。\n\n* 4. 游戏抽奖滚动动画，主要用了UIPickerView来实现。点击后设置pickerView的selectRow，开启动画效果，即可实现改效果。\n\n* 5. 启动动画，这里主要是加了一个蒙层，通过控制器的mask，设置未CALayer，然后将png镂空图标设置给mask的conents，然后可以通过CAKeyframeAnimation给mask设置动画，这样可以实现启动展开效果。\n\n* 6. 滑动菜单，主要是在prepare方法中，定义了场景的transitioningDelegate为自定义效果，通过扩展UIViewControllerAnimatedTransitioning的系统协议，在animateTransition方法里面加入我们自己定义好的动画，可以实现滑动菜单效果。\n\n* 7. 酷炫左右缩放菜单效果，跳转的逻辑可以在故事版里面写，这里只是菜单里面配置了一个自定义的transitioningDelegate得以实现，具体动画在UIViewControllerAnimatedTransitioning这个协议里面的animateTransition方法中处理，这里面可以拿到跳转的控制器，控制器可以再拿里面的ui。\n\n* 8. 限制字符串，这个比较简单，就是UITextView的用法，一个是监听键盘收起和弹出，给底部栏加动画，另一个是实现UITextViewDelegate，可以拿到当前长度。\n\n* 9. 自定义下拉刷新，主要是对UIRefreshControl做处理，这个控制器可以添加子View，子View可以通过Bundle.main.loadNibNamed加载xib文件。这样可以实现自定义下拉刷新效果。\n\n* 10. 列表转场动画，这个主要就是走didSelectItemAt的协议方法中，实现动画，关键逻辑就是cell.frame赋予self.view.bounds，相当于放大了cell，达成目标效果。\n\n\n\n\n\n\n\n\n\n","source":"_posts/iOS-swift-3天30个swift项目之第二天.md","raw":"---\ntitle: iOS swift 3天30个swift项目之第二天\ndate: 2023-02-04 09:49:09\nop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- 30个Swift项目\ncategories:\n- iOS\n---\n\n## 1 渐变TableView\n\n### 1.1 效果\n<img src=cleartableviewcell.gif>\n\n### 1.2 代码实现\n\n直接是继承了UITableViewController这个控制器，这个应该是自带了一个列表。内部有一个tableView。\n```\nclass ClearTableViewController: UITableViewController {\n```\n\n初始化：\n```Swift\noverride func viewDidLoad() {\n        super.viewDidLoad()\n\n        self.view.backgroundColor = UIColor.black\n        self.tableView.separatorStyle = UITableViewCellSeparatorStyle.none\n        self.tableView.tableFooterView = UIView(frame: CGRect.zero)\n        self.tableView.register(TableViewCell.self, forCellReuseIdentifier: \"tableCell\")        \n}\n```\n\n这里绑定了TableViewCell。\n```Swift\nclass TableViewCell: UITableViewCell {\n\n    let gradientLayer = CAGradientLayer()\n    \n    override func awakeFromNib() {\n        super.awakeFromNib()\n    }\n    \n    override func setSelected(_ selected: Bool, animated: Bool) {\n        super.setSelected(selected, animated: animated)\n    }\n    \n    override init(style: UITableViewCellStyle, reuseIdentifier: String?) {\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        \n        gradientLayer.frame = self.bounds\n        let color1 = UIColor(white: 1.0, alpha: 0.2).cgColor\n        let color2 = UIColor(white: 1.0, alpha: 0.1).cgColor\n        let color3 = UIColor.clear.cgColor\n        let color4 = UIColor(white: 0.0, alpha: 0.05).cgColor\n        \n        gradientLayer.colors = [color1, color2, color3, color4]\n        gradientLayer.locations = [0.0, 0.04, 0.95, 1.0]\n    }\n    \n    override func layoutSubviews() {\n        super.layoutSubviews()\n        gradientLayer.frame = self.bounds\n    }\n\n    required init?(coder aDecoder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n}\n```\n这里把UITableViewCell的bounds给到了一个渐变层CAGradientLayer。\n\n数据绑定：\n```Swift\n var tableData = [\"Read 3 article on Medium\", \"Cleanup bedroom\", \"Go for a run\", \"Hit the gym\", \"Build another swift project\", \"Movement training\", \"Fix the layout problem of a client project\", \"Write the experience of #30daysSwift\", \"Inbox Zero\", \"Booking the ticket to Chengdu\", \"Test the Adobe Project Comet\", \"Hop on a call to mom\"]\n```\n\n然后因为这个是UITableViewController，就无需重复设置代理了：\n```Swift\noverride func numberOfSections(in tableView: UITableView) -> Int {\n        return 1\n    }\n    \n    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        return tableData.count\n    }\n    \n    override func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n        return 60\n    }\n    \n    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n        \n        let cell = tableView.dequeueReusableCell(withIdentifier: \"tableCell\", for: indexPath) as! TableViewCell\n        \n        cell.textLabel?.text = tableData[indexPath.row]\n        cell.textLabel?.textColor = UIColor.white\n        cell.textLabel?.backgroundColor = UIColor.clear\n        cell.textLabel?.font = UIFont(name: \"Avenir Next\", size: 18)\n        cell.selectionStyle = UITableViewCellSelectionStyle.none\n        return cell\n    }\n    \n    override func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {\n        cell.backgroundColor = colorforIndex(index: indexPath.row)\n    }\n    \n    func colorforIndex(index: Int) -> UIColor {\n        \n        let itemCount = tableData.count - 1\n        let color = (CGFloat(index) / CGFloat(itemCount)) * 0.6\n        return UIColor(red: 1.0, green: color, blue: 0.0, alpha: 1.0)\n    }\n```\n重点实现下这几个代理方法即可。颜色设置主要是通过willDisplay这个方法设置进去了。\n\n## 2 登录动画\n\n### 2.1 效果\n<img src=simple%20login%20animation.gif>\n\n### 2.2 故事版关系\n<img src=21_1.png>\n这里是有两个场景Scene，每个Scene绑定了一个类，也就是左侧的两个Controller。\n这里学会了不用代码，直接用storyboard直接实现控制器的跳转。\n\n可以参考下这篇文章：[Xcode新建View Controller Scene并实现界面间跳转的方法](https://blog.csdn.net/Sherlooock/article/details/106825134)。\n\n### 2.3 启动页\n```Swift\nclass SplasViewController: UIViewController {\n    \n    @IBOutlet weak var signupButton: UIButton!\n    @IBOutlet weak var loginButton: UIButton!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        signupButton.layer.cornerRadius = 5\n        loginButton.layer.cornerRadius = 5 \n    }\n    \n    override var preferredStatusBarStyle: UIStatusBarStyle {\n        return UIStatusBarStyle.lightContent\n    }\n}\n这里设置了按钮圆角。\n```\n\n### 2.4 登录页\nUI定义：\n```Swift\n@IBOutlet weak var uesernameTextField: UITextField!\n@IBOutlet weak var passwordTextField: UITextField!\n\n@IBOutlet weak var centerAlignUsername: NSLayoutConstraint!\n@IBOutlet weak var centerAlignPassword: NSLayoutConstraint!\n\n@IBOutlet weak var loginButton: UIButton!\n```\n\n初始化：\n```Swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    \n    uesernameTextField.layer.cornerRadius = 5\n    passwordTextField.layer.cornerRadius = 5\n    uesernameTextField.delegate = self\n    passwordTextField.delegate = self\n    loginButton.layer.cornerRadius = 5\n}\n```\n这里设置编辑框代理，设置按钮圆角。\n\n将要显示：\n```Swift\noverride func viewWillAppear(_ animated: Bool) {\n    super.viewWillAppear(animated)\n    \n    centerAlignUsername.constant -= view.bounds.width\n    centerAlignPassword.constant -= view.bounds.width\n    loginButton.alpha = 0\n}\n```\n这里设置刚进页面x轴减去控件宽度，实现效果就是从左边滑出来。\n\n已经显示了：\n```Swift\noverride func viewDidAppear(_ animated: Bool) {\n    super.viewDidAppear(animated)\n    \n    UIView.animate(withDuration: 0.5, delay: 0.00, options: .curveEaseOut, animations: {\n        \n        self.centerAlignUsername.constant += self.view.bounds.width\n        self.view.layoutIfNeeded()\n    \n        }, completion: nil)\n    \n    UIView.animate(withDuration: 0.5, delay: 0.10, options: .curveEaseOut, animations: {\n        \n        self.centerAlignPassword.constant += self.view.bounds.width\n        self.view.layoutIfNeeded()\n        \n        }, completion: nil)\n    \n    UIView.animate(withDuration: 0.5, delay: 0.20, options: .curveEaseOut, animations: {\n        \n        self.loginButton.alpha = 1\n        \n        }, completion: nil)\n\n}\n```\n这是设置3个动画，将三个视图从左边滑出。\n\n## 3 列表动画\n\n### 3.1 效果\n<img src=AnimateTabel.gif>\n\n### 3.2 第一个列表\n初始化：\n```Swift\noverride func viewDidLoad() {\n    super.viewDidLoad()    \n    self.view.backgroundColor = UIColor.black\n    self.tableView.separatorStyle = UITableViewCellSeparatorStyle.none\n    self.tableView.tableFooterView = UIView(frame: CGRect.zero)\n    self.tableView.register(FirstTableCell.self, forCellReuseIdentifier: \"tableCell\")\n}\n```\n这里绑定了第一个Table的Cell：\n```Swift\nclass FirstTableCell: UITableViewCell {\n\n    let gradientLayer = CAGradientLayer()\n    \n    override func awakeFromNib() {\n        super.awakeFromNib()\n    }\n    \n    override func setSelected(_ selected: Bool, animated: Bool) {\n        super.setSelected(selected, animated: animated)\n    }\n    \n    \n    override init(style: UITableViewCellStyle, reuseIdentifier: String?) {\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        \n        gradientLayer.frame = self.bounds\n        let color1 = UIColor(white: 1.0, alpha: 0.2).cgColor as CGColor\n        let color2 = UIColor(white: 1.0, alpha: 0.1).cgColor as CGColor\n        let color3 = UIColor.clear.cgColor as CGColor\n        let color4 = UIColor(white: 0.0, alpha: 0.05).cgColor as CGColor\n        \n        gradientLayer.colors = [color1, color2, color3, color4]\n        gradientLayer.locations = [0.0, 0.04, 0.95, 1.0]\n        layer.insertSublayer(gradientLayer, at: 0)\n    }\n    \n    override func layoutSubviews() {\n        super.layoutSubviews()\n        gradientLayer.frame = self.bounds\n    }\n    \n    required init?(coder aDecoder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n}\n```\n这里跟前面类似，设置了渐变背景。通过layer层insertSublayer设置了渐变层实现。\n\n如何实现动画呢？\n继续看第一个控制器。\n\n将要的生命周期：\n```Swift\noverride func viewWillAppear(_ animated: Bool) {\n    animateTable()\n}\n\nfunc animateTable() {\n        self.tableView.reloadData()\n        let cells = tableView.visibleCells\n        let tableHeight: CGFloat = tableView.bounds.size.height\n        \n        for i in cells {\n            let cell: UITableViewCell = i as UITableViewCell\n            cell.transform = CGAffineTransform(translationX: 0, y: tableHeight)\n        }\n        \n        var index = 0\n        for a in cells {\n            \n            let cell: UITableViewCell = a as UITableViewCell\n            \n            UIView.animate(withDuration: 1.5, delay: 0.05 * Double(index), usingSpringWithDamping: 0.8, initialSpringVelocity: 0, options: [], animations: {\n                \n                cell.transform = CGAffineTransform(translationX: 0, y: 0);\n                \n            }, completion: nil)\n            \n            index += 1\n        }\n    }\n```\n这里一个设置了Cell的transform，第一个是从底部初始位置，第二个循环是恢复到目标位置。\n\n第一个table绑定的代理和数据源：\n```Swift\noverride func numberOfSections(in tableView: UITableView) -> Int {\n        return 1\n    }\n    \noverride func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n    return tableData.count\n}\n\noverride func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n    return 60\n}\n\noverride func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    \n    let cell = tableView.dequeueReusableCell(withIdentifier: \"tableCell\", for: indexPath)\n    \n    cell.textLabel?.text = tableData[indexPath.row]\n    cell.textLabel?.textColor = UIColor.white\n    cell.textLabel?.backgroundColor = UIColor.clear\n    cell.textLabel?.font = UIFont(name: \"Avenir Next\", size: 18)\n    cell.selectionStyle = UITableViewCellSelectionStyle.none\n    return cell\n}\n\noverride func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {\n    cell.backgroundColor =  colorforIndex(indexPath.row)\n}\n\noverride func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n    performSegue(withIdentifier: \"ShowAnimateTableViewController\", sender: nil)\n}\n\nfunc colorforIndex(_ index: Int) -> UIColor {\n    let itemCount = tableData.count - 1\n    let color = (CGFloat(index) / CGFloat(itemCount)) * 0.6\n    return UIColor(red: color, green: 0.0, blue: 1.0, alpha: 1.0)\n}\n```\n这里设置了渐变色，和前面一样。\n\n### 3.3 第2个列表\n\n继承UITableViewController:\n```Swift\nclass AnimateTableViewController: UITableViewController {\n```\n\n初始化：\n```Swift\n override func viewDidLoad() {\n    super.viewDidLoad()\n    \n    self.view.backgroundColor = UIColor.black\n    self.tableView.separatorStyle = UITableViewCellSeparatorStyle.none\n    self.tableView.tableFooterView = UIView(frame: CGRect.zero)\n    self.tableView.register(SecondTableCell.self, forCellReuseIdentifier: \"SecondTableCell\")\n}\n```\n\n将要显示：\n```Swift\noverride func viewWillAppear(_ animated: Bool) {\n    animateTable()\n}\n    \nfunc animateTable() {\n    \n    self.tableView.reloadData()\n    \n    let cells = tableView.visibleCells\n    let tableHeight: CGFloat = tableView.bounds.size.height\n    \n    for (index, cell) in cells.enumerated() {\n        cell.transform = CGAffineTransform(translationX: 0, y: tableHeight)\n        UIView.animate(withDuration: 1.0, delay: 0.05 * Double(index), usingSpringWithDamping: 0.8, initialSpringVelocity: 0, options: [], animations: {\n                cell.transform = CGAffineTransform(translationX: 0, y: 0);\n            }, completion: nil)\n    }\n}\n```\n这里设置了显示动画，从底部弹出效果。\n\n```Swift\noverride func numberOfSections(in tableView: UITableView) -> Int {\n        return 1\n    }\n    \noverride func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n    return tableData.count\n}\n\noverride func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n    return 60\n}\n\noverride func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    \n    let cell = tableView.dequeueReusableCell(withIdentifier: \"SecondTableCell\", for: indexPath)\n    \n    cell.textLabel?.text = tableData[indexPath.row]\n    cell.textLabel?.textColor = UIColor.white\n    cell.textLabel?.backgroundColor = UIColor.clear\n    cell.textLabel?.font = UIFont(name: \"Avenir Next\", size: 18)\n    cell.selectionStyle = UITableViewCellSelectionStyle.none\n    return cell\n    \n}\n\noverride func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {\n    cell.backgroundColor =  colorforIndex(indexPath.row)\n}\n\nfunc colorforIndex(_ index: Int) -> UIColor {\n    let itemCount = tableData.count - 1\n    let color = (CGFloat(index) / CGFloat(itemCount)) * 0.6\n    return UIColor(red: 1.0, green: color, blue: 0.0, alpha: 1.0)\n}\n```\n这里数据源绑定。还需要一个Cell支持下。\nSecondTableCell:\n```Swift\nclass SecondTableCell: UITableViewCell {\n    \n    let gradientLayer = CAGradientLayer()\n    \n    override func awakeFromNib() {\n        super.awakeFromNib()\n    }\n    \n    override func setSelected(_ selected: Bool, animated: Bool) {\n        super.setSelected(selected, animated: animated)\n    }\n\n    override init(style: UITableViewCellStyle, reuseIdentifier: String?) {\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        \n        gradientLayer.frame = self.bounds\n        let color1 = UIColor(white: 1.0, alpha: 0.2).cgColor as CGColor\n        let color2 = UIColor(white: 1.0, alpha: 0.1).cgColor as CGColor\n        let color3 = UIColor.clear.cgColor as CGColor\n        let color4 = UIColor(white: 0.0, alpha: 0.05).cgColor as CGColor\n        \n        gradientLayer.colors = [color1, color2, color3, color4]\n        gradientLayer.locations = [0.0, 0.04, 0.95, 1.0]\n        layer.insertSublayer(gradientLayer, at: 0)\n    }\n    \n    override func layoutSubviews() {\n        super.layoutSubviews()\n        gradientLayer.frame = self.bounds\n    }\n    \n    required init?(coder aDecoder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n}\n```\n这里和第一个Cell类似。\n\n## 4 游戏抽奖滚动图案\n\n### 4.1 效果\n<img src=emoji%20spin.gif>\n\n### 4.2 UI\n这里一个背景图片\ngo按钮\n中间是UIPickerView，有点像时间滚动条\n底部模式，结果文案。\n\n直接在故事版里面拖好了。\n\n然后拖动3个View到控制器：\n```Swift\nclass ViewController: UIViewController {\n\n    @IBOutlet weak var emojiPickerView: UIPickerView!\n    @IBOutlet weak var goButton: UIButton!\n    @IBOutlet weak var resultLabel: UILabel!\n```\n\n### 4.3 Data\n```Swift\n var imageArray = [String]()\n    var dataArray1 = [Int]()\n    var dataArray2 = [Int]()\n    var dataArray3 = [Int]()\n    var amazingFlag = false\n    var bounds: CGRect = CGRect.zero\n```\n变量声明，等下作为UIPickerView的数据。\n\n### 4.3 生命周期之viewDidLoad\n```Swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    \n    bounds = goButton.bounds\n    imageArray = [\"👻\",\"👸\",\"💩\",\"😘\",\"🍔\",\"🤖\",\"🍟\",\"🐼\",\"🚖\",\"🐷\"]\n    \n    for _ in 0...100 {\n        self.dataArray1.append((Int)(arc4random() % 10 ))\n        self.dataArray2.append((Int)(arc4random() % 10 ))\n        self.dataArray3.append((Int)(arc4random() % 10 ))\n    }\n    \n    resultLabel.text = \"\"\n    \n    emojiPickerView.delegate = self\n    emojiPickerView.dataSource = self\n    \n    goButton.layer.cornerRadius = 6\n    goButton.layer.masksToBounds = true\n}\n```\n这里生成长度为100的3个数组。本质上存放的0到9个数字。\n\n### 4.4 将要可见\n```Swift\noverride func viewWillAppear(_ animated: Bool) {\n    super.viewWillAppear(animated)\n    \n    goButton.alpha = 0   \n}\n```\n\n### 4.5 已经可见\n```Swift\noverride func viewDidAppear(_ animated: Bool) {\n    super.viewDidAppear(animated)\n    \n    UIView.animate(withDuration: 0.5, delay: 0.3, options: .curveEaseOut, animations: {\n        \n        self.goButton.alpha = 1\n        \n        }, completion: nil)\n}\n```\n底部按钮逐渐显示。\n\n### 4.6 点击事件\n```Swift\n@IBAction func amazingButtonDidTouch(_ sender: UIButton) {\n    amazingFlag = !amazingFlag;\n    sender.setTitle(amazingFlag ? \"开挂模式\":\"常规模式\", for: .normal)\n}\n\n@IBAction func goButtoDidTouch(_ sender: AnyObject) {\n    let index1: Int\n    let index2: Int\n    let index3: Int\n    if amazingFlag {\n        index1 = Int(arc4random()) % 90 + 3\n        index2 = dataArray2.firstIndex(of: dataArray1[index1])!\n        index3 = dataArray3.lastIndex(of: dataArray1[index1])!\n    } else {\n        index1 = Int(arc4random()) % 90 + 3\n        index2 = Int(arc4random()) % 90 + 3\n        index3 = Int(arc4random()) % 90 + 3\n    }\n    \n    /// 下次多少行，开启动画效果\n    emojiPickerView.selectRow(index1, inComponent: 0, animated: true)\n    emojiPickerView.selectRow(index2, inComponent: 1, animated: true)\n    emojiPickerView.selectRow(index3, inComponent: 2, animated: true)\n    \n    /// 结果显示\n    if(dataArray1[emojiPickerView.selectedRow(inComponent: 0)] == dataArray2[emojiPickerView.selectedRow(inComponent: 1)] && dataArray2[emojiPickerView.selectedRow(inComponent: 1)] == dataArray3[emojiPickerView.selectedRow(inComponent: 2)]) {\n        \n        resultLabel.text = \"Bingo!\"\n        \n    } else {\n        resultLabel.text = \"💔\"\n    }\n    \n    /// 底部Go抖动效果\n    UIView.animate(withDuration: 0.5, delay: 0.0, usingSpringWithDamping: 0.1, initialSpringVelocity: 5, options: .curveLinear, animations: {\n        \n        self.goButton.bounds = CGRect(x: self.bounds.origin.x, y: self.bounds.origin.y, width: self.bounds.size.width - 20, height: self.bounds.size.height)\n        \n    }, completion: { (compelete: Bool) in\n        \n        UIView.animate(withDuration: 0.1, delay: 0.0, options: UIViewAnimationOptions(), animations: {\n            \n            self.goButton.bounds = CGRect(x: self.bounds.origin.x, y: self.bounds.origin.y, width: self.bounds.size.width, height: self.bounds.size.height)\n            \n        }, completion: nil)\n        \n    })\n}\n```\n\n## 5 启动动画\n\n### 5.1 效果\n<img src=splash.gif>\n\n### 5.2 启动页\n启动页需要再info.plist中配置\n如下：\n<img src=25_1.png>\n\n这里我们在LaunchScreen.storyboard中设置了一个背景图片。\n这里面设置了一张白色的🕊没有效果哦。但是之前有，不知道为啥。\n\n### 5.3 首页\n首页其实加了一个同启动页的蓝色背景，中间减掉一个白鸽，然后白鸽再扩展的动画。\n这个背景是在故事版的View右侧属性里面的Background中设置的。\n\n设置蒙层：\n```Swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    // Do any additional setup after loading the view, typically from a nib.\n    \n    self.mask = CALayer()\n    self.mask!.contents = UIImage(named: \"twitter\")?.cgImage\n    self.mask!.contentsGravity = kCAGravityResizeAspect\n    self.mask!.bounds = CGRect(x: 0, y: 0, width: 100, height: 81)\n    self.mask!.anchorPoint = CGPoint(x: 0.5, y: 0.5)\n    self.imageView.setNeedsLayout()\n    self.imageView.layoutIfNeeded()\n    self.mask!.position = CGPoint(x: self.imageView.frame.size.width / 2, y: self.imageView.frame.size.height / 2)\n    self.imageView.layer.mask = mask\n    \n    animateMask()\n}\n```\n这里给到imageView的layer的mask，这样就相当于在蓝色背景中镂空可以看到里面的东西了。\n\n```Swift\nfunc animateMask() {\n    let keyFrameAnimation = CAKeyframeAnimation(keyPath: \"bounds\")\n    keyFrameAnimation.delegate = self\n    keyFrameAnimation.duration = 0.6\n    keyFrameAnimation.beginTime = CACurrentMediaTime() + 0.5\n    keyFrameAnimation.timingFunctions = [CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut), CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut)]\n    do {\n        // 动画需要加上这段代码，否则会造成页面闪一下\n        keyFrameAnimation.fillMode = kCAFillModeForwards\n        keyFrameAnimation.isRemovedOnCompletion = false\n    }\n    let initalBounds = NSValue(cgRect: mask!.bounds)\n    let secondBounds = NSValue(cgRect: CGRect(x: 0, y: 0, width: 90*0.9, height: 73*0.9))\n    let finalBounds = NSValue(cgRect: CGRect(x: 0, y: 0, width: 1600, height: 1300))\n    keyFrameAnimation.values = [initalBounds, secondBounds, finalBounds]\n    keyFrameAnimation.keyTimes = [0, 0.3, 1]\n    self.mask!.add(keyFrameAnimation, forKey: \"bounds\")\n}\n```\n这个动画的作用是将镂空效果爆炸，显示出主页面。\n\n动画停止后需要去除蒙层哦：\n```Swift\nextension ViewController : CAAnimationDelegate {\n    func animationDidStop(_ anim: CAAnimation, finished flag: Bool) {\n        self.imageView.layer.mask = nil\n    }\n}\n```\n动画结束，需要将蒙层去掉，不然屏幕上方会多出一块多余的遮挡视图。\n\n## 6 滑动菜单\n\n### 6.1 效果\n<img src=SlideMenu.gif>\n\n### 6.2 首页\n```Swift\nclass NewsTableViewController: BaseTableViewController {\n    let menuTransitionManager = MenuTransitionManager()\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        self.title = \"Everyday Moments\"\n        self.view.backgroundColor = UIColor(red:0.062, green:0.062, blue:0.07, alpha:1)\n    }\n    \n    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {\n        let menuTableViewController = segue.destination as! MenuTableViewController\n        menuTableViewController.currentItem = self.title!\n        menuTableViewController.transitioningDelegate = menuTransitionManager\n        menuTransitionManager.delegate = self\n    }\n}\n```\n这里有一个prepare方法，实际上是跳转到其它页面前会执行。\n我们在故事版里面定义了跳转关系，这里就可以通过prepare方法拿到跳转的目标控制器了。\n\n这是一个新闻的列表页。\n这里首先继承了BaseTableViewController:\n```Swift\nclass BaseTableViewController: UITableViewController {\n    \n    override var preferredStatusBarStyle: UIStatusBarStyle {\n        return UIStatusBarStyle.lightContent\n    }\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        self.tableView.separatorStyle = UITableViewCellSeparatorStyle.none\n    }\n}\n```\n\n然后这里有一个MenuTransitionManager,是我们自定义的一个类：\n个人猜测这个Transition相关的应该是为了实现一个转场动画，实现菜单能够丝滑地顶下来吧。\n里面放了一个自己定义的协议MenuTransitionManagerDelegate:\n```Swift\n@objc protocol MenuTransitionManagerDelegate {\n    func dismiss()\n}\n\nclass MenuTransitionManager: NSObject {\n    var duration = 0.5\n    var isPresenting = false\n    var delegate:MenuTransitionManagerDelegate?\n    var snapshot:UIView? {\n        didSet {\n            if let _delegate = delegate {\n                let tapGestureRecognizer = UITapGestureRecognizer(target: _delegate, action: #selector(MenuTransitionManagerDelegate.dismiss))\n                snapshot?.addGestureRecognizer(tapGestureRecognizer)\n            }\n        }\n    }\n}\n```\n\n然后扩展了一个UIViewControllerAnimatedTransitioning，\n这个应该是系统的协议：\n```Swift\nextension MenuTransitionManager : UIViewControllerAnimatedTransitioning {\n    func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -> TimeInterval {\n        return duration\n    }\n    \n    func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {\n        let fromView = transitionContext.view(forKey: .from)!\n        let toView = transitionContext.view(forKey: .to)!\n        let container = transitionContext.containerView\n        let moveLeft = CGAffineTransform(translationX: 250, y: 0)\n        let moveRight = CGAffineTransform(translationX: 0, y: 0)\n        \n        if isPresenting {\n            snapshot = fromView.snapshotView(afterScreenUpdates: true)\n            container.addSubview(toView)\n            container.addSubview(snapshot!)\n        }\n        \n        UIView.animate(withDuration: duration, delay: 0.0, usingSpringWithDamping: 0.9, initialSpringVelocity: 0.3, options: .curveEaseInOut, animations: {\n            if self.isPresenting {\n                self.snapshot?.transform = moveLeft\n                toView.transform = .identity\n            } else {\n                self.snapshot?.transform = .identity\n                fromView.transform = moveRight\n            }\n            \n        }, completion: { finished in\n            transitionContext.completeTransition(true)\n            if !self.isPresenting {\n                self.snapshot?.removeFromSuperview()\n            }\n        })\n    }\n}\n```\n同时也扩展了UIViewControllerTransitioningDelegate,也是系统的：\n```Swift\nextension MenuTransitionManager : UIViewControllerTransitioningDelegate {\n    func animationController(forDismissed dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n        isPresenting = false\n        return self\n    }\n    \n    func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n        isPresenting = true\n        return self\n    }\n}\n```\n\n再看下首页新闻展示的代理和数据源：\n```Swift\nextension NewsTableViewController {\n    // MARK: UITableViewDataSource\n    override func numberOfSections(in tableView: UITableView) -> Int {\n        return 3\n    }\n    \n    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        return 4\n    }\n    \n    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n        let cell = tableView.dequeueReusableCell(withIdentifier: \"Cell\", for: indexPath) as! NewsTableViewCell\n        cell.backgroundColor = UIColor.clear\n        \n        if indexPath.row == 0 {\n            cell.postImageView.image = UIImage(named: \"1\")\n            cell.postTitle.text = \"Love mountain.\"\n            cell.postAuthor.text = \"Allen Wang\"\n            cell.authorImageView.image = UIImage(named: \"a\")\n            \n        } else if indexPath.row == 1 {\n            cell.postImageView.image = UIImage(named: \"2\")\n            cell.postTitle.text = \"New graphic design - LIVE FREE\"\n            cell.postAuthor.text = \"Cole\"\n            cell.authorImageView.image = UIImage(named: \"b\")\n            \n        } else if indexPath.row == 2 {\n            cell.postImageView.image = UIImage(named: \"3\")\n            cell.postTitle.text = \"Summer sand\"\n            cell.postAuthor.text = \"Daniel Hooper\"\n            cell.authorImageView.image = UIImage(named: \"c\")\n            \n        } else {\n            cell.postImageView.image = UIImage(named: \"4\")\n            cell.postTitle.text = \"Seeking for signal\"\n            cell.postAuthor.text = \"Noby-Wan Kenobi\"\n            cell.authorImageView.image = UIImage(named: \"d\")\n            \n        }\n        \n        return cell\n    }\n}\n```\n这里每行能够正常展示了。Cell用了自定义的NewsTableViewCell:\n```Swift\nclass NewsTableViewCell: UITableViewCell {\n    @IBOutlet weak var postImageView:UIImageView!\n    @IBOutlet weak var postTitle:UILabel!\n    @IBOutlet weak var postAuthor:UILabel!\n    @IBOutlet weak var authorImageView:UIImageView!\n\n    override func awakeFromNib() {\n        super.awakeFromNib()\n        authorImageView.layer.cornerRadius = authorImageView.frame.width / 2\n        authorImageView.layer.masksToBounds = true\n    }\n\n    override func setSelected(_ selected: Bool, animated: Bool) {\n        super.setSelected(selected, animated: animated)\n\n        // Configure the view for the selected state\n    }\n}\n```\n具体布局还是故事版里面处理的布局。\n\n然后让首页也实现我们自定义的MenuTransitionManagerDelegate 转场代理吧：\n```Swift\nextension NewsTableViewController : MenuTransitionManagerDelegate {\n    func dismiss() {\n        dismiss(animated: true, completion: nil)\n    }\n}\n```\n这里猜测是点击空白区域，菜单dismiss吧。\n\n### 6.3 菜单控制器\n```Swift\nclass MenuTableViewController: BaseTableViewController {\n    var menuItems = [\"Everyday Moments\", \"Popular\", \"Editors\", \"Upcoming\", \"Fresh\", \"Stock-photos\", \"Trending\"]\n    var currentItem = \"Everyday Moments\"\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        self.view.backgroundColor = UIColor(red:0.109, green:0.114, blue:0.128, alpha:1)\n    }\n    \n    // 这里prepare去掉效果一样\n    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {\n        let menuTableViewController = segue.source as! MenuTableViewController\n        \n        if let selectedRow = menuTableViewController.tableView.indexPathForSelectedRow?.row {\n            currentItem = menuItems[selectedRow]\n        }\n    }\n}\n\nextension MenuTableViewController {\n    // MARK: UITableViewDataSource\n    override func numberOfSections(in tableView: UITableView) -> Int {\n        return 1\n    }\n    \n    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        return menuItems.count\n    }\n    \n    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n        let cell = tableView.dequeueReusableCell(withIdentifier: \"Cell\", for: indexPath) as! MenuTableViewCell\n        \n        cell.titleLabel.text = menuItems[indexPath.row]\n        cell.titleLabel.textColor = (menuItems[indexPath.row] == currentItem) ? UIColor.white : UIColor.gray\n        cell.backgroundColor = UIColor.clear\n        return cell\n    }\n}\n```\n这里实现了菜单列表显示。\n\n菜单Cell如下：\n```Swift\nclass MenuTableViewCell: UITableViewCell {\n\n    @IBOutlet weak var titleLabel:UILabel!\n    \n    override func awakeFromNib() {\n        super.awakeFromNib()\n        // Initialization code\n    }\n\n    override func setSelected(_ selected: Bool, animated: Bool) {\n        super.setSelected(selected, animated: animated)\n\n        // Configure the view for the selected state\n    }\n\n}\n```\n\n## 7 酷炫左右缩放菜单\n\n### 7.1 效果\n<img src=TumblrMenu.gif>\n\n### 7.2 首页\n```Swift\nclass MainViewController: BaseViewController {\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        self.navigationController?.isNavigationBarHidden = true\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n    \n    @IBAction func unwindToMainViewController (_ sender: UIStoryboardSegue){\n        self.dismiss(animated: true, completion: nil)\n    }\n}\n```\n这里的unwindToMainViewController 是我们自行在故事版拖进来的，这样子在这个控制器里面的点击事件也可以处理的。\n这里就是dismiss弹框。\n其它ui是我们自己拖到故事版里面的。\n\n### 7.3 菜单页\n菜单页是由一个UIVisualEffectView的父布局包裹的。\n这个故事版的Scene绑定的class为MenuViewController。\n```Swift\nclass MenuViewController: BaseViewController {\n    \n    let transitionManager = MenuTransitionManager()\n    \n    @IBOutlet weak var textButton: UIButton!\n    @IBOutlet weak var textLabel: UILabel!\n    \n    @IBOutlet weak var photoButton: UIButton!\n    @IBOutlet weak var photoLabel: UILabel!\n    \n    @IBOutlet weak var quoteButton: UIButton!\n    @IBOutlet weak var quoteLabel: UILabel!\n    \n    @IBOutlet weak var linkButton: UIButton!\n    @IBOutlet weak var linkLabel: UILabel!\n    \n    @IBOutlet weak var chatButton: UIButton!\n    @IBOutlet weak var chatLabel: UILabel!\n    \n    @IBOutlet weak var audioButton: UIButton!\n    @IBOutlet weak var audioLabel: UILabel!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        self.transitioningDelegate = self.transitionManager\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n}\n```\n这里声明了，布局效果在故事版里面拖动的。\n\n注意了这里self的transitiningDelegate设置了转场动画。\n\n也是我们自己定义的一个类：\n```Swift\n\nclass MenuTransitionManager: NSObject {\n\n    private var presenting = false\n\n    func offstage(_ amount: CGFloat) -> CGAffineTransform {\n        return CGAffineTransform(translationX: amount, y: 0)\n    }\n    \n    func offStageMenuController(_ menuViewController: MenuViewController) {\n        if !presenting{\n            menuViewController.view.alpha = 0\n        }\n        let topRowOffset  : CGFloat = 300\n        let middleRowOffset : CGFloat = 150\n        let bottomRowOffset  : CGFloat = 50\n        \n        menuViewController.textButton.transform = self.offstage(-topRowOffset)\n        menuViewController.textLabel.transform = self.offstage(-topRowOffset)\n        \n        menuViewController.quoteButton.transform = self.offstage(-middleRowOffset)\n        menuViewController.quoteLabel.transform = self.offstage(-middleRowOffset)\n        \n        menuViewController.chatButton.transform = self.offstage(-bottomRowOffset)\n        menuViewController.chatLabel.transform = self.offstage(-bottomRowOffset)\n        \n        menuViewController.photoButton.transform = self.offstage(topRowOffset)\n        menuViewController.photoLabel.transform = self.offstage(topRowOffset)\n        \n        menuViewController.linkButton.transform = self.offstage(middleRowOffset)\n        menuViewController.linkLabel.transform = self.offstage(middleRowOffset)\n        \n        menuViewController.audioButton.transform = self.offstage(bottomRowOffset)\n        menuViewController.audioLabel.transform = self.offstage(bottomRowOffset)\n        \n    }\n    \n    func onStageMenuController(_ menuViewController: MenuViewController) {\n        menuViewController.view.alpha = 1\n        \n        menuViewController.textButton.transform = .identity\n        menuViewController.textLabel.transform = .identity\n        menuViewController.quoteButton.transform = .identity\n        menuViewController.quoteLabel.transform = .identity\n        menuViewController.chatButton.transform = .identity\n        menuViewController.chatLabel.transform = .identity\n        menuViewController.photoButton.transform = .identity\n        menuViewController.photoLabel.transform = .identity\n        menuViewController.linkButton.transform = .identity\n        menuViewController.linkLabel.transform = .identity\n        menuViewController.audioButton.transform = .identity\n        menuViewController.audioLabel.transform = .identity\n        \n    }\n}\n```\n可以看到这里主要是针对里面控制器的ui的transform做了一些配置。\n\n然后这个管理员实现了UIViewControllerTransitioningDelegate代理：\n```Swift\nextension MenuTransitionManager : UIViewControllerTransitioningDelegate {\n    func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n        self.presenting = true\n        return self\n    }\n    \n    func animationController(forDismissed dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n        self.presenting = false\n        return self\n    }\n}\n```\n\n同样也实现了UIViewControllerAnimatedTransitioning这个协议：\n```Swift\nextension MenuTransitionManager : UIViewControllerAnimatedTransitioning {\n    \n    func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -> TimeInterval {\n        return 0.5\n    }\n    \n    func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {\n        let container = transitionContext.containerView\n        let screens: (from:UIViewController, to:UIViewController) = (transitionContext.viewController(forKey: .from)!, transitionContext.viewController(forKey: .to)!)\n        \n        let menuViewController = !self.presenting ? screens.from as! MenuViewController : screens.to as! MenuViewController\n        let bottomViewController = !self.presenting ? screens.to as UIViewController : screens.from as UIViewController\n        \n        let menuView: UIView! = menuViewController.view\n        let bottomView: UIView! = bottomViewController.view\n        \n        if (self.presenting) {\n             self.offStageMenuController(menuViewController)\n        }\n        container.addSubview(bottomView)\n        container.addSubview(menuView)\n        \n        let duration = self.transitionDuration(using: transitionContext)\n        \n        UIView.animate(withDuration: duration, delay: 0.0, usingSpringWithDamping: 0.7, initialSpringVelocity: 0.8, options: [], animations: {\n            if (self.presenting) {\n                 self.onStageMenuController(menuViewController)\n            } else {\n                self.offStageMenuController(menuViewController)\n            }\n        }, completion: { finished in\n            transitionContext.completeTransition(true)\n            UIApplication.shared.keyWindow!.addSubview(screens.to.view)\n        })\n    }\n}\n```\n主要是动画执行的时候，走了self.onStageMenuController方法或者self.offStageMenuController这个方法实现动画效果。\n\n## 8 限制字符串\n\n### 8.1 效果\n<img src=Limit.gif>\n\n### 8.2 UI\n这里也是先构造一个故事版。\n左上角：Close按钮。\n右上角：Tweet按钮。\n头像：Avatar Image VIew。\n底部View: 4个Button\n编辑框：UITextView\n\n<img src=18_1.png>\n\n控制器要用的：\n```Swift\nclass ViewController: UIViewController {\n\n    @IBOutlet weak var tweetTextView: UITextView!\n    @IBOutlet weak var bottomUIView: UIView!\n    @IBOutlet weak var avatarImageView: UIImageView!\n    @IBOutlet weak var characterCountLabel: UILabel!\n```\n\n初始化生命周期：\n```Swift\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        tweetTextView.delegate = self\n        avatarImageView.layer.cornerRadius = avatarImageView.frame.width / 2\n        tweetTextView.backgroundColor = UIColor.clear\n        \n        NotificationCenter.default.addObserver(self, selector:#selector(ViewController.keyBoardWillShow(_:)), name:UIResponder.keyboardWillShowNotification, object: nil)\n        NotificationCenter.default.addObserver(self, selector:#selector(ViewController.keyBoardWillHide(_:)), name:UIResponder.keyboardWillHideNotification, object: nil)\n    }\n```\n这里配置了UITextView的代理为自己，后面一定会实现相关方法的。\n\n然后这里监听了键盘显示和隐藏哦。\n主要是将底部的控制栏跟随键盘上下顶起来。\n\n```Swift\n@objc func keyBoardWillShow(_ note:NSNotification) {\n    let userInfo  = note.userInfo\n    let keyBoardBounds = (userInfo![UIResponder.keyboardFrameEndUserInfoKey] as! NSValue).cgRectValue\n    let duration = (userInfo![UIResponder.keyboardAnimationDurationUserInfoKey] as! NSNumber).doubleValue\n    let deltaY = keyBoardBounds.size.height\n    let animations = {\n        self.bottomUIView.transform = CGAffineTransform(translationX: 0, y: -deltaY)\n    }\n    \n    if duration > 0 {\n        // 莫名其妙的一段代码, 左移16位能看出来是个啥值吗\n        // let options = UIView.AnimationOptions(rawValue: UInt((userInfo![UIResponder.keyboardAnimationCurveUserInfoKey] as! NSNumber).intValue << 16))\n        UIView.animate(withDuration: duration, delay: 0, options:[.beginFromCurrentState, .curveLinear], animations: animations, completion: nil)\n    }else {\n        animations()\n    }\n}\n```\n上面的代码是为了在键盘弹出的时候，底部bottomUIView跟随键盘顶起来。\n\n```Swift\n@objc func keyBoardWillHide(_ note:NSNotification) {\n    let userInfo  = note.userInfo\n    let duration = (userInfo![UIResponder.keyboardAnimationDurationUserInfoKey] as! NSNumber).doubleValue\n    \n    let animations = {\n        self.bottomUIView.transform = .identity\n    }\n    \n    if duration > 0 {\n        // let options = UIView.AnimationOptions(rawValue: UInt((userInfo![UIResponder.keyboardAnimationCurveUserInfoKey] as! NSNumber).intValue << 16))\n        UIView.animate(withDuration: duration, delay: 0, options:[.beginFromCurrentState, .curveLinear], animations: animations, completion: nil)\n    }else{\n        animations()\n    }\n    \n}\n```\n上面的代码是为了在键盘隐藏的时候，底部bottomUIView也随之落下去。\n\n然后编辑框的代理如下：\n```Swift\nextension ViewController : UITextViewDelegate {\n    // MARK:UITextViewDelegate\n    func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {\n        let inputTextLength = text.count - range.length + tweetTextView.text.count\n        if inputTextLength > 140 {\n            return false\n        }\n        characterCountLabel.text = \"\\(140 - inputTextLength)\"\n        return true\n    }\n}\n```\n这里是为了统计当前剩余字符，如果不足，则无法继续输入。\n\n## 9 自定义下拉刷新\n\n### 9.1 效果\n<img src=CustomPullToRefresh.gif>\n\n### 9.2 变量定义\n```Swift\n    var refreshController: UIRefreshControl!\n    var customView: UIView!\n    var labelsArray: Array<UILabel> = []\n    var isAnimating = false\n    var currentColorIndex = 0\n    var currentLabelIndex = 0\n    var timer: Timer!\n    var dataArray: Array<String> = [\"😂\", \"🤗\", \"😳\", \"😌\", \"😊\"]\n```\n这里第一个就是刷新控制器了，应该主要就是往这里面加逻辑。\n\n### 9.3 初始化\n```Swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    \n    tblDemo.delegate = self\n    tblDemo.dataSource = self\n    refreshController = UIRefreshControl()\n    refreshController.backgroundColor = UIColor.clear\n    refreshController.tintColor = UIColor.clear\n    tblDemo.addSubview(refreshController)\n    \n    loadCustomRefreshContents()\n}\n```\n这里设置了代理和数据源，new了一个刷新控制器，清空背景，给tableView添加了一个子View。\n\n下面加载自定义xib文件：\n```Swift\n func loadCustomRefreshContents() {\n        \n    let refreshContents = Bundle.main.loadNibNamed(\"RefreshContents\", owner: self, options: nil)\n    \n    customView = refreshContents![0] as? UIView\n    customView.frame = refreshController.bounds\n    \n    for i in 0..<customView.subviews.count {\n        labelsArray.append(customView.viewWithTag(i + 1) as! UILabel)\n    }\n    \n    refreshController.addSubview(customView)\n}\n```\n这个布局里面主要是存放了我们自定义头部的View。\n\n### 9.4 数据源和代理\n```Swift\nextension ViewController : UITableViewDelegate {\n    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n        \n    }\n    \n    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n        return 80\n    }\n}\n\nextension ViewController : UITableViewDataSource {\n    \n    func numberOfSectionsInTableView(tableView: UITableView) -> Int {\n        return 1\n    }\n    \n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        return dataArray.count\n    }\n    \n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n        let cell = tableView.dequeueReusableCell(withIdentifier: \"idCell\", for: indexPath)\n        \n        cell.textLabel!.text = dataArray[indexPath.row]\n        cell.textLabel!.font = UIFont(name: \"Apple Color Emoji\", size: 40)\n        cell.textLabel!.textAlignment = .center\n        \n        return cell\n    }\n}\n```\n这里cell用默认的。\n\n### 9.5 下拉动画实现\n首先实现UIScrollViewDelegate代理：\n```Swift\nextension ViewController : UIScrollViewDelegate {\n    func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {\n        if refreshController.isRefreshing {\n            if !isAnimating {\n                doSomething()\n                animateRefreshStep1()\n            }\n        }\n    }\n}\n```\n如果没有在刷新中，没有在动画中，就做点失去，然后走动画第一步。\n\n```Swift \nfunc doSomething() {\n    timer = Timer.scheduledTimer(timeInterval: 5, target: self, selector: #selector(ViewController.endedOfWork), userInfo: nil, repeats: true)\n}\n```\n这里开启定时器，5s后才走endedofWork。\n```Swift\n@objc func endedOfWork() {\n    refreshController.endRefreshing()\n    timer.invalidate()\n    timer = nil\n}\n```\n这里停止刷新，定时器结束。\n说明上面的doSomething只是开启一个定时器，模拟进行网络请求，然后加载动画而已。\n\n动画第一步：\n```Swift\nfunc animateRefreshStep1() {\n    isAnimating = true\n    \n    UIView.animate(withDuration: 0.1, delay: 0.0, options: .curveLinear, animations: {\n        self.labelsArray[self.currentLabelIndex].transform = CGAffineTransform(rotationAngle: CGFloat(Double.pi/4))\n        self.labelsArray[self.currentLabelIndex].textColor = self.getNextColor()\n        }, completion: { _ in\n            UIView.animate(withDuration: 0.05, delay: 0.0, options: .curveLinear, animations: {\n                self.labelsArray[self.currentLabelIndex].transform = .identity\n                self.labelsArray[self.currentLabelIndex].textColor = UIColor.black\n                }, completion: { _ in\n                    self.currentLabelIndex += 1\n                    if self.currentLabelIndex < self.labelsArray.count {\n                        self.animateRefreshStep1()\n                    }else {\n                        self.animateRefreshStep2()\n                    }\n            })\n    })\n}\n\nfunc getNextColor() -> UIColor {\n    var colorsArray: Array<UIColor> = [.magenta, .brown, .yellow,\n                                        .red, .green, .blue, .orange]\n    if currentColorIndex == colorsArray.count {\n        currentColorIndex = 0\n    }\n    let returnColor = colorsArray[currentColorIndex]\n    currentColorIndex += 1\n    return returnColor\n}\n```\n这里开启动画了，给子View配置transform和textColor。\n递归走每一个子View动画，走完后走动画第二步：\n```Swift\nfunc animateRefreshStep2() {\n    UIView.animate(withDuration: 0.40, delay: 0.0, options: .curveLinear, animations: {\n        let scale = CGAffineTransform(scaleX: 1.5, y: 1.5)\n        self.labelsArray[1].transform = scale\n        self.labelsArray[2].transform = scale\n        self.labelsArray[3].transform = scale\n        self.labelsArray[4].transform = scale\n        self.labelsArray[5].transform = scale\n        self.labelsArray[6].transform = scale\n        self.labelsArray[7].transform = scale\n        self.labelsArray[8].transform = scale\n        self.labelsArray[9].transform = scale\n        self.labelsArray[10].transform = scale\n        self.labelsArray[11].transform = scale\n        \n        }, completion: { _ in\n            UIView.animate(withDuration: 0.25, delay: 0.0, options: .curveLinear, animations: {\n                self.labelsArray[0].transform = .identity\n                self.labelsArray[1].transform = .identity\n                self.labelsArray[2].transform = .identity\n                self.labelsArray[3].transform = .identity\n                self.labelsArray[4].transform = .identity\n                self.labelsArray[5].transform = .identity\n                self.labelsArray[6].transform = .identity\n                self.labelsArray[7].transform = .identity\n                self.labelsArray[8].transform = .identity\n                self.labelsArray[9].transform = .identity\n                self.labelsArray[10].transform = .identity\n                self.labelsArray[11].transform = .identity\n                \n                }, completion: { _ in\n                    if self.refreshController.isRefreshing {\n                        self.currentLabelIndex = 0\n                        self.animateRefreshStep1()\n                    } else {\n                        self.isAnimating = false\n                        self.currentLabelIndex = 0\n                        for i in 0 ..< self.labelsArray.count {\n                            self.labelsArray[i].textColor = UIColor.black\n                            self.labelsArray[i].transform = .identity\n                        }\n                    }\n            })\n    })\n}\n```\n\n## 10 CollectionView动画\n\n### 10.1 效果\n<img src=CollectionViewAnimation.gif>\n\n### 10.2 首页\nMain.storyboard里面放置了一个UICollectionView。\n\n里面放置了2个结构体：\n```Swift\nprivate struct Storyboard {\n    static let CellIdentifier = \"AnimationCollectionViewCell\"\n    static let NibName = \"AnimationCollectionViewCell\"\n}\n    \nprivate struct Constants {\n    static let AnimationDuration: Double = 0.5\n    static let AnimationDelay: Double = 0.0\n    static let AnimationSpringDamping: CGFloat = 1.0\n    static let AnimationInitialSpringVelocity: CGFloat = 1.0\n}\n```\n\n成员定义：\n```Swift\n@IBOutlet var testCollectionView: UICollectionView!\n\nvar imageCollection: AnimationImageCollection!\n```\n第一个是拖过来的，第二个是自定义的：\n```Swift\nstruct AnimationImageCollection {\n    private let imagePaths = [\"1\", \"2\", \"3\", \"4\", \"5\"]\n    var images: [AnimationCellModel]\n    \n    init() {\n        images = imagePaths.map { AnimationCellModel(imagePath: $0) }\n    }\n}\n```\n这个是一个结构体，里面的实体是这个：\n```Swift\nstruct AnimationCellModel {\n    let imagePath: String\n    \n    init(imagePath: String?) {\n        self.imagePath = imagePath ?? \"\"\n    }\n}\n```\n很简单，放置了一个图片路径而已。\n\n回到第一个控制器：\n```Swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    \n    imageCollection = AnimationImageCollection()\n    testCollectionView.register(UINib(nibName: Storyboard.NibName, bundle: nil), forCellWithReuseIdentifier: Storyboard.CellIdentifier)\n}\n```\n这里集合View注册了一个Cell，这个Cell是我们建立的xib文件，名称叫做AnimationCollectionViewCell.\n\n### 10.3 子item\n应该就是这个itemCell了，还是看下吧：\n```Swift\nclass AnimationCollectionViewCell: UICollectionViewCell {\n    \n    @IBOutlet weak var backButton: UIButton!\n    @IBOutlet weak var animationImageView: UIImageView!\n    @IBOutlet weak var animationTextView: UITextView!\n    \n    var backButtonTapped: (() -> Void)?\n    \n    func prepareCell(_ viewModel: AnimationCellModel) {\n        animationImageView.image = UIImage(named: viewModel.imagePath)\n        animationTextView.isScrollEnabled = false\n        backButton.isHidden = true\n        addTapEventHandler()\n    }\n    \n    func handleCellSelected() {\n        animationTextView.isScrollEnabled = false\n        backButton.isHidden = false\n        self.superview?.bringSubview(toFront: self)\n    }\n    \n    private func addTapEventHandler() {\n        backButton.addTarget(self, action: #selector(backButtonDidTouch(_:)), for: .touchUpInside)\n    }\n    \n    @objc func backButtonDidTouch(_ sender: UIGestureRecognizer) {\n        backButtonTapped?()\n    }\n}\n```\nitem布局就是返回按钮，图片，和文案。\n这个返回按钮默认应该是隐藏的，选中才给它显示。选中的时候走handleCellSelected方法，\n这里走了一个\n```\n  self.superview?.bringSubview(toFront: self)\n```\n这个作用应该就是把item移动到最前面了。\n\n```Swift\n private func addTapEventHandler() {\n    backButton.addTarget(self, action: #selector(backButtonDidTouch(_:)), for: .touchUpInside)\n}\n\n@objc func backButtonDidTouch(_ sender: UIGestureRecognizer) {\n    backButtonTapped?()\n}\n```\n这里将返回的点击事件暴露出去了。\n\n回调给首页里面了：\n```Swift\n// MARK: 按钮事件\nfunc backButtonDidTouch() {\n    guard let indexPaths = self.collectionView!.indexPathsForSelectedItems else {\n        return\n    }\n\n    collectionView!.isScrollEnabled = true\n    collectionView!.reloadItems(at: indexPaths)\n}\n```\n\n### 10.4 代理设置和数据绑定\n```Swift\n // MARK: UICollectionViewDataSource\noverride func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n    \n    guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: Storyboard.CellIdentifier, for: indexPath) as? AnimationCollectionViewCell,\n        let viewModel = imageCollection.images.safeIndex(indexPath.item) else {\n        return UICollectionViewCell()\n    }\n    // 这里是自己定义的方法哦\n    cell.prepareCell(viewModel)\n    return cell\n}\n\noverride func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {\n    return imageCollection.images.count\n}\n\n// MARK: UICollectionViewDelegate\noverride func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {\n    guard let cell = collectionView.cellForItem(at: indexPath) as? AnimationCollectionViewCell else {\n        return\n    }\n    \n    self.handleAnimationCellSelected(collectionView, cell: cell)\n}\n```\n这里选中的时候走了handleAnimationCellSelected这个方法，才实现动画效果的：\n```Swift\nprivate func handleAnimationCellSelected(_ collectionView: UICollectionView, cell: AnimationCollectionViewCell) {\n        \n    cell.handleCellSelected()\n    cell.backButtonTapped = self.backButtonDidTouch\n    \n    let animations = {\n        cell.frame = self.view.bounds\n    }\n\n    let completion: (_ finished: Bool) -> () = { _ in\n        collectionView.isScrollEnabled = false\n    }\n\n    UIView.animate(withDuration: Constants.AnimationDuration, delay: Constants.AnimationDelay, usingSpringWithDamping: Constants.AnimationSpringDamping, initialSpringVelocity: Constants.AnimationInitialSpringVelocity, options: [], animations: animations, completion: completion)\n}\n```\n动画主要是设置了cell的frame吧。\n\n\n## 11 总结\n* 1. 渐变TableView主要实现的是每个cell颜色不同，实现渐变效果，主要是在Cell里面定义了一个CAGradientlayer，在tableView的代理方法为willDisplay中给cell设置了背景色。背景色+渐变层实现了这种效果。\n\n* 2. 登录动画的实现方案，就是在视图将要可见，将左侧约束减掉视图宽度，然后已经可见再走UIView的动画函数，再恢复约束，实现动画效果。\n\n* 3. 列表动画，主要也是在将要可见的生命周期，遍历cell，修改cell的transform为CGAffineTransform，改变y值初始值为整个tableView的高度，然后动画设置恢复，从而实现进入动画效果。\n\n* 4. 游戏抽奖滚动动画，主要用了UIPickerView来实现。点击后设置pickerView的selectRow，开启动画效果，即可实现改效果。\n\n* 5. 启动动画，这里主要是加了一个蒙层，通过控制器的mask，设置未CALayer，然后将png镂空图标设置给mask的conents，然后可以通过CAKeyframeAnimation给mask设置动画，这样可以实现启动展开效果。\n\n* 6. 滑动菜单，主要是在prepare方法中，定义了场景的transitioningDelegate为自定义效果，通过扩展UIViewControllerAnimatedTransitioning的系统协议，在animateTransition方法里面加入我们自己定义好的动画，可以实现滑动菜单效果。\n\n* 7. 酷炫左右缩放菜单效果，跳转的逻辑可以在故事版里面写，这里只是菜单里面配置了一个自定义的transitioningDelegate得以实现，具体动画在UIViewControllerAnimatedTransitioning这个协议里面的animateTransition方法中处理，这里面可以拿到跳转的控制器，控制器可以再拿里面的ui。\n\n* 8. 限制字符串，这个比较简单，就是UITextView的用法，一个是监听键盘收起和弹出，给底部栏加动画，另一个是实现UITextViewDelegate，可以拿到当前长度。\n\n* 9. 自定义下拉刷新，主要是对UIRefreshControl做处理，这个控制器可以添加子View，子View可以通过Bundle.main.loadNibNamed加载xib文件。这样可以实现自定义下拉刷新效果。\n\n* 10. 列表转场动画，这个主要就是走didSelectItemAt的协议方法中，实现动画，关键逻辑就是cell.frame赋予self.view.bounds，相当于放大了cell，达成目标效果。\n\n\n\n\n\n\n\n\n\n","slug":"iOS-swift-3天30个swift项目之第二天","published":1,"updated":"2023-02-04T10:51:59.690Z","_id":"cldpu0pmm0000a0v73we29j2z","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-渐变TableView\"><a href=\"#1-渐变TableView\" class=\"headerlink\" title=\"1 渐变TableView\"></a>1 渐变TableView</h2><h3 id=\"1-1-效果\"><a href=\"#1-1-效果\" class=\"headerlink\" title=\"1.1 效果\"></a>1.1 效果</h3><img src=cleartableviewcell.gif>\n\n<h3 id=\"1-2-代码实现\"><a href=\"#1-2-代码实现\" class=\"headerlink\" title=\"1.2 代码实现\"></a>1.2 代码实现</h3><p>直接是继承了UITableViewController这个控制器，这个应该是自带了一个列表。内部有一个tableView。</p>\n<pre><code>class ClearTableViewController: UITableViewController &#123;\n</code></pre>\n<p>初始化：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n        super.viewDidLoad()\n\n        self.view.backgroundColor = UIColor.black\n        self.tableView.separatorStyle = UITableViewCellSeparatorStyle.none\n        self.tableView.tableFooterView = UIView(frame: CGRect.zero)\n        self.tableView.register(TableViewCell.self, forCellReuseIdentifier: &quot;tableCell&quot;)        \n&#125;\n</code></pre>\n<p>这里绑定了TableViewCell。</p>\n<pre><code class=\"line-numbers language-Swift\">class TableViewCell: UITableViewCell &#123;\n\n    let gradientLayer = CAGradientLayer()\n    \n    override func awakeFromNib() &#123;\n        super.awakeFromNib()\n    &#125;\n    \n    override func setSelected(_ selected: Bool, animated: Bool) &#123;\n        super.setSelected(selected, animated: animated)\n    &#125;\n    \n    override init(style: UITableViewCellStyle, reuseIdentifier: String?) &#123;\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        \n        gradientLayer.frame = self.bounds\n        let color1 = UIColor(white: 1.0, alpha: 0.2).cgColor\n        let color2 = UIColor(white: 1.0, alpha: 0.1).cgColor\n        let color3 = UIColor.clear.cgColor\n        let color4 = UIColor(white: 0.0, alpha: 0.05).cgColor\n        \n        gradientLayer.colors = [color1, color2, color3, color4]\n        gradientLayer.locations = [0.0, 0.04, 0.95, 1.0]\n    &#125;\n    \n    override func layoutSubviews() &#123;\n        super.layoutSubviews()\n        gradientLayer.frame = self.bounds\n    &#125;\n\n    required init?(coder aDecoder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n&#125;\n</code></pre>\n<p>这里把UITableViewCell的bounds给到了一个渐变层CAGradientLayer。</p>\n<p>数据绑定：</p>\n<pre><code class=\"line-numbers language-Swift\"> var tableData = [&quot;Read 3 article on Medium&quot;, &quot;Cleanup bedroom&quot;, &quot;Go for a run&quot;, &quot;Hit the gym&quot;, &quot;Build another swift project&quot;, &quot;Movement training&quot;, &quot;Fix the layout problem of a client project&quot;, &quot;Write the experience of #30daysSwift&quot;, &quot;Inbox Zero&quot;, &quot;Booking the ticket to Chengdu&quot;, &quot;Test the Adobe Project Comet&quot;, &quot;Hop on a call to mom&quot;]\n</code></pre>\n<p>然后因为这个是UITableViewController，就无需重复设置代理了：</p>\n<pre><code class=\"line-numbers language-Swift\">override func numberOfSections(in tableView: UITableView) -&gt; Int &#123;\n        return 1\n    &#125;\n    \n    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n        return tableData.count\n    &#125;\n    \n    override func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n        return 60\n    &#125;\n    \n    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n        \n        let cell = tableView.dequeueReusableCell(withIdentifier: &quot;tableCell&quot;, for: indexPath) as! TableViewCell\n        \n        cell.textLabel?.text = tableData[indexPath.row]\n        cell.textLabel?.textColor = UIColor.white\n        cell.textLabel?.backgroundColor = UIColor.clear\n        cell.textLabel?.font = UIFont(name: &quot;Avenir Next&quot;, size: 18)\n        cell.selectionStyle = UITableViewCellSelectionStyle.none\n        return cell\n    &#125;\n    \n    override func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) &#123;\n        cell.backgroundColor = colorforIndex(index: indexPath.row)\n    &#125;\n    \n    func colorforIndex(index: Int) -&gt; UIColor &#123;\n        \n        let itemCount = tableData.count - 1\n        let color = (CGFloat(index) / CGFloat(itemCount)) * 0.6\n        return UIColor(red: 1.0, green: color, blue: 0.0, alpha: 1.0)\n    &#125;\n</code></pre>\n<p>重点实现下这几个代理方法即可。颜色设置主要是通过willDisplay这个方法设置进去了。</p>\n<h2 id=\"2-登录动画\"><a href=\"#2-登录动画\" class=\"headerlink\" title=\"2 登录动画\"></a>2 登录动画</h2><h3 id=\"2-1-效果\"><a href=\"#2-1-效果\" class=\"headerlink\" title=\"2.1 效果\"></a>2.1 效果</h3><img src=simple%20login%20animation.gif>\n\n<h3 id=\"2-2-故事版关系\"><a href=\"#2-2-故事版关系\" class=\"headerlink\" title=\"2.2 故事版关系\"></a>2.2 故事版关系</h3><img src=21_1.png>\n这里是有两个场景Scene，每个Scene绑定了一个类，也就是左侧的两个Controller。\n这里学会了不用代码，直接用storyboard直接实现控制器的跳转。\n\n<p>可以参考下这篇文章：<a href=\"https://blog.csdn.net/Sherlooock/article/details/106825134\">Xcode新建View Controller Scene并实现界面间跳转的方法</a>。</p>\n<h3 id=\"2-3-启动页\"><a href=\"#2-3-启动页\" class=\"headerlink\" title=\"2.3 启动页\"></a>2.3 启动页</h3><pre><code class=\"line-numbers language-Swift\">class SplasViewController: UIViewController &#123;\n    \n    @IBOutlet weak var signupButton: UIButton!\n    @IBOutlet weak var loginButton: UIButton!\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        \n        signupButton.layer.cornerRadius = 5\n        loginButton.layer.cornerRadius = 5 \n    &#125;\n    \n    override var preferredStatusBarStyle: UIStatusBarStyle &#123;\n        return UIStatusBarStyle.lightContent\n    &#125;\n&#125;\n这里设置了按钮圆角。\n</code></pre>\n<h3 id=\"2-4-登录页\"><a href=\"#2-4-登录页\" class=\"headerlink\" title=\"2.4 登录页\"></a>2.4 登录页</h3><p>UI定义：</p>\n<pre><code class=\"line-numbers language-Swift\">@IBOutlet weak var uesernameTextField: UITextField!\n@IBOutlet weak var passwordTextField: UITextField!\n\n@IBOutlet weak var centerAlignUsername: NSLayoutConstraint!\n@IBOutlet weak var centerAlignPassword: NSLayoutConstraint!\n\n@IBOutlet weak var loginButton: UIButton!\n</code></pre>\n<p>初始化：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n    super.viewDidLoad()\n    \n    uesernameTextField.layer.cornerRadius = 5\n    passwordTextField.layer.cornerRadius = 5\n    uesernameTextField.delegate = self\n    passwordTextField.delegate = self\n    loginButton.layer.cornerRadius = 5\n&#125;\n</code></pre>\n<p>这里设置编辑框代理，设置按钮圆角。</p>\n<p>将要显示：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewWillAppear(_ animated: Bool) &#123;\n    super.viewWillAppear(animated)\n    \n    centerAlignUsername.constant -= view.bounds.width\n    centerAlignPassword.constant -= view.bounds.width\n    loginButton.alpha = 0\n&#125;\n</code></pre>\n<p>这里设置刚进页面x轴减去控件宽度，实现效果就是从左边滑出来。</p>\n<p>已经显示了：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidAppear(_ animated: Bool) &#123;\n    super.viewDidAppear(animated)\n    \n    UIView.animate(withDuration: 0.5, delay: 0.00, options: .curveEaseOut, animations: &#123;\n        \n        self.centerAlignUsername.constant += self.view.bounds.width\n        self.view.layoutIfNeeded()\n    \n        &#125;, completion: nil)\n    \n    UIView.animate(withDuration: 0.5, delay: 0.10, options: .curveEaseOut, animations: &#123;\n        \n        self.centerAlignPassword.constant += self.view.bounds.width\n        self.view.layoutIfNeeded()\n        \n        &#125;, completion: nil)\n    \n    UIView.animate(withDuration: 0.5, delay: 0.20, options: .curveEaseOut, animations: &#123;\n        \n        self.loginButton.alpha = 1\n        \n        &#125;, completion: nil)\n\n&#125;\n</code></pre>\n<p>这是设置3个动画，将三个视图从左边滑出。</p>\n<h2 id=\"3-列表动画\"><a href=\"#3-列表动画\" class=\"headerlink\" title=\"3 列表动画\"></a>3 列表动画</h2><h3 id=\"3-1-效果\"><a href=\"#3-1-效果\" class=\"headerlink\" title=\"3.1 效果\"></a>3.1 效果</h3><img src=AnimateTabel.gif>\n\n<h3 id=\"3-2-第一个列表\"><a href=\"#3-2-第一个列表\" class=\"headerlink\" title=\"3.2 第一个列表\"></a>3.2 第一个列表</h3><p>初始化：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n    super.viewDidLoad()    \n    self.view.backgroundColor = UIColor.black\n    self.tableView.separatorStyle = UITableViewCellSeparatorStyle.none\n    self.tableView.tableFooterView = UIView(frame: CGRect.zero)\n    self.tableView.register(FirstTableCell.self, forCellReuseIdentifier: &quot;tableCell&quot;)\n&#125;\n</code></pre>\n<p>这里绑定了第一个Table的Cell：</p>\n<pre><code class=\"line-numbers language-Swift\">class FirstTableCell: UITableViewCell &#123;\n\n    let gradientLayer = CAGradientLayer()\n    \n    override func awakeFromNib() &#123;\n        super.awakeFromNib()\n    &#125;\n    \n    override func setSelected(_ selected: Bool, animated: Bool) &#123;\n        super.setSelected(selected, animated: animated)\n    &#125;\n    \n    \n    override init(style: UITableViewCellStyle, reuseIdentifier: String?) &#123;\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        \n        gradientLayer.frame = self.bounds\n        let color1 = UIColor(white: 1.0, alpha: 0.2).cgColor as CGColor\n        let color2 = UIColor(white: 1.0, alpha: 0.1).cgColor as CGColor\n        let color3 = UIColor.clear.cgColor as CGColor\n        let color4 = UIColor(white: 0.0, alpha: 0.05).cgColor as CGColor\n        \n        gradientLayer.colors = [color1, color2, color3, color4]\n        gradientLayer.locations = [0.0, 0.04, 0.95, 1.0]\n        layer.insertSublayer(gradientLayer, at: 0)\n    &#125;\n    \n    override func layoutSubviews() &#123;\n        super.layoutSubviews()\n        gradientLayer.frame = self.bounds\n    &#125;\n    \n    required init?(coder aDecoder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n&#125;\n</code></pre>\n<p>这里跟前面类似，设置了渐变背景。通过layer层insertSublayer设置了渐变层实现。</p>\n<p>如何实现动画呢？<br>继续看第一个控制器。</p>\n<p>将要的生命周期：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewWillAppear(_ animated: Bool) &#123;\n    animateTable()\n&#125;\n\nfunc animateTable() &#123;\n        self.tableView.reloadData()\n        let cells = tableView.visibleCells\n        let tableHeight: CGFloat = tableView.bounds.size.height\n        \n        for i in cells &#123;\n            let cell: UITableViewCell = i as UITableViewCell\n            cell.transform = CGAffineTransform(translationX: 0, y: tableHeight)\n        &#125;\n        \n        var index = 0\n        for a in cells &#123;\n            \n            let cell: UITableViewCell = a as UITableViewCell\n            \n            UIView.animate(withDuration: 1.5, delay: 0.05 * Double(index), usingSpringWithDamping: 0.8, initialSpringVelocity: 0, options: [], animations: &#123;\n                \n                cell.transform = CGAffineTransform(translationX: 0, y: 0);\n                \n            &#125;, completion: nil)\n            \n            index += 1\n        &#125;\n    &#125;\n</code></pre>\n<p>这里一个设置了Cell的transform，第一个是从底部初始位置，第二个循环是恢复到目标位置。</p>\n<p>第一个table绑定的代理和数据源：</p>\n<pre><code class=\"line-numbers language-Swift\">override func numberOfSections(in tableView: UITableView) -&gt; Int &#123;\n        return 1\n    &#125;\n    \noverride func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n    return tableData.count\n&#125;\n\noverride func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n    return 60\n&#125;\n\noverride func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n    \n    let cell = tableView.dequeueReusableCell(withIdentifier: &quot;tableCell&quot;, for: indexPath)\n    \n    cell.textLabel?.text = tableData[indexPath.row]\n    cell.textLabel?.textColor = UIColor.white\n    cell.textLabel?.backgroundColor = UIColor.clear\n    cell.textLabel?.font = UIFont(name: &quot;Avenir Next&quot;, size: 18)\n    cell.selectionStyle = UITableViewCellSelectionStyle.none\n    return cell\n&#125;\n\noverride func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) &#123;\n    cell.backgroundColor =  colorforIndex(indexPath.row)\n&#125;\n\noverride func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123;\n    performSegue(withIdentifier: &quot;ShowAnimateTableViewController&quot;, sender: nil)\n&#125;\n\nfunc colorforIndex(_ index: Int) -&gt; UIColor &#123;\n    let itemCount = tableData.count - 1\n    let color = (CGFloat(index) / CGFloat(itemCount)) * 0.6\n    return UIColor(red: color, green: 0.0, blue: 1.0, alpha: 1.0)\n&#125;\n</code></pre>\n<p>这里设置了渐变色，和前面一样。</p>\n<h3 id=\"3-3-第2个列表\"><a href=\"#3-3-第2个列表\" class=\"headerlink\" title=\"3.3 第2个列表\"></a>3.3 第2个列表</h3><p>继承UITableViewController:</p>\n<pre><code class=\"line-numbers language-Swift\">class AnimateTableViewController: UITableViewController &#123;\n</code></pre>\n<p>初始化：</p>\n<pre><code class=\"line-numbers language-Swift\"> override func viewDidLoad() &#123;\n    super.viewDidLoad()\n    \n    self.view.backgroundColor = UIColor.black\n    self.tableView.separatorStyle = UITableViewCellSeparatorStyle.none\n    self.tableView.tableFooterView = UIView(frame: CGRect.zero)\n    self.tableView.register(SecondTableCell.self, forCellReuseIdentifier: &quot;SecondTableCell&quot;)\n&#125;\n</code></pre>\n<p>将要显示：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewWillAppear(_ animated: Bool) &#123;\n    animateTable()\n&#125;\n    \nfunc animateTable() &#123;\n    \n    self.tableView.reloadData()\n    \n    let cells = tableView.visibleCells\n    let tableHeight: CGFloat = tableView.bounds.size.height\n    \n    for (index, cell) in cells.enumerated() &#123;\n        cell.transform = CGAffineTransform(translationX: 0, y: tableHeight)\n        UIView.animate(withDuration: 1.0, delay: 0.05 * Double(index), usingSpringWithDamping: 0.8, initialSpringVelocity: 0, options: [], animations: &#123;\n                cell.transform = CGAffineTransform(translationX: 0, y: 0);\n            &#125;, completion: nil)\n    &#125;\n&#125;\n</code></pre>\n<p>这里设置了显示动画，从底部弹出效果。</p>\n<pre><code class=\"line-numbers language-Swift\">override func numberOfSections(in tableView: UITableView) -&gt; Int &#123;\n        return 1\n    &#125;\n    \noverride func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n    return tableData.count\n&#125;\n\noverride func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n    return 60\n&#125;\n\noverride func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n    \n    let cell = tableView.dequeueReusableCell(withIdentifier: &quot;SecondTableCell&quot;, for: indexPath)\n    \n    cell.textLabel?.text = tableData[indexPath.row]\n    cell.textLabel?.textColor = UIColor.white\n    cell.textLabel?.backgroundColor = UIColor.clear\n    cell.textLabel?.font = UIFont(name: &quot;Avenir Next&quot;, size: 18)\n    cell.selectionStyle = UITableViewCellSelectionStyle.none\n    return cell\n    \n&#125;\n\noverride func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) &#123;\n    cell.backgroundColor =  colorforIndex(indexPath.row)\n&#125;\n\nfunc colorforIndex(_ index: Int) -&gt; UIColor &#123;\n    let itemCount = tableData.count - 1\n    let color = (CGFloat(index) / CGFloat(itemCount)) * 0.6\n    return UIColor(red: 1.0, green: color, blue: 0.0, alpha: 1.0)\n&#125;\n</code></pre>\n<p>这里数据源绑定。还需要一个Cell支持下。<br>SecondTableCell:</p>\n<pre><code class=\"line-numbers language-Swift\">class SecondTableCell: UITableViewCell &#123;\n    \n    let gradientLayer = CAGradientLayer()\n    \n    override func awakeFromNib() &#123;\n        super.awakeFromNib()\n    &#125;\n    \n    override func setSelected(_ selected: Bool, animated: Bool) &#123;\n        super.setSelected(selected, animated: animated)\n    &#125;\n\n    override init(style: UITableViewCellStyle, reuseIdentifier: String?) &#123;\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        \n        gradientLayer.frame = self.bounds\n        let color1 = UIColor(white: 1.0, alpha: 0.2).cgColor as CGColor\n        let color2 = UIColor(white: 1.0, alpha: 0.1).cgColor as CGColor\n        let color3 = UIColor.clear.cgColor as CGColor\n        let color4 = UIColor(white: 0.0, alpha: 0.05).cgColor as CGColor\n        \n        gradientLayer.colors = [color1, color2, color3, color4]\n        gradientLayer.locations = [0.0, 0.04, 0.95, 1.0]\n        layer.insertSublayer(gradientLayer, at: 0)\n    &#125;\n    \n    override func layoutSubviews() &#123;\n        super.layoutSubviews()\n        gradientLayer.frame = self.bounds\n    &#125;\n    \n    required init?(coder aDecoder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n&#125;\n</code></pre>\n<p>这里和第一个Cell类似。</p>\n<h2 id=\"4-游戏抽奖滚动图案\"><a href=\"#4-游戏抽奖滚动图案\" class=\"headerlink\" title=\"4 游戏抽奖滚动图案\"></a>4 游戏抽奖滚动图案</h2><h3 id=\"4-1-效果\"><a href=\"#4-1-效果\" class=\"headerlink\" title=\"4.1 效果\"></a>4.1 效果</h3><img src=emoji%20spin.gif>\n\n<h3 id=\"4-2-UI\"><a href=\"#4-2-UI\" class=\"headerlink\" title=\"4.2 UI\"></a>4.2 UI</h3><p>这里一个背景图片<br>go按钮<br>中间是UIPickerView，有点像时间滚动条<br>底部模式，结果文案。</p>\n<p>直接在故事版里面拖好了。</p>\n<p>然后拖动3个View到控制器：</p>\n<pre><code class=\"line-numbers language-Swift\">class ViewController: UIViewController &#123;\n\n    @IBOutlet weak var emojiPickerView: UIPickerView!\n    @IBOutlet weak var goButton: UIButton!\n    @IBOutlet weak var resultLabel: UILabel!\n</code></pre>\n<h3 id=\"4-3-Data\"><a href=\"#4-3-Data\" class=\"headerlink\" title=\"4.3 Data\"></a>4.3 Data</h3><pre><code class=\"line-numbers language-Swift\"> var imageArray = [String]()\n    var dataArray1 = [Int]()\n    var dataArray2 = [Int]()\n    var dataArray3 = [Int]()\n    var amazingFlag = false\n    var bounds: CGRect = CGRect.zero\n</code></pre>\n<p>变量声明，等下作为UIPickerView的数据。</p>\n<h3 id=\"4-3-生命周期之viewDidLoad\"><a href=\"#4-3-生命周期之viewDidLoad\" class=\"headerlink\" title=\"4.3 生命周期之viewDidLoad\"></a>4.3 生命周期之viewDidLoad</h3><pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n    super.viewDidLoad()\n    \n    bounds = goButton.bounds\n    imageArray = [&quot;👻&quot;,&quot;👸&quot;,&quot;💩&quot;,&quot;😘&quot;,&quot;🍔&quot;,&quot;🤖&quot;,&quot;🍟&quot;,&quot;🐼&quot;,&quot;🚖&quot;,&quot;🐷&quot;]\n    \n    for _ in 0...100 &#123;\n        self.dataArray1.append((Int)(arc4random() % 10 ))\n        self.dataArray2.append((Int)(arc4random() % 10 ))\n        self.dataArray3.append((Int)(arc4random() % 10 ))\n    &#125;\n    \n    resultLabel.text = &quot;&quot;\n    \n    emojiPickerView.delegate = self\n    emojiPickerView.dataSource = self\n    \n    goButton.layer.cornerRadius = 6\n    goButton.layer.masksToBounds = true\n&#125;\n</code></pre>\n<p>这里生成长度为100的3个数组。本质上存放的0到9个数字。</p>\n<h3 id=\"4-4-将要可见\"><a href=\"#4-4-将要可见\" class=\"headerlink\" title=\"4.4 将要可见\"></a>4.4 将要可见</h3><pre><code class=\"line-numbers language-Swift\">override func viewWillAppear(_ animated: Bool) &#123;\n    super.viewWillAppear(animated)\n    \n    goButton.alpha = 0   \n&#125;\n</code></pre>\n<h3 id=\"4-5-已经可见\"><a href=\"#4-5-已经可见\" class=\"headerlink\" title=\"4.5 已经可见\"></a>4.5 已经可见</h3><pre><code class=\"line-numbers language-Swift\">override func viewDidAppear(_ animated: Bool) &#123;\n    super.viewDidAppear(animated)\n    \n    UIView.animate(withDuration: 0.5, delay: 0.3, options: .curveEaseOut, animations: &#123;\n        \n        self.goButton.alpha = 1\n        \n        &#125;, completion: nil)\n&#125;\n</code></pre>\n<p>底部按钮逐渐显示。</p>\n<h3 id=\"4-6-点击事件\"><a href=\"#4-6-点击事件\" class=\"headerlink\" title=\"4.6 点击事件\"></a>4.6 点击事件</h3><pre><code class=\"line-numbers language-Swift\">@IBAction func amazingButtonDidTouch(_ sender: UIButton) &#123;\n    amazingFlag = !amazingFlag;\n    sender.setTitle(amazingFlag ? &quot;开挂模式&quot;:&quot;常规模式&quot;, for: .normal)\n&#125;\n\n@IBAction func goButtoDidTouch(_ sender: AnyObject) &#123;\n    let index1: Int\n    let index2: Int\n    let index3: Int\n    if amazingFlag &#123;\n        index1 = Int(arc4random()) % 90 + 3\n        index2 = dataArray2.firstIndex(of: dataArray1[index1])!\n        index3 = dataArray3.lastIndex(of: dataArray1[index1])!\n    &#125; else &#123;\n        index1 = Int(arc4random()) % 90 + 3\n        index2 = Int(arc4random()) % 90 + 3\n        index3 = Int(arc4random()) % 90 + 3\n    &#125;\n    \n    /// 下次多少行，开启动画效果\n    emojiPickerView.selectRow(index1, inComponent: 0, animated: true)\n    emojiPickerView.selectRow(index2, inComponent: 1, animated: true)\n    emojiPickerView.selectRow(index3, inComponent: 2, animated: true)\n    \n    /// 结果显示\n    if(dataArray1[emojiPickerView.selectedRow(inComponent: 0)] == dataArray2[emojiPickerView.selectedRow(inComponent: 1)] &amp;&amp; dataArray2[emojiPickerView.selectedRow(inComponent: 1)] == dataArray3[emojiPickerView.selectedRow(inComponent: 2)]) &#123;\n        \n        resultLabel.text = &quot;Bingo!&quot;\n        \n    &#125; else &#123;\n        resultLabel.text = &quot;💔&quot;\n    &#125;\n    \n    /// 底部Go抖动效果\n    UIView.animate(withDuration: 0.5, delay: 0.0, usingSpringWithDamping: 0.1, initialSpringVelocity: 5, options: .curveLinear, animations: &#123;\n        \n        self.goButton.bounds = CGRect(x: self.bounds.origin.x, y: self.bounds.origin.y, width: self.bounds.size.width - 20, height: self.bounds.size.height)\n        \n    &#125;, completion: &#123; (compelete: Bool) in\n        \n        UIView.animate(withDuration: 0.1, delay: 0.0, options: UIViewAnimationOptions(), animations: &#123;\n            \n            self.goButton.bounds = CGRect(x: self.bounds.origin.x, y: self.bounds.origin.y, width: self.bounds.size.width, height: self.bounds.size.height)\n            \n        &#125;, completion: nil)\n        \n    &#125;)\n&#125;\n</code></pre>\n<h2 id=\"5-启动动画\"><a href=\"#5-启动动画\" class=\"headerlink\" title=\"5 启动动画\"></a>5 启动动画</h2><h3 id=\"5-1-效果\"><a href=\"#5-1-效果\" class=\"headerlink\" title=\"5.1 效果\"></a>5.1 效果</h3><img src=splash.gif>\n\n<h3 id=\"5-2-启动页\"><a href=\"#5-2-启动页\" class=\"headerlink\" title=\"5.2 启动页\"></a>5.2 启动页</h3><p>启动页需要再info.plist中配置<br>如下：<br><img src=25_1.png></p>\n<p>这里我们在LaunchScreen.storyboard中设置了一个背景图片。<br>这里面设置了一张白色的🕊没有效果哦。但是之前有，不知道为啥。</p>\n<h3 id=\"5-3-首页\"><a href=\"#5-3-首页\" class=\"headerlink\" title=\"5.3 首页\"></a>5.3 首页</h3><p>首页其实加了一个同启动页的蓝色背景，中间减掉一个白鸽，然后白鸽再扩展的动画。<br>这个背景是在故事版的View右侧属性里面的Background中设置的。</p>\n<p>设置蒙层：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n    super.viewDidLoad()\n    // Do any additional setup after loading the view, typically from a nib.\n    \n    self.mask = CALayer()\n    self.mask!.contents = UIImage(named: &quot;twitter&quot;)?.cgImage\n    self.mask!.contentsGravity = kCAGravityResizeAspect\n    self.mask!.bounds = CGRect(x: 0, y: 0, width: 100, height: 81)\n    self.mask!.anchorPoint = CGPoint(x: 0.5, y: 0.5)\n    self.imageView.setNeedsLayout()\n    self.imageView.layoutIfNeeded()\n    self.mask!.position = CGPoint(x: self.imageView.frame.size.width / 2, y: self.imageView.frame.size.height / 2)\n    self.imageView.layer.mask = mask\n    \n    animateMask()\n&#125;\n</code></pre>\n<p>这里给到imageView的layer的mask，这样就相当于在蓝色背景中镂空可以看到里面的东西了。</p>\n<pre><code class=\"line-numbers language-Swift\">func animateMask() &#123;\n    let keyFrameAnimation = CAKeyframeAnimation(keyPath: &quot;bounds&quot;)\n    keyFrameAnimation.delegate = self\n    keyFrameAnimation.duration = 0.6\n    keyFrameAnimation.beginTime = CACurrentMediaTime() + 0.5\n    keyFrameAnimation.timingFunctions = [CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut), CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut)]\n    do &#123;\n        // 动画需要加上这段代码，否则会造成页面闪一下\n        keyFrameAnimation.fillMode = kCAFillModeForwards\n        keyFrameAnimation.isRemovedOnCompletion = false\n    &#125;\n    let initalBounds = NSValue(cgRect: mask!.bounds)\n    let secondBounds = NSValue(cgRect: CGRect(x: 0, y: 0, width: 90*0.9, height: 73*0.9))\n    let finalBounds = NSValue(cgRect: CGRect(x: 0, y: 0, width: 1600, height: 1300))\n    keyFrameAnimation.values = [initalBounds, secondBounds, finalBounds]\n    keyFrameAnimation.keyTimes = [0, 0.3, 1]\n    self.mask!.add(keyFrameAnimation, forKey: &quot;bounds&quot;)\n&#125;\n</code></pre>\n<p>这个动画的作用是将镂空效果爆炸，显示出主页面。</p>\n<p>动画停止后需要去除蒙层哦：</p>\n<pre><code class=\"line-numbers language-Swift\">extension ViewController : CAAnimationDelegate &#123;\n    func animationDidStop(_ anim: CAAnimation, finished flag: Bool) &#123;\n        self.imageView.layer.mask = nil\n    &#125;\n&#125;\n</code></pre>\n<p>动画结束，需要将蒙层去掉，不然屏幕上方会多出一块多余的遮挡视图。</p>\n<h2 id=\"6-滑动菜单\"><a href=\"#6-滑动菜单\" class=\"headerlink\" title=\"6 滑动菜单\"></a>6 滑动菜单</h2><h3 id=\"6-1-效果\"><a href=\"#6-1-效果\" class=\"headerlink\" title=\"6.1 效果\"></a>6.1 效果</h3><img src=SlideMenu.gif>\n\n<h3 id=\"6-2-首页\"><a href=\"#6-2-首页\" class=\"headerlink\" title=\"6.2 首页\"></a>6.2 首页</h3><pre><code class=\"line-numbers language-Swift\">class NewsTableViewController: BaseTableViewController &#123;\n    let menuTransitionManager = MenuTransitionManager()\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n\n        self.title = &quot;Everyday Moments&quot;\n        self.view.backgroundColor = UIColor(red:0.062, green:0.062, blue:0.07, alpha:1)\n    &#125;\n    \n    override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123;\n        let menuTableViewController = segue.destination as! MenuTableViewController\n        menuTableViewController.currentItem = self.title!\n        menuTableViewController.transitioningDelegate = menuTransitionManager\n        menuTransitionManager.delegate = self\n    &#125;\n&#125;\n</code></pre>\n<p>这里有一个prepare方法，实际上是跳转到其它页面前会执行。<br>我们在故事版里面定义了跳转关系，这里就可以通过prepare方法拿到跳转的目标控制器了。</p>\n<p>这是一个新闻的列表页。<br>这里首先继承了BaseTableViewController:</p>\n<pre><code class=\"line-numbers language-Swift\">class BaseTableViewController: UITableViewController &#123;\n    \n    override var preferredStatusBarStyle: UIStatusBarStyle &#123;\n        return UIStatusBarStyle.lightContent\n    &#125;\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        self.tableView.separatorStyle = UITableViewCellSeparatorStyle.none\n    &#125;\n&#125;\n</code></pre>\n<p>然后这里有一个MenuTransitionManager,是我们自定义的一个类：<br>个人猜测这个Transition相关的应该是为了实现一个转场动画，实现菜单能够丝滑地顶下来吧。<br>里面放了一个自己定义的协议MenuTransitionManagerDelegate:</p>\n<pre><code class=\"line-numbers language-Swift\">@objc protocol MenuTransitionManagerDelegate &#123;\n    func dismiss()\n&#125;\n\nclass MenuTransitionManager: NSObject &#123;\n    var duration = 0.5\n    var isPresenting = false\n    var delegate:MenuTransitionManagerDelegate?\n    var snapshot:UIView? &#123;\n        didSet &#123;\n            if let _delegate = delegate &#123;\n                let tapGestureRecognizer = UITapGestureRecognizer(target: _delegate, action: #selector(MenuTransitionManagerDelegate.dismiss))\n                snapshot?.addGestureRecognizer(tapGestureRecognizer)\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>然后扩展了一个UIViewControllerAnimatedTransitioning，<br>这个应该是系统的协议：</p>\n<pre><code class=\"line-numbers language-Swift\">extension MenuTransitionManager : UIViewControllerAnimatedTransitioning &#123;\n    func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval &#123;\n        return duration\n    &#125;\n    \n    func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123;\n        let fromView = transitionContext.view(forKey: .from)!\n        let toView = transitionContext.view(forKey: .to)!\n        let container = transitionContext.containerView\n        let moveLeft = CGAffineTransform(translationX: 250, y: 0)\n        let moveRight = CGAffineTransform(translationX: 0, y: 0)\n        \n        if isPresenting &#123;\n            snapshot = fromView.snapshotView(afterScreenUpdates: true)\n            container.addSubview(toView)\n            container.addSubview(snapshot!)\n        &#125;\n        \n        UIView.animate(withDuration: duration, delay: 0.0, usingSpringWithDamping: 0.9, initialSpringVelocity: 0.3, options: .curveEaseInOut, animations: &#123;\n            if self.isPresenting &#123;\n                self.snapshot?.transform = moveLeft\n                toView.transform = .identity\n            &#125; else &#123;\n                self.snapshot?.transform = .identity\n                fromView.transform = moveRight\n            &#125;\n            \n        &#125;, completion: &#123; finished in\n            transitionContext.completeTransition(true)\n            if !self.isPresenting &#123;\n                self.snapshot?.removeFromSuperview()\n            &#125;\n        &#125;)\n    &#125;\n&#125;\n</code></pre>\n<p>同时也扩展了UIViewControllerTransitioningDelegate,也是系统的：</p>\n<pre><code class=\"line-numbers language-Swift\">extension MenuTransitionManager : UIViewControllerTransitioningDelegate &#123;\n    func animationController(forDismissed dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;\n        isPresenting = false\n        return self\n    &#125;\n    \n    func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;\n        isPresenting = true\n        return self\n    &#125;\n&#125;\n</code></pre>\n<p>再看下首页新闻展示的代理和数据源：</p>\n<pre><code class=\"line-numbers language-Swift\">extension NewsTableViewController &#123;\n    // MARK: UITableViewDataSource\n    override func numberOfSections(in tableView: UITableView) -&gt; Int &#123;\n        return 3\n    &#125;\n    \n    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n        return 4\n    &#125;\n    \n    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n        let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) as! NewsTableViewCell\n        cell.backgroundColor = UIColor.clear\n        \n        if indexPath.row == 0 &#123;\n            cell.postImageView.image = UIImage(named: &quot;1&quot;)\n            cell.postTitle.text = &quot;Love mountain.&quot;\n            cell.postAuthor.text = &quot;Allen Wang&quot;\n            cell.authorImageView.image = UIImage(named: &quot;a&quot;)\n            \n        &#125; else if indexPath.row == 1 &#123;\n            cell.postImageView.image = UIImage(named: &quot;2&quot;)\n            cell.postTitle.text = &quot;New graphic design - LIVE FREE&quot;\n            cell.postAuthor.text = &quot;Cole&quot;\n            cell.authorImageView.image = UIImage(named: &quot;b&quot;)\n            \n        &#125; else if indexPath.row == 2 &#123;\n            cell.postImageView.image = UIImage(named: &quot;3&quot;)\n            cell.postTitle.text = &quot;Summer sand&quot;\n            cell.postAuthor.text = &quot;Daniel Hooper&quot;\n            cell.authorImageView.image = UIImage(named: &quot;c&quot;)\n            \n        &#125; else &#123;\n            cell.postImageView.image = UIImage(named: &quot;4&quot;)\n            cell.postTitle.text = &quot;Seeking for signal&quot;\n            cell.postAuthor.text = &quot;Noby-Wan Kenobi&quot;\n            cell.authorImageView.image = UIImage(named: &quot;d&quot;)\n            \n        &#125;\n        \n        return cell\n    &#125;\n&#125;\n</code></pre>\n<p>这里每行能够正常展示了。Cell用了自定义的NewsTableViewCell:</p>\n<pre><code class=\"line-numbers language-Swift\">class NewsTableViewCell: UITableViewCell &#123;\n    @IBOutlet weak var postImageView:UIImageView!\n    @IBOutlet weak var postTitle:UILabel!\n    @IBOutlet weak var postAuthor:UILabel!\n    @IBOutlet weak var authorImageView:UIImageView!\n\n    override func awakeFromNib() &#123;\n        super.awakeFromNib()\n        authorImageView.layer.cornerRadius = authorImageView.frame.width / 2\n        authorImageView.layer.masksToBounds = true\n    &#125;\n\n    override func setSelected(_ selected: Bool, animated: Bool) &#123;\n        super.setSelected(selected, animated: animated)\n\n        // Configure the view for the selected state\n    &#125;\n&#125;\n</code></pre>\n<p>具体布局还是故事版里面处理的布局。</p>\n<p>然后让首页也实现我们自定义的MenuTransitionManagerDelegate 转场代理吧：</p>\n<pre><code class=\"line-numbers language-Swift\">extension NewsTableViewController : MenuTransitionManagerDelegate &#123;\n    func dismiss() &#123;\n        dismiss(animated: true, completion: nil)\n    &#125;\n&#125;\n</code></pre>\n<p>这里猜测是点击空白区域，菜单dismiss吧。</p>\n<h3 id=\"6-3-菜单控制器\"><a href=\"#6-3-菜单控制器\" class=\"headerlink\" title=\"6.3 菜单控制器\"></a>6.3 菜单控制器</h3><pre><code class=\"line-numbers language-Swift\">class MenuTableViewController: BaseTableViewController &#123;\n    var menuItems = [&quot;Everyday Moments&quot;, &quot;Popular&quot;, &quot;Editors&quot;, &quot;Upcoming&quot;, &quot;Fresh&quot;, &quot;Stock-photos&quot;, &quot;Trending&quot;]\n    var currentItem = &quot;Everyday Moments&quot;\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        self.view.backgroundColor = UIColor(red:0.109, green:0.114, blue:0.128, alpha:1)\n    &#125;\n    \n    // 这里prepare去掉效果一样\n    override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123;\n        let menuTableViewController = segue.source as! MenuTableViewController\n        \n        if let selectedRow = menuTableViewController.tableView.indexPathForSelectedRow?.row &#123;\n            currentItem = menuItems[selectedRow]\n        &#125;\n    &#125;\n&#125;\n\nextension MenuTableViewController &#123;\n    // MARK: UITableViewDataSource\n    override func numberOfSections(in tableView: UITableView) -&gt; Int &#123;\n        return 1\n    &#125;\n    \n    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n        return menuItems.count\n    &#125;\n    \n    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n        let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) as! MenuTableViewCell\n        \n        cell.titleLabel.text = menuItems[indexPath.row]\n        cell.titleLabel.textColor = (menuItems[indexPath.row] == currentItem) ? UIColor.white : UIColor.gray\n        cell.backgroundColor = UIColor.clear\n        return cell\n    &#125;\n&#125;\n</code></pre>\n<p>这里实现了菜单列表显示。</p>\n<p>菜单Cell如下：</p>\n<pre><code class=\"line-numbers language-Swift\">class MenuTableViewCell: UITableViewCell &#123;\n\n    @IBOutlet weak var titleLabel:UILabel!\n    \n    override func awakeFromNib() &#123;\n        super.awakeFromNib()\n        // Initialization code\n    &#125;\n\n    override func setSelected(_ selected: Bool, animated: Bool) &#123;\n        super.setSelected(selected, animated: animated)\n\n        // Configure the view for the selected state\n    &#125;\n\n&#125;\n</code></pre>\n<h2 id=\"7-酷炫左右缩放菜单\"><a href=\"#7-酷炫左右缩放菜单\" class=\"headerlink\" title=\"7 酷炫左右缩放菜单\"></a>7 酷炫左右缩放菜单</h2><h3 id=\"7-1-效果\"><a href=\"#7-1-效果\" class=\"headerlink\" title=\"7.1 效果\"></a>7.1 效果</h3><img src=TumblrMenu.gif>\n\n<h3 id=\"7-2-首页\"><a href=\"#7-2-首页\" class=\"headerlink\" title=\"7.2 首页\"></a>7.2 首页</h3><pre><code class=\"line-numbers language-Swift\">class MainViewController: BaseViewController &#123;\n\n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        self.navigationController?.isNavigationBarHidden = true\n    &#125;\n\n    override func didReceiveMemoryWarning() &#123;\n        super.didReceiveMemoryWarning()\n    &#125;\n    \n    @IBAction func unwindToMainViewController (_ sender: UIStoryboardSegue)&#123;\n        self.dismiss(animated: true, completion: nil)\n    &#125;\n&#125;\n</code></pre>\n<p>这里的unwindToMainViewController 是我们自行在故事版拖进来的，这样子在这个控制器里面的点击事件也可以处理的。<br>这里就是dismiss弹框。<br>其它ui是我们自己拖到故事版里面的。</p>\n<h3 id=\"7-3-菜单页\"><a href=\"#7-3-菜单页\" class=\"headerlink\" title=\"7.3 菜单页\"></a>7.3 菜单页</h3><p>菜单页是由一个UIVisualEffectView的父布局包裹的。<br>这个故事版的Scene绑定的class为MenuViewController。</p>\n<pre><code class=\"line-numbers language-Swift\">class MenuViewController: BaseViewController &#123;\n    \n    let transitionManager = MenuTransitionManager()\n    \n    @IBOutlet weak var textButton: UIButton!\n    @IBOutlet weak var textLabel: UILabel!\n    \n    @IBOutlet weak var photoButton: UIButton!\n    @IBOutlet weak var photoLabel: UILabel!\n    \n    @IBOutlet weak var quoteButton: UIButton!\n    @IBOutlet weak var quoteLabel: UILabel!\n    \n    @IBOutlet weak var linkButton: UIButton!\n    @IBOutlet weak var linkLabel: UILabel!\n    \n    @IBOutlet weak var chatButton: UIButton!\n    @IBOutlet weak var chatLabel: UILabel!\n    \n    @IBOutlet weak var audioButton: UIButton!\n    @IBOutlet weak var audioLabel: UILabel!\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        self.transitioningDelegate = self.transitionManager\n    &#125;\n\n    override func didReceiveMemoryWarning() &#123;\n        super.didReceiveMemoryWarning()\n    &#125;\n&#125;\n</code></pre>\n<p>这里声明了，布局效果在故事版里面拖动的。</p>\n<p>注意了这里self的transitiningDelegate设置了转场动画。</p>\n<p>也是我们自己定义的一个类：</p>\n<pre><code class=\"line-numbers language-Swift\">\nclass MenuTransitionManager: NSObject &#123;\n\n    private var presenting = false\n\n    func offstage(_ amount: CGFloat) -&gt; CGAffineTransform &#123;\n        return CGAffineTransform(translationX: amount, y: 0)\n    &#125;\n    \n    func offStageMenuController(_ menuViewController: MenuViewController) &#123;\n        if !presenting&#123;\n            menuViewController.view.alpha = 0\n        &#125;\n        let topRowOffset  : CGFloat = 300\n        let middleRowOffset : CGFloat = 150\n        let bottomRowOffset  : CGFloat = 50\n        \n        menuViewController.textButton.transform = self.offstage(-topRowOffset)\n        menuViewController.textLabel.transform = self.offstage(-topRowOffset)\n        \n        menuViewController.quoteButton.transform = self.offstage(-middleRowOffset)\n        menuViewController.quoteLabel.transform = self.offstage(-middleRowOffset)\n        \n        menuViewController.chatButton.transform = self.offstage(-bottomRowOffset)\n        menuViewController.chatLabel.transform = self.offstage(-bottomRowOffset)\n        \n        menuViewController.photoButton.transform = self.offstage(topRowOffset)\n        menuViewController.photoLabel.transform = self.offstage(topRowOffset)\n        \n        menuViewController.linkButton.transform = self.offstage(middleRowOffset)\n        menuViewController.linkLabel.transform = self.offstage(middleRowOffset)\n        \n        menuViewController.audioButton.transform = self.offstage(bottomRowOffset)\n        menuViewController.audioLabel.transform = self.offstage(bottomRowOffset)\n        \n    &#125;\n    \n    func onStageMenuController(_ menuViewController: MenuViewController) &#123;\n        menuViewController.view.alpha = 1\n        \n        menuViewController.textButton.transform = .identity\n        menuViewController.textLabel.transform = .identity\n        menuViewController.quoteButton.transform = .identity\n        menuViewController.quoteLabel.transform = .identity\n        menuViewController.chatButton.transform = .identity\n        menuViewController.chatLabel.transform = .identity\n        menuViewController.photoButton.transform = .identity\n        menuViewController.photoLabel.transform = .identity\n        menuViewController.linkButton.transform = .identity\n        menuViewController.linkLabel.transform = .identity\n        menuViewController.audioButton.transform = .identity\n        menuViewController.audioLabel.transform = .identity\n        \n    &#125;\n&#125;\n</code></pre>\n<p>可以看到这里主要是针对里面控制器的ui的transform做了一些配置。</p>\n<p>然后这个管理员实现了UIViewControllerTransitioningDelegate代理：</p>\n<pre><code class=\"line-numbers language-Swift\">extension MenuTransitionManager : UIViewControllerTransitioningDelegate &#123;\n    func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;\n        self.presenting = true\n        return self\n    &#125;\n    \n    func animationController(forDismissed dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;\n        self.presenting = false\n        return self\n    &#125;\n&#125;\n</code></pre>\n<p>同样也实现了UIViewControllerAnimatedTransitioning这个协议：</p>\n<pre><code class=\"line-numbers language-Swift\">extension MenuTransitionManager : UIViewControllerAnimatedTransitioning &#123;\n    \n    func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval &#123;\n        return 0.5\n    &#125;\n    \n    func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123;\n        let container = transitionContext.containerView\n        let screens: (from:UIViewController, to:UIViewController) = (transitionContext.viewController(forKey: .from)!, transitionContext.viewController(forKey: .to)!)\n        \n        let menuViewController = !self.presenting ? screens.from as! MenuViewController : screens.to as! MenuViewController\n        let bottomViewController = !self.presenting ? screens.to as UIViewController : screens.from as UIViewController\n        \n        let menuView: UIView! = menuViewController.view\n        let bottomView: UIView! = bottomViewController.view\n        \n        if (self.presenting) &#123;\n             self.offStageMenuController(menuViewController)\n        &#125;\n        container.addSubview(bottomView)\n        container.addSubview(menuView)\n        \n        let duration = self.transitionDuration(using: transitionContext)\n        \n        UIView.animate(withDuration: duration, delay: 0.0, usingSpringWithDamping: 0.7, initialSpringVelocity: 0.8, options: [], animations: &#123;\n            if (self.presenting) &#123;\n                 self.onStageMenuController(menuViewController)\n            &#125; else &#123;\n                self.offStageMenuController(menuViewController)\n            &#125;\n        &#125;, completion: &#123; finished in\n            transitionContext.completeTransition(true)\n            UIApplication.shared.keyWindow!.addSubview(screens.to.view)\n        &#125;)\n    &#125;\n&#125;\n</code></pre>\n<p>主要是动画执行的时候，走了self.onStageMenuController方法或者self.offStageMenuController这个方法实现动画效果。</p>\n<h2 id=\"8-限制字符串\"><a href=\"#8-限制字符串\" class=\"headerlink\" title=\"8 限制字符串\"></a>8 限制字符串</h2><h3 id=\"8-1-效果\"><a href=\"#8-1-效果\" class=\"headerlink\" title=\"8.1 效果\"></a>8.1 效果</h3><img src=Limit.gif>\n\n<h3 id=\"8-2-UI\"><a href=\"#8-2-UI\" class=\"headerlink\" title=\"8.2 UI\"></a>8.2 UI</h3><p>这里也是先构造一个故事版。<br>左上角：Close按钮。<br>右上角：Tweet按钮。<br>头像：Avatar Image VIew。<br>底部View: 4个Button<br>编辑框：UITextView</p>\n<img src=18_1.png>\n\n<p>控制器要用的：</p>\n<pre><code class=\"line-numbers language-Swift\">class ViewController: UIViewController &#123;\n\n    @IBOutlet weak var tweetTextView: UITextView!\n    @IBOutlet weak var bottomUIView: UIView!\n    @IBOutlet weak var avatarImageView: UIImageView!\n    @IBOutlet weak var characterCountLabel: UILabel!\n</code></pre>\n<p>初始化生命周期：</p>\n<pre><code class=\"line-numbers language-Swift\">    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        tweetTextView.delegate = self\n        avatarImageView.layer.cornerRadius = avatarImageView.frame.width / 2\n        tweetTextView.backgroundColor = UIColor.clear\n        \n        NotificationCenter.default.addObserver(self, selector:#selector(ViewController.keyBoardWillShow(_:)), name:UIResponder.keyboardWillShowNotification, object: nil)\n        NotificationCenter.default.addObserver(self, selector:#selector(ViewController.keyBoardWillHide(_:)), name:UIResponder.keyboardWillHideNotification, object: nil)\n    &#125;\n</code></pre>\n<p>这里配置了UITextView的代理为自己，后面一定会实现相关方法的。</p>\n<p>然后这里监听了键盘显示和隐藏哦。<br>主要是将底部的控制栏跟随键盘上下顶起来。</p>\n<pre><code class=\"line-numbers language-Swift\">@objc func keyBoardWillShow(_ note:NSNotification) &#123;\n    let userInfo  = note.userInfo\n    let keyBoardBounds = (userInfo![UIResponder.keyboardFrameEndUserInfoKey] as! NSValue).cgRectValue\n    let duration = (userInfo![UIResponder.keyboardAnimationDurationUserInfoKey] as! NSNumber).doubleValue\n    let deltaY = keyBoardBounds.size.height\n    let animations = &#123;\n        self.bottomUIView.transform = CGAffineTransform(translationX: 0, y: -deltaY)\n    &#125;\n    \n    if duration &gt; 0 &#123;\n        // 莫名其妙的一段代码, 左移16位能看出来是个啥值吗\n        // let options = UIView.AnimationOptions(rawValue: UInt((userInfo![UIResponder.keyboardAnimationCurveUserInfoKey] as! NSNumber).intValue &lt;&lt; 16))\n        UIView.animate(withDuration: duration, delay: 0, options:[.beginFromCurrentState, .curveLinear], animations: animations, completion: nil)\n    &#125;else &#123;\n        animations()\n    &#125;\n&#125;\n</code></pre>\n<p>上面的代码是为了在键盘弹出的时候，底部bottomUIView跟随键盘顶起来。</p>\n<pre><code class=\"line-numbers language-Swift\">@objc func keyBoardWillHide(_ note:NSNotification) &#123;\n    let userInfo  = note.userInfo\n    let duration = (userInfo![UIResponder.keyboardAnimationDurationUserInfoKey] as! NSNumber).doubleValue\n    \n    let animations = &#123;\n        self.bottomUIView.transform = .identity\n    &#125;\n    \n    if duration &gt; 0 &#123;\n        // let options = UIView.AnimationOptions(rawValue: UInt((userInfo![UIResponder.keyboardAnimationCurveUserInfoKey] as! NSNumber).intValue &lt;&lt; 16))\n        UIView.animate(withDuration: duration, delay: 0, options:[.beginFromCurrentState, .curveLinear], animations: animations, completion: nil)\n    &#125;else&#123;\n        animations()\n    &#125;\n    \n&#125;\n</code></pre>\n<p>上面的代码是为了在键盘隐藏的时候，底部bottomUIView也随之落下去。</p>\n<p>然后编辑框的代理如下：</p>\n<pre><code class=\"line-numbers language-Swift\">extension ViewController : UITextViewDelegate &#123;\n    // MARK:UITextViewDelegate\n    func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -&gt; Bool &#123;\n        let inputTextLength = text.count - range.length + tweetTextView.text.count\n        if inputTextLength &gt; 140 &#123;\n            return false\n        &#125;\n        characterCountLabel.text = &quot;\\(140 - inputTextLength)&quot;\n        return true\n    &#125;\n&#125;\n</code></pre>\n<p>这里是为了统计当前剩余字符，如果不足，则无法继续输入。</p>\n<h2 id=\"9-自定义下拉刷新\"><a href=\"#9-自定义下拉刷新\" class=\"headerlink\" title=\"9 自定义下拉刷新\"></a>9 自定义下拉刷新</h2><h3 id=\"9-1-效果\"><a href=\"#9-1-效果\" class=\"headerlink\" title=\"9.1 效果\"></a>9.1 效果</h3><img src=CustomPullToRefresh.gif>\n\n<h3 id=\"9-2-变量定义\"><a href=\"#9-2-变量定义\" class=\"headerlink\" title=\"9.2 变量定义\"></a>9.2 变量定义</h3><pre><code class=\"line-numbers language-Swift\">    var refreshController: UIRefreshControl!\n    var customView: UIView!\n    var labelsArray: Array&lt;UILabel&gt; = []\n    var isAnimating = false\n    var currentColorIndex = 0\n    var currentLabelIndex = 0\n    var timer: Timer!\n    var dataArray: Array&lt;String&gt; = [&quot;😂&quot;, &quot;🤗&quot;, &quot;😳&quot;, &quot;😌&quot;, &quot;😊&quot;]\n</code></pre>\n<p>这里第一个就是刷新控制器了，应该主要就是往这里面加逻辑。</p>\n<h3 id=\"9-3-初始化\"><a href=\"#9-3-初始化\" class=\"headerlink\" title=\"9.3 初始化\"></a>9.3 初始化</h3><pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n    super.viewDidLoad()\n    \n    tblDemo.delegate = self\n    tblDemo.dataSource = self\n    refreshController = UIRefreshControl()\n    refreshController.backgroundColor = UIColor.clear\n    refreshController.tintColor = UIColor.clear\n    tblDemo.addSubview(refreshController)\n    \n    loadCustomRefreshContents()\n&#125;\n</code></pre>\n<p>这里设置了代理和数据源，new了一个刷新控制器，清空背景，给tableView添加了一个子View。</p>\n<p>下面加载自定义xib文件：</p>\n<pre><code class=\"line-numbers language-Swift\"> func loadCustomRefreshContents() &#123;\n        \n    let refreshContents = Bundle.main.loadNibNamed(&quot;RefreshContents&quot;, owner: self, options: nil)\n    \n    customView = refreshContents![0] as? UIView\n    customView.frame = refreshController.bounds\n    \n    for i in 0..&lt;customView.subviews.count &#123;\n        labelsArray.append(customView.viewWithTag(i + 1) as! UILabel)\n    &#125;\n    \n    refreshController.addSubview(customView)\n&#125;\n</code></pre>\n<p>这个布局里面主要是存放了我们自定义头部的View。</p>\n<h3 id=\"9-4-数据源和代理\"><a href=\"#9-4-数据源和代理\" class=\"headerlink\" title=\"9.4 数据源和代理\"></a>9.4 数据源和代理</h3><pre><code class=\"line-numbers language-Swift\">extension ViewController : UITableViewDelegate &#123;\n    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123;\n        \n    &#125;\n    \n    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n        return 80\n    &#125;\n&#125;\n\nextension ViewController : UITableViewDataSource &#123;\n    \n    func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int &#123;\n        return 1\n    &#125;\n    \n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n        return dataArray.count\n    &#125;\n    \n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n        let cell = tableView.dequeueReusableCell(withIdentifier: &quot;idCell&quot;, for: indexPath)\n        \n        cell.textLabel!.text = dataArray[indexPath.row]\n        cell.textLabel!.font = UIFont(name: &quot;Apple Color Emoji&quot;, size: 40)\n        cell.textLabel!.textAlignment = .center\n        \n        return cell\n    &#125;\n&#125;\n</code></pre>\n<p>这里cell用默认的。</p>\n<h3 id=\"9-5-下拉动画实现\"><a href=\"#9-5-下拉动画实现\" class=\"headerlink\" title=\"9.5 下拉动画实现\"></a>9.5 下拉动画实现</h3><p>首先实现UIScrollViewDelegate代理：</p>\n<pre><code class=\"line-numbers language-Swift\">extension ViewController : UIScrollViewDelegate &#123;\n    func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) &#123;\n        if refreshController.isRefreshing &#123;\n            if !isAnimating &#123;\n                doSomething()\n                animateRefreshStep1()\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>如果没有在刷新中，没有在动画中，就做点失去，然后走动画第一步。</p>\n<pre><code class=\"line-numbers language-Swift\">func doSomething() &#123;\n    timer = Timer.scheduledTimer(timeInterval: 5, target: self, selector: #selector(ViewController.endedOfWork), userInfo: nil, repeats: true)\n&#125;\n</code></pre>\n<p>这里开启定时器，5s后才走endedofWork。</p>\n<pre><code class=\"line-numbers language-Swift\">@objc func endedOfWork() &#123;\n    refreshController.endRefreshing()\n    timer.invalidate()\n    timer = nil\n&#125;\n</code></pre>\n<p>这里停止刷新，定时器结束。<br>说明上面的doSomething只是开启一个定时器，模拟进行网络请求，然后加载动画而已。</p>\n<p>动画第一步：</p>\n<pre><code class=\"line-numbers language-Swift\">func animateRefreshStep1() &#123;\n    isAnimating = true\n    \n    UIView.animate(withDuration: 0.1, delay: 0.0, options: .curveLinear, animations: &#123;\n        self.labelsArray[self.currentLabelIndex].transform = CGAffineTransform(rotationAngle: CGFloat(Double.pi/4))\n        self.labelsArray[self.currentLabelIndex].textColor = self.getNextColor()\n        &#125;, completion: &#123; _ in\n            UIView.animate(withDuration: 0.05, delay: 0.0, options: .curveLinear, animations: &#123;\n                self.labelsArray[self.currentLabelIndex].transform = .identity\n                self.labelsArray[self.currentLabelIndex].textColor = UIColor.black\n                &#125;, completion: &#123; _ in\n                    self.currentLabelIndex += 1\n                    if self.currentLabelIndex &lt; self.labelsArray.count &#123;\n                        self.animateRefreshStep1()\n                    &#125;else &#123;\n                        self.animateRefreshStep2()\n                    &#125;\n            &#125;)\n    &#125;)\n&#125;\n\nfunc getNextColor() -&gt; UIColor &#123;\n    var colorsArray: Array&lt;UIColor&gt; = [.magenta, .brown, .yellow,\n                                        .red, .green, .blue, .orange]\n    if currentColorIndex == colorsArray.count &#123;\n        currentColorIndex = 0\n    &#125;\n    let returnColor = colorsArray[currentColorIndex]\n    currentColorIndex += 1\n    return returnColor\n&#125;\n</code></pre>\n<p>这里开启动画了，给子View配置transform和textColor。<br>递归走每一个子View动画，走完后走动画第二步：</p>\n<pre><code class=\"line-numbers language-Swift\">func animateRefreshStep2() &#123;\n    UIView.animate(withDuration: 0.40, delay: 0.0, options: .curveLinear, animations: &#123;\n        let scale = CGAffineTransform(scaleX: 1.5, y: 1.5)\n        self.labelsArray[1].transform = scale\n        self.labelsArray[2].transform = scale\n        self.labelsArray[3].transform = scale\n        self.labelsArray[4].transform = scale\n        self.labelsArray[5].transform = scale\n        self.labelsArray[6].transform = scale\n        self.labelsArray[7].transform = scale\n        self.labelsArray[8].transform = scale\n        self.labelsArray[9].transform = scale\n        self.labelsArray[10].transform = scale\n        self.labelsArray[11].transform = scale\n        \n        &#125;, completion: &#123; _ in\n            UIView.animate(withDuration: 0.25, delay: 0.0, options: .curveLinear, animations: &#123;\n                self.labelsArray[0].transform = .identity\n                self.labelsArray[1].transform = .identity\n                self.labelsArray[2].transform = .identity\n                self.labelsArray[3].transform = .identity\n                self.labelsArray[4].transform = .identity\n                self.labelsArray[5].transform = .identity\n                self.labelsArray[6].transform = .identity\n                self.labelsArray[7].transform = .identity\n                self.labelsArray[8].transform = .identity\n                self.labelsArray[9].transform = .identity\n                self.labelsArray[10].transform = .identity\n                self.labelsArray[11].transform = .identity\n                \n                &#125;, completion: &#123; _ in\n                    if self.refreshController.isRefreshing &#123;\n                        self.currentLabelIndex = 0\n                        self.animateRefreshStep1()\n                    &#125; else &#123;\n                        self.isAnimating = false\n                        self.currentLabelIndex = 0\n                        for i in 0 ..&lt; self.labelsArray.count &#123;\n                            self.labelsArray[i].textColor = UIColor.black\n                            self.labelsArray[i].transform = .identity\n                        &#125;\n                    &#125;\n            &#125;)\n    &#125;)\n&#125;\n</code></pre>\n<h2 id=\"10-CollectionView动画\"><a href=\"#10-CollectionView动画\" class=\"headerlink\" title=\"10 CollectionView动画\"></a>10 CollectionView动画</h2><h3 id=\"10-1-效果\"><a href=\"#10-1-效果\" class=\"headerlink\" title=\"10.1 效果\"></a>10.1 效果</h3><img src=CollectionViewAnimation.gif>\n\n<h3 id=\"10-2-首页\"><a href=\"#10-2-首页\" class=\"headerlink\" title=\"10.2 首页\"></a>10.2 首页</h3><p>Main.storyboard里面放置了一个UICollectionView。</p>\n<p>里面放置了2个结构体：</p>\n<pre><code class=\"line-numbers language-Swift\">private struct Storyboard &#123;\n    static let CellIdentifier = &quot;AnimationCollectionViewCell&quot;\n    static let NibName = &quot;AnimationCollectionViewCell&quot;\n&#125;\n    \nprivate struct Constants &#123;\n    static let AnimationDuration: Double = 0.5\n    static let AnimationDelay: Double = 0.0\n    static let AnimationSpringDamping: CGFloat = 1.0\n    static let AnimationInitialSpringVelocity: CGFloat = 1.0\n&#125;\n</code></pre>\n<p>成员定义：</p>\n<pre><code class=\"line-numbers language-Swift\">@IBOutlet var testCollectionView: UICollectionView!\n\nvar imageCollection: AnimationImageCollection!\n</code></pre>\n<p>第一个是拖过来的，第二个是自定义的：</p>\n<pre><code class=\"line-numbers language-Swift\">struct AnimationImageCollection &#123;\n    private let imagePaths = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]\n    var images: [AnimationCellModel]\n    \n    init() &#123;\n        images = imagePaths.map &#123; AnimationCellModel(imagePath: $0) &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这个是一个结构体，里面的实体是这个：</p>\n<pre><code class=\"line-numbers language-Swift\">struct AnimationCellModel &#123;\n    let imagePath: String\n    \n    init(imagePath: String?) &#123;\n        self.imagePath = imagePath ?? &quot;&quot;\n    &#125;\n&#125;\n</code></pre>\n<p>很简单，放置了一个图片路径而已。</p>\n<p>回到第一个控制器：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n    super.viewDidLoad()\n    \n    imageCollection = AnimationImageCollection()\n    testCollectionView.register(UINib(nibName: Storyboard.NibName, bundle: nil), forCellWithReuseIdentifier: Storyboard.CellIdentifier)\n&#125;\n</code></pre>\n<p>这里集合View注册了一个Cell，这个Cell是我们建立的xib文件，名称叫做AnimationCollectionViewCell.</p>\n<h3 id=\"10-3-子item\"><a href=\"#10-3-子item\" class=\"headerlink\" title=\"10.3 子item\"></a>10.3 子item</h3><p>应该就是这个itemCell了，还是看下吧：</p>\n<pre><code class=\"line-numbers language-Swift\">class AnimationCollectionViewCell: UICollectionViewCell &#123;\n    \n    @IBOutlet weak var backButton: UIButton!\n    @IBOutlet weak var animationImageView: UIImageView!\n    @IBOutlet weak var animationTextView: UITextView!\n    \n    var backButtonTapped: (() -&gt; Void)?\n    \n    func prepareCell(_ viewModel: AnimationCellModel) &#123;\n        animationImageView.image = UIImage(named: viewModel.imagePath)\n        animationTextView.isScrollEnabled = false\n        backButton.isHidden = true\n        addTapEventHandler()\n    &#125;\n    \n    func handleCellSelected() &#123;\n        animationTextView.isScrollEnabled = false\n        backButton.isHidden = false\n        self.superview?.bringSubview(toFront: self)\n    &#125;\n    \n    private func addTapEventHandler() &#123;\n        backButton.addTarget(self, action: #selector(backButtonDidTouch(_:)), for: .touchUpInside)\n    &#125;\n    \n    @objc func backButtonDidTouch(_ sender: UIGestureRecognizer) &#123;\n        backButtonTapped?()\n    &#125;\n&#125;\n</code></pre>\n<p>item布局就是返回按钮，图片，和文案。<br>这个返回按钮默认应该是隐藏的，选中才给它显示。选中的时候走handleCellSelected方法，<br>这里走了一个</p>\n<pre><code>  self.superview?.bringSubview(toFront: self)\n</code></pre>\n<p>这个作用应该就是把item移动到最前面了。</p>\n<pre><code class=\"line-numbers language-Swift\"> private func addTapEventHandler() &#123;\n    backButton.addTarget(self, action: #selector(backButtonDidTouch(_:)), for: .touchUpInside)\n&#125;\n\n@objc func backButtonDidTouch(_ sender: UIGestureRecognizer) &#123;\n    backButtonTapped?()\n&#125;\n</code></pre>\n<p>这里将返回的点击事件暴露出去了。</p>\n<p>回调给首页里面了：</p>\n<pre><code class=\"line-numbers language-Swift\">// MARK: 按钮事件\nfunc backButtonDidTouch() &#123;\n    guard let indexPaths = self.collectionView!.indexPathsForSelectedItems else &#123;\n        return\n    &#125;\n\n    collectionView!.isScrollEnabled = true\n    collectionView!.reloadItems(at: indexPaths)\n&#125;\n</code></pre>\n<h3 id=\"10-4-代理设置和数据绑定\"><a href=\"#10-4-代理设置和数据绑定\" class=\"headerlink\" title=\"10.4 代理设置和数据绑定\"></a>10.4 代理设置和数据绑定</h3><pre><code class=\"line-numbers language-Swift\"> // MARK: UICollectionViewDataSource\noverride func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123;\n    \n    guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: Storyboard.CellIdentifier, for: indexPath) as? AnimationCollectionViewCell,\n        let viewModel = imageCollection.images.safeIndex(indexPath.item) else &#123;\n        return UICollectionViewCell()\n    &#125;\n    // 这里是自己定义的方法哦\n    cell.prepareCell(viewModel)\n    return cell\n&#125;\n\noverride func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123;\n    return imageCollection.images.count\n&#125;\n\n// MARK: UICollectionViewDelegate\noverride func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) &#123;\n    guard let cell = collectionView.cellForItem(at: indexPath) as? AnimationCollectionViewCell else &#123;\n        return\n    &#125;\n    \n    self.handleAnimationCellSelected(collectionView, cell: cell)\n&#125;\n</code></pre>\n<p>这里选中的时候走了handleAnimationCellSelected这个方法，才实现动画效果的：</p>\n<pre><code class=\"line-numbers language-Swift\">private func handleAnimationCellSelected(_ collectionView: UICollectionView, cell: AnimationCollectionViewCell) &#123;\n        \n    cell.handleCellSelected()\n    cell.backButtonTapped = self.backButtonDidTouch\n    \n    let animations = &#123;\n        cell.frame = self.view.bounds\n    &#125;\n\n    let completion: (_ finished: Bool) -&gt; () = &#123; _ in\n        collectionView.isScrollEnabled = false\n    &#125;\n\n    UIView.animate(withDuration: Constants.AnimationDuration, delay: Constants.AnimationDelay, usingSpringWithDamping: Constants.AnimationSpringDamping, initialSpringVelocity: Constants.AnimationInitialSpringVelocity, options: [], animations: animations, completion: completion)\n&#125;\n</code></pre>\n<p>动画主要是设置了cell的frame吧。</p>\n<h2 id=\"11-总结\"><a href=\"#11-总结\" class=\"headerlink\" title=\"11 总结\"></a>11 总结</h2><ul>\n<li><ol>\n<li>渐变TableView主要实现的是每个cell颜色不同，实现渐变效果，主要是在Cell里面定义了一个CAGradientlayer，在tableView的代理方法为willDisplay中给cell设置了背景色。背景色+渐变层实现了这种效果。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>登录动画的实现方案，就是在视图将要可见，将左侧约束减掉视图宽度，然后已经可见再走UIView的动画函数，再恢复约束，实现动画效果。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>列表动画，主要也是在将要可见的生命周期，遍历cell，修改cell的transform为CGAffineTransform，改变y值初始值为整个tableView的高度，然后动画设置恢复，从而实现进入动画效果。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>游戏抽奖滚动动画，主要用了UIPickerView来实现。点击后设置pickerView的selectRow，开启动画效果，即可实现改效果。</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>启动动画，这里主要是加了一个蒙层，通过控制器的mask，设置未CALayer，然后将png镂空图标设置给mask的conents，然后可以通过CAKeyframeAnimation给mask设置动画，这样可以实现启动展开效果。</li>\n</ol>\n</li>\n<li><ol start=\"6\">\n<li>滑动菜单，主要是在prepare方法中，定义了场景的transitioningDelegate为自定义效果，通过扩展UIViewControllerAnimatedTransitioning的系统协议，在animateTransition方法里面加入我们自己定义好的动画，可以实现滑动菜单效果。</li>\n</ol>\n</li>\n<li><ol start=\"7\">\n<li>酷炫左右缩放菜单效果，跳转的逻辑可以在故事版里面写，这里只是菜单里面配置了一个自定义的transitioningDelegate得以实现，具体动画在UIViewControllerAnimatedTransitioning这个协议里面的animateTransition方法中处理，这里面可以拿到跳转的控制器，控制器可以再拿里面的ui。</li>\n</ol>\n</li>\n<li><ol start=\"8\">\n<li>限制字符串，这个比较简单，就是UITextView的用法，一个是监听键盘收起和弹出，给底部栏加动画，另一个是实现UITextViewDelegate，可以拿到当前长度。</li>\n</ol>\n</li>\n<li><ol start=\"9\">\n<li>自定义下拉刷新，主要是对UIRefreshControl做处理，这个控制器可以添加子View，子View可以通过Bundle.main.loadNibNamed加载xib文件。这样可以实现自定义下拉刷新效果。</li>\n</ol>\n</li>\n<li><ol start=\"10\">\n<li>列表转场动画，这个主要就是走didSelectItemAt的协议方法中，实现动画，关键逻辑就是cell.frame赋予self.view.bounds，相当于放大了cell，达成目标效果。</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-渐变TableView\"><a href=\"#1-渐变TableView\" class=\"headerlink\" title=\"1 渐变TableView\"></a>1 渐变TableView</h2><h3 id=\"1-1-效果\"><a href=\"#1-1-效果\" class=\"headerlink\" title=\"1.1 效果\"></a>1.1 效果</h3><img src=cleartableviewcell.gif>\n\n<h3 id=\"1-2-代码实现\"><a href=\"#1-2-代码实现\" class=\"headerlink\" title=\"1.2 代码实现\"></a>1.2 代码实现</h3><p>直接是继承了UITableViewController这个控制器，这个应该是自带了一个列表。内部有一个tableView。</p>\n<pre><code>class ClearTableViewController: UITableViewController &#123;\n</code></pre>\n<p>初始化：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n        super.viewDidLoad()\n\n        self.view.backgroundColor = UIColor.black\n        self.tableView.separatorStyle = UITableViewCellSeparatorStyle.none\n        self.tableView.tableFooterView = UIView(frame: CGRect.zero)\n        self.tableView.register(TableViewCell.self, forCellReuseIdentifier: &quot;tableCell&quot;)        \n&#125;\n</code></pre>\n<p>这里绑定了TableViewCell。</p>\n<pre><code class=\"line-numbers language-Swift\">class TableViewCell: UITableViewCell &#123;\n\n    let gradientLayer = CAGradientLayer()\n    \n    override func awakeFromNib() &#123;\n        super.awakeFromNib()\n    &#125;\n    \n    override func setSelected(_ selected: Bool, animated: Bool) &#123;\n        super.setSelected(selected, animated: animated)\n    &#125;\n    \n    override init(style: UITableViewCellStyle, reuseIdentifier: String?) &#123;\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        \n        gradientLayer.frame = self.bounds\n        let color1 = UIColor(white: 1.0, alpha: 0.2).cgColor\n        let color2 = UIColor(white: 1.0, alpha: 0.1).cgColor\n        let color3 = UIColor.clear.cgColor\n        let color4 = UIColor(white: 0.0, alpha: 0.05).cgColor\n        \n        gradientLayer.colors = [color1, color2, color3, color4]\n        gradientLayer.locations = [0.0, 0.04, 0.95, 1.0]\n    &#125;\n    \n    override func layoutSubviews() &#123;\n        super.layoutSubviews()\n        gradientLayer.frame = self.bounds\n    &#125;\n\n    required init?(coder aDecoder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n&#125;\n</code></pre>\n<p>这里把UITableViewCell的bounds给到了一个渐变层CAGradientLayer。</p>\n<p>数据绑定：</p>\n<pre><code class=\"line-numbers language-Swift\"> var tableData = [&quot;Read 3 article on Medium&quot;, &quot;Cleanup bedroom&quot;, &quot;Go for a run&quot;, &quot;Hit the gym&quot;, &quot;Build another swift project&quot;, &quot;Movement training&quot;, &quot;Fix the layout problem of a client project&quot;, &quot;Write the experience of #30daysSwift&quot;, &quot;Inbox Zero&quot;, &quot;Booking the ticket to Chengdu&quot;, &quot;Test the Adobe Project Comet&quot;, &quot;Hop on a call to mom&quot;]\n</code></pre>\n<p>然后因为这个是UITableViewController，就无需重复设置代理了：</p>\n<pre><code class=\"line-numbers language-Swift\">override func numberOfSections(in tableView: UITableView) -&gt; Int &#123;\n        return 1\n    &#125;\n    \n    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n        return tableData.count\n    &#125;\n    \n    override func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n        return 60\n    &#125;\n    \n    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n        \n        let cell = tableView.dequeueReusableCell(withIdentifier: &quot;tableCell&quot;, for: indexPath) as! TableViewCell\n        \n        cell.textLabel?.text = tableData[indexPath.row]\n        cell.textLabel?.textColor = UIColor.white\n        cell.textLabel?.backgroundColor = UIColor.clear\n        cell.textLabel?.font = UIFont(name: &quot;Avenir Next&quot;, size: 18)\n        cell.selectionStyle = UITableViewCellSelectionStyle.none\n        return cell\n    &#125;\n    \n    override func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) &#123;\n        cell.backgroundColor = colorforIndex(index: indexPath.row)\n    &#125;\n    \n    func colorforIndex(index: Int) -&gt; UIColor &#123;\n        \n        let itemCount = tableData.count - 1\n        let color = (CGFloat(index) / CGFloat(itemCount)) * 0.6\n        return UIColor(red: 1.0, green: color, blue: 0.0, alpha: 1.0)\n    &#125;\n</code></pre>\n<p>重点实现下这几个代理方法即可。颜色设置主要是通过willDisplay这个方法设置进去了。</p>\n<h2 id=\"2-登录动画\"><a href=\"#2-登录动画\" class=\"headerlink\" title=\"2 登录动画\"></a>2 登录动画</h2><h3 id=\"2-1-效果\"><a href=\"#2-1-效果\" class=\"headerlink\" title=\"2.1 效果\"></a>2.1 效果</h3><img src=simple%20login%20animation.gif>\n\n<h3 id=\"2-2-故事版关系\"><a href=\"#2-2-故事版关系\" class=\"headerlink\" title=\"2.2 故事版关系\"></a>2.2 故事版关系</h3><img src=21_1.png>\n这里是有两个场景Scene，每个Scene绑定了一个类，也就是左侧的两个Controller。\n这里学会了不用代码，直接用storyboard直接实现控制器的跳转。\n\n<p>可以参考下这篇文章：<a href=\"https://blog.csdn.net/Sherlooock/article/details/106825134\">Xcode新建View Controller Scene并实现界面间跳转的方法</a>。</p>\n<h3 id=\"2-3-启动页\"><a href=\"#2-3-启动页\" class=\"headerlink\" title=\"2.3 启动页\"></a>2.3 启动页</h3><pre><code class=\"line-numbers language-Swift\">class SplasViewController: UIViewController &#123;\n    \n    @IBOutlet weak var signupButton: UIButton!\n    @IBOutlet weak var loginButton: UIButton!\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        \n        signupButton.layer.cornerRadius = 5\n        loginButton.layer.cornerRadius = 5 \n    &#125;\n    \n    override var preferredStatusBarStyle: UIStatusBarStyle &#123;\n        return UIStatusBarStyle.lightContent\n    &#125;\n&#125;\n这里设置了按钮圆角。\n</code></pre>\n<h3 id=\"2-4-登录页\"><a href=\"#2-4-登录页\" class=\"headerlink\" title=\"2.4 登录页\"></a>2.4 登录页</h3><p>UI定义：</p>\n<pre><code class=\"line-numbers language-Swift\">@IBOutlet weak var uesernameTextField: UITextField!\n@IBOutlet weak var passwordTextField: UITextField!\n\n@IBOutlet weak var centerAlignUsername: NSLayoutConstraint!\n@IBOutlet weak var centerAlignPassword: NSLayoutConstraint!\n\n@IBOutlet weak var loginButton: UIButton!\n</code></pre>\n<p>初始化：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n    super.viewDidLoad()\n    \n    uesernameTextField.layer.cornerRadius = 5\n    passwordTextField.layer.cornerRadius = 5\n    uesernameTextField.delegate = self\n    passwordTextField.delegate = self\n    loginButton.layer.cornerRadius = 5\n&#125;\n</code></pre>\n<p>这里设置编辑框代理，设置按钮圆角。</p>\n<p>将要显示：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewWillAppear(_ animated: Bool) &#123;\n    super.viewWillAppear(animated)\n    \n    centerAlignUsername.constant -= view.bounds.width\n    centerAlignPassword.constant -= view.bounds.width\n    loginButton.alpha = 0\n&#125;\n</code></pre>\n<p>这里设置刚进页面x轴减去控件宽度，实现效果就是从左边滑出来。</p>\n<p>已经显示了：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidAppear(_ animated: Bool) &#123;\n    super.viewDidAppear(animated)\n    \n    UIView.animate(withDuration: 0.5, delay: 0.00, options: .curveEaseOut, animations: &#123;\n        \n        self.centerAlignUsername.constant += self.view.bounds.width\n        self.view.layoutIfNeeded()\n    \n        &#125;, completion: nil)\n    \n    UIView.animate(withDuration: 0.5, delay: 0.10, options: .curveEaseOut, animations: &#123;\n        \n        self.centerAlignPassword.constant += self.view.bounds.width\n        self.view.layoutIfNeeded()\n        \n        &#125;, completion: nil)\n    \n    UIView.animate(withDuration: 0.5, delay: 0.20, options: .curveEaseOut, animations: &#123;\n        \n        self.loginButton.alpha = 1\n        \n        &#125;, completion: nil)\n\n&#125;\n</code></pre>\n<p>这是设置3个动画，将三个视图从左边滑出。</p>\n<h2 id=\"3-列表动画\"><a href=\"#3-列表动画\" class=\"headerlink\" title=\"3 列表动画\"></a>3 列表动画</h2><h3 id=\"3-1-效果\"><a href=\"#3-1-效果\" class=\"headerlink\" title=\"3.1 效果\"></a>3.1 效果</h3><img src=AnimateTabel.gif>\n\n<h3 id=\"3-2-第一个列表\"><a href=\"#3-2-第一个列表\" class=\"headerlink\" title=\"3.2 第一个列表\"></a>3.2 第一个列表</h3><p>初始化：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n    super.viewDidLoad()    \n    self.view.backgroundColor = UIColor.black\n    self.tableView.separatorStyle = UITableViewCellSeparatorStyle.none\n    self.tableView.tableFooterView = UIView(frame: CGRect.zero)\n    self.tableView.register(FirstTableCell.self, forCellReuseIdentifier: &quot;tableCell&quot;)\n&#125;\n</code></pre>\n<p>这里绑定了第一个Table的Cell：</p>\n<pre><code class=\"line-numbers language-Swift\">class FirstTableCell: UITableViewCell &#123;\n\n    let gradientLayer = CAGradientLayer()\n    \n    override func awakeFromNib() &#123;\n        super.awakeFromNib()\n    &#125;\n    \n    override func setSelected(_ selected: Bool, animated: Bool) &#123;\n        super.setSelected(selected, animated: animated)\n    &#125;\n    \n    \n    override init(style: UITableViewCellStyle, reuseIdentifier: String?) &#123;\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        \n        gradientLayer.frame = self.bounds\n        let color1 = UIColor(white: 1.0, alpha: 0.2).cgColor as CGColor\n        let color2 = UIColor(white: 1.0, alpha: 0.1).cgColor as CGColor\n        let color3 = UIColor.clear.cgColor as CGColor\n        let color4 = UIColor(white: 0.0, alpha: 0.05).cgColor as CGColor\n        \n        gradientLayer.colors = [color1, color2, color3, color4]\n        gradientLayer.locations = [0.0, 0.04, 0.95, 1.0]\n        layer.insertSublayer(gradientLayer, at: 0)\n    &#125;\n    \n    override func layoutSubviews() &#123;\n        super.layoutSubviews()\n        gradientLayer.frame = self.bounds\n    &#125;\n    \n    required init?(coder aDecoder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n&#125;\n</code></pre>\n<p>这里跟前面类似，设置了渐变背景。通过layer层insertSublayer设置了渐变层实现。</p>\n<p>如何实现动画呢？<br>继续看第一个控制器。</p>\n<p>将要的生命周期：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewWillAppear(_ animated: Bool) &#123;\n    animateTable()\n&#125;\n\nfunc animateTable() &#123;\n        self.tableView.reloadData()\n        let cells = tableView.visibleCells\n        let tableHeight: CGFloat = tableView.bounds.size.height\n        \n        for i in cells &#123;\n            let cell: UITableViewCell = i as UITableViewCell\n            cell.transform = CGAffineTransform(translationX: 0, y: tableHeight)\n        &#125;\n        \n        var index = 0\n        for a in cells &#123;\n            \n            let cell: UITableViewCell = a as UITableViewCell\n            \n            UIView.animate(withDuration: 1.5, delay: 0.05 * Double(index), usingSpringWithDamping: 0.8, initialSpringVelocity: 0, options: [], animations: &#123;\n                \n                cell.transform = CGAffineTransform(translationX: 0, y: 0);\n                \n            &#125;, completion: nil)\n            \n            index += 1\n        &#125;\n    &#125;\n</code></pre>\n<p>这里一个设置了Cell的transform，第一个是从底部初始位置，第二个循环是恢复到目标位置。</p>\n<p>第一个table绑定的代理和数据源：</p>\n<pre><code class=\"line-numbers language-Swift\">override func numberOfSections(in tableView: UITableView) -&gt; Int &#123;\n        return 1\n    &#125;\n    \noverride func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n    return tableData.count\n&#125;\n\noverride func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n    return 60\n&#125;\n\noverride func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n    \n    let cell = tableView.dequeueReusableCell(withIdentifier: &quot;tableCell&quot;, for: indexPath)\n    \n    cell.textLabel?.text = tableData[indexPath.row]\n    cell.textLabel?.textColor = UIColor.white\n    cell.textLabel?.backgroundColor = UIColor.clear\n    cell.textLabel?.font = UIFont(name: &quot;Avenir Next&quot;, size: 18)\n    cell.selectionStyle = UITableViewCellSelectionStyle.none\n    return cell\n&#125;\n\noverride func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) &#123;\n    cell.backgroundColor =  colorforIndex(indexPath.row)\n&#125;\n\noverride func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123;\n    performSegue(withIdentifier: &quot;ShowAnimateTableViewController&quot;, sender: nil)\n&#125;\n\nfunc colorforIndex(_ index: Int) -&gt; UIColor &#123;\n    let itemCount = tableData.count - 1\n    let color = (CGFloat(index) / CGFloat(itemCount)) * 0.6\n    return UIColor(red: color, green: 0.0, blue: 1.0, alpha: 1.0)\n&#125;\n</code></pre>\n<p>这里设置了渐变色，和前面一样。</p>\n<h3 id=\"3-3-第2个列表\"><a href=\"#3-3-第2个列表\" class=\"headerlink\" title=\"3.3 第2个列表\"></a>3.3 第2个列表</h3><p>继承UITableViewController:</p>\n<pre><code class=\"line-numbers language-Swift\">class AnimateTableViewController: UITableViewController &#123;\n</code></pre>\n<p>初始化：</p>\n<pre><code class=\"line-numbers language-Swift\"> override func viewDidLoad() &#123;\n    super.viewDidLoad()\n    \n    self.view.backgroundColor = UIColor.black\n    self.tableView.separatorStyle = UITableViewCellSeparatorStyle.none\n    self.tableView.tableFooterView = UIView(frame: CGRect.zero)\n    self.tableView.register(SecondTableCell.self, forCellReuseIdentifier: &quot;SecondTableCell&quot;)\n&#125;\n</code></pre>\n<p>将要显示：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewWillAppear(_ animated: Bool) &#123;\n    animateTable()\n&#125;\n    \nfunc animateTable() &#123;\n    \n    self.tableView.reloadData()\n    \n    let cells = tableView.visibleCells\n    let tableHeight: CGFloat = tableView.bounds.size.height\n    \n    for (index, cell) in cells.enumerated() &#123;\n        cell.transform = CGAffineTransform(translationX: 0, y: tableHeight)\n        UIView.animate(withDuration: 1.0, delay: 0.05 * Double(index), usingSpringWithDamping: 0.8, initialSpringVelocity: 0, options: [], animations: &#123;\n                cell.transform = CGAffineTransform(translationX: 0, y: 0);\n            &#125;, completion: nil)\n    &#125;\n&#125;\n</code></pre>\n<p>这里设置了显示动画，从底部弹出效果。</p>\n<pre><code class=\"line-numbers language-Swift\">override func numberOfSections(in tableView: UITableView) -&gt; Int &#123;\n        return 1\n    &#125;\n    \noverride func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n    return tableData.count\n&#125;\n\noverride func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n    return 60\n&#125;\n\noverride func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n    \n    let cell = tableView.dequeueReusableCell(withIdentifier: &quot;SecondTableCell&quot;, for: indexPath)\n    \n    cell.textLabel?.text = tableData[indexPath.row]\n    cell.textLabel?.textColor = UIColor.white\n    cell.textLabel?.backgroundColor = UIColor.clear\n    cell.textLabel?.font = UIFont(name: &quot;Avenir Next&quot;, size: 18)\n    cell.selectionStyle = UITableViewCellSelectionStyle.none\n    return cell\n    \n&#125;\n\noverride func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) &#123;\n    cell.backgroundColor =  colorforIndex(indexPath.row)\n&#125;\n\nfunc colorforIndex(_ index: Int) -&gt; UIColor &#123;\n    let itemCount = tableData.count - 1\n    let color = (CGFloat(index) / CGFloat(itemCount)) * 0.6\n    return UIColor(red: 1.0, green: color, blue: 0.0, alpha: 1.0)\n&#125;\n</code></pre>\n<p>这里数据源绑定。还需要一个Cell支持下。<br>SecondTableCell:</p>\n<pre><code class=\"line-numbers language-Swift\">class SecondTableCell: UITableViewCell &#123;\n    \n    let gradientLayer = CAGradientLayer()\n    \n    override func awakeFromNib() &#123;\n        super.awakeFromNib()\n    &#125;\n    \n    override func setSelected(_ selected: Bool, animated: Bool) &#123;\n        super.setSelected(selected, animated: animated)\n    &#125;\n\n    override init(style: UITableViewCellStyle, reuseIdentifier: String?) &#123;\n        super.init(style: style, reuseIdentifier: reuseIdentifier)\n        \n        gradientLayer.frame = self.bounds\n        let color1 = UIColor(white: 1.0, alpha: 0.2).cgColor as CGColor\n        let color2 = UIColor(white: 1.0, alpha: 0.1).cgColor as CGColor\n        let color3 = UIColor.clear.cgColor as CGColor\n        let color4 = UIColor(white: 0.0, alpha: 0.05).cgColor as CGColor\n        \n        gradientLayer.colors = [color1, color2, color3, color4]\n        gradientLayer.locations = [0.0, 0.04, 0.95, 1.0]\n        layer.insertSublayer(gradientLayer, at: 0)\n    &#125;\n    \n    override func layoutSubviews() &#123;\n        super.layoutSubviews()\n        gradientLayer.frame = self.bounds\n    &#125;\n    \n    required init?(coder aDecoder: NSCoder) &#123;\n        fatalError(&quot;init(coder:) has not been implemented&quot;)\n    &#125;\n&#125;\n</code></pre>\n<p>这里和第一个Cell类似。</p>\n<h2 id=\"4-游戏抽奖滚动图案\"><a href=\"#4-游戏抽奖滚动图案\" class=\"headerlink\" title=\"4 游戏抽奖滚动图案\"></a>4 游戏抽奖滚动图案</h2><h3 id=\"4-1-效果\"><a href=\"#4-1-效果\" class=\"headerlink\" title=\"4.1 效果\"></a>4.1 效果</h3><img src=emoji%20spin.gif>\n\n<h3 id=\"4-2-UI\"><a href=\"#4-2-UI\" class=\"headerlink\" title=\"4.2 UI\"></a>4.2 UI</h3><p>这里一个背景图片<br>go按钮<br>中间是UIPickerView，有点像时间滚动条<br>底部模式，结果文案。</p>\n<p>直接在故事版里面拖好了。</p>\n<p>然后拖动3个View到控制器：</p>\n<pre><code class=\"line-numbers language-Swift\">class ViewController: UIViewController &#123;\n\n    @IBOutlet weak var emojiPickerView: UIPickerView!\n    @IBOutlet weak var goButton: UIButton!\n    @IBOutlet weak var resultLabel: UILabel!\n</code></pre>\n<h3 id=\"4-3-Data\"><a href=\"#4-3-Data\" class=\"headerlink\" title=\"4.3 Data\"></a>4.3 Data</h3><pre><code class=\"line-numbers language-Swift\"> var imageArray = [String]()\n    var dataArray1 = [Int]()\n    var dataArray2 = [Int]()\n    var dataArray3 = [Int]()\n    var amazingFlag = false\n    var bounds: CGRect = CGRect.zero\n</code></pre>\n<p>变量声明，等下作为UIPickerView的数据。</p>\n<h3 id=\"4-3-生命周期之viewDidLoad\"><a href=\"#4-3-生命周期之viewDidLoad\" class=\"headerlink\" title=\"4.3 生命周期之viewDidLoad\"></a>4.3 生命周期之viewDidLoad</h3><pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n    super.viewDidLoad()\n    \n    bounds = goButton.bounds\n    imageArray = [&quot;👻&quot;,&quot;👸&quot;,&quot;💩&quot;,&quot;😘&quot;,&quot;🍔&quot;,&quot;🤖&quot;,&quot;🍟&quot;,&quot;🐼&quot;,&quot;🚖&quot;,&quot;🐷&quot;]\n    \n    for _ in 0...100 &#123;\n        self.dataArray1.append((Int)(arc4random() % 10 ))\n        self.dataArray2.append((Int)(arc4random() % 10 ))\n        self.dataArray3.append((Int)(arc4random() % 10 ))\n    &#125;\n    \n    resultLabel.text = &quot;&quot;\n    \n    emojiPickerView.delegate = self\n    emojiPickerView.dataSource = self\n    \n    goButton.layer.cornerRadius = 6\n    goButton.layer.masksToBounds = true\n&#125;\n</code></pre>\n<p>这里生成长度为100的3个数组。本质上存放的0到9个数字。</p>\n<h3 id=\"4-4-将要可见\"><a href=\"#4-4-将要可见\" class=\"headerlink\" title=\"4.4 将要可见\"></a>4.4 将要可见</h3><pre><code class=\"line-numbers language-Swift\">override func viewWillAppear(_ animated: Bool) &#123;\n    super.viewWillAppear(animated)\n    \n    goButton.alpha = 0   \n&#125;\n</code></pre>\n<h3 id=\"4-5-已经可见\"><a href=\"#4-5-已经可见\" class=\"headerlink\" title=\"4.5 已经可见\"></a>4.5 已经可见</h3><pre><code class=\"line-numbers language-Swift\">override func viewDidAppear(_ animated: Bool) &#123;\n    super.viewDidAppear(animated)\n    \n    UIView.animate(withDuration: 0.5, delay: 0.3, options: .curveEaseOut, animations: &#123;\n        \n        self.goButton.alpha = 1\n        \n        &#125;, completion: nil)\n&#125;\n</code></pre>\n<p>底部按钮逐渐显示。</p>\n<h3 id=\"4-6-点击事件\"><a href=\"#4-6-点击事件\" class=\"headerlink\" title=\"4.6 点击事件\"></a>4.6 点击事件</h3><pre><code class=\"line-numbers language-Swift\">@IBAction func amazingButtonDidTouch(_ sender: UIButton) &#123;\n    amazingFlag = !amazingFlag;\n    sender.setTitle(amazingFlag ? &quot;开挂模式&quot;:&quot;常规模式&quot;, for: .normal)\n&#125;\n\n@IBAction func goButtoDidTouch(_ sender: AnyObject) &#123;\n    let index1: Int\n    let index2: Int\n    let index3: Int\n    if amazingFlag &#123;\n        index1 = Int(arc4random()) % 90 + 3\n        index2 = dataArray2.firstIndex(of: dataArray1[index1])!\n        index3 = dataArray3.lastIndex(of: dataArray1[index1])!\n    &#125; else &#123;\n        index1 = Int(arc4random()) % 90 + 3\n        index2 = Int(arc4random()) % 90 + 3\n        index3 = Int(arc4random()) % 90 + 3\n    &#125;\n    \n    /// 下次多少行，开启动画效果\n    emojiPickerView.selectRow(index1, inComponent: 0, animated: true)\n    emojiPickerView.selectRow(index2, inComponent: 1, animated: true)\n    emojiPickerView.selectRow(index3, inComponent: 2, animated: true)\n    \n    /// 结果显示\n    if(dataArray1[emojiPickerView.selectedRow(inComponent: 0)] == dataArray2[emojiPickerView.selectedRow(inComponent: 1)] &amp;&amp; dataArray2[emojiPickerView.selectedRow(inComponent: 1)] == dataArray3[emojiPickerView.selectedRow(inComponent: 2)]) &#123;\n        \n        resultLabel.text = &quot;Bingo!&quot;\n        \n    &#125; else &#123;\n        resultLabel.text = &quot;💔&quot;\n    &#125;\n    \n    /// 底部Go抖动效果\n    UIView.animate(withDuration: 0.5, delay: 0.0, usingSpringWithDamping: 0.1, initialSpringVelocity: 5, options: .curveLinear, animations: &#123;\n        \n        self.goButton.bounds = CGRect(x: self.bounds.origin.x, y: self.bounds.origin.y, width: self.bounds.size.width - 20, height: self.bounds.size.height)\n        \n    &#125;, completion: &#123; (compelete: Bool) in\n        \n        UIView.animate(withDuration: 0.1, delay: 0.0, options: UIViewAnimationOptions(), animations: &#123;\n            \n            self.goButton.bounds = CGRect(x: self.bounds.origin.x, y: self.bounds.origin.y, width: self.bounds.size.width, height: self.bounds.size.height)\n            \n        &#125;, completion: nil)\n        \n    &#125;)\n&#125;\n</code></pre>\n<h2 id=\"5-启动动画\"><a href=\"#5-启动动画\" class=\"headerlink\" title=\"5 启动动画\"></a>5 启动动画</h2><h3 id=\"5-1-效果\"><a href=\"#5-1-效果\" class=\"headerlink\" title=\"5.1 效果\"></a>5.1 效果</h3><img src=splash.gif>\n\n<h3 id=\"5-2-启动页\"><a href=\"#5-2-启动页\" class=\"headerlink\" title=\"5.2 启动页\"></a>5.2 启动页</h3><p>启动页需要再info.plist中配置<br>如下：<br><img src=25_1.png></p>\n<p>这里我们在LaunchScreen.storyboard中设置了一个背景图片。<br>这里面设置了一张白色的🕊没有效果哦。但是之前有，不知道为啥。</p>\n<h3 id=\"5-3-首页\"><a href=\"#5-3-首页\" class=\"headerlink\" title=\"5.3 首页\"></a>5.3 首页</h3><p>首页其实加了一个同启动页的蓝色背景，中间减掉一个白鸽，然后白鸽再扩展的动画。<br>这个背景是在故事版的View右侧属性里面的Background中设置的。</p>\n<p>设置蒙层：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n    super.viewDidLoad()\n    // Do any additional setup after loading the view, typically from a nib.\n    \n    self.mask = CALayer()\n    self.mask!.contents = UIImage(named: &quot;twitter&quot;)?.cgImage\n    self.mask!.contentsGravity = kCAGravityResizeAspect\n    self.mask!.bounds = CGRect(x: 0, y: 0, width: 100, height: 81)\n    self.mask!.anchorPoint = CGPoint(x: 0.5, y: 0.5)\n    self.imageView.setNeedsLayout()\n    self.imageView.layoutIfNeeded()\n    self.mask!.position = CGPoint(x: self.imageView.frame.size.width / 2, y: self.imageView.frame.size.height / 2)\n    self.imageView.layer.mask = mask\n    \n    animateMask()\n&#125;\n</code></pre>\n<p>这里给到imageView的layer的mask，这样就相当于在蓝色背景中镂空可以看到里面的东西了。</p>\n<pre><code class=\"line-numbers language-Swift\">func animateMask() &#123;\n    let keyFrameAnimation = CAKeyframeAnimation(keyPath: &quot;bounds&quot;)\n    keyFrameAnimation.delegate = self\n    keyFrameAnimation.duration = 0.6\n    keyFrameAnimation.beginTime = CACurrentMediaTime() + 0.5\n    keyFrameAnimation.timingFunctions = [CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut), CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut)]\n    do &#123;\n        // 动画需要加上这段代码，否则会造成页面闪一下\n        keyFrameAnimation.fillMode = kCAFillModeForwards\n        keyFrameAnimation.isRemovedOnCompletion = false\n    &#125;\n    let initalBounds = NSValue(cgRect: mask!.bounds)\n    let secondBounds = NSValue(cgRect: CGRect(x: 0, y: 0, width: 90*0.9, height: 73*0.9))\n    let finalBounds = NSValue(cgRect: CGRect(x: 0, y: 0, width: 1600, height: 1300))\n    keyFrameAnimation.values = [initalBounds, secondBounds, finalBounds]\n    keyFrameAnimation.keyTimes = [0, 0.3, 1]\n    self.mask!.add(keyFrameAnimation, forKey: &quot;bounds&quot;)\n&#125;\n</code></pre>\n<p>这个动画的作用是将镂空效果爆炸，显示出主页面。</p>\n<p>动画停止后需要去除蒙层哦：</p>\n<pre><code class=\"line-numbers language-Swift\">extension ViewController : CAAnimationDelegate &#123;\n    func animationDidStop(_ anim: CAAnimation, finished flag: Bool) &#123;\n        self.imageView.layer.mask = nil\n    &#125;\n&#125;\n</code></pre>\n<p>动画结束，需要将蒙层去掉，不然屏幕上方会多出一块多余的遮挡视图。</p>\n<h2 id=\"6-滑动菜单\"><a href=\"#6-滑动菜单\" class=\"headerlink\" title=\"6 滑动菜单\"></a>6 滑动菜单</h2><h3 id=\"6-1-效果\"><a href=\"#6-1-效果\" class=\"headerlink\" title=\"6.1 效果\"></a>6.1 效果</h3><img src=SlideMenu.gif>\n\n<h3 id=\"6-2-首页\"><a href=\"#6-2-首页\" class=\"headerlink\" title=\"6.2 首页\"></a>6.2 首页</h3><pre><code class=\"line-numbers language-Swift\">class NewsTableViewController: BaseTableViewController &#123;\n    let menuTransitionManager = MenuTransitionManager()\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n\n        self.title = &quot;Everyday Moments&quot;\n        self.view.backgroundColor = UIColor(red:0.062, green:0.062, blue:0.07, alpha:1)\n    &#125;\n    \n    override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123;\n        let menuTableViewController = segue.destination as! MenuTableViewController\n        menuTableViewController.currentItem = self.title!\n        menuTableViewController.transitioningDelegate = menuTransitionManager\n        menuTransitionManager.delegate = self\n    &#125;\n&#125;\n</code></pre>\n<p>这里有一个prepare方法，实际上是跳转到其它页面前会执行。<br>我们在故事版里面定义了跳转关系，这里就可以通过prepare方法拿到跳转的目标控制器了。</p>\n<p>这是一个新闻的列表页。<br>这里首先继承了BaseTableViewController:</p>\n<pre><code class=\"line-numbers language-Swift\">class BaseTableViewController: UITableViewController &#123;\n    \n    override var preferredStatusBarStyle: UIStatusBarStyle &#123;\n        return UIStatusBarStyle.lightContent\n    &#125;\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        self.tableView.separatorStyle = UITableViewCellSeparatorStyle.none\n    &#125;\n&#125;\n</code></pre>\n<p>然后这里有一个MenuTransitionManager,是我们自定义的一个类：<br>个人猜测这个Transition相关的应该是为了实现一个转场动画，实现菜单能够丝滑地顶下来吧。<br>里面放了一个自己定义的协议MenuTransitionManagerDelegate:</p>\n<pre><code class=\"line-numbers language-Swift\">@objc protocol MenuTransitionManagerDelegate &#123;\n    func dismiss()\n&#125;\n\nclass MenuTransitionManager: NSObject &#123;\n    var duration = 0.5\n    var isPresenting = false\n    var delegate:MenuTransitionManagerDelegate?\n    var snapshot:UIView? &#123;\n        didSet &#123;\n            if let _delegate = delegate &#123;\n                let tapGestureRecognizer = UITapGestureRecognizer(target: _delegate, action: #selector(MenuTransitionManagerDelegate.dismiss))\n                snapshot?.addGestureRecognizer(tapGestureRecognizer)\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>然后扩展了一个UIViewControllerAnimatedTransitioning，<br>这个应该是系统的协议：</p>\n<pre><code class=\"line-numbers language-Swift\">extension MenuTransitionManager : UIViewControllerAnimatedTransitioning &#123;\n    func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval &#123;\n        return duration\n    &#125;\n    \n    func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123;\n        let fromView = transitionContext.view(forKey: .from)!\n        let toView = transitionContext.view(forKey: .to)!\n        let container = transitionContext.containerView\n        let moveLeft = CGAffineTransform(translationX: 250, y: 0)\n        let moveRight = CGAffineTransform(translationX: 0, y: 0)\n        \n        if isPresenting &#123;\n            snapshot = fromView.snapshotView(afterScreenUpdates: true)\n            container.addSubview(toView)\n            container.addSubview(snapshot!)\n        &#125;\n        \n        UIView.animate(withDuration: duration, delay: 0.0, usingSpringWithDamping: 0.9, initialSpringVelocity: 0.3, options: .curveEaseInOut, animations: &#123;\n            if self.isPresenting &#123;\n                self.snapshot?.transform = moveLeft\n                toView.transform = .identity\n            &#125; else &#123;\n                self.snapshot?.transform = .identity\n                fromView.transform = moveRight\n            &#125;\n            \n        &#125;, completion: &#123; finished in\n            transitionContext.completeTransition(true)\n            if !self.isPresenting &#123;\n                self.snapshot?.removeFromSuperview()\n            &#125;\n        &#125;)\n    &#125;\n&#125;\n</code></pre>\n<p>同时也扩展了UIViewControllerTransitioningDelegate,也是系统的：</p>\n<pre><code class=\"line-numbers language-Swift\">extension MenuTransitionManager : UIViewControllerTransitioningDelegate &#123;\n    func animationController(forDismissed dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;\n        isPresenting = false\n        return self\n    &#125;\n    \n    func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;\n        isPresenting = true\n        return self\n    &#125;\n&#125;\n</code></pre>\n<p>再看下首页新闻展示的代理和数据源：</p>\n<pre><code class=\"line-numbers language-Swift\">extension NewsTableViewController &#123;\n    // MARK: UITableViewDataSource\n    override func numberOfSections(in tableView: UITableView) -&gt; Int &#123;\n        return 3\n    &#125;\n    \n    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n        return 4\n    &#125;\n    \n    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n        let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) as! NewsTableViewCell\n        cell.backgroundColor = UIColor.clear\n        \n        if indexPath.row == 0 &#123;\n            cell.postImageView.image = UIImage(named: &quot;1&quot;)\n            cell.postTitle.text = &quot;Love mountain.&quot;\n            cell.postAuthor.text = &quot;Allen Wang&quot;\n            cell.authorImageView.image = UIImage(named: &quot;a&quot;)\n            \n        &#125; else if indexPath.row == 1 &#123;\n            cell.postImageView.image = UIImage(named: &quot;2&quot;)\n            cell.postTitle.text = &quot;New graphic design - LIVE FREE&quot;\n            cell.postAuthor.text = &quot;Cole&quot;\n            cell.authorImageView.image = UIImage(named: &quot;b&quot;)\n            \n        &#125; else if indexPath.row == 2 &#123;\n            cell.postImageView.image = UIImage(named: &quot;3&quot;)\n            cell.postTitle.text = &quot;Summer sand&quot;\n            cell.postAuthor.text = &quot;Daniel Hooper&quot;\n            cell.authorImageView.image = UIImage(named: &quot;c&quot;)\n            \n        &#125; else &#123;\n            cell.postImageView.image = UIImage(named: &quot;4&quot;)\n            cell.postTitle.text = &quot;Seeking for signal&quot;\n            cell.postAuthor.text = &quot;Noby-Wan Kenobi&quot;\n            cell.authorImageView.image = UIImage(named: &quot;d&quot;)\n            \n        &#125;\n        \n        return cell\n    &#125;\n&#125;\n</code></pre>\n<p>这里每行能够正常展示了。Cell用了自定义的NewsTableViewCell:</p>\n<pre><code class=\"line-numbers language-Swift\">class NewsTableViewCell: UITableViewCell &#123;\n    @IBOutlet weak var postImageView:UIImageView!\n    @IBOutlet weak var postTitle:UILabel!\n    @IBOutlet weak var postAuthor:UILabel!\n    @IBOutlet weak var authorImageView:UIImageView!\n\n    override func awakeFromNib() &#123;\n        super.awakeFromNib()\n        authorImageView.layer.cornerRadius = authorImageView.frame.width / 2\n        authorImageView.layer.masksToBounds = true\n    &#125;\n\n    override func setSelected(_ selected: Bool, animated: Bool) &#123;\n        super.setSelected(selected, animated: animated)\n\n        // Configure the view for the selected state\n    &#125;\n&#125;\n</code></pre>\n<p>具体布局还是故事版里面处理的布局。</p>\n<p>然后让首页也实现我们自定义的MenuTransitionManagerDelegate 转场代理吧：</p>\n<pre><code class=\"line-numbers language-Swift\">extension NewsTableViewController : MenuTransitionManagerDelegate &#123;\n    func dismiss() &#123;\n        dismiss(animated: true, completion: nil)\n    &#125;\n&#125;\n</code></pre>\n<p>这里猜测是点击空白区域，菜单dismiss吧。</p>\n<h3 id=\"6-3-菜单控制器\"><a href=\"#6-3-菜单控制器\" class=\"headerlink\" title=\"6.3 菜单控制器\"></a>6.3 菜单控制器</h3><pre><code class=\"line-numbers language-Swift\">class MenuTableViewController: BaseTableViewController &#123;\n    var menuItems = [&quot;Everyday Moments&quot;, &quot;Popular&quot;, &quot;Editors&quot;, &quot;Upcoming&quot;, &quot;Fresh&quot;, &quot;Stock-photos&quot;, &quot;Trending&quot;]\n    var currentItem = &quot;Everyday Moments&quot;\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        self.view.backgroundColor = UIColor(red:0.109, green:0.114, blue:0.128, alpha:1)\n    &#125;\n    \n    // 这里prepare去掉效果一样\n    override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123;\n        let menuTableViewController = segue.source as! MenuTableViewController\n        \n        if let selectedRow = menuTableViewController.tableView.indexPathForSelectedRow?.row &#123;\n            currentItem = menuItems[selectedRow]\n        &#125;\n    &#125;\n&#125;\n\nextension MenuTableViewController &#123;\n    // MARK: UITableViewDataSource\n    override func numberOfSections(in tableView: UITableView) -&gt; Int &#123;\n        return 1\n    &#125;\n    \n    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n        return menuItems.count\n    &#125;\n    \n    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n        let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) as! MenuTableViewCell\n        \n        cell.titleLabel.text = menuItems[indexPath.row]\n        cell.titleLabel.textColor = (menuItems[indexPath.row] == currentItem) ? UIColor.white : UIColor.gray\n        cell.backgroundColor = UIColor.clear\n        return cell\n    &#125;\n&#125;\n</code></pre>\n<p>这里实现了菜单列表显示。</p>\n<p>菜单Cell如下：</p>\n<pre><code class=\"line-numbers language-Swift\">class MenuTableViewCell: UITableViewCell &#123;\n\n    @IBOutlet weak var titleLabel:UILabel!\n    \n    override func awakeFromNib() &#123;\n        super.awakeFromNib()\n        // Initialization code\n    &#125;\n\n    override func setSelected(_ selected: Bool, animated: Bool) &#123;\n        super.setSelected(selected, animated: animated)\n\n        // Configure the view for the selected state\n    &#125;\n\n&#125;\n</code></pre>\n<h2 id=\"7-酷炫左右缩放菜单\"><a href=\"#7-酷炫左右缩放菜单\" class=\"headerlink\" title=\"7 酷炫左右缩放菜单\"></a>7 酷炫左右缩放菜单</h2><h3 id=\"7-1-效果\"><a href=\"#7-1-效果\" class=\"headerlink\" title=\"7.1 效果\"></a>7.1 效果</h3><img src=TumblrMenu.gif>\n\n<h3 id=\"7-2-首页\"><a href=\"#7-2-首页\" class=\"headerlink\" title=\"7.2 首页\"></a>7.2 首页</h3><pre><code class=\"line-numbers language-Swift\">class MainViewController: BaseViewController &#123;\n\n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        self.navigationController?.isNavigationBarHidden = true\n    &#125;\n\n    override func didReceiveMemoryWarning() &#123;\n        super.didReceiveMemoryWarning()\n    &#125;\n    \n    @IBAction func unwindToMainViewController (_ sender: UIStoryboardSegue)&#123;\n        self.dismiss(animated: true, completion: nil)\n    &#125;\n&#125;\n</code></pre>\n<p>这里的unwindToMainViewController 是我们自行在故事版拖进来的，这样子在这个控制器里面的点击事件也可以处理的。<br>这里就是dismiss弹框。<br>其它ui是我们自己拖到故事版里面的。</p>\n<h3 id=\"7-3-菜单页\"><a href=\"#7-3-菜单页\" class=\"headerlink\" title=\"7.3 菜单页\"></a>7.3 菜单页</h3><p>菜单页是由一个UIVisualEffectView的父布局包裹的。<br>这个故事版的Scene绑定的class为MenuViewController。</p>\n<pre><code class=\"line-numbers language-Swift\">class MenuViewController: BaseViewController &#123;\n    \n    let transitionManager = MenuTransitionManager()\n    \n    @IBOutlet weak var textButton: UIButton!\n    @IBOutlet weak var textLabel: UILabel!\n    \n    @IBOutlet weak var photoButton: UIButton!\n    @IBOutlet weak var photoLabel: UILabel!\n    \n    @IBOutlet weak var quoteButton: UIButton!\n    @IBOutlet weak var quoteLabel: UILabel!\n    \n    @IBOutlet weak var linkButton: UIButton!\n    @IBOutlet weak var linkLabel: UILabel!\n    \n    @IBOutlet weak var chatButton: UIButton!\n    @IBOutlet weak var chatLabel: UILabel!\n    \n    @IBOutlet weak var audioButton: UIButton!\n    @IBOutlet weak var audioLabel: UILabel!\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        self.transitioningDelegate = self.transitionManager\n    &#125;\n\n    override func didReceiveMemoryWarning() &#123;\n        super.didReceiveMemoryWarning()\n    &#125;\n&#125;\n</code></pre>\n<p>这里声明了，布局效果在故事版里面拖动的。</p>\n<p>注意了这里self的transitiningDelegate设置了转场动画。</p>\n<p>也是我们自己定义的一个类：</p>\n<pre><code class=\"line-numbers language-Swift\">\nclass MenuTransitionManager: NSObject &#123;\n\n    private var presenting = false\n\n    func offstage(_ amount: CGFloat) -&gt; CGAffineTransform &#123;\n        return CGAffineTransform(translationX: amount, y: 0)\n    &#125;\n    \n    func offStageMenuController(_ menuViewController: MenuViewController) &#123;\n        if !presenting&#123;\n            menuViewController.view.alpha = 0\n        &#125;\n        let topRowOffset  : CGFloat = 300\n        let middleRowOffset : CGFloat = 150\n        let bottomRowOffset  : CGFloat = 50\n        \n        menuViewController.textButton.transform = self.offstage(-topRowOffset)\n        menuViewController.textLabel.transform = self.offstage(-topRowOffset)\n        \n        menuViewController.quoteButton.transform = self.offstage(-middleRowOffset)\n        menuViewController.quoteLabel.transform = self.offstage(-middleRowOffset)\n        \n        menuViewController.chatButton.transform = self.offstage(-bottomRowOffset)\n        menuViewController.chatLabel.transform = self.offstage(-bottomRowOffset)\n        \n        menuViewController.photoButton.transform = self.offstage(topRowOffset)\n        menuViewController.photoLabel.transform = self.offstage(topRowOffset)\n        \n        menuViewController.linkButton.transform = self.offstage(middleRowOffset)\n        menuViewController.linkLabel.transform = self.offstage(middleRowOffset)\n        \n        menuViewController.audioButton.transform = self.offstage(bottomRowOffset)\n        menuViewController.audioLabel.transform = self.offstage(bottomRowOffset)\n        \n    &#125;\n    \n    func onStageMenuController(_ menuViewController: MenuViewController) &#123;\n        menuViewController.view.alpha = 1\n        \n        menuViewController.textButton.transform = .identity\n        menuViewController.textLabel.transform = .identity\n        menuViewController.quoteButton.transform = .identity\n        menuViewController.quoteLabel.transform = .identity\n        menuViewController.chatButton.transform = .identity\n        menuViewController.chatLabel.transform = .identity\n        menuViewController.photoButton.transform = .identity\n        menuViewController.photoLabel.transform = .identity\n        menuViewController.linkButton.transform = .identity\n        menuViewController.linkLabel.transform = .identity\n        menuViewController.audioButton.transform = .identity\n        menuViewController.audioLabel.transform = .identity\n        \n    &#125;\n&#125;\n</code></pre>\n<p>可以看到这里主要是针对里面控制器的ui的transform做了一些配置。</p>\n<p>然后这个管理员实现了UIViewControllerTransitioningDelegate代理：</p>\n<pre><code class=\"line-numbers language-Swift\">extension MenuTransitionManager : UIViewControllerTransitioningDelegate &#123;\n    func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;\n        self.presenting = true\n        return self\n    &#125;\n    \n    func animationController(forDismissed dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;\n        self.presenting = false\n        return self\n    &#125;\n&#125;\n</code></pre>\n<p>同样也实现了UIViewControllerAnimatedTransitioning这个协议：</p>\n<pre><code class=\"line-numbers language-Swift\">extension MenuTransitionManager : UIViewControllerAnimatedTransitioning &#123;\n    \n    func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval &#123;\n        return 0.5\n    &#125;\n    \n    func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123;\n        let container = transitionContext.containerView\n        let screens: (from:UIViewController, to:UIViewController) = (transitionContext.viewController(forKey: .from)!, transitionContext.viewController(forKey: .to)!)\n        \n        let menuViewController = !self.presenting ? screens.from as! MenuViewController : screens.to as! MenuViewController\n        let bottomViewController = !self.presenting ? screens.to as UIViewController : screens.from as UIViewController\n        \n        let menuView: UIView! = menuViewController.view\n        let bottomView: UIView! = bottomViewController.view\n        \n        if (self.presenting) &#123;\n             self.offStageMenuController(menuViewController)\n        &#125;\n        container.addSubview(bottomView)\n        container.addSubview(menuView)\n        \n        let duration = self.transitionDuration(using: transitionContext)\n        \n        UIView.animate(withDuration: duration, delay: 0.0, usingSpringWithDamping: 0.7, initialSpringVelocity: 0.8, options: [], animations: &#123;\n            if (self.presenting) &#123;\n                 self.onStageMenuController(menuViewController)\n            &#125; else &#123;\n                self.offStageMenuController(menuViewController)\n            &#125;\n        &#125;, completion: &#123; finished in\n            transitionContext.completeTransition(true)\n            UIApplication.shared.keyWindow!.addSubview(screens.to.view)\n        &#125;)\n    &#125;\n&#125;\n</code></pre>\n<p>主要是动画执行的时候，走了self.onStageMenuController方法或者self.offStageMenuController这个方法实现动画效果。</p>\n<h2 id=\"8-限制字符串\"><a href=\"#8-限制字符串\" class=\"headerlink\" title=\"8 限制字符串\"></a>8 限制字符串</h2><h3 id=\"8-1-效果\"><a href=\"#8-1-效果\" class=\"headerlink\" title=\"8.1 效果\"></a>8.1 效果</h3><img src=Limit.gif>\n\n<h3 id=\"8-2-UI\"><a href=\"#8-2-UI\" class=\"headerlink\" title=\"8.2 UI\"></a>8.2 UI</h3><p>这里也是先构造一个故事版。<br>左上角：Close按钮。<br>右上角：Tweet按钮。<br>头像：Avatar Image VIew。<br>底部View: 4个Button<br>编辑框：UITextView</p>\n<img src=18_1.png>\n\n<p>控制器要用的：</p>\n<pre><code class=\"line-numbers language-Swift\">class ViewController: UIViewController &#123;\n\n    @IBOutlet weak var tweetTextView: UITextView!\n    @IBOutlet weak var bottomUIView: UIView!\n    @IBOutlet weak var avatarImageView: UIImageView!\n    @IBOutlet weak var characterCountLabel: UILabel!\n</code></pre>\n<p>初始化生命周期：</p>\n<pre><code class=\"line-numbers language-Swift\">    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        tweetTextView.delegate = self\n        avatarImageView.layer.cornerRadius = avatarImageView.frame.width / 2\n        tweetTextView.backgroundColor = UIColor.clear\n        \n        NotificationCenter.default.addObserver(self, selector:#selector(ViewController.keyBoardWillShow(_:)), name:UIResponder.keyboardWillShowNotification, object: nil)\n        NotificationCenter.default.addObserver(self, selector:#selector(ViewController.keyBoardWillHide(_:)), name:UIResponder.keyboardWillHideNotification, object: nil)\n    &#125;\n</code></pre>\n<p>这里配置了UITextView的代理为自己，后面一定会实现相关方法的。</p>\n<p>然后这里监听了键盘显示和隐藏哦。<br>主要是将底部的控制栏跟随键盘上下顶起来。</p>\n<pre><code class=\"line-numbers language-Swift\">@objc func keyBoardWillShow(_ note:NSNotification) &#123;\n    let userInfo  = note.userInfo\n    let keyBoardBounds = (userInfo![UIResponder.keyboardFrameEndUserInfoKey] as! NSValue).cgRectValue\n    let duration = (userInfo![UIResponder.keyboardAnimationDurationUserInfoKey] as! NSNumber).doubleValue\n    let deltaY = keyBoardBounds.size.height\n    let animations = &#123;\n        self.bottomUIView.transform = CGAffineTransform(translationX: 0, y: -deltaY)\n    &#125;\n    \n    if duration &gt; 0 &#123;\n        // 莫名其妙的一段代码, 左移16位能看出来是个啥值吗\n        // let options = UIView.AnimationOptions(rawValue: UInt((userInfo![UIResponder.keyboardAnimationCurveUserInfoKey] as! NSNumber).intValue &lt;&lt; 16))\n        UIView.animate(withDuration: duration, delay: 0, options:[.beginFromCurrentState, .curveLinear], animations: animations, completion: nil)\n    &#125;else &#123;\n        animations()\n    &#125;\n&#125;\n</code></pre>\n<p>上面的代码是为了在键盘弹出的时候，底部bottomUIView跟随键盘顶起来。</p>\n<pre><code class=\"line-numbers language-Swift\">@objc func keyBoardWillHide(_ note:NSNotification) &#123;\n    let userInfo  = note.userInfo\n    let duration = (userInfo![UIResponder.keyboardAnimationDurationUserInfoKey] as! NSNumber).doubleValue\n    \n    let animations = &#123;\n        self.bottomUIView.transform = .identity\n    &#125;\n    \n    if duration &gt; 0 &#123;\n        // let options = UIView.AnimationOptions(rawValue: UInt((userInfo![UIResponder.keyboardAnimationCurveUserInfoKey] as! NSNumber).intValue &lt;&lt; 16))\n        UIView.animate(withDuration: duration, delay: 0, options:[.beginFromCurrentState, .curveLinear], animations: animations, completion: nil)\n    &#125;else&#123;\n        animations()\n    &#125;\n    \n&#125;\n</code></pre>\n<p>上面的代码是为了在键盘隐藏的时候，底部bottomUIView也随之落下去。</p>\n<p>然后编辑框的代理如下：</p>\n<pre><code class=\"line-numbers language-Swift\">extension ViewController : UITextViewDelegate &#123;\n    // MARK:UITextViewDelegate\n    func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -&gt; Bool &#123;\n        let inputTextLength = text.count - range.length + tweetTextView.text.count\n        if inputTextLength &gt; 140 &#123;\n            return false\n        &#125;\n        characterCountLabel.text = &quot;\\(140 - inputTextLength)&quot;\n        return true\n    &#125;\n&#125;\n</code></pre>\n<p>这里是为了统计当前剩余字符，如果不足，则无法继续输入。</p>\n<h2 id=\"9-自定义下拉刷新\"><a href=\"#9-自定义下拉刷新\" class=\"headerlink\" title=\"9 自定义下拉刷新\"></a>9 自定义下拉刷新</h2><h3 id=\"9-1-效果\"><a href=\"#9-1-效果\" class=\"headerlink\" title=\"9.1 效果\"></a>9.1 效果</h3><img src=CustomPullToRefresh.gif>\n\n<h3 id=\"9-2-变量定义\"><a href=\"#9-2-变量定义\" class=\"headerlink\" title=\"9.2 变量定义\"></a>9.2 变量定义</h3><pre><code class=\"line-numbers language-Swift\">    var refreshController: UIRefreshControl!\n    var customView: UIView!\n    var labelsArray: Array&lt;UILabel&gt; = []\n    var isAnimating = false\n    var currentColorIndex = 0\n    var currentLabelIndex = 0\n    var timer: Timer!\n    var dataArray: Array&lt;String&gt; = [&quot;😂&quot;, &quot;🤗&quot;, &quot;😳&quot;, &quot;😌&quot;, &quot;😊&quot;]\n</code></pre>\n<p>这里第一个就是刷新控制器了，应该主要就是往这里面加逻辑。</p>\n<h3 id=\"9-3-初始化\"><a href=\"#9-3-初始化\" class=\"headerlink\" title=\"9.3 初始化\"></a>9.3 初始化</h3><pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n    super.viewDidLoad()\n    \n    tblDemo.delegate = self\n    tblDemo.dataSource = self\n    refreshController = UIRefreshControl()\n    refreshController.backgroundColor = UIColor.clear\n    refreshController.tintColor = UIColor.clear\n    tblDemo.addSubview(refreshController)\n    \n    loadCustomRefreshContents()\n&#125;\n</code></pre>\n<p>这里设置了代理和数据源，new了一个刷新控制器，清空背景，给tableView添加了一个子View。</p>\n<p>下面加载自定义xib文件：</p>\n<pre><code class=\"line-numbers language-Swift\"> func loadCustomRefreshContents() &#123;\n        \n    let refreshContents = Bundle.main.loadNibNamed(&quot;RefreshContents&quot;, owner: self, options: nil)\n    \n    customView = refreshContents![0] as? UIView\n    customView.frame = refreshController.bounds\n    \n    for i in 0..&lt;customView.subviews.count &#123;\n        labelsArray.append(customView.viewWithTag(i + 1) as! UILabel)\n    &#125;\n    \n    refreshController.addSubview(customView)\n&#125;\n</code></pre>\n<p>这个布局里面主要是存放了我们自定义头部的View。</p>\n<h3 id=\"9-4-数据源和代理\"><a href=\"#9-4-数据源和代理\" class=\"headerlink\" title=\"9.4 数据源和代理\"></a>9.4 数据源和代理</h3><pre><code class=\"line-numbers language-Swift\">extension ViewController : UITableViewDelegate &#123;\n    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123;\n        \n    &#125;\n    \n    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n        return 80\n    &#125;\n&#125;\n\nextension ViewController : UITableViewDataSource &#123;\n    \n    func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int &#123;\n        return 1\n    &#125;\n    \n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n        return dataArray.count\n    &#125;\n    \n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n        let cell = tableView.dequeueReusableCell(withIdentifier: &quot;idCell&quot;, for: indexPath)\n        \n        cell.textLabel!.text = dataArray[indexPath.row]\n        cell.textLabel!.font = UIFont(name: &quot;Apple Color Emoji&quot;, size: 40)\n        cell.textLabel!.textAlignment = .center\n        \n        return cell\n    &#125;\n&#125;\n</code></pre>\n<p>这里cell用默认的。</p>\n<h3 id=\"9-5-下拉动画实现\"><a href=\"#9-5-下拉动画实现\" class=\"headerlink\" title=\"9.5 下拉动画实现\"></a>9.5 下拉动画实现</h3><p>首先实现UIScrollViewDelegate代理：</p>\n<pre><code class=\"line-numbers language-Swift\">extension ViewController : UIScrollViewDelegate &#123;\n    func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) &#123;\n        if refreshController.isRefreshing &#123;\n            if !isAnimating &#123;\n                doSomething()\n                animateRefreshStep1()\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>如果没有在刷新中，没有在动画中，就做点失去，然后走动画第一步。</p>\n<pre><code class=\"line-numbers language-Swift\">func doSomething() &#123;\n    timer = Timer.scheduledTimer(timeInterval: 5, target: self, selector: #selector(ViewController.endedOfWork), userInfo: nil, repeats: true)\n&#125;\n</code></pre>\n<p>这里开启定时器，5s后才走endedofWork。</p>\n<pre><code class=\"line-numbers language-Swift\">@objc func endedOfWork() &#123;\n    refreshController.endRefreshing()\n    timer.invalidate()\n    timer = nil\n&#125;\n</code></pre>\n<p>这里停止刷新，定时器结束。<br>说明上面的doSomething只是开启一个定时器，模拟进行网络请求，然后加载动画而已。</p>\n<p>动画第一步：</p>\n<pre><code class=\"line-numbers language-Swift\">func animateRefreshStep1() &#123;\n    isAnimating = true\n    \n    UIView.animate(withDuration: 0.1, delay: 0.0, options: .curveLinear, animations: &#123;\n        self.labelsArray[self.currentLabelIndex].transform = CGAffineTransform(rotationAngle: CGFloat(Double.pi/4))\n        self.labelsArray[self.currentLabelIndex].textColor = self.getNextColor()\n        &#125;, completion: &#123; _ in\n            UIView.animate(withDuration: 0.05, delay: 0.0, options: .curveLinear, animations: &#123;\n                self.labelsArray[self.currentLabelIndex].transform = .identity\n                self.labelsArray[self.currentLabelIndex].textColor = UIColor.black\n                &#125;, completion: &#123; _ in\n                    self.currentLabelIndex += 1\n                    if self.currentLabelIndex &lt; self.labelsArray.count &#123;\n                        self.animateRefreshStep1()\n                    &#125;else &#123;\n                        self.animateRefreshStep2()\n                    &#125;\n            &#125;)\n    &#125;)\n&#125;\n\nfunc getNextColor() -&gt; UIColor &#123;\n    var colorsArray: Array&lt;UIColor&gt; = [.magenta, .brown, .yellow,\n                                        .red, .green, .blue, .orange]\n    if currentColorIndex == colorsArray.count &#123;\n        currentColorIndex = 0\n    &#125;\n    let returnColor = colorsArray[currentColorIndex]\n    currentColorIndex += 1\n    return returnColor\n&#125;\n</code></pre>\n<p>这里开启动画了，给子View配置transform和textColor。<br>递归走每一个子View动画，走完后走动画第二步：</p>\n<pre><code class=\"line-numbers language-Swift\">func animateRefreshStep2() &#123;\n    UIView.animate(withDuration: 0.40, delay: 0.0, options: .curveLinear, animations: &#123;\n        let scale = CGAffineTransform(scaleX: 1.5, y: 1.5)\n        self.labelsArray[1].transform = scale\n        self.labelsArray[2].transform = scale\n        self.labelsArray[3].transform = scale\n        self.labelsArray[4].transform = scale\n        self.labelsArray[5].transform = scale\n        self.labelsArray[6].transform = scale\n        self.labelsArray[7].transform = scale\n        self.labelsArray[8].transform = scale\n        self.labelsArray[9].transform = scale\n        self.labelsArray[10].transform = scale\n        self.labelsArray[11].transform = scale\n        \n        &#125;, completion: &#123; _ in\n            UIView.animate(withDuration: 0.25, delay: 0.0, options: .curveLinear, animations: &#123;\n                self.labelsArray[0].transform = .identity\n                self.labelsArray[1].transform = .identity\n                self.labelsArray[2].transform = .identity\n                self.labelsArray[3].transform = .identity\n                self.labelsArray[4].transform = .identity\n                self.labelsArray[5].transform = .identity\n                self.labelsArray[6].transform = .identity\n                self.labelsArray[7].transform = .identity\n                self.labelsArray[8].transform = .identity\n                self.labelsArray[9].transform = .identity\n                self.labelsArray[10].transform = .identity\n                self.labelsArray[11].transform = .identity\n                \n                &#125;, completion: &#123; _ in\n                    if self.refreshController.isRefreshing &#123;\n                        self.currentLabelIndex = 0\n                        self.animateRefreshStep1()\n                    &#125; else &#123;\n                        self.isAnimating = false\n                        self.currentLabelIndex = 0\n                        for i in 0 ..&lt; self.labelsArray.count &#123;\n                            self.labelsArray[i].textColor = UIColor.black\n                            self.labelsArray[i].transform = .identity\n                        &#125;\n                    &#125;\n            &#125;)\n    &#125;)\n&#125;\n</code></pre>\n<h2 id=\"10-CollectionView动画\"><a href=\"#10-CollectionView动画\" class=\"headerlink\" title=\"10 CollectionView动画\"></a>10 CollectionView动画</h2><h3 id=\"10-1-效果\"><a href=\"#10-1-效果\" class=\"headerlink\" title=\"10.1 效果\"></a>10.1 效果</h3><img src=CollectionViewAnimation.gif>\n\n<h3 id=\"10-2-首页\"><a href=\"#10-2-首页\" class=\"headerlink\" title=\"10.2 首页\"></a>10.2 首页</h3><p>Main.storyboard里面放置了一个UICollectionView。</p>\n<p>里面放置了2个结构体：</p>\n<pre><code class=\"line-numbers language-Swift\">private struct Storyboard &#123;\n    static let CellIdentifier = &quot;AnimationCollectionViewCell&quot;\n    static let NibName = &quot;AnimationCollectionViewCell&quot;\n&#125;\n    \nprivate struct Constants &#123;\n    static let AnimationDuration: Double = 0.5\n    static let AnimationDelay: Double = 0.0\n    static let AnimationSpringDamping: CGFloat = 1.0\n    static let AnimationInitialSpringVelocity: CGFloat = 1.0\n&#125;\n</code></pre>\n<p>成员定义：</p>\n<pre><code class=\"line-numbers language-Swift\">@IBOutlet var testCollectionView: UICollectionView!\n\nvar imageCollection: AnimationImageCollection!\n</code></pre>\n<p>第一个是拖过来的，第二个是自定义的：</p>\n<pre><code class=\"line-numbers language-Swift\">struct AnimationImageCollection &#123;\n    private let imagePaths = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]\n    var images: [AnimationCellModel]\n    \n    init() &#123;\n        images = imagePaths.map &#123; AnimationCellModel(imagePath: $0) &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这个是一个结构体，里面的实体是这个：</p>\n<pre><code class=\"line-numbers language-Swift\">struct AnimationCellModel &#123;\n    let imagePath: String\n    \n    init(imagePath: String?) &#123;\n        self.imagePath = imagePath ?? &quot;&quot;\n    &#125;\n&#125;\n</code></pre>\n<p>很简单，放置了一个图片路径而已。</p>\n<p>回到第一个控制器：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n    super.viewDidLoad()\n    \n    imageCollection = AnimationImageCollection()\n    testCollectionView.register(UINib(nibName: Storyboard.NibName, bundle: nil), forCellWithReuseIdentifier: Storyboard.CellIdentifier)\n&#125;\n</code></pre>\n<p>这里集合View注册了一个Cell，这个Cell是我们建立的xib文件，名称叫做AnimationCollectionViewCell.</p>\n<h3 id=\"10-3-子item\"><a href=\"#10-3-子item\" class=\"headerlink\" title=\"10.3 子item\"></a>10.3 子item</h3><p>应该就是这个itemCell了，还是看下吧：</p>\n<pre><code class=\"line-numbers language-Swift\">class AnimationCollectionViewCell: UICollectionViewCell &#123;\n    \n    @IBOutlet weak var backButton: UIButton!\n    @IBOutlet weak var animationImageView: UIImageView!\n    @IBOutlet weak var animationTextView: UITextView!\n    \n    var backButtonTapped: (() -&gt; Void)?\n    \n    func prepareCell(_ viewModel: AnimationCellModel) &#123;\n        animationImageView.image = UIImage(named: viewModel.imagePath)\n        animationTextView.isScrollEnabled = false\n        backButton.isHidden = true\n        addTapEventHandler()\n    &#125;\n    \n    func handleCellSelected() &#123;\n        animationTextView.isScrollEnabled = false\n        backButton.isHidden = false\n        self.superview?.bringSubview(toFront: self)\n    &#125;\n    \n    private func addTapEventHandler() &#123;\n        backButton.addTarget(self, action: #selector(backButtonDidTouch(_:)), for: .touchUpInside)\n    &#125;\n    \n    @objc func backButtonDidTouch(_ sender: UIGestureRecognizer) &#123;\n        backButtonTapped?()\n    &#125;\n&#125;\n</code></pre>\n<p>item布局就是返回按钮，图片，和文案。<br>这个返回按钮默认应该是隐藏的，选中才给它显示。选中的时候走handleCellSelected方法，<br>这里走了一个</p>\n<pre><code>  self.superview?.bringSubview(toFront: self)\n</code></pre>\n<p>这个作用应该就是把item移动到最前面了。</p>\n<pre><code class=\"line-numbers language-Swift\"> private func addTapEventHandler() &#123;\n    backButton.addTarget(self, action: #selector(backButtonDidTouch(_:)), for: .touchUpInside)\n&#125;\n\n@objc func backButtonDidTouch(_ sender: UIGestureRecognizer) &#123;\n    backButtonTapped?()\n&#125;\n</code></pre>\n<p>这里将返回的点击事件暴露出去了。</p>\n<p>回调给首页里面了：</p>\n<pre><code class=\"line-numbers language-Swift\">// MARK: 按钮事件\nfunc backButtonDidTouch() &#123;\n    guard let indexPaths = self.collectionView!.indexPathsForSelectedItems else &#123;\n        return\n    &#125;\n\n    collectionView!.isScrollEnabled = true\n    collectionView!.reloadItems(at: indexPaths)\n&#125;\n</code></pre>\n<h3 id=\"10-4-代理设置和数据绑定\"><a href=\"#10-4-代理设置和数据绑定\" class=\"headerlink\" title=\"10.4 代理设置和数据绑定\"></a>10.4 代理设置和数据绑定</h3><pre><code class=\"line-numbers language-Swift\"> // MARK: UICollectionViewDataSource\noverride func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123;\n    \n    guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: Storyboard.CellIdentifier, for: indexPath) as? AnimationCollectionViewCell,\n        let viewModel = imageCollection.images.safeIndex(indexPath.item) else &#123;\n        return UICollectionViewCell()\n    &#125;\n    // 这里是自己定义的方法哦\n    cell.prepareCell(viewModel)\n    return cell\n&#125;\n\noverride func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123;\n    return imageCollection.images.count\n&#125;\n\n// MARK: UICollectionViewDelegate\noverride func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) &#123;\n    guard let cell = collectionView.cellForItem(at: indexPath) as? AnimationCollectionViewCell else &#123;\n        return\n    &#125;\n    \n    self.handleAnimationCellSelected(collectionView, cell: cell)\n&#125;\n</code></pre>\n<p>这里选中的时候走了handleAnimationCellSelected这个方法，才实现动画效果的：</p>\n<pre><code class=\"line-numbers language-Swift\">private func handleAnimationCellSelected(_ collectionView: UICollectionView, cell: AnimationCollectionViewCell) &#123;\n        \n    cell.handleCellSelected()\n    cell.backButtonTapped = self.backButtonDidTouch\n    \n    let animations = &#123;\n        cell.frame = self.view.bounds\n    &#125;\n\n    let completion: (_ finished: Bool) -&gt; () = &#123; _ in\n        collectionView.isScrollEnabled = false\n    &#125;\n\n    UIView.animate(withDuration: Constants.AnimationDuration, delay: Constants.AnimationDelay, usingSpringWithDamping: Constants.AnimationSpringDamping, initialSpringVelocity: Constants.AnimationInitialSpringVelocity, options: [], animations: animations, completion: completion)\n&#125;\n</code></pre>\n<p>动画主要是设置了cell的frame吧。</p>\n<h2 id=\"11-总结\"><a href=\"#11-总结\" class=\"headerlink\" title=\"11 总结\"></a>11 总结</h2><ul>\n<li><ol>\n<li>渐变TableView主要实现的是每个cell颜色不同，实现渐变效果，主要是在Cell里面定义了一个CAGradientlayer，在tableView的代理方法为willDisplay中给cell设置了背景色。背景色+渐变层实现了这种效果。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>登录动画的实现方案，就是在视图将要可见，将左侧约束减掉视图宽度，然后已经可见再走UIView的动画函数，再恢复约束，实现动画效果。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>列表动画，主要也是在将要可见的生命周期，遍历cell，修改cell的transform为CGAffineTransform，改变y值初始值为整个tableView的高度，然后动画设置恢复，从而实现进入动画效果。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>游戏抽奖滚动动画，主要用了UIPickerView来实现。点击后设置pickerView的selectRow，开启动画效果，即可实现改效果。</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>启动动画，这里主要是加了一个蒙层，通过控制器的mask，设置未CALayer，然后将png镂空图标设置给mask的conents，然后可以通过CAKeyframeAnimation给mask设置动画，这样可以实现启动展开效果。</li>\n</ol>\n</li>\n<li><ol start=\"6\">\n<li>滑动菜单，主要是在prepare方法中，定义了场景的transitioningDelegate为自定义效果，通过扩展UIViewControllerAnimatedTransitioning的系统协议，在animateTransition方法里面加入我们自己定义好的动画，可以实现滑动菜单效果。</li>\n</ol>\n</li>\n<li><ol start=\"7\">\n<li>酷炫左右缩放菜单效果，跳转的逻辑可以在故事版里面写，这里只是菜单里面配置了一个自定义的transitioningDelegate得以实现，具体动画在UIViewControllerAnimatedTransitioning这个协议里面的animateTransition方法中处理，这里面可以拿到跳转的控制器，控制器可以再拿里面的ui。</li>\n</ol>\n</li>\n<li><ol start=\"8\">\n<li>限制字符串，这个比较简单，就是UITextView的用法，一个是监听键盘收起和弹出，给底部栏加动画，另一个是实现UITextViewDelegate，可以拿到当前长度。</li>\n</ol>\n</li>\n<li><ol start=\"9\">\n<li>自定义下拉刷新，主要是对UIRefreshControl做处理，这个控制器可以添加子View，子View可以通过Bundle.main.loadNibNamed加载xib文件。这样可以实现自定义下拉刷新效果。</li>\n</ol>\n</li>\n<li><ol start=\"10\">\n<li>列表转场动画，这个主要就是走didSelectItemAt的协议方法中，实现动画，关键逻辑就是cell.frame赋予self.view.bounds，相当于放大了cell，达成目标效果。</li>\n</ol>\n</li>\n</ul>\n"},{"title":"iOS swift 3天30个swift项目之第三天","date":"2023-02-05T01:32:39.000Z","op":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 滑动删除\n\n### 1.1 效果\n<img src=Swipeable%20Cell.gif>\n\n### 1.2 列表实现\n```Swift\nclass ViewController: UITableViewController {\n```\n\n数据定义：\n```Swift\nvar data = [\n    pattern(image: \"1\", name: \"Pattern Building\"),\n    pattern(image: \"2\", name: \"Joe Beez\"),\n    pattern(image: \"3\", name: \"Car It's car\"),\n    pattern(image: \"4\", name: \"Floral Kaleidoscopic\"),\n    pattern(image: \"5\", name: \"Sprinkle Pattern\"),\n    pattern(image: \"6\", name: \"Palitos de queso\"),\n    pattern(image: \"7\", name: \"Ready to Go? Pattern\"),\n    pattern(image: \"8\", name: \"Sets Seamless\"),\n]\n```\n\n数据绑定：\n```Swift\noverride func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        return data.count\n    }\n    \noverride func numberOfSections(in tableView: UITableView) -> Int {\n    return 4\n}\n\noverride func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n    return 60\n}\n\noverride func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    let cell = tableView.dequeueReusableCell(withIdentifier: \"PatternCell\", for: indexPath) as! PatternCell\n    let pattern = data[indexPath.row]\n    \n    cell.patternImageView.image = UIImage(named: pattern.image)\n    cell.patternNameLabel.text = pattern.name\n    return cell\n}\n\n// 横滑 增加3个UITableViewRowAction \noverride func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -> [UITableViewRowAction]? {\n    let delete = UITableViewRowAction(style: .normal, title: \"🗑\\nDelete\") { action, index in\n        print(\"Delete button tapped\")\n    }\n    delete.backgroundColor = UIColor.gray\n    \n    // 分析点击事件\n    let share = UITableViewRowAction(style: .normal, title: \"🤗\\nShare\") { (action, indexPath) in\n        let firstActivityItem = self.data[indexPath.row]\n        let activityViewController = UIActivityViewController(activityItems: [firstActivityItem.image as NSString], applicationActivities: nil)\n        \n        self.present(activityViewController, animated: true, completion: nil)\n    }\n    share.backgroundColor = UIColor.red\n    \n    let download = UITableViewRowAction(style: .normal, title: \"⬇️\\nDownload\") { action, index in\n        print(\"Download button tapped\")\n    }\n    download.backgroundColor = UIColor.blue\n    \n    return [download, share, delete]\n}\n\noverride func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool {\n    return true\n}\n\noverride func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) {\n    switch editingStyle {\n    case .delete:\n        print(\"Delete\")\n    case .insert:\n        print(\"Insert\")\n    case .none:\n        print(\"None\")\n    }\n}\n```\n\ncell是自定义的，但主要是通过故事版拖动的，代码绑定里面没有做其它事情。\n其实这个横滑效果，是系统支持的，我们只需要多实现一些协议方法即可。\n\n## 2 3D触摸菜单\n\n### 2.1 效果\n<img src=3DTouchQuickAction.gif>\n\n### 2.2 页面定义\n首页很简单，这里是在故事版里面绑定的控制器。\n就中间一个Label。\n\n然后还有2个页面，都是一张图片，在故事版里面定义了，没有在代码里面声明。\n\n### 2.3 配置3D菜单\n先在info.plist中配置菜单，这里先不实现具体跳转：\n<img src=22.png>\n\n### 2.4 AppDelegate配置\n```Swift\nenum ShortcutIdentifier: String {\n    \n    case First\n    case Second\n    case Third\n    \n    init?(fullType: String) {\n        guard let last = fullType.components(separatedBy: \".\").last else {\n            return nil\n        }\n        self.init(rawValue: last)\n    }\n    \n    var type: String {\n        return Bundle.main.bundleIdentifier! + \".\\(self.rawValue)\"\n    }\n}\n```\n\n这里先定义一个枚举，注意到这里的type为Bundle.main.bundleIdentifier，这里应该必须要为这个了。\n\n然后这里配置application协议：\n```Swift\nfunc application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -> Void) {\n    let handledShortCutItem = handleShortCutItem(shortcutItem)\n    // 走回调\n    completionHandler(handledShortCutItem)\n}\n\nfunc handleShortCutItem(_ shortcutItem: UIApplicationShortcutItem) -> Bool {\n        \n    var handled = false\n    \n    guard let _ = ShortcutIdentifier(fullType: shortcutItem.type) else {\n        return false\n    }\n    \n    guard let shortCutType = shortcutItem.type as String? else {\n        return false\n    }\n    \n    let storyboard = UIStoryboard(name: \"Main\", bundle: nil)\n    var vc: UIViewController\n    \n    switch (shortCutType) {\n    case ShortcutIdentifier.First.type:\n        // Handle shortcut 1\n        vc = storyboard.instantiateViewController(withIdentifier: \"RunVC\") as! RunViewController\n        handled = true\n    case ShortcutIdentifier.Second.type:\n        // Handle shortcut 2\n        vc = storyboard.instantiateViewController(withIdentifier: \"ScanVC\") as! ScanViewController\n        handled = true\n    case ShortcutIdentifier.Third.type:\n        // Handle shortcut 3\n        vc = storyboard.instantiateViewController(withIdentifier: \"WiFiVC\") as! SwitchWiFiViewController\n        handled = true\n    default:\n        vc = UIViewController()\n        break\n    }\n    \n    // Display the selected view controller\n    //\n    var presentedVC: UIViewController = window!.rootViewController!\n    while presentedVC.presentedViewController != nil {\n        presentedVC = presentedVC.presentedViewController!\n    }\n    if !presentedVC.isMember(of: vc.classForCoder) {\n        presentedVC.present(vc, animated: true, completion: nil)\n    }\n    \n    return handled\n}\n```\n这里定义了快捷键方式跳转方式，这里通过获取到Main的故事版，然后，故事版去instantiateViewController来获取其它的控制器，这里再通过present方法跳转到目标控制器。\n\n## 3 侧滑菜单\n\n### 3.1 效果\n<img src=SlideOutMenu.gif>\n\n### 3.2 侧滑支持\n首先需要引入SWRevealViewController.h和SWRevealViewController.m文件。\n这个用官方的即可，文件比较长，就不贴进来了。\n\n### 3.3 故事版定义\n<img src=23_1.png>\n这里定义好了跳转逻辑，直接在故事版里面操作的。\n\n其它2个item也是如此。\n\n主要是在Main.storyboard中定义了第一个控制为：SWRevealViewController\n这个是oc写的。\n\n故事版里面定义了这个控制器会指向一个BackTableVC。\n\n\n### 3.4 控制器配置\n第一个菜单控制器为：\n```Swift\nclass Channel : UIViewController {\n    \n    override func viewDidLoad() {\n        self.navigationController?.isNavigationBarHidden = true\n        self.view.addGestureRecognizer(self.revealViewController().panGestureRecognizer())\n    }\n    \n}\n```\n\n第二个菜单控制器为：\n```Swift\nclass ReadLater : UIViewController {\n    \n    override func viewDidLoad() {\n        self.navigationController?.isNavigationBarHidden = true\n        self.view.addGestureRecognizer(self.revealViewController().panGestureRecognizer())\n    }\n    \n}\n```\n\n第三个菜单控制为：\n```Swift\nclass FriendRead : UIViewController {\n    \n    override func viewDidLoad() {\n        self.navigationController?.isNavigationBarHidden = true\n        self.view.addGestureRecognizer(self.revealViewController().panGestureRecognizer())   \n    }   \n}\n```\n\n这里必须配置：\n```\n self.view.addGestureRecognizer(self.revealViewController().panGestureRecognizer())   \n```\n才能实现菜单左滑手势效果哦。\n\n## 4 磁片效果\n\n### 4.1 效果\n<img src=MosaicLayouts.gif>\n\n### 4.2 pod引入三方库\n这里通过Pod引入依赖，如下图：\n<img src=24_1.png>\n\n这里引入了FMMosaicLayout库+AFNetworking+ORStackView+SwiftyJSON\n用了这四个库。\n\n### 4.3 页面定义\n这里也是用了一个UICollectionView，单一个页面。\n直接继承了这个：UICollectionViewController。\n\n```Swift\noverride func numberOfSections(in collectionView: UICollectionView) -> Int {\n        return 10\n    }\n    \noverride func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n    let cell = collectionView.dequeueReusableCell(withReuseIdentifier: \"Cell\", for: indexPath)\n    cell.alpha = 0\n    \n    let imageView = cell.contentView.viewWithTag(2) as! UIImageView\n    imageView.image = UIImage(named: imageArray[indexPath.row])\n    \n    let cellDelay = UInt64((arc4random() % 600 ) / 1000 )\n    let cellDelayTime = DispatchTime(uptimeNanoseconds: cellDelay * NSEC_PER_SEC)\n    DispatchQueue.main.asyncAfter(deadline: cellDelayTime) {\n        UIView.animate(withDuration: 0.8, animations: {\n            cell.alpha = 1.0\n        })\n    }\n    \n    return cell\n}\n\n\noverride func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {\n    return imageArray.count\n}\n```\n主要实现了这几个协议方法。\nCell用了系统的。\n\n内容直接用UIImageView表示。\n\n然后这里异步开启动画效果，alpha从0到1的变化效果。\n\n### 4.4 初始化\n```Swift\nvar imageArray = [String]()\n\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    imageArray = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\"]\n    let mosaicLayout = FMMosaicLayout()\n    self.collectionView?.collectionViewLayout = mosaicLayout\n    if #available(iOS 11.0, *) {\n        self.collectionView?.contentInsetAdjustmentBehavior = .never\n    }\n}\n```\n这里初始化的时候，将collectionView的collectionViewLayout设置为三方库的View。\n\n如何设置为不同大小，这里就是三方库的作用了：\n```Swift\nextension ViewController : FMMosaicLayoutDelegate {\n\n    func collectionView(_ collectionView: UICollectionView!, layout collectionViewLayout: FMMosaicLayout!, numberOfColumnsInSection section: Int) -> Int {\n        return 3\n    }\n\n    func collectionView(_ collectionView: UICollectionView!, layout collectionViewLayout: FMMosaicLayout!, mosaicCellSizeForItemAt indexPath: IndexPath!) -> FMMosaicCellSize {\n        return indexPath.item % 7 == 0 ? .big : .small\n    }\n\n    func collectionView(_ collectionView: UICollectionView!, layout collectionViewLayout: FMMosaicLayout!, interitemSpacingForSectionAt section: Int) -> CGFloat {\n        return 1.0\n    }\n\n    func collectionView(_ collectionView: UICollectionView!, layout collectionViewLayout: FMMosaicLayout!, insetForSectionAt section: Int) -> UIEdgeInsets {\n        return UIEdgeInsets(top: 1.0, left: 1.0, bottom: 1.0, right: 1.0)\n    }\n}\n```\n这里如果是7的倍数就大图，否则小图。有3种类型。\n\n## 5 基础动画\n\n### 5.1 效果\n<img src=BasicAnimation.gif>\n\n### 5.2 故事版\n第一个启动页首先是Main.storyboard故事版，然后这个故事版有一个Storyboard Entry Point就是第一个场景了，这里第一个场景是空的NavigationController Scene。\n\n然后这里绑定了这个第一个场景跳转逻辑，底部这里有个：\n<img src=25_1.png>\n\n那如何修改这个启动路径呢？\n<img src=25_2.png>\n这里最右侧属性里面，先清除掉之前的，然后拖动小圆点，指向目标场景即可哦。\n\n这里Navigation Controller场景指向了BasicAnimation场景，这里面是一个TableView。\n这里配置的UITableView的代理和数据源都指向了Basic Animation。\n<img src=25_3.png>\n这里数据直接在故事版里面写好了。\n\n然后item的跳转也是直接在故事版里面拖动的：\n<img src=25_4.png>\n\n这里其实对应的首页的Controller没有啥东西：\n```Swift\nclass ViewController: UITableViewController {\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        self.tableView.tableFooterView = UIView(frame: .zero)\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n}\n```\n\n### 5.3 Position动画\n这里定义了3个方块。\n```Swift\nclass PositionViewController: UIViewController {\n\n    @IBOutlet weak var yellowSquareView: UIView!\n    @IBOutlet weak var blueSquareView: UIView!\n    @IBOutlet weak var mouseView: UIView!    \n```\n\n已经出现动画时执行动画：\n```Swift\noverride func viewDidAppear(_ animated: Bool) {\n        super.viewDidAppear(animated)\n        \n    UIView.animate(withDuration: 0.8, delay: 0.2, usingSpringWithDamping: 0.6, initialSpringVelocity: 0.8, options: .curveEaseInOut, animations: {\n        self.yellowSquareView.center.x = self.view.bounds.width - self.yellowSquareView.center.x\n        self.yellowSquareView.center.y = self.yellowSquareView.center.y + 30\n        self.blueSquareView.center.x = self.view.bounds.width -  self.blueSquareView.center.x\n        self.blueSquareView.center.y = self.blueSquareView.center.y + 30\n\n        }, completion: nil )\n    \n    UIView.animate(withDuration: 0.6, delay: 0.4, usingSpringWithDamping: 0.6, initialSpringVelocity: 0.8, options: .curveEaseOut, animations: {\n        self.setHeight(180)\n        self.mouseView.center.y = self.view.bounds.height - self.mouseView.center.y\n        }, completion: nil )\n}\n\nfunc setHeight(_ height: CGFloat) {\n    \n    var frame: CGRect = self.mouseView.frame\n    frame.size.height = height\n    \n    self.mouseView.frame = frame\n}\n```\n\n### 5.4 Opacity动画\n```Swift\nclass OpacityViewController: UIViewController {\n\n    @IBOutlet weak var exampleImageView: UIImageView!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n    \n    override func viewDidAppear(_ animated: Bool) {\n        super.viewDidAppear(animated)\n        \n        UIView.animate(withDuration: 2) {\n            self.exampleImageView.alpha = 0\n        }\n    }\n}\n```\n这里控制图片alpha从1到0的动画。\n\n### 5.5 Scale动画\n```Swift\nclass ScaleViewController: UIViewController {\n\n    @IBOutlet weak var scaleImageView: UIImageView!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        self.scaleImageView.alpha = 0\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n    \n    override func viewDidAppear(_ animated: Bool) {\n        super.viewDidAppear(animated)\n        \n        \n        UIView.animate(withDuration: 0.8, delay: 0, usingSpringWithDamping: 0.7, initialSpringVelocity: 1, options: .curveEaseIn, animations: {\n            self.scaleImageView.transform = CGAffineTransform(scaleX: 2, y: 2)\n            self.scaleImageView.alpha = 1\n            \n            }, completion: nil )\n    }\n}\n```\n这里alpha从0到1,缩放动画从1到2。\n\n### 5.6 Color动画\n```Swift\nclass ColorViewController: UIViewController {\n\n    @IBOutlet weak var bgColorView: UIView!\n    @IBOutlet weak var numberLabel: UILabel!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n    \n    override func viewDidAppear(_ animated: Bool) {\n        super.viewDidAppear(animated)\n        \n        \n        UIView.animate(withDuration: 0.5, delay: 0.2, options: .curveEaseIn, animations: {\n            self.bgColorView.backgroundColor = .black\n            \n            }, completion: nil )\n        \n        UIView.animate(withDuration: 0.5, delay: 0.8, options: .curveEaseOut, animations: {\n            self.numberLabel.textColor = UIColor(red:0.959, green:0.937, blue:0.109, alpha:1)\n            \n            }, completion: nil)\n    }\n}\n```\n这里设置颜色从黄到黑，文字颜色也变化了。\n\n### 5.7 Rotation动画\n```Swift \nclass RotationViewController: UIViewController {\n\n    @IBOutlet weak var emojiLabel: UILabel!\n    @IBOutlet weak var rotationImageView: UIImageView!\n    @IBOutlet weak var trump2: UIImageView!\n    @IBOutlet weak var trump3: UIImageView!\n    @IBOutlet weak var trump4: UIImageView!\n    @IBOutlet weak var trump5: UIImageView!\n    @IBOutlet weak var trump6: UIImageView!\n    @IBOutlet weak var trump7: UIImageView!\n    @IBOutlet weak var trump8: UIImageView!\n    \n    func spin() {\n        UIView.animate(withDuration: 0.8, delay: 0, options: .curveLinear, animations: {\n            self.rotationImageView.transform = self.rotationImageView.transform.rotated(by: CGFloat(Double.pi))\n            self.trump2.transform = self.trump2.transform.rotated(by: CGFloat(Double.pi))\n            self.trump3.transform = self.trump3.transform.rotated(by: CGFloat(Double.pi))\n            self.trump4.transform = self.trump4.transform.rotated(by: CGFloat(Double.pi))\n            self.trump5.transform = self.trump5.transform.rotated(by: CGFloat(Double.pi))\n            self.trump6.transform = self.trump6.transform.rotated(by: CGFloat(Double.pi))\n            self.trump7.transform = self.trump7.transform.rotated(by: CGFloat(Double.pi))\n            self.trump8.transform = self.trump8.transform.rotated(by: CGFloat(Double.pi))\n            self.emojiLabel.transform = self.emojiLabel.transform.rotated(by: CGFloat(Double.pi))\n            }) { (finished) -> Void in\n                self.spin()\n        }\n    }\n    \n    override func viewDidAppear(_ animated: Bool) {\n        super.viewDidAppear(animated)\n        self.spin()\n    }\n}\n```\n这里让8个视图都开始旋转了。\n\n## 6 CoreData使用\n\n### 6.1 效果\n<img src=CoreData.gif>\n\n### 6.2 AddDelegate配置\n```Swift\nlazy var applicationDocumentsDirectory: NSURL = {\n        // The directory the application uses to store the Core Data store file. This code uses a directory named \"me.appkitchen.cd\" in the application's documents Application Support directory.\n        let urls = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)\n        return urls[urls.count-1] as NSURL\n    }()\n\nlazy var managedObjectModel: NSManagedObjectModel = {\n    // The managed object model for the application. This property is not optional. It is a fatal error for the application not to be able to find and load its model.\n    let modelURL = Bundle.main.url(forResource: \"cd\", withExtension: \"momd\")!\n    return NSManagedObjectModel(contentsOf: modelURL)!\n}()\n\nlazy var persistentStoreCoordinator: NSPersistentStoreCoordinator = {\n    // The persistent store coordinator for the application. This implementation creates and returns a coordinator, having added the store for the application to it. This property is optional since there are legitimate error conditions that could cause the creation of the store to fail.\n    // Create the coordinator and store\n    let coordinator = NSPersistentStoreCoordinator(managedObjectModel: self.managedObjectModel)\n    let url = self.applicationDocumentsDirectory.appendingPathComponent(\"SingleViewCoreData.sqlite\")\n    var failureReason = \"There was an error creating or loading the application's saved data.\"\n    do {\n        try coordinator.addPersistentStore(ofType: NSSQLiteStoreType, configurationName: nil, at: url, options: nil)\n    } catch {\n        // Report any error we got.\n        var dict = [String: AnyObject]()\n        dict[NSLocalizedDescriptionKey] = \"Failed to initialize the application's saved data\" as AnyObject\n        dict[NSLocalizedFailureReasonErrorKey] = failureReason as AnyObject\n\n        dict[NSUnderlyingErrorKey] = error as NSError\n        let wrappedError = NSError(domain: \"YOUR_ERROR_DOMAIN\", code: 9999, userInfo: dict)\n        // Replace this with code to handle the error appropriately.\n        // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.\n        NSLog(\"Unresolved error \\(wrappedError), \\(wrappedError.userInfo)\")\n        abort()\n    }\n\n    return coordinator\n}()\n\nlazy var managedObjectContext: NSManagedObjectContext = {\n    // Returns the managed object context for the application (which is already bound to the persistent store coordinator for the application.) This property is optional since there are legitimate error conditions that could cause the creation of the context to fail.\n    let coordinator = self.persistentStoreCoordinator\n    var managedObjectContext = NSManagedObjectContext(concurrencyType: .mainQueueConcurrencyType)\n    managedObjectContext.persistentStoreCoordinator = coordinator\n    return managedObjectContext\n}()\n\n// MARK: - Core Data Saving support\n\nfunc saveContext () {\n    if managedObjectContext.hasChanges {\n        do {\n            try managedObjectContext.save()\n        } catch {\n            // Replace this implementation with code to handle the error appropriately.\n            // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.\n            let nserror = error as NSError\n            NSLog(\"Unresolved error \\(nserror), \\(nserror.userInfo)\")\n            abort()\n        }\n    }\n}\n```\n因为代码比较久了，这个按照XCode指示修复后就是这个效果。\n这里可以运行了。\n\n主要是applicationWillTerminate方法中saveContext了。\n\n### 6.3 可见数据操作\n这里代码使用还有点问题，暂时无法贴最新代码。\n关于CoreData的使用还是建议参考这篇文章：\n[了解和采用 CoreData 框架 —— Ficow 陪你学 CoreData](https://blog.ficowshen.com/page/post/52)。\n\n## 7 底部Bar动画\n\n### 7.1 效果\n<img src=TapBarAnimation.gif>\n\n### 7.2 故事版添加导航item\n<img src=27_1.png>\n\n这里应该是关联到了这3个item。\n这样子，就可以展示底部导航栏效果。\n然后item也定义了跳转的目标场景。\n\n### 7.3 第一个Tab页\n```Swift\nclass FirstTabViewController: UIViewController, UITableViewDataSource, UITableViewDelegate {\n\n    @IBOutlet weak var articleTableView: UITableView!\n    \n    var data = [\n    \n        article(avatarImage: \"allen\", sharedName: \"Allen Wang\", actionType: \"Read Later\", articleTitle: \"Giphy Cam Lets You Create And Share Homemade Gifs\", articleCoverImage: \"giphy\", articleSouce: \"TheNextWeb\", articleTime: \"5min  •  13:20\"),\n        article(avatarImage: \"Daniel Hooper\", sharedName: \"Daniel Hooper\", actionType: \"Shared on Twitter\", articleTitle: \"Principle. The Sketch of Prototyping Tools\", articleCoverImage: \"my workflow flow\", articleSouce: \"SketchTalk\", articleTime: \"3min  •  12:57\"),\n        article(avatarImage: \"davidbeckham\", sharedName: \"David Beckham\", actionType: \"Shared on Facebook\", articleTitle: \"Ohlala, An Uber For Escorts, Launches Its ‘Paid Dating’ Service In NYC\", articleCoverImage: \"Ohlala\", articleSouce: \"TechCrunch\", articleTime: \"1min  •  12:59\"),\n        article(avatarImage: \"bruce\", sharedName: \"Bruce Fan\", actionType: \"Shared on Weibo\", articleTitle: \"Lonely Planet’s new mobile app helps you explore major cities like a pro\", articleCoverImage: \"Lonely Planet\", articleSouce: \"36Kr\", articleTime: \"5min  •  11:21\"),\n\n    ]\n```\n上面是数据定义。\n\n然后设置代理和数据源：\n```Swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    \n    articleTableView.dataSource = self\n    articleTableView.delegate = self\n    articleTableView.separatorStyle = UITableViewCell.SeparatorStyle.none\n    articleTableView.tableFooterView = UIView(frame: .zero)\n}\n\n \nfunc numberOfSectionsInTableView(tableView: UITableView) -> Int {\n    return 10\n}\n\nfunc tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n    return data.count\n}\n\nfunc tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n    return 165\n}\n\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    let cell = articleTableView.dequeueReusableCell(withIdentifier: \"Cell\", for: indexPath) as! ArticleTableViewCell\n    let article = data[indexPath.row]\n    \n    cell.avatarImage.image = UIImage(named: article.avatarImage)\n    cell.articleCoverImage.image = UIImage(named: article.articleCoverImage)\n    cell.sharedNameLabel.text = article.sharedName\n    cell.actionTypeLabel.text = article.actionType\n    cell.articleTitleLabel.text = article.articleTitle\n    cell.articleSouceLabel.text = article.articleSouce\n    cell.articelCreatedAtLabel.text = article.articleTime\n    cell.selectionStyle = UITableViewCell.SelectionStyle.none\n    \n    return cell   \n}\n```\n这里配置了Cell:\n```Swift\nstruct article {\n    let avatarImage: String\n    let sharedName: String\n    let actionType: String\n    let articleTitle: String\n    let articleCoverImage: String\n    let articleSouce: String\n    let articleTime: String\n}\n\nclass ArticleTableViewCell: UITableViewCell {\n\n    @IBOutlet weak var avatarImage: UIImageView!\n    @IBOutlet weak var sharedNameLabel: UILabel!\n    @IBOutlet weak var actionTypeLabel: UILabel!\n    @IBOutlet weak var articleCoverImage: UIImageView!\n    \n    @IBOutlet weak var articleTitleLabel: UILabel!\n    @IBOutlet weak var articleSouceLabel: UILabel!\n    @IBOutlet weak var articelCreatedAtLabel: UILabel!\n    \n    override func awakeFromNib() {\n        super.awakeFromNib()\n        // Initialization code\n\n    }\n\n    override func setSelected(_ selected: Bool, animated: Bool) {\n        super.setSelected(selected, animated: animated)\n\n        // Configure the view for the selected state\n    }\n}\n```\n这里应该就是item配置了，具体布局是用故事版里面的配置的。\n\n可见的时候，执行动画效果：\n```Swift\noverride func viewWillAppear(_ animated: Bool) {   \n    animateTable()\n}\n\nfunc animateTable() {\n    \n    self.articleTableView.reloadData()\n    \n    let cells = articleTableView.visibleCells\n    let tableHeight: CGFloat = articleTableView.bounds.size.height\n    \n    for i in cells {\n        let cell: UITableViewCell = i as UITableViewCell\n        cell.transform = CGAffineTransform(translationX: 0, y: tableHeight)\n    }\n    \n    var index = 0\n    \n    for a in cells {\n        let cell: UITableViewCell = a as UITableViewCell\n        UIView.animate(withDuration: 1.0, delay: 0.05 * Double(index), usingSpringWithDamping: 0.8, initialSpringVelocity: 0, options: [], animations: {\n            cell.transform = CGAffineTransform(translationX: 0, y: 0);\n            }, completion: nil)\n        \n        index += 1\n    }\n}\n```\n从下往上的动画效果。\n\n\n### 7.4 第二个Tab的动画\n```Swift\noverride func viewDidAppear(_ animated: Bool) {\n    super.viewDidAppear(animated)\n    \n    UIView.animate(withDuration: 0.5, delay: 0.1, usingSpringWithDamping: 0.7, initialSpringVelocity: 1, options: .curveEaseIn, animations: {\n        self.exploreImageView.transform = CGAffineTransform(scaleX: 1, y: 1)\n        self.exploreImageView.alpha = 1\n        \n        }, completion: nil )\n}\n\noverride func viewDidDisappear(_ animated: Bool) {\n    super.viewDidDisappear(animated)\n    resetViewTransform()\n}\n\n// MARK:\nfunc resetViewTransform() {\n    self.exploreImageView.alpha = 0\n    self.exploreImageView.transform = CGAffineTransform(scaleX: 0.5, y: 0.5)\n}\n```\n\n### 7.5 第三个Tab的动画\n```Swift\noverride func viewDidAppear(_ animated: Bool) {\n        super.viewDidAppear(animated)\n    \n    UIView.animate(withDuration: 0.5, delay: 0.1, usingSpringWithDamping: 0.7, initialSpringVelocity: 1, options: .curveEaseIn, animations: {\n        self.profileImageView.transform = CGAffineTransform(scaleX: 1, y: 1)\n        self.profileImageView.alpha = 1\n        \n        }, completion: nil )\n}\n\noverride func viewDidDisappear(_ animated: Bool) {\n    super.viewDidDisappear(animated)\n    resetViewTransform()\n}\n\n// MARK:\nfunc resetViewTransform() {\n    self.profileImageView.alpha = 0\n    self.profileImageView.transform = CGAffineTransform(scaleX: 0.5, y: 0.5)\n}\n```\n\n## 8 系统搜索\n\n### 8.1 效果\n<img src=Spotlight%20Search.gif>\n\n### 8.2 首页\n数据设置：\n<img src=28_1.png>\n这里新建了一个电影数据，用key-value形式保存了。\n\n可见时处理：\n```Swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    loadMoviesInfo()\n    configureTableView()\n    navigationItem.title = \"Movies\"\n    setupSearchableContent()\n}\n\n// 加载根目录文件数据，拿到数组\nfunc loadMoviesInfo() {\n    if let path = Bundle.main.path(forResource: \"MoviesData\", ofType: \"plist\") {\n        moviesInfo = NSMutableArray(contentsOfFile: path)\n    }\n}\n\n// 配置代理和数据源\nfunc configureTableView() {\n    tblMovies.delegate = self\n    tblMovies.dataSource = self\n    tblMovies.tableFooterView = UIView(frame: CGRect.zero)\n    tblMovies.register(UINib(nibName: \"MovieSummaryCell\", bundle: nil), forCellReuseIdentifier: \"idCellMovieSummary\")\n}\n\n// 搜索数据装载，使用了系统的类  CSSearchableItem\nfunc setupSearchableContent() {\n    var searchableItems = [CSSearchableItem]()\n    \n    for i in 0...(moviesInfo.count - 1) {\n        \n        let movie = moviesInfo[i] as! [String: String]\n        let searchableItemAttributeSet = CSSearchableItemAttributeSet(itemContentType: kUTTypeText as String)\n        \n        //set the title\n        searchableItemAttributeSet.title = movie[\"Title\"]!\n        \n        //set the image\n        let imagePathParts = movie[\"Image\"]!.components(separatedBy: \".\")\n        searchableItemAttributeSet.thumbnailURL = Bundle.main.url(forResource: imagePathParts[0], withExtension: imagePathParts[1])\n        \n        // Set the description.\n        searchableItemAttributeSet.contentDescription = movie[\"Description\"]!\n        \n        var keywords = [String]()\n        let movieCategories = movie[\"Category\"]!.components(separatedBy: \", \")\n        for movieCategory in movieCategories {\n            keywords.append(movieCategory)\n        }\n        \n        let stars = movie[\"Stars\"]!.components(separatedBy: \", \")\n        for star in stars {\n            keywords.append(star)\n        }\n        \n        searchableItemAttributeSet.keywords = keywords\n        \n        let searchableItem = CSSearchableItem(uniqueIdentifier: \"com.appcoda.SpotIt.\\(i)\", domainIdentifier: \"movies\", attributeSet: searchableItemAttributeSet)\n        \n        searchableItems.append(searchableItem)\n        \n        CSSearchableIndex.default().indexSearchableItems(searchableItems) {\n            if $0 != nil {\n                print($0!.localizedDescription)\n            }\n        }\n    }\n}\n```\n\n监听系统搜索后跳转逻辑：\n```Swift\noverride func restoreUserActivityState(_ activity: NSUserActivity) {\n    if activity.activityType == CSSearchableItemActionType {\n        if let userInfo = activity.userInfo {\n            let selectedMovie = userInfo[CSSearchableItemActivityIdentifier] as! String\n            selectedMovieIndex = Int(selectedMovie.components(separatedBy: \".\").last!)\n            performSegue(withIdentifier: \"idSegueShowMovieDetails\", sender: self)\n        }\n    }\n}\n```\n\n然后是代理和数据源配置：\n```Swift\n func numberOfSections(in tableView: UITableView) -> Int {\n        return 1\n    }\n    \nfunc tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n    if moviesInfo != nil {\n        return moviesInfo.count\n    }\n    return 0\n}\n\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    let cell = tableView.dequeueReusableCell(withIdentifier: \"idCellMovieSummary\", for: indexPath) as! MovieSummaryCell\n    let currentMovieInfo = moviesInfo[(indexPath as NSIndexPath).row] as! [String: String]\n    \n    cell.lblTitle.text = currentMovieInfo[\"Title\"]!\n    cell.lblDescription.text = currentMovieInfo[\"Description\"]!\n    cell.lblRating.text = currentMovieInfo[\"Rating\"]!\n    cell.imgMovieImage.image = UIImage(named: currentMovieInfo[\"Image\"]!)\n    \n    return cell\n}\n\nfunc tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n    return 100.0\n}\n\nfunc tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n    selectedMovieIndex = (indexPath as NSIndexPath).row\n    performSegue(withIdentifier: \"idSegueShowMovieDetails\", sender: self)\n}\n\noverride func prepare(for segue: UIStoryboardSegue, sender: Any?) {\n    if let identifier = segue.identifier, identifier == \"idSegueShowMovieDetails\" {\n        let movieDetailsViewController = segue.destination as! MovieDetailsViewController\n        movieDetailsViewController.movieInfo = moviesInfo[selectedMovieIndex] as? [String: String]\n    }\n}\n```\n这里didSelectRowAt，通过调用系统的performSegue决定跳转到某个场景。\n\n### 8.3 详情页\n```Swift\nclass MovieDetailsViewController: UIViewController {\n\n    @IBOutlet weak var imgMovieImage: UIImageView!\n    @IBOutlet weak var lblTitle: UILabel!\n    @IBOutlet weak var lblCategory: UILabel!\n    @IBOutlet weak var lblDescription: UILabel!\n    @IBOutlet weak var lblDirector: UILabel!\n    @IBOutlet weak var lblStars: UILabel!\n    @IBOutlet weak var lblRating: UILabel!\n    \n    var movieInfo: [String: String]!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n    }\n    \n    override func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n        \n        lblRating.layer.cornerRadius = lblRating.frame.size.width/2\n        lblRating.layer.masksToBounds = true\n        \n        if movieInfo != nil {\n            populateMovieInfo()\n        }\n    }\n    \n    \n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n    \n    func populateMovieInfo() {\n        \n        lblTitle.text = movieInfo[\"Title\"]!\n        lblCategory.text = movieInfo[\"Category\"]!\n        lblDescription.text = movieInfo[\"Description\"]!\n        lblDirector.text = movieInfo[\"Director\"]!\n        lblStars.text = movieInfo[\"Stars\"]!\n        lblRating.text = movieInfo[\"Rating\"]!\n        imgMovieImage.image = UIImage(named: movieInfo[\"Image\"]!)\n        \n    }\n}\n```\n这里配置了movieInfo，外部设置进来，然后回显进去。\n\n## 9 选择头像\n\n### 9.1 效果\n<img src=AvatarPicker.gif>\n\n### 9.2 点击头像\n```Swift\n@IBAction func pickProfileImage(_ tap: UITapGestureRecognizer) {\n    let authorization = PHPhotoLibrary.authorizationStatus()\n    \n    if authorization == .notDetermined {\n        PHPhotoLibrary.requestAuthorization { _ in\n            DispatchQueue.main.async {\n                self.pickProfileImage(tap)\n            }\n        }\n    }\n    \n    if authorization == .authorized {\n        let controller = ImagePickerSheetController()\n        controller.addAction(action: ImageAction(title: NSLocalizedString(\"Take Photo or Video\", comment: \"Action Title\"), secondaryTitle: NSLocalizedString(\"Use this one\", comment: \"Action Title\"), handler: { _ in\n            self.presentCamera()\n        }, secondaryHandler: { (action, numberOfPhotos) in\n            controller.getSelectedImagesWithCompletion(completion: { images in\n                self.profileImage = images[0]\n                self.userProfileImageView.image = self.profileImage\n            })\n        }))\n                    \n        controller.addAction(action: ImageAction(title: NSLocalizedString(\"Cancel\", comment: \"Action Title\"), style: .Cancel, handler: nil, secondaryHandler: nil))\n        \n        self.present(controller, animated: true, completion: nil)\n    }\n    \n    \n}\n\nfunc presentCamera()\n{\n    print(\"拍照\")\n}\n```\n这里先判断有无权限，没有权限继续执行，有权限再跳转控制器。\n\n## 10 wiki-Face\n\n### 10.1 效果\n<img src=wikiFace.gif>\n\n### 10.2 搜索处理\n```Swift\nfunc textFieldShouldReturn(_ textField: UITextField) -> Bool {\n        \n    textField.resignFirstResponder()\n    \n    if let textFieldContent = textField.text {\n        do {\n            try WikiFace.faceForPerson(textFieldContent, size: CGSize(width: 300, height: 400), completion: { (image:UIImage?, imageFound:Bool) -> () in\n                if imageFound == true {\n                    DispatchQueue.main.async {\n                        self.faceImageView.image = image\n                        \n                        UIView.animate(withDuration: 0.8, delay: 0, usingSpringWithDamping: 0.7, initialSpringVelocity: 1, options: .curveEaseIn, animations: { () -> Void in\n                            \n                            self.faceImageView.transform = CGAffineTransform(scaleX: 1, y: 1)\n                            self.faceImageView.alpha = 1\n                            \n                            //Fuck! Useless...LOL\n                            self.faceImageView.layer.shadowOpacity = 0.4\n                            self.faceImageView.layer.shadowOffset = CGSize(width: 3.0, height: 2.0)\n                            self.faceImageView.layer.shadowRadius = 15.0\n                            self.faceImageView.layer.shadowColor = UIColor.black.cgColor\n                            \n                        }, completion: nil )\n                        \n                        WikiFace.centerImageViewOnFace(self.faceImageView)\n                    }\n                }\n\n            })\n        }catch WikiFace.WikiFaceError.CouldNotDownloadImage{\n            print(\"Could not access wikipedia for downloading an image\")\n        } catch {\n            print(error)\n        }\n    }\n    \n    return true\n    \n}\n```\n\n使用工具类：\n```Swift\nimport UIKit\nimport ImageIO\n\nclass WikiFace: NSObject {\n    \n    enum WikiFaceError: Error {\n        case CouldNotDownloadImage\n    }\n    \n    class func faceForPerson(_ person: String, size: CGSize, completion:@escaping (_ image: UIImage? ,_ imageFound: Bool) -> ()) throws {\n        \n        let escapedString = person.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlHostAllowed)\n        let pixelsForAPIRequest = Int(max(size.width, size.height)) * 2\n        \n        let url = URL(string: \"https://en.wikipedia.org/w/api.php?action=query&titles=\\(escapedString!)&prop=pageimages&format=json&pithumbsize=\\(pixelsForAPIRequest)\")\n        \n        let task: URLSessionTask = URLSession.shared.dataTask(with: url!, completionHandler: {\n            (data: Data?, response: URLResponse?, error: Error?) in\n            if error == nil {\n                let wikiDict = try! JSONSerialization.jsonObject(with: data!, options: JSONSerialization.ReadingOptions.allowFragments) as! NSDictionary\n        \n                if let query = wikiDict.object(forKey: \"query\") as? NSDictionary {\n                    if let pages = query.object(forKey: \"pages\") as? NSDictionary {\n                        if let pageContent = pages.allValues.first as? NSDictionary {\n                            if let thumbnail = pageContent.object(forKey: \"thumbnail\") as? NSDictionary {\n                                if let thumbURL = thumbnail.object(forKey: \"source\") as? String {\n                                    let faceImage = UIImage(data: try! Data(contentsOf: URL(string: thumbURL)!))\n                                    completion(faceImage, true)\n                                }\n                            }else{\n                                completion(nil, false)\n                            }\n                        }\n                    }\n                }\n            }\n        })\n        task.resume()\n    }\n    \n    class func centerImageViewOnFace (_ imageView: UIImageView) {\n        \n        let context = CIContext(options: nil)\n        let options = [CIDetectorAccuracy:CIDetectorAccuracyHigh]\n        let detector = CIDetector(ofType: CIDetectorTypeFace, context: context, options: options)\n        \n        let faceImage = imageView.image\n        let ciImage = CIImage(cgImage: faceImage!.cgImage!)\n        \n        let features = detector?.features(in: ciImage)\n        \n        if (features?.count)! > 0 {\n            \n            var face:CIFaceFeature!\n            \n            for rect in features! {\n                face = rect as? CIFaceFeature\n            }\n            \n            var faceRectWithExtendedBounds = face.bounds\n            faceRectWithExtendedBounds.origin.x -= 20\n            faceRectWithExtendedBounds.origin.y -= 30\n            \n            faceRectWithExtendedBounds.size.width += 40\n            faceRectWithExtendedBounds.size.height += 60\n            \n            let x = faceRectWithExtendedBounds.origin.x / faceImage!.size.width\n            let y = (faceImage!.size.height - faceRectWithExtendedBounds.origin.y - faceRectWithExtendedBounds.size.height) / faceImage!.size.height\n            \n            let widthFace = faceRectWithExtendedBounds.size.width / faceImage!.size.width\n            let heightFace = faceRectWithExtendedBounds.size.height  / faceImage!.size.height\n            \n            imageView.layer.contentsRect = CGRect(x: x, y: y, width: widthFace, height: heightFace)\n        }\n    }\n}\n```\n这里应该是走异步接口，然后将网络图片设置给UIImageVIew了。\n\n## 11 总结\n\n* 滑动删除效果其实是UITableView里面自带的一个方法editActionsForRowAt方法，里面配置的UITableViewRowAction实现的。\n\n* 3D触摸效果，首先需要在info.plist中配置菜单，然后在AppDelegate中定义菜单的跳转逻辑，可以present方式跳转到目标页面。\n\n* 侧滑菜单，这个需要引入一下SWRevealViewController，这个是oc写的，这里面配置一下菜单控制器，这样就可以实现侧滑效果，主要工作量在SWRevealViewController里面。\n\n* 磁片效果，这个主要是引入了一个三方库，FMMosaicLayout库，需要实现一下FMMosaicLayoutDelegate这个方法，这样就可以实现不同item的大小。\n\n* 基础动画，这里定义了各种各样的基础动画使用方法，Position动画就是height高度区别，Opacity效果是配置alpah，Scale效果是CGAffineTransform这个配置，Color动画就改变一下颜色值，Rotation动画就是设置transform的rotated方法。\n\n* CoreData的使用主要是现在appDelegate中设置saveContext，其它操作类似操作数据库。\n\n* 底部Bar动画，主要是在可见的时候，对每个UITableViewCell里面做了一个动画效果，里面通过设置CGAffineTransform这个实现。\n\n* 系统搜索，这个首先需要配置一个数据源，可以再plist文件里面写一个数组，然后通过系统的搜索类来实现，CSSearchableIndex这个来注入数据。然后配置restoreUserActivityState这个方法，可以决定item跳转目标类。\n\n* 选择头像，这里主要是用了一个工具类，然后通过PHPotoLibrary获取权限，有权限就跳转，没有权限申请，有权限跳转到自定义的ImagePickerSheetController，然后会present这个类。\n\n* wiki-Face，其实是显示一个网络图片的工具类。当我们编辑框结束，点击return后，这里利用WikiFace静态方法去加载网络接口，然后给图片的image设置进去。\n\n\n\n\n\n","source":"_posts/iOS-swift-3天30个swift项目之第三天.md","raw":"---\ntitle: iOS swift 3天30个swift项目之第三天\ndate: 2023-02-05 09:32:39\nop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- 30个Swift项目\ncategories:\n- iOS\n---\n\n## 1 滑动删除\n\n### 1.1 效果\n<img src=Swipeable%20Cell.gif>\n\n### 1.2 列表实现\n```Swift\nclass ViewController: UITableViewController {\n```\n\n数据定义：\n```Swift\nvar data = [\n    pattern(image: \"1\", name: \"Pattern Building\"),\n    pattern(image: \"2\", name: \"Joe Beez\"),\n    pattern(image: \"3\", name: \"Car It's car\"),\n    pattern(image: \"4\", name: \"Floral Kaleidoscopic\"),\n    pattern(image: \"5\", name: \"Sprinkle Pattern\"),\n    pattern(image: \"6\", name: \"Palitos de queso\"),\n    pattern(image: \"7\", name: \"Ready to Go? Pattern\"),\n    pattern(image: \"8\", name: \"Sets Seamless\"),\n]\n```\n\n数据绑定：\n```Swift\noverride func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        return data.count\n    }\n    \noverride func numberOfSections(in tableView: UITableView) -> Int {\n    return 4\n}\n\noverride func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n    return 60\n}\n\noverride func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    let cell = tableView.dequeueReusableCell(withIdentifier: \"PatternCell\", for: indexPath) as! PatternCell\n    let pattern = data[indexPath.row]\n    \n    cell.patternImageView.image = UIImage(named: pattern.image)\n    cell.patternNameLabel.text = pattern.name\n    return cell\n}\n\n// 横滑 增加3个UITableViewRowAction \noverride func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -> [UITableViewRowAction]? {\n    let delete = UITableViewRowAction(style: .normal, title: \"🗑\\nDelete\") { action, index in\n        print(\"Delete button tapped\")\n    }\n    delete.backgroundColor = UIColor.gray\n    \n    // 分析点击事件\n    let share = UITableViewRowAction(style: .normal, title: \"🤗\\nShare\") { (action, indexPath) in\n        let firstActivityItem = self.data[indexPath.row]\n        let activityViewController = UIActivityViewController(activityItems: [firstActivityItem.image as NSString], applicationActivities: nil)\n        \n        self.present(activityViewController, animated: true, completion: nil)\n    }\n    share.backgroundColor = UIColor.red\n    \n    let download = UITableViewRowAction(style: .normal, title: \"⬇️\\nDownload\") { action, index in\n        print(\"Download button tapped\")\n    }\n    download.backgroundColor = UIColor.blue\n    \n    return [download, share, delete]\n}\n\noverride func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool {\n    return true\n}\n\noverride func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) {\n    switch editingStyle {\n    case .delete:\n        print(\"Delete\")\n    case .insert:\n        print(\"Insert\")\n    case .none:\n        print(\"None\")\n    }\n}\n```\n\ncell是自定义的，但主要是通过故事版拖动的，代码绑定里面没有做其它事情。\n其实这个横滑效果，是系统支持的，我们只需要多实现一些协议方法即可。\n\n## 2 3D触摸菜单\n\n### 2.1 效果\n<img src=3DTouchQuickAction.gif>\n\n### 2.2 页面定义\n首页很简单，这里是在故事版里面绑定的控制器。\n就中间一个Label。\n\n然后还有2个页面，都是一张图片，在故事版里面定义了，没有在代码里面声明。\n\n### 2.3 配置3D菜单\n先在info.plist中配置菜单，这里先不实现具体跳转：\n<img src=22.png>\n\n### 2.4 AppDelegate配置\n```Swift\nenum ShortcutIdentifier: String {\n    \n    case First\n    case Second\n    case Third\n    \n    init?(fullType: String) {\n        guard let last = fullType.components(separatedBy: \".\").last else {\n            return nil\n        }\n        self.init(rawValue: last)\n    }\n    \n    var type: String {\n        return Bundle.main.bundleIdentifier! + \".\\(self.rawValue)\"\n    }\n}\n```\n\n这里先定义一个枚举，注意到这里的type为Bundle.main.bundleIdentifier，这里应该必须要为这个了。\n\n然后这里配置application协议：\n```Swift\nfunc application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -> Void) {\n    let handledShortCutItem = handleShortCutItem(shortcutItem)\n    // 走回调\n    completionHandler(handledShortCutItem)\n}\n\nfunc handleShortCutItem(_ shortcutItem: UIApplicationShortcutItem) -> Bool {\n        \n    var handled = false\n    \n    guard let _ = ShortcutIdentifier(fullType: shortcutItem.type) else {\n        return false\n    }\n    \n    guard let shortCutType = shortcutItem.type as String? else {\n        return false\n    }\n    \n    let storyboard = UIStoryboard(name: \"Main\", bundle: nil)\n    var vc: UIViewController\n    \n    switch (shortCutType) {\n    case ShortcutIdentifier.First.type:\n        // Handle shortcut 1\n        vc = storyboard.instantiateViewController(withIdentifier: \"RunVC\") as! RunViewController\n        handled = true\n    case ShortcutIdentifier.Second.type:\n        // Handle shortcut 2\n        vc = storyboard.instantiateViewController(withIdentifier: \"ScanVC\") as! ScanViewController\n        handled = true\n    case ShortcutIdentifier.Third.type:\n        // Handle shortcut 3\n        vc = storyboard.instantiateViewController(withIdentifier: \"WiFiVC\") as! SwitchWiFiViewController\n        handled = true\n    default:\n        vc = UIViewController()\n        break\n    }\n    \n    // Display the selected view controller\n    //\n    var presentedVC: UIViewController = window!.rootViewController!\n    while presentedVC.presentedViewController != nil {\n        presentedVC = presentedVC.presentedViewController!\n    }\n    if !presentedVC.isMember(of: vc.classForCoder) {\n        presentedVC.present(vc, animated: true, completion: nil)\n    }\n    \n    return handled\n}\n```\n这里定义了快捷键方式跳转方式，这里通过获取到Main的故事版，然后，故事版去instantiateViewController来获取其它的控制器，这里再通过present方法跳转到目标控制器。\n\n## 3 侧滑菜单\n\n### 3.1 效果\n<img src=SlideOutMenu.gif>\n\n### 3.2 侧滑支持\n首先需要引入SWRevealViewController.h和SWRevealViewController.m文件。\n这个用官方的即可，文件比较长，就不贴进来了。\n\n### 3.3 故事版定义\n<img src=23_1.png>\n这里定义好了跳转逻辑，直接在故事版里面操作的。\n\n其它2个item也是如此。\n\n主要是在Main.storyboard中定义了第一个控制为：SWRevealViewController\n这个是oc写的。\n\n故事版里面定义了这个控制器会指向一个BackTableVC。\n\n\n### 3.4 控制器配置\n第一个菜单控制器为：\n```Swift\nclass Channel : UIViewController {\n    \n    override func viewDidLoad() {\n        self.navigationController?.isNavigationBarHidden = true\n        self.view.addGestureRecognizer(self.revealViewController().panGestureRecognizer())\n    }\n    \n}\n```\n\n第二个菜单控制器为：\n```Swift\nclass ReadLater : UIViewController {\n    \n    override func viewDidLoad() {\n        self.navigationController?.isNavigationBarHidden = true\n        self.view.addGestureRecognizer(self.revealViewController().panGestureRecognizer())\n    }\n    \n}\n```\n\n第三个菜单控制为：\n```Swift\nclass FriendRead : UIViewController {\n    \n    override func viewDidLoad() {\n        self.navigationController?.isNavigationBarHidden = true\n        self.view.addGestureRecognizer(self.revealViewController().panGestureRecognizer())   \n    }   \n}\n```\n\n这里必须配置：\n```\n self.view.addGestureRecognizer(self.revealViewController().panGestureRecognizer())   \n```\n才能实现菜单左滑手势效果哦。\n\n## 4 磁片效果\n\n### 4.1 效果\n<img src=MosaicLayouts.gif>\n\n### 4.2 pod引入三方库\n这里通过Pod引入依赖，如下图：\n<img src=24_1.png>\n\n这里引入了FMMosaicLayout库+AFNetworking+ORStackView+SwiftyJSON\n用了这四个库。\n\n### 4.3 页面定义\n这里也是用了一个UICollectionView，单一个页面。\n直接继承了这个：UICollectionViewController。\n\n```Swift\noverride func numberOfSections(in collectionView: UICollectionView) -> Int {\n        return 10\n    }\n    \noverride func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n    let cell = collectionView.dequeueReusableCell(withReuseIdentifier: \"Cell\", for: indexPath)\n    cell.alpha = 0\n    \n    let imageView = cell.contentView.viewWithTag(2) as! UIImageView\n    imageView.image = UIImage(named: imageArray[indexPath.row])\n    \n    let cellDelay = UInt64((arc4random() % 600 ) / 1000 )\n    let cellDelayTime = DispatchTime(uptimeNanoseconds: cellDelay * NSEC_PER_SEC)\n    DispatchQueue.main.asyncAfter(deadline: cellDelayTime) {\n        UIView.animate(withDuration: 0.8, animations: {\n            cell.alpha = 1.0\n        })\n    }\n    \n    return cell\n}\n\n\noverride func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {\n    return imageArray.count\n}\n```\n主要实现了这几个协议方法。\nCell用了系统的。\n\n内容直接用UIImageView表示。\n\n然后这里异步开启动画效果，alpha从0到1的变化效果。\n\n### 4.4 初始化\n```Swift\nvar imageArray = [String]()\n\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    imageArray = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\"]\n    let mosaicLayout = FMMosaicLayout()\n    self.collectionView?.collectionViewLayout = mosaicLayout\n    if #available(iOS 11.0, *) {\n        self.collectionView?.contentInsetAdjustmentBehavior = .never\n    }\n}\n```\n这里初始化的时候，将collectionView的collectionViewLayout设置为三方库的View。\n\n如何设置为不同大小，这里就是三方库的作用了：\n```Swift\nextension ViewController : FMMosaicLayoutDelegate {\n\n    func collectionView(_ collectionView: UICollectionView!, layout collectionViewLayout: FMMosaicLayout!, numberOfColumnsInSection section: Int) -> Int {\n        return 3\n    }\n\n    func collectionView(_ collectionView: UICollectionView!, layout collectionViewLayout: FMMosaicLayout!, mosaicCellSizeForItemAt indexPath: IndexPath!) -> FMMosaicCellSize {\n        return indexPath.item % 7 == 0 ? .big : .small\n    }\n\n    func collectionView(_ collectionView: UICollectionView!, layout collectionViewLayout: FMMosaicLayout!, interitemSpacingForSectionAt section: Int) -> CGFloat {\n        return 1.0\n    }\n\n    func collectionView(_ collectionView: UICollectionView!, layout collectionViewLayout: FMMosaicLayout!, insetForSectionAt section: Int) -> UIEdgeInsets {\n        return UIEdgeInsets(top: 1.0, left: 1.0, bottom: 1.0, right: 1.0)\n    }\n}\n```\n这里如果是7的倍数就大图，否则小图。有3种类型。\n\n## 5 基础动画\n\n### 5.1 效果\n<img src=BasicAnimation.gif>\n\n### 5.2 故事版\n第一个启动页首先是Main.storyboard故事版，然后这个故事版有一个Storyboard Entry Point就是第一个场景了，这里第一个场景是空的NavigationController Scene。\n\n然后这里绑定了这个第一个场景跳转逻辑，底部这里有个：\n<img src=25_1.png>\n\n那如何修改这个启动路径呢？\n<img src=25_2.png>\n这里最右侧属性里面，先清除掉之前的，然后拖动小圆点，指向目标场景即可哦。\n\n这里Navigation Controller场景指向了BasicAnimation场景，这里面是一个TableView。\n这里配置的UITableView的代理和数据源都指向了Basic Animation。\n<img src=25_3.png>\n这里数据直接在故事版里面写好了。\n\n然后item的跳转也是直接在故事版里面拖动的：\n<img src=25_4.png>\n\n这里其实对应的首页的Controller没有啥东西：\n```Swift\nclass ViewController: UITableViewController {\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        self.tableView.tableFooterView = UIView(frame: .zero)\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n}\n```\n\n### 5.3 Position动画\n这里定义了3个方块。\n```Swift\nclass PositionViewController: UIViewController {\n\n    @IBOutlet weak var yellowSquareView: UIView!\n    @IBOutlet weak var blueSquareView: UIView!\n    @IBOutlet weak var mouseView: UIView!    \n```\n\n已经出现动画时执行动画：\n```Swift\noverride func viewDidAppear(_ animated: Bool) {\n        super.viewDidAppear(animated)\n        \n    UIView.animate(withDuration: 0.8, delay: 0.2, usingSpringWithDamping: 0.6, initialSpringVelocity: 0.8, options: .curveEaseInOut, animations: {\n        self.yellowSquareView.center.x = self.view.bounds.width - self.yellowSquareView.center.x\n        self.yellowSquareView.center.y = self.yellowSquareView.center.y + 30\n        self.blueSquareView.center.x = self.view.bounds.width -  self.blueSquareView.center.x\n        self.blueSquareView.center.y = self.blueSquareView.center.y + 30\n\n        }, completion: nil )\n    \n    UIView.animate(withDuration: 0.6, delay: 0.4, usingSpringWithDamping: 0.6, initialSpringVelocity: 0.8, options: .curveEaseOut, animations: {\n        self.setHeight(180)\n        self.mouseView.center.y = self.view.bounds.height - self.mouseView.center.y\n        }, completion: nil )\n}\n\nfunc setHeight(_ height: CGFloat) {\n    \n    var frame: CGRect = self.mouseView.frame\n    frame.size.height = height\n    \n    self.mouseView.frame = frame\n}\n```\n\n### 5.4 Opacity动画\n```Swift\nclass OpacityViewController: UIViewController {\n\n    @IBOutlet weak var exampleImageView: UIImageView!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n    \n    override func viewDidAppear(_ animated: Bool) {\n        super.viewDidAppear(animated)\n        \n        UIView.animate(withDuration: 2) {\n            self.exampleImageView.alpha = 0\n        }\n    }\n}\n```\n这里控制图片alpha从1到0的动画。\n\n### 5.5 Scale动画\n```Swift\nclass ScaleViewController: UIViewController {\n\n    @IBOutlet weak var scaleImageView: UIImageView!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        self.scaleImageView.alpha = 0\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n    \n    override func viewDidAppear(_ animated: Bool) {\n        super.viewDidAppear(animated)\n        \n        \n        UIView.animate(withDuration: 0.8, delay: 0, usingSpringWithDamping: 0.7, initialSpringVelocity: 1, options: .curveEaseIn, animations: {\n            self.scaleImageView.transform = CGAffineTransform(scaleX: 2, y: 2)\n            self.scaleImageView.alpha = 1\n            \n            }, completion: nil )\n    }\n}\n```\n这里alpha从0到1,缩放动画从1到2。\n\n### 5.6 Color动画\n```Swift\nclass ColorViewController: UIViewController {\n\n    @IBOutlet weak var bgColorView: UIView!\n    @IBOutlet weak var numberLabel: UILabel!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n    \n    override func viewDidAppear(_ animated: Bool) {\n        super.viewDidAppear(animated)\n        \n        \n        UIView.animate(withDuration: 0.5, delay: 0.2, options: .curveEaseIn, animations: {\n            self.bgColorView.backgroundColor = .black\n            \n            }, completion: nil )\n        \n        UIView.animate(withDuration: 0.5, delay: 0.8, options: .curveEaseOut, animations: {\n            self.numberLabel.textColor = UIColor(red:0.959, green:0.937, blue:0.109, alpha:1)\n            \n            }, completion: nil)\n    }\n}\n```\n这里设置颜色从黄到黑，文字颜色也变化了。\n\n### 5.7 Rotation动画\n```Swift \nclass RotationViewController: UIViewController {\n\n    @IBOutlet weak var emojiLabel: UILabel!\n    @IBOutlet weak var rotationImageView: UIImageView!\n    @IBOutlet weak var trump2: UIImageView!\n    @IBOutlet weak var trump3: UIImageView!\n    @IBOutlet weak var trump4: UIImageView!\n    @IBOutlet weak var trump5: UIImageView!\n    @IBOutlet weak var trump6: UIImageView!\n    @IBOutlet weak var trump7: UIImageView!\n    @IBOutlet weak var trump8: UIImageView!\n    \n    func spin() {\n        UIView.animate(withDuration: 0.8, delay: 0, options: .curveLinear, animations: {\n            self.rotationImageView.transform = self.rotationImageView.transform.rotated(by: CGFloat(Double.pi))\n            self.trump2.transform = self.trump2.transform.rotated(by: CGFloat(Double.pi))\n            self.trump3.transform = self.trump3.transform.rotated(by: CGFloat(Double.pi))\n            self.trump4.transform = self.trump4.transform.rotated(by: CGFloat(Double.pi))\n            self.trump5.transform = self.trump5.transform.rotated(by: CGFloat(Double.pi))\n            self.trump6.transform = self.trump6.transform.rotated(by: CGFloat(Double.pi))\n            self.trump7.transform = self.trump7.transform.rotated(by: CGFloat(Double.pi))\n            self.trump8.transform = self.trump8.transform.rotated(by: CGFloat(Double.pi))\n            self.emojiLabel.transform = self.emojiLabel.transform.rotated(by: CGFloat(Double.pi))\n            }) { (finished) -> Void in\n                self.spin()\n        }\n    }\n    \n    override func viewDidAppear(_ animated: Bool) {\n        super.viewDidAppear(animated)\n        self.spin()\n    }\n}\n```\n这里让8个视图都开始旋转了。\n\n## 6 CoreData使用\n\n### 6.1 效果\n<img src=CoreData.gif>\n\n### 6.2 AddDelegate配置\n```Swift\nlazy var applicationDocumentsDirectory: NSURL = {\n        // The directory the application uses to store the Core Data store file. This code uses a directory named \"me.appkitchen.cd\" in the application's documents Application Support directory.\n        let urls = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)\n        return urls[urls.count-1] as NSURL\n    }()\n\nlazy var managedObjectModel: NSManagedObjectModel = {\n    // The managed object model for the application. This property is not optional. It is a fatal error for the application not to be able to find and load its model.\n    let modelURL = Bundle.main.url(forResource: \"cd\", withExtension: \"momd\")!\n    return NSManagedObjectModel(contentsOf: modelURL)!\n}()\n\nlazy var persistentStoreCoordinator: NSPersistentStoreCoordinator = {\n    // The persistent store coordinator for the application. This implementation creates and returns a coordinator, having added the store for the application to it. This property is optional since there are legitimate error conditions that could cause the creation of the store to fail.\n    // Create the coordinator and store\n    let coordinator = NSPersistentStoreCoordinator(managedObjectModel: self.managedObjectModel)\n    let url = self.applicationDocumentsDirectory.appendingPathComponent(\"SingleViewCoreData.sqlite\")\n    var failureReason = \"There was an error creating or loading the application's saved data.\"\n    do {\n        try coordinator.addPersistentStore(ofType: NSSQLiteStoreType, configurationName: nil, at: url, options: nil)\n    } catch {\n        // Report any error we got.\n        var dict = [String: AnyObject]()\n        dict[NSLocalizedDescriptionKey] = \"Failed to initialize the application's saved data\" as AnyObject\n        dict[NSLocalizedFailureReasonErrorKey] = failureReason as AnyObject\n\n        dict[NSUnderlyingErrorKey] = error as NSError\n        let wrappedError = NSError(domain: \"YOUR_ERROR_DOMAIN\", code: 9999, userInfo: dict)\n        // Replace this with code to handle the error appropriately.\n        // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.\n        NSLog(\"Unresolved error \\(wrappedError), \\(wrappedError.userInfo)\")\n        abort()\n    }\n\n    return coordinator\n}()\n\nlazy var managedObjectContext: NSManagedObjectContext = {\n    // Returns the managed object context for the application (which is already bound to the persistent store coordinator for the application.) This property is optional since there are legitimate error conditions that could cause the creation of the context to fail.\n    let coordinator = self.persistentStoreCoordinator\n    var managedObjectContext = NSManagedObjectContext(concurrencyType: .mainQueueConcurrencyType)\n    managedObjectContext.persistentStoreCoordinator = coordinator\n    return managedObjectContext\n}()\n\n// MARK: - Core Data Saving support\n\nfunc saveContext () {\n    if managedObjectContext.hasChanges {\n        do {\n            try managedObjectContext.save()\n        } catch {\n            // Replace this implementation with code to handle the error appropriately.\n            // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.\n            let nserror = error as NSError\n            NSLog(\"Unresolved error \\(nserror), \\(nserror.userInfo)\")\n            abort()\n        }\n    }\n}\n```\n因为代码比较久了，这个按照XCode指示修复后就是这个效果。\n这里可以运行了。\n\n主要是applicationWillTerminate方法中saveContext了。\n\n### 6.3 可见数据操作\n这里代码使用还有点问题，暂时无法贴最新代码。\n关于CoreData的使用还是建议参考这篇文章：\n[了解和采用 CoreData 框架 —— Ficow 陪你学 CoreData](https://blog.ficowshen.com/page/post/52)。\n\n## 7 底部Bar动画\n\n### 7.1 效果\n<img src=TapBarAnimation.gif>\n\n### 7.2 故事版添加导航item\n<img src=27_1.png>\n\n这里应该是关联到了这3个item。\n这样子，就可以展示底部导航栏效果。\n然后item也定义了跳转的目标场景。\n\n### 7.3 第一个Tab页\n```Swift\nclass FirstTabViewController: UIViewController, UITableViewDataSource, UITableViewDelegate {\n\n    @IBOutlet weak var articleTableView: UITableView!\n    \n    var data = [\n    \n        article(avatarImage: \"allen\", sharedName: \"Allen Wang\", actionType: \"Read Later\", articleTitle: \"Giphy Cam Lets You Create And Share Homemade Gifs\", articleCoverImage: \"giphy\", articleSouce: \"TheNextWeb\", articleTime: \"5min  •  13:20\"),\n        article(avatarImage: \"Daniel Hooper\", sharedName: \"Daniel Hooper\", actionType: \"Shared on Twitter\", articleTitle: \"Principle. The Sketch of Prototyping Tools\", articleCoverImage: \"my workflow flow\", articleSouce: \"SketchTalk\", articleTime: \"3min  •  12:57\"),\n        article(avatarImage: \"davidbeckham\", sharedName: \"David Beckham\", actionType: \"Shared on Facebook\", articleTitle: \"Ohlala, An Uber For Escorts, Launches Its ‘Paid Dating’ Service In NYC\", articleCoverImage: \"Ohlala\", articleSouce: \"TechCrunch\", articleTime: \"1min  •  12:59\"),\n        article(avatarImage: \"bruce\", sharedName: \"Bruce Fan\", actionType: \"Shared on Weibo\", articleTitle: \"Lonely Planet’s new mobile app helps you explore major cities like a pro\", articleCoverImage: \"Lonely Planet\", articleSouce: \"36Kr\", articleTime: \"5min  •  11:21\"),\n\n    ]\n```\n上面是数据定义。\n\n然后设置代理和数据源：\n```Swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    \n    articleTableView.dataSource = self\n    articleTableView.delegate = self\n    articleTableView.separatorStyle = UITableViewCell.SeparatorStyle.none\n    articleTableView.tableFooterView = UIView(frame: .zero)\n}\n\n \nfunc numberOfSectionsInTableView(tableView: UITableView) -> Int {\n    return 10\n}\n\nfunc tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n    return data.count\n}\n\nfunc tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n    return 165\n}\n\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    let cell = articleTableView.dequeueReusableCell(withIdentifier: \"Cell\", for: indexPath) as! ArticleTableViewCell\n    let article = data[indexPath.row]\n    \n    cell.avatarImage.image = UIImage(named: article.avatarImage)\n    cell.articleCoverImage.image = UIImage(named: article.articleCoverImage)\n    cell.sharedNameLabel.text = article.sharedName\n    cell.actionTypeLabel.text = article.actionType\n    cell.articleTitleLabel.text = article.articleTitle\n    cell.articleSouceLabel.text = article.articleSouce\n    cell.articelCreatedAtLabel.text = article.articleTime\n    cell.selectionStyle = UITableViewCell.SelectionStyle.none\n    \n    return cell   \n}\n```\n这里配置了Cell:\n```Swift\nstruct article {\n    let avatarImage: String\n    let sharedName: String\n    let actionType: String\n    let articleTitle: String\n    let articleCoverImage: String\n    let articleSouce: String\n    let articleTime: String\n}\n\nclass ArticleTableViewCell: UITableViewCell {\n\n    @IBOutlet weak var avatarImage: UIImageView!\n    @IBOutlet weak var sharedNameLabel: UILabel!\n    @IBOutlet weak var actionTypeLabel: UILabel!\n    @IBOutlet weak var articleCoverImage: UIImageView!\n    \n    @IBOutlet weak var articleTitleLabel: UILabel!\n    @IBOutlet weak var articleSouceLabel: UILabel!\n    @IBOutlet weak var articelCreatedAtLabel: UILabel!\n    \n    override func awakeFromNib() {\n        super.awakeFromNib()\n        // Initialization code\n\n    }\n\n    override func setSelected(_ selected: Bool, animated: Bool) {\n        super.setSelected(selected, animated: animated)\n\n        // Configure the view for the selected state\n    }\n}\n```\n这里应该就是item配置了，具体布局是用故事版里面的配置的。\n\n可见的时候，执行动画效果：\n```Swift\noverride func viewWillAppear(_ animated: Bool) {   \n    animateTable()\n}\n\nfunc animateTable() {\n    \n    self.articleTableView.reloadData()\n    \n    let cells = articleTableView.visibleCells\n    let tableHeight: CGFloat = articleTableView.bounds.size.height\n    \n    for i in cells {\n        let cell: UITableViewCell = i as UITableViewCell\n        cell.transform = CGAffineTransform(translationX: 0, y: tableHeight)\n    }\n    \n    var index = 0\n    \n    for a in cells {\n        let cell: UITableViewCell = a as UITableViewCell\n        UIView.animate(withDuration: 1.0, delay: 0.05 * Double(index), usingSpringWithDamping: 0.8, initialSpringVelocity: 0, options: [], animations: {\n            cell.transform = CGAffineTransform(translationX: 0, y: 0);\n            }, completion: nil)\n        \n        index += 1\n    }\n}\n```\n从下往上的动画效果。\n\n\n### 7.4 第二个Tab的动画\n```Swift\noverride func viewDidAppear(_ animated: Bool) {\n    super.viewDidAppear(animated)\n    \n    UIView.animate(withDuration: 0.5, delay: 0.1, usingSpringWithDamping: 0.7, initialSpringVelocity: 1, options: .curveEaseIn, animations: {\n        self.exploreImageView.transform = CGAffineTransform(scaleX: 1, y: 1)\n        self.exploreImageView.alpha = 1\n        \n        }, completion: nil )\n}\n\noverride func viewDidDisappear(_ animated: Bool) {\n    super.viewDidDisappear(animated)\n    resetViewTransform()\n}\n\n// MARK:\nfunc resetViewTransform() {\n    self.exploreImageView.alpha = 0\n    self.exploreImageView.transform = CGAffineTransform(scaleX: 0.5, y: 0.5)\n}\n```\n\n### 7.5 第三个Tab的动画\n```Swift\noverride func viewDidAppear(_ animated: Bool) {\n        super.viewDidAppear(animated)\n    \n    UIView.animate(withDuration: 0.5, delay: 0.1, usingSpringWithDamping: 0.7, initialSpringVelocity: 1, options: .curveEaseIn, animations: {\n        self.profileImageView.transform = CGAffineTransform(scaleX: 1, y: 1)\n        self.profileImageView.alpha = 1\n        \n        }, completion: nil )\n}\n\noverride func viewDidDisappear(_ animated: Bool) {\n    super.viewDidDisappear(animated)\n    resetViewTransform()\n}\n\n// MARK:\nfunc resetViewTransform() {\n    self.profileImageView.alpha = 0\n    self.profileImageView.transform = CGAffineTransform(scaleX: 0.5, y: 0.5)\n}\n```\n\n## 8 系统搜索\n\n### 8.1 效果\n<img src=Spotlight%20Search.gif>\n\n### 8.2 首页\n数据设置：\n<img src=28_1.png>\n这里新建了一个电影数据，用key-value形式保存了。\n\n可见时处理：\n```Swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    loadMoviesInfo()\n    configureTableView()\n    navigationItem.title = \"Movies\"\n    setupSearchableContent()\n}\n\n// 加载根目录文件数据，拿到数组\nfunc loadMoviesInfo() {\n    if let path = Bundle.main.path(forResource: \"MoviesData\", ofType: \"plist\") {\n        moviesInfo = NSMutableArray(contentsOfFile: path)\n    }\n}\n\n// 配置代理和数据源\nfunc configureTableView() {\n    tblMovies.delegate = self\n    tblMovies.dataSource = self\n    tblMovies.tableFooterView = UIView(frame: CGRect.zero)\n    tblMovies.register(UINib(nibName: \"MovieSummaryCell\", bundle: nil), forCellReuseIdentifier: \"idCellMovieSummary\")\n}\n\n// 搜索数据装载，使用了系统的类  CSSearchableItem\nfunc setupSearchableContent() {\n    var searchableItems = [CSSearchableItem]()\n    \n    for i in 0...(moviesInfo.count - 1) {\n        \n        let movie = moviesInfo[i] as! [String: String]\n        let searchableItemAttributeSet = CSSearchableItemAttributeSet(itemContentType: kUTTypeText as String)\n        \n        //set the title\n        searchableItemAttributeSet.title = movie[\"Title\"]!\n        \n        //set the image\n        let imagePathParts = movie[\"Image\"]!.components(separatedBy: \".\")\n        searchableItemAttributeSet.thumbnailURL = Bundle.main.url(forResource: imagePathParts[0], withExtension: imagePathParts[1])\n        \n        // Set the description.\n        searchableItemAttributeSet.contentDescription = movie[\"Description\"]!\n        \n        var keywords = [String]()\n        let movieCategories = movie[\"Category\"]!.components(separatedBy: \", \")\n        for movieCategory in movieCategories {\n            keywords.append(movieCategory)\n        }\n        \n        let stars = movie[\"Stars\"]!.components(separatedBy: \", \")\n        for star in stars {\n            keywords.append(star)\n        }\n        \n        searchableItemAttributeSet.keywords = keywords\n        \n        let searchableItem = CSSearchableItem(uniqueIdentifier: \"com.appcoda.SpotIt.\\(i)\", domainIdentifier: \"movies\", attributeSet: searchableItemAttributeSet)\n        \n        searchableItems.append(searchableItem)\n        \n        CSSearchableIndex.default().indexSearchableItems(searchableItems) {\n            if $0 != nil {\n                print($0!.localizedDescription)\n            }\n        }\n    }\n}\n```\n\n监听系统搜索后跳转逻辑：\n```Swift\noverride func restoreUserActivityState(_ activity: NSUserActivity) {\n    if activity.activityType == CSSearchableItemActionType {\n        if let userInfo = activity.userInfo {\n            let selectedMovie = userInfo[CSSearchableItemActivityIdentifier] as! String\n            selectedMovieIndex = Int(selectedMovie.components(separatedBy: \".\").last!)\n            performSegue(withIdentifier: \"idSegueShowMovieDetails\", sender: self)\n        }\n    }\n}\n```\n\n然后是代理和数据源配置：\n```Swift\n func numberOfSections(in tableView: UITableView) -> Int {\n        return 1\n    }\n    \nfunc tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n    if moviesInfo != nil {\n        return moviesInfo.count\n    }\n    return 0\n}\n\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    let cell = tableView.dequeueReusableCell(withIdentifier: \"idCellMovieSummary\", for: indexPath) as! MovieSummaryCell\n    let currentMovieInfo = moviesInfo[(indexPath as NSIndexPath).row] as! [String: String]\n    \n    cell.lblTitle.text = currentMovieInfo[\"Title\"]!\n    cell.lblDescription.text = currentMovieInfo[\"Description\"]!\n    cell.lblRating.text = currentMovieInfo[\"Rating\"]!\n    cell.imgMovieImage.image = UIImage(named: currentMovieInfo[\"Image\"]!)\n    \n    return cell\n}\n\nfunc tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n    return 100.0\n}\n\nfunc tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n    selectedMovieIndex = (indexPath as NSIndexPath).row\n    performSegue(withIdentifier: \"idSegueShowMovieDetails\", sender: self)\n}\n\noverride func prepare(for segue: UIStoryboardSegue, sender: Any?) {\n    if let identifier = segue.identifier, identifier == \"idSegueShowMovieDetails\" {\n        let movieDetailsViewController = segue.destination as! MovieDetailsViewController\n        movieDetailsViewController.movieInfo = moviesInfo[selectedMovieIndex] as? [String: String]\n    }\n}\n```\n这里didSelectRowAt，通过调用系统的performSegue决定跳转到某个场景。\n\n### 8.3 详情页\n```Swift\nclass MovieDetailsViewController: UIViewController {\n\n    @IBOutlet weak var imgMovieImage: UIImageView!\n    @IBOutlet weak var lblTitle: UILabel!\n    @IBOutlet weak var lblCategory: UILabel!\n    @IBOutlet weak var lblDescription: UILabel!\n    @IBOutlet weak var lblDirector: UILabel!\n    @IBOutlet weak var lblStars: UILabel!\n    @IBOutlet weak var lblRating: UILabel!\n    \n    var movieInfo: [String: String]!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n    }\n    \n    override func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n        \n        lblRating.layer.cornerRadius = lblRating.frame.size.width/2\n        lblRating.layer.masksToBounds = true\n        \n        if movieInfo != nil {\n            populateMovieInfo()\n        }\n    }\n    \n    \n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n    \n    func populateMovieInfo() {\n        \n        lblTitle.text = movieInfo[\"Title\"]!\n        lblCategory.text = movieInfo[\"Category\"]!\n        lblDescription.text = movieInfo[\"Description\"]!\n        lblDirector.text = movieInfo[\"Director\"]!\n        lblStars.text = movieInfo[\"Stars\"]!\n        lblRating.text = movieInfo[\"Rating\"]!\n        imgMovieImage.image = UIImage(named: movieInfo[\"Image\"]!)\n        \n    }\n}\n```\n这里配置了movieInfo，外部设置进来，然后回显进去。\n\n## 9 选择头像\n\n### 9.1 效果\n<img src=AvatarPicker.gif>\n\n### 9.2 点击头像\n```Swift\n@IBAction func pickProfileImage(_ tap: UITapGestureRecognizer) {\n    let authorization = PHPhotoLibrary.authorizationStatus()\n    \n    if authorization == .notDetermined {\n        PHPhotoLibrary.requestAuthorization { _ in\n            DispatchQueue.main.async {\n                self.pickProfileImage(tap)\n            }\n        }\n    }\n    \n    if authorization == .authorized {\n        let controller = ImagePickerSheetController()\n        controller.addAction(action: ImageAction(title: NSLocalizedString(\"Take Photo or Video\", comment: \"Action Title\"), secondaryTitle: NSLocalizedString(\"Use this one\", comment: \"Action Title\"), handler: { _ in\n            self.presentCamera()\n        }, secondaryHandler: { (action, numberOfPhotos) in\n            controller.getSelectedImagesWithCompletion(completion: { images in\n                self.profileImage = images[0]\n                self.userProfileImageView.image = self.profileImage\n            })\n        }))\n                    \n        controller.addAction(action: ImageAction(title: NSLocalizedString(\"Cancel\", comment: \"Action Title\"), style: .Cancel, handler: nil, secondaryHandler: nil))\n        \n        self.present(controller, animated: true, completion: nil)\n    }\n    \n    \n}\n\nfunc presentCamera()\n{\n    print(\"拍照\")\n}\n```\n这里先判断有无权限，没有权限继续执行，有权限再跳转控制器。\n\n## 10 wiki-Face\n\n### 10.1 效果\n<img src=wikiFace.gif>\n\n### 10.2 搜索处理\n```Swift\nfunc textFieldShouldReturn(_ textField: UITextField) -> Bool {\n        \n    textField.resignFirstResponder()\n    \n    if let textFieldContent = textField.text {\n        do {\n            try WikiFace.faceForPerson(textFieldContent, size: CGSize(width: 300, height: 400), completion: { (image:UIImage?, imageFound:Bool) -> () in\n                if imageFound == true {\n                    DispatchQueue.main.async {\n                        self.faceImageView.image = image\n                        \n                        UIView.animate(withDuration: 0.8, delay: 0, usingSpringWithDamping: 0.7, initialSpringVelocity: 1, options: .curveEaseIn, animations: { () -> Void in\n                            \n                            self.faceImageView.transform = CGAffineTransform(scaleX: 1, y: 1)\n                            self.faceImageView.alpha = 1\n                            \n                            //Fuck! Useless...LOL\n                            self.faceImageView.layer.shadowOpacity = 0.4\n                            self.faceImageView.layer.shadowOffset = CGSize(width: 3.0, height: 2.0)\n                            self.faceImageView.layer.shadowRadius = 15.0\n                            self.faceImageView.layer.shadowColor = UIColor.black.cgColor\n                            \n                        }, completion: nil )\n                        \n                        WikiFace.centerImageViewOnFace(self.faceImageView)\n                    }\n                }\n\n            })\n        }catch WikiFace.WikiFaceError.CouldNotDownloadImage{\n            print(\"Could not access wikipedia for downloading an image\")\n        } catch {\n            print(error)\n        }\n    }\n    \n    return true\n    \n}\n```\n\n使用工具类：\n```Swift\nimport UIKit\nimport ImageIO\n\nclass WikiFace: NSObject {\n    \n    enum WikiFaceError: Error {\n        case CouldNotDownloadImage\n    }\n    \n    class func faceForPerson(_ person: String, size: CGSize, completion:@escaping (_ image: UIImage? ,_ imageFound: Bool) -> ()) throws {\n        \n        let escapedString = person.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlHostAllowed)\n        let pixelsForAPIRequest = Int(max(size.width, size.height)) * 2\n        \n        let url = URL(string: \"https://en.wikipedia.org/w/api.php?action=query&titles=\\(escapedString!)&prop=pageimages&format=json&pithumbsize=\\(pixelsForAPIRequest)\")\n        \n        let task: URLSessionTask = URLSession.shared.dataTask(with: url!, completionHandler: {\n            (data: Data?, response: URLResponse?, error: Error?) in\n            if error == nil {\n                let wikiDict = try! JSONSerialization.jsonObject(with: data!, options: JSONSerialization.ReadingOptions.allowFragments) as! NSDictionary\n        \n                if let query = wikiDict.object(forKey: \"query\") as? NSDictionary {\n                    if let pages = query.object(forKey: \"pages\") as? NSDictionary {\n                        if let pageContent = pages.allValues.first as? NSDictionary {\n                            if let thumbnail = pageContent.object(forKey: \"thumbnail\") as? NSDictionary {\n                                if let thumbURL = thumbnail.object(forKey: \"source\") as? String {\n                                    let faceImage = UIImage(data: try! Data(contentsOf: URL(string: thumbURL)!))\n                                    completion(faceImage, true)\n                                }\n                            }else{\n                                completion(nil, false)\n                            }\n                        }\n                    }\n                }\n            }\n        })\n        task.resume()\n    }\n    \n    class func centerImageViewOnFace (_ imageView: UIImageView) {\n        \n        let context = CIContext(options: nil)\n        let options = [CIDetectorAccuracy:CIDetectorAccuracyHigh]\n        let detector = CIDetector(ofType: CIDetectorTypeFace, context: context, options: options)\n        \n        let faceImage = imageView.image\n        let ciImage = CIImage(cgImage: faceImage!.cgImage!)\n        \n        let features = detector?.features(in: ciImage)\n        \n        if (features?.count)! > 0 {\n            \n            var face:CIFaceFeature!\n            \n            for rect in features! {\n                face = rect as? CIFaceFeature\n            }\n            \n            var faceRectWithExtendedBounds = face.bounds\n            faceRectWithExtendedBounds.origin.x -= 20\n            faceRectWithExtendedBounds.origin.y -= 30\n            \n            faceRectWithExtendedBounds.size.width += 40\n            faceRectWithExtendedBounds.size.height += 60\n            \n            let x = faceRectWithExtendedBounds.origin.x / faceImage!.size.width\n            let y = (faceImage!.size.height - faceRectWithExtendedBounds.origin.y - faceRectWithExtendedBounds.size.height) / faceImage!.size.height\n            \n            let widthFace = faceRectWithExtendedBounds.size.width / faceImage!.size.width\n            let heightFace = faceRectWithExtendedBounds.size.height  / faceImage!.size.height\n            \n            imageView.layer.contentsRect = CGRect(x: x, y: y, width: widthFace, height: heightFace)\n        }\n    }\n}\n```\n这里应该是走异步接口，然后将网络图片设置给UIImageVIew了。\n\n## 11 总结\n\n* 滑动删除效果其实是UITableView里面自带的一个方法editActionsForRowAt方法，里面配置的UITableViewRowAction实现的。\n\n* 3D触摸效果，首先需要在info.plist中配置菜单，然后在AppDelegate中定义菜单的跳转逻辑，可以present方式跳转到目标页面。\n\n* 侧滑菜单，这个需要引入一下SWRevealViewController，这个是oc写的，这里面配置一下菜单控制器，这样就可以实现侧滑效果，主要工作量在SWRevealViewController里面。\n\n* 磁片效果，这个主要是引入了一个三方库，FMMosaicLayout库，需要实现一下FMMosaicLayoutDelegate这个方法，这样就可以实现不同item的大小。\n\n* 基础动画，这里定义了各种各样的基础动画使用方法，Position动画就是height高度区别，Opacity效果是配置alpah，Scale效果是CGAffineTransform这个配置，Color动画就改变一下颜色值，Rotation动画就是设置transform的rotated方法。\n\n* CoreData的使用主要是现在appDelegate中设置saveContext，其它操作类似操作数据库。\n\n* 底部Bar动画，主要是在可见的时候，对每个UITableViewCell里面做了一个动画效果，里面通过设置CGAffineTransform这个实现。\n\n* 系统搜索，这个首先需要配置一个数据源，可以再plist文件里面写一个数组，然后通过系统的搜索类来实现，CSSearchableIndex这个来注入数据。然后配置restoreUserActivityState这个方法，可以决定item跳转目标类。\n\n* 选择头像，这里主要是用了一个工具类，然后通过PHPotoLibrary获取权限，有权限就跳转，没有权限申请，有权限跳转到自定义的ImagePickerSheetController，然后会present这个类。\n\n* wiki-Face，其实是显示一个网络图片的工具类。当我们编辑框结束，点击return后，这里利用WikiFace静态方法去加载网络接口，然后给图片的image设置进去。\n\n\n\n\n\n","slug":"iOS-swift-3天30个swift项目之第三天","published":1,"updated":"2023-02-05T12:13:17.490Z","_id":"cldrc1wyj000055v718zbbipy","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-滑动删除\"><a href=\"#1-滑动删除\" class=\"headerlink\" title=\"1 滑动删除\"></a>1 滑动删除</h2><h3 id=\"1-1-效果\"><a href=\"#1-1-效果\" class=\"headerlink\" title=\"1.1 效果\"></a>1.1 效果</h3><img src=Swipeable%20Cell.gif>\n\n<h3 id=\"1-2-列表实现\"><a href=\"#1-2-列表实现\" class=\"headerlink\" title=\"1.2 列表实现\"></a>1.2 列表实现</h3><pre><code class=\"line-numbers language-Swift\">class ViewController: UITableViewController &#123;\n</code></pre>\n<p>数据定义：</p>\n<pre><code class=\"line-numbers language-Swift\">var data = [\n    pattern(image: &quot;1&quot;, name: &quot;Pattern Building&quot;),\n    pattern(image: &quot;2&quot;, name: &quot;Joe Beez&quot;),\n    pattern(image: &quot;3&quot;, name: &quot;Car It&#39;s car&quot;),\n    pattern(image: &quot;4&quot;, name: &quot;Floral Kaleidoscopic&quot;),\n    pattern(image: &quot;5&quot;, name: &quot;Sprinkle Pattern&quot;),\n    pattern(image: &quot;6&quot;, name: &quot;Palitos de queso&quot;),\n    pattern(image: &quot;7&quot;, name: &quot;Ready to Go? Pattern&quot;),\n    pattern(image: &quot;8&quot;, name: &quot;Sets Seamless&quot;),\n]\n</code></pre>\n<p>数据绑定：</p>\n<pre><code class=\"line-numbers language-Swift\">override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n        return data.count\n    &#125;\n    \noverride func numberOfSections(in tableView: UITableView) -&gt; Int &#123;\n    return 4\n&#125;\n\noverride func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n    return 60\n&#125;\n\noverride func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n    let cell = tableView.dequeueReusableCell(withIdentifier: &quot;PatternCell&quot;, for: indexPath) as! PatternCell\n    let pattern = data[indexPath.row]\n    \n    cell.patternImageView.image = UIImage(named: pattern.image)\n    cell.patternNameLabel.text = pattern.name\n    return cell\n&#125;\n\n// 横滑 增加3个UITableViewRowAction \noverride func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -&gt; [UITableViewRowAction]? &#123;\n    let delete = UITableViewRowAction(style: .normal, title: &quot;🗑\\nDelete&quot;) &#123; action, index in\n        print(&quot;Delete button tapped&quot;)\n    &#125;\n    delete.backgroundColor = UIColor.gray\n    \n    // 分析点击事件\n    let share = UITableViewRowAction(style: .normal, title: &quot;🤗\\nShare&quot;) &#123; (action, indexPath) in\n        let firstActivityItem = self.data[indexPath.row]\n        let activityViewController = UIActivityViewController(activityItems: [firstActivityItem.image as NSString], applicationActivities: nil)\n        \n        self.present(activityViewController, animated: true, completion: nil)\n    &#125;\n    share.backgroundColor = UIColor.red\n    \n    let download = UITableViewRowAction(style: .normal, title: &quot;⬇️\\nDownload&quot;) &#123; action, index in\n        print(&quot;Download button tapped&quot;)\n    &#125;\n    download.backgroundColor = UIColor.blue\n    \n    return [download, share, delete]\n&#125;\n\noverride func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -&gt; Bool &#123;\n    return true\n&#125;\n\noverride func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) &#123;\n    switch editingStyle &#123;\n    case .delete:\n        print(&quot;Delete&quot;)\n    case .insert:\n        print(&quot;Insert&quot;)\n    case .none:\n        print(&quot;None&quot;)\n    &#125;\n&#125;\n</code></pre>\n<p>cell是自定义的，但主要是通过故事版拖动的，代码绑定里面没有做其它事情。<br>其实这个横滑效果，是系统支持的，我们只需要多实现一些协议方法即可。</p>\n<h2 id=\"2-3D触摸菜单\"><a href=\"#2-3D触摸菜单\" class=\"headerlink\" title=\"2 3D触摸菜单\"></a>2 3D触摸菜单</h2><h3 id=\"2-1-效果\"><a href=\"#2-1-效果\" class=\"headerlink\" title=\"2.1 效果\"></a>2.1 效果</h3><img src=3DTouchQuickAction.gif>\n\n<h3 id=\"2-2-页面定义\"><a href=\"#2-2-页面定义\" class=\"headerlink\" title=\"2.2 页面定义\"></a>2.2 页面定义</h3><p>首页很简单，这里是在故事版里面绑定的控制器。<br>就中间一个Label。</p>\n<p>然后还有2个页面，都是一张图片，在故事版里面定义了，没有在代码里面声明。</p>\n<h3 id=\"2-3-配置3D菜单\"><a href=\"#2-3-配置3D菜单\" class=\"headerlink\" title=\"2.3 配置3D菜单\"></a>2.3 配置3D菜单</h3><p>先在info.plist中配置菜单，这里先不实现具体跳转：<br><img src=22.png></p>\n<h3 id=\"2-4-AppDelegate配置\"><a href=\"#2-4-AppDelegate配置\" class=\"headerlink\" title=\"2.4 AppDelegate配置\"></a>2.4 AppDelegate配置</h3><pre><code class=\"line-numbers language-Swift\">enum ShortcutIdentifier: String &#123;\n    \n    case First\n    case Second\n    case Third\n    \n    init?(fullType: String) &#123;\n        guard let last = fullType.components(separatedBy: &quot;.&quot;).last else &#123;\n            return nil\n        &#125;\n        self.init(rawValue: last)\n    &#125;\n    \n    var type: String &#123;\n        return Bundle.main.bundleIdentifier! + &quot;.\\(self.rawValue)&quot;\n    &#125;\n&#125;\n</code></pre>\n<p>这里先定义一个枚举，注意到这里的type为Bundle.main.bundleIdentifier，这里应该必须要为这个了。</p>\n<p>然后这里配置application协议：</p>\n<pre><code class=\"line-numbers language-Swift\">func application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -&gt; Void) &#123;\n    let handledShortCutItem = handleShortCutItem(shortcutItem)\n    // 走回调\n    completionHandler(handledShortCutItem)\n&#125;\n\nfunc handleShortCutItem(_ shortcutItem: UIApplicationShortcutItem) -&gt; Bool &#123;\n        \n    var handled = false\n    \n    guard let _ = ShortcutIdentifier(fullType: shortcutItem.type) else &#123;\n        return false\n    &#125;\n    \n    guard let shortCutType = shortcutItem.type as String? else &#123;\n        return false\n    &#125;\n    \n    let storyboard = UIStoryboard(name: &quot;Main&quot;, bundle: nil)\n    var vc: UIViewController\n    \n    switch (shortCutType) &#123;\n    case ShortcutIdentifier.First.type:\n        // Handle shortcut 1\n        vc = storyboard.instantiateViewController(withIdentifier: &quot;RunVC&quot;) as! RunViewController\n        handled = true\n    case ShortcutIdentifier.Second.type:\n        // Handle shortcut 2\n        vc = storyboard.instantiateViewController(withIdentifier: &quot;ScanVC&quot;) as! ScanViewController\n        handled = true\n    case ShortcutIdentifier.Third.type:\n        // Handle shortcut 3\n        vc = storyboard.instantiateViewController(withIdentifier: &quot;WiFiVC&quot;) as! SwitchWiFiViewController\n        handled = true\n    default:\n        vc = UIViewController()\n        break\n    &#125;\n    \n    // Display the selected view controller\n    //\n    var presentedVC: UIViewController = window!.rootViewController!\n    while presentedVC.presentedViewController != nil &#123;\n        presentedVC = presentedVC.presentedViewController!\n    &#125;\n    if !presentedVC.isMember(of: vc.classForCoder) &#123;\n        presentedVC.present(vc, animated: true, completion: nil)\n    &#125;\n    \n    return handled\n&#125;\n</code></pre>\n<p>这里定义了快捷键方式跳转方式，这里通过获取到Main的故事版，然后，故事版去instantiateViewController来获取其它的控制器，这里再通过present方法跳转到目标控制器。</p>\n<h2 id=\"3-侧滑菜单\"><a href=\"#3-侧滑菜单\" class=\"headerlink\" title=\"3 侧滑菜单\"></a>3 侧滑菜单</h2><h3 id=\"3-1-效果\"><a href=\"#3-1-效果\" class=\"headerlink\" title=\"3.1 效果\"></a>3.1 效果</h3><img src=SlideOutMenu.gif>\n\n<h3 id=\"3-2-侧滑支持\"><a href=\"#3-2-侧滑支持\" class=\"headerlink\" title=\"3.2 侧滑支持\"></a>3.2 侧滑支持</h3><p>首先需要引入SWRevealViewController.h和SWRevealViewController.m文件。<br>这个用官方的即可，文件比较长，就不贴进来了。</p>\n<h3 id=\"3-3-故事版定义\"><a href=\"#3-3-故事版定义\" class=\"headerlink\" title=\"3.3 故事版定义\"></a>3.3 故事版定义</h3><img src=23_1.png>\n这里定义好了跳转逻辑，直接在故事版里面操作的。\n\n<p>其它2个item也是如此。</p>\n<p>主要是在Main.storyboard中定义了第一个控制为：SWRevealViewController<br>这个是oc写的。</p>\n<p>故事版里面定义了这个控制器会指向一个BackTableVC。</p>\n<h3 id=\"3-4-控制器配置\"><a href=\"#3-4-控制器配置\" class=\"headerlink\" title=\"3.4 控制器配置\"></a>3.4 控制器配置</h3><p>第一个菜单控制器为：</p>\n<pre><code class=\"line-numbers language-Swift\">class Channel : UIViewController &#123;\n    \n    override func viewDidLoad() &#123;\n        self.navigationController?.isNavigationBarHidden = true\n        self.view.addGestureRecognizer(self.revealViewController().panGestureRecognizer())\n    &#125;\n    \n&#125;\n</code></pre>\n<p>第二个菜单控制器为：</p>\n<pre><code class=\"line-numbers language-Swift\">class ReadLater : UIViewController &#123;\n    \n    override func viewDidLoad() &#123;\n        self.navigationController?.isNavigationBarHidden = true\n        self.view.addGestureRecognizer(self.revealViewController().panGestureRecognizer())\n    &#125;\n    \n&#125;\n</code></pre>\n<p>第三个菜单控制为：</p>\n<pre><code class=\"line-numbers language-Swift\">class FriendRead : UIViewController &#123;\n    \n    override func viewDidLoad() &#123;\n        self.navigationController?.isNavigationBarHidden = true\n        self.view.addGestureRecognizer(self.revealViewController().panGestureRecognizer())   \n    &#125;   \n&#125;\n</code></pre>\n<p>这里必须配置：</p>\n<pre><code> self.view.addGestureRecognizer(self.revealViewController().panGestureRecognizer())   \n</code></pre>\n<p>才能实现菜单左滑手势效果哦。</p>\n<h2 id=\"4-磁片效果\"><a href=\"#4-磁片效果\" class=\"headerlink\" title=\"4 磁片效果\"></a>4 磁片效果</h2><h3 id=\"4-1-效果\"><a href=\"#4-1-效果\" class=\"headerlink\" title=\"4.1 效果\"></a>4.1 效果</h3><img src=MosaicLayouts.gif>\n\n<h3 id=\"4-2-pod引入三方库\"><a href=\"#4-2-pod引入三方库\" class=\"headerlink\" title=\"4.2 pod引入三方库\"></a>4.2 pod引入三方库</h3><p>这里通过Pod引入依赖，如下图：<br><img src=24_1.png></p>\n<p>这里引入了FMMosaicLayout库+AFNetworking+ORStackView+SwiftyJSON<br>用了这四个库。</p>\n<h3 id=\"4-3-页面定义\"><a href=\"#4-3-页面定义\" class=\"headerlink\" title=\"4.3 页面定义\"></a>4.3 页面定义</h3><p>这里也是用了一个UICollectionView，单一个页面。<br>直接继承了这个：UICollectionViewController。</p>\n<pre><code class=\"line-numbers language-Swift\">override func numberOfSections(in collectionView: UICollectionView) -&gt; Int &#123;\n        return 10\n    &#125;\n    \noverride func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123;\n    let cell = collectionView.dequeueReusableCell(withReuseIdentifier: &quot;Cell&quot;, for: indexPath)\n    cell.alpha = 0\n    \n    let imageView = cell.contentView.viewWithTag(2) as! UIImageView\n    imageView.image = UIImage(named: imageArray[indexPath.row])\n    \n    let cellDelay = UInt64((arc4random() % 600 ) / 1000 )\n    let cellDelayTime = DispatchTime(uptimeNanoseconds: cellDelay * NSEC_PER_SEC)\n    DispatchQueue.main.asyncAfter(deadline: cellDelayTime) &#123;\n        UIView.animate(withDuration: 0.8, animations: &#123;\n            cell.alpha = 1.0\n        &#125;)\n    &#125;\n    \n    return cell\n&#125;\n\n\noverride func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123;\n    return imageArray.count\n&#125;\n</code></pre>\n<p>主要实现了这几个协议方法。<br>Cell用了系统的。</p>\n<p>内容直接用UIImageView表示。</p>\n<p>然后这里异步开启动画效果，alpha从0到1的变化效果。</p>\n<h3 id=\"4-4-初始化\"><a href=\"#4-4-初始化\" class=\"headerlink\" title=\"4.4 初始化\"></a>4.4 初始化</h3><pre><code class=\"line-numbers language-Swift\">var imageArray = [String]()\n\noverride func viewDidLoad() &#123;\n    super.viewDidLoad()\n    imageArray = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;, &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;, &quot;16&quot;, &quot;17&quot;, &quot;18&quot;, &quot;19&quot;, &quot;20&quot;, &quot;21&quot;]\n    let mosaicLayout = FMMosaicLayout()\n    self.collectionView?.collectionViewLayout = mosaicLayout\n    if #available(iOS 11.0, *) &#123;\n        self.collectionView?.contentInsetAdjustmentBehavior = .never\n    &#125;\n&#125;\n</code></pre>\n<p>这里初始化的时候，将collectionView的collectionViewLayout设置为三方库的View。</p>\n<p>如何设置为不同大小，这里就是三方库的作用了：</p>\n<pre><code class=\"line-numbers language-Swift\">extension ViewController : FMMosaicLayoutDelegate &#123;\n\n    func collectionView(_ collectionView: UICollectionView!, layout collectionViewLayout: FMMosaicLayout!, numberOfColumnsInSection section: Int) -&gt; Int &#123;\n        return 3\n    &#125;\n\n    func collectionView(_ collectionView: UICollectionView!, layout collectionViewLayout: FMMosaicLayout!, mosaicCellSizeForItemAt indexPath: IndexPath!) -&gt; FMMosaicCellSize &#123;\n        return indexPath.item % 7 == 0 ? .big : .small\n    &#125;\n\n    func collectionView(_ collectionView: UICollectionView!, layout collectionViewLayout: FMMosaicLayout!, interitemSpacingForSectionAt section: Int) -&gt; CGFloat &#123;\n        return 1.0\n    &#125;\n\n    func collectionView(_ collectionView: UICollectionView!, layout collectionViewLayout: FMMosaicLayout!, insetForSectionAt section: Int) -&gt; UIEdgeInsets &#123;\n        return UIEdgeInsets(top: 1.0, left: 1.0, bottom: 1.0, right: 1.0)\n    &#125;\n&#125;\n</code></pre>\n<p>这里如果是7的倍数就大图，否则小图。有3种类型。</p>\n<h2 id=\"5-基础动画\"><a href=\"#5-基础动画\" class=\"headerlink\" title=\"5 基础动画\"></a>5 基础动画</h2><h3 id=\"5-1-效果\"><a href=\"#5-1-效果\" class=\"headerlink\" title=\"5.1 效果\"></a>5.1 效果</h3><img src=BasicAnimation.gif>\n\n<h3 id=\"5-2-故事版\"><a href=\"#5-2-故事版\" class=\"headerlink\" title=\"5.2 故事版\"></a>5.2 故事版</h3><p>第一个启动页首先是Main.storyboard故事版，然后这个故事版有一个Storyboard Entry Point就是第一个场景了，这里第一个场景是空的NavigationController Scene。</p>\n<p>然后这里绑定了这个第一个场景跳转逻辑，底部这里有个：<br><img src=25_1.png></p>\n<p>那如何修改这个启动路径呢？<br><img src=25_2.png><br>这里最右侧属性里面，先清除掉之前的，然后拖动小圆点，指向目标场景即可哦。</p>\n<p>这里Navigation Controller场景指向了BasicAnimation场景，这里面是一个TableView。<br>这里配置的UITableView的代理和数据源都指向了Basic Animation。<br><img src=25_3.png><br>这里数据直接在故事版里面写好了。</p>\n<p>然后item的跳转也是直接在故事版里面拖动的：<br><img src=25_4.png></p>\n<p>这里其实对应的首页的Controller没有啥东西：</p>\n<pre><code class=\"line-numbers language-Swift\">class ViewController: UITableViewController &#123;\n\n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        self.tableView.tableFooterView = UIView(frame: .zero)\n    &#125;\n\n    override func didReceiveMemoryWarning() &#123;\n        super.didReceiveMemoryWarning()\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"5-3-Position动画\"><a href=\"#5-3-Position动画\" class=\"headerlink\" title=\"5.3 Position动画\"></a>5.3 Position动画</h3><p>这里定义了3个方块。</p>\n<pre><code class=\"line-numbers language-Swift\">class PositionViewController: UIViewController &#123;\n\n    @IBOutlet weak var yellowSquareView: UIView!\n    @IBOutlet weak var blueSquareView: UIView!\n    @IBOutlet weak var mouseView: UIView!    \n</code></pre>\n<p>已经出现动画时执行动画：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidAppear(_ animated: Bool) &#123;\n        super.viewDidAppear(animated)\n        \n    UIView.animate(withDuration: 0.8, delay: 0.2, usingSpringWithDamping: 0.6, initialSpringVelocity: 0.8, options: .curveEaseInOut, animations: &#123;\n        self.yellowSquareView.center.x = self.view.bounds.width - self.yellowSquareView.center.x\n        self.yellowSquareView.center.y = self.yellowSquareView.center.y + 30\n        self.blueSquareView.center.x = self.view.bounds.width -  self.blueSquareView.center.x\n        self.blueSquareView.center.y = self.blueSquareView.center.y + 30\n\n        &#125;, completion: nil )\n    \n    UIView.animate(withDuration: 0.6, delay: 0.4, usingSpringWithDamping: 0.6, initialSpringVelocity: 0.8, options: .curveEaseOut, animations: &#123;\n        self.setHeight(180)\n        self.mouseView.center.y = self.view.bounds.height - self.mouseView.center.y\n        &#125;, completion: nil )\n&#125;\n\nfunc setHeight(_ height: CGFloat) &#123;\n    \n    var frame: CGRect = self.mouseView.frame\n    frame.size.height = height\n    \n    self.mouseView.frame = frame\n&#125;\n</code></pre>\n<h3 id=\"5-4-Opacity动画\"><a href=\"#5-4-Opacity动画\" class=\"headerlink\" title=\"5.4 Opacity动画\"></a>5.4 Opacity动画</h3><pre><code class=\"line-numbers language-Swift\">class OpacityViewController: UIViewController &#123;\n\n    @IBOutlet weak var exampleImageView: UIImageView!\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n\n    &#125;\n\n    override func didReceiveMemoryWarning() &#123;\n        super.didReceiveMemoryWarning()\n    &#125;\n    \n    override func viewDidAppear(_ animated: Bool) &#123;\n        super.viewDidAppear(animated)\n        \n        UIView.animate(withDuration: 2) &#123;\n            self.exampleImageView.alpha = 0\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里控制图片alpha从1到0的动画。</p>\n<h3 id=\"5-5-Scale动画\"><a href=\"#5-5-Scale动画\" class=\"headerlink\" title=\"5.5 Scale动画\"></a>5.5 Scale动画</h3><pre><code class=\"line-numbers language-Swift\">class ScaleViewController: UIViewController &#123;\n\n    @IBOutlet weak var scaleImageView: UIImageView!\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        self.scaleImageView.alpha = 0\n    &#125;\n\n    override func didReceiveMemoryWarning() &#123;\n        super.didReceiveMemoryWarning()\n    &#125;\n    \n    override func viewDidAppear(_ animated: Bool) &#123;\n        super.viewDidAppear(animated)\n        \n        \n        UIView.animate(withDuration: 0.8, delay: 0, usingSpringWithDamping: 0.7, initialSpringVelocity: 1, options: .curveEaseIn, animations: &#123;\n            self.scaleImageView.transform = CGAffineTransform(scaleX: 2, y: 2)\n            self.scaleImageView.alpha = 1\n            \n            &#125;, completion: nil )\n    &#125;\n&#125;\n</code></pre>\n<p>这里alpha从0到1,缩放动画从1到2。</p>\n<h3 id=\"5-6-Color动画\"><a href=\"#5-6-Color动画\" class=\"headerlink\" title=\"5.6 Color动画\"></a>5.6 Color动画</h3><pre><code class=\"line-numbers language-Swift\">class ColorViewController: UIViewController &#123;\n\n    @IBOutlet weak var bgColorView: UIView!\n    @IBOutlet weak var numberLabel: UILabel!\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n\n    &#125;\n\n    override func didReceiveMemoryWarning() &#123;\n        super.didReceiveMemoryWarning()\n    &#125;\n    \n    override func viewDidAppear(_ animated: Bool) &#123;\n        super.viewDidAppear(animated)\n        \n        \n        UIView.animate(withDuration: 0.5, delay: 0.2, options: .curveEaseIn, animations: &#123;\n            self.bgColorView.backgroundColor = .black\n            \n            &#125;, completion: nil )\n        \n        UIView.animate(withDuration: 0.5, delay: 0.8, options: .curveEaseOut, animations: &#123;\n            self.numberLabel.textColor = UIColor(red:0.959, green:0.937, blue:0.109, alpha:1)\n            \n            &#125;, completion: nil)\n    &#125;\n&#125;\n</code></pre>\n<p>这里设置颜色从黄到黑，文字颜色也变化了。</p>\n<h3 id=\"5-7-Rotation动画\"><a href=\"#5-7-Rotation动画\" class=\"headerlink\" title=\"5.7 Rotation动画\"></a>5.7 Rotation动画</h3><pre><code class=\"line-numbers language-Swift\">class RotationViewController: UIViewController &#123;\n\n    @IBOutlet weak var emojiLabel: UILabel!\n    @IBOutlet weak var rotationImageView: UIImageView!\n    @IBOutlet weak var trump2: UIImageView!\n    @IBOutlet weak var trump3: UIImageView!\n    @IBOutlet weak var trump4: UIImageView!\n    @IBOutlet weak var trump5: UIImageView!\n    @IBOutlet weak var trump6: UIImageView!\n    @IBOutlet weak var trump7: UIImageView!\n    @IBOutlet weak var trump8: UIImageView!\n    \n    func spin() &#123;\n        UIView.animate(withDuration: 0.8, delay: 0, options: .curveLinear, animations: &#123;\n            self.rotationImageView.transform = self.rotationImageView.transform.rotated(by: CGFloat(Double.pi))\n            self.trump2.transform = self.trump2.transform.rotated(by: CGFloat(Double.pi))\n            self.trump3.transform = self.trump3.transform.rotated(by: CGFloat(Double.pi))\n            self.trump4.transform = self.trump4.transform.rotated(by: CGFloat(Double.pi))\n            self.trump5.transform = self.trump5.transform.rotated(by: CGFloat(Double.pi))\n            self.trump6.transform = self.trump6.transform.rotated(by: CGFloat(Double.pi))\n            self.trump7.transform = self.trump7.transform.rotated(by: CGFloat(Double.pi))\n            self.trump8.transform = self.trump8.transform.rotated(by: CGFloat(Double.pi))\n            self.emojiLabel.transform = self.emojiLabel.transform.rotated(by: CGFloat(Double.pi))\n            &#125;) &#123; (finished) -&gt; Void in\n                self.spin()\n        &#125;\n    &#125;\n    \n    override func viewDidAppear(_ animated: Bool) &#123;\n        super.viewDidAppear(animated)\n        self.spin()\n    &#125;\n&#125;\n</code></pre>\n<p>这里让8个视图都开始旋转了。</p>\n<h2 id=\"6-CoreData使用\"><a href=\"#6-CoreData使用\" class=\"headerlink\" title=\"6 CoreData使用\"></a>6 CoreData使用</h2><h3 id=\"6-1-效果\"><a href=\"#6-1-效果\" class=\"headerlink\" title=\"6.1 效果\"></a>6.1 效果</h3><img src=CoreData.gif>\n\n<h3 id=\"6-2-AddDelegate配置\"><a href=\"#6-2-AddDelegate配置\" class=\"headerlink\" title=\"6.2 AddDelegate配置\"></a>6.2 AddDelegate配置</h3><pre><code class=\"line-numbers language-Swift\">lazy var applicationDocumentsDirectory: NSURL = &#123;\n        // The directory the application uses to store the Core Data store file. This code uses a directory named &quot;me.appkitchen.cd&quot; in the application&#39;s documents Application Support directory.\n        let urls = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)\n        return urls[urls.count-1] as NSURL\n    &#125;()\n\nlazy var managedObjectModel: NSManagedObjectModel = &#123;\n    // The managed object model for the application. This property is not optional. It is a fatal error for the application not to be able to find and load its model.\n    let modelURL = Bundle.main.url(forResource: &quot;cd&quot;, withExtension: &quot;momd&quot;)!\n    return NSManagedObjectModel(contentsOf: modelURL)!\n&#125;()\n\nlazy var persistentStoreCoordinator: NSPersistentStoreCoordinator = &#123;\n    // The persistent store coordinator for the application. This implementation creates and returns a coordinator, having added the store for the application to it. This property is optional since there are legitimate error conditions that could cause the creation of the store to fail.\n    // Create the coordinator and store\n    let coordinator = NSPersistentStoreCoordinator(managedObjectModel: self.managedObjectModel)\n    let url = self.applicationDocumentsDirectory.appendingPathComponent(&quot;SingleViewCoreData.sqlite&quot;)\n    var failureReason = &quot;There was an error creating or loading the application&#39;s saved data.&quot;\n    do &#123;\n        try coordinator.addPersistentStore(ofType: NSSQLiteStoreType, configurationName: nil, at: url, options: nil)\n    &#125; catch &#123;\n        // Report any error we got.\n        var dict = [String: AnyObject]()\n        dict[NSLocalizedDescriptionKey] = &quot;Failed to initialize the application&#39;s saved data&quot; as AnyObject\n        dict[NSLocalizedFailureReasonErrorKey] = failureReason as AnyObject\n\n        dict[NSUnderlyingErrorKey] = error as NSError\n        let wrappedError = NSError(domain: &quot;YOUR_ERROR_DOMAIN&quot;, code: 9999, userInfo: dict)\n        // Replace this with code to handle the error appropriately.\n        // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.\n        NSLog(&quot;Unresolved error \\(wrappedError), \\(wrappedError.userInfo)&quot;)\n        abort()\n    &#125;\n\n    return coordinator\n&#125;()\n\nlazy var managedObjectContext: NSManagedObjectContext = &#123;\n    // Returns the managed object context for the application (which is already bound to the persistent store coordinator for the application.) This property is optional since there are legitimate error conditions that could cause the creation of the context to fail.\n    let coordinator = self.persistentStoreCoordinator\n    var managedObjectContext = NSManagedObjectContext(concurrencyType: .mainQueueConcurrencyType)\n    managedObjectContext.persistentStoreCoordinator = coordinator\n    return managedObjectContext\n&#125;()\n\n// MARK: - Core Data Saving support\n\nfunc saveContext () &#123;\n    if managedObjectContext.hasChanges &#123;\n        do &#123;\n            try managedObjectContext.save()\n        &#125; catch &#123;\n            // Replace this implementation with code to handle the error appropriately.\n            // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.\n            let nserror = error as NSError\n            NSLog(&quot;Unresolved error \\(nserror), \\(nserror.userInfo)&quot;)\n            abort()\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>因为代码比较久了，这个按照XCode指示修复后就是这个效果。<br>这里可以运行了。</p>\n<p>主要是applicationWillTerminate方法中saveContext了。</p>\n<h3 id=\"6-3-可见数据操作\"><a href=\"#6-3-可见数据操作\" class=\"headerlink\" title=\"6.3 可见数据操作\"></a>6.3 可见数据操作</h3><p>这里代码使用还有点问题，暂时无法贴最新代码。<br>关于CoreData的使用还是建议参考这篇文章：<br><a href=\"https://blog.ficowshen.com/page/post/52\">了解和采用 CoreData 框架 —— Ficow 陪你学 CoreData</a>。</p>\n<h2 id=\"7-底部Bar动画\"><a href=\"#7-底部Bar动画\" class=\"headerlink\" title=\"7 底部Bar动画\"></a>7 底部Bar动画</h2><h3 id=\"7-1-效果\"><a href=\"#7-1-效果\" class=\"headerlink\" title=\"7.1 效果\"></a>7.1 效果</h3><img src=TapBarAnimation.gif>\n\n<h3 id=\"7-2-故事版添加导航item\"><a href=\"#7-2-故事版添加导航item\" class=\"headerlink\" title=\"7.2 故事版添加导航item\"></a>7.2 故事版添加导航item</h3><img src=27_1.png>\n\n<p>这里应该是关联到了这3个item。<br>这样子，就可以展示底部导航栏效果。<br>然后item也定义了跳转的目标场景。</p>\n<h3 id=\"7-3-第一个Tab页\"><a href=\"#7-3-第一个Tab页\" class=\"headerlink\" title=\"7.3 第一个Tab页\"></a>7.3 第一个Tab页</h3><pre><code class=\"line-numbers language-Swift\">class FirstTabViewController: UIViewController, UITableViewDataSource, UITableViewDelegate &#123;\n\n    @IBOutlet weak var articleTableView: UITableView!\n    \n    var data = [\n    \n        article(avatarImage: &quot;allen&quot;, sharedName: &quot;Allen Wang&quot;, actionType: &quot;Read Later&quot;, articleTitle: &quot;Giphy Cam Lets You Create And Share Homemade Gifs&quot;, articleCoverImage: &quot;giphy&quot;, articleSouce: &quot;TheNextWeb&quot;, articleTime: &quot;5min  •  13:20&quot;),\n        article(avatarImage: &quot;Daniel Hooper&quot;, sharedName: &quot;Daniel Hooper&quot;, actionType: &quot;Shared on Twitter&quot;, articleTitle: &quot;Principle. The Sketch of Prototyping Tools&quot;, articleCoverImage: &quot;my workflow flow&quot;, articleSouce: &quot;SketchTalk&quot;, articleTime: &quot;3min  •  12:57&quot;),\n        article(avatarImage: &quot;davidbeckham&quot;, sharedName: &quot;David Beckham&quot;, actionType: &quot;Shared on Facebook&quot;, articleTitle: &quot;Ohlala, An Uber For Escorts, Launches Its ‘Paid Dating’ Service In NYC&quot;, articleCoverImage: &quot;Ohlala&quot;, articleSouce: &quot;TechCrunch&quot;, articleTime: &quot;1min  •  12:59&quot;),\n        article(avatarImage: &quot;bruce&quot;, sharedName: &quot;Bruce Fan&quot;, actionType: &quot;Shared on Weibo&quot;, articleTitle: &quot;Lonely Planet’s new mobile app helps you explore major cities like a pro&quot;, articleCoverImage: &quot;Lonely Planet&quot;, articleSouce: &quot;36Kr&quot;, articleTime: &quot;5min  •  11:21&quot;),\n\n    ]\n</code></pre>\n<p>上面是数据定义。</p>\n<p>然后设置代理和数据源：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n    super.viewDidLoad()\n    \n    articleTableView.dataSource = self\n    articleTableView.delegate = self\n    articleTableView.separatorStyle = UITableViewCell.SeparatorStyle.none\n    articleTableView.tableFooterView = UIView(frame: .zero)\n&#125;\n\n \nfunc numberOfSectionsInTableView(tableView: UITableView) -&gt; Int &#123;\n    return 10\n&#125;\n\nfunc tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n    return data.count\n&#125;\n\nfunc tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n    return 165\n&#125;\n\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n    let cell = articleTableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) as! ArticleTableViewCell\n    let article = data[indexPath.row]\n    \n    cell.avatarImage.image = UIImage(named: article.avatarImage)\n    cell.articleCoverImage.image = UIImage(named: article.articleCoverImage)\n    cell.sharedNameLabel.text = article.sharedName\n    cell.actionTypeLabel.text = article.actionType\n    cell.articleTitleLabel.text = article.articleTitle\n    cell.articleSouceLabel.text = article.articleSouce\n    cell.articelCreatedAtLabel.text = article.articleTime\n    cell.selectionStyle = UITableViewCell.SelectionStyle.none\n    \n    return cell   \n&#125;\n</code></pre>\n<p>这里配置了Cell:</p>\n<pre><code class=\"line-numbers language-Swift\">struct article &#123;\n    let avatarImage: String\n    let sharedName: String\n    let actionType: String\n    let articleTitle: String\n    let articleCoverImage: String\n    let articleSouce: String\n    let articleTime: String\n&#125;\n\nclass ArticleTableViewCell: UITableViewCell &#123;\n\n    @IBOutlet weak var avatarImage: UIImageView!\n    @IBOutlet weak var sharedNameLabel: UILabel!\n    @IBOutlet weak var actionTypeLabel: UILabel!\n    @IBOutlet weak var articleCoverImage: UIImageView!\n    \n    @IBOutlet weak var articleTitleLabel: UILabel!\n    @IBOutlet weak var articleSouceLabel: UILabel!\n    @IBOutlet weak var articelCreatedAtLabel: UILabel!\n    \n    override func awakeFromNib() &#123;\n        super.awakeFromNib()\n        // Initialization code\n\n    &#125;\n\n    override func setSelected(_ selected: Bool, animated: Bool) &#123;\n        super.setSelected(selected, animated: animated)\n\n        // Configure the view for the selected state\n    &#125;\n&#125;\n</code></pre>\n<p>这里应该就是item配置了，具体布局是用故事版里面的配置的。</p>\n<p>可见的时候，执行动画效果：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewWillAppear(_ animated: Bool) &#123;   \n    animateTable()\n&#125;\n\nfunc animateTable() &#123;\n    \n    self.articleTableView.reloadData()\n    \n    let cells = articleTableView.visibleCells\n    let tableHeight: CGFloat = articleTableView.bounds.size.height\n    \n    for i in cells &#123;\n        let cell: UITableViewCell = i as UITableViewCell\n        cell.transform = CGAffineTransform(translationX: 0, y: tableHeight)\n    &#125;\n    \n    var index = 0\n    \n    for a in cells &#123;\n        let cell: UITableViewCell = a as UITableViewCell\n        UIView.animate(withDuration: 1.0, delay: 0.05 * Double(index), usingSpringWithDamping: 0.8, initialSpringVelocity: 0, options: [], animations: &#123;\n            cell.transform = CGAffineTransform(translationX: 0, y: 0);\n            &#125;, completion: nil)\n        \n        index += 1\n    &#125;\n&#125;\n</code></pre>\n<p>从下往上的动画效果。</p>\n<h3 id=\"7-4-第二个Tab的动画\"><a href=\"#7-4-第二个Tab的动画\" class=\"headerlink\" title=\"7.4 第二个Tab的动画\"></a>7.4 第二个Tab的动画</h3><pre><code class=\"line-numbers language-Swift\">override func viewDidAppear(_ animated: Bool) &#123;\n    super.viewDidAppear(animated)\n    \n    UIView.animate(withDuration: 0.5, delay: 0.1, usingSpringWithDamping: 0.7, initialSpringVelocity: 1, options: .curveEaseIn, animations: &#123;\n        self.exploreImageView.transform = CGAffineTransform(scaleX: 1, y: 1)\n        self.exploreImageView.alpha = 1\n        \n        &#125;, completion: nil )\n&#125;\n\noverride func viewDidDisappear(_ animated: Bool) &#123;\n    super.viewDidDisappear(animated)\n    resetViewTransform()\n&#125;\n\n// MARK:\nfunc resetViewTransform() &#123;\n    self.exploreImageView.alpha = 0\n    self.exploreImageView.transform = CGAffineTransform(scaleX: 0.5, y: 0.5)\n&#125;\n</code></pre>\n<h3 id=\"7-5-第三个Tab的动画\"><a href=\"#7-5-第三个Tab的动画\" class=\"headerlink\" title=\"7.5 第三个Tab的动画\"></a>7.5 第三个Tab的动画</h3><pre><code class=\"line-numbers language-Swift\">override func viewDidAppear(_ animated: Bool) &#123;\n        super.viewDidAppear(animated)\n    \n    UIView.animate(withDuration: 0.5, delay: 0.1, usingSpringWithDamping: 0.7, initialSpringVelocity: 1, options: .curveEaseIn, animations: &#123;\n        self.profileImageView.transform = CGAffineTransform(scaleX: 1, y: 1)\n        self.profileImageView.alpha = 1\n        \n        &#125;, completion: nil )\n&#125;\n\noverride func viewDidDisappear(_ animated: Bool) &#123;\n    super.viewDidDisappear(animated)\n    resetViewTransform()\n&#125;\n\n// MARK:\nfunc resetViewTransform() &#123;\n    self.profileImageView.alpha = 0\n    self.profileImageView.transform = CGAffineTransform(scaleX: 0.5, y: 0.5)\n&#125;\n</code></pre>\n<h2 id=\"8-系统搜索\"><a href=\"#8-系统搜索\" class=\"headerlink\" title=\"8 系统搜索\"></a>8 系统搜索</h2><h3 id=\"8-1-效果\"><a href=\"#8-1-效果\" class=\"headerlink\" title=\"8.1 效果\"></a>8.1 效果</h3><img src=Spotlight%20Search.gif>\n\n<h3 id=\"8-2-首页\"><a href=\"#8-2-首页\" class=\"headerlink\" title=\"8.2 首页\"></a>8.2 首页</h3><p>数据设置：<br><img src=28_1.png><br>这里新建了一个电影数据，用key-value形式保存了。</p>\n<p>可见时处理：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n    super.viewDidLoad()\n    loadMoviesInfo()\n    configureTableView()\n    navigationItem.title = &quot;Movies&quot;\n    setupSearchableContent()\n&#125;\n\n// 加载根目录文件数据，拿到数组\nfunc loadMoviesInfo() &#123;\n    if let path = Bundle.main.path(forResource: &quot;MoviesData&quot;, ofType: &quot;plist&quot;) &#123;\n        moviesInfo = NSMutableArray(contentsOfFile: path)\n    &#125;\n&#125;\n\n// 配置代理和数据源\nfunc configureTableView() &#123;\n    tblMovies.delegate = self\n    tblMovies.dataSource = self\n    tblMovies.tableFooterView = UIView(frame: CGRect.zero)\n    tblMovies.register(UINib(nibName: &quot;MovieSummaryCell&quot;, bundle: nil), forCellReuseIdentifier: &quot;idCellMovieSummary&quot;)\n&#125;\n\n// 搜索数据装载，使用了系统的类  CSSearchableItem\nfunc setupSearchableContent() &#123;\n    var searchableItems = [CSSearchableItem]()\n    \n    for i in 0...(moviesInfo.count - 1) &#123;\n        \n        let movie = moviesInfo[i] as! [String: String]\n        let searchableItemAttributeSet = CSSearchableItemAttributeSet(itemContentType: kUTTypeText as String)\n        \n        //set the title\n        searchableItemAttributeSet.title = movie[&quot;Title&quot;]!\n        \n        //set the image\n        let imagePathParts = movie[&quot;Image&quot;]!.components(separatedBy: &quot;.&quot;)\n        searchableItemAttributeSet.thumbnailURL = Bundle.main.url(forResource: imagePathParts[0], withExtension: imagePathParts[1])\n        \n        // Set the description.\n        searchableItemAttributeSet.contentDescription = movie[&quot;Description&quot;]!\n        \n        var keywords = [String]()\n        let movieCategories = movie[&quot;Category&quot;]!.components(separatedBy: &quot;, &quot;)\n        for movieCategory in movieCategories &#123;\n            keywords.append(movieCategory)\n        &#125;\n        \n        let stars = movie[&quot;Stars&quot;]!.components(separatedBy: &quot;, &quot;)\n        for star in stars &#123;\n            keywords.append(star)\n        &#125;\n        \n        searchableItemAttributeSet.keywords = keywords\n        \n        let searchableItem = CSSearchableItem(uniqueIdentifier: &quot;com.appcoda.SpotIt.\\(i)&quot;, domainIdentifier: &quot;movies&quot;, attributeSet: searchableItemAttributeSet)\n        \n        searchableItems.append(searchableItem)\n        \n        CSSearchableIndex.default().indexSearchableItems(searchableItems) &#123;\n            if $0 != nil &#123;\n                print($0!.localizedDescription)\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>监听系统搜索后跳转逻辑：</p>\n<pre><code class=\"line-numbers language-Swift\">override func restoreUserActivityState(_ activity: NSUserActivity) &#123;\n    if activity.activityType == CSSearchableItemActionType &#123;\n        if let userInfo = activity.userInfo &#123;\n            let selectedMovie = userInfo[CSSearchableItemActivityIdentifier] as! String\n            selectedMovieIndex = Int(selectedMovie.components(separatedBy: &quot;.&quot;).last!)\n            performSegue(withIdentifier: &quot;idSegueShowMovieDetails&quot;, sender: self)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>然后是代理和数据源配置：</p>\n<pre><code class=\"line-numbers language-Swift\"> func numberOfSections(in tableView: UITableView) -&gt; Int &#123;\n        return 1\n    &#125;\n    \nfunc tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n    if moviesInfo != nil &#123;\n        return moviesInfo.count\n    &#125;\n    return 0\n&#125;\n\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n    let cell = tableView.dequeueReusableCell(withIdentifier: &quot;idCellMovieSummary&quot;, for: indexPath) as! MovieSummaryCell\n    let currentMovieInfo = moviesInfo[(indexPath as NSIndexPath).row] as! [String: String]\n    \n    cell.lblTitle.text = currentMovieInfo[&quot;Title&quot;]!\n    cell.lblDescription.text = currentMovieInfo[&quot;Description&quot;]!\n    cell.lblRating.text = currentMovieInfo[&quot;Rating&quot;]!\n    cell.imgMovieImage.image = UIImage(named: currentMovieInfo[&quot;Image&quot;]!)\n    \n    return cell\n&#125;\n\nfunc tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n    return 100.0\n&#125;\n\nfunc tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123;\n    selectedMovieIndex = (indexPath as NSIndexPath).row\n    performSegue(withIdentifier: &quot;idSegueShowMovieDetails&quot;, sender: self)\n&#125;\n\noverride func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123;\n    if let identifier = segue.identifier, identifier == &quot;idSegueShowMovieDetails&quot; &#123;\n        let movieDetailsViewController = segue.destination as! MovieDetailsViewController\n        movieDetailsViewController.movieInfo = moviesInfo[selectedMovieIndex] as? [String: String]\n    &#125;\n&#125;\n</code></pre>\n<p>这里didSelectRowAt，通过调用系统的performSegue决定跳转到某个场景。</p>\n<h3 id=\"8-3-详情页\"><a href=\"#8-3-详情页\" class=\"headerlink\" title=\"8.3 详情页\"></a>8.3 详情页</h3><pre><code class=\"line-numbers language-Swift\">class MovieDetailsViewController: UIViewController &#123;\n\n    @IBOutlet weak var imgMovieImage: UIImageView!\n    @IBOutlet weak var lblTitle: UILabel!\n    @IBOutlet weak var lblCategory: UILabel!\n    @IBOutlet weak var lblDescription: UILabel!\n    @IBOutlet weak var lblDirector: UILabel!\n    @IBOutlet weak var lblStars: UILabel!\n    @IBOutlet weak var lblRating: UILabel!\n    \n    var movieInfo: [String: String]!\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n    &#125;\n    \n    override func viewWillAppear(_ animated: Bool) &#123;\n        super.viewWillAppear(animated)\n        \n        lblRating.layer.cornerRadius = lblRating.frame.size.width/2\n        lblRating.layer.masksToBounds = true\n        \n        if movieInfo != nil &#123;\n            populateMovieInfo()\n        &#125;\n    &#125;\n    \n    \n    override func didReceiveMemoryWarning() &#123;\n        super.didReceiveMemoryWarning()\n    &#125;\n    \n    func populateMovieInfo() &#123;\n        \n        lblTitle.text = movieInfo[&quot;Title&quot;]!\n        lblCategory.text = movieInfo[&quot;Category&quot;]!\n        lblDescription.text = movieInfo[&quot;Description&quot;]!\n        lblDirector.text = movieInfo[&quot;Director&quot;]!\n        lblStars.text = movieInfo[&quot;Stars&quot;]!\n        lblRating.text = movieInfo[&quot;Rating&quot;]!\n        imgMovieImage.image = UIImage(named: movieInfo[&quot;Image&quot;]!)\n        \n    &#125;\n&#125;\n</code></pre>\n<p>这里配置了movieInfo，外部设置进来，然后回显进去。</p>\n<h2 id=\"9-选择头像\"><a href=\"#9-选择头像\" class=\"headerlink\" title=\"9 选择头像\"></a>9 选择头像</h2><h3 id=\"9-1-效果\"><a href=\"#9-1-效果\" class=\"headerlink\" title=\"9.1 效果\"></a>9.1 效果</h3><img src=AvatarPicker.gif>\n\n<h3 id=\"9-2-点击头像\"><a href=\"#9-2-点击头像\" class=\"headerlink\" title=\"9.2 点击头像\"></a>9.2 点击头像</h3><pre><code class=\"line-numbers language-Swift\">@IBAction func pickProfileImage(_ tap: UITapGestureRecognizer) &#123;\n    let authorization = PHPhotoLibrary.authorizationStatus()\n    \n    if authorization == .notDetermined &#123;\n        PHPhotoLibrary.requestAuthorization &#123; _ in\n            DispatchQueue.main.async &#123;\n                self.pickProfileImage(tap)\n            &#125;\n        &#125;\n    &#125;\n    \n    if authorization == .authorized &#123;\n        let controller = ImagePickerSheetController()\n        controller.addAction(action: ImageAction(title: NSLocalizedString(&quot;Take Photo or Video&quot;, comment: &quot;Action Title&quot;), secondaryTitle: NSLocalizedString(&quot;Use this one&quot;, comment: &quot;Action Title&quot;), handler: &#123; _ in\n            self.presentCamera()\n        &#125;, secondaryHandler: &#123; (action, numberOfPhotos) in\n            controller.getSelectedImagesWithCompletion(completion: &#123; images in\n                self.profileImage = images[0]\n                self.userProfileImageView.image = self.profileImage\n            &#125;)\n        &#125;))\n                    \n        controller.addAction(action: ImageAction(title: NSLocalizedString(&quot;Cancel&quot;, comment: &quot;Action Title&quot;), style: .Cancel, handler: nil, secondaryHandler: nil))\n        \n        self.present(controller, animated: true, completion: nil)\n    &#125;\n    \n    \n&#125;\n\nfunc presentCamera()\n&#123;\n    print(&quot;拍照&quot;)\n&#125;\n</code></pre>\n<p>这里先判断有无权限，没有权限继续执行，有权限再跳转控制器。</p>\n<h2 id=\"10-wiki-Face\"><a href=\"#10-wiki-Face\" class=\"headerlink\" title=\"10 wiki-Face\"></a>10 wiki-Face</h2><h3 id=\"10-1-效果\"><a href=\"#10-1-效果\" class=\"headerlink\" title=\"10.1 效果\"></a>10.1 效果</h3><img src=wikiFace.gif>\n\n<h3 id=\"10-2-搜索处理\"><a href=\"#10-2-搜索处理\" class=\"headerlink\" title=\"10.2 搜索处理\"></a>10.2 搜索处理</h3><pre><code class=\"line-numbers language-Swift\">func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool &#123;\n        \n    textField.resignFirstResponder()\n    \n    if let textFieldContent = textField.text &#123;\n        do &#123;\n            try WikiFace.faceForPerson(textFieldContent, size: CGSize(width: 300, height: 400), completion: &#123; (image:UIImage?, imageFound:Bool) -&gt; () in\n                if imageFound == true &#123;\n                    DispatchQueue.main.async &#123;\n                        self.faceImageView.image = image\n                        \n                        UIView.animate(withDuration: 0.8, delay: 0, usingSpringWithDamping: 0.7, initialSpringVelocity: 1, options: .curveEaseIn, animations: &#123; () -&gt; Void in\n                            \n                            self.faceImageView.transform = CGAffineTransform(scaleX: 1, y: 1)\n                            self.faceImageView.alpha = 1\n                            \n                            //Fuck! Useless...LOL\n                            self.faceImageView.layer.shadowOpacity = 0.4\n                            self.faceImageView.layer.shadowOffset = CGSize(width: 3.0, height: 2.0)\n                            self.faceImageView.layer.shadowRadius = 15.0\n                            self.faceImageView.layer.shadowColor = UIColor.black.cgColor\n                            \n                        &#125;, completion: nil )\n                        \n                        WikiFace.centerImageViewOnFace(self.faceImageView)\n                    &#125;\n                &#125;\n\n            &#125;)\n        &#125;catch WikiFace.WikiFaceError.CouldNotDownloadImage&#123;\n            print(&quot;Could not access wikipedia for downloading an image&quot;)\n        &#125; catch &#123;\n            print(error)\n        &#125;\n    &#125;\n    \n    return true\n    \n&#125;\n</code></pre>\n<p>使用工具类：</p>\n<pre><code class=\"line-numbers language-Swift\">import UIKit\nimport ImageIO\n\nclass WikiFace: NSObject &#123;\n    \n    enum WikiFaceError: Error &#123;\n        case CouldNotDownloadImage\n    &#125;\n    \n    class func faceForPerson(_ person: String, size: CGSize, completion:@escaping (_ image: UIImage? ,_ imageFound: Bool) -&gt; ()) throws &#123;\n        \n        let escapedString = person.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlHostAllowed)\n        let pixelsForAPIRequest = Int(max(size.width, size.height)) * 2\n        \n        let url = URL(string: &quot;https://en.wikipedia.org/w/api.php?action=query&amp;titles=\\(escapedString!)&amp;prop=pageimages&amp;format=json&amp;pithumbsize=\\(pixelsForAPIRequest)&quot;)\n        \n        let task: URLSessionTask = URLSession.shared.dataTask(with: url!, completionHandler: &#123;\n            (data: Data?, response: URLResponse?, error: Error?) in\n            if error == nil &#123;\n                let wikiDict = try! JSONSerialization.jsonObject(with: data!, options: JSONSerialization.ReadingOptions.allowFragments) as! NSDictionary\n        \n                if let query = wikiDict.object(forKey: &quot;query&quot;) as? NSDictionary &#123;\n                    if let pages = query.object(forKey: &quot;pages&quot;) as? NSDictionary &#123;\n                        if let pageContent = pages.allValues.first as? NSDictionary &#123;\n                            if let thumbnail = pageContent.object(forKey: &quot;thumbnail&quot;) as? NSDictionary &#123;\n                                if let thumbURL = thumbnail.object(forKey: &quot;source&quot;) as? String &#123;\n                                    let faceImage = UIImage(data: try! Data(contentsOf: URL(string: thumbURL)!))\n                                    completion(faceImage, true)\n                                &#125;\n                            &#125;else&#123;\n                                completion(nil, false)\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;)\n        task.resume()\n    &#125;\n    \n    class func centerImageViewOnFace (_ imageView: UIImageView) &#123;\n        \n        let context = CIContext(options: nil)\n        let options = [CIDetectorAccuracy:CIDetectorAccuracyHigh]\n        let detector = CIDetector(ofType: CIDetectorTypeFace, context: context, options: options)\n        \n        let faceImage = imageView.image\n        let ciImage = CIImage(cgImage: faceImage!.cgImage!)\n        \n        let features = detector?.features(in: ciImage)\n        \n        if (features?.count)! &gt; 0 &#123;\n            \n            var face:CIFaceFeature!\n            \n            for rect in features! &#123;\n                face = rect as? CIFaceFeature\n            &#125;\n            \n            var faceRectWithExtendedBounds = face.bounds\n            faceRectWithExtendedBounds.origin.x -= 20\n            faceRectWithExtendedBounds.origin.y -= 30\n            \n            faceRectWithExtendedBounds.size.width += 40\n            faceRectWithExtendedBounds.size.height += 60\n            \n            let x = faceRectWithExtendedBounds.origin.x / faceImage!.size.width\n            let y = (faceImage!.size.height - faceRectWithExtendedBounds.origin.y - faceRectWithExtendedBounds.size.height) / faceImage!.size.height\n            \n            let widthFace = faceRectWithExtendedBounds.size.width / faceImage!.size.width\n            let heightFace = faceRectWithExtendedBounds.size.height  / faceImage!.size.height\n            \n            imageView.layer.contentsRect = CGRect(x: x, y: y, width: widthFace, height: heightFace)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里应该是走异步接口，然后将网络图片设置给UIImageVIew了。</p>\n<h2 id=\"11-总结\"><a href=\"#11-总结\" class=\"headerlink\" title=\"11 总结\"></a>11 总结</h2><ul>\n<li><p>滑动删除效果其实是UITableView里面自带的一个方法editActionsForRowAt方法，里面配置的UITableViewRowAction实现的。</p>\n</li>\n<li><p>3D触摸效果，首先需要在info.plist中配置菜单，然后在AppDelegate中定义菜单的跳转逻辑，可以present方式跳转到目标页面。</p>\n</li>\n<li><p>侧滑菜单，这个需要引入一下SWRevealViewController，这个是oc写的，这里面配置一下菜单控制器，这样就可以实现侧滑效果，主要工作量在SWRevealViewController里面。</p>\n</li>\n<li><p>磁片效果，这个主要是引入了一个三方库，FMMosaicLayout库，需要实现一下FMMosaicLayoutDelegate这个方法，这样就可以实现不同item的大小。</p>\n</li>\n<li><p>基础动画，这里定义了各种各样的基础动画使用方法，Position动画就是height高度区别，Opacity效果是配置alpah，Scale效果是CGAffineTransform这个配置，Color动画就改变一下颜色值，Rotation动画就是设置transform的rotated方法。</p>\n</li>\n<li><p>CoreData的使用主要是现在appDelegate中设置saveContext，其它操作类似操作数据库。</p>\n</li>\n<li><p>底部Bar动画，主要是在可见的时候，对每个UITableViewCell里面做了一个动画效果，里面通过设置CGAffineTransform这个实现。</p>\n</li>\n<li><p>系统搜索，这个首先需要配置一个数据源，可以再plist文件里面写一个数组，然后通过系统的搜索类来实现，CSSearchableIndex这个来注入数据。然后配置restoreUserActivityState这个方法，可以决定item跳转目标类。</p>\n</li>\n<li><p>选择头像，这里主要是用了一个工具类，然后通过PHPotoLibrary获取权限，有权限就跳转，没有权限申请，有权限跳转到自定义的ImagePickerSheetController，然后会present这个类。</p>\n</li>\n<li><p>wiki-Face，其实是显示一个网络图片的工具类。当我们编辑框结束，点击return后，这里利用WikiFace静态方法去加载网络接口，然后给图片的image设置进去。</p>\n</li>\n</ul>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-滑动删除\"><a href=\"#1-滑动删除\" class=\"headerlink\" title=\"1 滑动删除\"></a>1 滑动删除</h2><h3 id=\"1-1-效果\"><a href=\"#1-1-效果\" class=\"headerlink\" title=\"1.1 效果\"></a>1.1 效果</h3><img src=Swipeable%20Cell.gif>\n\n<h3 id=\"1-2-列表实现\"><a href=\"#1-2-列表实现\" class=\"headerlink\" title=\"1.2 列表实现\"></a>1.2 列表实现</h3><pre><code class=\"line-numbers language-Swift\">class ViewController: UITableViewController &#123;\n</code></pre>\n<p>数据定义：</p>\n<pre><code class=\"line-numbers language-Swift\">var data = [\n    pattern(image: &quot;1&quot;, name: &quot;Pattern Building&quot;),\n    pattern(image: &quot;2&quot;, name: &quot;Joe Beez&quot;),\n    pattern(image: &quot;3&quot;, name: &quot;Car It&#39;s car&quot;),\n    pattern(image: &quot;4&quot;, name: &quot;Floral Kaleidoscopic&quot;),\n    pattern(image: &quot;5&quot;, name: &quot;Sprinkle Pattern&quot;),\n    pattern(image: &quot;6&quot;, name: &quot;Palitos de queso&quot;),\n    pattern(image: &quot;7&quot;, name: &quot;Ready to Go? Pattern&quot;),\n    pattern(image: &quot;8&quot;, name: &quot;Sets Seamless&quot;),\n]\n</code></pre>\n<p>数据绑定：</p>\n<pre><code class=\"line-numbers language-Swift\">override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n        return data.count\n    &#125;\n    \noverride func numberOfSections(in tableView: UITableView) -&gt; Int &#123;\n    return 4\n&#125;\n\noverride func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n    return 60\n&#125;\n\noverride func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n    let cell = tableView.dequeueReusableCell(withIdentifier: &quot;PatternCell&quot;, for: indexPath) as! PatternCell\n    let pattern = data[indexPath.row]\n    \n    cell.patternImageView.image = UIImage(named: pattern.image)\n    cell.patternNameLabel.text = pattern.name\n    return cell\n&#125;\n\n// 横滑 增加3个UITableViewRowAction \noverride func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -&gt; [UITableViewRowAction]? &#123;\n    let delete = UITableViewRowAction(style: .normal, title: &quot;🗑\\nDelete&quot;) &#123; action, index in\n        print(&quot;Delete button tapped&quot;)\n    &#125;\n    delete.backgroundColor = UIColor.gray\n    \n    // 分析点击事件\n    let share = UITableViewRowAction(style: .normal, title: &quot;🤗\\nShare&quot;) &#123; (action, indexPath) in\n        let firstActivityItem = self.data[indexPath.row]\n        let activityViewController = UIActivityViewController(activityItems: [firstActivityItem.image as NSString], applicationActivities: nil)\n        \n        self.present(activityViewController, animated: true, completion: nil)\n    &#125;\n    share.backgroundColor = UIColor.red\n    \n    let download = UITableViewRowAction(style: .normal, title: &quot;⬇️\\nDownload&quot;) &#123; action, index in\n        print(&quot;Download button tapped&quot;)\n    &#125;\n    download.backgroundColor = UIColor.blue\n    \n    return [download, share, delete]\n&#125;\n\noverride func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -&gt; Bool &#123;\n    return true\n&#125;\n\noverride func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) &#123;\n    switch editingStyle &#123;\n    case .delete:\n        print(&quot;Delete&quot;)\n    case .insert:\n        print(&quot;Insert&quot;)\n    case .none:\n        print(&quot;None&quot;)\n    &#125;\n&#125;\n</code></pre>\n<p>cell是自定义的，但主要是通过故事版拖动的，代码绑定里面没有做其它事情。<br>其实这个横滑效果，是系统支持的，我们只需要多实现一些协议方法即可。</p>\n<h2 id=\"2-3D触摸菜单\"><a href=\"#2-3D触摸菜单\" class=\"headerlink\" title=\"2 3D触摸菜单\"></a>2 3D触摸菜单</h2><h3 id=\"2-1-效果\"><a href=\"#2-1-效果\" class=\"headerlink\" title=\"2.1 效果\"></a>2.1 效果</h3><img src=3DTouchQuickAction.gif>\n\n<h3 id=\"2-2-页面定义\"><a href=\"#2-2-页面定义\" class=\"headerlink\" title=\"2.2 页面定义\"></a>2.2 页面定义</h3><p>首页很简单，这里是在故事版里面绑定的控制器。<br>就中间一个Label。</p>\n<p>然后还有2个页面，都是一张图片，在故事版里面定义了，没有在代码里面声明。</p>\n<h3 id=\"2-3-配置3D菜单\"><a href=\"#2-3-配置3D菜单\" class=\"headerlink\" title=\"2.3 配置3D菜单\"></a>2.3 配置3D菜单</h3><p>先在info.plist中配置菜单，这里先不实现具体跳转：<br><img src=22.png></p>\n<h3 id=\"2-4-AppDelegate配置\"><a href=\"#2-4-AppDelegate配置\" class=\"headerlink\" title=\"2.4 AppDelegate配置\"></a>2.4 AppDelegate配置</h3><pre><code class=\"line-numbers language-Swift\">enum ShortcutIdentifier: String &#123;\n    \n    case First\n    case Second\n    case Third\n    \n    init?(fullType: String) &#123;\n        guard let last = fullType.components(separatedBy: &quot;.&quot;).last else &#123;\n            return nil\n        &#125;\n        self.init(rawValue: last)\n    &#125;\n    \n    var type: String &#123;\n        return Bundle.main.bundleIdentifier! + &quot;.\\(self.rawValue)&quot;\n    &#125;\n&#125;\n</code></pre>\n<p>这里先定义一个枚举，注意到这里的type为Bundle.main.bundleIdentifier，这里应该必须要为这个了。</p>\n<p>然后这里配置application协议：</p>\n<pre><code class=\"line-numbers language-Swift\">func application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -&gt; Void) &#123;\n    let handledShortCutItem = handleShortCutItem(shortcutItem)\n    // 走回调\n    completionHandler(handledShortCutItem)\n&#125;\n\nfunc handleShortCutItem(_ shortcutItem: UIApplicationShortcutItem) -&gt; Bool &#123;\n        \n    var handled = false\n    \n    guard let _ = ShortcutIdentifier(fullType: shortcutItem.type) else &#123;\n        return false\n    &#125;\n    \n    guard let shortCutType = shortcutItem.type as String? else &#123;\n        return false\n    &#125;\n    \n    let storyboard = UIStoryboard(name: &quot;Main&quot;, bundle: nil)\n    var vc: UIViewController\n    \n    switch (shortCutType) &#123;\n    case ShortcutIdentifier.First.type:\n        // Handle shortcut 1\n        vc = storyboard.instantiateViewController(withIdentifier: &quot;RunVC&quot;) as! RunViewController\n        handled = true\n    case ShortcutIdentifier.Second.type:\n        // Handle shortcut 2\n        vc = storyboard.instantiateViewController(withIdentifier: &quot;ScanVC&quot;) as! ScanViewController\n        handled = true\n    case ShortcutIdentifier.Third.type:\n        // Handle shortcut 3\n        vc = storyboard.instantiateViewController(withIdentifier: &quot;WiFiVC&quot;) as! SwitchWiFiViewController\n        handled = true\n    default:\n        vc = UIViewController()\n        break\n    &#125;\n    \n    // Display the selected view controller\n    //\n    var presentedVC: UIViewController = window!.rootViewController!\n    while presentedVC.presentedViewController != nil &#123;\n        presentedVC = presentedVC.presentedViewController!\n    &#125;\n    if !presentedVC.isMember(of: vc.classForCoder) &#123;\n        presentedVC.present(vc, animated: true, completion: nil)\n    &#125;\n    \n    return handled\n&#125;\n</code></pre>\n<p>这里定义了快捷键方式跳转方式，这里通过获取到Main的故事版，然后，故事版去instantiateViewController来获取其它的控制器，这里再通过present方法跳转到目标控制器。</p>\n<h2 id=\"3-侧滑菜单\"><a href=\"#3-侧滑菜单\" class=\"headerlink\" title=\"3 侧滑菜单\"></a>3 侧滑菜单</h2><h3 id=\"3-1-效果\"><a href=\"#3-1-效果\" class=\"headerlink\" title=\"3.1 效果\"></a>3.1 效果</h3><img src=SlideOutMenu.gif>\n\n<h3 id=\"3-2-侧滑支持\"><a href=\"#3-2-侧滑支持\" class=\"headerlink\" title=\"3.2 侧滑支持\"></a>3.2 侧滑支持</h3><p>首先需要引入SWRevealViewController.h和SWRevealViewController.m文件。<br>这个用官方的即可，文件比较长，就不贴进来了。</p>\n<h3 id=\"3-3-故事版定义\"><a href=\"#3-3-故事版定义\" class=\"headerlink\" title=\"3.3 故事版定义\"></a>3.3 故事版定义</h3><img src=23_1.png>\n这里定义好了跳转逻辑，直接在故事版里面操作的。\n\n<p>其它2个item也是如此。</p>\n<p>主要是在Main.storyboard中定义了第一个控制为：SWRevealViewController<br>这个是oc写的。</p>\n<p>故事版里面定义了这个控制器会指向一个BackTableVC。</p>\n<h3 id=\"3-4-控制器配置\"><a href=\"#3-4-控制器配置\" class=\"headerlink\" title=\"3.4 控制器配置\"></a>3.4 控制器配置</h3><p>第一个菜单控制器为：</p>\n<pre><code class=\"line-numbers language-Swift\">class Channel : UIViewController &#123;\n    \n    override func viewDidLoad() &#123;\n        self.navigationController?.isNavigationBarHidden = true\n        self.view.addGestureRecognizer(self.revealViewController().panGestureRecognizer())\n    &#125;\n    \n&#125;\n</code></pre>\n<p>第二个菜单控制器为：</p>\n<pre><code class=\"line-numbers language-Swift\">class ReadLater : UIViewController &#123;\n    \n    override func viewDidLoad() &#123;\n        self.navigationController?.isNavigationBarHidden = true\n        self.view.addGestureRecognizer(self.revealViewController().panGestureRecognizer())\n    &#125;\n    \n&#125;\n</code></pre>\n<p>第三个菜单控制为：</p>\n<pre><code class=\"line-numbers language-Swift\">class FriendRead : UIViewController &#123;\n    \n    override func viewDidLoad() &#123;\n        self.navigationController?.isNavigationBarHidden = true\n        self.view.addGestureRecognizer(self.revealViewController().panGestureRecognizer())   \n    &#125;   \n&#125;\n</code></pre>\n<p>这里必须配置：</p>\n<pre><code> self.view.addGestureRecognizer(self.revealViewController().panGestureRecognizer())   \n</code></pre>\n<p>才能实现菜单左滑手势效果哦。</p>\n<h2 id=\"4-磁片效果\"><a href=\"#4-磁片效果\" class=\"headerlink\" title=\"4 磁片效果\"></a>4 磁片效果</h2><h3 id=\"4-1-效果\"><a href=\"#4-1-效果\" class=\"headerlink\" title=\"4.1 效果\"></a>4.1 效果</h3><img src=MosaicLayouts.gif>\n\n<h3 id=\"4-2-pod引入三方库\"><a href=\"#4-2-pod引入三方库\" class=\"headerlink\" title=\"4.2 pod引入三方库\"></a>4.2 pod引入三方库</h3><p>这里通过Pod引入依赖，如下图：<br><img src=24_1.png></p>\n<p>这里引入了FMMosaicLayout库+AFNetworking+ORStackView+SwiftyJSON<br>用了这四个库。</p>\n<h3 id=\"4-3-页面定义\"><a href=\"#4-3-页面定义\" class=\"headerlink\" title=\"4.3 页面定义\"></a>4.3 页面定义</h3><p>这里也是用了一个UICollectionView，单一个页面。<br>直接继承了这个：UICollectionViewController。</p>\n<pre><code class=\"line-numbers language-Swift\">override func numberOfSections(in collectionView: UICollectionView) -&gt; Int &#123;\n        return 10\n    &#125;\n    \noverride func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123;\n    let cell = collectionView.dequeueReusableCell(withReuseIdentifier: &quot;Cell&quot;, for: indexPath)\n    cell.alpha = 0\n    \n    let imageView = cell.contentView.viewWithTag(2) as! UIImageView\n    imageView.image = UIImage(named: imageArray[indexPath.row])\n    \n    let cellDelay = UInt64((arc4random() % 600 ) / 1000 )\n    let cellDelayTime = DispatchTime(uptimeNanoseconds: cellDelay * NSEC_PER_SEC)\n    DispatchQueue.main.asyncAfter(deadline: cellDelayTime) &#123;\n        UIView.animate(withDuration: 0.8, animations: &#123;\n            cell.alpha = 1.0\n        &#125;)\n    &#125;\n    \n    return cell\n&#125;\n\n\noverride func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123;\n    return imageArray.count\n&#125;\n</code></pre>\n<p>主要实现了这几个协议方法。<br>Cell用了系统的。</p>\n<p>内容直接用UIImageView表示。</p>\n<p>然后这里异步开启动画效果，alpha从0到1的变化效果。</p>\n<h3 id=\"4-4-初始化\"><a href=\"#4-4-初始化\" class=\"headerlink\" title=\"4.4 初始化\"></a>4.4 初始化</h3><pre><code class=\"line-numbers language-Swift\">var imageArray = [String]()\n\noverride func viewDidLoad() &#123;\n    super.viewDidLoad()\n    imageArray = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;, &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;, &quot;16&quot;, &quot;17&quot;, &quot;18&quot;, &quot;19&quot;, &quot;20&quot;, &quot;21&quot;]\n    let mosaicLayout = FMMosaicLayout()\n    self.collectionView?.collectionViewLayout = mosaicLayout\n    if #available(iOS 11.0, *) &#123;\n        self.collectionView?.contentInsetAdjustmentBehavior = .never\n    &#125;\n&#125;\n</code></pre>\n<p>这里初始化的时候，将collectionView的collectionViewLayout设置为三方库的View。</p>\n<p>如何设置为不同大小，这里就是三方库的作用了：</p>\n<pre><code class=\"line-numbers language-Swift\">extension ViewController : FMMosaicLayoutDelegate &#123;\n\n    func collectionView(_ collectionView: UICollectionView!, layout collectionViewLayout: FMMosaicLayout!, numberOfColumnsInSection section: Int) -&gt; Int &#123;\n        return 3\n    &#125;\n\n    func collectionView(_ collectionView: UICollectionView!, layout collectionViewLayout: FMMosaicLayout!, mosaicCellSizeForItemAt indexPath: IndexPath!) -&gt; FMMosaicCellSize &#123;\n        return indexPath.item % 7 == 0 ? .big : .small\n    &#125;\n\n    func collectionView(_ collectionView: UICollectionView!, layout collectionViewLayout: FMMosaicLayout!, interitemSpacingForSectionAt section: Int) -&gt; CGFloat &#123;\n        return 1.0\n    &#125;\n\n    func collectionView(_ collectionView: UICollectionView!, layout collectionViewLayout: FMMosaicLayout!, insetForSectionAt section: Int) -&gt; UIEdgeInsets &#123;\n        return UIEdgeInsets(top: 1.0, left: 1.0, bottom: 1.0, right: 1.0)\n    &#125;\n&#125;\n</code></pre>\n<p>这里如果是7的倍数就大图，否则小图。有3种类型。</p>\n<h2 id=\"5-基础动画\"><a href=\"#5-基础动画\" class=\"headerlink\" title=\"5 基础动画\"></a>5 基础动画</h2><h3 id=\"5-1-效果\"><a href=\"#5-1-效果\" class=\"headerlink\" title=\"5.1 效果\"></a>5.1 效果</h3><img src=BasicAnimation.gif>\n\n<h3 id=\"5-2-故事版\"><a href=\"#5-2-故事版\" class=\"headerlink\" title=\"5.2 故事版\"></a>5.2 故事版</h3><p>第一个启动页首先是Main.storyboard故事版，然后这个故事版有一个Storyboard Entry Point就是第一个场景了，这里第一个场景是空的NavigationController Scene。</p>\n<p>然后这里绑定了这个第一个场景跳转逻辑，底部这里有个：<br><img src=25_1.png></p>\n<p>那如何修改这个启动路径呢？<br><img src=25_2.png><br>这里最右侧属性里面，先清除掉之前的，然后拖动小圆点，指向目标场景即可哦。</p>\n<p>这里Navigation Controller场景指向了BasicAnimation场景，这里面是一个TableView。<br>这里配置的UITableView的代理和数据源都指向了Basic Animation。<br><img src=25_3.png><br>这里数据直接在故事版里面写好了。</p>\n<p>然后item的跳转也是直接在故事版里面拖动的：<br><img src=25_4.png></p>\n<p>这里其实对应的首页的Controller没有啥东西：</p>\n<pre><code class=\"line-numbers language-Swift\">class ViewController: UITableViewController &#123;\n\n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        self.tableView.tableFooterView = UIView(frame: .zero)\n    &#125;\n\n    override func didReceiveMemoryWarning() &#123;\n        super.didReceiveMemoryWarning()\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"5-3-Position动画\"><a href=\"#5-3-Position动画\" class=\"headerlink\" title=\"5.3 Position动画\"></a>5.3 Position动画</h3><p>这里定义了3个方块。</p>\n<pre><code class=\"line-numbers language-Swift\">class PositionViewController: UIViewController &#123;\n\n    @IBOutlet weak var yellowSquareView: UIView!\n    @IBOutlet weak var blueSquareView: UIView!\n    @IBOutlet weak var mouseView: UIView!    \n</code></pre>\n<p>已经出现动画时执行动画：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidAppear(_ animated: Bool) &#123;\n        super.viewDidAppear(animated)\n        \n    UIView.animate(withDuration: 0.8, delay: 0.2, usingSpringWithDamping: 0.6, initialSpringVelocity: 0.8, options: .curveEaseInOut, animations: &#123;\n        self.yellowSquareView.center.x = self.view.bounds.width - self.yellowSquareView.center.x\n        self.yellowSquareView.center.y = self.yellowSquareView.center.y + 30\n        self.blueSquareView.center.x = self.view.bounds.width -  self.blueSquareView.center.x\n        self.blueSquareView.center.y = self.blueSquareView.center.y + 30\n\n        &#125;, completion: nil )\n    \n    UIView.animate(withDuration: 0.6, delay: 0.4, usingSpringWithDamping: 0.6, initialSpringVelocity: 0.8, options: .curveEaseOut, animations: &#123;\n        self.setHeight(180)\n        self.mouseView.center.y = self.view.bounds.height - self.mouseView.center.y\n        &#125;, completion: nil )\n&#125;\n\nfunc setHeight(_ height: CGFloat) &#123;\n    \n    var frame: CGRect = self.mouseView.frame\n    frame.size.height = height\n    \n    self.mouseView.frame = frame\n&#125;\n</code></pre>\n<h3 id=\"5-4-Opacity动画\"><a href=\"#5-4-Opacity动画\" class=\"headerlink\" title=\"5.4 Opacity动画\"></a>5.4 Opacity动画</h3><pre><code class=\"line-numbers language-Swift\">class OpacityViewController: UIViewController &#123;\n\n    @IBOutlet weak var exampleImageView: UIImageView!\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n\n    &#125;\n\n    override func didReceiveMemoryWarning() &#123;\n        super.didReceiveMemoryWarning()\n    &#125;\n    \n    override func viewDidAppear(_ animated: Bool) &#123;\n        super.viewDidAppear(animated)\n        \n        UIView.animate(withDuration: 2) &#123;\n            self.exampleImageView.alpha = 0\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里控制图片alpha从1到0的动画。</p>\n<h3 id=\"5-5-Scale动画\"><a href=\"#5-5-Scale动画\" class=\"headerlink\" title=\"5.5 Scale动画\"></a>5.5 Scale动画</h3><pre><code class=\"line-numbers language-Swift\">class ScaleViewController: UIViewController &#123;\n\n    @IBOutlet weak var scaleImageView: UIImageView!\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n        self.scaleImageView.alpha = 0\n    &#125;\n\n    override func didReceiveMemoryWarning() &#123;\n        super.didReceiveMemoryWarning()\n    &#125;\n    \n    override func viewDidAppear(_ animated: Bool) &#123;\n        super.viewDidAppear(animated)\n        \n        \n        UIView.animate(withDuration: 0.8, delay: 0, usingSpringWithDamping: 0.7, initialSpringVelocity: 1, options: .curveEaseIn, animations: &#123;\n            self.scaleImageView.transform = CGAffineTransform(scaleX: 2, y: 2)\n            self.scaleImageView.alpha = 1\n            \n            &#125;, completion: nil )\n    &#125;\n&#125;\n</code></pre>\n<p>这里alpha从0到1,缩放动画从1到2。</p>\n<h3 id=\"5-6-Color动画\"><a href=\"#5-6-Color动画\" class=\"headerlink\" title=\"5.6 Color动画\"></a>5.6 Color动画</h3><pre><code class=\"line-numbers language-Swift\">class ColorViewController: UIViewController &#123;\n\n    @IBOutlet weak var bgColorView: UIView!\n    @IBOutlet weak var numberLabel: UILabel!\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n\n    &#125;\n\n    override func didReceiveMemoryWarning() &#123;\n        super.didReceiveMemoryWarning()\n    &#125;\n    \n    override func viewDidAppear(_ animated: Bool) &#123;\n        super.viewDidAppear(animated)\n        \n        \n        UIView.animate(withDuration: 0.5, delay: 0.2, options: .curveEaseIn, animations: &#123;\n            self.bgColorView.backgroundColor = .black\n            \n            &#125;, completion: nil )\n        \n        UIView.animate(withDuration: 0.5, delay: 0.8, options: .curveEaseOut, animations: &#123;\n            self.numberLabel.textColor = UIColor(red:0.959, green:0.937, blue:0.109, alpha:1)\n            \n            &#125;, completion: nil)\n    &#125;\n&#125;\n</code></pre>\n<p>这里设置颜色从黄到黑，文字颜色也变化了。</p>\n<h3 id=\"5-7-Rotation动画\"><a href=\"#5-7-Rotation动画\" class=\"headerlink\" title=\"5.7 Rotation动画\"></a>5.7 Rotation动画</h3><pre><code class=\"line-numbers language-Swift\">class RotationViewController: UIViewController &#123;\n\n    @IBOutlet weak var emojiLabel: UILabel!\n    @IBOutlet weak var rotationImageView: UIImageView!\n    @IBOutlet weak var trump2: UIImageView!\n    @IBOutlet weak var trump3: UIImageView!\n    @IBOutlet weak var trump4: UIImageView!\n    @IBOutlet weak var trump5: UIImageView!\n    @IBOutlet weak var trump6: UIImageView!\n    @IBOutlet weak var trump7: UIImageView!\n    @IBOutlet weak var trump8: UIImageView!\n    \n    func spin() &#123;\n        UIView.animate(withDuration: 0.8, delay: 0, options: .curveLinear, animations: &#123;\n            self.rotationImageView.transform = self.rotationImageView.transform.rotated(by: CGFloat(Double.pi))\n            self.trump2.transform = self.trump2.transform.rotated(by: CGFloat(Double.pi))\n            self.trump3.transform = self.trump3.transform.rotated(by: CGFloat(Double.pi))\n            self.trump4.transform = self.trump4.transform.rotated(by: CGFloat(Double.pi))\n            self.trump5.transform = self.trump5.transform.rotated(by: CGFloat(Double.pi))\n            self.trump6.transform = self.trump6.transform.rotated(by: CGFloat(Double.pi))\n            self.trump7.transform = self.trump7.transform.rotated(by: CGFloat(Double.pi))\n            self.trump8.transform = self.trump8.transform.rotated(by: CGFloat(Double.pi))\n            self.emojiLabel.transform = self.emojiLabel.transform.rotated(by: CGFloat(Double.pi))\n            &#125;) &#123; (finished) -&gt; Void in\n                self.spin()\n        &#125;\n    &#125;\n    \n    override func viewDidAppear(_ animated: Bool) &#123;\n        super.viewDidAppear(animated)\n        self.spin()\n    &#125;\n&#125;\n</code></pre>\n<p>这里让8个视图都开始旋转了。</p>\n<h2 id=\"6-CoreData使用\"><a href=\"#6-CoreData使用\" class=\"headerlink\" title=\"6 CoreData使用\"></a>6 CoreData使用</h2><h3 id=\"6-1-效果\"><a href=\"#6-1-效果\" class=\"headerlink\" title=\"6.1 效果\"></a>6.1 效果</h3><img src=CoreData.gif>\n\n<h3 id=\"6-2-AddDelegate配置\"><a href=\"#6-2-AddDelegate配置\" class=\"headerlink\" title=\"6.2 AddDelegate配置\"></a>6.2 AddDelegate配置</h3><pre><code class=\"line-numbers language-Swift\">lazy var applicationDocumentsDirectory: NSURL = &#123;\n        // The directory the application uses to store the Core Data store file. This code uses a directory named &quot;me.appkitchen.cd&quot; in the application&#39;s documents Application Support directory.\n        let urls = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)\n        return urls[urls.count-1] as NSURL\n    &#125;()\n\nlazy var managedObjectModel: NSManagedObjectModel = &#123;\n    // The managed object model for the application. This property is not optional. It is a fatal error for the application not to be able to find and load its model.\n    let modelURL = Bundle.main.url(forResource: &quot;cd&quot;, withExtension: &quot;momd&quot;)!\n    return NSManagedObjectModel(contentsOf: modelURL)!\n&#125;()\n\nlazy var persistentStoreCoordinator: NSPersistentStoreCoordinator = &#123;\n    // The persistent store coordinator for the application. This implementation creates and returns a coordinator, having added the store for the application to it. This property is optional since there are legitimate error conditions that could cause the creation of the store to fail.\n    // Create the coordinator and store\n    let coordinator = NSPersistentStoreCoordinator(managedObjectModel: self.managedObjectModel)\n    let url = self.applicationDocumentsDirectory.appendingPathComponent(&quot;SingleViewCoreData.sqlite&quot;)\n    var failureReason = &quot;There was an error creating or loading the application&#39;s saved data.&quot;\n    do &#123;\n        try coordinator.addPersistentStore(ofType: NSSQLiteStoreType, configurationName: nil, at: url, options: nil)\n    &#125; catch &#123;\n        // Report any error we got.\n        var dict = [String: AnyObject]()\n        dict[NSLocalizedDescriptionKey] = &quot;Failed to initialize the application&#39;s saved data&quot; as AnyObject\n        dict[NSLocalizedFailureReasonErrorKey] = failureReason as AnyObject\n\n        dict[NSUnderlyingErrorKey] = error as NSError\n        let wrappedError = NSError(domain: &quot;YOUR_ERROR_DOMAIN&quot;, code: 9999, userInfo: dict)\n        // Replace this with code to handle the error appropriately.\n        // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.\n        NSLog(&quot;Unresolved error \\(wrappedError), \\(wrappedError.userInfo)&quot;)\n        abort()\n    &#125;\n\n    return coordinator\n&#125;()\n\nlazy var managedObjectContext: NSManagedObjectContext = &#123;\n    // Returns the managed object context for the application (which is already bound to the persistent store coordinator for the application.) This property is optional since there are legitimate error conditions that could cause the creation of the context to fail.\n    let coordinator = self.persistentStoreCoordinator\n    var managedObjectContext = NSManagedObjectContext(concurrencyType: .mainQueueConcurrencyType)\n    managedObjectContext.persistentStoreCoordinator = coordinator\n    return managedObjectContext\n&#125;()\n\n// MARK: - Core Data Saving support\n\nfunc saveContext () &#123;\n    if managedObjectContext.hasChanges &#123;\n        do &#123;\n            try managedObjectContext.save()\n        &#125; catch &#123;\n            // Replace this implementation with code to handle the error appropriately.\n            // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.\n            let nserror = error as NSError\n            NSLog(&quot;Unresolved error \\(nserror), \\(nserror.userInfo)&quot;)\n            abort()\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>因为代码比较久了，这个按照XCode指示修复后就是这个效果。<br>这里可以运行了。</p>\n<p>主要是applicationWillTerminate方法中saveContext了。</p>\n<h3 id=\"6-3-可见数据操作\"><a href=\"#6-3-可见数据操作\" class=\"headerlink\" title=\"6.3 可见数据操作\"></a>6.3 可见数据操作</h3><p>这里代码使用还有点问题，暂时无法贴最新代码。<br>关于CoreData的使用还是建议参考这篇文章：<br><a href=\"https://blog.ficowshen.com/page/post/52\">了解和采用 CoreData 框架 —— Ficow 陪你学 CoreData</a>。</p>\n<h2 id=\"7-底部Bar动画\"><a href=\"#7-底部Bar动画\" class=\"headerlink\" title=\"7 底部Bar动画\"></a>7 底部Bar动画</h2><h3 id=\"7-1-效果\"><a href=\"#7-1-效果\" class=\"headerlink\" title=\"7.1 效果\"></a>7.1 效果</h3><img src=TapBarAnimation.gif>\n\n<h3 id=\"7-2-故事版添加导航item\"><a href=\"#7-2-故事版添加导航item\" class=\"headerlink\" title=\"7.2 故事版添加导航item\"></a>7.2 故事版添加导航item</h3><img src=27_1.png>\n\n<p>这里应该是关联到了这3个item。<br>这样子，就可以展示底部导航栏效果。<br>然后item也定义了跳转的目标场景。</p>\n<h3 id=\"7-3-第一个Tab页\"><a href=\"#7-3-第一个Tab页\" class=\"headerlink\" title=\"7.3 第一个Tab页\"></a>7.3 第一个Tab页</h3><pre><code class=\"line-numbers language-Swift\">class FirstTabViewController: UIViewController, UITableViewDataSource, UITableViewDelegate &#123;\n\n    @IBOutlet weak var articleTableView: UITableView!\n    \n    var data = [\n    \n        article(avatarImage: &quot;allen&quot;, sharedName: &quot;Allen Wang&quot;, actionType: &quot;Read Later&quot;, articleTitle: &quot;Giphy Cam Lets You Create And Share Homemade Gifs&quot;, articleCoverImage: &quot;giphy&quot;, articleSouce: &quot;TheNextWeb&quot;, articleTime: &quot;5min  •  13:20&quot;),\n        article(avatarImage: &quot;Daniel Hooper&quot;, sharedName: &quot;Daniel Hooper&quot;, actionType: &quot;Shared on Twitter&quot;, articleTitle: &quot;Principle. The Sketch of Prototyping Tools&quot;, articleCoverImage: &quot;my workflow flow&quot;, articleSouce: &quot;SketchTalk&quot;, articleTime: &quot;3min  •  12:57&quot;),\n        article(avatarImage: &quot;davidbeckham&quot;, sharedName: &quot;David Beckham&quot;, actionType: &quot;Shared on Facebook&quot;, articleTitle: &quot;Ohlala, An Uber For Escorts, Launches Its ‘Paid Dating’ Service In NYC&quot;, articleCoverImage: &quot;Ohlala&quot;, articleSouce: &quot;TechCrunch&quot;, articleTime: &quot;1min  •  12:59&quot;),\n        article(avatarImage: &quot;bruce&quot;, sharedName: &quot;Bruce Fan&quot;, actionType: &quot;Shared on Weibo&quot;, articleTitle: &quot;Lonely Planet’s new mobile app helps you explore major cities like a pro&quot;, articleCoverImage: &quot;Lonely Planet&quot;, articleSouce: &quot;36Kr&quot;, articleTime: &quot;5min  •  11:21&quot;),\n\n    ]\n</code></pre>\n<p>上面是数据定义。</p>\n<p>然后设置代理和数据源：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n    super.viewDidLoad()\n    \n    articleTableView.dataSource = self\n    articleTableView.delegate = self\n    articleTableView.separatorStyle = UITableViewCell.SeparatorStyle.none\n    articleTableView.tableFooterView = UIView(frame: .zero)\n&#125;\n\n \nfunc numberOfSectionsInTableView(tableView: UITableView) -&gt; Int &#123;\n    return 10\n&#125;\n\nfunc tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n    return data.count\n&#125;\n\nfunc tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n    return 165\n&#125;\n\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n    let cell = articleTableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) as! ArticleTableViewCell\n    let article = data[indexPath.row]\n    \n    cell.avatarImage.image = UIImage(named: article.avatarImage)\n    cell.articleCoverImage.image = UIImage(named: article.articleCoverImage)\n    cell.sharedNameLabel.text = article.sharedName\n    cell.actionTypeLabel.text = article.actionType\n    cell.articleTitleLabel.text = article.articleTitle\n    cell.articleSouceLabel.text = article.articleSouce\n    cell.articelCreatedAtLabel.text = article.articleTime\n    cell.selectionStyle = UITableViewCell.SelectionStyle.none\n    \n    return cell   \n&#125;\n</code></pre>\n<p>这里配置了Cell:</p>\n<pre><code class=\"line-numbers language-Swift\">struct article &#123;\n    let avatarImage: String\n    let sharedName: String\n    let actionType: String\n    let articleTitle: String\n    let articleCoverImage: String\n    let articleSouce: String\n    let articleTime: String\n&#125;\n\nclass ArticleTableViewCell: UITableViewCell &#123;\n\n    @IBOutlet weak var avatarImage: UIImageView!\n    @IBOutlet weak var sharedNameLabel: UILabel!\n    @IBOutlet weak var actionTypeLabel: UILabel!\n    @IBOutlet weak var articleCoverImage: UIImageView!\n    \n    @IBOutlet weak var articleTitleLabel: UILabel!\n    @IBOutlet weak var articleSouceLabel: UILabel!\n    @IBOutlet weak var articelCreatedAtLabel: UILabel!\n    \n    override func awakeFromNib() &#123;\n        super.awakeFromNib()\n        // Initialization code\n\n    &#125;\n\n    override func setSelected(_ selected: Bool, animated: Bool) &#123;\n        super.setSelected(selected, animated: animated)\n\n        // Configure the view for the selected state\n    &#125;\n&#125;\n</code></pre>\n<p>这里应该就是item配置了，具体布局是用故事版里面的配置的。</p>\n<p>可见的时候，执行动画效果：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewWillAppear(_ animated: Bool) &#123;   \n    animateTable()\n&#125;\n\nfunc animateTable() &#123;\n    \n    self.articleTableView.reloadData()\n    \n    let cells = articleTableView.visibleCells\n    let tableHeight: CGFloat = articleTableView.bounds.size.height\n    \n    for i in cells &#123;\n        let cell: UITableViewCell = i as UITableViewCell\n        cell.transform = CGAffineTransform(translationX: 0, y: tableHeight)\n    &#125;\n    \n    var index = 0\n    \n    for a in cells &#123;\n        let cell: UITableViewCell = a as UITableViewCell\n        UIView.animate(withDuration: 1.0, delay: 0.05 * Double(index), usingSpringWithDamping: 0.8, initialSpringVelocity: 0, options: [], animations: &#123;\n            cell.transform = CGAffineTransform(translationX: 0, y: 0);\n            &#125;, completion: nil)\n        \n        index += 1\n    &#125;\n&#125;\n</code></pre>\n<p>从下往上的动画效果。</p>\n<h3 id=\"7-4-第二个Tab的动画\"><a href=\"#7-4-第二个Tab的动画\" class=\"headerlink\" title=\"7.4 第二个Tab的动画\"></a>7.4 第二个Tab的动画</h3><pre><code class=\"line-numbers language-Swift\">override func viewDidAppear(_ animated: Bool) &#123;\n    super.viewDidAppear(animated)\n    \n    UIView.animate(withDuration: 0.5, delay: 0.1, usingSpringWithDamping: 0.7, initialSpringVelocity: 1, options: .curveEaseIn, animations: &#123;\n        self.exploreImageView.transform = CGAffineTransform(scaleX: 1, y: 1)\n        self.exploreImageView.alpha = 1\n        \n        &#125;, completion: nil )\n&#125;\n\noverride func viewDidDisappear(_ animated: Bool) &#123;\n    super.viewDidDisappear(animated)\n    resetViewTransform()\n&#125;\n\n// MARK:\nfunc resetViewTransform() &#123;\n    self.exploreImageView.alpha = 0\n    self.exploreImageView.transform = CGAffineTransform(scaleX: 0.5, y: 0.5)\n&#125;\n</code></pre>\n<h3 id=\"7-5-第三个Tab的动画\"><a href=\"#7-5-第三个Tab的动画\" class=\"headerlink\" title=\"7.5 第三个Tab的动画\"></a>7.5 第三个Tab的动画</h3><pre><code class=\"line-numbers language-Swift\">override func viewDidAppear(_ animated: Bool) &#123;\n        super.viewDidAppear(animated)\n    \n    UIView.animate(withDuration: 0.5, delay: 0.1, usingSpringWithDamping: 0.7, initialSpringVelocity: 1, options: .curveEaseIn, animations: &#123;\n        self.profileImageView.transform = CGAffineTransform(scaleX: 1, y: 1)\n        self.profileImageView.alpha = 1\n        \n        &#125;, completion: nil )\n&#125;\n\noverride func viewDidDisappear(_ animated: Bool) &#123;\n    super.viewDidDisappear(animated)\n    resetViewTransform()\n&#125;\n\n// MARK:\nfunc resetViewTransform() &#123;\n    self.profileImageView.alpha = 0\n    self.profileImageView.transform = CGAffineTransform(scaleX: 0.5, y: 0.5)\n&#125;\n</code></pre>\n<h2 id=\"8-系统搜索\"><a href=\"#8-系统搜索\" class=\"headerlink\" title=\"8 系统搜索\"></a>8 系统搜索</h2><h3 id=\"8-1-效果\"><a href=\"#8-1-效果\" class=\"headerlink\" title=\"8.1 效果\"></a>8.1 效果</h3><img src=Spotlight%20Search.gif>\n\n<h3 id=\"8-2-首页\"><a href=\"#8-2-首页\" class=\"headerlink\" title=\"8.2 首页\"></a>8.2 首页</h3><p>数据设置：<br><img src=28_1.png><br>这里新建了一个电影数据，用key-value形式保存了。</p>\n<p>可见时处理：</p>\n<pre><code class=\"line-numbers language-Swift\">override func viewDidLoad() &#123;\n    super.viewDidLoad()\n    loadMoviesInfo()\n    configureTableView()\n    navigationItem.title = &quot;Movies&quot;\n    setupSearchableContent()\n&#125;\n\n// 加载根目录文件数据，拿到数组\nfunc loadMoviesInfo() &#123;\n    if let path = Bundle.main.path(forResource: &quot;MoviesData&quot;, ofType: &quot;plist&quot;) &#123;\n        moviesInfo = NSMutableArray(contentsOfFile: path)\n    &#125;\n&#125;\n\n// 配置代理和数据源\nfunc configureTableView() &#123;\n    tblMovies.delegate = self\n    tblMovies.dataSource = self\n    tblMovies.tableFooterView = UIView(frame: CGRect.zero)\n    tblMovies.register(UINib(nibName: &quot;MovieSummaryCell&quot;, bundle: nil), forCellReuseIdentifier: &quot;idCellMovieSummary&quot;)\n&#125;\n\n// 搜索数据装载，使用了系统的类  CSSearchableItem\nfunc setupSearchableContent() &#123;\n    var searchableItems = [CSSearchableItem]()\n    \n    for i in 0...(moviesInfo.count - 1) &#123;\n        \n        let movie = moviesInfo[i] as! [String: String]\n        let searchableItemAttributeSet = CSSearchableItemAttributeSet(itemContentType: kUTTypeText as String)\n        \n        //set the title\n        searchableItemAttributeSet.title = movie[&quot;Title&quot;]!\n        \n        //set the image\n        let imagePathParts = movie[&quot;Image&quot;]!.components(separatedBy: &quot;.&quot;)\n        searchableItemAttributeSet.thumbnailURL = Bundle.main.url(forResource: imagePathParts[0], withExtension: imagePathParts[1])\n        \n        // Set the description.\n        searchableItemAttributeSet.contentDescription = movie[&quot;Description&quot;]!\n        \n        var keywords = [String]()\n        let movieCategories = movie[&quot;Category&quot;]!.components(separatedBy: &quot;, &quot;)\n        for movieCategory in movieCategories &#123;\n            keywords.append(movieCategory)\n        &#125;\n        \n        let stars = movie[&quot;Stars&quot;]!.components(separatedBy: &quot;, &quot;)\n        for star in stars &#123;\n            keywords.append(star)\n        &#125;\n        \n        searchableItemAttributeSet.keywords = keywords\n        \n        let searchableItem = CSSearchableItem(uniqueIdentifier: &quot;com.appcoda.SpotIt.\\(i)&quot;, domainIdentifier: &quot;movies&quot;, attributeSet: searchableItemAttributeSet)\n        \n        searchableItems.append(searchableItem)\n        \n        CSSearchableIndex.default().indexSearchableItems(searchableItems) &#123;\n            if $0 != nil &#123;\n                print($0!.localizedDescription)\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>监听系统搜索后跳转逻辑：</p>\n<pre><code class=\"line-numbers language-Swift\">override func restoreUserActivityState(_ activity: NSUserActivity) &#123;\n    if activity.activityType == CSSearchableItemActionType &#123;\n        if let userInfo = activity.userInfo &#123;\n            let selectedMovie = userInfo[CSSearchableItemActivityIdentifier] as! String\n            selectedMovieIndex = Int(selectedMovie.components(separatedBy: &quot;.&quot;).last!)\n            performSegue(withIdentifier: &quot;idSegueShowMovieDetails&quot;, sender: self)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>然后是代理和数据源配置：</p>\n<pre><code class=\"line-numbers language-Swift\"> func numberOfSections(in tableView: UITableView) -&gt; Int &#123;\n        return 1\n    &#125;\n    \nfunc tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;\n    if moviesInfo != nil &#123;\n        return moviesInfo.count\n    &#125;\n    return 0\n&#125;\n\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;\n    let cell = tableView.dequeueReusableCell(withIdentifier: &quot;idCellMovieSummary&quot;, for: indexPath) as! MovieSummaryCell\n    let currentMovieInfo = moviesInfo[(indexPath as NSIndexPath).row] as! [String: String]\n    \n    cell.lblTitle.text = currentMovieInfo[&quot;Title&quot;]!\n    cell.lblDescription.text = currentMovieInfo[&quot;Description&quot;]!\n    cell.lblRating.text = currentMovieInfo[&quot;Rating&quot;]!\n    cell.imgMovieImage.image = UIImage(named: currentMovieInfo[&quot;Image&quot;]!)\n    \n    return cell\n&#125;\n\nfunc tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;\n    return 100.0\n&#125;\n\nfunc tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123;\n    selectedMovieIndex = (indexPath as NSIndexPath).row\n    performSegue(withIdentifier: &quot;idSegueShowMovieDetails&quot;, sender: self)\n&#125;\n\noverride func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123;\n    if let identifier = segue.identifier, identifier == &quot;idSegueShowMovieDetails&quot; &#123;\n        let movieDetailsViewController = segue.destination as! MovieDetailsViewController\n        movieDetailsViewController.movieInfo = moviesInfo[selectedMovieIndex] as? [String: String]\n    &#125;\n&#125;\n</code></pre>\n<p>这里didSelectRowAt，通过调用系统的performSegue决定跳转到某个场景。</p>\n<h3 id=\"8-3-详情页\"><a href=\"#8-3-详情页\" class=\"headerlink\" title=\"8.3 详情页\"></a>8.3 详情页</h3><pre><code class=\"line-numbers language-Swift\">class MovieDetailsViewController: UIViewController &#123;\n\n    @IBOutlet weak var imgMovieImage: UIImageView!\n    @IBOutlet weak var lblTitle: UILabel!\n    @IBOutlet weak var lblCategory: UILabel!\n    @IBOutlet weak var lblDescription: UILabel!\n    @IBOutlet weak var lblDirector: UILabel!\n    @IBOutlet weak var lblStars: UILabel!\n    @IBOutlet weak var lblRating: UILabel!\n    \n    var movieInfo: [String: String]!\n    \n    override func viewDidLoad() &#123;\n        super.viewDidLoad()\n    &#125;\n    \n    override func viewWillAppear(_ animated: Bool) &#123;\n        super.viewWillAppear(animated)\n        \n        lblRating.layer.cornerRadius = lblRating.frame.size.width/2\n        lblRating.layer.masksToBounds = true\n        \n        if movieInfo != nil &#123;\n            populateMovieInfo()\n        &#125;\n    &#125;\n    \n    \n    override func didReceiveMemoryWarning() &#123;\n        super.didReceiveMemoryWarning()\n    &#125;\n    \n    func populateMovieInfo() &#123;\n        \n        lblTitle.text = movieInfo[&quot;Title&quot;]!\n        lblCategory.text = movieInfo[&quot;Category&quot;]!\n        lblDescription.text = movieInfo[&quot;Description&quot;]!\n        lblDirector.text = movieInfo[&quot;Director&quot;]!\n        lblStars.text = movieInfo[&quot;Stars&quot;]!\n        lblRating.text = movieInfo[&quot;Rating&quot;]!\n        imgMovieImage.image = UIImage(named: movieInfo[&quot;Image&quot;]!)\n        \n    &#125;\n&#125;\n</code></pre>\n<p>这里配置了movieInfo，外部设置进来，然后回显进去。</p>\n<h2 id=\"9-选择头像\"><a href=\"#9-选择头像\" class=\"headerlink\" title=\"9 选择头像\"></a>9 选择头像</h2><h3 id=\"9-1-效果\"><a href=\"#9-1-效果\" class=\"headerlink\" title=\"9.1 效果\"></a>9.1 效果</h3><img src=AvatarPicker.gif>\n\n<h3 id=\"9-2-点击头像\"><a href=\"#9-2-点击头像\" class=\"headerlink\" title=\"9.2 点击头像\"></a>9.2 点击头像</h3><pre><code class=\"line-numbers language-Swift\">@IBAction func pickProfileImage(_ tap: UITapGestureRecognizer) &#123;\n    let authorization = PHPhotoLibrary.authorizationStatus()\n    \n    if authorization == .notDetermined &#123;\n        PHPhotoLibrary.requestAuthorization &#123; _ in\n            DispatchQueue.main.async &#123;\n                self.pickProfileImage(tap)\n            &#125;\n        &#125;\n    &#125;\n    \n    if authorization == .authorized &#123;\n        let controller = ImagePickerSheetController()\n        controller.addAction(action: ImageAction(title: NSLocalizedString(&quot;Take Photo or Video&quot;, comment: &quot;Action Title&quot;), secondaryTitle: NSLocalizedString(&quot;Use this one&quot;, comment: &quot;Action Title&quot;), handler: &#123; _ in\n            self.presentCamera()\n        &#125;, secondaryHandler: &#123; (action, numberOfPhotos) in\n            controller.getSelectedImagesWithCompletion(completion: &#123; images in\n                self.profileImage = images[0]\n                self.userProfileImageView.image = self.profileImage\n            &#125;)\n        &#125;))\n                    \n        controller.addAction(action: ImageAction(title: NSLocalizedString(&quot;Cancel&quot;, comment: &quot;Action Title&quot;), style: .Cancel, handler: nil, secondaryHandler: nil))\n        \n        self.present(controller, animated: true, completion: nil)\n    &#125;\n    \n    \n&#125;\n\nfunc presentCamera()\n&#123;\n    print(&quot;拍照&quot;)\n&#125;\n</code></pre>\n<p>这里先判断有无权限，没有权限继续执行，有权限再跳转控制器。</p>\n<h2 id=\"10-wiki-Face\"><a href=\"#10-wiki-Face\" class=\"headerlink\" title=\"10 wiki-Face\"></a>10 wiki-Face</h2><h3 id=\"10-1-效果\"><a href=\"#10-1-效果\" class=\"headerlink\" title=\"10.1 效果\"></a>10.1 效果</h3><img src=wikiFace.gif>\n\n<h3 id=\"10-2-搜索处理\"><a href=\"#10-2-搜索处理\" class=\"headerlink\" title=\"10.2 搜索处理\"></a>10.2 搜索处理</h3><pre><code class=\"line-numbers language-Swift\">func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool &#123;\n        \n    textField.resignFirstResponder()\n    \n    if let textFieldContent = textField.text &#123;\n        do &#123;\n            try WikiFace.faceForPerson(textFieldContent, size: CGSize(width: 300, height: 400), completion: &#123; (image:UIImage?, imageFound:Bool) -&gt; () in\n                if imageFound == true &#123;\n                    DispatchQueue.main.async &#123;\n                        self.faceImageView.image = image\n                        \n                        UIView.animate(withDuration: 0.8, delay: 0, usingSpringWithDamping: 0.7, initialSpringVelocity: 1, options: .curveEaseIn, animations: &#123; () -&gt; Void in\n                            \n                            self.faceImageView.transform = CGAffineTransform(scaleX: 1, y: 1)\n                            self.faceImageView.alpha = 1\n                            \n                            //Fuck! Useless...LOL\n                            self.faceImageView.layer.shadowOpacity = 0.4\n                            self.faceImageView.layer.shadowOffset = CGSize(width: 3.0, height: 2.0)\n                            self.faceImageView.layer.shadowRadius = 15.0\n                            self.faceImageView.layer.shadowColor = UIColor.black.cgColor\n                            \n                        &#125;, completion: nil )\n                        \n                        WikiFace.centerImageViewOnFace(self.faceImageView)\n                    &#125;\n                &#125;\n\n            &#125;)\n        &#125;catch WikiFace.WikiFaceError.CouldNotDownloadImage&#123;\n            print(&quot;Could not access wikipedia for downloading an image&quot;)\n        &#125; catch &#123;\n            print(error)\n        &#125;\n    &#125;\n    \n    return true\n    \n&#125;\n</code></pre>\n<p>使用工具类：</p>\n<pre><code class=\"line-numbers language-Swift\">import UIKit\nimport ImageIO\n\nclass WikiFace: NSObject &#123;\n    \n    enum WikiFaceError: Error &#123;\n        case CouldNotDownloadImage\n    &#125;\n    \n    class func faceForPerson(_ person: String, size: CGSize, completion:@escaping (_ image: UIImage? ,_ imageFound: Bool) -&gt; ()) throws &#123;\n        \n        let escapedString = person.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlHostAllowed)\n        let pixelsForAPIRequest = Int(max(size.width, size.height)) * 2\n        \n        let url = URL(string: &quot;https://en.wikipedia.org/w/api.php?action=query&amp;titles=\\(escapedString!)&amp;prop=pageimages&amp;format=json&amp;pithumbsize=\\(pixelsForAPIRequest)&quot;)\n        \n        let task: URLSessionTask = URLSession.shared.dataTask(with: url!, completionHandler: &#123;\n            (data: Data?, response: URLResponse?, error: Error?) in\n            if error == nil &#123;\n                let wikiDict = try! JSONSerialization.jsonObject(with: data!, options: JSONSerialization.ReadingOptions.allowFragments) as! NSDictionary\n        \n                if let query = wikiDict.object(forKey: &quot;query&quot;) as? NSDictionary &#123;\n                    if let pages = query.object(forKey: &quot;pages&quot;) as? NSDictionary &#123;\n                        if let pageContent = pages.allValues.first as? NSDictionary &#123;\n                            if let thumbnail = pageContent.object(forKey: &quot;thumbnail&quot;) as? NSDictionary &#123;\n                                if let thumbURL = thumbnail.object(forKey: &quot;source&quot;) as? String &#123;\n                                    let faceImage = UIImage(data: try! Data(contentsOf: URL(string: thumbURL)!))\n                                    completion(faceImage, true)\n                                &#125;\n                            &#125;else&#123;\n                                completion(nil, false)\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;)\n        task.resume()\n    &#125;\n    \n    class func centerImageViewOnFace (_ imageView: UIImageView) &#123;\n        \n        let context = CIContext(options: nil)\n        let options = [CIDetectorAccuracy:CIDetectorAccuracyHigh]\n        let detector = CIDetector(ofType: CIDetectorTypeFace, context: context, options: options)\n        \n        let faceImage = imageView.image\n        let ciImage = CIImage(cgImage: faceImage!.cgImage!)\n        \n        let features = detector?.features(in: ciImage)\n        \n        if (features?.count)! &gt; 0 &#123;\n            \n            var face:CIFaceFeature!\n            \n            for rect in features! &#123;\n                face = rect as? CIFaceFeature\n            &#125;\n            \n            var faceRectWithExtendedBounds = face.bounds\n            faceRectWithExtendedBounds.origin.x -= 20\n            faceRectWithExtendedBounds.origin.y -= 30\n            \n            faceRectWithExtendedBounds.size.width += 40\n            faceRectWithExtendedBounds.size.height += 60\n            \n            let x = faceRectWithExtendedBounds.origin.x / faceImage!.size.width\n            let y = (faceImage!.size.height - faceRectWithExtendedBounds.origin.y - faceRectWithExtendedBounds.size.height) / faceImage!.size.height\n            \n            let widthFace = faceRectWithExtendedBounds.size.width / faceImage!.size.width\n            let heightFace = faceRectWithExtendedBounds.size.height  / faceImage!.size.height\n            \n            imageView.layer.contentsRect = CGRect(x: x, y: y, width: widthFace, height: heightFace)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里应该是走异步接口，然后将网络图片设置给UIImageVIew了。</p>\n<h2 id=\"11-总结\"><a href=\"#11-总结\" class=\"headerlink\" title=\"11 总结\"></a>11 总结</h2><ul>\n<li><p>滑动删除效果其实是UITableView里面自带的一个方法editActionsForRowAt方法，里面配置的UITableViewRowAction实现的。</p>\n</li>\n<li><p>3D触摸效果，首先需要在info.plist中配置菜单，然后在AppDelegate中定义菜单的跳转逻辑，可以present方式跳转到目标页面。</p>\n</li>\n<li><p>侧滑菜单，这个需要引入一下SWRevealViewController，这个是oc写的，这里面配置一下菜单控制器，这样就可以实现侧滑效果，主要工作量在SWRevealViewController里面。</p>\n</li>\n<li><p>磁片效果，这个主要是引入了一个三方库，FMMosaicLayout库，需要实现一下FMMosaicLayoutDelegate这个方法，这样就可以实现不同item的大小。</p>\n</li>\n<li><p>基础动画，这里定义了各种各样的基础动画使用方法，Position动画就是height高度区别，Opacity效果是配置alpah，Scale效果是CGAffineTransform这个配置，Color动画就改变一下颜色值，Rotation动画就是设置transform的rotated方法。</p>\n</li>\n<li><p>CoreData的使用主要是现在appDelegate中设置saveContext，其它操作类似操作数据库。</p>\n</li>\n<li><p>底部Bar动画，主要是在可见的时候，对每个UITableViewCell里面做了一个动画效果，里面通过设置CGAffineTransform这个实现。</p>\n</li>\n<li><p>系统搜索，这个首先需要配置一个数据源，可以再plist文件里面写一个数组，然后通过系统的搜索类来实现，CSSearchableIndex这个来注入数据。然后配置restoreUserActivityState这个方法，可以决定item跳转目标类。</p>\n</li>\n<li><p>选择头像，这里主要是用了一个工具类，然后通过PHPotoLibrary获取权限，有权限就跳转，没有权限申请，有权限跳转到自定义的ImagePickerSheetController，然后会present这个类。</p>\n</li>\n<li><p>wiki-Face，其实是显示一个网络图片的工具类。当我们编辑框结束，点击return后，这里利用WikiFace静态方法去加载网络接口，然后给图片的image设置进去。</p>\n</li>\n</ul>\n"},{"title":"iOS swift Gitee客户端 完整项目分析之一","date":"2023-02-06T06:47:06.000Z","op":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 项目地址\n> [https://gitee.com/open-gitee/gitee_ios](https://gitee.com/open-gitee/gitee_ios) \nGitee基于SwiftUI和OpenApi的iOS客户端项目。\n\n## 2 项目截图\n||||\n|--|--|--|\n| <img src=1.png> | <img src=2.png> | <img src=3.png> |\n| <img src=4.png> | <img src=5.png> | <img src=6.png> |\n\n## 3 首页架构\n\n这里是底部3个Tab，首页展示一个工作台消息中心，你的团队的入库。应该是写死的布局。\n\n第二个tab是好友动态，这里展示一个列表，展示动态列表。\n\n第三个tab是设置页，上方是头像，然后是关注粉丝star啥的。\n\n关于App和Scene代码结构，可以参考这篇文章：\n[SwiftUI2.0 —— App、Scene及新的代码结构（一）](https://zhuanlan.zhihu.com/p/152624613)。\n\n应用初始化代码：\n```Swift\n@main\nstruct GiteeApp: App {\n    var body: some Scene {\n        WindowGroup {\n            TabBarView(selectedBarIndex: 0)\n                .preferredColorScheme(.dark)\n        }\n    }\n}\n```\n这里body就是首页了。\nApp，Scene，WindowGroup都是系统类。\n\n里面的TabBarView是自定义View来的：\n```Swift\nstruct TabBarView: View {\n    @State var selectedBarIndex:Int\n    \n    var body: some View {\n        NavigationView{\n            TabView(selection: $selectedBarIndex) {\n                HomeView()\n                .tabItem {\n                    Image(systemName:\"briefcase\")\n                    Text(\"首页\")\n                }\n                    .tag(0)\n                ActivityView()\n                .tabItem {\n                    Image(systemName:\"stopwatch\")\n                    Text(\"动态\")\n                }\n                    .tag(1)\n//                ExploreView()\n//                .tabItem {\n//                    Image(systemName:\"opticaldisc\")\n//                    Text(\"发现\")\n//                }\n//                    .tag(2)\n                SettingView()\n                .tabItem {\n                    Image(systemName:\"gearshape\")\n                    Text(\"设置\")\n                }\n                    .tag(3)\n            }\n            .navigationBarTitle(getNavBarTitle(),displayMode: getNavBarModel())\n            .navigationBarHidden(self.selectedBarIndex==3)\n            .foregroundColor(.white)\n            .accentColor(.white) //这里修改文字颜色\n        }\n        .navigationViewStyle(StackNavigationViewStyle())\n        .accentColor(.white)\n        .foregroundColor(.white)\n        .preferredColorScheme(.dark)\n    }\n```\n这里TabView其实就是定义的底部Tab，然后item点击后是配置在中间的。\n比如HomeView就是首页了，ActivityView应该就是动态页了，SettingView就是设置页了。\n\n```Swift\n\nfunc getNavBarModel() -> NavigationBarItem.TitleDisplayMode{\n    if self.selectedBarIndex == 0 {\n        return .large\n    }\n    if self.selectedBarIndex == 1 {\n        return .inline\n    }\n    if self.selectedBarIndex == 2 {\n        return .large\n    }\n    if self.selectedBarIndex == 3 {\n        return .large\n    }\n    return .inline\n}\nfunc getNavBarTitle() -> String{\n    if self.selectedBarIndex == 0 {\n        return \"Gitee\"\n    }\n    if self.selectedBarIndex == 1 {\n        return \"好友动态\"\n    }\n    if self.selectedBarIndex == 2 {\n        return \"发现\"\n    }\n    if self.selectedBarIndex == 3{\n        return \"设置\"\n    }\n    return  \"\"\n}\n```\n这里配置tab具体数据。\n![](./iOS-swift-Gitee%E5%AE%A2%E6%88%B7%E7%AB%AF-%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%80/tab1.png)\n<img src=tab1.png>\n这里Form是表格。\nSection是组别。\n这里有一个NavigationLink是item1就是第一个item，这里显示代码仓库。颜色和icon都可以设置的。\n\n 但是这里的HomeListItem是自己定义的哦。\n ```Swift\nstruct HomeListItem : View {\n    @State var title: String\n    @State var icon: String\n    @State var color: Color\n    \n    var body: some View {\n        HStack(spacing: 15){\n            Image(systemName:icon)\n                .scaleEffect(1.5, anchor: .center)\n                .foregroundColor(color)\n            Text(title).font(.system(size:16))\n        }\n        .padding(.horizontal, 5)\n        .frame( height: 48)\n        .cornerRadius(10)\n    }\n}\n ```\n\n这个HStack是系统的，估计类似于Flutter里面的Stack吧。\n这里右侧箭头是咋来的呢？\n原来是\n```Swift\nvar body: some View {\n    Form {\n        Section(header: Text(\"工作台\")) {\n            NavigationLink(destination: RepoView()) {\n                HomeListItem(title: \"代码仓库\",icon:\"archivebox.circle\", color: Color(hex: 0x7699ec))\n            }\n//                NavigationLink(destination:  PullRequestView()) {\n//                    HomeListItem(title: \"Pull Request\",icon:\"shuffle.circle\", color: Color(hex: 0x00b392))\n//                }\n            NavigationLink(destination:  IssuesView()) {\n                HomeListItem(title: \"Issues\",icon:\"exclamationmark.circle\", color: Color(hex: 0xfe665b))\n            }\n        }\n```\n这里面的NavigationLink自带的箭头哦。\n\n### 3.2 仓库页面\n前面用了一个NavigationLink包裹，那么点击这个之后应该是跳转到目标页面。\n\n这里是先跳转到你的仓库页面。\n先看看哈：\n```Swift\nvar body: some View {\n    LoadingView(isLoading:self.$isLoading,message: self.$message,isModal:self.$isModal) {\n        ZStack{\n            if repoList.count == 0 && !isLoading {\n                VStack{\n                    Image(systemName: \"doc.text.magnifyingglass\")\n                        .scaleEffect(3, anchor: .center)\n                    Text(\"暂无查询到的仓库\").padding(.top,30)\n                }\n            }\n            RefreshView(refreshing: $isRefreshing, action: {\n                self.page = 1\n                self.getRepoList(page: self.page)\n            }) {\n                LazyVStack{\n                    ForEach(self.repoList){ item in\n                        NavigationLink(destination: RepoDetailView(repoFullPath: item.repoNamespace.path + \"/\" + item.repoPath)) {\n                            RepoItemView(repoItem: item)\n                                .onAppear(){\n                                    if !waitPlease && item.id == repoList[repoList.count - 1].id {\n                                        self.page = self.page + 1\n                                        self.getRepoList(page: self.page)\n                                    }\n                                }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    .sheet(isPresented: $isLoginShow,onDismiss: {\n        UserModel().getMyInfo { (userInfo) in\n            self.page = 1\n            self.getRepoList(page: self.page)\n        } error: {\n            self.isLoginShow.toggle()\n        }\n    }){\n        LoginView()\n            .modifier(DisableModalDismiss(disabled: true))\n    }\n    .padding(.top,5)\n    .navigationBarTitle(Text(naviTitle), displayMode: .inline)\n    .navigationBarItems(\n        trailing:\n            HStack {\n                Button(action: {\n                    self.isFilterShow.toggle()\n                }) {\n                    Image(systemName: \"rectangle.and.text.magnifyingglass\")\n                        \n                        .scaleEffect(1, anchor: .center)\n                }\n            }\n            .sheet(isPresented: $isFilterShow,onDismiss: {\n                self.isLoading = true\n                self.page = 1\n                self.getRepoList(page: self.page)\n            }){\n                RepoFilterView(showListFrom: self.showListFrom)\n                    .modifier(DisableModalDismiss(disabled: false))\n            }\n    )\n    .onAppear(){\n        switch self.showListFrom {\n        case ShowRepoListFrom.fromWatches:\n            self.naviTitle = \"Watch的仓库\"\n        case ShowRepoListFrom.fromStars:\n            self.naviTitle = \"Star的仓库\"\n        default:\n            self.naviTitle = \"你的仓库\"\n        }\n        \n        localConfig.setValue(\"all\", forKey: giteeConfig.repo_type)\n        localConfig.setValue(\"pushed\", forKey: giteeConfig.repo_sort)\n        localConfig.setValue(\"desc\", forKey: giteeConfig.repo_direction)\n        self.page = 1\n        self.getRepoList( page: self.page)\n    }\n}\n```\n\nloading视图：\n```Swift\nstruct LoadingView<Content>: View where Content: View {\n    \n    @Binding var isLoading: Bool\n    @Binding var message:String\n    @Binding var isModal: Bool\n    @State var isAnimating: Bool = true\n    var content: () -> Content\n    \n    var body: some View {\n        GeometryReader { geometry in\n            ZStack(alignment: .center) {\n                self.content()\n                    .disabled(self.isModal)\n                    .blur(radius: self.isModal ? 10 : 0)\n                VStack {\n                    Text(self.message)\n                        .padding(.bottom,20)\n                    ActivityIndicatorLoading(isAnimating: self.$isAnimating, style: .large)\n                }\n                    \n                .frame(width: geometry.size.width / 2,\n                       height: geometry.size.height / 5)\n                    .background(Color.secondary.colorInvert())\n                    .foregroundColor(Color.primary)\n                    .cornerRadius(20)\n                    .opacity(self.isLoading ? 1 : 0)\n            }\n        }\n    }\n}\n```\n这里的Loading效果是ActivityIndicatorLoading这个实现的。这个是自定义的哦。\n继续走这个：\n```Swift\nstruct ActivityIndicatorLoading: UIViewRepresentable {\n    \n    @Binding var isAnimating: Bool\n    let style: UIActivityIndicatorView.Style\n    \n    func makeUIView(context: UIViewRepresentableContext<ActivityIndicatorLoading>) -> UIActivityIndicatorView {\n        return UIActivityIndicatorView(style: style)\n    }\n    \n    func updateUIView(_ uiView: UIActivityIndicatorView, context: UIViewRepresentableContext<ActivityIndicatorLoading>) {\n        isAnimating ? uiView.startAnimating() : uiView.stopAnimating()\n    }\n}\n```\n原来是UIActivityIndicatorView这个类来实现loading效果的。\n\n然后这里有个自定义刷新视图。\n可以参考下这篇文章：[https://swiftui-lab.com/scrollview-pull-to-refresh/](https://swiftui-lab.com/scrollview-pull-to-refresh/)。\n\n```Swift\nLazyVStack{\n    ForEach(self.repoList){ item in\n        NavigationLink(destination: RepoDetailView(repoFullPath: item.repoNamespace.path + \"/\" + item.repoPath)) {\n            RepoItemView(repoItem: item)\n                .onAppear(){\n                    if !waitPlease && item.id == repoList[repoList.count - 1].id {\n                        self.page = self.page + 1\n                        self.getRepoList(page: self.page)\n                    }\n                }\n        }\n    }\n}\n```\n这里就是刷新器里面展示列表。\n\n列表的item是这个RepoItemView:\n```Swift\nstruct RepoItemView:View{\n    @State var repoItem: RepoModel\n    @State private var isActiveCommit:Bool = false\n    @State private var isActivePullRequest:Bool = false\n    @State private var isActiveIssues:Bool = false\n    \n    var body: some View{\n        VStack{\n            VStack{\n                NavigationLink(destination: CommitView(repoFullPath: repoItem.repoNamespace.path + \"/\" + repoItem.repoPath,repoDefaultBranch: repoItem.repoDefaultBranch), isActive: $isActiveCommit) { EmptyView() }\n                NavigationLink(destination: PullRequestView(repoFullPath: repoItem.repoNamespace.path + \"/\" + repoItem.repoPath), isActive: $isActivePullRequest) { EmptyView() }\n                NavigationLink(destination: IssuesView(repoPath: repoItem.repoNamespace.path + \"/\" + repoItem.repoPath),isActive: $isActiveIssues) { EmptyView() }\n            }\n            .frame(width: 0, height: 0)\n            .opacity(0)\n            VStack(alignment: .leading){\n                HStack(alignment: .top) {\n                    if !self.repoItem.repoIsOpenSource {\n                        Image(systemName: \"lock.square.fill\")\n                            .foregroundColor(Color(hex: 0xffc55a))\n                            .padding(.trailing,-5)\n                            .scaleEffect(1, anchor: .center)\n                    }\n                    VStack(alignment: .leading){\n                        Text(self.repoItem.repoNamespace.name + \"/\" + self.repoItem.repoName)\n                            .font(.system(size: 16))\n                            .lineLimit(1)\n                    }\n                    Spacer()\n                    Text(self.repoItem.repoPushDate)\n                        .font(.system(size: 12))\n                        .foregroundColor(.gray)\n                    \n                }\n                .padding(5)\n                Text(self.repoItem.repoDesc == \"\" ? \"很尴尬,该项目暂无介绍...\" : self.repoItem.repoDesc)\n                    .font(.system(size: 14))\n                    .foregroundColor(.gray)\n                    .lineLimit(3)\n                    .multilineTextAlignment(.leading)\n                    .padding(.top,10)\n                    .padding(.leading,5)\n                    .fixedSize(horizontal: false, vertical: true)\n                Spacer()\n                HStack{\n                    if self.repoItem.repoLanguage != \"\" {\n                        VStack{\n                            Text(self.repoItem.repoLanguage)\n                                .padding(.vertical,1)\n                                .padding(.horizontal,3)\n                        }\n                        .font(.system(size: 12))\n                        .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n                        .foregroundColor(.gray)\n                        .cornerRadius(3)\n                    }\n                    if self.repoItem.repoLicense != \"\" {\n                        VStack{\n                            Text(self.repoItem.repoLicense)\n                                .padding(.vertical,1)\n                                .padding(.horizontal,3)\n                        }\n                        .font(.system(size: 12))\n                        .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n                        .foregroundColor(.gray)\n                        .cornerRadius(3)\n                    }\n                    Spacer()\n                    HStack{\n                        Image(systemName: \"star.fill\")\n                            .foregroundColor(.gray)\n                            .scaleEffect(0.6, anchor: .center)\n                            .padding(0)\n                        Text(self.repoItem.repoStars)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .padding(0)\n                            .padding(.leading,-12)\n                    }\n                    HStack{\n                        Image(systemName: \"eye.fill\")\n                            .foregroundColor(.gray)\n                            .scaleEffect(0.6, anchor: .center)\n                            .padding(0)\n                        Text(self.repoItem.repoWatches)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .padding(0)\n                            .padding(.leading,-12)\n                    }\n                    .padding(.horizontal,-8)\n                    HStack{\n                        Image(systemName: \"arrowshape.turn.up.backward.2.fill\")\n                            .foregroundColor(.gray)\n                            .scaleEffect(0.7, anchor: .center)\n                            .padding(0)\n                        Text(self.repoItem.repoForks)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .padding(0)\n                            .padding(.leading,-12)\n                    }\n                }\n                .padding(.top,5)\n            }\n            .padding(10)\n        }\n        .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n        .cornerRadius(10)\n        .padding(.horizontal,5)\n        .padding(.bottom,5)\n        //        .swipeCell(\n        //            cellPosition: .both,\n        //            leftSlot: nil,\n        //            rightSlot: SwipeCellSlot(\n        //                slots:\n        //                    [\n        //                        SwipeCellButton(\n        //                            buttonStyle: .titleAndImage,\n        //                            title: \"Mark\",\n        //                            systemImage: \"bookmark\",\n        //                            titleColor: .white,\n        //                            imageColor: .white,\n        //                            view: nil,\n        //                            backgroundColor: .green,\n        //                            action: {\n        //                                print(\"123\")\n        //                            },\n        //                            feedback:true\n        //                        )\n        //                    ]\n        //            )\n        //        )\n        .contextMenu(ContextMenu {\n            Button(action: {\n                self.isActiveCommit = true\n            }) {\n                HStack{\n                    Image(systemName: \"icloud.and.arrow.up\").scaleEffect(1, anchor: .center)\n                    Spacer()\n                    Text(\"提交记录\")\n                }\n            }\n            Divider()\n            Button(action: {\n                self.isActivePullRequest = true\n            }) {\n                HStack{\n                    Image(systemName: \"shuffle.circle\").scaleEffect(1, anchor: .center)\n                    Spacer()\n                    Text(\"Pull Requests\")\n                }\n            }\n            Button(action: {\n                self.isActiveIssues = true\n            }) {\n                HStack{\n                    Image(systemName: \"exclamationmark.circle\").scaleEffect(1, anchor: .center)\n                    Spacer()\n                    Text(\"查看Issues\")\n                }\n            }\n        })\n    }\n}\n```\n\n长按会弹出菜单，提交记录，Pull Requests Issues都是菜单项。\n注意到这里的菜单是一个Button，里面配置了action，然后在顶部配置了NavigationLink，实现跳转。\n\n### 3.3 提交记录 \n\n比如点击了提交记录：\n这里显示body:\n```Swift\nvar body: some View {\n    LoadingView(isLoading:self.$isLoading,message: self.$message,isModal:self.$isModal) {\n        ZStack{\n            if commitList.count == 0 && !isLoading {\n                VStack{\n                    Image(systemName: \"doc.text.magnifyingglass\")\n                        .scaleEffect(3, anchor: .center)\n                    Text(\"暂无查询到的提交\").padding(.top,30)\n                }\n            }\n            RefreshView(refreshing: $isRefreshing, action: {\n                self.page = 1\n                self.getCommitList(page: self.page)\n            }) {\n                LazyVStack{\n                    ForEach(self.commitList){ item in\n                        CommitItemView(commitItem: item, repoFullPath: self.repoFullPath!)\n                            .onAppear(){\n                                if !waitPlease && item.id == commitList[commitList.count - 1].id {\n                                    self.page = self.page + 1\n                                    self.getCommitList(page: self.page)\n                                }\n                            }\n                    }\n                }\n            }\n        }\n        .padding(.top,5)\n        .navigationBarTitle(Text(self.showCommitFrom == CommitFromModel.fromRepo ? branch : \"包含的提交\"), displayMode: .inline)\n        .navigationBarItems(\n            trailing:\n                HStack {\n                    if self.showCommitFrom == CommitFromModel.fromRepo{\n                        Button {\n                        } label: {\n                            Menu {\n                                ForEach (0 ..< self.branchList.count, id: \\.self) {index in\n                                    Button(self.branchList[index], action: {\n                                        self.branch = self.branchList[index]\n                                        self.page = 1\n                                        self.isLoading = true\n                                        self.getCommitList(page: self.page)\n                                    })\n                                }\n                            } label: {\n                                VStack{\n                                    Text(\"分支\").foregroundColor(.yellow)\n                                }\n                            }\n                        }\n                    }\n                }\n        )\n        .onAppear(){\n            if self.showCommitFrom == CommitFromModel.fromRepo{\n                self.branch = self.repoDefaultBranch!\n            }else{\n                self.branch = \"master\"\n            }\n            self.page = 1\n            self.getCommitList( page: self.page)\n            self.getBranchList()\n        }\n    }\n}\n```\n\nonAppear的时候，走接口。\n```Swift\n func getCommitList(page: Int){\n        if self.waitPlease { return }\n        self.waitPlease = true\n        if commitList.count == 0 {\n            self.isLoading = true\n        }\n        var url = \"repos/\"\n        if self.showCommitFrom == CommitFromModel.fromRepo{\n            url = url + self.repoFullPath! + \"/commits?page=\" + String(page)\n            url = url + \"&sha=\" + self.branch\n        }else if self.showCommitFrom == CommitFromModel.fromPullRequest{\n            url = url + (self.pullRequestItem?.prTo.repoNamespace.path)! + \"/\"\n            url = url + (self.pullRequestItem?.prTo.repoPath)! + \"/pulls/\"\n            url = url + String(self.pullRequestItem!.prId) + \"/commits\";\n        }\n        \n        HttpRequest(url: url, withAccessToken: true)\n            .doGet { (value) in\n                let json = JSON(value)\n                if json[\"message\"].string != nil {\n                    print(\"error\")\n                    DispatchQueue.main.async {\n                        UIAlertController.confirm(message: json[\"message\"].stringValue, title: \"发生错误\", confirmText: \"重新登录\", cancelText: \"返回\") { (action) in\n                            Helper.relogin()\n                        }\n                    }\n                }else{\n                    var tempList = self.commitList\n                    if page == 1{\n                        tempList = []\n                    }\n                    for (_,subJson):(String, JSON) in json {\n                        let author = subJson[\"commit\"][\"author\"][\"name\"].stringValue\n                        let userInfo = UserItemModel(id: Int(subJson[\"author\"][\"id\"].intValue), userHead: String(subJson[\"author\"][\"avatar_url\"].stringValue), userName: String(subJson[\"author\"][\"name\"].stringValue), userAccount: String(subJson[\"author\"][\"login\"].stringValue))\n                        tempList.append(CommitModel(id: subJson[\"sha\"].stringValue, sha: String(subJson[\"sha\"].stringValue), author: author, commitTime: String(subJson[\"commit\"][\"author\"][\"date\"].stringValue), message: String(subJson[\"commit\"][\"message\"].stringValue), addCount:  String(subJson[\"stats\"][\"additions\"].stringValue), deleteCount: String(subJson[\"stats\"][\"deletions\"].stringValue), totalCount: String(subJson[\"stats\"][\"total\"].stringValue), user: userInfo))\n                    }\n                    self.commitList = tempList\n                }\n                self.isRefreshing = false\n                self.isLoading = false\n                self.waitPlease = false\n            } errorCallback: {\n                self.isRefreshing = false\n                self.isLoading = false\n                self.waitPlease = false\n            }\n    }\n```\n\n这里获取分支：\n```Swift\nfunc getBranchList(){\n        var url = \"repos/\"\n        url = url + self.repoFullPath! + \"/branches\";\n        HttpRequest(url: url, withAccessToken: true)\n            .doGet { (value) in\n                let json = JSON(value)\n                if json[\"message\"].string != nil {\n                    DispatchQueue.main.async {\n                        UIAlertController.confirm(message: json[\"message\"].stringValue, title: \"发生错误\", confirmText: \"重新登录\", cancelText: \"返回\") { (action) in\n                            Helper.relogin()\n                        }\n                    }\n                }else{\n                    if page == 1{\n                        branchList = []\n                    }\n                    for (_,subJson):(String, JSON) in json {\n                        branchList.append(subJson[\"name\"].stringValue)\n                    }\n                }\n            } errorCallback: {\n                \n            }\n    }\n```\n\n注意到分支列表里面用了分支的item：\n```Swift\nstruct CommitItemView:View{\n    @State var commitItem: CommitModel\n    @State var repoFullPath: String\n    @State var userHead:UIImage? = nil\n    let placeholderImage = UIImage(named: \"nohead\")!\n    @State var isCommitChangeShow: Bool = false\n    \n    var body: some View{\n        VStack{\n            VStack(alignment: .leading){\n                VStack(alignment: .leading){\n                    HStack(alignment: .top) {\n                        Image(uiImage: self.userHead ?? placeholderImage)\n                            .resizable()\n                            .scaledToFit()\n                            .frame(\n                                width:20,height:20,\n                                alignment: .center\n                            )\n                            .cornerRadius(5)\n                            .onAppear(){\n                                guard let url = URL(string: commitItem.user.userHead) else {\n                                    return\n                                }\n                                URLSession.shared.dataTask(with: url) { (data, response, error) in\n                                    if let data = data, let image = UIImage(data: data) {\n                                        self.userHead = image\n                                    }\n                                }.resume()\n                            }\n                        VStack(alignment: .leading){\n                            Text(commitItem.message)\n                                .font(.system(size: 16))\n                                .lineLimit(1)\n                        }\n                        Spacer()\n                        Text(\"+\" + commitItem.addCount).foregroundColor(.green).font(.system(size:14)).fontWeight(.bold).padding(.leading,0)\n                        Text(\"-\" + commitItem.deleteCount).foregroundColor(.red).font(.system(size:14)).fontWeight(.bold).padding(.leading,0)\n                        \n                    }\n                }\n                .padding(.vertical,5)\n                HStack{\n                    Text(Helper.getDateFromString(str: commitItem.commitTime)).font(.system(size:14)).foregroundColor(.gray)\n                    Text(\"由 \").font(.system(size:14)).foregroundColor(.gray).padding(.leading,-5)\n                    Text(commitItem.author + \"(\" + commitItem.user.userAccount + \")\").font(.system(size:14)).foregroundColor(Color(hex: 0xaaaaaa)).padding(.leading,0).padding(.leading,-5)\n                    Text(\" 提交\").font(.system(size:14)).foregroundColor(.gray).padding(.leading,0).padding(.leading,-5)\n                    Spacer()\n                }\n            }\n            .padding(10)\n        }\n        .onTapGesture {\n            self.isCommitChangeShow = true\n        }\n        .sheet(isPresented: $isCommitChangeShow,onDismiss: {\n            \n        }){\n            CommitChangesView(sha: self.commitItem.sha, repoFullPath:\n                                self.repoFullPath)\n        }\n        .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n        .cornerRadius(10)\n        .padding(.horizontal,5)\n        .padding(.bottom,-5)\n    }\n}\n```\n\n### 3.4 Pull Request\n\n整个body定义：\n```Swift\nvar body: some View {\n    LoadingView(isLoading:self.$isLoading,message: self.$message,isModal:self.$isModal) {\n        ZStack{\n            if pullRequestList.count == 0 && !isLoading {\n                VStack{\n                    Image(systemName: \"doc.text.magnifyingglass\")\n                        .scaleEffect(3, anchor: .center)\n                    Text(\"暂无查询到的Pull Requests\").padding(.top,30)\n                }\n            }\n            RefreshView(refreshing: $isRefreshing, action: {\n                self.page = 1\n                self.getPullRequestList(page: self.page)\n            }) {\n                LazyVStack{\n                    ForEach(self.pullRequestList){ item in\n                        PullRequestItemView(pullRequestItem: item)\n                            .onAppear(){\n                                if !waitPlease && item.id == pullRequestList[pullRequestList.count - 1].id {\n                                    self.page = self.page + 1\n                                    self.getPullRequestList(page: self.page)\n                                }\n                            }\n                    }\n                }\n            }\n        }\n    }\n    .navigationBarTitle(Text(\"Pull Requests\"), displayMode: .inline)\n    .navigationBarItems(trailing:\n                            HStack {\n                                Button(action: {\n                                    self.isFilterShow.toggle()\n                                }) {\n                                    Image(systemName: \"rectangle.and.text.magnifyingglass\")\n                                        \n                                        .scaleEffect(1, anchor: .center)\n                                }\n                            }\n                            .sheet(isPresented: $isFilterShow,onDismiss: {\n                                self.isLoading = true\n                                self.page = 1\n                                self.getPullRequestList(page: self.page)\n                            }){\n                                PullRequestFilterView()\n                                    .modifier(DisableModalDismiss(disabled: false))\n                            }\n    )\n    .onAppear(){\n        localConfig.setValue(\"open\", forKey: giteeConfig.pull_request_state)\n        localConfig.setValue(\"updated\", forKey: giteeConfig.pull_request_sort)\n        localConfig.setValue(\"desc\", forKey: giteeConfig.pull_request_direction)\n        self.page = 1\n        self.getPullRequestList( page: self.page)\n    }\n}\n```\n\n可见时请求接口：\n```Swift\nfunc getPullRequestList(page: Int){\n    if self.waitPlease { return }\n    self.waitPlease = true\n    if pullRequestList.count == 0 {\n        self.isLoading = true\n    }\n    let state = localConfig.string(forKey: giteeConfig.pull_request_state)\n    let sort = localConfig.string(forKey: giteeConfig.pull_request_sort)\n    let direction = localConfig.string(forKey: giteeConfig.pull_request_direction)\n    var url = \"repos/\"\n    url = url + self.repoFullPath + \"/pulls?page=\" + String(page);\n    \n    url = url + \"&state=\" + state!\n    url = url + \"&sort=\" + sort!\n    url = url + \"&direction=\" + direction!\n    \n    \n    HttpRequest(url: url, withAccessToken: true)\n        .doGet { (value) in\n            let json = JSON(value)\n            if json[\"message\"].string != nil {\n                print(\"error\")\n                DispatchQueue.main.async {\n                    UIAlertController.confirm(message: json[\"message\"].stringValue, title: \"发生错误\", confirmText: \"重新登录\", cancelText: \"返回\") { (action) in\n                        Helper.relogin()\n                    }\n                }\n            }else{\n                var tempList = self.pullRequestList\n                if page == 1{\n                    tempList = []\n                }\n                for (_,subJson):(String, JSON) in json {\n                    let userInfo = UserItemModel(id: Int(subJson[\"user\"][\"id\"].intValue), userHead: String(subJson[\"user\"][\"avatar_url\"].stringValue), userName: String(subJson[\"user\"][\"name\"].stringValue), userAccount: String(subJson[\"user\"][\"login\"].stringValue))\n                    \n                    let fromRepo = RepoModel(id: Int(subJson[\"head\"][\"repo\"][\"id\"].intValue), repoName: String(subJson[\"head\"][\"repo\"][\"name\"].stringValue), repoPath: String(subJson[\"head\"][\"repo\"][\"path\"].stringValue), repoNamespace: RepoNamespace(id: Int(subJson[\"head\"][\"repo\"][\"namespace\"][\"id\"].intValue), name: String(subJson[\"head\"][\"repo\"][\"namespace\"][\"name\"].stringValue), path: String(subJson[\"head\"][\"repo\"][\"namespace\"][\"path\"].stringValue)), repoDesc: String(subJson[\"head\"][\"repo\"][\"description\"].stringValue), repoForks: \"\", repoStars: \"\",repoWatches:\"\", repoLicense:\"\", repoLanguage: \"\", repoPushDate:\"\", repoIsFork: false, repoIsOpenSource: Bool(subJson[\"head\"][\"repo\"][\"public\"].boolValue), repoIssues:\"\", repoDefaultBranch:\"\")\n                    \n                    let toRepo = RepoModel(id: Int(subJson[\"base\"][\"repo\"][\"id\"].intValue), repoName: String(subJson[\"base\"][\"repo\"][\"name\"].stringValue), repoPath: String(subJson[\"base\"][\"repo\"][\"path\"].stringValue), repoNamespace: RepoNamespace(id: Int(subJson[\"base\"][\"repo\"][\"namespace\"][\"id\"].intValue), name: String(subJson[\"base\"][\"repo\"][\"namespace\"][\"name\"].stringValue), path: String(subJson[\"base\"][\"repo\"][\"namespace\"][\"path\"].stringValue)), repoDesc: String(subJson[\"base\"][\"repo\"][\"description\"].stringValue), repoForks: \"\", repoStars: \"\",repoWatches:\"\", repoLicense:\"\", repoLanguage: \"\", repoPushDate:\"\", repoIsFork: false, repoIsOpenSource: Bool(subJson[\"base\"][\"repo\"][\"public\"].boolValue), repoIssues:\"\", repoDefaultBranch:\"\")\n                    \n                    tempList.append(PullRequestModel(id: Int(subJson[\"id\"].intValue), prId: Int(subJson[\"number\"].intValue), prStatus: getPullRequestStatus(status: String(subJson[\"state\"].stringValue)), prTitle: String(subJson[\"title\"].stringValue), prBody: String(subJson[\"body\"].stringValue), prUser: userInfo, prFrom: fromRepo, prTo: toRepo, prTime: Helper.getDateFromString(str: String(subJson[\"updated_at\"].stringValue)), prAuthMerge: Bool(subJson[\"mergeable\"].boolValue),prFromBranch: String(subJson[\"head\"][\"ref\"].stringValue),prToBranch: String(subJson[\"base\"][\"ref\"].stringValue)))\n                }\n                self.pullRequestList = tempList\n            }\n            self.isRefreshing = false\n            self.isLoading = false\n            self.waitPlease = false\n        } errorCallback: {\n            self.isRefreshing = false\n            self.isLoading = false\n            self.waitPlease = false\n            \n        }\n}\n```\n\n然后还是pull Request的item展示了：\n```Swift\nstruct PullRequestItemView:View{\n    @State var pullRequestItem: PullRequestModel\n    @State var prFromToString:String = \"\"\n    @State var prFromToString2:String = \"\"\n    @State private var isActiveCommit:Bool = false\n    @State private var isActivePullRequest:Bool = false\n    var body: some View{\n        VStack{\n            VStack(alignment: .leading){\n                HStack(alignment: .top) {\n                    VStack{\n                        Text(getPullRequestStatusStringShow(pullRequestItem:pullRequestItem))\n                            .foregroundColor(getPullRequestColor(pullRequestItem:pullRequestItem))\n                            .padding(.vertical,1)\n                            .padding(.horizontal,3)\n                    }\n                    .font(.system(size: 12))\n                    .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n                    .foregroundColor(.gray)\n                    .cornerRadius(3)\n                    VStack(alignment: .leading){\n                        Text(self.pullRequestItem.prTitle)\n                            .font(.system(size: 16))\n                            .lineLimit(1)\n                    }\n                    .padding(.leading,0)\n                    Spacer()\n                    Text(self.pullRequestItem.prTime)\n                        .padding(.vertical,1)\n                        .padding(.horizontal,3)\n                        .font(.system(size: 12))\n                        .foregroundColor(.gray)\n                }\n                .padding(5)\n                HStack(alignment: .center){\n                    Text(self.pullRequestItem.prBody)\n                        .font(.system(size: 14))\n                        .foregroundColor(.gray)\n                        .lineLimit(1)\n                        .padding(.top,10)\n                    Spacer()\n                }\n                HStack{\n                    VStack(alignment: .leading){\n                        Text(prFromToString)\n                            .padding(.vertical,0)\n                            .padding(.horizontal,3)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .lineLimit(1)\n                        \n                        Text(prFromToString2)\n                            .padding(.vertical,0)\n                            .padding(.horizontal,3)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .lineLimit(1)\n                    }\n                    Spacer()\n                }\n            }\n            .padding(10)\n        }\n        .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n        .cornerRadius(10)\n        .padding(.horizontal,5)\n        .sheet(isPresented: $isActivePullRequest,onDismiss: {\n        }){\n            PullRequestDetailView(pullRequestItem: $pullRequestItem).foregroundColor(.white)\n        }\n        .onTapGesture {\n            self.isActivePullRequest = true\n        }\n        .contextMenu(ContextMenu {\n            if pullRequestItem.prAutoMerge && pullRequestItem.prStatus == PullRequestStatus.open {\n                Button(action: {\n                }) {\n                    HStack{\n                        Image(systemName: \"mail.and.text.magnifyingglass\").scaleEffect(1, anchor: .center)\n                        Spacer()\n                        Text(\"审查通过\")\n                    }\n                }\n                Button(action: {\n                }) {\n                    HStack{\n                        Image(systemName: \"wrench.and.screwdriver\").scaleEffect(1, anchor: .center)\n                        Spacer()\n                        Text(\"测试通过\")\n                    }\n                }\n                Button(action: {\n                }) {\n                    HStack{\n                        Image(systemName: \"shuffle\").scaleEffect(1, anchor: .center)\n                        Spacer()\n                        Text(\"确认合并\")\n                    }\n                }\n            }\n            Divider()\n            Button(action: {\n                self.isActiveCommit = true\n            }) {\n                HStack{\n                    Image(systemName: \"icloud.and.arrow.up\").scaleEffect(1, anchor: .center)\n                    Spacer()\n                    Text(\"提交记录\")\n                }\n            }\n            .sheet(isPresented: $isActiveCommit,onDismiss: {\n            }){\n                CommitView(pullRequestItem: pullRequestItem).foregroundColor(.white)\n            }\n        })\n        .onAppear(){\n            if pullRequestItem.prFrom.repoNamespace.path == pullRequestItem.prTo.repoNamespace.path {\n                self.prFromToString = \"从 \" + pullRequestItem.prFromBranch + \"分支 到 \" + pullRequestItem.prToBranch + \"分支\"\n                self.prFromToString2 = \"这是你的自己的合并请求\"\n            }else{\n                self.prFromToString = \"从 \" + pullRequestItem.prFrom.repoNamespace.name + \"/\" + pullRequestItem.prFrom.repoName + \":\" + pullRequestItem.prFromBranch\n                self.prFromToString2 = \"到 \" + pullRequestItem.prTo.repoNamespace.name + \"/\" + pullRequestItem.prTo.repoName + \":\" + pullRequestItem.prToBranch\n            }\n        }\n    }\n}\n```\n\n### 3.5 查看Issues\n\nbody定义：\n```Swift\n var body: some View {\n    LoadingView(isLoading:self.$isLoading,message: self.$message,isModal:self.$isModal) {\n        VStack{\n            ZStack{\n                if issuesList.count == 0 && !isLoading {\n                    VStack{\n                        Image(systemName: \"doc.text.magnifyingglass\")\n                            .scaleEffect(3, anchor: .center)\n                        Text(\"暂无查询到的Issues\").padding(.top,30)\n                    }\n                }\n                RefreshView(refreshing: $isRefreshing, action: {\n                    self.page = 1\n                    self.getIssueList(page: self.page)\n                }) {\n                    LazyVStack{\n                        ForEach(self.issuesList){ item in\n                            NavigationLink(destination: IssueItemView(issueItem: item)) {\n                                IssueItemView(issueItem: item)\n                                    .onAppear(){\n                                        if !waitPlease && item.id == issuesList[issuesList.count - 1].id {\n                                            self.page = self.page + 1\n                                            self.getIssueList(page: self.page)\n                                        }\n                                    }\n                            }\n                        }\n                    }\n                }\n            }\n            if self.repoPath != \"\" {\n                Spacer()\n                HStack{\n                    Spacer()\n                    Button {\n                        self.isInserIssueShow = true\n                    } label: {\n                        Image(systemName: \"square.and.pencil\")\n                            .scaleEffect(1.2, anchor: .center)\n                    }\n                    .padding(12)\n                    .background(Color.yellow)\n                    .foregroundColor(Color.black)\n                    .cornerRadius(100)\n                    .sheet(isPresented: $isInserIssueShow) {\n                        let arr = self.repoPath.components(separatedBy: \"/\")\n                        IssueInsertView(repoNamespacePath: arr[0], repoPath: arr[1])\n                    }\n                }\n                .padding(.trailing,20)\n            }\n        }\n    }\n    .padding(.top,5)\n    .navigationBarTitle(Text(title!), displayMode: .inline)\n    .navigationBarItems(\n        trailing:\n            HStack {\n                Button(action: {\n                    self.isFilterShow.toggle()\n                }) {\n                    Image(systemName: \"rectangle.and.text.magnifyingglass\")\n                        \n                        .scaleEffect(1, anchor: .center)\n                }\n            }\n            .sheet(isPresented: $isFilterShow,onDismiss: {\n                self.isLoading = true\n                self.page = 1\n                self.getIssueList(page: self.page)\n            }){\n                IssueFilterView()\n                    .modifier(DisableModalDismiss(disabled: false))\n            }\n    )\n    .onAppear(){\n        localConfig.setValue(\"all\", forKey: giteeConfig.issue_filter)\n        localConfig.setValue(\"open\", forKey: giteeConfig.issue_state)\n        localConfig.setValue(\"created\", forKey: giteeConfig.issue_sort)\n        localConfig.setValue(\"desc\", forKey: giteeConfig.issue_direction)\n        self.page = 1\n        self.getIssueList(page: self.page)\n    }\n}\n```\n\n可见时请求列表：\n```Swift\nfunc getIssueList(page: Int){\n    if self.waitPlease { return }\n    self.waitPlease = true\n    if issuesList.count == 0 {\n        self.isLoading = true\n    }\n    let state = localConfig.string(forKey: giteeConfig.issue_state)\n    let filter = localConfig.string(forKey: giteeConfig.issue_filter)\n    let direction = localConfig.string(forKey: giteeConfig.issue_direction)\n    let sort = localConfig.string(forKey: giteeConfig.issue_sort)\n    var url = \"user/issues?page=\" + String(page)\n    \n    if self.repoPath != \"\" {\n        url = \"repos/\" + self.repoPath + \"/issues?page=\" + String(page)\n    }\n    \n    url = url + \"&state=\" + state!\n    url = url + \"&filter=\" + filter!\n    url = url + \"&direction=\" + direction!\n    url = url + \"&sort=\" + sort!\n    \n    \n    HttpRequest(url: url, withAccessToken: true)\n        .doGet { (value) in\n            let json = JSON(value)\n            if json[\"message\"].string != nil {\n                print(\"error\")\n                DispatchQueue.main.async {\n                    UIAlertController.confirm(message: json[\"message\"].stringValue, title: \"发生错误\", confirmText: \"重新登录\", cancelText: \"返回\") { (action) in\n                        Helper.relogin()\n                    }\n                }\n            }else{\n                var tempList = self.issuesList\n                if page == 1{\n                    tempList = []\n                }\n                for (_,subJson):(String, JSON) in json {\n                    let repoNamespace = RepoNamespace(id: Int(subJson[\"repository\"][\"namespace\"][\"id\"].stringValue)!, name: String(subJson[\"repository\"][\"namespace\"][\"name\"].stringValue), path:  String(subJson[\"repository\"][\"namespace\"][\"path\"].stringValue))\n                    let repoInfo = RepoModel(id: Int(subJson[\"repository\"][\"id\"].stringValue)!, repoName: String(subJson[\"repository\"][\"name\"].stringValue),repoPath:  String(subJson[\"repository\"][\"path\"].stringValue),repoNamespace: repoNamespace, repoDesc:  String(subJson[\"repository\"][\"description\"].stringValue), repoForks:  String(subJson[\"repository\"][\"forks_count\"].stringValue), repoStars:  String(subJson[\"repository\"][\"stargazers_count\"].stringValue), repoWatches:  String(subJson[\"repository\"][\"watchers_count\"].stringValue), repoLicense:  String(subJson[\"repository\"][\"license\"].stringValue), repoLanguage:  String(subJson[\"repository\"][\"language\"].stringValue), repoPushDate:  String(subJson[\"repository\"][\"pushed_at\"].stringValue), repoIsFork:  Bool(subJson[\"repository\"][\"fork\"].boolValue), repoIsOpenSource:  Bool(subJson[\"repository\"][\"public\"].boolValue), repoIssues:  String(subJson[\"repository\"][\"open_issues_count\"].stringValue), repoDefaultBranch:  String(subJson[\"repository\"][\"default_branch\"].stringValue))\n                    let userInfo = UserItemModel(id: Int(subJson[\"user\"][\"id\"].stringValue)!, userHead: String(subJson[\"user\"][\"avatar_url\"].stringValue), userName: String(subJson[\"user\"][\"name\"].stringValue), userAccount: String(subJson[\"user\"][\"login\"].stringValue))\n                    let issueInfo = IssueModel(id: Int(subJson[\"id\"].stringValue)!, issueId: String(subJson[\"number\"].stringValue), issueTitle: String(subJson[\"title\"].stringValue), issueTime: Helper.getDateFromString(str: String(subJson[\"created_at\"].stringValue)), issueDesc: String(subJson[\"body\"].stringValue), issueStatus: getIssueStatus(status: subJson[\"state\"].stringValue), repoInfo:repoInfo, userInfo: userInfo)\n                    tempList.append(\n                        issueInfo\n                    )\n                }\n                self.issuesList = tempList\n            }\n            self.isRefreshing = false\n            self.isLoading = false\n            self.waitPlease = false\n        } errorCallback: {\n            self.isRefreshing = false\n            self.isLoading = false\n            self.waitPlease = false\n            \n        }\n}\n```\n\n最后就是具体的IssueItemView了。\n```Swift\nstruct IssueItemView:View{\n    @State var issueItem: IssueModel\n    @State private var isActiveIsssueDetail:Bool = false\n    @State private var isActiveRepoDetail:Bool = false\n    var body: some View{\n        ZStack{\n            VStack{\n                NavigationLink(destination: RepoDetailView(repoFullPath: issueItem.repoInfo.repoNamespace.path + \"/\" + issueItem.repoInfo.repoPath), isActive: $isActiveRepoDetail) { EmptyView() }\n            }\n            .frame(width: 0, height: 0)\n            .opacity(0)\n            VStack{\n                VStack(alignment: .leading){\n                    HStack(alignment: .top) {\n                        Image(systemName:getIssueIcon(status: issueItem.issueStatus))\n                            .scaleEffect(1, anchor: .center)\n                            .foregroundColor(getIssueColor(status: issueItem.issueStatus))\n                        VStack(alignment: .leading){\n                            Text(issueItem.issueTitle)\n                                .font(.system(size: 16))\n                                .lineLimit(1)\n                        }\n                        Spacer()\n                        Text(issueItem.issueTime)\n                            .padding(.vertical,1)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                        \n                    }\n                    .padding(5)\n                    HStack{\n                        Text(issueItem.repoInfo.repoName)\n                            .padding(.leading,35)\n                            .font(.system(size: 12))\n                            .foregroundColor(Color(hex: 0xCCCCCC))\n                        Text(issueItem.issueDesc)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .lineLimit(1)\n                    }\n                    HStack{\n                        Image(systemName:\"person.circle\")\n                            .scaleEffect(0.7, anchor: .center)\n                            .foregroundColor(.gray)\n                            .padding(.leading,30)\n                        Text(issueItem.userInfo.userName)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .padding(.leading,-8)\n                        Spacer()\n                    }\n                    .padding(.top,5)\n                }\n                .padding(10)\n            }\n            .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n            .cornerRadius(10)\n            .padding(.horizontal,5)\n            .padding(.bottom,-3)\n            .sheet(isPresented: self.$isActiveIsssueDetail) {\n                self.reloadIssue()\n            } content: {\n                IssuesDetailView(issueItem: $issueItem)\n                    .foregroundColor(.white)\n            }\n            .onTapGesture {\n                self.isActiveIsssueDetail = true\n            }\n            .contextMenu(ContextMenu {\n                if issueItem.issueStatus != IssueStatus.open {\n                    Button(action: {\n                        self.changeIssueStatus(issueItem: issueItem,  issueStatus: IssueStatus.open)\n                    }) {\n                        HStack{\n                            Image(systemName: \"moon.circle\").scaleEffect(1, anchor: .center)\n                            Spacer()\n                            Text(\"标记为已开启\")\n                        }\n                    }\n                }\n                if issueItem.issueStatus != IssueStatus.progressing {\n                    Button(action: {\n                        self.changeIssueStatus(issueItem: issueItem,  issueStatus: IssueStatus.progressing)\n                    }) {\n                        HStack{\n                            Image(systemName: \"timer\").scaleEffect(1, anchor: .center)\n                            Spacer()\n                            Text(\"标记为进行中\")\n                        }\n                    }\n                }\n                if issueItem.issueStatus != IssueStatus.rejected {\n                    Button(action: {\n                        UIAlertController.alert(message: \"请期待Gitee开放这个API吧~\", title: \"即将上线\", confirmText: \"安排\")\n                    }) {\n                        HStack{\n                            Image(systemName: \"xmark.circle\").scaleEffect(1, anchor: .center)\n                            Spacer()\n                            Text(\"标记为已拒绝\")\n                        }\n                    }\n                }\n                if issueItem.issueStatus != IssueStatus.closed {\n                    Button(action: {\n                        self.changeIssueStatus(issueItem: issueItem, issueStatus: IssueStatus.closed)\n                    }) {\n                        HStack{\n                            Image(systemName: \"checkmark.circle\").scaleEffect(1, anchor: .center)\n                            Spacer()\n                            Text(\"标记为完成\")\n                        }\n                    }\n                }\n                Divider()\n                Button(action: {\n                    self.isActiveRepoDetail = true\n                }) {\n                    HStack{\n                        Image(systemName: \"archivebox.circle\").scaleEffect(1, anchor: .center)\n                        Spacer()\n                        Text(\"进入所属仓库\")\n                    }\n                }\n            })\n        }\n    }\n```\n\n## 4 总结\n\n* 这里学会了Swift初始化配置，可以简化其它流程，只需要继承App类。\n\n* 然后这里学会使用类似Flutter的组件，HStack,VStack,ZSack，Spacer,Text，Image这一类基础组件。\n\n* 网络请求的最好自己封装一个HttpRequest类，动态配置各种参数。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/iOS-swift-Gitee客户端-完整项目分析之一.md","raw":"---\ntitle: iOS swift Gitee客户端 完整项目分析之一\ndate: 2023-02-06 14:47:06\nop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- 完整项目 SwiftUI\ncategories:\n- iOS\n---\n\n## 1 项目地址\n> [https://gitee.com/open-gitee/gitee_ios](https://gitee.com/open-gitee/gitee_ios) \nGitee基于SwiftUI和OpenApi的iOS客户端项目。\n\n## 2 项目截图\n||||\n|--|--|--|\n| <img src=1.png> | <img src=2.png> | <img src=3.png> |\n| <img src=4.png> | <img src=5.png> | <img src=6.png> |\n\n## 3 首页架构\n\n这里是底部3个Tab，首页展示一个工作台消息中心，你的团队的入库。应该是写死的布局。\n\n第二个tab是好友动态，这里展示一个列表，展示动态列表。\n\n第三个tab是设置页，上方是头像，然后是关注粉丝star啥的。\n\n关于App和Scene代码结构，可以参考这篇文章：\n[SwiftUI2.0 —— App、Scene及新的代码结构（一）](https://zhuanlan.zhihu.com/p/152624613)。\n\n应用初始化代码：\n```Swift\n@main\nstruct GiteeApp: App {\n    var body: some Scene {\n        WindowGroup {\n            TabBarView(selectedBarIndex: 0)\n                .preferredColorScheme(.dark)\n        }\n    }\n}\n```\n这里body就是首页了。\nApp，Scene，WindowGroup都是系统类。\n\n里面的TabBarView是自定义View来的：\n```Swift\nstruct TabBarView: View {\n    @State var selectedBarIndex:Int\n    \n    var body: some View {\n        NavigationView{\n            TabView(selection: $selectedBarIndex) {\n                HomeView()\n                .tabItem {\n                    Image(systemName:\"briefcase\")\n                    Text(\"首页\")\n                }\n                    .tag(0)\n                ActivityView()\n                .tabItem {\n                    Image(systemName:\"stopwatch\")\n                    Text(\"动态\")\n                }\n                    .tag(1)\n//                ExploreView()\n//                .tabItem {\n//                    Image(systemName:\"opticaldisc\")\n//                    Text(\"发现\")\n//                }\n//                    .tag(2)\n                SettingView()\n                .tabItem {\n                    Image(systemName:\"gearshape\")\n                    Text(\"设置\")\n                }\n                    .tag(3)\n            }\n            .navigationBarTitle(getNavBarTitle(),displayMode: getNavBarModel())\n            .navigationBarHidden(self.selectedBarIndex==3)\n            .foregroundColor(.white)\n            .accentColor(.white) //这里修改文字颜色\n        }\n        .navigationViewStyle(StackNavigationViewStyle())\n        .accentColor(.white)\n        .foregroundColor(.white)\n        .preferredColorScheme(.dark)\n    }\n```\n这里TabView其实就是定义的底部Tab，然后item点击后是配置在中间的。\n比如HomeView就是首页了，ActivityView应该就是动态页了，SettingView就是设置页了。\n\n```Swift\n\nfunc getNavBarModel() -> NavigationBarItem.TitleDisplayMode{\n    if self.selectedBarIndex == 0 {\n        return .large\n    }\n    if self.selectedBarIndex == 1 {\n        return .inline\n    }\n    if self.selectedBarIndex == 2 {\n        return .large\n    }\n    if self.selectedBarIndex == 3 {\n        return .large\n    }\n    return .inline\n}\nfunc getNavBarTitle() -> String{\n    if self.selectedBarIndex == 0 {\n        return \"Gitee\"\n    }\n    if self.selectedBarIndex == 1 {\n        return \"好友动态\"\n    }\n    if self.selectedBarIndex == 2 {\n        return \"发现\"\n    }\n    if self.selectedBarIndex == 3{\n        return \"设置\"\n    }\n    return  \"\"\n}\n```\n这里配置tab具体数据。\n![](./iOS-swift-Gitee%E5%AE%A2%E6%88%B7%E7%AB%AF-%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%80/tab1.png)\n<img src=tab1.png>\n这里Form是表格。\nSection是组别。\n这里有一个NavigationLink是item1就是第一个item，这里显示代码仓库。颜色和icon都可以设置的。\n\n 但是这里的HomeListItem是自己定义的哦。\n ```Swift\nstruct HomeListItem : View {\n    @State var title: String\n    @State var icon: String\n    @State var color: Color\n    \n    var body: some View {\n        HStack(spacing: 15){\n            Image(systemName:icon)\n                .scaleEffect(1.5, anchor: .center)\n                .foregroundColor(color)\n            Text(title).font(.system(size:16))\n        }\n        .padding(.horizontal, 5)\n        .frame( height: 48)\n        .cornerRadius(10)\n    }\n}\n ```\n\n这个HStack是系统的，估计类似于Flutter里面的Stack吧。\n这里右侧箭头是咋来的呢？\n原来是\n```Swift\nvar body: some View {\n    Form {\n        Section(header: Text(\"工作台\")) {\n            NavigationLink(destination: RepoView()) {\n                HomeListItem(title: \"代码仓库\",icon:\"archivebox.circle\", color: Color(hex: 0x7699ec))\n            }\n//                NavigationLink(destination:  PullRequestView()) {\n//                    HomeListItem(title: \"Pull Request\",icon:\"shuffle.circle\", color: Color(hex: 0x00b392))\n//                }\n            NavigationLink(destination:  IssuesView()) {\n                HomeListItem(title: \"Issues\",icon:\"exclamationmark.circle\", color: Color(hex: 0xfe665b))\n            }\n        }\n```\n这里面的NavigationLink自带的箭头哦。\n\n### 3.2 仓库页面\n前面用了一个NavigationLink包裹，那么点击这个之后应该是跳转到目标页面。\n\n这里是先跳转到你的仓库页面。\n先看看哈：\n```Swift\nvar body: some View {\n    LoadingView(isLoading:self.$isLoading,message: self.$message,isModal:self.$isModal) {\n        ZStack{\n            if repoList.count == 0 && !isLoading {\n                VStack{\n                    Image(systemName: \"doc.text.magnifyingglass\")\n                        .scaleEffect(3, anchor: .center)\n                    Text(\"暂无查询到的仓库\").padding(.top,30)\n                }\n            }\n            RefreshView(refreshing: $isRefreshing, action: {\n                self.page = 1\n                self.getRepoList(page: self.page)\n            }) {\n                LazyVStack{\n                    ForEach(self.repoList){ item in\n                        NavigationLink(destination: RepoDetailView(repoFullPath: item.repoNamespace.path + \"/\" + item.repoPath)) {\n                            RepoItemView(repoItem: item)\n                                .onAppear(){\n                                    if !waitPlease && item.id == repoList[repoList.count - 1].id {\n                                        self.page = self.page + 1\n                                        self.getRepoList(page: self.page)\n                                    }\n                                }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    .sheet(isPresented: $isLoginShow,onDismiss: {\n        UserModel().getMyInfo { (userInfo) in\n            self.page = 1\n            self.getRepoList(page: self.page)\n        } error: {\n            self.isLoginShow.toggle()\n        }\n    }){\n        LoginView()\n            .modifier(DisableModalDismiss(disabled: true))\n    }\n    .padding(.top,5)\n    .navigationBarTitle(Text(naviTitle), displayMode: .inline)\n    .navigationBarItems(\n        trailing:\n            HStack {\n                Button(action: {\n                    self.isFilterShow.toggle()\n                }) {\n                    Image(systemName: \"rectangle.and.text.magnifyingglass\")\n                        \n                        .scaleEffect(1, anchor: .center)\n                }\n            }\n            .sheet(isPresented: $isFilterShow,onDismiss: {\n                self.isLoading = true\n                self.page = 1\n                self.getRepoList(page: self.page)\n            }){\n                RepoFilterView(showListFrom: self.showListFrom)\n                    .modifier(DisableModalDismiss(disabled: false))\n            }\n    )\n    .onAppear(){\n        switch self.showListFrom {\n        case ShowRepoListFrom.fromWatches:\n            self.naviTitle = \"Watch的仓库\"\n        case ShowRepoListFrom.fromStars:\n            self.naviTitle = \"Star的仓库\"\n        default:\n            self.naviTitle = \"你的仓库\"\n        }\n        \n        localConfig.setValue(\"all\", forKey: giteeConfig.repo_type)\n        localConfig.setValue(\"pushed\", forKey: giteeConfig.repo_sort)\n        localConfig.setValue(\"desc\", forKey: giteeConfig.repo_direction)\n        self.page = 1\n        self.getRepoList( page: self.page)\n    }\n}\n```\n\nloading视图：\n```Swift\nstruct LoadingView<Content>: View where Content: View {\n    \n    @Binding var isLoading: Bool\n    @Binding var message:String\n    @Binding var isModal: Bool\n    @State var isAnimating: Bool = true\n    var content: () -> Content\n    \n    var body: some View {\n        GeometryReader { geometry in\n            ZStack(alignment: .center) {\n                self.content()\n                    .disabled(self.isModal)\n                    .blur(radius: self.isModal ? 10 : 0)\n                VStack {\n                    Text(self.message)\n                        .padding(.bottom,20)\n                    ActivityIndicatorLoading(isAnimating: self.$isAnimating, style: .large)\n                }\n                    \n                .frame(width: geometry.size.width / 2,\n                       height: geometry.size.height / 5)\n                    .background(Color.secondary.colorInvert())\n                    .foregroundColor(Color.primary)\n                    .cornerRadius(20)\n                    .opacity(self.isLoading ? 1 : 0)\n            }\n        }\n    }\n}\n```\n这里的Loading效果是ActivityIndicatorLoading这个实现的。这个是自定义的哦。\n继续走这个：\n```Swift\nstruct ActivityIndicatorLoading: UIViewRepresentable {\n    \n    @Binding var isAnimating: Bool\n    let style: UIActivityIndicatorView.Style\n    \n    func makeUIView(context: UIViewRepresentableContext<ActivityIndicatorLoading>) -> UIActivityIndicatorView {\n        return UIActivityIndicatorView(style: style)\n    }\n    \n    func updateUIView(_ uiView: UIActivityIndicatorView, context: UIViewRepresentableContext<ActivityIndicatorLoading>) {\n        isAnimating ? uiView.startAnimating() : uiView.stopAnimating()\n    }\n}\n```\n原来是UIActivityIndicatorView这个类来实现loading效果的。\n\n然后这里有个自定义刷新视图。\n可以参考下这篇文章：[https://swiftui-lab.com/scrollview-pull-to-refresh/](https://swiftui-lab.com/scrollview-pull-to-refresh/)。\n\n```Swift\nLazyVStack{\n    ForEach(self.repoList){ item in\n        NavigationLink(destination: RepoDetailView(repoFullPath: item.repoNamespace.path + \"/\" + item.repoPath)) {\n            RepoItemView(repoItem: item)\n                .onAppear(){\n                    if !waitPlease && item.id == repoList[repoList.count - 1].id {\n                        self.page = self.page + 1\n                        self.getRepoList(page: self.page)\n                    }\n                }\n        }\n    }\n}\n```\n这里就是刷新器里面展示列表。\n\n列表的item是这个RepoItemView:\n```Swift\nstruct RepoItemView:View{\n    @State var repoItem: RepoModel\n    @State private var isActiveCommit:Bool = false\n    @State private var isActivePullRequest:Bool = false\n    @State private var isActiveIssues:Bool = false\n    \n    var body: some View{\n        VStack{\n            VStack{\n                NavigationLink(destination: CommitView(repoFullPath: repoItem.repoNamespace.path + \"/\" + repoItem.repoPath,repoDefaultBranch: repoItem.repoDefaultBranch), isActive: $isActiveCommit) { EmptyView() }\n                NavigationLink(destination: PullRequestView(repoFullPath: repoItem.repoNamespace.path + \"/\" + repoItem.repoPath), isActive: $isActivePullRequest) { EmptyView() }\n                NavigationLink(destination: IssuesView(repoPath: repoItem.repoNamespace.path + \"/\" + repoItem.repoPath),isActive: $isActiveIssues) { EmptyView() }\n            }\n            .frame(width: 0, height: 0)\n            .opacity(0)\n            VStack(alignment: .leading){\n                HStack(alignment: .top) {\n                    if !self.repoItem.repoIsOpenSource {\n                        Image(systemName: \"lock.square.fill\")\n                            .foregroundColor(Color(hex: 0xffc55a))\n                            .padding(.trailing,-5)\n                            .scaleEffect(1, anchor: .center)\n                    }\n                    VStack(alignment: .leading){\n                        Text(self.repoItem.repoNamespace.name + \"/\" + self.repoItem.repoName)\n                            .font(.system(size: 16))\n                            .lineLimit(1)\n                    }\n                    Spacer()\n                    Text(self.repoItem.repoPushDate)\n                        .font(.system(size: 12))\n                        .foregroundColor(.gray)\n                    \n                }\n                .padding(5)\n                Text(self.repoItem.repoDesc == \"\" ? \"很尴尬,该项目暂无介绍...\" : self.repoItem.repoDesc)\n                    .font(.system(size: 14))\n                    .foregroundColor(.gray)\n                    .lineLimit(3)\n                    .multilineTextAlignment(.leading)\n                    .padding(.top,10)\n                    .padding(.leading,5)\n                    .fixedSize(horizontal: false, vertical: true)\n                Spacer()\n                HStack{\n                    if self.repoItem.repoLanguage != \"\" {\n                        VStack{\n                            Text(self.repoItem.repoLanguage)\n                                .padding(.vertical,1)\n                                .padding(.horizontal,3)\n                        }\n                        .font(.system(size: 12))\n                        .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n                        .foregroundColor(.gray)\n                        .cornerRadius(3)\n                    }\n                    if self.repoItem.repoLicense != \"\" {\n                        VStack{\n                            Text(self.repoItem.repoLicense)\n                                .padding(.vertical,1)\n                                .padding(.horizontal,3)\n                        }\n                        .font(.system(size: 12))\n                        .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n                        .foregroundColor(.gray)\n                        .cornerRadius(3)\n                    }\n                    Spacer()\n                    HStack{\n                        Image(systemName: \"star.fill\")\n                            .foregroundColor(.gray)\n                            .scaleEffect(0.6, anchor: .center)\n                            .padding(0)\n                        Text(self.repoItem.repoStars)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .padding(0)\n                            .padding(.leading,-12)\n                    }\n                    HStack{\n                        Image(systemName: \"eye.fill\")\n                            .foregroundColor(.gray)\n                            .scaleEffect(0.6, anchor: .center)\n                            .padding(0)\n                        Text(self.repoItem.repoWatches)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .padding(0)\n                            .padding(.leading,-12)\n                    }\n                    .padding(.horizontal,-8)\n                    HStack{\n                        Image(systemName: \"arrowshape.turn.up.backward.2.fill\")\n                            .foregroundColor(.gray)\n                            .scaleEffect(0.7, anchor: .center)\n                            .padding(0)\n                        Text(self.repoItem.repoForks)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .padding(0)\n                            .padding(.leading,-12)\n                    }\n                }\n                .padding(.top,5)\n            }\n            .padding(10)\n        }\n        .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n        .cornerRadius(10)\n        .padding(.horizontal,5)\n        .padding(.bottom,5)\n        //        .swipeCell(\n        //            cellPosition: .both,\n        //            leftSlot: nil,\n        //            rightSlot: SwipeCellSlot(\n        //                slots:\n        //                    [\n        //                        SwipeCellButton(\n        //                            buttonStyle: .titleAndImage,\n        //                            title: \"Mark\",\n        //                            systemImage: \"bookmark\",\n        //                            titleColor: .white,\n        //                            imageColor: .white,\n        //                            view: nil,\n        //                            backgroundColor: .green,\n        //                            action: {\n        //                                print(\"123\")\n        //                            },\n        //                            feedback:true\n        //                        )\n        //                    ]\n        //            )\n        //        )\n        .contextMenu(ContextMenu {\n            Button(action: {\n                self.isActiveCommit = true\n            }) {\n                HStack{\n                    Image(systemName: \"icloud.and.arrow.up\").scaleEffect(1, anchor: .center)\n                    Spacer()\n                    Text(\"提交记录\")\n                }\n            }\n            Divider()\n            Button(action: {\n                self.isActivePullRequest = true\n            }) {\n                HStack{\n                    Image(systemName: \"shuffle.circle\").scaleEffect(1, anchor: .center)\n                    Spacer()\n                    Text(\"Pull Requests\")\n                }\n            }\n            Button(action: {\n                self.isActiveIssues = true\n            }) {\n                HStack{\n                    Image(systemName: \"exclamationmark.circle\").scaleEffect(1, anchor: .center)\n                    Spacer()\n                    Text(\"查看Issues\")\n                }\n            }\n        })\n    }\n}\n```\n\n长按会弹出菜单，提交记录，Pull Requests Issues都是菜单项。\n注意到这里的菜单是一个Button，里面配置了action，然后在顶部配置了NavigationLink，实现跳转。\n\n### 3.3 提交记录 \n\n比如点击了提交记录：\n这里显示body:\n```Swift\nvar body: some View {\n    LoadingView(isLoading:self.$isLoading,message: self.$message,isModal:self.$isModal) {\n        ZStack{\n            if commitList.count == 0 && !isLoading {\n                VStack{\n                    Image(systemName: \"doc.text.magnifyingglass\")\n                        .scaleEffect(3, anchor: .center)\n                    Text(\"暂无查询到的提交\").padding(.top,30)\n                }\n            }\n            RefreshView(refreshing: $isRefreshing, action: {\n                self.page = 1\n                self.getCommitList(page: self.page)\n            }) {\n                LazyVStack{\n                    ForEach(self.commitList){ item in\n                        CommitItemView(commitItem: item, repoFullPath: self.repoFullPath!)\n                            .onAppear(){\n                                if !waitPlease && item.id == commitList[commitList.count - 1].id {\n                                    self.page = self.page + 1\n                                    self.getCommitList(page: self.page)\n                                }\n                            }\n                    }\n                }\n            }\n        }\n        .padding(.top,5)\n        .navigationBarTitle(Text(self.showCommitFrom == CommitFromModel.fromRepo ? branch : \"包含的提交\"), displayMode: .inline)\n        .navigationBarItems(\n            trailing:\n                HStack {\n                    if self.showCommitFrom == CommitFromModel.fromRepo{\n                        Button {\n                        } label: {\n                            Menu {\n                                ForEach (0 ..< self.branchList.count, id: \\.self) {index in\n                                    Button(self.branchList[index], action: {\n                                        self.branch = self.branchList[index]\n                                        self.page = 1\n                                        self.isLoading = true\n                                        self.getCommitList(page: self.page)\n                                    })\n                                }\n                            } label: {\n                                VStack{\n                                    Text(\"分支\").foregroundColor(.yellow)\n                                }\n                            }\n                        }\n                    }\n                }\n        )\n        .onAppear(){\n            if self.showCommitFrom == CommitFromModel.fromRepo{\n                self.branch = self.repoDefaultBranch!\n            }else{\n                self.branch = \"master\"\n            }\n            self.page = 1\n            self.getCommitList( page: self.page)\n            self.getBranchList()\n        }\n    }\n}\n```\n\nonAppear的时候，走接口。\n```Swift\n func getCommitList(page: Int){\n        if self.waitPlease { return }\n        self.waitPlease = true\n        if commitList.count == 0 {\n            self.isLoading = true\n        }\n        var url = \"repos/\"\n        if self.showCommitFrom == CommitFromModel.fromRepo{\n            url = url + self.repoFullPath! + \"/commits?page=\" + String(page)\n            url = url + \"&sha=\" + self.branch\n        }else if self.showCommitFrom == CommitFromModel.fromPullRequest{\n            url = url + (self.pullRequestItem?.prTo.repoNamespace.path)! + \"/\"\n            url = url + (self.pullRequestItem?.prTo.repoPath)! + \"/pulls/\"\n            url = url + String(self.pullRequestItem!.prId) + \"/commits\";\n        }\n        \n        HttpRequest(url: url, withAccessToken: true)\n            .doGet { (value) in\n                let json = JSON(value)\n                if json[\"message\"].string != nil {\n                    print(\"error\")\n                    DispatchQueue.main.async {\n                        UIAlertController.confirm(message: json[\"message\"].stringValue, title: \"发生错误\", confirmText: \"重新登录\", cancelText: \"返回\") { (action) in\n                            Helper.relogin()\n                        }\n                    }\n                }else{\n                    var tempList = self.commitList\n                    if page == 1{\n                        tempList = []\n                    }\n                    for (_,subJson):(String, JSON) in json {\n                        let author = subJson[\"commit\"][\"author\"][\"name\"].stringValue\n                        let userInfo = UserItemModel(id: Int(subJson[\"author\"][\"id\"].intValue), userHead: String(subJson[\"author\"][\"avatar_url\"].stringValue), userName: String(subJson[\"author\"][\"name\"].stringValue), userAccount: String(subJson[\"author\"][\"login\"].stringValue))\n                        tempList.append(CommitModel(id: subJson[\"sha\"].stringValue, sha: String(subJson[\"sha\"].stringValue), author: author, commitTime: String(subJson[\"commit\"][\"author\"][\"date\"].stringValue), message: String(subJson[\"commit\"][\"message\"].stringValue), addCount:  String(subJson[\"stats\"][\"additions\"].stringValue), deleteCount: String(subJson[\"stats\"][\"deletions\"].stringValue), totalCount: String(subJson[\"stats\"][\"total\"].stringValue), user: userInfo))\n                    }\n                    self.commitList = tempList\n                }\n                self.isRefreshing = false\n                self.isLoading = false\n                self.waitPlease = false\n            } errorCallback: {\n                self.isRefreshing = false\n                self.isLoading = false\n                self.waitPlease = false\n            }\n    }\n```\n\n这里获取分支：\n```Swift\nfunc getBranchList(){\n        var url = \"repos/\"\n        url = url + self.repoFullPath! + \"/branches\";\n        HttpRequest(url: url, withAccessToken: true)\n            .doGet { (value) in\n                let json = JSON(value)\n                if json[\"message\"].string != nil {\n                    DispatchQueue.main.async {\n                        UIAlertController.confirm(message: json[\"message\"].stringValue, title: \"发生错误\", confirmText: \"重新登录\", cancelText: \"返回\") { (action) in\n                            Helper.relogin()\n                        }\n                    }\n                }else{\n                    if page == 1{\n                        branchList = []\n                    }\n                    for (_,subJson):(String, JSON) in json {\n                        branchList.append(subJson[\"name\"].stringValue)\n                    }\n                }\n            } errorCallback: {\n                \n            }\n    }\n```\n\n注意到分支列表里面用了分支的item：\n```Swift\nstruct CommitItemView:View{\n    @State var commitItem: CommitModel\n    @State var repoFullPath: String\n    @State var userHead:UIImage? = nil\n    let placeholderImage = UIImage(named: \"nohead\")!\n    @State var isCommitChangeShow: Bool = false\n    \n    var body: some View{\n        VStack{\n            VStack(alignment: .leading){\n                VStack(alignment: .leading){\n                    HStack(alignment: .top) {\n                        Image(uiImage: self.userHead ?? placeholderImage)\n                            .resizable()\n                            .scaledToFit()\n                            .frame(\n                                width:20,height:20,\n                                alignment: .center\n                            )\n                            .cornerRadius(5)\n                            .onAppear(){\n                                guard let url = URL(string: commitItem.user.userHead) else {\n                                    return\n                                }\n                                URLSession.shared.dataTask(with: url) { (data, response, error) in\n                                    if let data = data, let image = UIImage(data: data) {\n                                        self.userHead = image\n                                    }\n                                }.resume()\n                            }\n                        VStack(alignment: .leading){\n                            Text(commitItem.message)\n                                .font(.system(size: 16))\n                                .lineLimit(1)\n                        }\n                        Spacer()\n                        Text(\"+\" + commitItem.addCount).foregroundColor(.green).font(.system(size:14)).fontWeight(.bold).padding(.leading,0)\n                        Text(\"-\" + commitItem.deleteCount).foregroundColor(.red).font(.system(size:14)).fontWeight(.bold).padding(.leading,0)\n                        \n                    }\n                }\n                .padding(.vertical,5)\n                HStack{\n                    Text(Helper.getDateFromString(str: commitItem.commitTime)).font(.system(size:14)).foregroundColor(.gray)\n                    Text(\"由 \").font(.system(size:14)).foregroundColor(.gray).padding(.leading,-5)\n                    Text(commitItem.author + \"(\" + commitItem.user.userAccount + \")\").font(.system(size:14)).foregroundColor(Color(hex: 0xaaaaaa)).padding(.leading,0).padding(.leading,-5)\n                    Text(\" 提交\").font(.system(size:14)).foregroundColor(.gray).padding(.leading,0).padding(.leading,-5)\n                    Spacer()\n                }\n            }\n            .padding(10)\n        }\n        .onTapGesture {\n            self.isCommitChangeShow = true\n        }\n        .sheet(isPresented: $isCommitChangeShow,onDismiss: {\n            \n        }){\n            CommitChangesView(sha: self.commitItem.sha, repoFullPath:\n                                self.repoFullPath)\n        }\n        .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n        .cornerRadius(10)\n        .padding(.horizontal,5)\n        .padding(.bottom,-5)\n    }\n}\n```\n\n### 3.4 Pull Request\n\n整个body定义：\n```Swift\nvar body: some View {\n    LoadingView(isLoading:self.$isLoading,message: self.$message,isModal:self.$isModal) {\n        ZStack{\n            if pullRequestList.count == 0 && !isLoading {\n                VStack{\n                    Image(systemName: \"doc.text.magnifyingglass\")\n                        .scaleEffect(3, anchor: .center)\n                    Text(\"暂无查询到的Pull Requests\").padding(.top,30)\n                }\n            }\n            RefreshView(refreshing: $isRefreshing, action: {\n                self.page = 1\n                self.getPullRequestList(page: self.page)\n            }) {\n                LazyVStack{\n                    ForEach(self.pullRequestList){ item in\n                        PullRequestItemView(pullRequestItem: item)\n                            .onAppear(){\n                                if !waitPlease && item.id == pullRequestList[pullRequestList.count - 1].id {\n                                    self.page = self.page + 1\n                                    self.getPullRequestList(page: self.page)\n                                }\n                            }\n                    }\n                }\n            }\n        }\n    }\n    .navigationBarTitle(Text(\"Pull Requests\"), displayMode: .inline)\n    .navigationBarItems(trailing:\n                            HStack {\n                                Button(action: {\n                                    self.isFilterShow.toggle()\n                                }) {\n                                    Image(systemName: \"rectangle.and.text.magnifyingglass\")\n                                        \n                                        .scaleEffect(1, anchor: .center)\n                                }\n                            }\n                            .sheet(isPresented: $isFilterShow,onDismiss: {\n                                self.isLoading = true\n                                self.page = 1\n                                self.getPullRequestList(page: self.page)\n                            }){\n                                PullRequestFilterView()\n                                    .modifier(DisableModalDismiss(disabled: false))\n                            }\n    )\n    .onAppear(){\n        localConfig.setValue(\"open\", forKey: giteeConfig.pull_request_state)\n        localConfig.setValue(\"updated\", forKey: giteeConfig.pull_request_sort)\n        localConfig.setValue(\"desc\", forKey: giteeConfig.pull_request_direction)\n        self.page = 1\n        self.getPullRequestList( page: self.page)\n    }\n}\n```\n\n可见时请求接口：\n```Swift\nfunc getPullRequestList(page: Int){\n    if self.waitPlease { return }\n    self.waitPlease = true\n    if pullRequestList.count == 0 {\n        self.isLoading = true\n    }\n    let state = localConfig.string(forKey: giteeConfig.pull_request_state)\n    let sort = localConfig.string(forKey: giteeConfig.pull_request_sort)\n    let direction = localConfig.string(forKey: giteeConfig.pull_request_direction)\n    var url = \"repos/\"\n    url = url + self.repoFullPath + \"/pulls?page=\" + String(page);\n    \n    url = url + \"&state=\" + state!\n    url = url + \"&sort=\" + sort!\n    url = url + \"&direction=\" + direction!\n    \n    \n    HttpRequest(url: url, withAccessToken: true)\n        .doGet { (value) in\n            let json = JSON(value)\n            if json[\"message\"].string != nil {\n                print(\"error\")\n                DispatchQueue.main.async {\n                    UIAlertController.confirm(message: json[\"message\"].stringValue, title: \"发生错误\", confirmText: \"重新登录\", cancelText: \"返回\") { (action) in\n                        Helper.relogin()\n                    }\n                }\n            }else{\n                var tempList = self.pullRequestList\n                if page == 1{\n                    tempList = []\n                }\n                for (_,subJson):(String, JSON) in json {\n                    let userInfo = UserItemModel(id: Int(subJson[\"user\"][\"id\"].intValue), userHead: String(subJson[\"user\"][\"avatar_url\"].stringValue), userName: String(subJson[\"user\"][\"name\"].stringValue), userAccount: String(subJson[\"user\"][\"login\"].stringValue))\n                    \n                    let fromRepo = RepoModel(id: Int(subJson[\"head\"][\"repo\"][\"id\"].intValue), repoName: String(subJson[\"head\"][\"repo\"][\"name\"].stringValue), repoPath: String(subJson[\"head\"][\"repo\"][\"path\"].stringValue), repoNamespace: RepoNamespace(id: Int(subJson[\"head\"][\"repo\"][\"namespace\"][\"id\"].intValue), name: String(subJson[\"head\"][\"repo\"][\"namespace\"][\"name\"].stringValue), path: String(subJson[\"head\"][\"repo\"][\"namespace\"][\"path\"].stringValue)), repoDesc: String(subJson[\"head\"][\"repo\"][\"description\"].stringValue), repoForks: \"\", repoStars: \"\",repoWatches:\"\", repoLicense:\"\", repoLanguage: \"\", repoPushDate:\"\", repoIsFork: false, repoIsOpenSource: Bool(subJson[\"head\"][\"repo\"][\"public\"].boolValue), repoIssues:\"\", repoDefaultBranch:\"\")\n                    \n                    let toRepo = RepoModel(id: Int(subJson[\"base\"][\"repo\"][\"id\"].intValue), repoName: String(subJson[\"base\"][\"repo\"][\"name\"].stringValue), repoPath: String(subJson[\"base\"][\"repo\"][\"path\"].stringValue), repoNamespace: RepoNamespace(id: Int(subJson[\"base\"][\"repo\"][\"namespace\"][\"id\"].intValue), name: String(subJson[\"base\"][\"repo\"][\"namespace\"][\"name\"].stringValue), path: String(subJson[\"base\"][\"repo\"][\"namespace\"][\"path\"].stringValue)), repoDesc: String(subJson[\"base\"][\"repo\"][\"description\"].stringValue), repoForks: \"\", repoStars: \"\",repoWatches:\"\", repoLicense:\"\", repoLanguage: \"\", repoPushDate:\"\", repoIsFork: false, repoIsOpenSource: Bool(subJson[\"base\"][\"repo\"][\"public\"].boolValue), repoIssues:\"\", repoDefaultBranch:\"\")\n                    \n                    tempList.append(PullRequestModel(id: Int(subJson[\"id\"].intValue), prId: Int(subJson[\"number\"].intValue), prStatus: getPullRequestStatus(status: String(subJson[\"state\"].stringValue)), prTitle: String(subJson[\"title\"].stringValue), prBody: String(subJson[\"body\"].stringValue), prUser: userInfo, prFrom: fromRepo, prTo: toRepo, prTime: Helper.getDateFromString(str: String(subJson[\"updated_at\"].stringValue)), prAuthMerge: Bool(subJson[\"mergeable\"].boolValue),prFromBranch: String(subJson[\"head\"][\"ref\"].stringValue),prToBranch: String(subJson[\"base\"][\"ref\"].stringValue)))\n                }\n                self.pullRequestList = tempList\n            }\n            self.isRefreshing = false\n            self.isLoading = false\n            self.waitPlease = false\n        } errorCallback: {\n            self.isRefreshing = false\n            self.isLoading = false\n            self.waitPlease = false\n            \n        }\n}\n```\n\n然后还是pull Request的item展示了：\n```Swift\nstruct PullRequestItemView:View{\n    @State var pullRequestItem: PullRequestModel\n    @State var prFromToString:String = \"\"\n    @State var prFromToString2:String = \"\"\n    @State private var isActiveCommit:Bool = false\n    @State private var isActivePullRequest:Bool = false\n    var body: some View{\n        VStack{\n            VStack(alignment: .leading){\n                HStack(alignment: .top) {\n                    VStack{\n                        Text(getPullRequestStatusStringShow(pullRequestItem:pullRequestItem))\n                            .foregroundColor(getPullRequestColor(pullRequestItem:pullRequestItem))\n                            .padding(.vertical,1)\n                            .padding(.horizontal,3)\n                    }\n                    .font(.system(size: 12))\n                    .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n                    .foregroundColor(.gray)\n                    .cornerRadius(3)\n                    VStack(alignment: .leading){\n                        Text(self.pullRequestItem.prTitle)\n                            .font(.system(size: 16))\n                            .lineLimit(1)\n                    }\n                    .padding(.leading,0)\n                    Spacer()\n                    Text(self.pullRequestItem.prTime)\n                        .padding(.vertical,1)\n                        .padding(.horizontal,3)\n                        .font(.system(size: 12))\n                        .foregroundColor(.gray)\n                }\n                .padding(5)\n                HStack(alignment: .center){\n                    Text(self.pullRequestItem.prBody)\n                        .font(.system(size: 14))\n                        .foregroundColor(.gray)\n                        .lineLimit(1)\n                        .padding(.top,10)\n                    Spacer()\n                }\n                HStack{\n                    VStack(alignment: .leading){\n                        Text(prFromToString)\n                            .padding(.vertical,0)\n                            .padding(.horizontal,3)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .lineLimit(1)\n                        \n                        Text(prFromToString2)\n                            .padding(.vertical,0)\n                            .padding(.horizontal,3)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .lineLimit(1)\n                    }\n                    Spacer()\n                }\n            }\n            .padding(10)\n        }\n        .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n        .cornerRadius(10)\n        .padding(.horizontal,5)\n        .sheet(isPresented: $isActivePullRequest,onDismiss: {\n        }){\n            PullRequestDetailView(pullRequestItem: $pullRequestItem).foregroundColor(.white)\n        }\n        .onTapGesture {\n            self.isActivePullRequest = true\n        }\n        .contextMenu(ContextMenu {\n            if pullRequestItem.prAutoMerge && pullRequestItem.prStatus == PullRequestStatus.open {\n                Button(action: {\n                }) {\n                    HStack{\n                        Image(systemName: \"mail.and.text.magnifyingglass\").scaleEffect(1, anchor: .center)\n                        Spacer()\n                        Text(\"审查通过\")\n                    }\n                }\n                Button(action: {\n                }) {\n                    HStack{\n                        Image(systemName: \"wrench.and.screwdriver\").scaleEffect(1, anchor: .center)\n                        Spacer()\n                        Text(\"测试通过\")\n                    }\n                }\n                Button(action: {\n                }) {\n                    HStack{\n                        Image(systemName: \"shuffle\").scaleEffect(1, anchor: .center)\n                        Spacer()\n                        Text(\"确认合并\")\n                    }\n                }\n            }\n            Divider()\n            Button(action: {\n                self.isActiveCommit = true\n            }) {\n                HStack{\n                    Image(systemName: \"icloud.and.arrow.up\").scaleEffect(1, anchor: .center)\n                    Spacer()\n                    Text(\"提交记录\")\n                }\n            }\n            .sheet(isPresented: $isActiveCommit,onDismiss: {\n            }){\n                CommitView(pullRequestItem: pullRequestItem).foregroundColor(.white)\n            }\n        })\n        .onAppear(){\n            if pullRequestItem.prFrom.repoNamespace.path == pullRequestItem.prTo.repoNamespace.path {\n                self.prFromToString = \"从 \" + pullRequestItem.prFromBranch + \"分支 到 \" + pullRequestItem.prToBranch + \"分支\"\n                self.prFromToString2 = \"这是你的自己的合并请求\"\n            }else{\n                self.prFromToString = \"从 \" + pullRequestItem.prFrom.repoNamespace.name + \"/\" + pullRequestItem.prFrom.repoName + \":\" + pullRequestItem.prFromBranch\n                self.prFromToString2 = \"到 \" + pullRequestItem.prTo.repoNamespace.name + \"/\" + pullRequestItem.prTo.repoName + \":\" + pullRequestItem.prToBranch\n            }\n        }\n    }\n}\n```\n\n### 3.5 查看Issues\n\nbody定义：\n```Swift\n var body: some View {\n    LoadingView(isLoading:self.$isLoading,message: self.$message,isModal:self.$isModal) {\n        VStack{\n            ZStack{\n                if issuesList.count == 0 && !isLoading {\n                    VStack{\n                        Image(systemName: \"doc.text.magnifyingglass\")\n                            .scaleEffect(3, anchor: .center)\n                        Text(\"暂无查询到的Issues\").padding(.top,30)\n                    }\n                }\n                RefreshView(refreshing: $isRefreshing, action: {\n                    self.page = 1\n                    self.getIssueList(page: self.page)\n                }) {\n                    LazyVStack{\n                        ForEach(self.issuesList){ item in\n                            NavigationLink(destination: IssueItemView(issueItem: item)) {\n                                IssueItemView(issueItem: item)\n                                    .onAppear(){\n                                        if !waitPlease && item.id == issuesList[issuesList.count - 1].id {\n                                            self.page = self.page + 1\n                                            self.getIssueList(page: self.page)\n                                        }\n                                    }\n                            }\n                        }\n                    }\n                }\n            }\n            if self.repoPath != \"\" {\n                Spacer()\n                HStack{\n                    Spacer()\n                    Button {\n                        self.isInserIssueShow = true\n                    } label: {\n                        Image(systemName: \"square.and.pencil\")\n                            .scaleEffect(1.2, anchor: .center)\n                    }\n                    .padding(12)\n                    .background(Color.yellow)\n                    .foregroundColor(Color.black)\n                    .cornerRadius(100)\n                    .sheet(isPresented: $isInserIssueShow) {\n                        let arr = self.repoPath.components(separatedBy: \"/\")\n                        IssueInsertView(repoNamespacePath: arr[0], repoPath: arr[1])\n                    }\n                }\n                .padding(.trailing,20)\n            }\n        }\n    }\n    .padding(.top,5)\n    .navigationBarTitle(Text(title!), displayMode: .inline)\n    .navigationBarItems(\n        trailing:\n            HStack {\n                Button(action: {\n                    self.isFilterShow.toggle()\n                }) {\n                    Image(systemName: \"rectangle.and.text.magnifyingglass\")\n                        \n                        .scaleEffect(1, anchor: .center)\n                }\n            }\n            .sheet(isPresented: $isFilterShow,onDismiss: {\n                self.isLoading = true\n                self.page = 1\n                self.getIssueList(page: self.page)\n            }){\n                IssueFilterView()\n                    .modifier(DisableModalDismiss(disabled: false))\n            }\n    )\n    .onAppear(){\n        localConfig.setValue(\"all\", forKey: giteeConfig.issue_filter)\n        localConfig.setValue(\"open\", forKey: giteeConfig.issue_state)\n        localConfig.setValue(\"created\", forKey: giteeConfig.issue_sort)\n        localConfig.setValue(\"desc\", forKey: giteeConfig.issue_direction)\n        self.page = 1\n        self.getIssueList(page: self.page)\n    }\n}\n```\n\n可见时请求列表：\n```Swift\nfunc getIssueList(page: Int){\n    if self.waitPlease { return }\n    self.waitPlease = true\n    if issuesList.count == 0 {\n        self.isLoading = true\n    }\n    let state = localConfig.string(forKey: giteeConfig.issue_state)\n    let filter = localConfig.string(forKey: giteeConfig.issue_filter)\n    let direction = localConfig.string(forKey: giteeConfig.issue_direction)\n    let sort = localConfig.string(forKey: giteeConfig.issue_sort)\n    var url = \"user/issues?page=\" + String(page)\n    \n    if self.repoPath != \"\" {\n        url = \"repos/\" + self.repoPath + \"/issues?page=\" + String(page)\n    }\n    \n    url = url + \"&state=\" + state!\n    url = url + \"&filter=\" + filter!\n    url = url + \"&direction=\" + direction!\n    url = url + \"&sort=\" + sort!\n    \n    \n    HttpRequest(url: url, withAccessToken: true)\n        .doGet { (value) in\n            let json = JSON(value)\n            if json[\"message\"].string != nil {\n                print(\"error\")\n                DispatchQueue.main.async {\n                    UIAlertController.confirm(message: json[\"message\"].stringValue, title: \"发生错误\", confirmText: \"重新登录\", cancelText: \"返回\") { (action) in\n                        Helper.relogin()\n                    }\n                }\n            }else{\n                var tempList = self.issuesList\n                if page == 1{\n                    tempList = []\n                }\n                for (_,subJson):(String, JSON) in json {\n                    let repoNamespace = RepoNamespace(id: Int(subJson[\"repository\"][\"namespace\"][\"id\"].stringValue)!, name: String(subJson[\"repository\"][\"namespace\"][\"name\"].stringValue), path:  String(subJson[\"repository\"][\"namespace\"][\"path\"].stringValue))\n                    let repoInfo = RepoModel(id: Int(subJson[\"repository\"][\"id\"].stringValue)!, repoName: String(subJson[\"repository\"][\"name\"].stringValue),repoPath:  String(subJson[\"repository\"][\"path\"].stringValue),repoNamespace: repoNamespace, repoDesc:  String(subJson[\"repository\"][\"description\"].stringValue), repoForks:  String(subJson[\"repository\"][\"forks_count\"].stringValue), repoStars:  String(subJson[\"repository\"][\"stargazers_count\"].stringValue), repoWatches:  String(subJson[\"repository\"][\"watchers_count\"].stringValue), repoLicense:  String(subJson[\"repository\"][\"license\"].stringValue), repoLanguage:  String(subJson[\"repository\"][\"language\"].stringValue), repoPushDate:  String(subJson[\"repository\"][\"pushed_at\"].stringValue), repoIsFork:  Bool(subJson[\"repository\"][\"fork\"].boolValue), repoIsOpenSource:  Bool(subJson[\"repository\"][\"public\"].boolValue), repoIssues:  String(subJson[\"repository\"][\"open_issues_count\"].stringValue), repoDefaultBranch:  String(subJson[\"repository\"][\"default_branch\"].stringValue))\n                    let userInfo = UserItemModel(id: Int(subJson[\"user\"][\"id\"].stringValue)!, userHead: String(subJson[\"user\"][\"avatar_url\"].stringValue), userName: String(subJson[\"user\"][\"name\"].stringValue), userAccount: String(subJson[\"user\"][\"login\"].stringValue))\n                    let issueInfo = IssueModel(id: Int(subJson[\"id\"].stringValue)!, issueId: String(subJson[\"number\"].stringValue), issueTitle: String(subJson[\"title\"].stringValue), issueTime: Helper.getDateFromString(str: String(subJson[\"created_at\"].stringValue)), issueDesc: String(subJson[\"body\"].stringValue), issueStatus: getIssueStatus(status: subJson[\"state\"].stringValue), repoInfo:repoInfo, userInfo: userInfo)\n                    tempList.append(\n                        issueInfo\n                    )\n                }\n                self.issuesList = tempList\n            }\n            self.isRefreshing = false\n            self.isLoading = false\n            self.waitPlease = false\n        } errorCallback: {\n            self.isRefreshing = false\n            self.isLoading = false\n            self.waitPlease = false\n            \n        }\n}\n```\n\n最后就是具体的IssueItemView了。\n```Swift\nstruct IssueItemView:View{\n    @State var issueItem: IssueModel\n    @State private var isActiveIsssueDetail:Bool = false\n    @State private var isActiveRepoDetail:Bool = false\n    var body: some View{\n        ZStack{\n            VStack{\n                NavigationLink(destination: RepoDetailView(repoFullPath: issueItem.repoInfo.repoNamespace.path + \"/\" + issueItem.repoInfo.repoPath), isActive: $isActiveRepoDetail) { EmptyView() }\n            }\n            .frame(width: 0, height: 0)\n            .opacity(0)\n            VStack{\n                VStack(alignment: .leading){\n                    HStack(alignment: .top) {\n                        Image(systemName:getIssueIcon(status: issueItem.issueStatus))\n                            .scaleEffect(1, anchor: .center)\n                            .foregroundColor(getIssueColor(status: issueItem.issueStatus))\n                        VStack(alignment: .leading){\n                            Text(issueItem.issueTitle)\n                                .font(.system(size: 16))\n                                .lineLimit(1)\n                        }\n                        Spacer()\n                        Text(issueItem.issueTime)\n                            .padding(.vertical,1)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                        \n                    }\n                    .padding(5)\n                    HStack{\n                        Text(issueItem.repoInfo.repoName)\n                            .padding(.leading,35)\n                            .font(.system(size: 12))\n                            .foregroundColor(Color(hex: 0xCCCCCC))\n                        Text(issueItem.issueDesc)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .lineLimit(1)\n                    }\n                    HStack{\n                        Image(systemName:\"person.circle\")\n                            .scaleEffect(0.7, anchor: .center)\n                            .foregroundColor(.gray)\n                            .padding(.leading,30)\n                        Text(issueItem.userInfo.userName)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .padding(.leading,-8)\n                        Spacer()\n                    }\n                    .padding(.top,5)\n                }\n                .padding(10)\n            }\n            .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n            .cornerRadius(10)\n            .padding(.horizontal,5)\n            .padding(.bottom,-3)\n            .sheet(isPresented: self.$isActiveIsssueDetail) {\n                self.reloadIssue()\n            } content: {\n                IssuesDetailView(issueItem: $issueItem)\n                    .foregroundColor(.white)\n            }\n            .onTapGesture {\n                self.isActiveIsssueDetail = true\n            }\n            .contextMenu(ContextMenu {\n                if issueItem.issueStatus != IssueStatus.open {\n                    Button(action: {\n                        self.changeIssueStatus(issueItem: issueItem,  issueStatus: IssueStatus.open)\n                    }) {\n                        HStack{\n                            Image(systemName: \"moon.circle\").scaleEffect(1, anchor: .center)\n                            Spacer()\n                            Text(\"标记为已开启\")\n                        }\n                    }\n                }\n                if issueItem.issueStatus != IssueStatus.progressing {\n                    Button(action: {\n                        self.changeIssueStatus(issueItem: issueItem,  issueStatus: IssueStatus.progressing)\n                    }) {\n                        HStack{\n                            Image(systemName: \"timer\").scaleEffect(1, anchor: .center)\n                            Spacer()\n                            Text(\"标记为进行中\")\n                        }\n                    }\n                }\n                if issueItem.issueStatus != IssueStatus.rejected {\n                    Button(action: {\n                        UIAlertController.alert(message: \"请期待Gitee开放这个API吧~\", title: \"即将上线\", confirmText: \"安排\")\n                    }) {\n                        HStack{\n                            Image(systemName: \"xmark.circle\").scaleEffect(1, anchor: .center)\n                            Spacer()\n                            Text(\"标记为已拒绝\")\n                        }\n                    }\n                }\n                if issueItem.issueStatus != IssueStatus.closed {\n                    Button(action: {\n                        self.changeIssueStatus(issueItem: issueItem, issueStatus: IssueStatus.closed)\n                    }) {\n                        HStack{\n                            Image(systemName: \"checkmark.circle\").scaleEffect(1, anchor: .center)\n                            Spacer()\n                            Text(\"标记为完成\")\n                        }\n                    }\n                }\n                Divider()\n                Button(action: {\n                    self.isActiveRepoDetail = true\n                }) {\n                    HStack{\n                        Image(systemName: \"archivebox.circle\").scaleEffect(1, anchor: .center)\n                        Spacer()\n                        Text(\"进入所属仓库\")\n                    }\n                }\n            })\n        }\n    }\n```\n\n## 4 总结\n\n* 这里学会了Swift初始化配置，可以简化其它流程，只需要继承App类。\n\n* 然后这里学会使用类似Flutter的组件，HStack,VStack,ZSack，Spacer,Text，Image这一类基础组件。\n\n* 网络请求的最好自己封装一个HttpRequest类，动态配置各种参数。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"iOS-swift-Gitee客户端-完整项目分析之一","published":1,"updated":"2023-02-06T14:16:04.043Z","_id":"cldsgpnnk0000egv78r9w1qr7","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-项目地址\"><a href=\"#1-项目地址\" class=\"headerlink\" title=\"1 项目地址\"></a>1 项目地址</h2><blockquote>\n<p><a href=\"https://gitee.com/open-gitee/gitee_ios\">https://gitee.com/open-gitee/gitee_ios</a><br>Gitee基于SwiftUI和OpenApi的iOS客户端项目。</p>\n</blockquote>\n<h2 id=\"2-项目截图\"><a href=\"#2-项目截图\" class=\"headerlink\" title=\"2 项目截图\"></a>2 项目截图</h2><table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=1.png></td>\n<td><img src=2.png></td>\n<td><img src=3.png></td>\n</tr>\n<tr>\n<td><img src=4.png></td>\n<td><img src=5.png></td>\n<td><img src=6.png></td>\n</tr>\n</tbody></table>\n<h2 id=\"3-首页架构\"><a href=\"#3-首页架构\" class=\"headerlink\" title=\"3 首页架构\"></a>3 首页架构</h2><p>这里是底部3个Tab，首页展示一个工作台消息中心，你的团队的入库。应该是写死的布局。</p>\n<p>第二个tab是好友动态，这里展示一个列表，展示动态列表。</p>\n<p>第三个tab是设置页，上方是头像，然后是关注粉丝star啥的。</p>\n<p>关于App和Scene代码结构，可以参考这篇文章：<br><a href=\"https://zhuanlan.zhihu.com/p/152624613\">SwiftUI2.0 —— App、Scene及新的代码结构（一）</a>。</p>\n<p>应用初始化代码：</p>\n<pre><code class=\"line-numbers language-Swift\">@main\nstruct GiteeApp: App &#123;\n    var body: some Scene &#123;\n        WindowGroup &#123;\n            TabBarView(selectedBarIndex: 0)\n                .preferredColorScheme(.dark)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里body就是首页了。<br>App，Scene，WindowGroup都是系统类。</p>\n<p>里面的TabBarView是自定义View来的：</p>\n<pre><code class=\"line-numbers language-Swift\">struct TabBarView: View &#123;\n    @State var selectedBarIndex:Int\n    \n    var body: some View &#123;\n        NavigationView&#123;\n            TabView(selection: $selectedBarIndex) &#123;\n                HomeView()\n                .tabItem &#123;\n                    Image(systemName:&quot;briefcase&quot;)\n                    Text(&quot;首页&quot;)\n                &#125;\n                    .tag(0)\n                ActivityView()\n                .tabItem &#123;\n                    Image(systemName:&quot;stopwatch&quot;)\n                    Text(&quot;动态&quot;)\n                &#125;\n                    .tag(1)\n//                ExploreView()\n//                .tabItem &#123;\n//                    Image(systemName:&quot;opticaldisc&quot;)\n//                    Text(&quot;发现&quot;)\n//                &#125;\n//                    .tag(2)\n                SettingView()\n                .tabItem &#123;\n                    Image(systemName:&quot;gearshape&quot;)\n                    Text(&quot;设置&quot;)\n                &#125;\n                    .tag(3)\n            &#125;\n            .navigationBarTitle(getNavBarTitle(),displayMode: getNavBarModel())\n            .navigationBarHidden(self.selectedBarIndex==3)\n            .foregroundColor(.white)\n            .accentColor(.white) //这里修改文字颜色\n        &#125;\n        .navigationViewStyle(StackNavigationViewStyle())\n        .accentColor(.white)\n        .foregroundColor(.white)\n        .preferredColorScheme(.dark)\n    &#125;\n</code></pre>\n<p>这里TabView其实就是定义的底部Tab，然后item点击后是配置在中间的。<br>比如HomeView就是首页了，ActivityView应该就是动态页了，SettingView就是设置页了。</p>\n<pre><code class=\"line-numbers language-Swift\">\nfunc getNavBarModel() -&gt; NavigationBarItem.TitleDisplayMode&#123;\n    if self.selectedBarIndex == 0 &#123;\n        return .large\n    &#125;\n    if self.selectedBarIndex == 1 &#123;\n        return .inline\n    &#125;\n    if self.selectedBarIndex == 2 &#123;\n        return .large\n    &#125;\n    if self.selectedBarIndex == 3 &#123;\n        return .large\n    &#125;\n    return .inline\n&#125;\nfunc getNavBarTitle() -&gt; String&#123;\n    if self.selectedBarIndex == 0 &#123;\n        return &quot;Gitee&quot;\n    &#125;\n    if self.selectedBarIndex == 1 &#123;\n        return &quot;好友动态&quot;\n    &#125;\n    if self.selectedBarIndex == 2 &#123;\n        return &quot;发现&quot;\n    &#125;\n    if self.selectedBarIndex == 3&#123;\n        return &quot;设置&quot;\n    &#125;\n    return  &quot;&quot;\n&#125;\n</code></pre>\n<p>这里配置tab具体数据。<br><img src=\"/./iOS-swift-Gitee%E5%AE%A2%E6%88%B7%E7%AB%AF-%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%80/tab1.png\"><br><img src=tab1.png><br>这里Form是表格。<br>Section是组别。<br>这里有一个NavigationLink是item1就是第一个item，这里显示代码仓库。颜色和icon都可以设置的。</p>\n<p> 但是这里的HomeListItem是自己定义的哦。</p>\n<pre><code class=\"line-numbers language-Swift\">struct HomeListItem : View &#123;\n   @State var title: String\n   @State var icon: String\n   @State var color: Color\n   \n   var body: some View &#123;\n       HStack(spacing: 15)&#123;\n           Image(systemName:icon)\n               .scaleEffect(1.5, anchor: .center)\n               .foregroundColor(color)\n           Text(title).font(.system(size:16))\n       &#125;\n       .padding(.horizontal, 5)\n       .frame( height: 48)\n       .cornerRadius(10)\n   &#125;\n&#125;\n</code></pre>\n<p>这个HStack是系统的，估计类似于Flutter里面的Stack吧。<br>这里右侧箭头是咋来的呢？<br>原来是</p>\n<pre><code class=\"line-numbers language-Swift\">var body: some View &#123;\n    Form &#123;\n        Section(header: Text(&quot;工作台&quot;)) &#123;\n            NavigationLink(destination: RepoView()) &#123;\n                HomeListItem(title: &quot;代码仓库&quot;,icon:&quot;archivebox.circle&quot;, color: Color(hex: 0x7699ec))\n            &#125;\n//                NavigationLink(destination:  PullRequestView()) &#123;\n//                    HomeListItem(title: &quot;Pull Request&quot;,icon:&quot;shuffle.circle&quot;, color: Color(hex: 0x00b392))\n//                &#125;\n            NavigationLink(destination:  IssuesView()) &#123;\n                HomeListItem(title: &quot;Issues&quot;,icon:&quot;exclamationmark.circle&quot;, color: Color(hex: 0xfe665b))\n            &#125;\n        &#125;\n</code></pre>\n<p>这里面的NavigationLink自带的箭头哦。</p>\n<h3 id=\"3-2-仓库页面\"><a href=\"#3-2-仓库页面\" class=\"headerlink\" title=\"3.2 仓库页面\"></a>3.2 仓库页面</h3><p>前面用了一个NavigationLink包裹，那么点击这个之后应该是跳转到目标页面。</p>\n<p>这里是先跳转到你的仓库页面。<br>先看看哈：</p>\n<pre><code class=\"line-numbers language-Swift\">var body: some View &#123;\n    LoadingView(isLoading:self.$isLoading,message: self.$message,isModal:self.$isModal) &#123;\n        ZStack&#123;\n            if repoList.count == 0 &amp;&amp; !isLoading &#123;\n                VStack&#123;\n                    Image(systemName: &quot;doc.text.magnifyingglass&quot;)\n                        .scaleEffect(3, anchor: .center)\n                    Text(&quot;暂无查询到的仓库&quot;).padding(.top,30)\n                &#125;\n            &#125;\n            RefreshView(refreshing: $isRefreshing, action: &#123;\n                self.page = 1\n                self.getRepoList(page: self.page)\n            &#125;) &#123;\n                LazyVStack&#123;\n                    ForEach(self.repoList)&#123; item in\n                        NavigationLink(destination: RepoDetailView(repoFullPath: item.repoNamespace.path + &quot;/&quot; + item.repoPath)) &#123;\n                            RepoItemView(repoItem: item)\n                                .onAppear()&#123;\n                                    if !waitPlease &amp;&amp; item.id == repoList[repoList.count - 1].id &#123;\n                                        self.page = self.page + 1\n                                        self.getRepoList(page: self.page)\n                                    &#125;\n                                &#125;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    .sheet(isPresented: $isLoginShow,onDismiss: &#123;\n        UserModel().getMyInfo &#123; (userInfo) in\n            self.page = 1\n            self.getRepoList(page: self.page)\n        &#125; error: &#123;\n            self.isLoginShow.toggle()\n        &#125;\n    &#125;)&#123;\n        LoginView()\n            .modifier(DisableModalDismiss(disabled: true))\n    &#125;\n    .padding(.top,5)\n    .navigationBarTitle(Text(naviTitle), displayMode: .inline)\n    .navigationBarItems(\n        trailing:\n            HStack &#123;\n                Button(action: &#123;\n                    self.isFilterShow.toggle()\n                &#125;) &#123;\n                    Image(systemName: &quot;rectangle.and.text.magnifyingglass&quot;)\n                        \n                        .scaleEffect(1, anchor: .center)\n                &#125;\n            &#125;\n            .sheet(isPresented: $isFilterShow,onDismiss: &#123;\n                self.isLoading = true\n                self.page = 1\n                self.getRepoList(page: self.page)\n            &#125;)&#123;\n                RepoFilterView(showListFrom: self.showListFrom)\n                    .modifier(DisableModalDismiss(disabled: false))\n            &#125;\n    )\n    .onAppear()&#123;\n        switch self.showListFrom &#123;\n        case ShowRepoListFrom.fromWatches:\n            self.naviTitle = &quot;Watch的仓库&quot;\n        case ShowRepoListFrom.fromStars:\n            self.naviTitle = &quot;Star的仓库&quot;\n        default:\n            self.naviTitle = &quot;你的仓库&quot;\n        &#125;\n        \n        localConfig.setValue(&quot;all&quot;, forKey: giteeConfig.repo_type)\n        localConfig.setValue(&quot;pushed&quot;, forKey: giteeConfig.repo_sort)\n        localConfig.setValue(&quot;desc&quot;, forKey: giteeConfig.repo_direction)\n        self.page = 1\n        self.getRepoList( page: self.page)\n    &#125;\n&#125;\n</code></pre>\n<p>loading视图：</p>\n<pre><code class=\"line-numbers language-Swift\">struct LoadingView&lt;Content&gt;: View where Content: View &#123;\n    \n    @Binding var isLoading: Bool\n    @Binding var message:String\n    @Binding var isModal: Bool\n    @State var isAnimating: Bool = true\n    var content: () -&gt; Content\n    \n    var body: some View &#123;\n        GeometryReader &#123; geometry in\n            ZStack(alignment: .center) &#123;\n                self.content()\n                    .disabled(self.isModal)\n                    .blur(radius: self.isModal ? 10 : 0)\n                VStack &#123;\n                    Text(self.message)\n                        .padding(.bottom,20)\n                    ActivityIndicatorLoading(isAnimating: self.$isAnimating, style: .large)\n                &#125;\n                    \n                .frame(width: geometry.size.width / 2,\n                       height: geometry.size.height / 5)\n                    .background(Color.secondary.colorInvert())\n                    .foregroundColor(Color.primary)\n                    .cornerRadius(20)\n                    .opacity(self.isLoading ? 1 : 0)\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里的Loading效果是ActivityIndicatorLoading这个实现的。这个是自定义的哦。<br>继续走这个：</p>\n<pre><code class=\"line-numbers language-Swift\">struct ActivityIndicatorLoading: UIViewRepresentable &#123;\n    \n    @Binding var isAnimating: Bool\n    let style: UIActivityIndicatorView.Style\n    \n    func makeUIView(context: UIViewRepresentableContext&lt;ActivityIndicatorLoading&gt;) -&gt; UIActivityIndicatorView &#123;\n        return UIActivityIndicatorView(style: style)\n    &#125;\n    \n    func updateUIView(_ uiView: UIActivityIndicatorView, context: UIViewRepresentableContext&lt;ActivityIndicatorLoading&gt;) &#123;\n        isAnimating ? uiView.startAnimating() : uiView.stopAnimating()\n    &#125;\n&#125;\n</code></pre>\n<p>原来是UIActivityIndicatorView这个类来实现loading效果的。</p>\n<p>然后这里有个自定义刷新视图。<br>可以参考下这篇文章：<a href=\"https://swiftui-lab.com/scrollview-pull-to-refresh/\">https://swiftui-lab.com/scrollview-pull-to-refresh/</a>。</p>\n<pre><code class=\"line-numbers language-Swift\">LazyVStack&#123;\n    ForEach(self.repoList)&#123; item in\n        NavigationLink(destination: RepoDetailView(repoFullPath: item.repoNamespace.path + &quot;/&quot; + item.repoPath)) &#123;\n            RepoItemView(repoItem: item)\n                .onAppear()&#123;\n                    if !waitPlease &amp;&amp; item.id == repoList[repoList.count - 1].id &#123;\n                        self.page = self.page + 1\n                        self.getRepoList(page: self.page)\n                    &#125;\n                &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里就是刷新器里面展示列表。</p>\n<p>列表的item是这个RepoItemView:</p>\n<pre><code class=\"line-numbers language-Swift\">struct RepoItemView:View&#123;\n    @State var repoItem: RepoModel\n    @State private var isActiveCommit:Bool = false\n    @State private var isActivePullRequest:Bool = false\n    @State private var isActiveIssues:Bool = false\n    \n    var body: some View&#123;\n        VStack&#123;\n            VStack&#123;\n                NavigationLink(destination: CommitView(repoFullPath: repoItem.repoNamespace.path + &quot;/&quot; + repoItem.repoPath,repoDefaultBranch: repoItem.repoDefaultBranch), isActive: $isActiveCommit) &#123; EmptyView() &#125;\n                NavigationLink(destination: PullRequestView(repoFullPath: repoItem.repoNamespace.path + &quot;/&quot; + repoItem.repoPath), isActive: $isActivePullRequest) &#123; EmptyView() &#125;\n                NavigationLink(destination: IssuesView(repoPath: repoItem.repoNamespace.path + &quot;/&quot; + repoItem.repoPath),isActive: $isActiveIssues) &#123; EmptyView() &#125;\n            &#125;\n            .frame(width: 0, height: 0)\n            .opacity(0)\n            VStack(alignment: .leading)&#123;\n                HStack(alignment: .top) &#123;\n                    if !self.repoItem.repoIsOpenSource &#123;\n                        Image(systemName: &quot;lock.square.fill&quot;)\n                            .foregroundColor(Color(hex: 0xffc55a))\n                            .padding(.trailing,-5)\n                            .scaleEffect(1, anchor: .center)\n                    &#125;\n                    VStack(alignment: .leading)&#123;\n                        Text(self.repoItem.repoNamespace.name + &quot;/&quot; + self.repoItem.repoName)\n                            .font(.system(size: 16))\n                            .lineLimit(1)\n                    &#125;\n                    Spacer()\n                    Text(self.repoItem.repoPushDate)\n                        .font(.system(size: 12))\n                        .foregroundColor(.gray)\n                    \n                &#125;\n                .padding(5)\n                Text(self.repoItem.repoDesc == &quot;&quot; ? &quot;很尴尬,该项目暂无介绍...&quot; : self.repoItem.repoDesc)\n                    .font(.system(size: 14))\n                    .foregroundColor(.gray)\n                    .lineLimit(3)\n                    .multilineTextAlignment(.leading)\n                    .padding(.top,10)\n                    .padding(.leading,5)\n                    .fixedSize(horizontal: false, vertical: true)\n                Spacer()\n                HStack&#123;\n                    if self.repoItem.repoLanguage != &quot;&quot; &#123;\n                        VStack&#123;\n                            Text(self.repoItem.repoLanguage)\n                                .padding(.vertical,1)\n                                .padding(.horizontal,3)\n                        &#125;\n                        .font(.system(size: 12))\n                        .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n                        .foregroundColor(.gray)\n                        .cornerRadius(3)\n                    &#125;\n                    if self.repoItem.repoLicense != &quot;&quot; &#123;\n                        VStack&#123;\n                            Text(self.repoItem.repoLicense)\n                                .padding(.vertical,1)\n                                .padding(.horizontal,3)\n                        &#125;\n                        .font(.system(size: 12))\n                        .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n                        .foregroundColor(.gray)\n                        .cornerRadius(3)\n                    &#125;\n                    Spacer()\n                    HStack&#123;\n                        Image(systemName: &quot;star.fill&quot;)\n                            .foregroundColor(.gray)\n                            .scaleEffect(0.6, anchor: .center)\n                            .padding(0)\n                        Text(self.repoItem.repoStars)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .padding(0)\n                            .padding(.leading,-12)\n                    &#125;\n                    HStack&#123;\n                        Image(systemName: &quot;eye.fill&quot;)\n                            .foregroundColor(.gray)\n                            .scaleEffect(0.6, anchor: .center)\n                            .padding(0)\n                        Text(self.repoItem.repoWatches)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .padding(0)\n                            .padding(.leading,-12)\n                    &#125;\n                    .padding(.horizontal,-8)\n                    HStack&#123;\n                        Image(systemName: &quot;arrowshape.turn.up.backward.2.fill&quot;)\n                            .foregroundColor(.gray)\n                            .scaleEffect(0.7, anchor: .center)\n                            .padding(0)\n                        Text(self.repoItem.repoForks)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .padding(0)\n                            .padding(.leading,-12)\n                    &#125;\n                &#125;\n                .padding(.top,5)\n            &#125;\n            .padding(10)\n        &#125;\n        .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n        .cornerRadius(10)\n        .padding(.horizontal,5)\n        .padding(.bottom,5)\n        //        .swipeCell(\n        //            cellPosition: .both,\n        //            leftSlot: nil,\n        //            rightSlot: SwipeCellSlot(\n        //                slots:\n        //                    [\n        //                        SwipeCellButton(\n        //                            buttonStyle: .titleAndImage,\n        //                            title: &quot;Mark&quot;,\n        //                            systemImage: &quot;bookmark&quot;,\n        //                            titleColor: .white,\n        //                            imageColor: .white,\n        //                            view: nil,\n        //                            backgroundColor: .green,\n        //                            action: &#123;\n        //                                print(&quot;123&quot;)\n        //                            &#125;,\n        //                            feedback:true\n        //                        )\n        //                    ]\n        //            )\n        //        )\n        .contextMenu(ContextMenu &#123;\n            Button(action: &#123;\n                self.isActiveCommit = true\n            &#125;) &#123;\n                HStack&#123;\n                    Image(systemName: &quot;icloud.and.arrow.up&quot;).scaleEffect(1, anchor: .center)\n                    Spacer()\n                    Text(&quot;提交记录&quot;)\n                &#125;\n            &#125;\n            Divider()\n            Button(action: &#123;\n                self.isActivePullRequest = true\n            &#125;) &#123;\n                HStack&#123;\n                    Image(systemName: &quot;shuffle.circle&quot;).scaleEffect(1, anchor: .center)\n                    Spacer()\n                    Text(&quot;Pull Requests&quot;)\n                &#125;\n            &#125;\n            Button(action: &#123;\n                self.isActiveIssues = true\n            &#125;) &#123;\n                HStack&#123;\n                    Image(systemName: &quot;exclamationmark.circle&quot;).scaleEffect(1, anchor: .center)\n                    Spacer()\n                    Text(&quot;查看Issues&quot;)\n                &#125;\n            &#125;\n        &#125;)\n    &#125;\n&#125;\n</code></pre>\n<p>长按会弹出菜单，提交记录，Pull Requests Issues都是菜单项。<br>注意到这里的菜单是一个Button，里面配置了action，然后在顶部配置了NavigationLink，实现跳转。</p>\n<h3 id=\"3-3-提交记录\"><a href=\"#3-3-提交记录\" class=\"headerlink\" title=\"3.3 提交记录\"></a>3.3 提交记录</h3><p>比如点击了提交记录：<br>这里显示body:</p>\n<pre><code class=\"line-numbers language-Swift\">var body: some View &#123;\n    LoadingView(isLoading:self.$isLoading,message: self.$message,isModal:self.$isModal) &#123;\n        ZStack&#123;\n            if commitList.count == 0 &amp;&amp; !isLoading &#123;\n                VStack&#123;\n                    Image(systemName: &quot;doc.text.magnifyingglass&quot;)\n                        .scaleEffect(3, anchor: .center)\n                    Text(&quot;暂无查询到的提交&quot;).padding(.top,30)\n                &#125;\n            &#125;\n            RefreshView(refreshing: $isRefreshing, action: &#123;\n                self.page = 1\n                self.getCommitList(page: self.page)\n            &#125;) &#123;\n                LazyVStack&#123;\n                    ForEach(self.commitList)&#123; item in\n                        CommitItemView(commitItem: item, repoFullPath: self.repoFullPath!)\n                            .onAppear()&#123;\n                                if !waitPlease &amp;&amp; item.id == commitList[commitList.count - 1].id &#123;\n                                    self.page = self.page + 1\n                                    self.getCommitList(page: self.page)\n                                &#125;\n                            &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        .padding(.top,5)\n        .navigationBarTitle(Text(self.showCommitFrom == CommitFromModel.fromRepo ? branch : &quot;包含的提交&quot;), displayMode: .inline)\n        .navigationBarItems(\n            trailing:\n                HStack &#123;\n                    if self.showCommitFrom == CommitFromModel.fromRepo&#123;\n                        Button &#123;\n                        &#125; label: &#123;\n                            Menu &#123;\n                                ForEach (0 ..&lt; self.branchList.count, id: \\.self) &#123;index in\n                                    Button(self.branchList[index], action: &#123;\n                                        self.branch = self.branchList[index]\n                                        self.page = 1\n                                        self.isLoading = true\n                                        self.getCommitList(page: self.page)\n                                    &#125;)\n                                &#125;\n                            &#125; label: &#123;\n                                VStack&#123;\n                                    Text(&quot;分支&quot;).foregroundColor(.yellow)\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n        )\n        .onAppear()&#123;\n            if self.showCommitFrom == CommitFromModel.fromRepo&#123;\n                self.branch = self.repoDefaultBranch!\n            &#125;else&#123;\n                self.branch = &quot;master&quot;\n            &#125;\n            self.page = 1\n            self.getCommitList( page: self.page)\n            self.getBranchList()\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>onAppear的时候，走接口。</p>\n<pre><code class=\"line-numbers language-Swift\"> func getCommitList(page: Int)&#123;\n        if self.waitPlease &#123; return &#125;\n        self.waitPlease = true\n        if commitList.count == 0 &#123;\n            self.isLoading = true\n        &#125;\n        var url = &quot;repos/&quot;\n        if self.showCommitFrom == CommitFromModel.fromRepo&#123;\n            url = url + self.repoFullPath! + &quot;/commits?page=&quot; + String(page)\n            url = url + &quot;&amp;sha=&quot; + self.branch\n        &#125;else if self.showCommitFrom == CommitFromModel.fromPullRequest&#123;\n            url = url + (self.pullRequestItem?.prTo.repoNamespace.path)! + &quot;/&quot;\n            url = url + (self.pullRequestItem?.prTo.repoPath)! + &quot;/pulls/&quot;\n            url = url + String(self.pullRequestItem!.prId) + &quot;/commits&quot;;\n        &#125;\n        \n        HttpRequest(url: url, withAccessToken: true)\n            .doGet &#123; (value) in\n                let json = JSON(value)\n                if json[&quot;message&quot;].string != nil &#123;\n                    print(&quot;error&quot;)\n                    DispatchQueue.main.async &#123;\n                        UIAlertController.confirm(message: json[&quot;message&quot;].stringValue, title: &quot;发生错误&quot;, confirmText: &quot;重新登录&quot;, cancelText: &quot;返回&quot;) &#123; (action) in\n                            Helper.relogin()\n                        &#125;\n                    &#125;\n                &#125;else&#123;\n                    var tempList = self.commitList\n                    if page == 1&#123;\n                        tempList = []\n                    &#125;\n                    for (_,subJson):(String, JSON) in json &#123;\n                        let author = subJson[&quot;commit&quot;][&quot;author&quot;][&quot;name&quot;].stringValue\n                        let userInfo = UserItemModel(id: Int(subJson[&quot;author&quot;][&quot;id&quot;].intValue), userHead: String(subJson[&quot;author&quot;][&quot;avatar_url&quot;].stringValue), userName: String(subJson[&quot;author&quot;][&quot;name&quot;].stringValue), userAccount: String(subJson[&quot;author&quot;][&quot;login&quot;].stringValue))\n                        tempList.append(CommitModel(id: subJson[&quot;sha&quot;].stringValue, sha: String(subJson[&quot;sha&quot;].stringValue), author: author, commitTime: String(subJson[&quot;commit&quot;][&quot;author&quot;][&quot;date&quot;].stringValue), message: String(subJson[&quot;commit&quot;][&quot;message&quot;].stringValue), addCount:  String(subJson[&quot;stats&quot;][&quot;additions&quot;].stringValue), deleteCount: String(subJson[&quot;stats&quot;][&quot;deletions&quot;].stringValue), totalCount: String(subJson[&quot;stats&quot;][&quot;total&quot;].stringValue), user: userInfo))\n                    &#125;\n                    self.commitList = tempList\n                &#125;\n                self.isRefreshing = false\n                self.isLoading = false\n                self.waitPlease = false\n            &#125; errorCallback: &#123;\n                self.isRefreshing = false\n                self.isLoading = false\n                self.waitPlease = false\n            &#125;\n    &#125;\n</code></pre>\n<p>这里获取分支：</p>\n<pre><code class=\"line-numbers language-Swift\">func getBranchList()&#123;\n        var url = &quot;repos/&quot;\n        url = url + self.repoFullPath! + &quot;/branches&quot;;\n        HttpRequest(url: url, withAccessToken: true)\n            .doGet &#123; (value) in\n                let json = JSON(value)\n                if json[&quot;message&quot;].string != nil &#123;\n                    DispatchQueue.main.async &#123;\n                        UIAlertController.confirm(message: json[&quot;message&quot;].stringValue, title: &quot;发生错误&quot;, confirmText: &quot;重新登录&quot;, cancelText: &quot;返回&quot;) &#123; (action) in\n                            Helper.relogin()\n                        &#125;\n                    &#125;\n                &#125;else&#123;\n                    if page == 1&#123;\n                        branchList = []\n                    &#125;\n                    for (_,subJson):(String, JSON) in json &#123;\n                        branchList.append(subJson[&quot;name&quot;].stringValue)\n                    &#125;\n                &#125;\n            &#125; errorCallback: &#123;\n                \n            &#125;\n    &#125;\n</code></pre>\n<p>注意到分支列表里面用了分支的item：</p>\n<pre><code class=\"line-numbers language-Swift\">struct CommitItemView:View&#123;\n    @State var commitItem: CommitModel\n    @State var repoFullPath: String\n    @State var userHead:UIImage? = nil\n    let placeholderImage = UIImage(named: &quot;nohead&quot;)!\n    @State var isCommitChangeShow: Bool = false\n    \n    var body: some View&#123;\n        VStack&#123;\n            VStack(alignment: .leading)&#123;\n                VStack(alignment: .leading)&#123;\n                    HStack(alignment: .top) &#123;\n                        Image(uiImage: self.userHead ?? placeholderImage)\n                            .resizable()\n                            .scaledToFit()\n                            .frame(\n                                width:20,height:20,\n                                alignment: .center\n                            )\n                            .cornerRadius(5)\n                            .onAppear()&#123;\n                                guard let url = URL(string: commitItem.user.userHead) else &#123;\n                                    return\n                                &#125;\n                                URLSession.shared.dataTask(with: url) &#123; (data, response, error) in\n                                    if let data = data, let image = UIImage(data: data) &#123;\n                                        self.userHead = image\n                                    &#125;\n                                &#125;.resume()\n                            &#125;\n                        VStack(alignment: .leading)&#123;\n                            Text(commitItem.message)\n                                .font(.system(size: 16))\n                                .lineLimit(1)\n                        &#125;\n                        Spacer()\n                        Text(&quot;+&quot; + commitItem.addCount).foregroundColor(.green).font(.system(size:14)).fontWeight(.bold).padding(.leading,0)\n                        Text(&quot;-&quot; + commitItem.deleteCount).foregroundColor(.red).font(.system(size:14)).fontWeight(.bold).padding(.leading,0)\n                        \n                    &#125;\n                &#125;\n                .padding(.vertical,5)\n                HStack&#123;\n                    Text(Helper.getDateFromString(str: commitItem.commitTime)).font(.system(size:14)).foregroundColor(.gray)\n                    Text(&quot;由 &quot;).font(.system(size:14)).foregroundColor(.gray).padding(.leading,-5)\n                    Text(commitItem.author + &quot;(&quot; + commitItem.user.userAccount + &quot;)&quot;).font(.system(size:14)).foregroundColor(Color(hex: 0xaaaaaa)).padding(.leading,0).padding(.leading,-5)\n                    Text(&quot; 提交&quot;).font(.system(size:14)).foregroundColor(.gray).padding(.leading,0).padding(.leading,-5)\n                    Spacer()\n                &#125;\n            &#125;\n            .padding(10)\n        &#125;\n        .onTapGesture &#123;\n            self.isCommitChangeShow = true\n        &#125;\n        .sheet(isPresented: $isCommitChangeShow,onDismiss: &#123;\n            \n        &#125;)&#123;\n            CommitChangesView(sha: self.commitItem.sha, repoFullPath:\n                                self.repoFullPath)\n        &#125;\n        .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n        .cornerRadius(10)\n        .padding(.horizontal,5)\n        .padding(.bottom,-5)\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"3-4-Pull-Request\"><a href=\"#3-4-Pull-Request\" class=\"headerlink\" title=\"3.4 Pull Request\"></a>3.4 Pull Request</h3><p>整个body定义：</p>\n<pre><code class=\"line-numbers language-Swift\">var body: some View &#123;\n    LoadingView(isLoading:self.$isLoading,message: self.$message,isModal:self.$isModal) &#123;\n        ZStack&#123;\n            if pullRequestList.count == 0 &amp;&amp; !isLoading &#123;\n                VStack&#123;\n                    Image(systemName: &quot;doc.text.magnifyingglass&quot;)\n                        .scaleEffect(3, anchor: .center)\n                    Text(&quot;暂无查询到的Pull Requests&quot;).padding(.top,30)\n                &#125;\n            &#125;\n            RefreshView(refreshing: $isRefreshing, action: &#123;\n                self.page = 1\n                self.getPullRequestList(page: self.page)\n            &#125;) &#123;\n                LazyVStack&#123;\n                    ForEach(self.pullRequestList)&#123; item in\n                        PullRequestItemView(pullRequestItem: item)\n                            .onAppear()&#123;\n                                if !waitPlease &amp;&amp; item.id == pullRequestList[pullRequestList.count - 1].id &#123;\n                                    self.page = self.page + 1\n                                    self.getPullRequestList(page: self.page)\n                                &#125;\n                            &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    .navigationBarTitle(Text(&quot;Pull Requests&quot;), displayMode: .inline)\n    .navigationBarItems(trailing:\n                            HStack &#123;\n                                Button(action: &#123;\n                                    self.isFilterShow.toggle()\n                                &#125;) &#123;\n                                    Image(systemName: &quot;rectangle.and.text.magnifyingglass&quot;)\n                                        \n                                        .scaleEffect(1, anchor: .center)\n                                &#125;\n                            &#125;\n                            .sheet(isPresented: $isFilterShow,onDismiss: &#123;\n                                self.isLoading = true\n                                self.page = 1\n                                self.getPullRequestList(page: self.page)\n                            &#125;)&#123;\n                                PullRequestFilterView()\n                                    .modifier(DisableModalDismiss(disabled: false))\n                            &#125;\n    )\n    .onAppear()&#123;\n        localConfig.setValue(&quot;open&quot;, forKey: giteeConfig.pull_request_state)\n        localConfig.setValue(&quot;updated&quot;, forKey: giteeConfig.pull_request_sort)\n        localConfig.setValue(&quot;desc&quot;, forKey: giteeConfig.pull_request_direction)\n        self.page = 1\n        self.getPullRequestList( page: self.page)\n    &#125;\n&#125;\n</code></pre>\n<p>可见时请求接口：</p>\n<pre><code class=\"line-numbers language-Swift\">func getPullRequestList(page: Int)&#123;\n    if self.waitPlease &#123; return &#125;\n    self.waitPlease = true\n    if pullRequestList.count == 0 &#123;\n        self.isLoading = true\n    &#125;\n    let state = localConfig.string(forKey: giteeConfig.pull_request_state)\n    let sort = localConfig.string(forKey: giteeConfig.pull_request_sort)\n    let direction = localConfig.string(forKey: giteeConfig.pull_request_direction)\n    var url = &quot;repos/&quot;\n    url = url + self.repoFullPath + &quot;/pulls?page=&quot; + String(page);\n    \n    url = url + &quot;&amp;state=&quot; + state!\n    url = url + &quot;&amp;sort=&quot; + sort!\n    url = url + &quot;&amp;direction=&quot; + direction!\n    \n    \n    HttpRequest(url: url, withAccessToken: true)\n        .doGet &#123; (value) in\n            let json = JSON(value)\n            if json[&quot;message&quot;].string != nil &#123;\n                print(&quot;error&quot;)\n                DispatchQueue.main.async &#123;\n                    UIAlertController.confirm(message: json[&quot;message&quot;].stringValue, title: &quot;发生错误&quot;, confirmText: &quot;重新登录&quot;, cancelText: &quot;返回&quot;) &#123; (action) in\n                        Helper.relogin()\n                    &#125;\n                &#125;\n            &#125;else&#123;\n                var tempList = self.pullRequestList\n                if page == 1&#123;\n                    tempList = []\n                &#125;\n                for (_,subJson):(String, JSON) in json &#123;\n                    let userInfo = UserItemModel(id: Int(subJson[&quot;user&quot;][&quot;id&quot;].intValue), userHead: String(subJson[&quot;user&quot;][&quot;avatar_url&quot;].stringValue), userName: String(subJson[&quot;user&quot;][&quot;name&quot;].stringValue), userAccount: String(subJson[&quot;user&quot;][&quot;login&quot;].stringValue))\n                    \n                    let fromRepo = RepoModel(id: Int(subJson[&quot;head&quot;][&quot;repo&quot;][&quot;id&quot;].intValue), repoName: String(subJson[&quot;head&quot;][&quot;repo&quot;][&quot;name&quot;].stringValue), repoPath: String(subJson[&quot;head&quot;][&quot;repo&quot;][&quot;path&quot;].stringValue), repoNamespace: RepoNamespace(id: Int(subJson[&quot;head&quot;][&quot;repo&quot;][&quot;namespace&quot;][&quot;id&quot;].intValue), name: String(subJson[&quot;head&quot;][&quot;repo&quot;][&quot;namespace&quot;][&quot;name&quot;].stringValue), path: String(subJson[&quot;head&quot;][&quot;repo&quot;][&quot;namespace&quot;][&quot;path&quot;].stringValue)), repoDesc: String(subJson[&quot;head&quot;][&quot;repo&quot;][&quot;description&quot;].stringValue), repoForks: &quot;&quot;, repoStars: &quot;&quot;,repoWatches:&quot;&quot;, repoLicense:&quot;&quot;, repoLanguage: &quot;&quot;, repoPushDate:&quot;&quot;, repoIsFork: false, repoIsOpenSource: Bool(subJson[&quot;head&quot;][&quot;repo&quot;][&quot;public&quot;].boolValue), repoIssues:&quot;&quot;, repoDefaultBranch:&quot;&quot;)\n                    \n                    let toRepo = RepoModel(id: Int(subJson[&quot;base&quot;][&quot;repo&quot;][&quot;id&quot;].intValue), repoName: String(subJson[&quot;base&quot;][&quot;repo&quot;][&quot;name&quot;].stringValue), repoPath: String(subJson[&quot;base&quot;][&quot;repo&quot;][&quot;path&quot;].stringValue), repoNamespace: RepoNamespace(id: Int(subJson[&quot;base&quot;][&quot;repo&quot;][&quot;namespace&quot;][&quot;id&quot;].intValue), name: String(subJson[&quot;base&quot;][&quot;repo&quot;][&quot;namespace&quot;][&quot;name&quot;].stringValue), path: String(subJson[&quot;base&quot;][&quot;repo&quot;][&quot;namespace&quot;][&quot;path&quot;].stringValue)), repoDesc: String(subJson[&quot;base&quot;][&quot;repo&quot;][&quot;description&quot;].stringValue), repoForks: &quot;&quot;, repoStars: &quot;&quot;,repoWatches:&quot;&quot;, repoLicense:&quot;&quot;, repoLanguage: &quot;&quot;, repoPushDate:&quot;&quot;, repoIsFork: false, repoIsOpenSource: Bool(subJson[&quot;base&quot;][&quot;repo&quot;][&quot;public&quot;].boolValue), repoIssues:&quot;&quot;, repoDefaultBranch:&quot;&quot;)\n                    \n                    tempList.append(PullRequestModel(id: Int(subJson[&quot;id&quot;].intValue), prId: Int(subJson[&quot;number&quot;].intValue), prStatus: getPullRequestStatus(status: String(subJson[&quot;state&quot;].stringValue)), prTitle: String(subJson[&quot;title&quot;].stringValue), prBody: String(subJson[&quot;body&quot;].stringValue), prUser: userInfo, prFrom: fromRepo, prTo: toRepo, prTime: Helper.getDateFromString(str: String(subJson[&quot;updated_at&quot;].stringValue)), prAuthMerge: Bool(subJson[&quot;mergeable&quot;].boolValue),prFromBranch: String(subJson[&quot;head&quot;][&quot;ref&quot;].stringValue),prToBranch: String(subJson[&quot;base&quot;][&quot;ref&quot;].stringValue)))\n                &#125;\n                self.pullRequestList = tempList\n            &#125;\n            self.isRefreshing = false\n            self.isLoading = false\n            self.waitPlease = false\n        &#125; errorCallback: &#123;\n            self.isRefreshing = false\n            self.isLoading = false\n            self.waitPlease = false\n            \n        &#125;\n&#125;\n</code></pre>\n<p>然后还是pull Request的item展示了：</p>\n<pre><code class=\"line-numbers language-Swift\">struct PullRequestItemView:View&#123;\n    @State var pullRequestItem: PullRequestModel\n    @State var prFromToString:String = &quot;&quot;\n    @State var prFromToString2:String = &quot;&quot;\n    @State private var isActiveCommit:Bool = false\n    @State private var isActivePullRequest:Bool = false\n    var body: some View&#123;\n        VStack&#123;\n            VStack(alignment: .leading)&#123;\n                HStack(alignment: .top) &#123;\n                    VStack&#123;\n                        Text(getPullRequestStatusStringShow(pullRequestItem:pullRequestItem))\n                            .foregroundColor(getPullRequestColor(pullRequestItem:pullRequestItem))\n                            .padding(.vertical,1)\n                            .padding(.horizontal,3)\n                    &#125;\n                    .font(.system(size: 12))\n                    .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n                    .foregroundColor(.gray)\n                    .cornerRadius(3)\n                    VStack(alignment: .leading)&#123;\n                        Text(self.pullRequestItem.prTitle)\n                            .font(.system(size: 16))\n                            .lineLimit(1)\n                    &#125;\n                    .padding(.leading,0)\n                    Spacer()\n                    Text(self.pullRequestItem.prTime)\n                        .padding(.vertical,1)\n                        .padding(.horizontal,3)\n                        .font(.system(size: 12))\n                        .foregroundColor(.gray)\n                &#125;\n                .padding(5)\n                HStack(alignment: .center)&#123;\n                    Text(self.pullRequestItem.prBody)\n                        .font(.system(size: 14))\n                        .foregroundColor(.gray)\n                        .lineLimit(1)\n                        .padding(.top,10)\n                    Spacer()\n                &#125;\n                HStack&#123;\n                    VStack(alignment: .leading)&#123;\n                        Text(prFromToString)\n                            .padding(.vertical,0)\n                            .padding(.horizontal,3)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .lineLimit(1)\n                        \n                        Text(prFromToString2)\n                            .padding(.vertical,0)\n                            .padding(.horizontal,3)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .lineLimit(1)\n                    &#125;\n                    Spacer()\n                &#125;\n            &#125;\n            .padding(10)\n        &#125;\n        .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n        .cornerRadius(10)\n        .padding(.horizontal,5)\n        .sheet(isPresented: $isActivePullRequest,onDismiss: &#123;\n        &#125;)&#123;\n            PullRequestDetailView(pullRequestItem: $pullRequestItem).foregroundColor(.white)\n        &#125;\n        .onTapGesture &#123;\n            self.isActivePullRequest = true\n        &#125;\n        .contextMenu(ContextMenu &#123;\n            if pullRequestItem.prAutoMerge &amp;&amp; pullRequestItem.prStatus == PullRequestStatus.open &#123;\n                Button(action: &#123;\n                &#125;) &#123;\n                    HStack&#123;\n                        Image(systemName: &quot;mail.and.text.magnifyingglass&quot;).scaleEffect(1, anchor: .center)\n                        Spacer()\n                        Text(&quot;审查通过&quot;)\n                    &#125;\n                &#125;\n                Button(action: &#123;\n                &#125;) &#123;\n                    HStack&#123;\n                        Image(systemName: &quot;wrench.and.screwdriver&quot;).scaleEffect(1, anchor: .center)\n                        Spacer()\n                        Text(&quot;测试通过&quot;)\n                    &#125;\n                &#125;\n                Button(action: &#123;\n                &#125;) &#123;\n                    HStack&#123;\n                        Image(systemName: &quot;shuffle&quot;).scaleEffect(1, anchor: .center)\n                        Spacer()\n                        Text(&quot;确认合并&quot;)\n                    &#125;\n                &#125;\n            &#125;\n            Divider()\n            Button(action: &#123;\n                self.isActiveCommit = true\n            &#125;) &#123;\n                HStack&#123;\n                    Image(systemName: &quot;icloud.and.arrow.up&quot;).scaleEffect(1, anchor: .center)\n                    Spacer()\n                    Text(&quot;提交记录&quot;)\n                &#125;\n            &#125;\n            .sheet(isPresented: $isActiveCommit,onDismiss: &#123;\n            &#125;)&#123;\n                CommitView(pullRequestItem: pullRequestItem).foregroundColor(.white)\n            &#125;\n        &#125;)\n        .onAppear()&#123;\n            if pullRequestItem.prFrom.repoNamespace.path == pullRequestItem.prTo.repoNamespace.path &#123;\n                self.prFromToString = &quot;从 &quot; + pullRequestItem.prFromBranch + &quot;分支 到 &quot; + pullRequestItem.prToBranch + &quot;分支&quot;\n                self.prFromToString2 = &quot;这是你的自己的合并请求&quot;\n            &#125;else&#123;\n                self.prFromToString = &quot;从 &quot; + pullRequestItem.prFrom.repoNamespace.name + &quot;/&quot; + pullRequestItem.prFrom.repoName + &quot;:&quot; + pullRequestItem.prFromBranch\n                self.prFromToString2 = &quot;到 &quot; + pullRequestItem.prTo.repoNamespace.name + &quot;/&quot; + pullRequestItem.prTo.repoName + &quot;:&quot; + pullRequestItem.prToBranch\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"3-5-查看Issues\"><a href=\"#3-5-查看Issues\" class=\"headerlink\" title=\"3.5 查看Issues\"></a>3.5 查看Issues</h3><p>body定义：</p>\n<pre><code class=\"line-numbers language-Swift\"> var body: some View &#123;\n    LoadingView(isLoading:self.$isLoading,message: self.$message,isModal:self.$isModal) &#123;\n        VStack&#123;\n            ZStack&#123;\n                if issuesList.count == 0 &amp;&amp; !isLoading &#123;\n                    VStack&#123;\n                        Image(systemName: &quot;doc.text.magnifyingglass&quot;)\n                            .scaleEffect(3, anchor: .center)\n                        Text(&quot;暂无查询到的Issues&quot;).padding(.top,30)\n                    &#125;\n                &#125;\n                RefreshView(refreshing: $isRefreshing, action: &#123;\n                    self.page = 1\n                    self.getIssueList(page: self.page)\n                &#125;) &#123;\n                    LazyVStack&#123;\n                        ForEach(self.issuesList)&#123; item in\n                            NavigationLink(destination: IssueItemView(issueItem: item)) &#123;\n                                IssueItemView(issueItem: item)\n                                    .onAppear()&#123;\n                                        if !waitPlease &amp;&amp; item.id == issuesList[issuesList.count - 1].id &#123;\n                                            self.page = self.page + 1\n                                            self.getIssueList(page: self.page)\n                                        &#125;\n                                    &#125;\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n            if self.repoPath != &quot;&quot; &#123;\n                Spacer()\n                HStack&#123;\n                    Spacer()\n                    Button &#123;\n                        self.isInserIssueShow = true\n                    &#125; label: &#123;\n                        Image(systemName: &quot;square.and.pencil&quot;)\n                            .scaleEffect(1.2, anchor: .center)\n                    &#125;\n                    .padding(12)\n                    .background(Color.yellow)\n                    .foregroundColor(Color.black)\n                    .cornerRadius(100)\n                    .sheet(isPresented: $isInserIssueShow) &#123;\n                        let arr = self.repoPath.components(separatedBy: &quot;/&quot;)\n                        IssueInsertView(repoNamespacePath: arr[0], repoPath: arr[1])\n                    &#125;\n                &#125;\n                .padding(.trailing,20)\n            &#125;\n        &#125;\n    &#125;\n    .padding(.top,5)\n    .navigationBarTitle(Text(title!), displayMode: .inline)\n    .navigationBarItems(\n        trailing:\n            HStack &#123;\n                Button(action: &#123;\n                    self.isFilterShow.toggle()\n                &#125;) &#123;\n                    Image(systemName: &quot;rectangle.and.text.magnifyingglass&quot;)\n                        \n                        .scaleEffect(1, anchor: .center)\n                &#125;\n            &#125;\n            .sheet(isPresented: $isFilterShow,onDismiss: &#123;\n                self.isLoading = true\n                self.page = 1\n                self.getIssueList(page: self.page)\n            &#125;)&#123;\n                IssueFilterView()\n                    .modifier(DisableModalDismiss(disabled: false))\n            &#125;\n    )\n    .onAppear()&#123;\n        localConfig.setValue(&quot;all&quot;, forKey: giteeConfig.issue_filter)\n        localConfig.setValue(&quot;open&quot;, forKey: giteeConfig.issue_state)\n        localConfig.setValue(&quot;created&quot;, forKey: giteeConfig.issue_sort)\n        localConfig.setValue(&quot;desc&quot;, forKey: giteeConfig.issue_direction)\n        self.page = 1\n        self.getIssueList(page: self.page)\n    &#125;\n&#125;\n</code></pre>\n<p>可见时请求列表：</p>\n<pre><code class=\"line-numbers language-Swift\">func getIssueList(page: Int)&#123;\n    if self.waitPlease &#123; return &#125;\n    self.waitPlease = true\n    if issuesList.count == 0 &#123;\n        self.isLoading = true\n    &#125;\n    let state = localConfig.string(forKey: giteeConfig.issue_state)\n    let filter = localConfig.string(forKey: giteeConfig.issue_filter)\n    let direction = localConfig.string(forKey: giteeConfig.issue_direction)\n    let sort = localConfig.string(forKey: giteeConfig.issue_sort)\n    var url = &quot;user/issues?page=&quot; + String(page)\n    \n    if self.repoPath != &quot;&quot; &#123;\n        url = &quot;repos/&quot; + self.repoPath + &quot;/issues?page=&quot; + String(page)\n    &#125;\n    \n    url = url + &quot;&amp;state=&quot; + state!\n    url = url + &quot;&amp;filter=&quot; + filter!\n    url = url + &quot;&amp;direction=&quot; + direction!\n    url = url + &quot;&amp;sort=&quot; + sort!\n    \n    \n    HttpRequest(url: url, withAccessToken: true)\n        .doGet &#123; (value) in\n            let json = JSON(value)\n            if json[&quot;message&quot;].string != nil &#123;\n                print(&quot;error&quot;)\n                DispatchQueue.main.async &#123;\n                    UIAlertController.confirm(message: json[&quot;message&quot;].stringValue, title: &quot;发生错误&quot;, confirmText: &quot;重新登录&quot;, cancelText: &quot;返回&quot;) &#123; (action) in\n                        Helper.relogin()\n                    &#125;\n                &#125;\n            &#125;else&#123;\n                var tempList = self.issuesList\n                if page == 1&#123;\n                    tempList = []\n                &#125;\n                for (_,subJson):(String, JSON) in json &#123;\n                    let repoNamespace = RepoNamespace(id: Int(subJson[&quot;repository&quot;][&quot;namespace&quot;][&quot;id&quot;].stringValue)!, name: String(subJson[&quot;repository&quot;][&quot;namespace&quot;][&quot;name&quot;].stringValue), path:  String(subJson[&quot;repository&quot;][&quot;namespace&quot;][&quot;path&quot;].stringValue))\n                    let repoInfo = RepoModel(id: Int(subJson[&quot;repository&quot;][&quot;id&quot;].stringValue)!, repoName: String(subJson[&quot;repository&quot;][&quot;name&quot;].stringValue),repoPath:  String(subJson[&quot;repository&quot;][&quot;path&quot;].stringValue),repoNamespace: repoNamespace, repoDesc:  String(subJson[&quot;repository&quot;][&quot;description&quot;].stringValue), repoForks:  String(subJson[&quot;repository&quot;][&quot;forks_count&quot;].stringValue), repoStars:  String(subJson[&quot;repository&quot;][&quot;stargazers_count&quot;].stringValue), repoWatches:  String(subJson[&quot;repository&quot;][&quot;watchers_count&quot;].stringValue), repoLicense:  String(subJson[&quot;repository&quot;][&quot;license&quot;].stringValue), repoLanguage:  String(subJson[&quot;repository&quot;][&quot;language&quot;].stringValue), repoPushDate:  String(subJson[&quot;repository&quot;][&quot;pushed_at&quot;].stringValue), repoIsFork:  Bool(subJson[&quot;repository&quot;][&quot;fork&quot;].boolValue), repoIsOpenSource:  Bool(subJson[&quot;repository&quot;][&quot;public&quot;].boolValue), repoIssues:  String(subJson[&quot;repository&quot;][&quot;open_issues_count&quot;].stringValue), repoDefaultBranch:  String(subJson[&quot;repository&quot;][&quot;default_branch&quot;].stringValue))\n                    let userInfo = UserItemModel(id: Int(subJson[&quot;user&quot;][&quot;id&quot;].stringValue)!, userHead: String(subJson[&quot;user&quot;][&quot;avatar_url&quot;].stringValue), userName: String(subJson[&quot;user&quot;][&quot;name&quot;].stringValue), userAccount: String(subJson[&quot;user&quot;][&quot;login&quot;].stringValue))\n                    let issueInfo = IssueModel(id: Int(subJson[&quot;id&quot;].stringValue)!, issueId: String(subJson[&quot;number&quot;].stringValue), issueTitle: String(subJson[&quot;title&quot;].stringValue), issueTime: Helper.getDateFromString(str: String(subJson[&quot;created_at&quot;].stringValue)), issueDesc: String(subJson[&quot;body&quot;].stringValue), issueStatus: getIssueStatus(status: subJson[&quot;state&quot;].stringValue), repoInfo:repoInfo, userInfo: userInfo)\n                    tempList.append(\n                        issueInfo\n                    )\n                &#125;\n                self.issuesList = tempList\n            &#125;\n            self.isRefreshing = false\n            self.isLoading = false\n            self.waitPlease = false\n        &#125; errorCallback: &#123;\n            self.isRefreshing = false\n            self.isLoading = false\n            self.waitPlease = false\n            \n        &#125;\n&#125;\n</code></pre>\n<p>最后就是具体的IssueItemView了。</p>\n<pre><code class=\"line-numbers language-Swift\">struct IssueItemView:View&#123;\n    @State var issueItem: IssueModel\n    @State private var isActiveIsssueDetail:Bool = false\n    @State private var isActiveRepoDetail:Bool = false\n    var body: some View&#123;\n        ZStack&#123;\n            VStack&#123;\n                NavigationLink(destination: RepoDetailView(repoFullPath: issueItem.repoInfo.repoNamespace.path + &quot;/&quot; + issueItem.repoInfo.repoPath), isActive: $isActiveRepoDetail) &#123; EmptyView() &#125;\n            &#125;\n            .frame(width: 0, height: 0)\n            .opacity(0)\n            VStack&#123;\n                VStack(alignment: .leading)&#123;\n                    HStack(alignment: .top) &#123;\n                        Image(systemName:getIssueIcon(status: issueItem.issueStatus))\n                            .scaleEffect(1, anchor: .center)\n                            .foregroundColor(getIssueColor(status: issueItem.issueStatus))\n                        VStack(alignment: .leading)&#123;\n                            Text(issueItem.issueTitle)\n                                .font(.system(size: 16))\n                                .lineLimit(1)\n                        &#125;\n                        Spacer()\n                        Text(issueItem.issueTime)\n                            .padding(.vertical,1)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                        \n                    &#125;\n                    .padding(5)\n                    HStack&#123;\n                        Text(issueItem.repoInfo.repoName)\n                            .padding(.leading,35)\n                            .font(.system(size: 12))\n                            .foregroundColor(Color(hex: 0xCCCCCC))\n                        Text(issueItem.issueDesc)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .lineLimit(1)\n                    &#125;\n                    HStack&#123;\n                        Image(systemName:&quot;person.circle&quot;)\n                            .scaleEffect(0.7, anchor: .center)\n                            .foregroundColor(.gray)\n                            .padding(.leading,30)\n                        Text(issueItem.userInfo.userName)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .padding(.leading,-8)\n                        Spacer()\n                    &#125;\n                    .padding(.top,5)\n                &#125;\n                .padding(10)\n            &#125;\n            .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n            .cornerRadius(10)\n            .padding(.horizontal,5)\n            .padding(.bottom,-3)\n            .sheet(isPresented: self.$isActiveIsssueDetail) &#123;\n                self.reloadIssue()\n            &#125; content: &#123;\n                IssuesDetailView(issueItem: $issueItem)\n                    .foregroundColor(.white)\n            &#125;\n            .onTapGesture &#123;\n                self.isActiveIsssueDetail = true\n            &#125;\n            .contextMenu(ContextMenu &#123;\n                if issueItem.issueStatus != IssueStatus.open &#123;\n                    Button(action: &#123;\n                        self.changeIssueStatus(issueItem: issueItem,  issueStatus: IssueStatus.open)\n                    &#125;) &#123;\n                        HStack&#123;\n                            Image(systemName: &quot;moon.circle&quot;).scaleEffect(1, anchor: .center)\n                            Spacer()\n                            Text(&quot;标记为已开启&quot;)\n                        &#125;\n                    &#125;\n                &#125;\n                if issueItem.issueStatus != IssueStatus.progressing &#123;\n                    Button(action: &#123;\n                        self.changeIssueStatus(issueItem: issueItem,  issueStatus: IssueStatus.progressing)\n                    &#125;) &#123;\n                        HStack&#123;\n                            Image(systemName: &quot;timer&quot;).scaleEffect(1, anchor: .center)\n                            Spacer()\n                            Text(&quot;标记为进行中&quot;)\n                        &#125;\n                    &#125;\n                &#125;\n                if issueItem.issueStatus != IssueStatus.rejected &#123;\n                    Button(action: &#123;\n                        UIAlertController.alert(message: &quot;请期待Gitee开放这个API吧~&quot;, title: &quot;即将上线&quot;, confirmText: &quot;安排&quot;)\n                    &#125;) &#123;\n                        HStack&#123;\n                            Image(systemName: &quot;xmark.circle&quot;).scaleEffect(1, anchor: .center)\n                            Spacer()\n                            Text(&quot;标记为已拒绝&quot;)\n                        &#125;\n                    &#125;\n                &#125;\n                if issueItem.issueStatus != IssueStatus.closed &#123;\n                    Button(action: &#123;\n                        self.changeIssueStatus(issueItem: issueItem, issueStatus: IssueStatus.closed)\n                    &#125;) &#123;\n                        HStack&#123;\n                            Image(systemName: &quot;checkmark.circle&quot;).scaleEffect(1, anchor: .center)\n                            Spacer()\n                            Text(&quot;标记为完成&quot;)\n                        &#125;\n                    &#125;\n                &#125;\n                Divider()\n                Button(action: &#123;\n                    self.isActiveRepoDetail = true\n                &#125;) &#123;\n                    HStack&#123;\n                        Image(systemName: &quot;archivebox.circle&quot;).scaleEffect(1, anchor: .center)\n                        Spacer()\n                        Text(&quot;进入所属仓库&quot;)\n                    &#125;\n                &#125;\n            &#125;)\n        &#125;\n    &#125;\n</code></pre>\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4 总结\"></a>4 总结</h2><ul>\n<li><p>这里学会了Swift初始化配置，可以简化其它流程，只需要继承App类。</p>\n</li>\n<li><p>然后这里学会使用类似Flutter的组件，HStack,VStack,ZSack，Spacer,Text，Image这一类基础组件。</p>\n</li>\n<li><p>网络请求的最好自己封装一个HttpRequest类，动态配置各种参数。</p>\n</li>\n</ul>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-项目地址\"><a href=\"#1-项目地址\" class=\"headerlink\" title=\"1 项目地址\"></a>1 项目地址</h2><blockquote>\n<p><a href=\"https://gitee.com/open-gitee/gitee_ios\">https://gitee.com/open-gitee/gitee_ios</a><br>Gitee基于SwiftUI和OpenApi的iOS客户端项目。</p>\n</blockquote>\n<h2 id=\"2-项目截图\"><a href=\"#2-项目截图\" class=\"headerlink\" title=\"2 项目截图\"></a>2 项目截图</h2><table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=1.png></td>\n<td><img src=2.png></td>\n<td><img src=3.png></td>\n</tr>\n<tr>\n<td><img src=4.png></td>\n<td><img src=5.png></td>\n<td><img src=6.png></td>\n</tr>\n</tbody></table>\n<h2 id=\"3-首页架构\"><a href=\"#3-首页架构\" class=\"headerlink\" title=\"3 首页架构\"></a>3 首页架构</h2><p>这里是底部3个Tab，首页展示一个工作台消息中心，你的团队的入库。应该是写死的布局。</p>\n<p>第二个tab是好友动态，这里展示一个列表，展示动态列表。</p>\n<p>第三个tab是设置页，上方是头像，然后是关注粉丝star啥的。</p>\n<p>关于App和Scene代码结构，可以参考这篇文章：<br><a href=\"https://zhuanlan.zhihu.com/p/152624613\">SwiftUI2.0 —— App、Scene及新的代码结构（一）</a>。</p>\n<p>应用初始化代码：</p>\n<pre><code class=\"line-numbers language-Swift\">@main\nstruct GiteeApp: App &#123;\n    var body: some Scene &#123;\n        WindowGroup &#123;\n            TabBarView(selectedBarIndex: 0)\n                .preferredColorScheme(.dark)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里body就是首页了。<br>App，Scene，WindowGroup都是系统类。</p>\n<p>里面的TabBarView是自定义View来的：</p>\n<pre><code class=\"line-numbers language-Swift\">struct TabBarView: View &#123;\n    @State var selectedBarIndex:Int\n    \n    var body: some View &#123;\n        NavigationView&#123;\n            TabView(selection: $selectedBarIndex) &#123;\n                HomeView()\n                .tabItem &#123;\n                    Image(systemName:&quot;briefcase&quot;)\n                    Text(&quot;首页&quot;)\n                &#125;\n                    .tag(0)\n                ActivityView()\n                .tabItem &#123;\n                    Image(systemName:&quot;stopwatch&quot;)\n                    Text(&quot;动态&quot;)\n                &#125;\n                    .tag(1)\n//                ExploreView()\n//                .tabItem &#123;\n//                    Image(systemName:&quot;opticaldisc&quot;)\n//                    Text(&quot;发现&quot;)\n//                &#125;\n//                    .tag(2)\n                SettingView()\n                .tabItem &#123;\n                    Image(systemName:&quot;gearshape&quot;)\n                    Text(&quot;设置&quot;)\n                &#125;\n                    .tag(3)\n            &#125;\n            .navigationBarTitle(getNavBarTitle(),displayMode: getNavBarModel())\n            .navigationBarHidden(self.selectedBarIndex==3)\n            .foregroundColor(.white)\n            .accentColor(.white) //这里修改文字颜色\n        &#125;\n        .navigationViewStyle(StackNavigationViewStyle())\n        .accentColor(.white)\n        .foregroundColor(.white)\n        .preferredColorScheme(.dark)\n    &#125;\n</code></pre>\n<p>这里TabView其实就是定义的底部Tab，然后item点击后是配置在中间的。<br>比如HomeView就是首页了，ActivityView应该就是动态页了，SettingView就是设置页了。</p>\n<pre><code class=\"line-numbers language-Swift\">\nfunc getNavBarModel() -&gt; NavigationBarItem.TitleDisplayMode&#123;\n    if self.selectedBarIndex == 0 &#123;\n        return .large\n    &#125;\n    if self.selectedBarIndex == 1 &#123;\n        return .inline\n    &#125;\n    if self.selectedBarIndex == 2 &#123;\n        return .large\n    &#125;\n    if self.selectedBarIndex == 3 &#123;\n        return .large\n    &#125;\n    return .inline\n&#125;\nfunc getNavBarTitle() -&gt; String&#123;\n    if self.selectedBarIndex == 0 &#123;\n        return &quot;Gitee&quot;\n    &#125;\n    if self.selectedBarIndex == 1 &#123;\n        return &quot;好友动态&quot;\n    &#125;\n    if self.selectedBarIndex == 2 &#123;\n        return &quot;发现&quot;\n    &#125;\n    if self.selectedBarIndex == 3&#123;\n        return &quot;设置&quot;\n    &#125;\n    return  &quot;&quot;\n&#125;\n</code></pre>\n<p>这里配置tab具体数据。<br><img src=\"/./iOS-swift-Gitee%E5%AE%A2%E6%88%B7%E7%AB%AF-%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%80/tab1.png\"><br><img src=tab1.png><br>这里Form是表格。<br>Section是组别。<br>这里有一个NavigationLink是item1就是第一个item，这里显示代码仓库。颜色和icon都可以设置的。</p>\n<p> 但是这里的HomeListItem是自己定义的哦。</p>\n<pre><code class=\"line-numbers language-Swift\">struct HomeListItem : View &#123;\n   @State var title: String\n   @State var icon: String\n   @State var color: Color\n   \n   var body: some View &#123;\n       HStack(spacing: 15)&#123;\n           Image(systemName:icon)\n               .scaleEffect(1.5, anchor: .center)\n               .foregroundColor(color)\n           Text(title).font(.system(size:16))\n       &#125;\n       .padding(.horizontal, 5)\n       .frame( height: 48)\n       .cornerRadius(10)\n   &#125;\n&#125;\n</code></pre>\n<p>这个HStack是系统的，估计类似于Flutter里面的Stack吧。<br>这里右侧箭头是咋来的呢？<br>原来是</p>\n<pre><code class=\"line-numbers language-Swift\">var body: some View &#123;\n    Form &#123;\n        Section(header: Text(&quot;工作台&quot;)) &#123;\n            NavigationLink(destination: RepoView()) &#123;\n                HomeListItem(title: &quot;代码仓库&quot;,icon:&quot;archivebox.circle&quot;, color: Color(hex: 0x7699ec))\n            &#125;\n//                NavigationLink(destination:  PullRequestView()) &#123;\n//                    HomeListItem(title: &quot;Pull Request&quot;,icon:&quot;shuffle.circle&quot;, color: Color(hex: 0x00b392))\n//                &#125;\n            NavigationLink(destination:  IssuesView()) &#123;\n                HomeListItem(title: &quot;Issues&quot;,icon:&quot;exclamationmark.circle&quot;, color: Color(hex: 0xfe665b))\n            &#125;\n        &#125;\n</code></pre>\n<p>这里面的NavigationLink自带的箭头哦。</p>\n<h3 id=\"3-2-仓库页面\"><a href=\"#3-2-仓库页面\" class=\"headerlink\" title=\"3.2 仓库页面\"></a>3.2 仓库页面</h3><p>前面用了一个NavigationLink包裹，那么点击这个之后应该是跳转到目标页面。</p>\n<p>这里是先跳转到你的仓库页面。<br>先看看哈：</p>\n<pre><code class=\"line-numbers language-Swift\">var body: some View &#123;\n    LoadingView(isLoading:self.$isLoading,message: self.$message,isModal:self.$isModal) &#123;\n        ZStack&#123;\n            if repoList.count == 0 &amp;&amp; !isLoading &#123;\n                VStack&#123;\n                    Image(systemName: &quot;doc.text.magnifyingglass&quot;)\n                        .scaleEffect(3, anchor: .center)\n                    Text(&quot;暂无查询到的仓库&quot;).padding(.top,30)\n                &#125;\n            &#125;\n            RefreshView(refreshing: $isRefreshing, action: &#123;\n                self.page = 1\n                self.getRepoList(page: self.page)\n            &#125;) &#123;\n                LazyVStack&#123;\n                    ForEach(self.repoList)&#123; item in\n                        NavigationLink(destination: RepoDetailView(repoFullPath: item.repoNamespace.path + &quot;/&quot; + item.repoPath)) &#123;\n                            RepoItemView(repoItem: item)\n                                .onAppear()&#123;\n                                    if !waitPlease &amp;&amp; item.id == repoList[repoList.count - 1].id &#123;\n                                        self.page = self.page + 1\n                                        self.getRepoList(page: self.page)\n                                    &#125;\n                                &#125;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    .sheet(isPresented: $isLoginShow,onDismiss: &#123;\n        UserModel().getMyInfo &#123; (userInfo) in\n            self.page = 1\n            self.getRepoList(page: self.page)\n        &#125; error: &#123;\n            self.isLoginShow.toggle()\n        &#125;\n    &#125;)&#123;\n        LoginView()\n            .modifier(DisableModalDismiss(disabled: true))\n    &#125;\n    .padding(.top,5)\n    .navigationBarTitle(Text(naviTitle), displayMode: .inline)\n    .navigationBarItems(\n        trailing:\n            HStack &#123;\n                Button(action: &#123;\n                    self.isFilterShow.toggle()\n                &#125;) &#123;\n                    Image(systemName: &quot;rectangle.and.text.magnifyingglass&quot;)\n                        \n                        .scaleEffect(1, anchor: .center)\n                &#125;\n            &#125;\n            .sheet(isPresented: $isFilterShow,onDismiss: &#123;\n                self.isLoading = true\n                self.page = 1\n                self.getRepoList(page: self.page)\n            &#125;)&#123;\n                RepoFilterView(showListFrom: self.showListFrom)\n                    .modifier(DisableModalDismiss(disabled: false))\n            &#125;\n    )\n    .onAppear()&#123;\n        switch self.showListFrom &#123;\n        case ShowRepoListFrom.fromWatches:\n            self.naviTitle = &quot;Watch的仓库&quot;\n        case ShowRepoListFrom.fromStars:\n            self.naviTitle = &quot;Star的仓库&quot;\n        default:\n            self.naviTitle = &quot;你的仓库&quot;\n        &#125;\n        \n        localConfig.setValue(&quot;all&quot;, forKey: giteeConfig.repo_type)\n        localConfig.setValue(&quot;pushed&quot;, forKey: giteeConfig.repo_sort)\n        localConfig.setValue(&quot;desc&quot;, forKey: giteeConfig.repo_direction)\n        self.page = 1\n        self.getRepoList( page: self.page)\n    &#125;\n&#125;\n</code></pre>\n<p>loading视图：</p>\n<pre><code class=\"line-numbers language-Swift\">struct LoadingView&lt;Content&gt;: View where Content: View &#123;\n    \n    @Binding var isLoading: Bool\n    @Binding var message:String\n    @Binding var isModal: Bool\n    @State var isAnimating: Bool = true\n    var content: () -&gt; Content\n    \n    var body: some View &#123;\n        GeometryReader &#123; geometry in\n            ZStack(alignment: .center) &#123;\n                self.content()\n                    .disabled(self.isModal)\n                    .blur(radius: self.isModal ? 10 : 0)\n                VStack &#123;\n                    Text(self.message)\n                        .padding(.bottom,20)\n                    ActivityIndicatorLoading(isAnimating: self.$isAnimating, style: .large)\n                &#125;\n                    \n                .frame(width: geometry.size.width / 2,\n                       height: geometry.size.height / 5)\n                    .background(Color.secondary.colorInvert())\n                    .foregroundColor(Color.primary)\n                    .cornerRadius(20)\n                    .opacity(self.isLoading ? 1 : 0)\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里的Loading效果是ActivityIndicatorLoading这个实现的。这个是自定义的哦。<br>继续走这个：</p>\n<pre><code class=\"line-numbers language-Swift\">struct ActivityIndicatorLoading: UIViewRepresentable &#123;\n    \n    @Binding var isAnimating: Bool\n    let style: UIActivityIndicatorView.Style\n    \n    func makeUIView(context: UIViewRepresentableContext&lt;ActivityIndicatorLoading&gt;) -&gt; UIActivityIndicatorView &#123;\n        return UIActivityIndicatorView(style: style)\n    &#125;\n    \n    func updateUIView(_ uiView: UIActivityIndicatorView, context: UIViewRepresentableContext&lt;ActivityIndicatorLoading&gt;) &#123;\n        isAnimating ? uiView.startAnimating() : uiView.stopAnimating()\n    &#125;\n&#125;\n</code></pre>\n<p>原来是UIActivityIndicatorView这个类来实现loading效果的。</p>\n<p>然后这里有个自定义刷新视图。<br>可以参考下这篇文章：<a href=\"https://swiftui-lab.com/scrollview-pull-to-refresh/\">https://swiftui-lab.com/scrollview-pull-to-refresh/</a>。</p>\n<pre><code class=\"line-numbers language-Swift\">LazyVStack&#123;\n    ForEach(self.repoList)&#123; item in\n        NavigationLink(destination: RepoDetailView(repoFullPath: item.repoNamespace.path + &quot;/&quot; + item.repoPath)) &#123;\n            RepoItemView(repoItem: item)\n                .onAppear()&#123;\n                    if !waitPlease &amp;&amp; item.id == repoList[repoList.count - 1].id &#123;\n                        self.page = self.page + 1\n                        self.getRepoList(page: self.page)\n                    &#125;\n                &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这里就是刷新器里面展示列表。</p>\n<p>列表的item是这个RepoItemView:</p>\n<pre><code class=\"line-numbers language-Swift\">struct RepoItemView:View&#123;\n    @State var repoItem: RepoModel\n    @State private var isActiveCommit:Bool = false\n    @State private var isActivePullRequest:Bool = false\n    @State private var isActiveIssues:Bool = false\n    \n    var body: some View&#123;\n        VStack&#123;\n            VStack&#123;\n                NavigationLink(destination: CommitView(repoFullPath: repoItem.repoNamespace.path + &quot;/&quot; + repoItem.repoPath,repoDefaultBranch: repoItem.repoDefaultBranch), isActive: $isActiveCommit) &#123; EmptyView() &#125;\n                NavigationLink(destination: PullRequestView(repoFullPath: repoItem.repoNamespace.path + &quot;/&quot; + repoItem.repoPath), isActive: $isActivePullRequest) &#123; EmptyView() &#125;\n                NavigationLink(destination: IssuesView(repoPath: repoItem.repoNamespace.path + &quot;/&quot; + repoItem.repoPath),isActive: $isActiveIssues) &#123; EmptyView() &#125;\n            &#125;\n            .frame(width: 0, height: 0)\n            .opacity(0)\n            VStack(alignment: .leading)&#123;\n                HStack(alignment: .top) &#123;\n                    if !self.repoItem.repoIsOpenSource &#123;\n                        Image(systemName: &quot;lock.square.fill&quot;)\n                            .foregroundColor(Color(hex: 0xffc55a))\n                            .padding(.trailing,-5)\n                            .scaleEffect(1, anchor: .center)\n                    &#125;\n                    VStack(alignment: .leading)&#123;\n                        Text(self.repoItem.repoNamespace.name + &quot;/&quot; + self.repoItem.repoName)\n                            .font(.system(size: 16))\n                            .lineLimit(1)\n                    &#125;\n                    Spacer()\n                    Text(self.repoItem.repoPushDate)\n                        .font(.system(size: 12))\n                        .foregroundColor(.gray)\n                    \n                &#125;\n                .padding(5)\n                Text(self.repoItem.repoDesc == &quot;&quot; ? &quot;很尴尬,该项目暂无介绍...&quot; : self.repoItem.repoDesc)\n                    .font(.system(size: 14))\n                    .foregroundColor(.gray)\n                    .lineLimit(3)\n                    .multilineTextAlignment(.leading)\n                    .padding(.top,10)\n                    .padding(.leading,5)\n                    .fixedSize(horizontal: false, vertical: true)\n                Spacer()\n                HStack&#123;\n                    if self.repoItem.repoLanguage != &quot;&quot; &#123;\n                        VStack&#123;\n                            Text(self.repoItem.repoLanguage)\n                                .padding(.vertical,1)\n                                .padding(.horizontal,3)\n                        &#125;\n                        .font(.system(size: 12))\n                        .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n                        .foregroundColor(.gray)\n                        .cornerRadius(3)\n                    &#125;\n                    if self.repoItem.repoLicense != &quot;&quot; &#123;\n                        VStack&#123;\n                            Text(self.repoItem.repoLicense)\n                                .padding(.vertical,1)\n                                .padding(.horizontal,3)\n                        &#125;\n                        .font(.system(size: 12))\n                        .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n                        .foregroundColor(.gray)\n                        .cornerRadius(3)\n                    &#125;\n                    Spacer()\n                    HStack&#123;\n                        Image(systemName: &quot;star.fill&quot;)\n                            .foregroundColor(.gray)\n                            .scaleEffect(0.6, anchor: .center)\n                            .padding(0)\n                        Text(self.repoItem.repoStars)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .padding(0)\n                            .padding(.leading,-12)\n                    &#125;\n                    HStack&#123;\n                        Image(systemName: &quot;eye.fill&quot;)\n                            .foregroundColor(.gray)\n                            .scaleEffect(0.6, anchor: .center)\n                            .padding(0)\n                        Text(self.repoItem.repoWatches)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .padding(0)\n                            .padding(.leading,-12)\n                    &#125;\n                    .padding(.horizontal,-8)\n                    HStack&#123;\n                        Image(systemName: &quot;arrowshape.turn.up.backward.2.fill&quot;)\n                            .foregroundColor(.gray)\n                            .scaleEffect(0.7, anchor: .center)\n                            .padding(0)\n                        Text(self.repoItem.repoForks)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .padding(0)\n                            .padding(.leading,-12)\n                    &#125;\n                &#125;\n                .padding(.top,5)\n            &#125;\n            .padding(10)\n        &#125;\n        .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n        .cornerRadius(10)\n        .padding(.horizontal,5)\n        .padding(.bottom,5)\n        //        .swipeCell(\n        //            cellPosition: .both,\n        //            leftSlot: nil,\n        //            rightSlot: SwipeCellSlot(\n        //                slots:\n        //                    [\n        //                        SwipeCellButton(\n        //                            buttonStyle: .titleAndImage,\n        //                            title: &quot;Mark&quot;,\n        //                            systemImage: &quot;bookmark&quot;,\n        //                            titleColor: .white,\n        //                            imageColor: .white,\n        //                            view: nil,\n        //                            backgroundColor: .green,\n        //                            action: &#123;\n        //                                print(&quot;123&quot;)\n        //                            &#125;,\n        //                            feedback:true\n        //                        )\n        //                    ]\n        //            )\n        //        )\n        .contextMenu(ContextMenu &#123;\n            Button(action: &#123;\n                self.isActiveCommit = true\n            &#125;) &#123;\n                HStack&#123;\n                    Image(systemName: &quot;icloud.and.arrow.up&quot;).scaleEffect(1, anchor: .center)\n                    Spacer()\n                    Text(&quot;提交记录&quot;)\n                &#125;\n            &#125;\n            Divider()\n            Button(action: &#123;\n                self.isActivePullRequest = true\n            &#125;) &#123;\n                HStack&#123;\n                    Image(systemName: &quot;shuffle.circle&quot;).scaleEffect(1, anchor: .center)\n                    Spacer()\n                    Text(&quot;Pull Requests&quot;)\n                &#125;\n            &#125;\n            Button(action: &#123;\n                self.isActiveIssues = true\n            &#125;) &#123;\n                HStack&#123;\n                    Image(systemName: &quot;exclamationmark.circle&quot;).scaleEffect(1, anchor: .center)\n                    Spacer()\n                    Text(&quot;查看Issues&quot;)\n                &#125;\n            &#125;\n        &#125;)\n    &#125;\n&#125;\n</code></pre>\n<p>长按会弹出菜单，提交记录，Pull Requests Issues都是菜单项。<br>注意到这里的菜单是一个Button，里面配置了action，然后在顶部配置了NavigationLink，实现跳转。</p>\n<h3 id=\"3-3-提交记录\"><a href=\"#3-3-提交记录\" class=\"headerlink\" title=\"3.3 提交记录\"></a>3.3 提交记录</h3><p>比如点击了提交记录：<br>这里显示body:</p>\n<pre><code class=\"line-numbers language-Swift\">var body: some View &#123;\n    LoadingView(isLoading:self.$isLoading,message: self.$message,isModal:self.$isModal) &#123;\n        ZStack&#123;\n            if commitList.count == 0 &amp;&amp; !isLoading &#123;\n                VStack&#123;\n                    Image(systemName: &quot;doc.text.magnifyingglass&quot;)\n                        .scaleEffect(3, anchor: .center)\n                    Text(&quot;暂无查询到的提交&quot;).padding(.top,30)\n                &#125;\n            &#125;\n            RefreshView(refreshing: $isRefreshing, action: &#123;\n                self.page = 1\n                self.getCommitList(page: self.page)\n            &#125;) &#123;\n                LazyVStack&#123;\n                    ForEach(self.commitList)&#123; item in\n                        CommitItemView(commitItem: item, repoFullPath: self.repoFullPath!)\n                            .onAppear()&#123;\n                                if !waitPlease &amp;&amp; item.id == commitList[commitList.count - 1].id &#123;\n                                    self.page = self.page + 1\n                                    self.getCommitList(page: self.page)\n                                &#125;\n                            &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        .padding(.top,5)\n        .navigationBarTitle(Text(self.showCommitFrom == CommitFromModel.fromRepo ? branch : &quot;包含的提交&quot;), displayMode: .inline)\n        .navigationBarItems(\n            trailing:\n                HStack &#123;\n                    if self.showCommitFrom == CommitFromModel.fromRepo&#123;\n                        Button &#123;\n                        &#125; label: &#123;\n                            Menu &#123;\n                                ForEach (0 ..&lt; self.branchList.count, id: \\.self) &#123;index in\n                                    Button(self.branchList[index], action: &#123;\n                                        self.branch = self.branchList[index]\n                                        self.page = 1\n                                        self.isLoading = true\n                                        self.getCommitList(page: self.page)\n                                    &#125;)\n                                &#125;\n                            &#125; label: &#123;\n                                VStack&#123;\n                                    Text(&quot;分支&quot;).foregroundColor(.yellow)\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n        )\n        .onAppear()&#123;\n            if self.showCommitFrom == CommitFromModel.fromRepo&#123;\n                self.branch = self.repoDefaultBranch!\n            &#125;else&#123;\n                self.branch = &quot;master&quot;\n            &#125;\n            self.page = 1\n            self.getCommitList( page: self.page)\n            self.getBranchList()\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>onAppear的时候，走接口。</p>\n<pre><code class=\"line-numbers language-Swift\"> func getCommitList(page: Int)&#123;\n        if self.waitPlease &#123; return &#125;\n        self.waitPlease = true\n        if commitList.count == 0 &#123;\n            self.isLoading = true\n        &#125;\n        var url = &quot;repos/&quot;\n        if self.showCommitFrom == CommitFromModel.fromRepo&#123;\n            url = url + self.repoFullPath! + &quot;/commits?page=&quot; + String(page)\n            url = url + &quot;&amp;sha=&quot; + self.branch\n        &#125;else if self.showCommitFrom == CommitFromModel.fromPullRequest&#123;\n            url = url + (self.pullRequestItem?.prTo.repoNamespace.path)! + &quot;/&quot;\n            url = url + (self.pullRequestItem?.prTo.repoPath)! + &quot;/pulls/&quot;\n            url = url + String(self.pullRequestItem!.prId) + &quot;/commits&quot;;\n        &#125;\n        \n        HttpRequest(url: url, withAccessToken: true)\n            .doGet &#123; (value) in\n                let json = JSON(value)\n                if json[&quot;message&quot;].string != nil &#123;\n                    print(&quot;error&quot;)\n                    DispatchQueue.main.async &#123;\n                        UIAlertController.confirm(message: json[&quot;message&quot;].stringValue, title: &quot;发生错误&quot;, confirmText: &quot;重新登录&quot;, cancelText: &quot;返回&quot;) &#123; (action) in\n                            Helper.relogin()\n                        &#125;\n                    &#125;\n                &#125;else&#123;\n                    var tempList = self.commitList\n                    if page == 1&#123;\n                        tempList = []\n                    &#125;\n                    for (_,subJson):(String, JSON) in json &#123;\n                        let author = subJson[&quot;commit&quot;][&quot;author&quot;][&quot;name&quot;].stringValue\n                        let userInfo = UserItemModel(id: Int(subJson[&quot;author&quot;][&quot;id&quot;].intValue), userHead: String(subJson[&quot;author&quot;][&quot;avatar_url&quot;].stringValue), userName: String(subJson[&quot;author&quot;][&quot;name&quot;].stringValue), userAccount: String(subJson[&quot;author&quot;][&quot;login&quot;].stringValue))\n                        tempList.append(CommitModel(id: subJson[&quot;sha&quot;].stringValue, sha: String(subJson[&quot;sha&quot;].stringValue), author: author, commitTime: String(subJson[&quot;commit&quot;][&quot;author&quot;][&quot;date&quot;].stringValue), message: String(subJson[&quot;commit&quot;][&quot;message&quot;].stringValue), addCount:  String(subJson[&quot;stats&quot;][&quot;additions&quot;].stringValue), deleteCount: String(subJson[&quot;stats&quot;][&quot;deletions&quot;].stringValue), totalCount: String(subJson[&quot;stats&quot;][&quot;total&quot;].stringValue), user: userInfo))\n                    &#125;\n                    self.commitList = tempList\n                &#125;\n                self.isRefreshing = false\n                self.isLoading = false\n                self.waitPlease = false\n            &#125; errorCallback: &#123;\n                self.isRefreshing = false\n                self.isLoading = false\n                self.waitPlease = false\n            &#125;\n    &#125;\n</code></pre>\n<p>这里获取分支：</p>\n<pre><code class=\"line-numbers language-Swift\">func getBranchList()&#123;\n        var url = &quot;repos/&quot;\n        url = url + self.repoFullPath! + &quot;/branches&quot;;\n        HttpRequest(url: url, withAccessToken: true)\n            .doGet &#123; (value) in\n                let json = JSON(value)\n                if json[&quot;message&quot;].string != nil &#123;\n                    DispatchQueue.main.async &#123;\n                        UIAlertController.confirm(message: json[&quot;message&quot;].stringValue, title: &quot;发生错误&quot;, confirmText: &quot;重新登录&quot;, cancelText: &quot;返回&quot;) &#123; (action) in\n                            Helper.relogin()\n                        &#125;\n                    &#125;\n                &#125;else&#123;\n                    if page == 1&#123;\n                        branchList = []\n                    &#125;\n                    for (_,subJson):(String, JSON) in json &#123;\n                        branchList.append(subJson[&quot;name&quot;].stringValue)\n                    &#125;\n                &#125;\n            &#125; errorCallback: &#123;\n                \n            &#125;\n    &#125;\n</code></pre>\n<p>注意到分支列表里面用了分支的item：</p>\n<pre><code class=\"line-numbers language-Swift\">struct CommitItemView:View&#123;\n    @State var commitItem: CommitModel\n    @State var repoFullPath: String\n    @State var userHead:UIImage? = nil\n    let placeholderImage = UIImage(named: &quot;nohead&quot;)!\n    @State var isCommitChangeShow: Bool = false\n    \n    var body: some View&#123;\n        VStack&#123;\n            VStack(alignment: .leading)&#123;\n                VStack(alignment: .leading)&#123;\n                    HStack(alignment: .top) &#123;\n                        Image(uiImage: self.userHead ?? placeholderImage)\n                            .resizable()\n                            .scaledToFit()\n                            .frame(\n                                width:20,height:20,\n                                alignment: .center\n                            )\n                            .cornerRadius(5)\n                            .onAppear()&#123;\n                                guard let url = URL(string: commitItem.user.userHead) else &#123;\n                                    return\n                                &#125;\n                                URLSession.shared.dataTask(with: url) &#123; (data, response, error) in\n                                    if let data = data, let image = UIImage(data: data) &#123;\n                                        self.userHead = image\n                                    &#125;\n                                &#125;.resume()\n                            &#125;\n                        VStack(alignment: .leading)&#123;\n                            Text(commitItem.message)\n                                .font(.system(size: 16))\n                                .lineLimit(1)\n                        &#125;\n                        Spacer()\n                        Text(&quot;+&quot; + commitItem.addCount).foregroundColor(.green).font(.system(size:14)).fontWeight(.bold).padding(.leading,0)\n                        Text(&quot;-&quot; + commitItem.deleteCount).foregroundColor(.red).font(.system(size:14)).fontWeight(.bold).padding(.leading,0)\n                        \n                    &#125;\n                &#125;\n                .padding(.vertical,5)\n                HStack&#123;\n                    Text(Helper.getDateFromString(str: commitItem.commitTime)).font(.system(size:14)).foregroundColor(.gray)\n                    Text(&quot;由 &quot;).font(.system(size:14)).foregroundColor(.gray).padding(.leading,-5)\n                    Text(commitItem.author + &quot;(&quot; + commitItem.user.userAccount + &quot;)&quot;).font(.system(size:14)).foregroundColor(Color(hex: 0xaaaaaa)).padding(.leading,0).padding(.leading,-5)\n                    Text(&quot; 提交&quot;).font(.system(size:14)).foregroundColor(.gray).padding(.leading,0).padding(.leading,-5)\n                    Spacer()\n                &#125;\n            &#125;\n            .padding(10)\n        &#125;\n        .onTapGesture &#123;\n            self.isCommitChangeShow = true\n        &#125;\n        .sheet(isPresented: $isCommitChangeShow,onDismiss: &#123;\n            \n        &#125;)&#123;\n            CommitChangesView(sha: self.commitItem.sha, repoFullPath:\n                                self.repoFullPath)\n        &#125;\n        .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n        .cornerRadius(10)\n        .padding(.horizontal,5)\n        .padding(.bottom,-5)\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"3-4-Pull-Request\"><a href=\"#3-4-Pull-Request\" class=\"headerlink\" title=\"3.4 Pull Request\"></a>3.4 Pull Request</h3><p>整个body定义：</p>\n<pre><code class=\"line-numbers language-Swift\">var body: some View &#123;\n    LoadingView(isLoading:self.$isLoading,message: self.$message,isModal:self.$isModal) &#123;\n        ZStack&#123;\n            if pullRequestList.count == 0 &amp;&amp; !isLoading &#123;\n                VStack&#123;\n                    Image(systemName: &quot;doc.text.magnifyingglass&quot;)\n                        .scaleEffect(3, anchor: .center)\n                    Text(&quot;暂无查询到的Pull Requests&quot;).padding(.top,30)\n                &#125;\n            &#125;\n            RefreshView(refreshing: $isRefreshing, action: &#123;\n                self.page = 1\n                self.getPullRequestList(page: self.page)\n            &#125;) &#123;\n                LazyVStack&#123;\n                    ForEach(self.pullRequestList)&#123; item in\n                        PullRequestItemView(pullRequestItem: item)\n                            .onAppear()&#123;\n                                if !waitPlease &amp;&amp; item.id == pullRequestList[pullRequestList.count - 1].id &#123;\n                                    self.page = self.page + 1\n                                    self.getPullRequestList(page: self.page)\n                                &#125;\n                            &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    .navigationBarTitle(Text(&quot;Pull Requests&quot;), displayMode: .inline)\n    .navigationBarItems(trailing:\n                            HStack &#123;\n                                Button(action: &#123;\n                                    self.isFilterShow.toggle()\n                                &#125;) &#123;\n                                    Image(systemName: &quot;rectangle.and.text.magnifyingglass&quot;)\n                                        \n                                        .scaleEffect(1, anchor: .center)\n                                &#125;\n                            &#125;\n                            .sheet(isPresented: $isFilterShow,onDismiss: &#123;\n                                self.isLoading = true\n                                self.page = 1\n                                self.getPullRequestList(page: self.page)\n                            &#125;)&#123;\n                                PullRequestFilterView()\n                                    .modifier(DisableModalDismiss(disabled: false))\n                            &#125;\n    )\n    .onAppear()&#123;\n        localConfig.setValue(&quot;open&quot;, forKey: giteeConfig.pull_request_state)\n        localConfig.setValue(&quot;updated&quot;, forKey: giteeConfig.pull_request_sort)\n        localConfig.setValue(&quot;desc&quot;, forKey: giteeConfig.pull_request_direction)\n        self.page = 1\n        self.getPullRequestList( page: self.page)\n    &#125;\n&#125;\n</code></pre>\n<p>可见时请求接口：</p>\n<pre><code class=\"line-numbers language-Swift\">func getPullRequestList(page: Int)&#123;\n    if self.waitPlease &#123; return &#125;\n    self.waitPlease = true\n    if pullRequestList.count == 0 &#123;\n        self.isLoading = true\n    &#125;\n    let state = localConfig.string(forKey: giteeConfig.pull_request_state)\n    let sort = localConfig.string(forKey: giteeConfig.pull_request_sort)\n    let direction = localConfig.string(forKey: giteeConfig.pull_request_direction)\n    var url = &quot;repos/&quot;\n    url = url + self.repoFullPath + &quot;/pulls?page=&quot; + String(page);\n    \n    url = url + &quot;&amp;state=&quot; + state!\n    url = url + &quot;&amp;sort=&quot; + sort!\n    url = url + &quot;&amp;direction=&quot; + direction!\n    \n    \n    HttpRequest(url: url, withAccessToken: true)\n        .doGet &#123; (value) in\n            let json = JSON(value)\n            if json[&quot;message&quot;].string != nil &#123;\n                print(&quot;error&quot;)\n                DispatchQueue.main.async &#123;\n                    UIAlertController.confirm(message: json[&quot;message&quot;].stringValue, title: &quot;发生错误&quot;, confirmText: &quot;重新登录&quot;, cancelText: &quot;返回&quot;) &#123; (action) in\n                        Helper.relogin()\n                    &#125;\n                &#125;\n            &#125;else&#123;\n                var tempList = self.pullRequestList\n                if page == 1&#123;\n                    tempList = []\n                &#125;\n                for (_,subJson):(String, JSON) in json &#123;\n                    let userInfo = UserItemModel(id: Int(subJson[&quot;user&quot;][&quot;id&quot;].intValue), userHead: String(subJson[&quot;user&quot;][&quot;avatar_url&quot;].stringValue), userName: String(subJson[&quot;user&quot;][&quot;name&quot;].stringValue), userAccount: String(subJson[&quot;user&quot;][&quot;login&quot;].stringValue))\n                    \n                    let fromRepo = RepoModel(id: Int(subJson[&quot;head&quot;][&quot;repo&quot;][&quot;id&quot;].intValue), repoName: String(subJson[&quot;head&quot;][&quot;repo&quot;][&quot;name&quot;].stringValue), repoPath: String(subJson[&quot;head&quot;][&quot;repo&quot;][&quot;path&quot;].stringValue), repoNamespace: RepoNamespace(id: Int(subJson[&quot;head&quot;][&quot;repo&quot;][&quot;namespace&quot;][&quot;id&quot;].intValue), name: String(subJson[&quot;head&quot;][&quot;repo&quot;][&quot;namespace&quot;][&quot;name&quot;].stringValue), path: String(subJson[&quot;head&quot;][&quot;repo&quot;][&quot;namespace&quot;][&quot;path&quot;].stringValue)), repoDesc: String(subJson[&quot;head&quot;][&quot;repo&quot;][&quot;description&quot;].stringValue), repoForks: &quot;&quot;, repoStars: &quot;&quot;,repoWatches:&quot;&quot;, repoLicense:&quot;&quot;, repoLanguage: &quot;&quot;, repoPushDate:&quot;&quot;, repoIsFork: false, repoIsOpenSource: Bool(subJson[&quot;head&quot;][&quot;repo&quot;][&quot;public&quot;].boolValue), repoIssues:&quot;&quot;, repoDefaultBranch:&quot;&quot;)\n                    \n                    let toRepo = RepoModel(id: Int(subJson[&quot;base&quot;][&quot;repo&quot;][&quot;id&quot;].intValue), repoName: String(subJson[&quot;base&quot;][&quot;repo&quot;][&quot;name&quot;].stringValue), repoPath: String(subJson[&quot;base&quot;][&quot;repo&quot;][&quot;path&quot;].stringValue), repoNamespace: RepoNamespace(id: Int(subJson[&quot;base&quot;][&quot;repo&quot;][&quot;namespace&quot;][&quot;id&quot;].intValue), name: String(subJson[&quot;base&quot;][&quot;repo&quot;][&quot;namespace&quot;][&quot;name&quot;].stringValue), path: String(subJson[&quot;base&quot;][&quot;repo&quot;][&quot;namespace&quot;][&quot;path&quot;].stringValue)), repoDesc: String(subJson[&quot;base&quot;][&quot;repo&quot;][&quot;description&quot;].stringValue), repoForks: &quot;&quot;, repoStars: &quot;&quot;,repoWatches:&quot;&quot;, repoLicense:&quot;&quot;, repoLanguage: &quot;&quot;, repoPushDate:&quot;&quot;, repoIsFork: false, repoIsOpenSource: Bool(subJson[&quot;base&quot;][&quot;repo&quot;][&quot;public&quot;].boolValue), repoIssues:&quot;&quot;, repoDefaultBranch:&quot;&quot;)\n                    \n                    tempList.append(PullRequestModel(id: Int(subJson[&quot;id&quot;].intValue), prId: Int(subJson[&quot;number&quot;].intValue), prStatus: getPullRequestStatus(status: String(subJson[&quot;state&quot;].stringValue)), prTitle: String(subJson[&quot;title&quot;].stringValue), prBody: String(subJson[&quot;body&quot;].stringValue), prUser: userInfo, prFrom: fromRepo, prTo: toRepo, prTime: Helper.getDateFromString(str: String(subJson[&quot;updated_at&quot;].stringValue)), prAuthMerge: Bool(subJson[&quot;mergeable&quot;].boolValue),prFromBranch: String(subJson[&quot;head&quot;][&quot;ref&quot;].stringValue),prToBranch: String(subJson[&quot;base&quot;][&quot;ref&quot;].stringValue)))\n                &#125;\n                self.pullRequestList = tempList\n            &#125;\n            self.isRefreshing = false\n            self.isLoading = false\n            self.waitPlease = false\n        &#125; errorCallback: &#123;\n            self.isRefreshing = false\n            self.isLoading = false\n            self.waitPlease = false\n            \n        &#125;\n&#125;\n</code></pre>\n<p>然后还是pull Request的item展示了：</p>\n<pre><code class=\"line-numbers language-Swift\">struct PullRequestItemView:View&#123;\n    @State var pullRequestItem: PullRequestModel\n    @State var prFromToString:String = &quot;&quot;\n    @State var prFromToString2:String = &quot;&quot;\n    @State private var isActiveCommit:Bool = false\n    @State private var isActivePullRequest:Bool = false\n    var body: some View&#123;\n        VStack&#123;\n            VStack(alignment: .leading)&#123;\n                HStack(alignment: .top) &#123;\n                    VStack&#123;\n                        Text(getPullRequestStatusStringShow(pullRequestItem:pullRequestItem))\n                            .foregroundColor(getPullRequestColor(pullRequestItem:pullRequestItem))\n                            .padding(.vertical,1)\n                            .padding(.horizontal,3)\n                    &#125;\n                    .font(.system(size: 12))\n                    .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n                    .foregroundColor(.gray)\n                    .cornerRadius(3)\n                    VStack(alignment: .leading)&#123;\n                        Text(self.pullRequestItem.prTitle)\n                            .font(.system(size: 16))\n                            .lineLimit(1)\n                    &#125;\n                    .padding(.leading,0)\n                    Spacer()\n                    Text(self.pullRequestItem.prTime)\n                        .padding(.vertical,1)\n                        .padding(.horizontal,3)\n                        .font(.system(size: 12))\n                        .foregroundColor(.gray)\n                &#125;\n                .padding(5)\n                HStack(alignment: .center)&#123;\n                    Text(self.pullRequestItem.prBody)\n                        .font(.system(size: 14))\n                        .foregroundColor(.gray)\n                        .lineLimit(1)\n                        .padding(.top,10)\n                    Spacer()\n                &#125;\n                HStack&#123;\n                    VStack(alignment: .leading)&#123;\n                        Text(prFromToString)\n                            .padding(.vertical,0)\n                            .padding(.horizontal,3)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .lineLimit(1)\n                        \n                        Text(prFromToString2)\n                            .padding(.vertical,0)\n                            .padding(.horizontal,3)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .lineLimit(1)\n                    &#125;\n                    Spacer()\n                &#125;\n            &#125;\n            .padding(10)\n        &#125;\n        .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n        .cornerRadius(10)\n        .padding(.horizontal,5)\n        .sheet(isPresented: $isActivePullRequest,onDismiss: &#123;\n        &#125;)&#123;\n            PullRequestDetailView(pullRequestItem: $pullRequestItem).foregroundColor(.white)\n        &#125;\n        .onTapGesture &#123;\n            self.isActivePullRequest = true\n        &#125;\n        .contextMenu(ContextMenu &#123;\n            if pullRequestItem.prAutoMerge &amp;&amp; pullRequestItem.prStatus == PullRequestStatus.open &#123;\n                Button(action: &#123;\n                &#125;) &#123;\n                    HStack&#123;\n                        Image(systemName: &quot;mail.and.text.magnifyingglass&quot;).scaleEffect(1, anchor: .center)\n                        Spacer()\n                        Text(&quot;审查通过&quot;)\n                    &#125;\n                &#125;\n                Button(action: &#123;\n                &#125;) &#123;\n                    HStack&#123;\n                        Image(systemName: &quot;wrench.and.screwdriver&quot;).scaleEffect(1, anchor: .center)\n                        Spacer()\n                        Text(&quot;测试通过&quot;)\n                    &#125;\n                &#125;\n                Button(action: &#123;\n                &#125;) &#123;\n                    HStack&#123;\n                        Image(systemName: &quot;shuffle&quot;).scaleEffect(1, anchor: .center)\n                        Spacer()\n                        Text(&quot;确认合并&quot;)\n                    &#125;\n                &#125;\n            &#125;\n            Divider()\n            Button(action: &#123;\n                self.isActiveCommit = true\n            &#125;) &#123;\n                HStack&#123;\n                    Image(systemName: &quot;icloud.and.arrow.up&quot;).scaleEffect(1, anchor: .center)\n                    Spacer()\n                    Text(&quot;提交记录&quot;)\n                &#125;\n            &#125;\n            .sheet(isPresented: $isActiveCommit,onDismiss: &#123;\n            &#125;)&#123;\n                CommitView(pullRequestItem: pullRequestItem).foregroundColor(.white)\n            &#125;\n        &#125;)\n        .onAppear()&#123;\n            if pullRequestItem.prFrom.repoNamespace.path == pullRequestItem.prTo.repoNamespace.path &#123;\n                self.prFromToString = &quot;从 &quot; + pullRequestItem.prFromBranch + &quot;分支 到 &quot; + pullRequestItem.prToBranch + &quot;分支&quot;\n                self.prFromToString2 = &quot;这是你的自己的合并请求&quot;\n            &#125;else&#123;\n                self.prFromToString = &quot;从 &quot; + pullRequestItem.prFrom.repoNamespace.name + &quot;/&quot; + pullRequestItem.prFrom.repoName + &quot;:&quot; + pullRequestItem.prFromBranch\n                self.prFromToString2 = &quot;到 &quot; + pullRequestItem.prTo.repoNamespace.name + &quot;/&quot; + pullRequestItem.prTo.repoName + &quot;:&quot; + pullRequestItem.prToBranch\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"3-5-查看Issues\"><a href=\"#3-5-查看Issues\" class=\"headerlink\" title=\"3.5 查看Issues\"></a>3.5 查看Issues</h3><p>body定义：</p>\n<pre><code class=\"line-numbers language-Swift\"> var body: some View &#123;\n    LoadingView(isLoading:self.$isLoading,message: self.$message,isModal:self.$isModal) &#123;\n        VStack&#123;\n            ZStack&#123;\n                if issuesList.count == 0 &amp;&amp; !isLoading &#123;\n                    VStack&#123;\n                        Image(systemName: &quot;doc.text.magnifyingglass&quot;)\n                            .scaleEffect(3, anchor: .center)\n                        Text(&quot;暂无查询到的Issues&quot;).padding(.top,30)\n                    &#125;\n                &#125;\n                RefreshView(refreshing: $isRefreshing, action: &#123;\n                    self.page = 1\n                    self.getIssueList(page: self.page)\n                &#125;) &#123;\n                    LazyVStack&#123;\n                        ForEach(self.issuesList)&#123; item in\n                            NavigationLink(destination: IssueItemView(issueItem: item)) &#123;\n                                IssueItemView(issueItem: item)\n                                    .onAppear()&#123;\n                                        if !waitPlease &amp;&amp; item.id == issuesList[issuesList.count - 1].id &#123;\n                                            self.page = self.page + 1\n                                            self.getIssueList(page: self.page)\n                                        &#125;\n                                    &#125;\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n            if self.repoPath != &quot;&quot; &#123;\n                Spacer()\n                HStack&#123;\n                    Spacer()\n                    Button &#123;\n                        self.isInserIssueShow = true\n                    &#125; label: &#123;\n                        Image(systemName: &quot;square.and.pencil&quot;)\n                            .scaleEffect(1.2, anchor: .center)\n                    &#125;\n                    .padding(12)\n                    .background(Color.yellow)\n                    .foregroundColor(Color.black)\n                    .cornerRadius(100)\n                    .sheet(isPresented: $isInserIssueShow) &#123;\n                        let arr = self.repoPath.components(separatedBy: &quot;/&quot;)\n                        IssueInsertView(repoNamespacePath: arr[0], repoPath: arr[1])\n                    &#125;\n                &#125;\n                .padding(.trailing,20)\n            &#125;\n        &#125;\n    &#125;\n    .padding(.top,5)\n    .navigationBarTitle(Text(title!), displayMode: .inline)\n    .navigationBarItems(\n        trailing:\n            HStack &#123;\n                Button(action: &#123;\n                    self.isFilterShow.toggle()\n                &#125;) &#123;\n                    Image(systemName: &quot;rectangle.and.text.magnifyingglass&quot;)\n                        \n                        .scaleEffect(1, anchor: .center)\n                &#125;\n            &#125;\n            .sheet(isPresented: $isFilterShow,onDismiss: &#123;\n                self.isLoading = true\n                self.page = 1\n                self.getIssueList(page: self.page)\n            &#125;)&#123;\n                IssueFilterView()\n                    .modifier(DisableModalDismiss(disabled: false))\n            &#125;\n    )\n    .onAppear()&#123;\n        localConfig.setValue(&quot;all&quot;, forKey: giteeConfig.issue_filter)\n        localConfig.setValue(&quot;open&quot;, forKey: giteeConfig.issue_state)\n        localConfig.setValue(&quot;created&quot;, forKey: giteeConfig.issue_sort)\n        localConfig.setValue(&quot;desc&quot;, forKey: giteeConfig.issue_direction)\n        self.page = 1\n        self.getIssueList(page: self.page)\n    &#125;\n&#125;\n</code></pre>\n<p>可见时请求列表：</p>\n<pre><code class=\"line-numbers language-Swift\">func getIssueList(page: Int)&#123;\n    if self.waitPlease &#123; return &#125;\n    self.waitPlease = true\n    if issuesList.count == 0 &#123;\n        self.isLoading = true\n    &#125;\n    let state = localConfig.string(forKey: giteeConfig.issue_state)\n    let filter = localConfig.string(forKey: giteeConfig.issue_filter)\n    let direction = localConfig.string(forKey: giteeConfig.issue_direction)\n    let sort = localConfig.string(forKey: giteeConfig.issue_sort)\n    var url = &quot;user/issues?page=&quot; + String(page)\n    \n    if self.repoPath != &quot;&quot; &#123;\n        url = &quot;repos/&quot; + self.repoPath + &quot;/issues?page=&quot; + String(page)\n    &#125;\n    \n    url = url + &quot;&amp;state=&quot; + state!\n    url = url + &quot;&amp;filter=&quot; + filter!\n    url = url + &quot;&amp;direction=&quot; + direction!\n    url = url + &quot;&amp;sort=&quot; + sort!\n    \n    \n    HttpRequest(url: url, withAccessToken: true)\n        .doGet &#123; (value) in\n            let json = JSON(value)\n            if json[&quot;message&quot;].string != nil &#123;\n                print(&quot;error&quot;)\n                DispatchQueue.main.async &#123;\n                    UIAlertController.confirm(message: json[&quot;message&quot;].stringValue, title: &quot;发生错误&quot;, confirmText: &quot;重新登录&quot;, cancelText: &quot;返回&quot;) &#123; (action) in\n                        Helper.relogin()\n                    &#125;\n                &#125;\n            &#125;else&#123;\n                var tempList = self.issuesList\n                if page == 1&#123;\n                    tempList = []\n                &#125;\n                for (_,subJson):(String, JSON) in json &#123;\n                    let repoNamespace = RepoNamespace(id: Int(subJson[&quot;repository&quot;][&quot;namespace&quot;][&quot;id&quot;].stringValue)!, name: String(subJson[&quot;repository&quot;][&quot;namespace&quot;][&quot;name&quot;].stringValue), path:  String(subJson[&quot;repository&quot;][&quot;namespace&quot;][&quot;path&quot;].stringValue))\n                    let repoInfo = RepoModel(id: Int(subJson[&quot;repository&quot;][&quot;id&quot;].stringValue)!, repoName: String(subJson[&quot;repository&quot;][&quot;name&quot;].stringValue),repoPath:  String(subJson[&quot;repository&quot;][&quot;path&quot;].stringValue),repoNamespace: repoNamespace, repoDesc:  String(subJson[&quot;repository&quot;][&quot;description&quot;].stringValue), repoForks:  String(subJson[&quot;repository&quot;][&quot;forks_count&quot;].stringValue), repoStars:  String(subJson[&quot;repository&quot;][&quot;stargazers_count&quot;].stringValue), repoWatches:  String(subJson[&quot;repository&quot;][&quot;watchers_count&quot;].stringValue), repoLicense:  String(subJson[&quot;repository&quot;][&quot;license&quot;].stringValue), repoLanguage:  String(subJson[&quot;repository&quot;][&quot;language&quot;].stringValue), repoPushDate:  String(subJson[&quot;repository&quot;][&quot;pushed_at&quot;].stringValue), repoIsFork:  Bool(subJson[&quot;repository&quot;][&quot;fork&quot;].boolValue), repoIsOpenSource:  Bool(subJson[&quot;repository&quot;][&quot;public&quot;].boolValue), repoIssues:  String(subJson[&quot;repository&quot;][&quot;open_issues_count&quot;].stringValue), repoDefaultBranch:  String(subJson[&quot;repository&quot;][&quot;default_branch&quot;].stringValue))\n                    let userInfo = UserItemModel(id: Int(subJson[&quot;user&quot;][&quot;id&quot;].stringValue)!, userHead: String(subJson[&quot;user&quot;][&quot;avatar_url&quot;].stringValue), userName: String(subJson[&quot;user&quot;][&quot;name&quot;].stringValue), userAccount: String(subJson[&quot;user&quot;][&quot;login&quot;].stringValue))\n                    let issueInfo = IssueModel(id: Int(subJson[&quot;id&quot;].stringValue)!, issueId: String(subJson[&quot;number&quot;].stringValue), issueTitle: String(subJson[&quot;title&quot;].stringValue), issueTime: Helper.getDateFromString(str: String(subJson[&quot;created_at&quot;].stringValue)), issueDesc: String(subJson[&quot;body&quot;].stringValue), issueStatus: getIssueStatus(status: subJson[&quot;state&quot;].stringValue), repoInfo:repoInfo, userInfo: userInfo)\n                    tempList.append(\n                        issueInfo\n                    )\n                &#125;\n                self.issuesList = tempList\n            &#125;\n            self.isRefreshing = false\n            self.isLoading = false\n            self.waitPlease = false\n        &#125; errorCallback: &#123;\n            self.isRefreshing = false\n            self.isLoading = false\n            self.waitPlease = false\n            \n        &#125;\n&#125;\n</code></pre>\n<p>最后就是具体的IssueItemView了。</p>\n<pre><code class=\"line-numbers language-Swift\">struct IssueItemView:View&#123;\n    @State var issueItem: IssueModel\n    @State private var isActiveIsssueDetail:Bool = false\n    @State private var isActiveRepoDetail:Bool = false\n    var body: some View&#123;\n        ZStack&#123;\n            VStack&#123;\n                NavigationLink(destination: RepoDetailView(repoFullPath: issueItem.repoInfo.repoNamespace.path + &quot;/&quot; + issueItem.repoInfo.repoPath), isActive: $isActiveRepoDetail) &#123; EmptyView() &#125;\n            &#125;\n            .frame(width: 0, height: 0)\n            .opacity(0)\n            VStack&#123;\n                VStack(alignment: .leading)&#123;\n                    HStack(alignment: .top) &#123;\n                        Image(systemName:getIssueIcon(status: issueItem.issueStatus))\n                            .scaleEffect(1, anchor: .center)\n                            .foregroundColor(getIssueColor(status: issueItem.issueStatus))\n                        VStack(alignment: .leading)&#123;\n                            Text(issueItem.issueTitle)\n                                .font(.system(size: 16))\n                                .lineLimit(1)\n                        &#125;\n                        Spacer()\n                        Text(issueItem.issueTime)\n                            .padding(.vertical,1)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                        \n                    &#125;\n                    .padding(5)\n                    HStack&#123;\n                        Text(issueItem.repoInfo.repoName)\n                            .padding(.leading,35)\n                            .font(.system(size: 12))\n                            .foregroundColor(Color(hex: 0xCCCCCC))\n                        Text(issueItem.issueDesc)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .lineLimit(1)\n                    &#125;\n                    HStack&#123;\n                        Image(systemName:&quot;person.circle&quot;)\n                            .scaleEffect(0.7, anchor: .center)\n                            .foregroundColor(.gray)\n                            .padding(.leading,30)\n                        Text(issueItem.userInfo.userName)\n                            .font(.system(size: 12))\n                            .foregroundColor(.gray)\n                            .padding(.leading,-8)\n                        Spacer()\n                    &#125;\n                    .padding(.top,5)\n                &#125;\n                .padding(10)\n            &#125;\n            .background(Color(red: 1, green: 1, blue: 1, opacity: 0.1))\n            .cornerRadius(10)\n            .padding(.horizontal,5)\n            .padding(.bottom,-3)\n            .sheet(isPresented: self.$isActiveIsssueDetail) &#123;\n                self.reloadIssue()\n            &#125; content: &#123;\n                IssuesDetailView(issueItem: $issueItem)\n                    .foregroundColor(.white)\n            &#125;\n            .onTapGesture &#123;\n                self.isActiveIsssueDetail = true\n            &#125;\n            .contextMenu(ContextMenu &#123;\n                if issueItem.issueStatus != IssueStatus.open &#123;\n                    Button(action: &#123;\n                        self.changeIssueStatus(issueItem: issueItem,  issueStatus: IssueStatus.open)\n                    &#125;) &#123;\n                        HStack&#123;\n                            Image(systemName: &quot;moon.circle&quot;).scaleEffect(1, anchor: .center)\n                            Spacer()\n                            Text(&quot;标记为已开启&quot;)\n                        &#125;\n                    &#125;\n                &#125;\n                if issueItem.issueStatus != IssueStatus.progressing &#123;\n                    Button(action: &#123;\n                        self.changeIssueStatus(issueItem: issueItem,  issueStatus: IssueStatus.progressing)\n                    &#125;) &#123;\n                        HStack&#123;\n                            Image(systemName: &quot;timer&quot;).scaleEffect(1, anchor: .center)\n                            Spacer()\n                            Text(&quot;标记为进行中&quot;)\n                        &#125;\n                    &#125;\n                &#125;\n                if issueItem.issueStatus != IssueStatus.rejected &#123;\n                    Button(action: &#123;\n                        UIAlertController.alert(message: &quot;请期待Gitee开放这个API吧~&quot;, title: &quot;即将上线&quot;, confirmText: &quot;安排&quot;)\n                    &#125;) &#123;\n                        HStack&#123;\n                            Image(systemName: &quot;xmark.circle&quot;).scaleEffect(1, anchor: .center)\n                            Spacer()\n                            Text(&quot;标记为已拒绝&quot;)\n                        &#125;\n                    &#125;\n                &#125;\n                if issueItem.issueStatus != IssueStatus.closed &#123;\n                    Button(action: &#123;\n                        self.changeIssueStatus(issueItem: issueItem, issueStatus: IssueStatus.closed)\n                    &#125;) &#123;\n                        HStack&#123;\n                            Image(systemName: &quot;checkmark.circle&quot;).scaleEffect(1, anchor: .center)\n                            Spacer()\n                            Text(&quot;标记为完成&quot;)\n                        &#125;\n                    &#125;\n                &#125;\n                Divider()\n                Button(action: &#123;\n                    self.isActiveRepoDetail = true\n                &#125;) &#123;\n                    HStack&#123;\n                        Image(systemName: &quot;archivebox.circle&quot;).scaleEffect(1, anchor: .center)\n                        Spacer()\n                        Text(&quot;进入所属仓库&quot;)\n                    &#125;\n                &#125;\n            &#125;)\n        &#125;\n    &#125;\n</code></pre>\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4 总结\"></a>4 总结</h2><ul>\n<li><p>这里学会了Swift初始化配置，可以简化其它流程，只需要继承App类。</p>\n</li>\n<li><p>然后这里学会使用类似Flutter的组件，HStack,VStack,ZSack，Spacer,Text，Image这一类基础组件。</p>\n</li>\n<li><p>网络请求的最好自己封装一个HttpRequest类，动态配置各种参数。</p>\n</li>\n</ul>\n"},{"title":"Android OpenGLES demo 学习之一","date":"2023-02-07T04:03:07.000Z","top":false,"cover":false,"toc":true,"mathjax":true,"_content":"\n## 1 展示一个基本的红色三角形\n\n### 1.1 效果\n![](./Android-OpenGLES-demo-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B8%80/01.png)\n<img src=01.png>\n\n### 1.2 渲染页\n```Kotlin\nclass NativeRenderActivity : Activity(), AudioCollector.Callback, SensorEventListener {\n\n    private var mMinSetting = -1\n    private var mMagSetting = -1\n\n    companion object {\n        private const val MIN_DIALOG = 1\n        private const val CONTEXT_CLIENT_VERSION = 3\n        private const val MAG_DIALOG = 2\n        private const val MIN_SETTING = \"min_setting\"\n        private const val MAG_SETTING = \"mag_setting\"\n        private const val TAG: String = \"NativeRenderActivity\"\n\n        private val REQUEST_PERMISSIONS = arrayOf(\n            Manifest.permission.WRITE_EXTERNAL_STORAGE,\n            Manifest.permission.RECORD_AUDIO\n        )\n        private const val PERMISSION_REQUEST_CODE = 1\n    }\n\n    private var mRootView: ViewGroup? = null\n\n    /**\n     * Hold a reference to our GLSurfaceView\n     */\n    private var mGLSurfaceView: MyCustomerGLSurfaceView? = null\n\n    private var renderer: MyNativeRenderer? = null\n\n    var type = IMyNativeRendererType.SAMPLE_TYPE\n\n\n    private var mAudioCollector: AudioCollector? = null\n\n    private var mSensorManager: SensorManager? = null\n```\n这里声明了必要的类。\n\nMyCustomerGLSurfaceView应该是自定义的GLSurfaceView。\n\n### 1.3 自定义渲染\n引用自己写的so库。\n\n```Kotlin\nclass MyNativeRenderer(activity: Activity) : GLSurfaceView.Renderer, RenderAction {\n    private var mActivity: Activity = activity\n    var mSampleType = 0\n\n    init {\n        System.loadLibrary(\"ouyangpeng-opengles-lib\")\n    }\n```\n这里的ouyangpeng-opengles-lib就是我们自己编写库，这里应该是cpp文件，但这里loadLibrary是load so库，编译时会打包成so库。\n\n```Kotlin\n////////////////////////////////// Native 方法///////////////////////////////////////\n    // 通用的\n    private external fun nativeSurfaceCreate(assetManager: AssetManager)\n    private external fun nativeSurfaceChange(width: Int, height: Int)\n    private external fun nativeDrawFrame()\n    private external fun nativeSetRenderType(sampleCategoryType: Int, renderSampleType: Int)\n    private external fun nativeOnDestroy()\n\n    // 特定的方法\n    private external fun nativeSwitchBlendingMode()\n\n    // 特定的方法\n    private external fun nativeSetDelta(x: Float, y: Float)\n    private external fun nativeSetMinFilter(filter: Int)\n    private external fun nativeSetMagFilter(filter: Int)\n\n    private external fun nativeSetImageData(\n        format: Int,\n        width: Int,\n        height: Int,\n        imageData: ByteArray?\n    )\n\n    private external fun nativeSetImageDataWithIndex(\n        index: Int,\n        format: Int,\n        width: Int,\n        height: Int,\n        imageData: ByteArray?\n    )\n\n    private external fun nativeUpdateTransformMatrix(\n        rotateX: Float,\n        rotateY: Float,\n        scaleX: Float,\n        scaleY: Float\n    )\n\n    private external fun nativeSetAudioData(audioData: ShortArray)\n\n    private external fun nativeSetTouchLocation(x: Float, y: Float)\n\n    private external fun nativeSetGravityXY(x: Float, y: Float)\n```\n这里定义了native方法。\n具体实现的地方在cpp文件中。\n\n```Kotlin\n////////////////////////////////// Java 方法///////////////////////////////////////\n\n/**\n    * 当Surface被创建的时候，GLSurfaceView 会调用这个方法。\n    * 这发送在应用程序第一次运行的时候，并且，当设备被唤醒或者用户从其他Activity切换换来时，\n    * 这个方法也可能被调用。在实践中，这意味着，当应用程序运行时，本方法可能会被调用多次。\n    *\n    *\n    * 为什么会有一个未被使用的参数类型GL10呢？\n    * 它是OpenGL ES 1.0的API遗留下来的。如果要编写OpenGL ES 1.0的渲染器，就要用这个参数。\n    * 但是，对应OpenGL ES 3.0，GLES20/GLEL30类提供了静态方法来读取。\n    */\noverride fun onSurfaceCreated(gl: GL10, config: EGLConfig) {\n    val assetManager: AssetManager = mActivity.assets\n    nativeSurfaceCreate(assetManager)\n}\n\n/**\n    * 当Surface被创建以后，每次Surface尺寸变化时，这个方法都会被 GLSurfaceView 调用到。\n    * 在横屏、竖屏来回切换的时候，Surface尺寸会发生变化\n    */\noverride fun onSurfaceChanged(gl: GL10, width: Int, height: Int) {\n    nativeSurfaceChange(width, height)\n}\n\n/**\n    * 当绘制一帧时，这个方法会被 GLSurfaceView 调用。\n    * 在这个方法中，我们一定要绘制一些东西，即使只是清空屏幕。\n    * 因为，在这个方法返回后，渲染缓冲区会被交换并显示在屏幕上，\n    * 如果什么都没画，可能会看到糟糕的闪烁效果。\n    */\noverride fun onDrawFrame(gl: GL10) {\n    // 提前赋值，变化水印的bitmap\n    if (mSampleType == IMyNativeRendererType.SAMPLE_TYPE_KEY_TIME_WATERMARK_STICKER) {\n        // 获取时间水印的bitmap\n        val mBitmap: Bitmap = CommonUtils.getTimeWaterBitmap()\n\n        val bytes = mBitmap.byteCount\n        val buf = ByteBuffer.allocate(bytes)\n        mBitmap.copyPixelsToBuffer(buf)\n        val byteArray = buf.array()\n        setImageDataWithIndex(\n            0,\n            ImageFormat.IMAGE_FORMAT_RGBA,\n            mBitmap.width,\n            mBitmap.height,\n            byteArray\n        )\n    }\n\n    // native层去绘制\n    nativeDrawFrame()\n}\n\nfun setRenderType(sampleCategoryType: Int, renderSampleType: Int) {\n    if (sampleCategoryType == IMyNativeRendererType.SAMPLE_TYPE) {\n        mSampleType = renderSampleType\n    }\n    nativeSetRenderType(sampleCategoryType, renderSampleType)\n}\n\nfun onDestroy() {\n    nativeOnDestroy()\n}\n\noverride fun switchBlendingMode() {\n    nativeSwitchBlendingMode()\n}\n\noverride fun setMinFilter(filter: Int) {\n    nativeSetMinFilter(filter)\n}\n\noverride fun setMagFilter(filter: Int) {\n    nativeSetMagFilter(filter)\n}\n\noverride fun setDelta(deltaX: Float, deltaY: Float) {\n    nativeSetDelta(deltaX, deltaY)\n}\n\noverride fun setImageData(\n    format: Int,\n    width: Int,\n    height: Int,\n    imageData: ByteArray\n) {\n    nativeSetImageData(format, width, height, imageData)\n}\n\noverride fun setImageDataWithIndex(\n    index: Int,\n    format: Int,\n    width: Int,\n    height: Int,\n    imageData: ByteArray\n) {\n    nativeSetImageDataWithIndex(index, format, width, height, imageData)\n}\n\noverride fun updateTransformMatrix(\n    rotateX: Float,\n    rotateY: Float,\n    scaleX: Float,\n    scaleY: Float\n) {\n    nativeUpdateTransformMatrix(rotateX, rotateY, scaleX, scaleY)\n}\n\noverride fun setAudioData(audioData: ShortArray) {\n    nativeSetAudioData(audioData)\n}\n\noverride fun setTouchLocation(x: Float, y: Float) {\n    nativeSetTouchLocation(x,y)\n}\n\noverride fun setGravityXY(x: Float, y: Float){\n    nativeSetGravityXY(x,y)\n}\n```\n主要渲染的方式应该是走这里。\nonDrawFrame方法就是绘制每一帧。\n\n里面是用：\n```Kotlin\n/**\n    * 当绘制一帧时，这个方法会被 GLSurfaceView 调用。\n    * 在这个方法中，我们一定要绘制一些东西，即使只是清空屏幕。\n    * 因为，在这个方法返回后，渲染缓冲区会被交换并显示在屏幕上，\n    * 如果什么都没画，可能会看到糟糕的闪烁效果。\n    */\noverride fun onDrawFrame(gl: GL10) {\n    // 提前赋值，变化水印的bitmap\n    if (mSampleType == IMyNativeRendererType.SAMPLE_TYPE_KEY_TIME_WATERMARK_STICKER) {\n        // 获取时间水印的bitmap\n        val mBitmap: Bitmap = CommonUtils.getTimeWaterBitmap()\n\n        val bytes = mBitmap.byteCount\n        val buf = ByteBuffer.allocate(bytes)\n        mBitmap.copyPixelsToBuffer(buf)\n        val byteArray = buf.array()\n        setImageDataWithIndex(\n            0,\n            ImageFormat.IMAGE_FORMAT_RGBA,\n            mBitmap.width,\n            mBitmap.height,\n            byteArray\n        )\n    }\n\n    // native层去绘制\n    nativeDrawFrame()\n}\n```\nnative层去绘制的。\n\n### 1.4 布局\n```Kotlin\nsetContentView(R.layout.activity_native_render)\nmRootView = findViewById<View>(R.id.rootView) as ViewGroup\n\n// Tell the surface view we want to create an OpenGL ES 3.0-compatible context,\n// and set an OpenGL ES 3.0-compatible renderer.\nmGLSurfaceView =\n    MyCustomerGLSurfaceView(this, myNativeRenderer, CONTEXT_CLIENT_VERSION)\n\nmGLSurfaceView?.let {\n    val lp = RelativeLayout.LayoutParams(\n        ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT\n    )\n    lp.addRule(RelativeLayout.CENTER_IN_PARENT)\n    mRootView!!.addView(it, lp)\n\n    if (mRootView!!.width != it.width\n        || mRootView!!.height != it.height\n    ) {\n        it.setAspectRatio(mRootView!!.width, mRootView!!.height)\n    }\n    // 设置渲染模式\n    setRenderMode(it)\n    // 加载图片\n    loadImageToGLSurfaceView()\n    // 申请重新绘制\n    it.requestRender()\n}\n```\n这里先设置了下ContentView进去。\n其实里面没啥的，就一个RelativeLayout：\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:id=\"@+id/rootView\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n</RelativeLayout>\n```\n\n然后这里new了一个自定义的MyCustomerGLSurfaceView。\n然后在RootView里面添加了这个自定义View。\n\n然后有一个代码很重要：\n```Kotlin\n mGLSurfaceView = MyCustomerGLSurfaceView(this, myNativeRenderer, CONTEXT_CLIENT_VERSION)\n```\n这里将 渲染器作为参数传到这个自定义View里面了。\n\n### 1.5 自定义View\n继承GLSurfaceView，来自android.opengl.GLSurfaceView。\n```Kotlin\nclass MyCustomerGLSurfaceView : GLSurfaceView, ScaleGestureDetector.OnScaleGestureListener {\n    private lateinit var mRenderer: MyNativeRenderer\n    private lateinit var mScaleGestureDetector: ScaleGestureDetector\n\n    private var mPreviousX = 0f\n    private var mPreviousY = 0f\n\n    private var mXAngle = 0f\n    private var mYAngle = 0f\n\n    private var mRatioWidth = 0\n    private var mRatioHeight = 0\n\n    private var mPreScale = 1.0f\n    private var mCurScale = 1.0f\n\n    private var mDensity = 0f\n\n    private var mLastMultiTouchTime: Long = 0\n\n    constructor(context: Context?) : super(context) {}\n\n    constructor(context: Context?, attrs: AttributeSet?) : super(context, attrs) {}\n\n    constructor(context: Context?, glRender: MyNativeRenderer, eglContextVersion: Int) : this(\n        context,\n        null,\n        glRender,\n        eglContextVersion\n    )\n\n    constructor(\n        context: Context?,\n        attrs: AttributeSet?,\n        glRender: MyNativeRenderer,\n        eglContextVersion: Int\n    ) : super(context, attrs) {\n        setEGLContextClientVersion(eglContextVersion)\n        mRenderer = glRender\n\n        /*If no setEGLConfigChooser method is called,\n        then by default the view will choose an RGB_888 surface with a depth buffer depth of at least 16 bits.*/\n        // 最后 2 个参数表示分别配置 16 位的深度缓冲区和模板缓冲区\n        setEGLConfigChooser(8, 8, 8, 8, 16, 8)\n        setRenderer(mRenderer)\n        mScaleGestureDetector = ScaleGestureDetector(context, this)\n    }\n```\n\n定义触摸事件：\n```Kotlin\noverride fun onTouchEvent(event: MotionEvent): Boolean {\n    Log.d(TAG, \"onTouchEvent\")\n    if (event.pointerCount == 1) {\n        Log.d(TAG, \"event.pointerCount == 1\")\n        val currentTimeMillis = System.currentTimeMillis()\n        if (currentTimeMillis - mLastMultiTouchTime > 200) {\n            var x: Float = -1.0f\n            var y: Float = -1.0f\n            when (event.action) {\n                MotionEvent.ACTION_DOWN -> {\n                    if (mRenderer.mSampleType == IMyNativeRendererType.SAMPLE_TYPE_KEY_LESSON_FIVE) {\n                        // Android的 GLSurfaceView 在后台线程中执行渲染，必须要小心，\n                        // 只能在这个渲染线程中调用OpenGL，在Android主线程中使用UI(用户界面)相关的调用\n                        // 两个线程之间的通信可以用如下方法：\n                        // 在主线程中的 GLSurfaceView实例可以调用 queueEven() 方法传递一个Runnable给后台渲染线程\n                        // 渲染线程可以调用Activity的runOnUIThread()来传递事件(event)给主线程\n\n                        // Ensure we call switchMode() on the OpenGL thread.\n                        // queueEvent() is a method of GLSurfaceView that will do this for us.\n                        queueEvent { mRenderer.switchBlendingMode() }\n                        return true\n                    }\n                }\n\n                MotionEvent.ACTION_MOVE -> {\n                    x = event.x\n                    y = event.y\n                    val deltaX = (x - mPreviousX) / mDensity / 2\n                    val deltaY = (y - mPreviousY) / mDensity / 2\n                    if (mRenderer.mSampleType == IMyNativeRendererType.SAMPLE_TYPE_KEY_LESSON_SIX) {\n                        mRenderer.setDelta(deltaX, deltaY)\n                    } else if (mRenderer.mSampleType == IMyNativeRendererType.SAMPLE_TYPE_KEY_SCRATCH_CARD) {\n                        mRenderer.setTouchLocation(x, y)\n                        // 重新请求绘制\n                        requestRender()\n                    }\n\n                    val dy = y - mPreviousY\n                    val dx = x - mPreviousX\n                    mYAngle += (dx * TOUCH_SCALE_FACTOR).toInt()\n                    mXAngle += (dy * TOUCH_SCALE_FACTOR).toInt()\n                }\n\n                MotionEvent.ACTION_CANCEL -> {\n                    x = -1.0f\n                    y = -1.0f\n                }\n\n                MotionEvent.ACTION_UP->{\n                    if (mRenderer.mSampleType == IMyNativeRendererType.SAMPLE_TYPE_KEY_SHOCK_WAVE) {\n                        mRenderer.setTouchLocation(event.x, event.y)\n                    }\n                }\n            }\n\n            mPreviousX = x\n            mPreviousY = y\n\n            when (mRenderer.mSampleType) {\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_FBO_LEG,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_COORD_SYSTEM,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_BASE_LIGHT,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_MULTI_LIGHT,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_STENCIL_TESTING,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_PARTICLE_SYSTEM2,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_INSTANCING,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_PBO,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_UBO,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_TEXT_RENDER,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_3D_MODEL,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_3D_MODEL2,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_BLENDING,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_SKYBOX -> {\n                    Log.d(TAG, \"updateTransformMatrix\")\n                    mRenderer.updateTransformMatrix(mXAngle, mYAngle, mCurScale, mCurScale)\n                    requestRender()\n                }\n            }\n\n        }\n    } else {\n        Log.d(TAG, \"event.pointerCount != 1\")\n        mScaleGestureDetector.onTouchEvent(event)\n    }\n    return true\n}\n```\n\n测量方法：\n```Kotlin\noverride fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {\n    super.onMeasure(widthMeasureSpec, heightMeasureSpec)\n    val width = MeasureSpec.getSize(widthMeasureSpec)\n    val height = MeasureSpec.getSize(heightMeasureSpec)\n    if (0 == mRatioWidth || 0 == mRatioHeight) {\n        setMeasuredDimension(width, height)\n    } else {\n        if (width < height * mRatioWidth / mRatioHeight) {\n            setMeasuredDimension(width, width * mRatioHeight / mRatioWidth)\n        } else {\n            setMeasuredDimension(height * mRatioWidth / mRatioHeight, height)\n        }\n    }\n}\n```\n\n其实设置方法：\n```Kotlin\nfun setAspectRatio(width: Int, height: Int) {\n    Log.d(TAG, \"setAspectRatio() called with: width = [$width], height = [$height]\")\n    require(!(width < 0 || height < 0)) { \"Size cannot be negative.\" }\n    mRatioWidth = width\n    mRatioHeight = height\n    requestLayout()\n}\n\n// Hides superclass method.\nfun setRenderer(renderer: Renderer, density: Float) {\n    mRenderer = renderer as MyNativeRenderer\n    mDensity = density\n    super.setRenderer(renderer)\n}\n```\n\n定义缩放方法：\n```Kotlin\noverride fun onScale(detector: ScaleGestureDetector?): Boolean {\n        Log.d(TAG, \"onScale\")\n    when (mRenderer.mSampleType) {\n        IMyNativeRendererType.SAMPLE_TYPE_KEY_COORD_SYSTEM,\n        IMyNativeRendererType.SAMPLE_TYPE_KEY_BASE_LIGHT,\n        IMyNativeRendererType.SAMPLE_TYPE_KEY_TEXT_RENDER,\n        IMyNativeRendererType.SAMPLE_TYPE_KEY_3D_MODEL,\n        IMyNativeRendererType.SAMPLE_TYPE_KEY_3D_MODEL2,\n        IMyNativeRendererType.SAMPLE_TYPE_KEY_INSTANCING -> {\n            val preSpan = detector!!.previousSpan\n            val curSpan = detector.currentSpan\n            mCurScale = if (curSpan < preSpan) {\n                mPreScale - (preSpan - curSpan) / 200\n            } else {\n                mPreScale + (curSpan - preSpan) / 200\n            }\n            mCurScale = 0.05f.coerceAtLeast(mCurScale.coerceAtMost(80.0f))\n            mRenderer.updateTransformMatrix(mXAngle, mYAngle, mCurScale, mCurScale)\n            requestRender()\n        }\n        else -> {}\n    }\n\n    return false\n}\n\noverride fun onScaleBegin(detector: ScaleGestureDetector?): Boolean {\n    Log.d(TAG, \"onScaleBegin\")\n    return true\n}\n\noverride fun onScaleEnd(detector: ScaleGestureDetector?) {\n    Log.d(TAG, \"onScaleEnd\")\n    mPreScale = mCurScale\n    mLastMultiTouchTime = System.currentTimeMillis()\n}\n```\n\n常量定义：\n```Kotlin\ncompanion object {\n    private const val TOUCH_SCALE_FACTOR = 180.0f / 320\n    private const val TAG = \"MyCustomerGLSurfaceView\"\n}\n```\n\n### 1.6 C层流程\n首先是Java层：\n```Kotlin\nfun setRenderType(sampleCategoryType: Int, renderSampleType: Int) {\n        if (sampleCategoryType == IMyNativeRendererType.SAMPLE_TYPE) {\n            mSampleType = renderSampleType\n        }\n        nativeSetRenderType(sampleCategoryType, renderSampleType)\n    }\n```\n这里走了native方法：\n```C++\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_oyp_openglesdemo_render_MyNativeRenderer_nativeSetRenderType(\n        JNIEnv *env, jobject thiz, jint sampleCategoryType, jint renderSampleType) {\n    MyGLRenderContext::GetInstance()->SetRenderType(sampleCategoryType, renderSampleType);\n}\n```\n这里是JniImpl.cpp类中定义的方法。\n\n然后会走到MyGLRenderContext方法中，有个单例类,先看下怎么声明的类吧：\n```C++\n\n#ifndef OPENGLESDEMO_MYGLRENDERCONTEXT_H\n#define OPENGLESDEMO_MYGLRENDERCONTEXT_H\n\n#include <GLBaseSample.h>\n\nclass MyGLRenderContext\n{\n    MyGLRenderContext();\n\n    ~MyGLRenderContext();\n\npublic:\n    void SetRenderType(int sampleCategoryType, int renderSampleType);\n\n    void OnSurfaceCreated(JNIEnv *env, jobject assetManager);\n\n    void OnSurfaceChanged(int width, int height);\n\n    void OnDrawFrame();\n\n    static MyGLRenderContext* GetInstance();\n\n    static void DestroyInstance();\n\n    void SwitchBlendingMode();\n\n    void SetDelta(float x, float y);\n\n    void SetMinFilter(int filter);\n\n    void SetMagFilter(int filter);\n\n    void SetImageData(int format, int width, int height, uint8_t *pData);\n\n    void SetImageDataWithIndex(int index, int format, int width, int height, uint8_t *pData);\n\n    void UpdateTransformMatrix(float d, float d1, float d2, float d3);\n\n    void SetAudioData(short *buffer, int len);\n\n    void SetTouchLocation(float x, float y);\n\n    void SetGravityXY(float x, float y);\n\nprivate:\n    static MyGLRenderContext *m_pContext;\n    GLBaseSample *m_pBeforeSample;\n    GLBaseSample *m_pCurSample;\n\n    static NativeImage getImage(int format, int width, int height, uint8_t *pData) ;\n};\n\n#endif //OPENGLESDEMO_MYGLRENDERCONTEXT_H\n```\n\n具体怎么实现呢？\n```C++\nMyGLRenderContext *MyGLRenderContext::GetInstance() {\n//    LOGD(\"MyGLRenderContext::GetInstance\")\n    if (m_pContext == nullptr) {\n        m_pContext = new MyGLRenderContext();\n    }\n    return m_pContext;\n}\n\nvoid MyGLRenderContext::DestroyInstance() {\n    LOGD(\"MyGLRenderContext::DestroyInstance\")\n    if (m_pContext) {\n        delete m_pContext;\n        m_pContext = nullptr;\n    }\n\n}\n```\n这里具体实现了GetInstance和DestoryInstance方法。\n\n构造函数呢？\n```C++\nMyGLRenderContext::MyGLRenderContext() {\n    LOGD(\"MyGLRenderContext::MyGLRenderContext\")\n    m_pCurSample = nullptr;\n    m_pBeforeSample = nullptr;\n}\n\nMyGLRenderContext::~MyGLRenderContext() {\n    LOGD(\"MyGLRenderContext::~MyGLRenderContext\")\n\n    if (m_pCurSample) {\n        m_pCurSample->Shutdown();\n        delete m_pCurSample;\n        m_pCurSample = nullptr;\n    }\n\n    if (m_pBeforeSample) {\n        m_pBeforeSample->Shutdown();\n        delete m_pBeforeSample;\n        m_pBeforeSample = nullptr;\n    }\n}\n```\n\n需要关注一下这里面有个指针变量，GLBaseSample，是什么呢？\n目测是一个记录demo如何绘制顶点着色器的一个类。\n```C++\n\n// 注意，这个目录在java层创建，参考 com.oyp.openglesdemo.activity.NativeRenderActivity.onResume方法\n#define DEFAULT_OGL_ASSETS_DIR \"/data/data/com.oyp.openglesdemo/cache\"\n\nclass GLBaseSample {\n    \npublic:\n    GLBaseSample() {\n        VERTEX_SHADER = GL_NONE;\n        FRAGMENT_SHADER = GL_NONE;\n        m_ProgramObj = 0;\n        m_Width = 0;\n        m_Height = 0;\n    }\n\n    virtual ~GLBaseSample() {}\n\n    virtual void Create() = 0;\n\n    virtual void Change(int width, int height) {\n        LOGD(\"Change() width = %d , height = %d\\n\", width, height)\n        m_Width = width;\n        m_Height = height;\n        // Set the viewport\n        // 通知OpenGL ES 用于绘制的2D渲染表面的原点、宽度和高度。\n        // 在OpenGL ES 中，视口(Viewport) 定义所有OpenGL ES 渲染操作最终显示的2D矩形\n        // 视口(Viewport) 由原点坐标(x,y)和宽度(width) 、高度(height)定义。\n        glViewport(0, 0, m_Width, m_Height);\n    }\n\n    virtual void Draw() = 0;\n\n    virtual void Shutdown(){\n        if (m_ProgramObj) {\n            glDeleteProgram(m_ProgramObj);\n            m_ProgramObj = GL_NONE;\n        }\n        if(VERTEX_SHADER != nullptr){\n            delete[] VERTEX_SHADER;\n            VERTEX_SHADER = nullptr;\n        }\n        if(FRAGMENT_SHADER!= nullptr){\n            delete[] FRAGMENT_SHADER;\n            FRAGMENT_SHADER = nullptr;\n        }\n    }\n\n    // 默认啥都不做，等待有需要的子类去重写\n    virtual void SwitchBlendingMode() {}\n\n    virtual void SetDelta(float x, float y) {}\n\n    virtual void SetMinFilter(int filter) {}\n\n    virtual void SetMagFilter(int filter) {}\n\n    virtual void LoadImage(NativeImage *pImage) {};\n\n    virtual void LoadMultiImageWithIndex(int index, NativeImage *pImage) {}\n\n    virtual void UpdateTransformMatrix(float rotateX, float rotateY, float scaleX, float scaleY) {}\n\n    virtual void LoadAudioData(short *buffer, int len) {}\n\n    virtual void SetTouchLocation(float x, float y) {}\n\n    virtual void SetGravityXY(float x, float y) {}\n\nprotected:\n    /**\n     * 程序对象\n     */\n    GLuint m_ProgramObj;\n\n    /**\n     * 顶点着色器\n     */\n    const char *VERTEX_SHADER;\n    /**\n     * 片段着色器脚本\n     */\n    const char *FRAGMENT_SHADER;\n\n    /**\n     * 屏幕宽度\n     */\n    int m_Width;\n    /**\n     * 屏幕高度\n     */\n    int m_Height;\n};\n\n#endif //OPENGLESDEMO_GLBASESAMPLE_H\n```\n\n然后回到MyGLRenderContext中。\n具体看下setRenderType如何实现的吧？\n```C++\nvoid MyGLRenderContext::SetRenderType(int sampleCategoryType, int renderSampleType) {\n    LOGD(\"MyGLRenderContext::SetRenderType sampleCategoryType = %d, renderSampleType = %d\",\n         sampleCategoryType, renderSampleType)\n\n    if (sampleCategoryType == SAMPLE_TYPE) {\n        m_pBeforeSample = m_pCurSample;\n\n        LOGD(\"MyGLRenderContext::SetRenderType 0 m_pBeforeSample = %p\", m_pBeforeSample)\n\n        switch (renderSampleType) {\n            case SAMPLE_TYPE_KEY_TRIANGLE:\n                m_pCurSample = new NativeTriangle();\n                break;\n            case SAMPLE_TYPE_KEY_TRIANGLE2:\n                m_pCurSample = new NativeTriangle2();\n                break;\n            case SAMPLE_TYPE_KEY_TRIANGLE3:\n                m_pCurSample = new NativeTriangle3();\n                break;\n            case SAMPLE_TYPE_KEY_TRIANGLE_MAP_BUFFERS:\n                m_pCurSample = new NativeTriangleMapBuffers();\n                break;\n            case SAMPLE_TYPE_KEY_TRIANGLE_VERTEX_ARRAY_OBJECT:\n                m_pCurSample = new NativeTriangleVAO();\n                break;\n            case SAMPLE_TYPE_KEY_TRIANGLE_VERTEX_BUFFER_OBJECT:\n                m_pCurSample = new NativeTriangleVBO();\n                break;\n            case SAMPLE_TYPE_KEY_CUBE_SIMPLE_VERTEX_SHADER:\n                m_pCurSample = new NativeCubeSimpleVertexShader();\n                break;\n            case SAMPLE_TYPE_KEY_SIMPLE_TEXTURE_2D:\n                m_pCurSample = new SimpleTexture2D();\n                break;\n            case SAMPLE_TYPE_KEY_SIMPLE_TEXTURE_CUBE_MAP:\n                m_pCurSample = new SimpleTextureCubeMap();\n                break;\n            case SAMPLE_TYPE_KEY_MIPMAP_2D:\n                m_pCurSample = new MipMap2D();\n                break;\n            case SAMPLE_TYPE_KEY_TEXTURE_WRAP:\n                m_pCurSample = new TextureWrap();\n                break;\n            case SAMPLE_TYPE_KEY_MULTI_TEXTURE:\n                m_pCurSample = new MultiTexture();\n                break;\n            case SAMPLE_TYPE_KEY_PARTICLE_SYSTEM:\n                m_pCurSample = new ParticleSystem();\n                break;\n            case SAMPLE_TYPE_KEY_PARTICLE_SYSTEM_TRANSFORM_FEEDBACK:\n                m_pCurSample = new ParticleSystemTransformFeedBack();\n                break;\n            case SAMPLE_TYPE_KEY_NOISE3D:\n                m_pCurSample = new Noise3DRender();\n                break;\n            case SAMPLE_TYPE_KEY_MRT:\n                m_pCurSample = new MRT();\n                break;\n            case SAMPLE_TYPE_KEY_TERRAIN_RENDER:\n                m_pCurSample = new TerrainRender();\n                break;\n            case SAMPLE_TYPE_KEY_SHADOWS:\n                m_pCurSample = new Shadows();\n                break;\n            case SAMPLE_TYPE_KEY_LESSON_ONE:\n                m_pCurSample = new Native1Lesson();\n                break;\n            case SAMPLE_TYPE_KEY_LESSON_TWO:\n                m_pCurSample = new Native2Lesson();\n                break;\n            case SAMPLE_TYPE_KEY_LESSON_THREE:\n                m_pCurSample = new Native3Lesson();\n                break;\n            case SAMPLE_TYPE_KEY_LESSON_FOUR:\n                m_pCurSample = new Native4Lesson();\n                break;\n            case SAMPLE_TYPE_KEY_LESSON_FIVE:\n                m_pCurSample = new Native5Lesson();\n                break;\n            case SAMPLE_TYPE_KEY_LESSON_SIX:\n                m_pCurSample = new Native6Lesson();\n                break;\n            case SAMPLE_TYPE_KEY_TEXTURE_MAP:\n                m_pCurSample = new TextureMapSample();\n                break;\n            case SAMPLE_TYPE_KEY_YUV_RENDER:\n                m_pCurSample = new NV21TextureMapSample();\n                break;\n            case SAMPLE_TYPE_KEY_FBO:\n                m_pCurSample = new FBOSample();\n                break;\n            case SAMPLE_TYPE_KEY_FBO_LEG:\n                m_pCurSample = new FBOLegLengthenSample();\n                break;\n            case SAMPLE_TYPE_COORD_SYSTEM:\n                m_pCurSample = new CoordSystemSample();\n                break;\n            case SAMPLE_TYPE_KEY_BASE_LIGHT:\n                m_pCurSample = new BasicLightingSample();\n                break;\n            case SAMPLE_TYPE_KEY_MULTI_LIGHT:\n                m_pCurSample = new MultiLightingsSample();\n                break;\n            case SAMPLE_TYPE_KEY_INSTANCING:\n                m_pCurSample = new Instancing3DSample();\n                break;\n            case SAMPLE_TYPE_KEY_STENCIL_TESTING:\n                m_pCurSample = new StencilTestingSample();\n                break;\n            case SAMPLE_TYPE_KEY_BLENDING:\n                m_pCurSample = new BlendingSample();\n                break;\n            case SAMPLE_TYPE_KEY_PARTICLE_SYSTEM2:\n                m_pCurSample = new ParticlesSample2();\n                break;\n            case SAMPLE_TYPE_KEY_SKYBOX:\n                m_pCurSample = new SkyBoxSample();\n                break;\n            case SAMPLE_TYPE_KEY_PBO:\n                m_pCurSample = new PBOSample();\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_BEATING_HEART:\n                m_pCurSample = new BaseShaderToySimpleSample(\n                        SAMPLE_TYPE_KEY_SHADER_TOY_BEATING_HEART);\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_CLOUD:\n                m_pCurSample = new BaseShaderToySimpleSample(SAMPLE_TYPE_KEY_SHADER_TOY_CLOUD);\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_TIME_TUNNEL:\n                m_pCurSample = new TimeTunnelSample();\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_MAIN_SEQUENCE_STAR:\n                m_pCurSample = new BaseShaderToySimpleSample(\n                        SAMPLE_TYPE_KEY_SHADER_TOY_MAIN_SEQUENCE_STAR);\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_SKY_PATH:\n                m_pCurSample = new BaseShaderToySimpleSample(SAMPLE_TYPE_KEY_SHADER_TOY_SKY_PATH);\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_A_DAY:\n                m_pCurSample = new BaseShaderToySimpleSample(SAMPLE_TYPE_KEY_SHADER_TOY_A_DAY);\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_ATMOSPHERE_SYSTEM_TEST:\n                m_pCurSample = new BaseShaderToySimpleSample(\n                        SAMPLE_TYPE_KEY_SHADER_TOY_ATMOSPHERE_SYSTEM_TEST);\n                break;\n            case SAMPLE_TYPE_KEY_BEZIER_CURVE:\n                m_pCurSample = new BezierCurveSample();\n                break;\n            case SAMPLE_TYPE_KEY_BIG_EYES:\n                m_pCurSample = new BigEyesSample();\n                break;\n            case SAMPLE_TYPE_KEY_FACE_SLENDER:\n                m_pCurSample = new FaceSlenderSample();\n                break;\n            case SAMPLE_TYPE_KEY_BIG_HEAD:\n                m_pCurSample = new BigHeadSample();\n                break;\n            case SAMPLE_TYPE_KEY_RATARY_HEAD:\n                m_pCurSample = new RotaryHeadSample();\n                break;\n            case SAMPLE_TYPE_KEY_VISUALIZE_AUDIO:\n                m_pCurSample = new VisualizeAudioSample();\n                break;\n            case SAMPLE_TYPE_KEY_SCRATCH_CARD:\n                m_pCurSample = new ScratchCardSample();\n                break;\n            case SAMPLE_TYPE_KEY_AVATAR:\n                m_pCurSample = new AvatarSample();\n                break;\n            case SAMPLE_TYPE_KEY_SHOCK_WAVE:\n                m_pCurSample = new ShockWaveSample();\n                break;\n            case SAMPLE_TYPE_KEY_MRT2:\n                m_pCurSample = new MRTSample();\n                break;\n            case SAMPLE_TYPE_KEY_FBO_BLIT:\n                m_pCurSample = new FBOBlitSample();\n                break;\n            case SAMPLE_TYPE_KEY_UBO:\n                m_pCurSample = new UniformBufferSample();\n                break;\n            case SAMPLE_TYPE_KEY_RGB2YUV:\n                m_pCurSample = new RGB2YUVSample();\n                break;\n            case SAMPLE_TYPE_KEY_MULTI_THREAD_RENDER:\n                m_pCurSample = new SharedEGLContextSample();\n                break;\n            case SAMPLE_TYPE_KEY_TEXT_RENDER:\n                m_pCurSample = new TextRenderSample();\n                break;\n            case SAMPLE_TYPE_KEY_STAY_COLOR:\n                m_pCurSample = new PortraitStayColorExample();\n                break;\n            case SAMPLE_TYPE_KEY_TRANSITIONS_1:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_2:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_3:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_4:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_5:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_6:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_7:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_8:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_9:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_10:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_11:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_12:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_13:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_14:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_15:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_16:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_17:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_18:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_19:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_20:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_21:\n                m_pCurSample = new GLTransitionExample(renderSampleType);\n                break;\n            case SAMPLE_TYPE_KEY_3D_MODEL:\n                m_pCurSample = new Model3DSample();\n                break;\n            case SAMPLE_TYPE_KEY_3D_MODEL2:\n                m_pCurSample = new Model3DSample2();\n                break;\n            case SAMPLE_TYPE_KEY_AIR_HOCKEY:\n                m_pCurSample = new AirHockeySample();\n                break;\n\n            case SAMPLE_TYPE_KEY_RECTANGLE:\n                m_pCurSample = new NativeRectangle();\n                break;\n\n            case SAMPLE_TYPE_KEY_STICKER:\n                m_pCurSample = new StickerSample();\n                break;\n            case SAMPLE_TYPE_KEY_TIME_WATERMARK_STICKER:\n                m_pCurSample = new TimeWatermarkStickerSample();\n                break;\n\n            case SAMPLE_TYPE_KEY_GREEN_SCREEN_MATTING:\n                m_pCurSample = new GreenScreenMatting();\n                break;\n            case SAMPLE_TYPE_KEY_GREEN_SCREEN_MATTING_MIX:\n                m_pCurSample = new GreenScreenMattingMix();\n                break;\n            case SAMPLE_TYPE_KEY_ROTATE_TEXTURE:\n                m_pCurSample = new RotateTexture();\n                break;\n            default:\n                m_pCurSample = nullptr;\n                break;\n        }\n        if (m_pCurSample == nullptr) {\n            throw MyGLException(\n                    \"MyGLRenderContext::SetRenderType() 请注意：你应该忘记初始化你要展示的Sample类型 ，请补上初始化的代码，否则无法渲染\");\n        }\n        LOGD(\"MyGLRenderContext::SetRenderType m_pBeforeSample = %p, m_pCurSample=%p\",\n             m_pBeforeSample, m_pCurSample)\n    }\n}\n```\n这里是所有类型，不过我们重点是看三角形。\n三角形是这样赋值过去的。\n```C++\nswitch (renderSampleType) {\n    case SAMPLE_TYPE_KEY_TRIANGLE:\n        m_pCurSample = new NativeTriangle();\n        break;\n```\n这里new了一个NativeTriangle给到m_pCurSample指针变量。\n这个m_pCurSample就是前面在MyGLRenderContext定义的两个指针变量的其中一个。\n类型是GLBaseSample这个的指针类型。\n\n### 1.7 三角形绘制方法\n这里先声明头文件：\n```C++\n#pragma once\n\n#include <GLBaseSample.h>\n\nclass NativeTriangle : public GLBaseSample {\n\n#define VERTEX_POS_INDX       0\n\npublic:\n    NativeTriangle() = default;\n\n    virtual ~NativeTriangle() = default;\n\n    virtual void Create();\n\n    virtual void Draw();\n\n    virtual void Shutdown();\n};\n```\n这里看到了这个是必须继承我们的GLBaseSample，但不是绘制三角形必要，是我们为了统一管理demo，新建的一个Sample来，其它demo都继承这个，就比较好管理。\n\n然后再写cpp文件，去实现这个三角形：\n```C++\n#include \"NativeTriangle.h\"\n\n// 可以参考这篇讲解： https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/\n// 我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z）\n// 由于我们希望渲染一个三角形，我们一共要指定三个顶点，每个顶点都有一个3D位置。\n// 我们会将它们以标准化设备坐标的形式（OpenGL的可见区域）定义为一个float数组。\n// https://learnopengl-cn.github.io/img/01/04/ndc.png\n\n// https://developer.android.com/guide/topics/graphics/opengl#kotlin\n// 在 OpenGL 中，形状的面是由三维空间中的三个或更多点定义的表面。\n// 一个包含三个或更多三维点（在 OpenGL 中被称为顶点）的集合具有一个正面和一个背面。\n// 如何知道哪一面为正面，哪一面为背面呢？这个问题问得好！答案与环绕（即您定义形状的点的方向）有关。\n// 查看图片 ： https://developer.android.com/images/opengl/ccw-winding.png\n// 或者查看本地图片：Android_Java/Chapter_2/Hello_Triangle/ccw-winding.png\n// 在此示例中，三角形的点按照使它们沿逆时针方向绘制的顺序定义。\n// 这些坐标的绘制顺序定义了该形状的环绕方向。默认情况下，在 OpenGL 中，沿逆时针方向绘制的面为正面。\n// 因此您看到的是该形状的正面（根据 OpenGL 解释），而另一面是背面。\n//\n// 知道形状的哪一面为正面为何如此重要呢？\n// 答案与 OpenGL 的“面剔除”这一常用功能有关。\n// 面剔除是 OpenGL 环境的一个选项，它允许渲染管道忽略（不计算或不绘制）形状的背面，从而节省时间和内存并缩短处理周期：\nstatic GLfloat vVertices[] = {\n        // 逆时针 三个顶点\n        0.0f, 0.5f, 0.0f,            // 上角\n        -0.5f, -0.5f, 0.0f,          // 左下角\n        0.5f, -0.5f, 0.0f            // 右下角\n};\n```\n这里先定义下3个坐标。这个坐标以屏幕中心为（0,0）,坐标跟常规的数学坐标一致。\n\n然后是一个Create方法，具体会在MyGLRenderContext的onSurfaceCreated中会执行\n```C++\nvoid MyGLRenderContext::OnSurfaceCreated(JNIEnv *env, jobject assetManager) {\n    LOGD(\"MyGLRenderContext::OnSurfaceCreated\")\n\n    // 初始化设置assetManager  一定要记得初始化，否则会报空指针异常\n    GLUtils::setEnvAndAssetManager(env, assetManager);\n\n    if (m_pBeforeSample) {\n        m_pBeforeSample->Shutdown();\n        delete m_pBeforeSample;\n        m_pBeforeSample = nullptr;\n    }\n\n    // 就是这里会走Create\n    if (m_pCurSample) {\n        m_pCurSample->Create();\n    }\n}\n```\n\n三角形的Create方法怎么写呢？\n```C++\nvoid NativeTriangle::Create() {\n    GLUtils::printGLInfo();\n\n    // Main Program\n    // 顶点着色器\n    VERTEX_SHADER = GLUtils::openTextFile(\n            \"vertex/vertex_shader_hello_triangle.glsl\");\n    // 片段着色器\n    FRAGMENT_SHADER = GLUtils::openTextFile(\n            \"fragment/fragment_shader_hello_triangle.glsl\");\n\n    m_ProgramObj = GLUtils::createProgram(&VERTEX_SHADER, &FRAGMENT_SHADER);\n    if (!m_ProgramObj) {\n        LOGD(\"Could not Create program\")\n        return;\n    }\n    // 设置清除颜色\n    glClearColor(1.0f, 1.0f, 1.0f, 0.0f);\n}\n```\n这里主要是初始化，并没有绘制相关信息。\n\n主要绘制发生于Draw方法：\n```C++\nvoid NativeTriangle::Draw() {\n    // Clear the color buffer\n    // 清除屏幕\n    // 在OpenGL ES中，绘图中涉及多种缓冲区类型：颜色、深度、模板。\n    // 这个例子，绘制三角形，只向颜色缓冲区中绘制图形。在每个帧的开始，我们用glClear函数清除颜色缓冲区\n    // 缓冲区将用glClearColor指定的颜色清除。\n    // 这个例子，我们调用了GLES30.glClearColor(1.0f, 1.0f, 1.0f, 0.0f); 因此屏幕清为白色。\n    // 清除颜色应该由应用程序在调用颜色缓冲区的glClear之前设置。\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    // Use the program object\n    // 在glUseProgram函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象（也就是之前写的着色器)了。\n    // 当我们渲染一个物体时要使用着色器程序 , 将其设置为活动程序。这样就可以开始渲染了\n    glUseProgram(m_ProgramObj);\n\n    // Load the vertex data\n    //  顶点着色器允许我们指定任何以顶点属性为形式的输入。这使其具有很强的灵活性的同时，\n    //  它还的确意味着我们必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。\n    //  所以，我们必须在渲染前指定OpenGL该如何解释顶点数据。\n\n    //  我们的顶点缓冲数据会被解析为下面这样子：https://learnopengl-cn.github.io/img/01/04/vertex_attribute_pointer.png\n    //   . 位置数据被储存为32位（4字节）浮点值。\n    //   . 每个位置包含3个这样的值。\n    //   . 在这3个值之间没有空隙（或其他值）。这几个值在数组中紧密排列(Tightly Packed)。\n    //   . 数据中第一个值在缓冲开始的位置。\n\n    // 有了这些信息我们就可以使用glVertexAttribPointer函数告诉OpenGL该如何解析顶点数据（应用到逐个顶点属性上）了：\n    // Load the vertex data\n\n    // 第一个参数指定我们要配置的顶点属性。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入0。\n    // 第二个参数指定顶点属性的大小。顶点属性是一个vec3，它由3个值组成，所以大小是3。\n    // 第三个参数指定数据的类型，这里是GL_FLOAT(GLSL中vec*都是由浮点数值组成的)。\n    // 第四个参数定义我们是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。\n    // 第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。我们设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。\n    //      一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，\n    //      （译注: 这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节）。\n    // 最后一个参数的类型是void*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。\n    glVertexAttribPointer(VERTEX_POS_INDX, 3, GL_FLOAT, GL_FALSE, 0, vVertices);\n\n    // 现在我们已经定义了OpenGL该如何解释顶点数据，\n    // 我们现在应该使用glEnableVertexAttribArray，以顶点属性位置值作为参数，启用顶点属性；顶点属性默认是禁用的。\n    glEnableVertexAttribArray(VERTEX_POS_INDX);\n\n    // glDrawArrays函数第一个参数是我们打算绘制的OpenGL图元的类型。我们希望绘制的是一个三角形，这里传递GL_TRIANGLES给它。\n    // 第二个参数指定了顶点数组的起始索引，我们这里填0。\n    // 最后一个参数指定我们打算绘制多少个顶点，这里是3（我们只从我们的数据中渲染一个三角形，它只有3个顶点长）。\n    //        public static final int GL_POINTS                                  = 0x0000;\n    //        public static final int GL_LINES                                   = 0x0001;\n    //        public static final int GL_LINE_LOOP                               = 0x0002;\n    //        public static final int GL_LINE_STRIP                              = 0x0003;\n    //        public static final int GL_TRIANGLES                               = 0x0004;\n    //        public static final int GL_TRIANGLE_STRIP                          = 0x0005;\n    //        public static final int GL_TRIANGLE_FAN                            = 0x0006;\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n\n    // 禁用 通用顶点属性数组\n    glDisableVertexAttribArray(0);\n}\n```\n\n主要是glVertexAttribPointer中传入了顶点坐标。\n但这里还不能显示，需要解释一下顶点数据，怎么绘制顶点等。\n这里传入了一个GL_TRIANGLES，系统就知道这三个点用来绘制三角形哦。\n\n### 1.8 三角形颜色怎么设置\n其实有多种方法。\n方法1：可以在顶点后面直接加红绿蓝颜色值。\n方法2：在片段着色器里面加。\n方法3：可以通过特殊手段传值给着色器。\n\n这里我们看下第2种，直接在片段着色器中如何修改颜色。\n\n首先确认下在哪里加载片段主色器的。\n```C++\nvoid NativeRectangle::Create() {\n    GLUtils::printGLInfo();\n\n    // Main Program\n    // 顶点着色器\n    VERTEX_SHADER = GLUtils::openTextFile(\n            \"vertex/vertex_shader_hello_triangle.glsl\");\n    // 片段着色器\n    FRAGMENT_SHADER = GLUtils::openTextFile(\n            \"fragment/fragment_shader_hello_triangle.glsl\");\n\n    m_ProgramObj = GLUtils::createProgram(&VERTEX_SHADER, &FRAGMENT_SHADER);\n    if (!m_ProgramObj) {\n        LOGD(\"Could not Create program\")\n        return;\n    }\n```\nsoga，原来在这里，create方法中，定义了片段着色器fragment/fragment_shader_hello_triangle.glsl。\n顶点主色器是同理，应该是顶点的颜色。\n\n目标位置在app/src/main/assets/fragment文件夹下，原来藏这里了。\n```glsl\n#version 300 es\n// 表示OpenGL ES着色器语言V3.00\n\n// 声明着色器中浮点变量的默认精度\nprecision mediump float;\n// 声明一个输出变量fragColor，这是一个4分量的向量，\n// 写入这个变量的值将被输出到颜色缓冲器\nout vec4 fragColor;\n\nvoid main()\n{\n\t//在计算机图形中颜色被表示为有4个元素的数组：红色、绿色、蓝色和alpha(透明度)分量，\n\t//通常缩写为RGBA。当在OpenGL或GLSL中定义一个颜色的时候，\n\t//我们把颜色每个分量的强度设置在0.0到1.0之间。\n\n\t//比如说我们设置红为1.0f，绿为1.0f，我们会得到两个颜色的混合色，即黄色。\n\t//这三种颜色分量的不同调配可以生成超过1600万种不同的颜色！\n\n\t// 所有片段的着色器输出都是红色( 1.0, 0.0, 0.0, 1.0 )\n\tfragColor = vec4 ( 1.0, 0.0, 0.0, 1.0 );\n\n\t// 会输出橘黄色\n\t// fragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n}\n```\n这个是着色器语言，决定怎么显示颜色。\n这个着色器语言这么加载到程序的呢？\n继续看上面的Create方法：\n```C++\n  m_ProgramObj = GLUtils::createProgram(&VERTEX_SHADER, &FRAGMENT_SHADER);\n    if (!m_ProgramObj) {\n        LOGD(\"Could not Create program\")\n        return;\n    }\n```\n这里就加载到当前程序了。包括了顶点着色器和片段着色器。\n\n整个流程基本就是这样了，另外别忘了一个指针置空的问题。\n我们这里每个demo会走一个Shutdown方法，这里就是关闭的时候进行一些数据回收操作。\n\n\n## 2 总结\n* 首先Java层需要自定义一个View，继承GLSurfaceView，需要实现必须实现的方法。主要先在构造函数中进行必要的初始化，然后再设置Renderer，这个的Renderer是我们自己定义的一个封装好的类，这里面加载so库，方法c层的外观者类。\n\n* 在外观者类定义好Surface初始化和DrawFrame的底层方法，定义好怎么初始化，怎么绘制的方法。再自定义View中调用，实现在底层实现。\n\n* 可以通过alt+enter一键生成一个生成名字的方法，参数有JNIEnv的指针变量，可以访问jni的关键实例。然后这里面走我们自定义单例MyGLRenderContext的onDrawFrame或者其它方法。\n\n* 然后我们在MyGLRenderContext声明了一个demo指针变量，可以让这个demo执行目标函数，比如onSurfaceCreated方法，就命令里面的m_pCurSample走Create方法。\n\n* 因为外部先走setRenderType，所以我们在这里给m_pCurSample指针new对象。\n\n* 比如绘制三角形，就创建一个NativeTriangle,当然继承demo类，然后定义一个坐标集合，三角形就按照数学坐标定义3个点。然后create方法里面加载我们的着色器，着色器代码可以放在项目的assets文件夹下。然后让GLUtils创建程序。\n\n* 最后就是在自定义View的onDrawFrame绘制每一帧了。这里如果是三角形，我们就按照前面定义的坐标集合来绘制三角形即可。\n\n\n\n","source":"_posts/Android-OpenGLES-demo-学习之一.md","raw":"---\ntitle: Android OpenGLES demo 学习之一\ndate: 2023-02-07 12:03:07\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n- Android OpenGLES\ncategories:\n- Android\n---\n\n## 1 展示一个基本的红色三角形\n\n### 1.1 效果\n![](./Android-OpenGLES-demo-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B8%80/01.png)\n<img src=01.png>\n\n### 1.2 渲染页\n```Kotlin\nclass NativeRenderActivity : Activity(), AudioCollector.Callback, SensorEventListener {\n\n    private var mMinSetting = -1\n    private var mMagSetting = -1\n\n    companion object {\n        private const val MIN_DIALOG = 1\n        private const val CONTEXT_CLIENT_VERSION = 3\n        private const val MAG_DIALOG = 2\n        private const val MIN_SETTING = \"min_setting\"\n        private const val MAG_SETTING = \"mag_setting\"\n        private const val TAG: String = \"NativeRenderActivity\"\n\n        private val REQUEST_PERMISSIONS = arrayOf(\n            Manifest.permission.WRITE_EXTERNAL_STORAGE,\n            Manifest.permission.RECORD_AUDIO\n        )\n        private const val PERMISSION_REQUEST_CODE = 1\n    }\n\n    private var mRootView: ViewGroup? = null\n\n    /**\n     * Hold a reference to our GLSurfaceView\n     */\n    private var mGLSurfaceView: MyCustomerGLSurfaceView? = null\n\n    private var renderer: MyNativeRenderer? = null\n\n    var type = IMyNativeRendererType.SAMPLE_TYPE\n\n\n    private var mAudioCollector: AudioCollector? = null\n\n    private var mSensorManager: SensorManager? = null\n```\n这里声明了必要的类。\n\nMyCustomerGLSurfaceView应该是自定义的GLSurfaceView。\n\n### 1.3 自定义渲染\n引用自己写的so库。\n\n```Kotlin\nclass MyNativeRenderer(activity: Activity) : GLSurfaceView.Renderer, RenderAction {\n    private var mActivity: Activity = activity\n    var mSampleType = 0\n\n    init {\n        System.loadLibrary(\"ouyangpeng-opengles-lib\")\n    }\n```\n这里的ouyangpeng-opengles-lib就是我们自己编写库，这里应该是cpp文件，但这里loadLibrary是load so库，编译时会打包成so库。\n\n```Kotlin\n////////////////////////////////// Native 方法///////////////////////////////////////\n    // 通用的\n    private external fun nativeSurfaceCreate(assetManager: AssetManager)\n    private external fun nativeSurfaceChange(width: Int, height: Int)\n    private external fun nativeDrawFrame()\n    private external fun nativeSetRenderType(sampleCategoryType: Int, renderSampleType: Int)\n    private external fun nativeOnDestroy()\n\n    // 特定的方法\n    private external fun nativeSwitchBlendingMode()\n\n    // 特定的方法\n    private external fun nativeSetDelta(x: Float, y: Float)\n    private external fun nativeSetMinFilter(filter: Int)\n    private external fun nativeSetMagFilter(filter: Int)\n\n    private external fun nativeSetImageData(\n        format: Int,\n        width: Int,\n        height: Int,\n        imageData: ByteArray?\n    )\n\n    private external fun nativeSetImageDataWithIndex(\n        index: Int,\n        format: Int,\n        width: Int,\n        height: Int,\n        imageData: ByteArray?\n    )\n\n    private external fun nativeUpdateTransformMatrix(\n        rotateX: Float,\n        rotateY: Float,\n        scaleX: Float,\n        scaleY: Float\n    )\n\n    private external fun nativeSetAudioData(audioData: ShortArray)\n\n    private external fun nativeSetTouchLocation(x: Float, y: Float)\n\n    private external fun nativeSetGravityXY(x: Float, y: Float)\n```\n这里定义了native方法。\n具体实现的地方在cpp文件中。\n\n```Kotlin\n////////////////////////////////// Java 方法///////////////////////////////////////\n\n/**\n    * 当Surface被创建的时候，GLSurfaceView 会调用这个方法。\n    * 这发送在应用程序第一次运行的时候，并且，当设备被唤醒或者用户从其他Activity切换换来时，\n    * 这个方法也可能被调用。在实践中，这意味着，当应用程序运行时，本方法可能会被调用多次。\n    *\n    *\n    * 为什么会有一个未被使用的参数类型GL10呢？\n    * 它是OpenGL ES 1.0的API遗留下来的。如果要编写OpenGL ES 1.0的渲染器，就要用这个参数。\n    * 但是，对应OpenGL ES 3.0，GLES20/GLEL30类提供了静态方法来读取。\n    */\noverride fun onSurfaceCreated(gl: GL10, config: EGLConfig) {\n    val assetManager: AssetManager = mActivity.assets\n    nativeSurfaceCreate(assetManager)\n}\n\n/**\n    * 当Surface被创建以后，每次Surface尺寸变化时，这个方法都会被 GLSurfaceView 调用到。\n    * 在横屏、竖屏来回切换的时候，Surface尺寸会发生变化\n    */\noverride fun onSurfaceChanged(gl: GL10, width: Int, height: Int) {\n    nativeSurfaceChange(width, height)\n}\n\n/**\n    * 当绘制一帧时，这个方法会被 GLSurfaceView 调用。\n    * 在这个方法中，我们一定要绘制一些东西，即使只是清空屏幕。\n    * 因为，在这个方法返回后，渲染缓冲区会被交换并显示在屏幕上，\n    * 如果什么都没画，可能会看到糟糕的闪烁效果。\n    */\noverride fun onDrawFrame(gl: GL10) {\n    // 提前赋值，变化水印的bitmap\n    if (mSampleType == IMyNativeRendererType.SAMPLE_TYPE_KEY_TIME_WATERMARK_STICKER) {\n        // 获取时间水印的bitmap\n        val mBitmap: Bitmap = CommonUtils.getTimeWaterBitmap()\n\n        val bytes = mBitmap.byteCount\n        val buf = ByteBuffer.allocate(bytes)\n        mBitmap.copyPixelsToBuffer(buf)\n        val byteArray = buf.array()\n        setImageDataWithIndex(\n            0,\n            ImageFormat.IMAGE_FORMAT_RGBA,\n            mBitmap.width,\n            mBitmap.height,\n            byteArray\n        )\n    }\n\n    // native层去绘制\n    nativeDrawFrame()\n}\n\nfun setRenderType(sampleCategoryType: Int, renderSampleType: Int) {\n    if (sampleCategoryType == IMyNativeRendererType.SAMPLE_TYPE) {\n        mSampleType = renderSampleType\n    }\n    nativeSetRenderType(sampleCategoryType, renderSampleType)\n}\n\nfun onDestroy() {\n    nativeOnDestroy()\n}\n\noverride fun switchBlendingMode() {\n    nativeSwitchBlendingMode()\n}\n\noverride fun setMinFilter(filter: Int) {\n    nativeSetMinFilter(filter)\n}\n\noverride fun setMagFilter(filter: Int) {\n    nativeSetMagFilter(filter)\n}\n\noverride fun setDelta(deltaX: Float, deltaY: Float) {\n    nativeSetDelta(deltaX, deltaY)\n}\n\noverride fun setImageData(\n    format: Int,\n    width: Int,\n    height: Int,\n    imageData: ByteArray\n) {\n    nativeSetImageData(format, width, height, imageData)\n}\n\noverride fun setImageDataWithIndex(\n    index: Int,\n    format: Int,\n    width: Int,\n    height: Int,\n    imageData: ByteArray\n) {\n    nativeSetImageDataWithIndex(index, format, width, height, imageData)\n}\n\noverride fun updateTransformMatrix(\n    rotateX: Float,\n    rotateY: Float,\n    scaleX: Float,\n    scaleY: Float\n) {\n    nativeUpdateTransformMatrix(rotateX, rotateY, scaleX, scaleY)\n}\n\noverride fun setAudioData(audioData: ShortArray) {\n    nativeSetAudioData(audioData)\n}\n\noverride fun setTouchLocation(x: Float, y: Float) {\n    nativeSetTouchLocation(x,y)\n}\n\noverride fun setGravityXY(x: Float, y: Float){\n    nativeSetGravityXY(x,y)\n}\n```\n主要渲染的方式应该是走这里。\nonDrawFrame方法就是绘制每一帧。\n\n里面是用：\n```Kotlin\n/**\n    * 当绘制一帧时，这个方法会被 GLSurfaceView 调用。\n    * 在这个方法中，我们一定要绘制一些东西，即使只是清空屏幕。\n    * 因为，在这个方法返回后，渲染缓冲区会被交换并显示在屏幕上，\n    * 如果什么都没画，可能会看到糟糕的闪烁效果。\n    */\noverride fun onDrawFrame(gl: GL10) {\n    // 提前赋值，变化水印的bitmap\n    if (mSampleType == IMyNativeRendererType.SAMPLE_TYPE_KEY_TIME_WATERMARK_STICKER) {\n        // 获取时间水印的bitmap\n        val mBitmap: Bitmap = CommonUtils.getTimeWaterBitmap()\n\n        val bytes = mBitmap.byteCount\n        val buf = ByteBuffer.allocate(bytes)\n        mBitmap.copyPixelsToBuffer(buf)\n        val byteArray = buf.array()\n        setImageDataWithIndex(\n            0,\n            ImageFormat.IMAGE_FORMAT_RGBA,\n            mBitmap.width,\n            mBitmap.height,\n            byteArray\n        )\n    }\n\n    // native层去绘制\n    nativeDrawFrame()\n}\n```\nnative层去绘制的。\n\n### 1.4 布局\n```Kotlin\nsetContentView(R.layout.activity_native_render)\nmRootView = findViewById<View>(R.id.rootView) as ViewGroup\n\n// Tell the surface view we want to create an OpenGL ES 3.0-compatible context,\n// and set an OpenGL ES 3.0-compatible renderer.\nmGLSurfaceView =\n    MyCustomerGLSurfaceView(this, myNativeRenderer, CONTEXT_CLIENT_VERSION)\n\nmGLSurfaceView?.let {\n    val lp = RelativeLayout.LayoutParams(\n        ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT\n    )\n    lp.addRule(RelativeLayout.CENTER_IN_PARENT)\n    mRootView!!.addView(it, lp)\n\n    if (mRootView!!.width != it.width\n        || mRootView!!.height != it.height\n    ) {\n        it.setAspectRatio(mRootView!!.width, mRootView!!.height)\n    }\n    // 设置渲染模式\n    setRenderMode(it)\n    // 加载图片\n    loadImageToGLSurfaceView()\n    // 申请重新绘制\n    it.requestRender()\n}\n```\n这里先设置了下ContentView进去。\n其实里面没啥的，就一个RelativeLayout：\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:id=\"@+id/rootView\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n</RelativeLayout>\n```\n\n然后这里new了一个自定义的MyCustomerGLSurfaceView。\n然后在RootView里面添加了这个自定义View。\n\n然后有一个代码很重要：\n```Kotlin\n mGLSurfaceView = MyCustomerGLSurfaceView(this, myNativeRenderer, CONTEXT_CLIENT_VERSION)\n```\n这里将 渲染器作为参数传到这个自定义View里面了。\n\n### 1.5 自定义View\n继承GLSurfaceView，来自android.opengl.GLSurfaceView。\n```Kotlin\nclass MyCustomerGLSurfaceView : GLSurfaceView, ScaleGestureDetector.OnScaleGestureListener {\n    private lateinit var mRenderer: MyNativeRenderer\n    private lateinit var mScaleGestureDetector: ScaleGestureDetector\n\n    private var mPreviousX = 0f\n    private var mPreviousY = 0f\n\n    private var mXAngle = 0f\n    private var mYAngle = 0f\n\n    private var mRatioWidth = 0\n    private var mRatioHeight = 0\n\n    private var mPreScale = 1.0f\n    private var mCurScale = 1.0f\n\n    private var mDensity = 0f\n\n    private var mLastMultiTouchTime: Long = 0\n\n    constructor(context: Context?) : super(context) {}\n\n    constructor(context: Context?, attrs: AttributeSet?) : super(context, attrs) {}\n\n    constructor(context: Context?, glRender: MyNativeRenderer, eglContextVersion: Int) : this(\n        context,\n        null,\n        glRender,\n        eglContextVersion\n    )\n\n    constructor(\n        context: Context?,\n        attrs: AttributeSet?,\n        glRender: MyNativeRenderer,\n        eglContextVersion: Int\n    ) : super(context, attrs) {\n        setEGLContextClientVersion(eglContextVersion)\n        mRenderer = glRender\n\n        /*If no setEGLConfigChooser method is called,\n        then by default the view will choose an RGB_888 surface with a depth buffer depth of at least 16 bits.*/\n        // 最后 2 个参数表示分别配置 16 位的深度缓冲区和模板缓冲区\n        setEGLConfigChooser(8, 8, 8, 8, 16, 8)\n        setRenderer(mRenderer)\n        mScaleGestureDetector = ScaleGestureDetector(context, this)\n    }\n```\n\n定义触摸事件：\n```Kotlin\noverride fun onTouchEvent(event: MotionEvent): Boolean {\n    Log.d(TAG, \"onTouchEvent\")\n    if (event.pointerCount == 1) {\n        Log.d(TAG, \"event.pointerCount == 1\")\n        val currentTimeMillis = System.currentTimeMillis()\n        if (currentTimeMillis - mLastMultiTouchTime > 200) {\n            var x: Float = -1.0f\n            var y: Float = -1.0f\n            when (event.action) {\n                MotionEvent.ACTION_DOWN -> {\n                    if (mRenderer.mSampleType == IMyNativeRendererType.SAMPLE_TYPE_KEY_LESSON_FIVE) {\n                        // Android的 GLSurfaceView 在后台线程中执行渲染，必须要小心，\n                        // 只能在这个渲染线程中调用OpenGL，在Android主线程中使用UI(用户界面)相关的调用\n                        // 两个线程之间的通信可以用如下方法：\n                        // 在主线程中的 GLSurfaceView实例可以调用 queueEven() 方法传递一个Runnable给后台渲染线程\n                        // 渲染线程可以调用Activity的runOnUIThread()来传递事件(event)给主线程\n\n                        // Ensure we call switchMode() on the OpenGL thread.\n                        // queueEvent() is a method of GLSurfaceView that will do this for us.\n                        queueEvent { mRenderer.switchBlendingMode() }\n                        return true\n                    }\n                }\n\n                MotionEvent.ACTION_MOVE -> {\n                    x = event.x\n                    y = event.y\n                    val deltaX = (x - mPreviousX) / mDensity / 2\n                    val deltaY = (y - mPreviousY) / mDensity / 2\n                    if (mRenderer.mSampleType == IMyNativeRendererType.SAMPLE_TYPE_KEY_LESSON_SIX) {\n                        mRenderer.setDelta(deltaX, deltaY)\n                    } else if (mRenderer.mSampleType == IMyNativeRendererType.SAMPLE_TYPE_KEY_SCRATCH_CARD) {\n                        mRenderer.setTouchLocation(x, y)\n                        // 重新请求绘制\n                        requestRender()\n                    }\n\n                    val dy = y - mPreviousY\n                    val dx = x - mPreviousX\n                    mYAngle += (dx * TOUCH_SCALE_FACTOR).toInt()\n                    mXAngle += (dy * TOUCH_SCALE_FACTOR).toInt()\n                }\n\n                MotionEvent.ACTION_CANCEL -> {\n                    x = -1.0f\n                    y = -1.0f\n                }\n\n                MotionEvent.ACTION_UP->{\n                    if (mRenderer.mSampleType == IMyNativeRendererType.SAMPLE_TYPE_KEY_SHOCK_WAVE) {\n                        mRenderer.setTouchLocation(event.x, event.y)\n                    }\n                }\n            }\n\n            mPreviousX = x\n            mPreviousY = y\n\n            when (mRenderer.mSampleType) {\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_FBO_LEG,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_COORD_SYSTEM,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_BASE_LIGHT,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_MULTI_LIGHT,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_STENCIL_TESTING,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_PARTICLE_SYSTEM2,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_INSTANCING,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_PBO,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_UBO,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_TEXT_RENDER,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_3D_MODEL,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_3D_MODEL2,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_BLENDING,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_SKYBOX -> {\n                    Log.d(TAG, \"updateTransformMatrix\")\n                    mRenderer.updateTransformMatrix(mXAngle, mYAngle, mCurScale, mCurScale)\n                    requestRender()\n                }\n            }\n\n        }\n    } else {\n        Log.d(TAG, \"event.pointerCount != 1\")\n        mScaleGestureDetector.onTouchEvent(event)\n    }\n    return true\n}\n```\n\n测量方法：\n```Kotlin\noverride fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {\n    super.onMeasure(widthMeasureSpec, heightMeasureSpec)\n    val width = MeasureSpec.getSize(widthMeasureSpec)\n    val height = MeasureSpec.getSize(heightMeasureSpec)\n    if (0 == mRatioWidth || 0 == mRatioHeight) {\n        setMeasuredDimension(width, height)\n    } else {\n        if (width < height * mRatioWidth / mRatioHeight) {\n            setMeasuredDimension(width, width * mRatioHeight / mRatioWidth)\n        } else {\n            setMeasuredDimension(height * mRatioWidth / mRatioHeight, height)\n        }\n    }\n}\n```\n\n其实设置方法：\n```Kotlin\nfun setAspectRatio(width: Int, height: Int) {\n    Log.d(TAG, \"setAspectRatio() called with: width = [$width], height = [$height]\")\n    require(!(width < 0 || height < 0)) { \"Size cannot be negative.\" }\n    mRatioWidth = width\n    mRatioHeight = height\n    requestLayout()\n}\n\n// Hides superclass method.\nfun setRenderer(renderer: Renderer, density: Float) {\n    mRenderer = renderer as MyNativeRenderer\n    mDensity = density\n    super.setRenderer(renderer)\n}\n```\n\n定义缩放方法：\n```Kotlin\noverride fun onScale(detector: ScaleGestureDetector?): Boolean {\n        Log.d(TAG, \"onScale\")\n    when (mRenderer.mSampleType) {\n        IMyNativeRendererType.SAMPLE_TYPE_KEY_COORD_SYSTEM,\n        IMyNativeRendererType.SAMPLE_TYPE_KEY_BASE_LIGHT,\n        IMyNativeRendererType.SAMPLE_TYPE_KEY_TEXT_RENDER,\n        IMyNativeRendererType.SAMPLE_TYPE_KEY_3D_MODEL,\n        IMyNativeRendererType.SAMPLE_TYPE_KEY_3D_MODEL2,\n        IMyNativeRendererType.SAMPLE_TYPE_KEY_INSTANCING -> {\n            val preSpan = detector!!.previousSpan\n            val curSpan = detector.currentSpan\n            mCurScale = if (curSpan < preSpan) {\n                mPreScale - (preSpan - curSpan) / 200\n            } else {\n                mPreScale + (curSpan - preSpan) / 200\n            }\n            mCurScale = 0.05f.coerceAtLeast(mCurScale.coerceAtMost(80.0f))\n            mRenderer.updateTransformMatrix(mXAngle, mYAngle, mCurScale, mCurScale)\n            requestRender()\n        }\n        else -> {}\n    }\n\n    return false\n}\n\noverride fun onScaleBegin(detector: ScaleGestureDetector?): Boolean {\n    Log.d(TAG, \"onScaleBegin\")\n    return true\n}\n\noverride fun onScaleEnd(detector: ScaleGestureDetector?) {\n    Log.d(TAG, \"onScaleEnd\")\n    mPreScale = mCurScale\n    mLastMultiTouchTime = System.currentTimeMillis()\n}\n```\n\n常量定义：\n```Kotlin\ncompanion object {\n    private const val TOUCH_SCALE_FACTOR = 180.0f / 320\n    private const val TAG = \"MyCustomerGLSurfaceView\"\n}\n```\n\n### 1.6 C层流程\n首先是Java层：\n```Kotlin\nfun setRenderType(sampleCategoryType: Int, renderSampleType: Int) {\n        if (sampleCategoryType == IMyNativeRendererType.SAMPLE_TYPE) {\n            mSampleType = renderSampleType\n        }\n        nativeSetRenderType(sampleCategoryType, renderSampleType)\n    }\n```\n这里走了native方法：\n```C++\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_oyp_openglesdemo_render_MyNativeRenderer_nativeSetRenderType(\n        JNIEnv *env, jobject thiz, jint sampleCategoryType, jint renderSampleType) {\n    MyGLRenderContext::GetInstance()->SetRenderType(sampleCategoryType, renderSampleType);\n}\n```\n这里是JniImpl.cpp类中定义的方法。\n\n然后会走到MyGLRenderContext方法中，有个单例类,先看下怎么声明的类吧：\n```C++\n\n#ifndef OPENGLESDEMO_MYGLRENDERCONTEXT_H\n#define OPENGLESDEMO_MYGLRENDERCONTEXT_H\n\n#include <GLBaseSample.h>\n\nclass MyGLRenderContext\n{\n    MyGLRenderContext();\n\n    ~MyGLRenderContext();\n\npublic:\n    void SetRenderType(int sampleCategoryType, int renderSampleType);\n\n    void OnSurfaceCreated(JNIEnv *env, jobject assetManager);\n\n    void OnSurfaceChanged(int width, int height);\n\n    void OnDrawFrame();\n\n    static MyGLRenderContext* GetInstance();\n\n    static void DestroyInstance();\n\n    void SwitchBlendingMode();\n\n    void SetDelta(float x, float y);\n\n    void SetMinFilter(int filter);\n\n    void SetMagFilter(int filter);\n\n    void SetImageData(int format, int width, int height, uint8_t *pData);\n\n    void SetImageDataWithIndex(int index, int format, int width, int height, uint8_t *pData);\n\n    void UpdateTransformMatrix(float d, float d1, float d2, float d3);\n\n    void SetAudioData(short *buffer, int len);\n\n    void SetTouchLocation(float x, float y);\n\n    void SetGravityXY(float x, float y);\n\nprivate:\n    static MyGLRenderContext *m_pContext;\n    GLBaseSample *m_pBeforeSample;\n    GLBaseSample *m_pCurSample;\n\n    static NativeImage getImage(int format, int width, int height, uint8_t *pData) ;\n};\n\n#endif //OPENGLESDEMO_MYGLRENDERCONTEXT_H\n```\n\n具体怎么实现呢？\n```C++\nMyGLRenderContext *MyGLRenderContext::GetInstance() {\n//    LOGD(\"MyGLRenderContext::GetInstance\")\n    if (m_pContext == nullptr) {\n        m_pContext = new MyGLRenderContext();\n    }\n    return m_pContext;\n}\n\nvoid MyGLRenderContext::DestroyInstance() {\n    LOGD(\"MyGLRenderContext::DestroyInstance\")\n    if (m_pContext) {\n        delete m_pContext;\n        m_pContext = nullptr;\n    }\n\n}\n```\n这里具体实现了GetInstance和DestoryInstance方法。\n\n构造函数呢？\n```C++\nMyGLRenderContext::MyGLRenderContext() {\n    LOGD(\"MyGLRenderContext::MyGLRenderContext\")\n    m_pCurSample = nullptr;\n    m_pBeforeSample = nullptr;\n}\n\nMyGLRenderContext::~MyGLRenderContext() {\n    LOGD(\"MyGLRenderContext::~MyGLRenderContext\")\n\n    if (m_pCurSample) {\n        m_pCurSample->Shutdown();\n        delete m_pCurSample;\n        m_pCurSample = nullptr;\n    }\n\n    if (m_pBeforeSample) {\n        m_pBeforeSample->Shutdown();\n        delete m_pBeforeSample;\n        m_pBeforeSample = nullptr;\n    }\n}\n```\n\n需要关注一下这里面有个指针变量，GLBaseSample，是什么呢？\n目测是一个记录demo如何绘制顶点着色器的一个类。\n```C++\n\n// 注意，这个目录在java层创建，参考 com.oyp.openglesdemo.activity.NativeRenderActivity.onResume方法\n#define DEFAULT_OGL_ASSETS_DIR \"/data/data/com.oyp.openglesdemo/cache\"\n\nclass GLBaseSample {\n    \npublic:\n    GLBaseSample() {\n        VERTEX_SHADER = GL_NONE;\n        FRAGMENT_SHADER = GL_NONE;\n        m_ProgramObj = 0;\n        m_Width = 0;\n        m_Height = 0;\n    }\n\n    virtual ~GLBaseSample() {}\n\n    virtual void Create() = 0;\n\n    virtual void Change(int width, int height) {\n        LOGD(\"Change() width = %d , height = %d\\n\", width, height)\n        m_Width = width;\n        m_Height = height;\n        // Set the viewport\n        // 通知OpenGL ES 用于绘制的2D渲染表面的原点、宽度和高度。\n        // 在OpenGL ES 中，视口(Viewport) 定义所有OpenGL ES 渲染操作最终显示的2D矩形\n        // 视口(Viewport) 由原点坐标(x,y)和宽度(width) 、高度(height)定义。\n        glViewport(0, 0, m_Width, m_Height);\n    }\n\n    virtual void Draw() = 0;\n\n    virtual void Shutdown(){\n        if (m_ProgramObj) {\n            glDeleteProgram(m_ProgramObj);\n            m_ProgramObj = GL_NONE;\n        }\n        if(VERTEX_SHADER != nullptr){\n            delete[] VERTEX_SHADER;\n            VERTEX_SHADER = nullptr;\n        }\n        if(FRAGMENT_SHADER!= nullptr){\n            delete[] FRAGMENT_SHADER;\n            FRAGMENT_SHADER = nullptr;\n        }\n    }\n\n    // 默认啥都不做，等待有需要的子类去重写\n    virtual void SwitchBlendingMode() {}\n\n    virtual void SetDelta(float x, float y) {}\n\n    virtual void SetMinFilter(int filter) {}\n\n    virtual void SetMagFilter(int filter) {}\n\n    virtual void LoadImage(NativeImage *pImage) {};\n\n    virtual void LoadMultiImageWithIndex(int index, NativeImage *pImage) {}\n\n    virtual void UpdateTransformMatrix(float rotateX, float rotateY, float scaleX, float scaleY) {}\n\n    virtual void LoadAudioData(short *buffer, int len) {}\n\n    virtual void SetTouchLocation(float x, float y) {}\n\n    virtual void SetGravityXY(float x, float y) {}\n\nprotected:\n    /**\n     * 程序对象\n     */\n    GLuint m_ProgramObj;\n\n    /**\n     * 顶点着色器\n     */\n    const char *VERTEX_SHADER;\n    /**\n     * 片段着色器脚本\n     */\n    const char *FRAGMENT_SHADER;\n\n    /**\n     * 屏幕宽度\n     */\n    int m_Width;\n    /**\n     * 屏幕高度\n     */\n    int m_Height;\n};\n\n#endif //OPENGLESDEMO_GLBASESAMPLE_H\n```\n\n然后回到MyGLRenderContext中。\n具体看下setRenderType如何实现的吧？\n```C++\nvoid MyGLRenderContext::SetRenderType(int sampleCategoryType, int renderSampleType) {\n    LOGD(\"MyGLRenderContext::SetRenderType sampleCategoryType = %d, renderSampleType = %d\",\n         sampleCategoryType, renderSampleType)\n\n    if (sampleCategoryType == SAMPLE_TYPE) {\n        m_pBeforeSample = m_pCurSample;\n\n        LOGD(\"MyGLRenderContext::SetRenderType 0 m_pBeforeSample = %p\", m_pBeforeSample)\n\n        switch (renderSampleType) {\n            case SAMPLE_TYPE_KEY_TRIANGLE:\n                m_pCurSample = new NativeTriangle();\n                break;\n            case SAMPLE_TYPE_KEY_TRIANGLE2:\n                m_pCurSample = new NativeTriangle2();\n                break;\n            case SAMPLE_TYPE_KEY_TRIANGLE3:\n                m_pCurSample = new NativeTriangle3();\n                break;\n            case SAMPLE_TYPE_KEY_TRIANGLE_MAP_BUFFERS:\n                m_pCurSample = new NativeTriangleMapBuffers();\n                break;\n            case SAMPLE_TYPE_KEY_TRIANGLE_VERTEX_ARRAY_OBJECT:\n                m_pCurSample = new NativeTriangleVAO();\n                break;\n            case SAMPLE_TYPE_KEY_TRIANGLE_VERTEX_BUFFER_OBJECT:\n                m_pCurSample = new NativeTriangleVBO();\n                break;\n            case SAMPLE_TYPE_KEY_CUBE_SIMPLE_VERTEX_SHADER:\n                m_pCurSample = new NativeCubeSimpleVertexShader();\n                break;\n            case SAMPLE_TYPE_KEY_SIMPLE_TEXTURE_2D:\n                m_pCurSample = new SimpleTexture2D();\n                break;\n            case SAMPLE_TYPE_KEY_SIMPLE_TEXTURE_CUBE_MAP:\n                m_pCurSample = new SimpleTextureCubeMap();\n                break;\n            case SAMPLE_TYPE_KEY_MIPMAP_2D:\n                m_pCurSample = new MipMap2D();\n                break;\n            case SAMPLE_TYPE_KEY_TEXTURE_WRAP:\n                m_pCurSample = new TextureWrap();\n                break;\n            case SAMPLE_TYPE_KEY_MULTI_TEXTURE:\n                m_pCurSample = new MultiTexture();\n                break;\n            case SAMPLE_TYPE_KEY_PARTICLE_SYSTEM:\n                m_pCurSample = new ParticleSystem();\n                break;\n            case SAMPLE_TYPE_KEY_PARTICLE_SYSTEM_TRANSFORM_FEEDBACK:\n                m_pCurSample = new ParticleSystemTransformFeedBack();\n                break;\n            case SAMPLE_TYPE_KEY_NOISE3D:\n                m_pCurSample = new Noise3DRender();\n                break;\n            case SAMPLE_TYPE_KEY_MRT:\n                m_pCurSample = new MRT();\n                break;\n            case SAMPLE_TYPE_KEY_TERRAIN_RENDER:\n                m_pCurSample = new TerrainRender();\n                break;\n            case SAMPLE_TYPE_KEY_SHADOWS:\n                m_pCurSample = new Shadows();\n                break;\n            case SAMPLE_TYPE_KEY_LESSON_ONE:\n                m_pCurSample = new Native1Lesson();\n                break;\n            case SAMPLE_TYPE_KEY_LESSON_TWO:\n                m_pCurSample = new Native2Lesson();\n                break;\n            case SAMPLE_TYPE_KEY_LESSON_THREE:\n                m_pCurSample = new Native3Lesson();\n                break;\n            case SAMPLE_TYPE_KEY_LESSON_FOUR:\n                m_pCurSample = new Native4Lesson();\n                break;\n            case SAMPLE_TYPE_KEY_LESSON_FIVE:\n                m_pCurSample = new Native5Lesson();\n                break;\n            case SAMPLE_TYPE_KEY_LESSON_SIX:\n                m_pCurSample = new Native6Lesson();\n                break;\n            case SAMPLE_TYPE_KEY_TEXTURE_MAP:\n                m_pCurSample = new TextureMapSample();\n                break;\n            case SAMPLE_TYPE_KEY_YUV_RENDER:\n                m_pCurSample = new NV21TextureMapSample();\n                break;\n            case SAMPLE_TYPE_KEY_FBO:\n                m_pCurSample = new FBOSample();\n                break;\n            case SAMPLE_TYPE_KEY_FBO_LEG:\n                m_pCurSample = new FBOLegLengthenSample();\n                break;\n            case SAMPLE_TYPE_COORD_SYSTEM:\n                m_pCurSample = new CoordSystemSample();\n                break;\n            case SAMPLE_TYPE_KEY_BASE_LIGHT:\n                m_pCurSample = new BasicLightingSample();\n                break;\n            case SAMPLE_TYPE_KEY_MULTI_LIGHT:\n                m_pCurSample = new MultiLightingsSample();\n                break;\n            case SAMPLE_TYPE_KEY_INSTANCING:\n                m_pCurSample = new Instancing3DSample();\n                break;\n            case SAMPLE_TYPE_KEY_STENCIL_TESTING:\n                m_pCurSample = new StencilTestingSample();\n                break;\n            case SAMPLE_TYPE_KEY_BLENDING:\n                m_pCurSample = new BlendingSample();\n                break;\n            case SAMPLE_TYPE_KEY_PARTICLE_SYSTEM2:\n                m_pCurSample = new ParticlesSample2();\n                break;\n            case SAMPLE_TYPE_KEY_SKYBOX:\n                m_pCurSample = new SkyBoxSample();\n                break;\n            case SAMPLE_TYPE_KEY_PBO:\n                m_pCurSample = new PBOSample();\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_BEATING_HEART:\n                m_pCurSample = new BaseShaderToySimpleSample(\n                        SAMPLE_TYPE_KEY_SHADER_TOY_BEATING_HEART);\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_CLOUD:\n                m_pCurSample = new BaseShaderToySimpleSample(SAMPLE_TYPE_KEY_SHADER_TOY_CLOUD);\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_TIME_TUNNEL:\n                m_pCurSample = new TimeTunnelSample();\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_MAIN_SEQUENCE_STAR:\n                m_pCurSample = new BaseShaderToySimpleSample(\n                        SAMPLE_TYPE_KEY_SHADER_TOY_MAIN_SEQUENCE_STAR);\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_SKY_PATH:\n                m_pCurSample = new BaseShaderToySimpleSample(SAMPLE_TYPE_KEY_SHADER_TOY_SKY_PATH);\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_A_DAY:\n                m_pCurSample = new BaseShaderToySimpleSample(SAMPLE_TYPE_KEY_SHADER_TOY_A_DAY);\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_ATMOSPHERE_SYSTEM_TEST:\n                m_pCurSample = new BaseShaderToySimpleSample(\n                        SAMPLE_TYPE_KEY_SHADER_TOY_ATMOSPHERE_SYSTEM_TEST);\n                break;\n            case SAMPLE_TYPE_KEY_BEZIER_CURVE:\n                m_pCurSample = new BezierCurveSample();\n                break;\n            case SAMPLE_TYPE_KEY_BIG_EYES:\n                m_pCurSample = new BigEyesSample();\n                break;\n            case SAMPLE_TYPE_KEY_FACE_SLENDER:\n                m_pCurSample = new FaceSlenderSample();\n                break;\n            case SAMPLE_TYPE_KEY_BIG_HEAD:\n                m_pCurSample = new BigHeadSample();\n                break;\n            case SAMPLE_TYPE_KEY_RATARY_HEAD:\n                m_pCurSample = new RotaryHeadSample();\n                break;\n            case SAMPLE_TYPE_KEY_VISUALIZE_AUDIO:\n                m_pCurSample = new VisualizeAudioSample();\n                break;\n            case SAMPLE_TYPE_KEY_SCRATCH_CARD:\n                m_pCurSample = new ScratchCardSample();\n                break;\n            case SAMPLE_TYPE_KEY_AVATAR:\n                m_pCurSample = new AvatarSample();\n                break;\n            case SAMPLE_TYPE_KEY_SHOCK_WAVE:\n                m_pCurSample = new ShockWaveSample();\n                break;\n            case SAMPLE_TYPE_KEY_MRT2:\n                m_pCurSample = new MRTSample();\n                break;\n            case SAMPLE_TYPE_KEY_FBO_BLIT:\n                m_pCurSample = new FBOBlitSample();\n                break;\n            case SAMPLE_TYPE_KEY_UBO:\n                m_pCurSample = new UniformBufferSample();\n                break;\n            case SAMPLE_TYPE_KEY_RGB2YUV:\n                m_pCurSample = new RGB2YUVSample();\n                break;\n            case SAMPLE_TYPE_KEY_MULTI_THREAD_RENDER:\n                m_pCurSample = new SharedEGLContextSample();\n                break;\n            case SAMPLE_TYPE_KEY_TEXT_RENDER:\n                m_pCurSample = new TextRenderSample();\n                break;\n            case SAMPLE_TYPE_KEY_STAY_COLOR:\n                m_pCurSample = new PortraitStayColorExample();\n                break;\n            case SAMPLE_TYPE_KEY_TRANSITIONS_1:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_2:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_3:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_4:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_5:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_6:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_7:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_8:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_9:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_10:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_11:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_12:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_13:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_14:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_15:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_16:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_17:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_18:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_19:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_20:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_21:\n                m_pCurSample = new GLTransitionExample(renderSampleType);\n                break;\n            case SAMPLE_TYPE_KEY_3D_MODEL:\n                m_pCurSample = new Model3DSample();\n                break;\n            case SAMPLE_TYPE_KEY_3D_MODEL2:\n                m_pCurSample = new Model3DSample2();\n                break;\n            case SAMPLE_TYPE_KEY_AIR_HOCKEY:\n                m_pCurSample = new AirHockeySample();\n                break;\n\n            case SAMPLE_TYPE_KEY_RECTANGLE:\n                m_pCurSample = new NativeRectangle();\n                break;\n\n            case SAMPLE_TYPE_KEY_STICKER:\n                m_pCurSample = new StickerSample();\n                break;\n            case SAMPLE_TYPE_KEY_TIME_WATERMARK_STICKER:\n                m_pCurSample = new TimeWatermarkStickerSample();\n                break;\n\n            case SAMPLE_TYPE_KEY_GREEN_SCREEN_MATTING:\n                m_pCurSample = new GreenScreenMatting();\n                break;\n            case SAMPLE_TYPE_KEY_GREEN_SCREEN_MATTING_MIX:\n                m_pCurSample = new GreenScreenMattingMix();\n                break;\n            case SAMPLE_TYPE_KEY_ROTATE_TEXTURE:\n                m_pCurSample = new RotateTexture();\n                break;\n            default:\n                m_pCurSample = nullptr;\n                break;\n        }\n        if (m_pCurSample == nullptr) {\n            throw MyGLException(\n                    \"MyGLRenderContext::SetRenderType() 请注意：你应该忘记初始化你要展示的Sample类型 ，请补上初始化的代码，否则无法渲染\");\n        }\n        LOGD(\"MyGLRenderContext::SetRenderType m_pBeforeSample = %p, m_pCurSample=%p\",\n             m_pBeforeSample, m_pCurSample)\n    }\n}\n```\n这里是所有类型，不过我们重点是看三角形。\n三角形是这样赋值过去的。\n```C++\nswitch (renderSampleType) {\n    case SAMPLE_TYPE_KEY_TRIANGLE:\n        m_pCurSample = new NativeTriangle();\n        break;\n```\n这里new了一个NativeTriangle给到m_pCurSample指针变量。\n这个m_pCurSample就是前面在MyGLRenderContext定义的两个指针变量的其中一个。\n类型是GLBaseSample这个的指针类型。\n\n### 1.7 三角形绘制方法\n这里先声明头文件：\n```C++\n#pragma once\n\n#include <GLBaseSample.h>\n\nclass NativeTriangle : public GLBaseSample {\n\n#define VERTEX_POS_INDX       0\n\npublic:\n    NativeTriangle() = default;\n\n    virtual ~NativeTriangle() = default;\n\n    virtual void Create();\n\n    virtual void Draw();\n\n    virtual void Shutdown();\n};\n```\n这里看到了这个是必须继承我们的GLBaseSample，但不是绘制三角形必要，是我们为了统一管理demo，新建的一个Sample来，其它demo都继承这个，就比较好管理。\n\n然后再写cpp文件，去实现这个三角形：\n```C++\n#include \"NativeTriangle.h\"\n\n// 可以参考这篇讲解： https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/\n// 我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z）\n// 由于我们希望渲染一个三角形，我们一共要指定三个顶点，每个顶点都有一个3D位置。\n// 我们会将它们以标准化设备坐标的形式（OpenGL的可见区域）定义为一个float数组。\n// https://learnopengl-cn.github.io/img/01/04/ndc.png\n\n// https://developer.android.com/guide/topics/graphics/opengl#kotlin\n// 在 OpenGL 中，形状的面是由三维空间中的三个或更多点定义的表面。\n// 一个包含三个或更多三维点（在 OpenGL 中被称为顶点）的集合具有一个正面和一个背面。\n// 如何知道哪一面为正面，哪一面为背面呢？这个问题问得好！答案与环绕（即您定义形状的点的方向）有关。\n// 查看图片 ： https://developer.android.com/images/opengl/ccw-winding.png\n// 或者查看本地图片：Android_Java/Chapter_2/Hello_Triangle/ccw-winding.png\n// 在此示例中，三角形的点按照使它们沿逆时针方向绘制的顺序定义。\n// 这些坐标的绘制顺序定义了该形状的环绕方向。默认情况下，在 OpenGL 中，沿逆时针方向绘制的面为正面。\n// 因此您看到的是该形状的正面（根据 OpenGL 解释），而另一面是背面。\n//\n// 知道形状的哪一面为正面为何如此重要呢？\n// 答案与 OpenGL 的“面剔除”这一常用功能有关。\n// 面剔除是 OpenGL 环境的一个选项，它允许渲染管道忽略（不计算或不绘制）形状的背面，从而节省时间和内存并缩短处理周期：\nstatic GLfloat vVertices[] = {\n        // 逆时针 三个顶点\n        0.0f, 0.5f, 0.0f,            // 上角\n        -0.5f, -0.5f, 0.0f,          // 左下角\n        0.5f, -0.5f, 0.0f            // 右下角\n};\n```\n这里先定义下3个坐标。这个坐标以屏幕中心为（0,0）,坐标跟常规的数学坐标一致。\n\n然后是一个Create方法，具体会在MyGLRenderContext的onSurfaceCreated中会执行\n```C++\nvoid MyGLRenderContext::OnSurfaceCreated(JNIEnv *env, jobject assetManager) {\n    LOGD(\"MyGLRenderContext::OnSurfaceCreated\")\n\n    // 初始化设置assetManager  一定要记得初始化，否则会报空指针异常\n    GLUtils::setEnvAndAssetManager(env, assetManager);\n\n    if (m_pBeforeSample) {\n        m_pBeforeSample->Shutdown();\n        delete m_pBeforeSample;\n        m_pBeforeSample = nullptr;\n    }\n\n    // 就是这里会走Create\n    if (m_pCurSample) {\n        m_pCurSample->Create();\n    }\n}\n```\n\n三角形的Create方法怎么写呢？\n```C++\nvoid NativeTriangle::Create() {\n    GLUtils::printGLInfo();\n\n    // Main Program\n    // 顶点着色器\n    VERTEX_SHADER = GLUtils::openTextFile(\n            \"vertex/vertex_shader_hello_triangle.glsl\");\n    // 片段着色器\n    FRAGMENT_SHADER = GLUtils::openTextFile(\n            \"fragment/fragment_shader_hello_triangle.glsl\");\n\n    m_ProgramObj = GLUtils::createProgram(&VERTEX_SHADER, &FRAGMENT_SHADER);\n    if (!m_ProgramObj) {\n        LOGD(\"Could not Create program\")\n        return;\n    }\n    // 设置清除颜色\n    glClearColor(1.0f, 1.0f, 1.0f, 0.0f);\n}\n```\n这里主要是初始化，并没有绘制相关信息。\n\n主要绘制发生于Draw方法：\n```C++\nvoid NativeTriangle::Draw() {\n    // Clear the color buffer\n    // 清除屏幕\n    // 在OpenGL ES中，绘图中涉及多种缓冲区类型：颜色、深度、模板。\n    // 这个例子，绘制三角形，只向颜色缓冲区中绘制图形。在每个帧的开始，我们用glClear函数清除颜色缓冲区\n    // 缓冲区将用glClearColor指定的颜色清除。\n    // 这个例子，我们调用了GLES30.glClearColor(1.0f, 1.0f, 1.0f, 0.0f); 因此屏幕清为白色。\n    // 清除颜色应该由应用程序在调用颜色缓冲区的glClear之前设置。\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    // Use the program object\n    // 在glUseProgram函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象（也就是之前写的着色器)了。\n    // 当我们渲染一个物体时要使用着色器程序 , 将其设置为活动程序。这样就可以开始渲染了\n    glUseProgram(m_ProgramObj);\n\n    // Load the vertex data\n    //  顶点着色器允许我们指定任何以顶点属性为形式的输入。这使其具有很强的灵活性的同时，\n    //  它还的确意味着我们必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。\n    //  所以，我们必须在渲染前指定OpenGL该如何解释顶点数据。\n\n    //  我们的顶点缓冲数据会被解析为下面这样子：https://learnopengl-cn.github.io/img/01/04/vertex_attribute_pointer.png\n    //   . 位置数据被储存为32位（4字节）浮点值。\n    //   . 每个位置包含3个这样的值。\n    //   . 在这3个值之间没有空隙（或其他值）。这几个值在数组中紧密排列(Tightly Packed)。\n    //   . 数据中第一个值在缓冲开始的位置。\n\n    // 有了这些信息我们就可以使用glVertexAttribPointer函数告诉OpenGL该如何解析顶点数据（应用到逐个顶点属性上）了：\n    // Load the vertex data\n\n    // 第一个参数指定我们要配置的顶点属性。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入0。\n    // 第二个参数指定顶点属性的大小。顶点属性是一个vec3，它由3个值组成，所以大小是3。\n    // 第三个参数指定数据的类型，这里是GL_FLOAT(GLSL中vec*都是由浮点数值组成的)。\n    // 第四个参数定义我们是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。\n    // 第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。我们设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。\n    //      一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，\n    //      （译注: 这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节）。\n    // 最后一个参数的类型是void*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。\n    glVertexAttribPointer(VERTEX_POS_INDX, 3, GL_FLOAT, GL_FALSE, 0, vVertices);\n\n    // 现在我们已经定义了OpenGL该如何解释顶点数据，\n    // 我们现在应该使用glEnableVertexAttribArray，以顶点属性位置值作为参数，启用顶点属性；顶点属性默认是禁用的。\n    glEnableVertexAttribArray(VERTEX_POS_INDX);\n\n    // glDrawArrays函数第一个参数是我们打算绘制的OpenGL图元的类型。我们希望绘制的是一个三角形，这里传递GL_TRIANGLES给它。\n    // 第二个参数指定了顶点数组的起始索引，我们这里填0。\n    // 最后一个参数指定我们打算绘制多少个顶点，这里是3（我们只从我们的数据中渲染一个三角形，它只有3个顶点长）。\n    //        public static final int GL_POINTS                                  = 0x0000;\n    //        public static final int GL_LINES                                   = 0x0001;\n    //        public static final int GL_LINE_LOOP                               = 0x0002;\n    //        public static final int GL_LINE_STRIP                              = 0x0003;\n    //        public static final int GL_TRIANGLES                               = 0x0004;\n    //        public static final int GL_TRIANGLE_STRIP                          = 0x0005;\n    //        public static final int GL_TRIANGLE_FAN                            = 0x0006;\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n\n    // 禁用 通用顶点属性数组\n    glDisableVertexAttribArray(0);\n}\n```\n\n主要是glVertexAttribPointer中传入了顶点坐标。\n但这里还不能显示，需要解释一下顶点数据，怎么绘制顶点等。\n这里传入了一个GL_TRIANGLES，系统就知道这三个点用来绘制三角形哦。\n\n### 1.8 三角形颜色怎么设置\n其实有多种方法。\n方法1：可以在顶点后面直接加红绿蓝颜色值。\n方法2：在片段着色器里面加。\n方法3：可以通过特殊手段传值给着色器。\n\n这里我们看下第2种，直接在片段着色器中如何修改颜色。\n\n首先确认下在哪里加载片段主色器的。\n```C++\nvoid NativeRectangle::Create() {\n    GLUtils::printGLInfo();\n\n    // Main Program\n    // 顶点着色器\n    VERTEX_SHADER = GLUtils::openTextFile(\n            \"vertex/vertex_shader_hello_triangle.glsl\");\n    // 片段着色器\n    FRAGMENT_SHADER = GLUtils::openTextFile(\n            \"fragment/fragment_shader_hello_triangle.glsl\");\n\n    m_ProgramObj = GLUtils::createProgram(&VERTEX_SHADER, &FRAGMENT_SHADER);\n    if (!m_ProgramObj) {\n        LOGD(\"Could not Create program\")\n        return;\n    }\n```\nsoga，原来在这里，create方法中，定义了片段着色器fragment/fragment_shader_hello_triangle.glsl。\n顶点主色器是同理，应该是顶点的颜色。\n\n目标位置在app/src/main/assets/fragment文件夹下，原来藏这里了。\n```glsl\n#version 300 es\n// 表示OpenGL ES着色器语言V3.00\n\n// 声明着色器中浮点变量的默认精度\nprecision mediump float;\n// 声明一个输出变量fragColor，这是一个4分量的向量，\n// 写入这个变量的值将被输出到颜色缓冲器\nout vec4 fragColor;\n\nvoid main()\n{\n\t//在计算机图形中颜色被表示为有4个元素的数组：红色、绿色、蓝色和alpha(透明度)分量，\n\t//通常缩写为RGBA。当在OpenGL或GLSL中定义一个颜色的时候，\n\t//我们把颜色每个分量的强度设置在0.0到1.0之间。\n\n\t//比如说我们设置红为1.0f，绿为1.0f，我们会得到两个颜色的混合色，即黄色。\n\t//这三种颜色分量的不同调配可以生成超过1600万种不同的颜色！\n\n\t// 所有片段的着色器输出都是红色( 1.0, 0.0, 0.0, 1.0 )\n\tfragColor = vec4 ( 1.0, 0.0, 0.0, 1.0 );\n\n\t// 会输出橘黄色\n\t// fragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n}\n```\n这个是着色器语言，决定怎么显示颜色。\n这个着色器语言这么加载到程序的呢？\n继续看上面的Create方法：\n```C++\n  m_ProgramObj = GLUtils::createProgram(&VERTEX_SHADER, &FRAGMENT_SHADER);\n    if (!m_ProgramObj) {\n        LOGD(\"Could not Create program\")\n        return;\n    }\n```\n这里就加载到当前程序了。包括了顶点着色器和片段着色器。\n\n整个流程基本就是这样了，另外别忘了一个指针置空的问题。\n我们这里每个demo会走一个Shutdown方法，这里就是关闭的时候进行一些数据回收操作。\n\n\n## 2 总结\n* 首先Java层需要自定义一个View，继承GLSurfaceView，需要实现必须实现的方法。主要先在构造函数中进行必要的初始化，然后再设置Renderer，这个的Renderer是我们自己定义的一个封装好的类，这里面加载so库，方法c层的外观者类。\n\n* 在外观者类定义好Surface初始化和DrawFrame的底层方法，定义好怎么初始化，怎么绘制的方法。再自定义View中调用，实现在底层实现。\n\n* 可以通过alt+enter一键生成一个生成名字的方法，参数有JNIEnv的指针变量，可以访问jni的关键实例。然后这里面走我们自定义单例MyGLRenderContext的onDrawFrame或者其它方法。\n\n* 然后我们在MyGLRenderContext声明了一个demo指针变量，可以让这个demo执行目标函数，比如onSurfaceCreated方法，就命令里面的m_pCurSample走Create方法。\n\n* 因为外部先走setRenderType，所以我们在这里给m_pCurSample指针new对象。\n\n* 比如绘制三角形，就创建一个NativeTriangle,当然继承demo类，然后定义一个坐标集合，三角形就按照数学坐标定义3个点。然后create方法里面加载我们的着色器，着色器代码可以放在项目的assets文件夹下。然后让GLUtils创建程序。\n\n* 最后就是在自定义View的onDrawFrame绘制每一帧了。这里如果是三角形，我们就按照前面定义的坐标集合来绘制三角形即可。\n\n\n\n","slug":"Android-OpenGLES-demo-学习之一","published":1,"updated":"2023-02-07T10:49:45.477Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldu4ej0500002av7hzff1jhe","content":"<h2 id=\"1-展示一个基本的红色三角形\"><a href=\"#1-展示一个基本的红色三角形\" class=\"headerlink\" title=\"1 展示一个基本的红色三角形\"></a>1 展示一个基本的红色三角形</h2><h3 id=\"1-1-效果\"><a href=\"#1-1-效果\" class=\"headerlink\" title=\"1.1 效果\"></a>1.1 效果</h3><p><img src=\"/./Android-OpenGLES-demo-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B8%80/01.png\"><br><img src=01.png></p>\n<h3 id=\"1-2-渲染页\"><a href=\"#1-2-渲染页\" class=\"headerlink\" title=\"1.2 渲染页\"></a>1.2 渲染页</h3><pre><code class=\"line-numbers language-Kotlin\">class NativeRenderActivity : Activity(), AudioCollector.Callback, SensorEventListener &#123;\n\n    private var mMinSetting = -1\n    private var mMagSetting = -1\n\n    companion object &#123;\n        private const val MIN_DIALOG = 1\n        private const val CONTEXT_CLIENT_VERSION = 3\n        private const val MAG_DIALOG = 2\n        private const val MIN_SETTING = &quot;min_setting&quot;\n        private const val MAG_SETTING = &quot;mag_setting&quot;\n        private const val TAG: String = &quot;NativeRenderActivity&quot;\n\n        private val REQUEST_PERMISSIONS = arrayOf(\n            Manifest.permission.WRITE_EXTERNAL_STORAGE,\n            Manifest.permission.RECORD_AUDIO\n        )\n        private const val PERMISSION_REQUEST_CODE = 1\n    &#125;\n\n    private var mRootView: ViewGroup? = null\n\n    /**\n     * Hold a reference to our GLSurfaceView\n     */\n    private var mGLSurfaceView: MyCustomerGLSurfaceView? = null\n\n    private var renderer: MyNativeRenderer? = null\n\n    var type = IMyNativeRendererType.SAMPLE_TYPE\n\n\n    private var mAudioCollector: AudioCollector? = null\n\n    private var mSensorManager: SensorManager? = null\n</code></pre>\n<p>这里声明了必要的类。</p>\n<p>MyCustomerGLSurfaceView应该是自定义的GLSurfaceView。</p>\n<h3 id=\"1-3-自定义渲染\"><a href=\"#1-3-自定义渲染\" class=\"headerlink\" title=\"1.3 自定义渲染\"></a>1.3 自定义渲染</h3><p>引用自己写的so库。</p>\n<pre><code class=\"line-numbers language-Kotlin\">class MyNativeRenderer(activity: Activity) : GLSurfaceView.Renderer, RenderAction &#123;\n    private var mActivity: Activity = activity\n    var mSampleType = 0\n\n    init &#123;\n        System.loadLibrary(&quot;ouyangpeng-opengles-lib&quot;)\n    &#125;\n</code></pre>\n<p>这里的ouyangpeng-opengles-lib就是我们自己编写库，这里应该是cpp文件，但这里loadLibrary是load so库，编译时会打包成so库。</p>\n<pre><code class=\"line-numbers language-Kotlin\">////////////////////////////////// Native 方法///////////////////////////////////////\n    // 通用的\n    private external fun nativeSurfaceCreate(assetManager: AssetManager)\n    private external fun nativeSurfaceChange(width: Int, height: Int)\n    private external fun nativeDrawFrame()\n    private external fun nativeSetRenderType(sampleCategoryType: Int, renderSampleType: Int)\n    private external fun nativeOnDestroy()\n\n    // 特定的方法\n    private external fun nativeSwitchBlendingMode()\n\n    // 特定的方法\n    private external fun nativeSetDelta(x: Float, y: Float)\n    private external fun nativeSetMinFilter(filter: Int)\n    private external fun nativeSetMagFilter(filter: Int)\n\n    private external fun nativeSetImageData(\n        format: Int,\n        width: Int,\n        height: Int,\n        imageData: ByteArray?\n    )\n\n    private external fun nativeSetImageDataWithIndex(\n        index: Int,\n        format: Int,\n        width: Int,\n        height: Int,\n        imageData: ByteArray?\n    )\n\n    private external fun nativeUpdateTransformMatrix(\n        rotateX: Float,\n        rotateY: Float,\n        scaleX: Float,\n        scaleY: Float\n    )\n\n    private external fun nativeSetAudioData(audioData: ShortArray)\n\n    private external fun nativeSetTouchLocation(x: Float, y: Float)\n\n    private external fun nativeSetGravityXY(x: Float, y: Float)\n</code></pre>\n<p>这里定义了native方法。<br>具体实现的地方在cpp文件中。</p>\n<pre><code class=\"line-numbers language-Kotlin\">////////////////////////////////// Java 方法///////////////////////////////////////\n\n/**\n    * 当Surface被创建的时候，GLSurfaceView 会调用这个方法。\n    * 这发送在应用程序第一次运行的时候，并且，当设备被唤醒或者用户从其他Activity切换换来时，\n    * 这个方法也可能被调用。在实践中，这意味着，当应用程序运行时，本方法可能会被调用多次。\n    *\n    *\n    * 为什么会有一个未被使用的参数类型GL10呢？\n    * 它是OpenGL ES 1.0的API遗留下来的。如果要编写OpenGL ES 1.0的渲染器，就要用这个参数。\n    * 但是，对应OpenGL ES 3.0，GLES20/GLEL30类提供了静态方法来读取。\n    */\noverride fun onSurfaceCreated(gl: GL10, config: EGLConfig) &#123;\n    val assetManager: AssetManager = mActivity.assets\n    nativeSurfaceCreate(assetManager)\n&#125;\n\n/**\n    * 当Surface被创建以后，每次Surface尺寸变化时，这个方法都会被 GLSurfaceView 调用到。\n    * 在横屏、竖屏来回切换的时候，Surface尺寸会发生变化\n    */\noverride fun onSurfaceChanged(gl: GL10, width: Int, height: Int) &#123;\n    nativeSurfaceChange(width, height)\n&#125;\n\n/**\n    * 当绘制一帧时，这个方法会被 GLSurfaceView 调用。\n    * 在这个方法中，我们一定要绘制一些东西，即使只是清空屏幕。\n    * 因为，在这个方法返回后，渲染缓冲区会被交换并显示在屏幕上，\n    * 如果什么都没画，可能会看到糟糕的闪烁效果。\n    */\noverride fun onDrawFrame(gl: GL10) &#123;\n    // 提前赋值，变化水印的bitmap\n    if (mSampleType == IMyNativeRendererType.SAMPLE_TYPE_KEY_TIME_WATERMARK_STICKER) &#123;\n        // 获取时间水印的bitmap\n        val mBitmap: Bitmap = CommonUtils.getTimeWaterBitmap()\n\n        val bytes = mBitmap.byteCount\n        val buf = ByteBuffer.allocate(bytes)\n        mBitmap.copyPixelsToBuffer(buf)\n        val byteArray = buf.array()\n        setImageDataWithIndex(\n            0,\n            ImageFormat.IMAGE_FORMAT_RGBA,\n            mBitmap.width,\n            mBitmap.height,\n            byteArray\n        )\n    &#125;\n\n    // native层去绘制\n    nativeDrawFrame()\n&#125;\n\nfun setRenderType(sampleCategoryType: Int, renderSampleType: Int) &#123;\n    if (sampleCategoryType == IMyNativeRendererType.SAMPLE_TYPE) &#123;\n        mSampleType = renderSampleType\n    &#125;\n    nativeSetRenderType(sampleCategoryType, renderSampleType)\n&#125;\n\nfun onDestroy() &#123;\n    nativeOnDestroy()\n&#125;\n\noverride fun switchBlendingMode() &#123;\n    nativeSwitchBlendingMode()\n&#125;\n\noverride fun setMinFilter(filter: Int) &#123;\n    nativeSetMinFilter(filter)\n&#125;\n\noverride fun setMagFilter(filter: Int) &#123;\n    nativeSetMagFilter(filter)\n&#125;\n\noverride fun setDelta(deltaX: Float, deltaY: Float) &#123;\n    nativeSetDelta(deltaX, deltaY)\n&#125;\n\noverride fun setImageData(\n    format: Int,\n    width: Int,\n    height: Int,\n    imageData: ByteArray\n) &#123;\n    nativeSetImageData(format, width, height, imageData)\n&#125;\n\noverride fun setImageDataWithIndex(\n    index: Int,\n    format: Int,\n    width: Int,\n    height: Int,\n    imageData: ByteArray\n) &#123;\n    nativeSetImageDataWithIndex(index, format, width, height, imageData)\n&#125;\n\noverride fun updateTransformMatrix(\n    rotateX: Float,\n    rotateY: Float,\n    scaleX: Float,\n    scaleY: Float\n) &#123;\n    nativeUpdateTransformMatrix(rotateX, rotateY, scaleX, scaleY)\n&#125;\n\noverride fun setAudioData(audioData: ShortArray) &#123;\n    nativeSetAudioData(audioData)\n&#125;\n\noverride fun setTouchLocation(x: Float, y: Float) &#123;\n    nativeSetTouchLocation(x,y)\n&#125;\n\noverride fun setGravityXY(x: Float, y: Float)&#123;\n    nativeSetGravityXY(x,y)\n&#125;\n</code></pre>\n<p>主要渲染的方式应该是走这里。<br>onDrawFrame方法就是绘制每一帧。</p>\n<p>里面是用：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n    * 当绘制一帧时，这个方法会被 GLSurfaceView 调用。\n    * 在这个方法中，我们一定要绘制一些东西，即使只是清空屏幕。\n    * 因为，在这个方法返回后，渲染缓冲区会被交换并显示在屏幕上，\n    * 如果什么都没画，可能会看到糟糕的闪烁效果。\n    */\noverride fun onDrawFrame(gl: GL10) &#123;\n    // 提前赋值，变化水印的bitmap\n    if (mSampleType == IMyNativeRendererType.SAMPLE_TYPE_KEY_TIME_WATERMARK_STICKER) &#123;\n        // 获取时间水印的bitmap\n        val mBitmap: Bitmap = CommonUtils.getTimeWaterBitmap()\n\n        val bytes = mBitmap.byteCount\n        val buf = ByteBuffer.allocate(bytes)\n        mBitmap.copyPixelsToBuffer(buf)\n        val byteArray = buf.array()\n        setImageDataWithIndex(\n            0,\n            ImageFormat.IMAGE_FORMAT_RGBA,\n            mBitmap.width,\n            mBitmap.height,\n            byteArray\n        )\n    &#125;\n\n    // native层去绘制\n    nativeDrawFrame()\n&#125;\n</code></pre>\n<p>native层去绘制的。</p>\n<h3 id=\"1-4-布局\"><a href=\"#1-4-布局\" class=\"headerlink\" title=\"1.4 布局\"></a>1.4 布局</h3><pre><code class=\"line-numbers language-Kotlin\">setContentView(R.layout.activity_native_render)\nmRootView = findViewById&lt;View&gt;(R.id.rootView) as ViewGroup\n\n// Tell the surface view we want to create an OpenGL ES 3.0-compatible context,\n// and set an OpenGL ES 3.0-compatible renderer.\nmGLSurfaceView =\n    MyCustomerGLSurfaceView(this, myNativeRenderer, CONTEXT_CLIENT_VERSION)\n\nmGLSurfaceView?.let &#123;\n    val lp = RelativeLayout.LayoutParams(\n        ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT\n    )\n    lp.addRule(RelativeLayout.CENTER_IN_PARENT)\n    mRootView!!.addView(it, lp)\n\n    if (mRootView!!.width != it.width\n        || mRootView!!.height != it.height\n    ) &#123;\n        it.setAspectRatio(mRootView!!.width, mRootView!!.height)\n    &#125;\n    // 设置渲染模式\n    setRenderMode(it)\n    // 加载图片\n    loadImageToGLSurfaceView()\n    // 申请重新绘制\n    it.requestRender()\n&#125;\n</code></pre>\n<p>这里先设置了下ContentView进去。<br>其实里面没啥的，就一个RelativeLayout：</p>\n<pre><code class=\"line-numbers language-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:id=&quot;@+id/rootView&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;&gt;\n\n&lt;/RelativeLayout&gt;\n</code></pre>\n<p>然后这里new了一个自定义的MyCustomerGLSurfaceView。<br>然后在RootView里面添加了这个自定义View。</p>\n<p>然后有一个代码很重要：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> mGLSurfaceView = MyCustomerGLSurfaceView(this, myNativeRenderer, CONTEXT_CLIENT_VERSION)\n</code></pre>\n<p>这里将 渲染器作为参数传到这个自定义View里面了。</p>\n<h3 id=\"1-5-自定义View\"><a href=\"#1-5-自定义View\" class=\"headerlink\" title=\"1.5 自定义View\"></a>1.5 自定义View</h3><p>继承GLSurfaceView，来自android.opengl.GLSurfaceView。</p>\n<pre><code class=\"line-numbers language-Kotlin\">class MyCustomerGLSurfaceView : GLSurfaceView, ScaleGestureDetector.OnScaleGestureListener &#123;\n    private lateinit var mRenderer: MyNativeRenderer\n    private lateinit var mScaleGestureDetector: ScaleGestureDetector\n\n    private var mPreviousX = 0f\n    private var mPreviousY = 0f\n\n    private var mXAngle = 0f\n    private var mYAngle = 0f\n\n    private var mRatioWidth = 0\n    private var mRatioHeight = 0\n\n    private var mPreScale = 1.0f\n    private var mCurScale = 1.0f\n\n    private var mDensity = 0f\n\n    private var mLastMultiTouchTime: Long = 0\n\n    constructor(context: Context?) : super(context) &#123;&#125;\n\n    constructor(context: Context?, attrs: AttributeSet?) : super(context, attrs) &#123;&#125;\n\n    constructor(context: Context?, glRender: MyNativeRenderer, eglContextVersion: Int) : this(\n        context,\n        null,\n        glRender,\n        eglContextVersion\n    )\n\n    constructor(\n        context: Context?,\n        attrs: AttributeSet?,\n        glRender: MyNativeRenderer,\n        eglContextVersion: Int\n    ) : super(context, attrs) &#123;\n        setEGLContextClientVersion(eglContextVersion)\n        mRenderer = glRender\n\n        /*If no setEGLConfigChooser method is called,\n        then by default the view will choose an RGB_888 surface with a depth buffer depth of at least 16 bits.*/\n        // 最后 2 个参数表示分别配置 16 位的深度缓冲区和模板缓冲区\n        setEGLConfigChooser(8, 8, 8, 8, 16, 8)\n        setRenderer(mRenderer)\n        mScaleGestureDetector = ScaleGestureDetector(context, this)\n    &#125;\n</code></pre>\n<p>定义触摸事件：</p>\n<pre><code class=\"line-numbers language-Kotlin\">override fun onTouchEvent(event: MotionEvent): Boolean &#123;\n    Log.d(TAG, &quot;onTouchEvent&quot;)\n    if (event.pointerCount == 1) &#123;\n        Log.d(TAG, &quot;event.pointerCount == 1&quot;)\n        val currentTimeMillis = System.currentTimeMillis()\n        if (currentTimeMillis - mLastMultiTouchTime &gt; 200) &#123;\n            var x: Float = -1.0f\n            var y: Float = -1.0f\n            when (event.action) &#123;\n                MotionEvent.ACTION_DOWN -&gt; &#123;\n                    if (mRenderer.mSampleType == IMyNativeRendererType.SAMPLE_TYPE_KEY_LESSON_FIVE) &#123;\n                        // Android的 GLSurfaceView 在后台线程中执行渲染，必须要小心，\n                        // 只能在这个渲染线程中调用OpenGL，在Android主线程中使用UI(用户界面)相关的调用\n                        // 两个线程之间的通信可以用如下方法：\n                        // 在主线程中的 GLSurfaceView实例可以调用 queueEven() 方法传递一个Runnable给后台渲染线程\n                        // 渲染线程可以调用Activity的runOnUIThread()来传递事件(event)给主线程\n\n                        // Ensure we call switchMode() on the OpenGL thread.\n                        // queueEvent() is a method of GLSurfaceView that will do this for us.\n                        queueEvent &#123; mRenderer.switchBlendingMode() &#125;\n                        return true\n                    &#125;\n                &#125;\n\n                MotionEvent.ACTION_MOVE -&gt; &#123;\n                    x = event.x\n                    y = event.y\n                    val deltaX = (x - mPreviousX) / mDensity / 2\n                    val deltaY = (y - mPreviousY) / mDensity / 2\n                    if (mRenderer.mSampleType == IMyNativeRendererType.SAMPLE_TYPE_KEY_LESSON_SIX) &#123;\n                        mRenderer.setDelta(deltaX, deltaY)\n                    &#125; else if (mRenderer.mSampleType == IMyNativeRendererType.SAMPLE_TYPE_KEY_SCRATCH_CARD) &#123;\n                        mRenderer.setTouchLocation(x, y)\n                        // 重新请求绘制\n                        requestRender()\n                    &#125;\n\n                    val dy = y - mPreviousY\n                    val dx = x - mPreviousX\n                    mYAngle += (dx * TOUCH_SCALE_FACTOR).toInt()\n                    mXAngle += (dy * TOUCH_SCALE_FACTOR).toInt()\n                &#125;\n\n                MotionEvent.ACTION_CANCEL -&gt; &#123;\n                    x = -1.0f\n                    y = -1.0f\n                &#125;\n\n                MotionEvent.ACTION_UP-&gt;&#123;\n                    if (mRenderer.mSampleType == IMyNativeRendererType.SAMPLE_TYPE_KEY_SHOCK_WAVE) &#123;\n                        mRenderer.setTouchLocation(event.x, event.y)\n                    &#125;\n                &#125;\n            &#125;\n\n            mPreviousX = x\n            mPreviousY = y\n\n            when (mRenderer.mSampleType) &#123;\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_FBO_LEG,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_COORD_SYSTEM,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_BASE_LIGHT,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_MULTI_LIGHT,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_STENCIL_TESTING,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_PARTICLE_SYSTEM2,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_INSTANCING,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_PBO,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_UBO,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_TEXT_RENDER,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_3D_MODEL,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_3D_MODEL2,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_BLENDING,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_SKYBOX -&gt; &#123;\n                    Log.d(TAG, &quot;updateTransformMatrix&quot;)\n                    mRenderer.updateTransformMatrix(mXAngle, mYAngle, mCurScale, mCurScale)\n                    requestRender()\n                &#125;\n            &#125;\n\n        &#125;\n    &#125; else &#123;\n        Log.d(TAG, &quot;event.pointerCount != 1&quot;)\n        mScaleGestureDetector.onTouchEvent(event)\n    &#125;\n    return true\n&#125;\n</code></pre>\n<p>测量方法：</p>\n<pre><code class=\"line-numbers language-Kotlin\">override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) &#123;\n    super.onMeasure(widthMeasureSpec, heightMeasureSpec)\n    val width = MeasureSpec.getSize(widthMeasureSpec)\n    val height = MeasureSpec.getSize(heightMeasureSpec)\n    if (0 == mRatioWidth || 0 == mRatioHeight) &#123;\n        setMeasuredDimension(width, height)\n    &#125; else &#123;\n        if (width &lt; height * mRatioWidth / mRatioHeight) &#123;\n            setMeasuredDimension(width, width * mRatioHeight / mRatioWidth)\n        &#125; else &#123;\n            setMeasuredDimension(height * mRatioWidth / mRatioHeight, height)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>其实设置方法：</p>\n<pre><code class=\"line-numbers language-Kotlin\">fun setAspectRatio(width: Int, height: Int) &#123;\n    Log.d(TAG, &quot;setAspectRatio() called with: width = [$width], height = [$height]&quot;)\n    require(!(width &lt; 0 || height &lt; 0)) &#123; &quot;Size cannot be negative.&quot; &#125;\n    mRatioWidth = width\n    mRatioHeight = height\n    requestLayout()\n&#125;\n\n// Hides superclass method.\nfun setRenderer(renderer: Renderer, density: Float) &#123;\n    mRenderer = renderer as MyNativeRenderer\n    mDensity = density\n    super.setRenderer(renderer)\n&#125;\n</code></pre>\n<p>定义缩放方法：</p>\n<pre><code class=\"line-numbers language-Kotlin\">override fun onScale(detector: ScaleGestureDetector?): Boolean &#123;\n        Log.d(TAG, &quot;onScale&quot;)\n    when (mRenderer.mSampleType) &#123;\n        IMyNativeRendererType.SAMPLE_TYPE_KEY_COORD_SYSTEM,\n        IMyNativeRendererType.SAMPLE_TYPE_KEY_BASE_LIGHT,\n        IMyNativeRendererType.SAMPLE_TYPE_KEY_TEXT_RENDER,\n        IMyNativeRendererType.SAMPLE_TYPE_KEY_3D_MODEL,\n        IMyNativeRendererType.SAMPLE_TYPE_KEY_3D_MODEL2,\n        IMyNativeRendererType.SAMPLE_TYPE_KEY_INSTANCING -&gt; &#123;\n            val preSpan = detector!!.previousSpan\n            val curSpan = detector.currentSpan\n            mCurScale = if (curSpan &lt; preSpan) &#123;\n                mPreScale - (preSpan - curSpan) / 200\n            &#125; else &#123;\n                mPreScale + (curSpan - preSpan) / 200\n            &#125;\n            mCurScale = 0.05f.coerceAtLeast(mCurScale.coerceAtMost(80.0f))\n            mRenderer.updateTransformMatrix(mXAngle, mYAngle, mCurScale, mCurScale)\n            requestRender()\n        &#125;\n        else -&gt; &#123;&#125;\n    &#125;\n\n    return false\n&#125;\n\noverride fun onScaleBegin(detector: ScaleGestureDetector?): Boolean &#123;\n    Log.d(TAG, &quot;onScaleBegin&quot;)\n    return true\n&#125;\n\noverride fun onScaleEnd(detector: ScaleGestureDetector?) &#123;\n    Log.d(TAG, &quot;onScaleEnd&quot;)\n    mPreScale = mCurScale\n    mLastMultiTouchTime = System.currentTimeMillis()\n&#125;\n</code></pre>\n<p>常量定义：</p>\n<pre><code class=\"line-numbers language-Kotlin\">companion object &#123;\n    private const val TOUCH_SCALE_FACTOR = 180.0f / 320\n    private const val TAG = &quot;MyCustomerGLSurfaceView&quot;\n&#125;\n</code></pre>\n<h3 id=\"1-6-C层流程\"><a href=\"#1-6-C层流程\" class=\"headerlink\" title=\"1.6 C层流程\"></a>1.6 C层流程</h3><p>首先是Java层：</p>\n<pre><code class=\"line-numbers language-Kotlin\">fun setRenderType(sampleCategoryType: Int, renderSampleType: Int) &#123;\n        if (sampleCategoryType == IMyNativeRendererType.SAMPLE_TYPE) &#123;\n            mSampleType = renderSampleType\n        &#125;\n        nativeSetRenderType(sampleCategoryType, renderSampleType)\n    &#125;\n</code></pre>\n<p>这里走了native方法：</p>\n<pre><code class=\"line-numbers language-C++\">extern &quot;C&quot;\nJNIEXPORT void JNICALL\nJava_com_oyp_openglesdemo_render_MyNativeRenderer_nativeSetRenderType(\n        JNIEnv *env, jobject thiz, jint sampleCategoryType, jint renderSampleType) &#123;\n    MyGLRenderContext::GetInstance()-&gt;SetRenderType(sampleCategoryType, renderSampleType);\n&#125;\n</code></pre>\n<p>这里是JniImpl.cpp类中定义的方法。</p>\n<p>然后会走到MyGLRenderContext方法中，有个单例类,先看下怎么声明的类吧：</p>\n<pre><code class=\"line-numbers language-C++\">\n#ifndef OPENGLESDEMO_MYGLRENDERCONTEXT_H\n#define OPENGLESDEMO_MYGLRENDERCONTEXT_H\n\n#include &lt;GLBaseSample.h&gt;\n\nclass MyGLRenderContext\n&#123;\n    MyGLRenderContext();\n\n    ~MyGLRenderContext();\n\npublic:\n    void SetRenderType(int sampleCategoryType, int renderSampleType);\n\n    void OnSurfaceCreated(JNIEnv *env, jobject assetManager);\n\n    void OnSurfaceChanged(int width, int height);\n\n    void OnDrawFrame();\n\n    static MyGLRenderContext* GetInstance();\n\n    static void DestroyInstance();\n\n    void SwitchBlendingMode();\n\n    void SetDelta(float x, float y);\n\n    void SetMinFilter(int filter);\n\n    void SetMagFilter(int filter);\n\n    void SetImageData(int format, int width, int height, uint8_t *pData);\n\n    void SetImageDataWithIndex(int index, int format, int width, int height, uint8_t *pData);\n\n    void UpdateTransformMatrix(float d, float d1, float d2, float d3);\n\n    void SetAudioData(short *buffer, int len);\n\n    void SetTouchLocation(float x, float y);\n\n    void SetGravityXY(float x, float y);\n\nprivate:\n    static MyGLRenderContext *m_pContext;\n    GLBaseSample *m_pBeforeSample;\n    GLBaseSample *m_pCurSample;\n\n    static NativeImage getImage(int format, int width, int height, uint8_t *pData) ;\n&#125;;\n\n#endif //OPENGLESDEMO_MYGLRENDERCONTEXT_H\n</code></pre>\n<p>具体怎么实现呢？</p>\n<pre><code class=\"line-numbers language-C++\">MyGLRenderContext *MyGLRenderContext::GetInstance() &#123;\n//    LOGD(&quot;MyGLRenderContext::GetInstance&quot;)\n    if (m_pContext == nullptr) &#123;\n        m_pContext = new MyGLRenderContext();\n    &#125;\n    return m_pContext;\n&#125;\n\nvoid MyGLRenderContext::DestroyInstance() &#123;\n    LOGD(&quot;MyGLRenderContext::DestroyInstance&quot;)\n    if (m_pContext) &#123;\n        delete m_pContext;\n        m_pContext = nullptr;\n    &#125;\n\n&#125;\n</code></pre>\n<p>这里具体实现了GetInstance和DestoryInstance方法。</p>\n<p>构造函数呢？</p>\n<pre><code class=\"line-numbers language-C++\">MyGLRenderContext::MyGLRenderContext() &#123;\n    LOGD(&quot;MyGLRenderContext::MyGLRenderContext&quot;)\n    m_pCurSample = nullptr;\n    m_pBeforeSample = nullptr;\n&#125;\n\nMyGLRenderContext::~MyGLRenderContext() &#123;\n    LOGD(&quot;MyGLRenderContext::~MyGLRenderContext&quot;)\n\n    if (m_pCurSample) &#123;\n        m_pCurSample-&gt;Shutdown();\n        delete m_pCurSample;\n        m_pCurSample = nullptr;\n    &#125;\n\n    if (m_pBeforeSample) &#123;\n        m_pBeforeSample-&gt;Shutdown();\n        delete m_pBeforeSample;\n        m_pBeforeSample = nullptr;\n    &#125;\n&#125;\n</code></pre>\n<p>需要关注一下这里面有个指针变量，GLBaseSample，是什么呢？<br>目测是一个记录demo如何绘制顶点着色器的一个类。</p>\n<pre><code class=\"line-numbers language-C++\">\n// 注意，这个目录在java层创建，参考 com.oyp.openglesdemo.activity.NativeRenderActivity.onResume方法\n#define DEFAULT_OGL_ASSETS_DIR &quot;/data/data/com.oyp.openglesdemo/cache&quot;\n\nclass GLBaseSample &#123;\n    \npublic:\n    GLBaseSample() &#123;\n        VERTEX_SHADER = GL_NONE;\n        FRAGMENT_SHADER = GL_NONE;\n        m_ProgramObj = 0;\n        m_Width = 0;\n        m_Height = 0;\n    &#125;\n\n    virtual ~GLBaseSample() &#123;&#125;\n\n    virtual void Create() = 0;\n\n    virtual void Change(int width, int height) &#123;\n        LOGD(&quot;Change() width = %d , height = %d\\n&quot;, width, height)\n        m_Width = width;\n        m_Height = height;\n        // Set the viewport\n        // 通知OpenGL ES 用于绘制的2D渲染表面的原点、宽度和高度。\n        // 在OpenGL ES 中，视口(Viewport) 定义所有OpenGL ES 渲染操作最终显示的2D矩形\n        // 视口(Viewport) 由原点坐标(x,y)和宽度(width) 、高度(height)定义。\n        glViewport(0, 0, m_Width, m_Height);\n    &#125;\n\n    virtual void Draw() = 0;\n\n    virtual void Shutdown()&#123;\n        if (m_ProgramObj) &#123;\n            glDeleteProgram(m_ProgramObj);\n            m_ProgramObj = GL_NONE;\n        &#125;\n        if(VERTEX_SHADER != nullptr)&#123;\n            delete[] VERTEX_SHADER;\n            VERTEX_SHADER = nullptr;\n        &#125;\n        if(FRAGMENT_SHADER!= nullptr)&#123;\n            delete[] FRAGMENT_SHADER;\n            FRAGMENT_SHADER = nullptr;\n        &#125;\n    &#125;\n\n    // 默认啥都不做，等待有需要的子类去重写\n    virtual void SwitchBlendingMode() &#123;&#125;\n\n    virtual void SetDelta(float x, float y) &#123;&#125;\n\n    virtual void SetMinFilter(int filter) &#123;&#125;\n\n    virtual void SetMagFilter(int filter) &#123;&#125;\n\n    virtual void LoadImage(NativeImage *pImage) &#123;&#125;;\n\n    virtual void LoadMultiImageWithIndex(int index, NativeImage *pImage) &#123;&#125;\n\n    virtual void UpdateTransformMatrix(float rotateX, float rotateY, float scaleX, float scaleY) &#123;&#125;\n\n    virtual void LoadAudioData(short *buffer, int len) &#123;&#125;\n\n    virtual void SetTouchLocation(float x, float y) &#123;&#125;\n\n    virtual void SetGravityXY(float x, float y) &#123;&#125;\n\nprotected:\n    /**\n     * 程序对象\n     */\n    GLuint m_ProgramObj;\n\n    /**\n     * 顶点着色器\n     */\n    const char *VERTEX_SHADER;\n    /**\n     * 片段着色器脚本\n     */\n    const char *FRAGMENT_SHADER;\n\n    /**\n     * 屏幕宽度\n     */\n    int m_Width;\n    /**\n     * 屏幕高度\n     */\n    int m_Height;\n&#125;;\n\n#endif //OPENGLESDEMO_GLBASESAMPLE_H\n</code></pre>\n<p>然后回到MyGLRenderContext中。<br>具体看下setRenderType如何实现的吧？</p>\n<pre><code class=\"line-numbers language-C++\">void MyGLRenderContext::SetRenderType(int sampleCategoryType, int renderSampleType) &#123;\n    LOGD(&quot;MyGLRenderContext::SetRenderType sampleCategoryType = %d, renderSampleType = %d&quot;,\n         sampleCategoryType, renderSampleType)\n\n    if (sampleCategoryType == SAMPLE_TYPE) &#123;\n        m_pBeforeSample = m_pCurSample;\n\n        LOGD(&quot;MyGLRenderContext::SetRenderType 0 m_pBeforeSample = %p&quot;, m_pBeforeSample)\n\n        switch (renderSampleType) &#123;\n            case SAMPLE_TYPE_KEY_TRIANGLE:\n                m_pCurSample = new NativeTriangle();\n                break;\n            case SAMPLE_TYPE_KEY_TRIANGLE2:\n                m_pCurSample = new NativeTriangle2();\n                break;\n            case SAMPLE_TYPE_KEY_TRIANGLE3:\n                m_pCurSample = new NativeTriangle3();\n                break;\n            case SAMPLE_TYPE_KEY_TRIANGLE_MAP_BUFFERS:\n                m_pCurSample = new NativeTriangleMapBuffers();\n                break;\n            case SAMPLE_TYPE_KEY_TRIANGLE_VERTEX_ARRAY_OBJECT:\n                m_pCurSample = new NativeTriangleVAO();\n                break;\n            case SAMPLE_TYPE_KEY_TRIANGLE_VERTEX_BUFFER_OBJECT:\n                m_pCurSample = new NativeTriangleVBO();\n                break;\n            case SAMPLE_TYPE_KEY_CUBE_SIMPLE_VERTEX_SHADER:\n                m_pCurSample = new NativeCubeSimpleVertexShader();\n                break;\n            case SAMPLE_TYPE_KEY_SIMPLE_TEXTURE_2D:\n                m_pCurSample = new SimpleTexture2D();\n                break;\n            case SAMPLE_TYPE_KEY_SIMPLE_TEXTURE_CUBE_MAP:\n                m_pCurSample = new SimpleTextureCubeMap();\n                break;\n            case SAMPLE_TYPE_KEY_MIPMAP_2D:\n                m_pCurSample = new MipMap2D();\n                break;\n            case SAMPLE_TYPE_KEY_TEXTURE_WRAP:\n                m_pCurSample = new TextureWrap();\n                break;\n            case SAMPLE_TYPE_KEY_MULTI_TEXTURE:\n                m_pCurSample = new MultiTexture();\n                break;\n            case SAMPLE_TYPE_KEY_PARTICLE_SYSTEM:\n                m_pCurSample = new ParticleSystem();\n                break;\n            case SAMPLE_TYPE_KEY_PARTICLE_SYSTEM_TRANSFORM_FEEDBACK:\n                m_pCurSample = new ParticleSystemTransformFeedBack();\n                break;\n            case SAMPLE_TYPE_KEY_NOISE3D:\n                m_pCurSample = new Noise3DRender();\n                break;\n            case SAMPLE_TYPE_KEY_MRT:\n                m_pCurSample = new MRT();\n                break;\n            case SAMPLE_TYPE_KEY_TERRAIN_RENDER:\n                m_pCurSample = new TerrainRender();\n                break;\n            case SAMPLE_TYPE_KEY_SHADOWS:\n                m_pCurSample = new Shadows();\n                break;\n            case SAMPLE_TYPE_KEY_LESSON_ONE:\n                m_pCurSample = new Native1Lesson();\n                break;\n            case SAMPLE_TYPE_KEY_LESSON_TWO:\n                m_pCurSample = new Native2Lesson();\n                break;\n            case SAMPLE_TYPE_KEY_LESSON_THREE:\n                m_pCurSample = new Native3Lesson();\n                break;\n            case SAMPLE_TYPE_KEY_LESSON_FOUR:\n                m_pCurSample = new Native4Lesson();\n                break;\n            case SAMPLE_TYPE_KEY_LESSON_FIVE:\n                m_pCurSample = new Native5Lesson();\n                break;\n            case SAMPLE_TYPE_KEY_LESSON_SIX:\n                m_pCurSample = new Native6Lesson();\n                break;\n            case SAMPLE_TYPE_KEY_TEXTURE_MAP:\n                m_pCurSample = new TextureMapSample();\n                break;\n            case SAMPLE_TYPE_KEY_YUV_RENDER:\n                m_pCurSample = new NV21TextureMapSample();\n                break;\n            case SAMPLE_TYPE_KEY_FBO:\n                m_pCurSample = new FBOSample();\n                break;\n            case SAMPLE_TYPE_KEY_FBO_LEG:\n                m_pCurSample = new FBOLegLengthenSample();\n                break;\n            case SAMPLE_TYPE_COORD_SYSTEM:\n                m_pCurSample = new CoordSystemSample();\n                break;\n            case SAMPLE_TYPE_KEY_BASE_LIGHT:\n                m_pCurSample = new BasicLightingSample();\n                break;\n            case SAMPLE_TYPE_KEY_MULTI_LIGHT:\n                m_pCurSample = new MultiLightingsSample();\n                break;\n            case SAMPLE_TYPE_KEY_INSTANCING:\n                m_pCurSample = new Instancing3DSample();\n                break;\n            case SAMPLE_TYPE_KEY_STENCIL_TESTING:\n                m_pCurSample = new StencilTestingSample();\n                break;\n            case SAMPLE_TYPE_KEY_BLENDING:\n                m_pCurSample = new BlendingSample();\n                break;\n            case SAMPLE_TYPE_KEY_PARTICLE_SYSTEM2:\n                m_pCurSample = new ParticlesSample2();\n                break;\n            case SAMPLE_TYPE_KEY_SKYBOX:\n                m_pCurSample = new SkyBoxSample();\n                break;\n            case SAMPLE_TYPE_KEY_PBO:\n                m_pCurSample = new PBOSample();\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_BEATING_HEART:\n                m_pCurSample = new BaseShaderToySimpleSample(\n                        SAMPLE_TYPE_KEY_SHADER_TOY_BEATING_HEART);\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_CLOUD:\n                m_pCurSample = new BaseShaderToySimpleSample(SAMPLE_TYPE_KEY_SHADER_TOY_CLOUD);\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_TIME_TUNNEL:\n                m_pCurSample = new TimeTunnelSample();\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_MAIN_SEQUENCE_STAR:\n                m_pCurSample = new BaseShaderToySimpleSample(\n                        SAMPLE_TYPE_KEY_SHADER_TOY_MAIN_SEQUENCE_STAR);\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_SKY_PATH:\n                m_pCurSample = new BaseShaderToySimpleSample(SAMPLE_TYPE_KEY_SHADER_TOY_SKY_PATH);\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_A_DAY:\n                m_pCurSample = new BaseShaderToySimpleSample(SAMPLE_TYPE_KEY_SHADER_TOY_A_DAY);\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_ATMOSPHERE_SYSTEM_TEST:\n                m_pCurSample = new BaseShaderToySimpleSample(\n                        SAMPLE_TYPE_KEY_SHADER_TOY_ATMOSPHERE_SYSTEM_TEST);\n                break;\n            case SAMPLE_TYPE_KEY_BEZIER_CURVE:\n                m_pCurSample = new BezierCurveSample();\n                break;\n            case SAMPLE_TYPE_KEY_BIG_EYES:\n                m_pCurSample = new BigEyesSample();\n                break;\n            case SAMPLE_TYPE_KEY_FACE_SLENDER:\n                m_pCurSample = new FaceSlenderSample();\n                break;\n            case SAMPLE_TYPE_KEY_BIG_HEAD:\n                m_pCurSample = new BigHeadSample();\n                break;\n            case SAMPLE_TYPE_KEY_RATARY_HEAD:\n                m_pCurSample = new RotaryHeadSample();\n                break;\n            case SAMPLE_TYPE_KEY_VISUALIZE_AUDIO:\n                m_pCurSample = new VisualizeAudioSample();\n                break;\n            case SAMPLE_TYPE_KEY_SCRATCH_CARD:\n                m_pCurSample = new ScratchCardSample();\n                break;\n            case SAMPLE_TYPE_KEY_AVATAR:\n                m_pCurSample = new AvatarSample();\n                break;\n            case SAMPLE_TYPE_KEY_SHOCK_WAVE:\n                m_pCurSample = new ShockWaveSample();\n                break;\n            case SAMPLE_TYPE_KEY_MRT2:\n                m_pCurSample = new MRTSample();\n                break;\n            case SAMPLE_TYPE_KEY_FBO_BLIT:\n                m_pCurSample = new FBOBlitSample();\n                break;\n            case SAMPLE_TYPE_KEY_UBO:\n                m_pCurSample = new UniformBufferSample();\n                break;\n            case SAMPLE_TYPE_KEY_RGB2YUV:\n                m_pCurSample = new RGB2YUVSample();\n                break;\n            case SAMPLE_TYPE_KEY_MULTI_THREAD_RENDER:\n                m_pCurSample = new SharedEGLContextSample();\n                break;\n            case SAMPLE_TYPE_KEY_TEXT_RENDER:\n                m_pCurSample = new TextRenderSample();\n                break;\n            case SAMPLE_TYPE_KEY_STAY_COLOR:\n                m_pCurSample = new PortraitStayColorExample();\n                break;\n            case SAMPLE_TYPE_KEY_TRANSITIONS_1:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_2:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_3:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_4:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_5:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_6:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_7:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_8:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_9:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_10:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_11:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_12:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_13:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_14:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_15:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_16:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_17:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_18:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_19:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_20:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_21:\n                m_pCurSample = new GLTransitionExample(renderSampleType);\n                break;\n            case SAMPLE_TYPE_KEY_3D_MODEL:\n                m_pCurSample = new Model3DSample();\n                break;\n            case SAMPLE_TYPE_KEY_3D_MODEL2:\n                m_pCurSample = new Model3DSample2();\n                break;\n            case SAMPLE_TYPE_KEY_AIR_HOCKEY:\n                m_pCurSample = new AirHockeySample();\n                break;\n\n            case SAMPLE_TYPE_KEY_RECTANGLE:\n                m_pCurSample = new NativeRectangle();\n                break;\n\n            case SAMPLE_TYPE_KEY_STICKER:\n                m_pCurSample = new StickerSample();\n                break;\n            case SAMPLE_TYPE_KEY_TIME_WATERMARK_STICKER:\n                m_pCurSample = new TimeWatermarkStickerSample();\n                break;\n\n            case SAMPLE_TYPE_KEY_GREEN_SCREEN_MATTING:\n                m_pCurSample = new GreenScreenMatting();\n                break;\n            case SAMPLE_TYPE_KEY_GREEN_SCREEN_MATTING_MIX:\n                m_pCurSample = new GreenScreenMattingMix();\n                break;\n            case SAMPLE_TYPE_KEY_ROTATE_TEXTURE:\n                m_pCurSample = new RotateTexture();\n                break;\n            default:\n                m_pCurSample = nullptr;\n                break;\n        &#125;\n        if (m_pCurSample == nullptr) &#123;\n            throw MyGLException(\n                    &quot;MyGLRenderContext::SetRenderType() 请注意：你应该忘记初始化你要展示的Sample类型 ，请补上初始化的代码，否则无法渲染&quot;);\n        &#125;\n        LOGD(&quot;MyGLRenderContext::SetRenderType m_pBeforeSample = %p, m_pCurSample=%p&quot;,\n             m_pBeforeSample, m_pCurSample)\n    &#125;\n&#125;\n</code></pre>\n<p>这里是所有类型，不过我们重点是看三角形。<br>三角形是这样赋值过去的。</p>\n<pre><code class=\"line-numbers language-C++\">switch (renderSampleType) &#123;\n    case SAMPLE_TYPE_KEY_TRIANGLE:\n        m_pCurSample = new NativeTriangle();\n        break;\n</code></pre>\n<p>这里new了一个NativeTriangle给到m_pCurSample指针变量。<br>这个m_pCurSample就是前面在MyGLRenderContext定义的两个指针变量的其中一个。<br>类型是GLBaseSample这个的指针类型。</p>\n<h3 id=\"1-7-三角形绘制方法\"><a href=\"#1-7-三角形绘制方法\" class=\"headerlink\" title=\"1.7 三角形绘制方法\"></a>1.7 三角形绘制方法</h3><p>这里先声明头文件：</p>\n<pre><code class=\"line-numbers language-C++\">#pragma once\n\n#include &lt;GLBaseSample.h&gt;\n\nclass NativeTriangle : public GLBaseSample &#123;\n\n#define VERTEX_POS_INDX       0\n\npublic:\n    NativeTriangle() = default;\n\n    virtual ~NativeTriangle() = default;\n\n    virtual void Create();\n\n    virtual void Draw();\n\n    virtual void Shutdown();\n&#125;;\n</code></pre>\n<p>这里看到了这个是必须继承我们的GLBaseSample，但不是绘制三角形必要，是我们为了统一管理demo，新建的一个Sample来，其它demo都继承这个，就比较好管理。</p>\n<p>然后再写cpp文件，去实现这个三角形：</p>\n<pre><code class=\"line-numbers language-C++\">#include &quot;NativeTriangle.h&quot;\n\n// 可以参考这篇讲解： https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/\n// 我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z）\n// 由于我们希望渲染一个三角形，我们一共要指定三个顶点，每个顶点都有一个3D位置。\n// 我们会将它们以标准化设备坐标的形式（OpenGL的可见区域）定义为一个float数组。\n// https://learnopengl-cn.github.io/img/01/04/ndc.png\n\n// https://developer.android.com/guide/topics/graphics/opengl#kotlin\n// 在 OpenGL 中，形状的面是由三维空间中的三个或更多点定义的表面。\n// 一个包含三个或更多三维点（在 OpenGL 中被称为顶点）的集合具有一个正面和一个背面。\n// 如何知道哪一面为正面，哪一面为背面呢？这个问题问得好！答案与环绕（即您定义形状的点的方向）有关。\n// 查看图片 ： https://developer.android.com/images/opengl/ccw-winding.png\n// 或者查看本地图片：Android_Java/Chapter_2/Hello_Triangle/ccw-winding.png\n// 在此示例中，三角形的点按照使它们沿逆时针方向绘制的顺序定义。\n// 这些坐标的绘制顺序定义了该形状的环绕方向。默认情况下，在 OpenGL 中，沿逆时针方向绘制的面为正面。\n// 因此您看到的是该形状的正面（根据 OpenGL 解释），而另一面是背面。\n//\n// 知道形状的哪一面为正面为何如此重要呢？\n// 答案与 OpenGL 的“面剔除”这一常用功能有关。\n// 面剔除是 OpenGL 环境的一个选项，它允许渲染管道忽略（不计算或不绘制）形状的背面，从而节省时间和内存并缩短处理周期：\nstatic GLfloat vVertices[] = &#123;\n        // 逆时针 三个顶点\n        0.0f, 0.5f, 0.0f,            // 上角\n        -0.5f, -0.5f, 0.0f,          // 左下角\n        0.5f, -0.5f, 0.0f            // 右下角\n&#125;;\n</code></pre>\n<p>这里先定义下3个坐标。这个坐标以屏幕中心为（0,0）,坐标跟常规的数学坐标一致。</p>\n<p>然后是一个Create方法，具体会在MyGLRenderContext的onSurfaceCreated中会执行</p>\n<pre><code class=\"line-numbers language-C++\">void MyGLRenderContext::OnSurfaceCreated(JNIEnv *env, jobject assetManager) &#123;\n    LOGD(&quot;MyGLRenderContext::OnSurfaceCreated&quot;)\n\n    // 初始化设置assetManager  一定要记得初始化，否则会报空指针异常\n    GLUtils::setEnvAndAssetManager(env, assetManager);\n\n    if (m_pBeforeSample) &#123;\n        m_pBeforeSample-&gt;Shutdown();\n        delete m_pBeforeSample;\n        m_pBeforeSample = nullptr;\n    &#125;\n\n    // 就是这里会走Create\n    if (m_pCurSample) &#123;\n        m_pCurSample-&gt;Create();\n    &#125;\n&#125;\n</code></pre>\n<p>三角形的Create方法怎么写呢？</p>\n<pre><code class=\"line-numbers language-C++\">void NativeTriangle::Create() &#123;\n    GLUtils::printGLInfo();\n\n    // Main Program\n    // 顶点着色器\n    VERTEX_SHADER = GLUtils::openTextFile(\n            &quot;vertex/vertex_shader_hello_triangle.glsl&quot;);\n    // 片段着色器\n    FRAGMENT_SHADER = GLUtils::openTextFile(\n            &quot;fragment/fragment_shader_hello_triangle.glsl&quot;);\n\n    m_ProgramObj = GLUtils::createProgram(&amp;VERTEX_SHADER, &amp;FRAGMENT_SHADER);\n    if (!m_ProgramObj) &#123;\n        LOGD(&quot;Could not Create program&quot;)\n        return;\n    &#125;\n    // 设置清除颜色\n    glClearColor(1.0f, 1.0f, 1.0f, 0.0f);\n&#125;\n</code></pre>\n<p>这里主要是初始化，并没有绘制相关信息。</p>\n<p>主要绘制发生于Draw方法：</p>\n<pre><code class=\"line-numbers language-C++\">void NativeTriangle::Draw() &#123;\n    // Clear the color buffer\n    // 清除屏幕\n    // 在OpenGL ES中，绘图中涉及多种缓冲区类型：颜色、深度、模板。\n    // 这个例子，绘制三角形，只向颜色缓冲区中绘制图形。在每个帧的开始，我们用glClear函数清除颜色缓冲区\n    // 缓冲区将用glClearColor指定的颜色清除。\n    // 这个例子，我们调用了GLES30.glClearColor(1.0f, 1.0f, 1.0f, 0.0f); 因此屏幕清为白色。\n    // 清除颜色应该由应用程序在调用颜色缓冲区的glClear之前设置。\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    // Use the program object\n    // 在glUseProgram函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象（也就是之前写的着色器)了。\n    // 当我们渲染一个物体时要使用着色器程序 , 将其设置为活动程序。这样就可以开始渲染了\n    glUseProgram(m_ProgramObj);\n\n    // Load the vertex data\n    //  顶点着色器允许我们指定任何以顶点属性为形式的输入。这使其具有很强的灵活性的同时，\n    //  它还的确意味着我们必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。\n    //  所以，我们必须在渲染前指定OpenGL该如何解释顶点数据。\n\n    //  我们的顶点缓冲数据会被解析为下面这样子：https://learnopengl-cn.github.io/img/01/04/vertex_attribute_pointer.png\n    //   . 位置数据被储存为32位（4字节）浮点值。\n    //   . 每个位置包含3个这样的值。\n    //   . 在这3个值之间没有空隙（或其他值）。这几个值在数组中紧密排列(Tightly Packed)。\n    //   . 数据中第一个值在缓冲开始的位置。\n\n    // 有了这些信息我们就可以使用glVertexAttribPointer函数告诉OpenGL该如何解析顶点数据（应用到逐个顶点属性上）了：\n    // Load the vertex data\n\n    // 第一个参数指定我们要配置的顶点属性。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入0。\n    // 第二个参数指定顶点属性的大小。顶点属性是一个vec3，它由3个值组成，所以大小是3。\n    // 第三个参数指定数据的类型，这里是GL_FLOAT(GLSL中vec*都是由浮点数值组成的)。\n    // 第四个参数定义我们是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。\n    // 第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。我们设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。\n    //      一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，\n    //      （译注: 这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节）。\n    // 最后一个参数的类型是void*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。\n    glVertexAttribPointer(VERTEX_POS_INDX, 3, GL_FLOAT, GL_FALSE, 0, vVertices);\n\n    // 现在我们已经定义了OpenGL该如何解释顶点数据，\n    // 我们现在应该使用glEnableVertexAttribArray，以顶点属性位置值作为参数，启用顶点属性；顶点属性默认是禁用的。\n    glEnableVertexAttribArray(VERTEX_POS_INDX);\n\n    // glDrawArrays函数第一个参数是我们打算绘制的OpenGL图元的类型。我们希望绘制的是一个三角形，这里传递GL_TRIANGLES给它。\n    // 第二个参数指定了顶点数组的起始索引，我们这里填0。\n    // 最后一个参数指定我们打算绘制多少个顶点，这里是3（我们只从我们的数据中渲染一个三角形，它只有3个顶点长）。\n    //        public static final int GL_POINTS                                  = 0x0000;\n    //        public static final int GL_LINES                                   = 0x0001;\n    //        public static final int GL_LINE_LOOP                               = 0x0002;\n    //        public static final int GL_LINE_STRIP                              = 0x0003;\n    //        public static final int GL_TRIANGLES                               = 0x0004;\n    //        public static final int GL_TRIANGLE_STRIP                          = 0x0005;\n    //        public static final int GL_TRIANGLE_FAN                            = 0x0006;\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n\n    // 禁用 通用顶点属性数组\n    glDisableVertexAttribArray(0);\n&#125;\n</code></pre>\n<p>主要是glVertexAttribPointer中传入了顶点坐标。<br>但这里还不能显示，需要解释一下顶点数据，怎么绘制顶点等。<br>这里传入了一个GL_TRIANGLES，系统就知道这三个点用来绘制三角形哦。</p>\n<h3 id=\"1-8-三角形颜色怎么设置\"><a href=\"#1-8-三角形颜色怎么设置\" class=\"headerlink\" title=\"1.8 三角形颜色怎么设置\"></a>1.8 三角形颜色怎么设置</h3><p>其实有多种方法。<br>方法1：可以在顶点后面直接加红绿蓝颜色值。<br>方法2：在片段着色器里面加。<br>方法3：可以通过特殊手段传值给着色器。</p>\n<p>这里我们看下第2种，直接在片段着色器中如何修改颜色。</p>\n<p>首先确认下在哪里加载片段主色器的。</p>\n<pre><code class=\"line-numbers language-C++\">void NativeRectangle::Create() &#123;\n    GLUtils::printGLInfo();\n\n    // Main Program\n    // 顶点着色器\n    VERTEX_SHADER = GLUtils::openTextFile(\n            &quot;vertex/vertex_shader_hello_triangle.glsl&quot;);\n    // 片段着色器\n    FRAGMENT_SHADER = GLUtils::openTextFile(\n            &quot;fragment/fragment_shader_hello_triangle.glsl&quot;);\n\n    m_ProgramObj = GLUtils::createProgram(&amp;VERTEX_SHADER, &amp;FRAGMENT_SHADER);\n    if (!m_ProgramObj) &#123;\n        LOGD(&quot;Could not Create program&quot;)\n        return;\n    &#125;\n</code></pre>\n<p>soga，原来在这里，create方法中，定义了片段着色器fragment&#x2F;fragment_shader_hello_triangle.glsl。<br>顶点主色器是同理，应该是顶点的颜色。</p>\n<p>目标位置在app&#x2F;src&#x2F;main&#x2F;assets&#x2F;fragment文件夹下，原来藏这里了。</p>\n<pre><code class=\"line-numbers language-glsl\">#version 300 es\n// 表示OpenGL ES着色器语言V3.00\n\n// 声明着色器中浮点变量的默认精度\nprecision mediump float;\n// 声明一个输出变量fragColor，这是一个4分量的向量，\n// 写入这个变量的值将被输出到颜色缓冲器\nout vec4 fragColor;\n\nvoid main()\n&#123;\n    //在计算机图形中颜色被表示为有4个元素的数组：红色、绿色、蓝色和alpha(透明度)分量，\n    //通常缩写为RGBA。当在OpenGL或GLSL中定义一个颜色的时候，\n    //我们把颜色每个分量的强度设置在0.0到1.0之间。\n\n    //比如说我们设置红为1.0f，绿为1.0f，我们会得到两个颜色的混合色，即黄色。\n    //这三种颜色分量的不同调配可以生成超过1600万种不同的颜色！\n\n    // 所有片段的着色器输出都是红色( 1.0, 0.0, 0.0, 1.0 )\n    fragColor = vec4 ( 1.0, 0.0, 0.0, 1.0 );\n\n    // 会输出橘黄色\n    // fragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&#125;\n</code></pre>\n<p>这个是着色器语言，决定怎么显示颜色。<br>这个着色器语言这么加载到程序的呢？<br>继续看上面的Create方法：</p>\n<pre><code class=\"line-numbers language-C++\">  m_ProgramObj = GLUtils::createProgram(&amp;VERTEX_SHADER, &amp;FRAGMENT_SHADER);\n    if (!m_ProgramObj) &#123;\n        LOGD(&quot;Could not Create program&quot;)\n        return;\n    &#125;\n</code></pre>\n<p>这里就加载到当前程序了。包括了顶点着色器和片段着色器。</p>\n<p>整个流程基本就是这样了，另外别忘了一个指针置空的问题。<br>我们这里每个demo会走一个Shutdown方法，这里就是关闭的时候进行一些数据回收操作。</p>\n<h2 id=\"2-总结\"><a href=\"#2-总结\" class=\"headerlink\" title=\"2 总结\"></a>2 总结</h2><ul>\n<li><p>首先Java层需要自定义一个View，继承GLSurfaceView，需要实现必须实现的方法。主要先在构造函数中进行必要的初始化，然后再设置Renderer，这个的Renderer是我们自己定义的一个封装好的类，这里面加载so库，方法c层的外观者类。</p>\n</li>\n<li><p>在外观者类定义好Surface初始化和DrawFrame的底层方法，定义好怎么初始化，怎么绘制的方法。再自定义View中调用，实现在底层实现。</p>\n</li>\n<li><p>可以通过alt+enter一键生成一个生成名字的方法，参数有JNIEnv的指针变量，可以访问jni的关键实例。然后这里面走我们自定义单例MyGLRenderContext的onDrawFrame或者其它方法。</p>\n</li>\n<li><p>然后我们在MyGLRenderContext声明了一个demo指针变量，可以让这个demo执行目标函数，比如onSurfaceCreated方法，就命令里面的m_pCurSample走Create方法。</p>\n</li>\n<li><p>因为外部先走setRenderType，所以我们在这里给m_pCurSample指针new对象。</p>\n</li>\n<li><p>比如绘制三角形，就创建一个NativeTriangle,当然继承demo类，然后定义一个坐标集合，三角形就按照数学坐标定义3个点。然后create方法里面加载我们的着色器，着色器代码可以放在项目的assets文件夹下。然后让GLUtils创建程序。</p>\n</li>\n<li><p>最后就是在自定义View的onDrawFrame绘制每一帧了。这里如果是三角形，我们就按照前面定义的坐标集合来绘制三角形即可。</p>\n</li>\n</ul>\n","site":{"data":{"friends":[{"name":"知乎专栏","url":"https://zhuanlan.zhihu.com/godweiyang","title":"访问主页","introduction":"算法码上来","avatar":"/medias/avatars/myzhihu.png"},{"name":"火山翻译","url":"https://translate.volcengine.cn","title":"访问主页","introduction":"提供全球领先的翻译技术与服务","avatar":"/medias/avatars/bytedtrans.png"},{"name":"AntNLP","url":"https://antnlp.org","title":"访问主页","introduction":"华东师范大学自然语言处理实验室欢迎您的加入！","avatar":"/medias/avatars/antnlp.ico"},{"name":"IDS²","url":"https://www.smart-dependable-sino-europe.institute","title":"访问主页","introduction":"中欧可靠智能软件联合实验室欢迎您的加入！","avatar":"/medias/avatars/ids2.jpg"},{"name":"孙长志","url":"https://www.czsun.site","title":"访问主页","introduction":"AntNLP博士大师兄！","avatar":"/medias/avatars/sunchangzhi.jpg"},{"name":"纪焘","url":"https://taoji.site","title":"访问主页","introduction":"AntNLP博士带明星！","avatar":"/medias/avatars/jitao.jpg"},{"name":"杜雨沛","url":"https://yupei-du.github.io/","title":"访问主页","introduction":"AntNLP唱跳RAP打篮球全能师兄！","avatar":"/medias/avatars/duyupei.jpg"},{"name":"0xbirdpwn","url":"https://0xbird.top/","title":"访问主页","introduction":"十步杀一人，千里不留行，事了拂衣去，深藏功与名。","avatar":"/medias/avatars/0xbird.png"},{"name":"李佳倩的博客","url":"https://jiaqianlee.com/","title":"访问主页","introduction":"一只小白的成长之路！","avatar":"/medias/avatars/lijiaqian.png"},{"name":"kewlgrl","url":"https://blog.csdn.net/MIKASA3","title":"访问主页","introduction":"好大一只咸鱼哇","avatar":"/medias/avatars/kewlgrl.jpg"},{"name":"Think Far Blog","url":"https://wuli749826.github.io","title":"访问主页","introduction":"我曾经拥有这一切，转眼都飘散如烟。","avatar":"/medias/avatars/gsy.jpg"},{"name":"望城风景","url":"https://www.itaowei.cn/","title":"访问主页","introduction":"用力活过的日子，才配得上此刻的缅怀。","avatar":"/medias/avatars/taowei.jpg"},{"name":"jxtxzzw空间","url":"https://www.jxtxzzw.com/wordpress","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/zzw.jpg"},{"name":"DREAMWINGS","url":"https://www.dreamwings.cn/","title":"访问主页","introduction":"夢はそこでないと、私の権利である","avatar":"/medias/avatars/qianqian.png"},{"name":"ElaineLv","url":"https://www.elainelv.com/","title":"访问主页","introduction":"Stay hungry, Stay foolish","avatar":"/medias/avatars/lyn-draw.jpg"},{"name":"Subject_No_i","url":"https://subjectnoi.github.io","title":"访问主页","introduction":"在原七海 中野三玖 中野二乃 樱岛麻衣的老公","avatar":"/medias/avatars/lzh.png"},{"name":"菁菁","url":"https://angericky.github.io/","title":"访问主页","introduction":"做什么都是因为喜欢","avatar":"/medias/avatars/jingjing.jpg"},{"name":"Sweet-Q","url":"https://sweet-q.github.io","title":"访问主页","introduction":"华东师范大学数学系","avatar":"/medias/avatars/babyq.png"},{"name":"伟大的蚊子","url":"https://www.cnblogs.com/cww97/","title":"访问主页","introduction":"鼓楼的夜晚时间匆匆","avatar":"/medias/avatars/cww97.jpg"},{"name":"Fun4wut","url":"https://blog.fun4go.top","title":"访问主页","introduction":"菜鸡欢迎大佬的光顾","avatar":"/medias/avatars/fun4go.png"},{"name":"Hael Chan","url":"https://haelchan.me/","title":"访问主页","introduction":"浙江大学 & NLP & ML","avatar":"/medias/avatars/hael.jpg"},{"name":"happygirlzt","url":"https://www.happygirlzt.com","title":"访问主页","introduction":"A Backend Engineer","avatar":"/medias/avatars/zhangting.jpg"},{"name":"星空无限","url":"https://liyangzone.com","title":"访问主页","introduction":"前端开发，死飞大佬。分享技术，分享生活。","avatar":"/medias/avatars/liyangzone.jpg"},{"name":"Mashiro","url":"https://2heng.xin/","title":"访问主页","introduction":"樱花庄的白猫","avatar":"/medias/avatars/mashiro.jpg"},{"name":"hzwer","url":"https://hzwer.com/","title":"访问主页","introduction":"北京大学计算机系","avatar":"/medias/avatars/hzwer.jpg"},{"name":"MPY634","url":"https://mpy634.cn/","title":"访问主页","introduction":"摸鱼，永无止境。","avatar":"/medias/avatars/mpy634.png"},{"name":"徐铭辰的博客","url":"https://michaelxucs.com","title":"访问主页","introduction":"埃克塞特大学计算机系","avatar":"/medias/avatars/michael.jpg"},{"name":"Mizunashi","url":"https://mizunashi.me","title":"访问主页","introduction":"欢迎大佬们来玩","avatar":"/medias/avatars/mizunashi.png"},{"name":"xuzhongyou","url":"https://xuzhongyou.github.io/","title":"访问主页","introduction":"我哽咽道：你是赵默笙，可我不是何以琛啊。","avatar":"/medias/avatars/xuzhongyou.jpg"},{"name":"zerol","url":"https://zerol.me/","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/huaji.jpg"},{"name":"Zhang Yi","url":"https://codewithzhangyi.com/","title":"访问主页","introduction":"Coding is the New Sexy","avatar":"/medias/avatars/zhangyi.jpg"},{"name":"科学空间","url":"https://spaces.ac.cn/","title":"访问主页","introduction":"中山大学基础数学研究生","avatar":"/medias/avatars/spacesac.png"},{"name":"lucifer的博客","url":"https://lucifer.ren/blog/","title":"访问主页","introduction":"一个脑洞很大的程序员。","avatar":"https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg"},{"name":"钱栋伟","url":"https://sscjwdyzdw.club","title":"访问主页","introduction":"华东师范大学计算机系","avatar":"/medias/avatars/qiandongwei.jpg"},{"name":"CJ Blog","url":"https://chrisju.cn/","title":"访问主页","introduction":"Failing means foolish.","avatar":"/medias/avatars/mouse.jpg"},{"name":"Tawn","url":"https://tawn0000.github.io/","title":"访问主页","introduction":"JNU ACMer","avatar":"/medias/avatars/tawn.jpg"},{"name":"Master X","url":"https://masterx.top/","title":"访问主页","introduction":"ECNU&ML&DL","avatar":"/medias/avatars/masterx.jpg"},{"name":"分享客","url":"https://sharerdiary.com/","title":"访问主页","introduction":"爱生活，爱分享！","avatar":"/medias/avatars/yezijie.png"},{"name":"taotao","url":"https://zouzhitao.github.io","title":"访问主页","introduction":"taotao 码字的地方","avatar":"/medias/avatars/taotao.jpg"},{"name":"Xiejiadong","url":"https://xiejiadong.com","title":"访问主页","introduction":"Xiejiadong's blog","avatar":"/medias/avatars/xiejiadong.jpg"},{"name":"飞吧","url":"https://fei.bar","title":"访问主页","introduction":"啓飞的个人博客","avatar":"/medias/avatars/feibar.png"},{"name":"ajin","url":"https://ajin.cloud","title":"访问主页","introduction":"Always be enthusiastic","avatar":"/medias/avatars/ajin.jpg"},{"name":"Hiyoung","url":"https://hiyoungai.com/","title":"访问主页","introduction":"宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。","avatar":"https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg"},{"name":"无言的博客","url":"https://www.yzplove.top","title":"访问主页","introduction":"代码真是越敲越香","avatar":"https://cdn.jsdelivr.net/gh/yzp-99/yzp-99.github.io/medias/avatars/me.jpg"},{"name":"Naixin Zhang","url":"https://naixinzhang.github.io/","title":"访问主页","introduction":"Econ Master | Data Analyst/scientist Candidate","avatar":"https://naixinzhang.github.io/medias/avatars/avatar.jpg"},{"name":"帅张的梦呓","url":"https://ishuaizhang.com","title":"访问主页","introduction":"XDUer","avatar":"https://ishuaizhang.com/medias/avatars/avatar.jpg"},{"name":"Gatsby’s blog","url":"https://a347807131.github.io/","title":"访问主页","introduction":"Nothing perfect, Noting special.","avatar":"https://a347807131.github.io/medias/avatar.gif"},{"name":"宇宙湾","url":"https://yuzhouwan.com/","title":"访问主页","introduction":"主要是大数据和人工智能的原创文章。","avatar":"https://yuzhouwan.com/yuzhouwan_logo_128x128.ico"},{"name":"Dotnet9的博客","url":"https://dotnet9.com","title":"访问主页","introduction":"一个热衷于互联网分享精神的个人博客站点","avatar":"https://img.dotnet9.com/logo-foot.png"},{"name":"Macchiato","url":"https://hcj123123.oschina.io","title":"访问主页","introduction":"java学习者","avatar":"https://y.gtimg.cn/music/photo_new/T002R300x300M000002qD7gF3fW0JL_1.jpg?max_age=2592000"},{"name":"过客~励む","url":"https://yafine-blog.cn","title":"访问主页","introduction":"你现在的努力，是为了以后有更多的选择。","avatar":"https://yafine-blog.cn/medias/avatar.jpg"},{"name":"meteorsh","url":"https://weisenhui.top","title":"访问主页","introduction":"Data Science & Engineering","avatar":"https://weisenhui.top/medias/avatar.jpg"},{"name":"Kuroko","url":"https://kuroko.info","title":"访问主页","introduction":"浓烟下的诗歌电台","avatar":"http://kuroko.info/wp-content/uploads/2020/11/2.jpg"}],"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]}},"excerpt":"","more":"<h2 id=\"1-展示一个基本的红色三角形\"><a href=\"#1-展示一个基本的红色三角形\" class=\"headerlink\" title=\"1 展示一个基本的红色三角形\"></a>1 展示一个基本的红色三角形</h2><h3 id=\"1-1-效果\"><a href=\"#1-1-效果\" class=\"headerlink\" title=\"1.1 效果\"></a>1.1 效果</h3><p><img src=\"/./Android-OpenGLES-demo-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B8%80/01.png\"><br><img src=01.png></p>\n<h3 id=\"1-2-渲染页\"><a href=\"#1-2-渲染页\" class=\"headerlink\" title=\"1.2 渲染页\"></a>1.2 渲染页</h3><pre><code class=\"line-numbers language-Kotlin\">class NativeRenderActivity : Activity(), AudioCollector.Callback, SensorEventListener &#123;\n\n    private var mMinSetting = -1\n    private var mMagSetting = -1\n\n    companion object &#123;\n        private const val MIN_DIALOG = 1\n        private const val CONTEXT_CLIENT_VERSION = 3\n        private const val MAG_DIALOG = 2\n        private const val MIN_SETTING = &quot;min_setting&quot;\n        private const val MAG_SETTING = &quot;mag_setting&quot;\n        private const val TAG: String = &quot;NativeRenderActivity&quot;\n\n        private val REQUEST_PERMISSIONS = arrayOf(\n            Manifest.permission.WRITE_EXTERNAL_STORAGE,\n            Manifest.permission.RECORD_AUDIO\n        )\n        private const val PERMISSION_REQUEST_CODE = 1\n    &#125;\n\n    private var mRootView: ViewGroup? = null\n\n    /**\n     * Hold a reference to our GLSurfaceView\n     */\n    private var mGLSurfaceView: MyCustomerGLSurfaceView? = null\n\n    private var renderer: MyNativeRenderer? = null\n\n    var type = IMyNativeRendererType.SAMPLE_TYPE\n\n\n    private var mAudioCollector: AudioCollector? = null\n\n    private var mSensorManager: SensorManager? = null\n</code></pre>\n<p>这里声明了必要的类。</p>\n<p>MyCustomerGLSurfaceView应该是自定义的GLSurfaceView。</p>\n<h3 id=\"1-3-自定义渲染\"><a href=\"#1-3-自定义渲染\" class=\"headerlink\" title=\"1.3 自定义渲染\"></a>1.3 自定义渲染</h3><p>引用自己写的so库。</p>\n<pre><code class=\"line-numbers language-Kotlin\">class MyNativeRenderer(activity: Activity) : GLSurfaceView.Renderer, RenderAction &#123;\n    private var mActivity: Activity = activity\n    var mSampleType = 0\n\n    init &#123;\n        System.loadLibrary(&quot;ouyangpeng-opengles-lib&quot;)\n    &#125;\n</code></pre>\n<p>这里的ouyangpeng-opengles-lib就是我们自己编写库，这里应该是cpp文件，但这里loadLibrary是load so库，编译时会打包成so库。</p>\n<pre><code class=\"line-numbers language-Kotlin\">////////////////////////////////// Native 方法///////////////////////////////////////\n    // 通用的\n    private external fun nativeSurfaceCreate(assetManager: AssetManager)\n    private external fun nativeSurfaceChange(width: Int, height: Int)\n    private external fun nativeDrawFrame()\n    private external fun nativeSetRenderType(sampleCategoryType: Int, renderSampleType: Int)\n    private external fun nativeOnDestroy()\n\n    // 特定的方法\n    private external fun nativeSwitchBlendingMode()\n\n    // 特定的方法\n    private external fun nativeSetDelta(x: Float, y: Float)\n    private external fun nativeSetMinFilter(filter: Int)\n    private external fun nativeSetMagFilter(filter: Int)\n\n    private external fun nativeSetImageData(\n        format: Int,\n        width: Int,\n        height: Int,\n        imageData: ByteArray?\n    )\n\n    private external fun nativeSetImageDataWithIndex(\n        index: Int,\n        format: Int,\n        width: Int,\n        height: Int,\n        imageData: ByteArray?\n    )\n\n    private external fun nativeUpdateTransformMatrix(\n        rotateX: Float,\n        rotateY: Float,\n        scaleX: Float,\n        scaleY: Float\n    )\n\n    private external fun nativeSetAudioData(audioData: ShortArray)\n\n    private external fun nativeSetTouchLocation(x: Float, y: Float)\n\n    private external fun nativeSetGravityXY(x: Float, y: Float)\n</code></pre>\n<p>这里定义了native方法。<br>具体实现的地方在cpp文件中。</p>\n<pre><code class=\"line-numbers language-Kotlin\">////////////////////////////////// Java 方法///////////////////////////////////////\n\n/**\n    * 当Surface被创建的时候，GLSurfaceView 会调用这个方法。\n    * 这发送在应用程序第一次运行的时候，并且，当设备被唤醒或者用户从其他Activity切换换来时，\n    * 这个方法也可能被调用。在实践中，这意味着，当应用程序运行时，本方法可能会被调用多次。\n    *\n    *\n    * 为什么会有一个未被使用的参数类型GL10呢？\n    * 它是OpenGL ES 1.0的API遗留下来的。如果要编写OpenGL ES 1.0的渲染器，就要用这个参数。\n    * 但是，对应OpenGL ES 3.0，GLES20/GLEL30类提供了静态方法来读取。\n    */\noverride fun onSurfaceCreated(gl: GL10, config: EGLConfig) &#123;\n    val assetManager: AssetManager = mActivity.assets\n    nativeSurfaceCreate(assetManager)\n&#125;\n\n/**\n    * 当Surface被创建以后，每次Surface尺寸变化时，这个方法都会被 GLSurfaceView 调用到。\n    * 在横屏、竖屏来回切换的时候，Surface尺寸会发生变化\n    */\noverride fun onSurfaceChanged(gl: GL10, width: Int, height: Int) &#123;\n    nativeSurfaceChange(width, height)\n&#125;\n\n/**\n    * 当绘制一帧时，这个方法会被 GLSurfaceView 调用。\n    * 在这个方法中，我们一定要绘制一些东西，即使只是清空屏幕。\n    * 因为，在这个方法返回后，渲染缓冲区会被交换并显示在屏幕上，\n    * 如果什么都没画，可能会看到糟糕的闪烁效果。\n    */\noverride fun onDrawFrame(gl: GL10) &#123;\n    // 提前赋值，变化水印的bitmap\n    if (mSampleType == IMyNativeRendererType.SAMPLE_TYPE_KEY_TIME_WATERMARK_STICKER) &#123;\n        // 获取时间水印的bitmap\n        val mBitmap: Bitmap = CommonUtils.getTimeWaterBitmap()\n\n        val bytes = mBitmap.byteCount\n        val buf = ByteBuffer.allocate(bytes)\n        mBitmap.copyPixelsToBuffer(buf)\n        val byteArray = buf.array()\n        setImageDataWithIndex(\n            0,\n            ImageFormat.IMAGE_FORMAT_RGBA,\n            mBitmap.width,\n            mBitmap.height,\n            byteArray\n        )\n    &#125;\n\n    // native层去绘制\n    nativeDrawFrame()\n&#125;\n\nfun setRenderType(sampleCategoryType: Int, renderSampleType: Int) &#123;\n    if (sampleCategoryType == IMyNativeRendererType.SAMPLE_TYPE) &#123;\n        mSampleType = renderSampleType\n    &#125;\n    nativeSetRenderType(sampleCategoryType, renderSampleType)\n&#125;\n\nfun onDestroy() &#123;\n    nativeOnDestroy()\n&#125;\n\noverride fun switchBlendingMode() &#123;\n    nativeSwitchBlendingMode()\n&#125;\n\noverride fun setMinFilter(filter: Int) &#123;\n    nativeSetMinFilter(filter)\n&#125;\n\noverride fun setMagFilter(filter: Int) &#123;\n    nativeSetMagFilter(filter)\n&#125;\n\noverride fun setDelta(deltaX: Float, deltaY: Float) &#123;\n    nativeSetDelta(deltaX, deltaY)\n&#125;\n\noverride fun setImageData(\n    format: Int,\n    width: Int,\n    height: Int,\n    imageData: ByteArray\n) &#123;\n    nativeSetImageData(format, width, height, imageData)\n&#125;\n\noverride fun setImageDataWithIndex(\n    index: Int,\n    format: Int,\n    width: Int,\n    height: Int,\n    imageData: ByteArray\n) &#123;\n    nativeSetImageDataWithIndex(index, format, width, height, imageData)\n&#125;\n\noverride fun updateTransformMatrix(\n    rotateX: Float,\n    rotateY: Float,\n    scaleX: Float,\n    scaleY: Float\n) &#123;\n    nativeUpdateTransformMatrix(rotateX, rotateY, scaleX, scaleY)\n&#125;\n\noverride fun setAudioData(audioData: ShortArray) &#123;\n    nativeSetAudioData(audioData)\n&#125;\n\noverride fun setTouchLocation(x: Float, y: Float) &#123;\n    nativeSetTouchLocation(x,y)\n&#125;\n\noverride fun setGravityXY(x: Float, y: Float)&#123;\n    nativeSetGravityXY(x,y)\n&#125;\n</code></pre>\n<p>主要渲染的方式应该是走这里。<br>onDrawFrame方法就是绘制每一帧。</p>\n<p>里面是用：</p>\n<pre><code class=\"line-numbers language-Kotlin\">/**\n    * 当绘制一帧时，这个方法会被 GLSurfaceView 调用。\n    * 在这个方法中，我们一定要绘制一些东西，即使只是清空屏幕。\n    * 因为，在这个方法返回后，渲染缓冲区会被交换并显示在屏幕上，\n    * 如果什么都没画，可能会看到糟糕的闪烁效果。\n    */\noverride fun onDrawFrame(gl: GL10) &#123;\n    // 提前赋值，变化水印的bitmap\n    if (mSampleType == IMyNativeRendererType.SAMPLE_TYPE_KEY_TIME_WATERMARK_STICKER) &#123;\n        // 获取时间水印的bitmap\n        val mBitmap: Bitmap = CommonUtils.getTimeWaterBitmap()\n\n        val bytes = mBitmap.byteCount\n        val buf = ByteBuffer.allocate(bytes)\n        mBitmap.copyPixelsToBuffer(buf)\n        val byteArray = buf.array()\n        setImageDataWithIndex(\n            0,\n            ImageFormat.IMAGE_FORMAT_RGBA,\n            mBitmap.width,\n            mBitmap.height,\n            byteArray\n        )\n    &#125;\n\n    // native层去绘制\n    nativeDrawFrame()\n&#125;\n</code></pre>\n<p>native层去绘制的。</p>\n<h3 id=\"1-4-布局\"><a href=\"#1-4-布局\" class=\"headerlink\" title=\"1.4 布局\"></a>1.4 布局</h3><pre><code class=\"line-numbers language-Kotlin\">setContentView(R.layout.activity_native_render)\nmRootView = findViewById&lt;View&gt;(R.id.rootView) as ViewGroup\n\n// Tell the surface view we want to create an OpenGL ES 3.0-compatible context,\n// and set an OpenGL ES 3.0-compatible renderer.\nmGLSurfaceView =\n    MyCustomerGLSurfaceView(this, myNativeRenderer, CONTEXT_CLIENT_VERSION)\n\nmGLSurfaceView?.let &#123;\n    val lp = RelativeLayout.LayoutParams(\n        ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT\n    )\n    lp.addRule(RelativeLayout.CENTER_IN_PARENT)\n    mRootView!!.addView(it, lp)\n\n    if (mRootView!!.width != it.width\n        || mRootView!!.height != it.height\n    ) &#123;\n        it.setAspectRatio(mRootView!!.width, mRootView!!.height)\n    &#125;\n    // 设置渲染模式\n    setRenderMode(it)\n    // 加载图片\n    loadImageToGLSurfaceView()\n    // 申请重新绘制\n    it.requestRender()\n&#125;\n</code></pre>\n<p>这里先设置了下ContentView进去。<br>其实里面没啥的，就一个RelativeLayout：</p>\n<pre><code class=\"line-numbers language-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:id=&quot;@+id/rootView&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;&gt;\n\n&lt;/RelativeLayout&gt;\n</code></pre>\n<p>然后这里new了一个自定义的MyCustomerGLSurfaceView。<br>然后在RootView里面添加了这个自定义View。</p>\n<p>然后有一个代码很重要：</p>\n<pre><code class=\"line-numbers language-Kotlin\"> mGLSurfaceView = MyCustomerGLSurfaceView(this, myNativeRenderer, CONTEXT_CLIENT_VERSION)\n</code></pre>\n<p>这里将 渲染器作为参数传到这个自定义View里面了。</p>\n<h3 id=\"1-5-自定义View\"><a href=\"#1-5-自定义View\" class=\"headerlink\" title=\"1.5 自定义View\"></a>1.5 自定义View</h3><p>继承GLSurfaceView，来自android.opengl.GLSurfaceView。</p>\n<pre><code class=\"line-numbers language-Kotlin\">class MyCustomerGLSurfaceView : GLSurfaceView, ScaleGestureDetector.OnScaleGestureListener &#123;\n    private lateinit var mRenderer: MyNativeRenderer\n    private lateinit var mScaleGestureDetector: ScaleGestureDetector\n\n    private var mPreviousX = 0f\n    private var mPreviousY = 0f\n\n    private var mXAngle = 0f\n    private var mYAngle = 0f\n\n    private var mRatioWidth = 0\n    private var mRatioHeight = 0\n\n    private var mPreScale = 1.0f\n    private var mCurScale = 1.0f\n\n    private var mDensity = 0f\n\n    private var mLastMultiTouchTime: Long = 0\n\n    constructor(context: Context?) : super(context) &#123;&#125;\n\n    constructor(context: Context?, attrs: AttributeSet?) : super(context, attrs) &#123;&#125;\n\n    constructor(context: Context?, glRender: MyNativeRenderer, eglContextVersion: Int) : this(\n        context,\n        null,\n        glRender,\n        eglContextVersion\n    )\n\n    constructor(\n        context: Context?,\n        attrs: AttributeSet?,\n        glRender: MyNativeRenderer,\n        eglContextVersion: Int\n    ) : super(context, attrs) &#123;\n        setEGLContextClientVersion(eglContextVersion)\n        mRenderer = glRender\n\n        /*If no setEGLConfigChooser method is called,\n        then by default the view will choose an RGB_888 surface with a depth buffer depth of at least 16 bits.*/\n        // 最后 2 个参数表示分别配置 16 位的深度缓冲区和模板缓冲区\n        setEGLConfigChooser(8, 8, 8, 8, 16, 8)\n        setRenderer(mRenderer)\n        mScaleGestureDetector = ScaleGestureDetector(context, this)\n    &#125;\n</code></pre>\n<p>定义触摸事件：</p>\n<pre><code class=\"line-numbers language-Kotlin\">override fun onTouchEvent(event: MotionEvent): Boolean &#123;\n    Log.d(TAG, &quot;onTouchEvent&quot;)\n    if (event.pointerCount == 1) &#123;\n        Log.d(TAG, &quot;event.pointerCount == 1&quot;)\n        val currentTimeMillis = System.currentTimeMillis()\n        if (currentTimeMillis - mLastMultiTouchTime &gt; 200) &#123;\n            var x: Float = -1.0f\n            var y: Float = -1.0f\n            when (event.action) &#123;\n                MotionEvent.ACTION_DOWN -&gt; &#123;\n                    if (mRenderer.mSampleType == IMyNativeRendererType.SAMPLE_TYPE_KEY_LESSON_FIVE) &#123;\n                        // Android的 GLSurfaceView 在后台线程中执行渲染，必须要小心，\n                        // 只能在这个渲染线程中调用OpenGL，在Android主线程中使用UI(用户界面)相关的调用\n                        // 两个线程之间的通信可以用如下方法：\n                        // 在主线程中的 GLSurfaceView实例可以调用 queueEven() 方法传递一个Runnable给后台渲染线程\n                        // 渲染线程可以调用Activity的runOnUIThread()来传递事件(event)给主线程\n\n                        // Ensure we call switchMode() on the OpenGL thread.\n                        // queueEvent() is a method of GLSurfaceView that will do this for us.\n                        queueEvent &#123; mRenderer.switchBlendingMode() &#125;\n                        return true\n                    &#125;\n                &#125;\n\n                MotionEvent.ACTION_MOVE -&gt; &#123;\n                    x = event.x\n                    y = event.y\n                    val deltaX = (x - mPreviousX) / mDensity / 2\n                    val deltaY = (y - mPreviousY) / mDensity / 2\n                    if (mRenderer.mSampleType == IMyNativeRendererType.SAMPLE_TYPE_KEY_LESSON_SIX) &#123;\n                        mRenderer.setDelta(deltaX, deltaY)\n                    &#125; else if (mRenderer.mSampleType == IMyNativeRendererType.SAMPLE_TYPE_KEY_SCRATCH_CARD) &#123;\n                        mRenderer.setTouchLocation(x, y)\n                        // 重新请求绘制\n                        requestRender()\n                    &#125;\n\n                    val dy = y - mPreviousY\n                    val dx = x - mPreviousX\n                    mYAngle += (dx * TOUCH_SCALE_FACTOR).toInt()\n                    mXAngle += (dy * TOUCH_SCALE_FACTOR).toInt()\n                &#125;\n\n                MotionEvent.ACTION_CANCEL -&gt; &#123;\n                    x = -1.0f\n                    y = -1.0f\n                &#125;\n\n                MotionEvent.ACTION_UP-&gt;&#123;\n                    if (mRenderer.mSampleType == IMyNativeRendererType.SAMPLE_TYPE_KEY_SHOCK_WAVE) &#123;\n                        mRenderer.setTouchLocation(event.x, event.y)\n                    &#125;\n                &#125;\n            &#125;\n\n            mPreviousX = x\n            mPreviousY = y\n\n            when (mRenderer.mSampleType) &#123;\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_FBO_LEG,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_COORD_SYSTEM,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_BASE_LIGHT,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_MULTI_LIGHT,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_STENCIL_TESTING,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_PARTICLE_SYSTEM2,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_INSTANCING,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_PBO,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_UBO,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_TEXT_RENDER,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_3D_MODEL,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_3D_MODEL2,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_BLENDING,\n                IMyNativeRendererType.SAMPLE_TYPE_KEY_SKYBOX -&gt; &#123;\n                    Log.d(TAG, &quot;updateTransformMatrix&quot;)\n                    mRenderer.updateTransformMatrix(mXAngle, mYAngle, mCurScale, mCurScale)\n                    requestRender()\n                &#125;\n            &#125;\n\n        &#125;\n    &#125; else &#123;\n        Log.d(TAG, &quot;event.pointerCount != 1&quot;)\n        mScaleGestureDetector.onTouchEvent(event)\n    &#125;\n    return true\n&#125;\n</code></pre>\n<p>测量方法：</p>\n<pre><code class=\"line-numbers language-Kotlin\">override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) &#123;\n    super.onMeasure(widthMeasureSpec, heightMeasureSpec)\n    val width = MeasureSpec.getSize(widthMeasureSpec)\n    val height = MeasureSpec.getSize(heightMeasureSpec)\n    if (0 == mRatioWidth || 0 == mRatioHeight) &#123;\n        setMeasuredDimension(width, height)\n    &#125; else &#123;\n        if (width &lt; height * mRatioWidth / mRatioHeight) &#123;\n            setMeasuredDimension(width, width * mRatioHeight / mRatioWidth)\n        &#125; else &#123;\n            setMeasuredDimension(height * mRatioWidth / mRatioHeight, height)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>其实设置方法：</p>\n<pre><code class=\"line-numbers language-Kotlin\">fun setAspectRatio(width: Int, height: Int) &#123;\n    Log.d(TAG, &quot;setAspectRatio() called with: width = [$width], height = [$height]&quot;)\n    require(!(width &lt; 0 || height &lt; 0)) &#123; &quot;Size cannot be negative.&quot; &#125;\n    mRatioWidth = width\n    mRatioHeight = height\n    requestLayout()\n&#125;\n\n// Hides superclass method.\nfun setRenderer(renderer: Renderer, density: Float) &#123;\n    mRenderer = renderer as MyNativeRenderer\n    mDensity = density\n    super.setRenderer(renderer)\n&#125;\n</code></pre>\n<p>定义缩放方法：</p>\n<pre><code class=\"line-numbers language-Kotlin\">override fun onScale(detector: ScaleGestureDetector?): Boolean &#123;\n        Log.d(TAG, &quot;onScale&quot;)\n    when (mRenderer.mSampleType) &#123;\n        IMyNativeRendererType.SAMPLE_TYPE_KEY_COORD_SYSTEM,\n        IMyNativeRendererType.SAMPLE_TYPE_KEY_BASE_LIGHT,\n        IMyNativeRendererType.SAMPLE_TYPE_KEY_TEXT_RENDER,\n        IMyNativeRendererType.SAMPLE_TYPE_KEY_3D_MODEL,\n        IMyNativeRendererType.SAMPLE_TYPE_KEY_3D_MODEL2,\n        IMyNativeRendererType.SAMPLE_TYPE_KEY_INSTANCING -&gt; &#123;\n            val preSpan = detector!!.previousSpan\n            val curSpan = detector.currentSpan\n            mCurScale = if (curSpan &lt; preSpan) &#123;\n                mPreScale - (preSpan - curSpan) / 200\n            &#125; else &#123;\n                mPreScale + (curSpan - preSpan) / 200\n            &#125;\n            mCurScale = 0.05f.coerceAtLeast(mCurScale.coerceAtMost(80.0f))\n            mRenderer.updateTransformMatrix(mXAngle, mYAngle, mCurScale, mCurScale)\n            requestRender()\n        &#125;\n        else -&gt; &#123;&#125;\n    &#125;\n\n    return false\n&#125;\n\noverride fun onScaleBegin(detector: ScaleGestureDetector?): Boolean &#123;\n    Log.d(TAG, &quot;onScaleBegin&quot;)\n    return true\n&#125;\n\noverride fun onScaleEnd(detector: ScaleGestureDetector?) &#123;\n    Log.d(TAG, &quot;onScaleEnd&quot;)\n    mPreScale = mCurScale\n    mLastMultiTouchTime = System.currentTimeMillis()\n&#125;\n</code></pre>\n<p>常量定义：</p>\n<pre><code class=\"line-numbers language-Kotlin\">companion object &#123;\n    private const val TOUCH_SCALE_FACTOR = 180.0f / 320\n    private const val TAG = &quot;MyCustomerGLSurfaceView&quot;\n&#125;\n</code></pre>\n<h3 id=\"1-6-C层流程\"><a href=\"#1-6-C层流程\" class=\"headerlink\" title=\"1.6 C层流程\"></a>1.6 C层流程</h3><p>首先是Java层：</p>\n<pre><code class=\"line-numbers language-Kotlin\">fun setRenderType(sampleCategoryType: Int, renderSampleType: Int) &#123;\n        if (sampleCategoryType == IMyNativeRendererType.SAMPLE_TYPE) &#123;\n            mSampleType = renderSampleType\n        &#125;\n        nativeSetRenderType(sampleCategoryType, renderSampleType)\n    &#125;\n</code></pre>\n<p>这里走了native方法：</p>\n<pre><code class=\"line-numbers language-C++\">extern &quot;C&quot;\nJNIEXPORT void JNICALL\nJava_com_oyp_openglesdemo_render_MyNativeRenderer_nativeSetRenderType(\n        JNIEnv *env, jobject thiz, jint sampleCategoryType, jint renderSampleType) &#123;\n    MyGLRenderContext::GetInstance()-&gt;SetRenderType(sampleCategoryType, renderSampleType);\n&#125;\n</code></pre>\n<p>这里是JniImpl.cpp类中定义的方法。</p>\n<p>然后会走到MyGLRenderContext方法中，有个单例类,先看下怎么声明的类吧：</p>\n<pre><code class=\"line-numbers language-C++\">\n#ifndef OPENGLESDEMO_MYGLRENDERCONTEXT_H\n#define OPENGLESDEMO_MYGLRENDERCONTEXT_H\n\n#include &lt;GLBaseSample.h&gt;\n\nclass MyGLRenderContext\n&#123;\n    MyGLRenderContext();\n\n    ~MyGLRenderContext();\n\npublic:\n    void SetRenderType(int sampleCategoryType, int renderSampleType);\n\n    void OnSurfaceCreated(JNIEnv *env, jobject assetManager);\n\n    void OnSurfaceChanged(int width, int height);\n\n    void OnDrawFrame();\n\n    static MyGLRenderContext* GetInstance();\n\n    static void DestroyInstance();\n\n    void SwitchBlendingMode();\n\n    void SetDelta(float x, float y);\n\n    void SetMinFilter(int filter);\n\n    void SetMagFilter(int filter);\n\n    void SetImageData(int format, int width, int height, uint8_t *pData);\n\n    void SetImageDataWithIndex(int index, int format, int width, int height, uint8_t *pData);\n\n    void UpdateTransformMatrix(float d, float d1, float d2, float d3);\n\n    void SetAudioData(short *buffer, int len);\n\n    void SetTouchLocation(float x, float y);\n\n    void SetGravityXY(float x, float y);\n\nprivate:\n    static MyGLRenderContext *m_pContext;\n    GLBaseSample *m_pBeforeSample;\n    GLBaseSample *m_pCurSample;\n\n    static NativeImage getImage(int format, int width, int height, uint8_t *pData) ;\n&#125;;\n\n#endif //OPENGLESDEMO_MYGLRENDERCONTEXT_H\n</code></pre>\n<p>具体怎么实现呢？</p>\n<pre><code class=\"line-numbers language-C++\">MyGLRenderContext *MyGLRenderContext::GetInstance() &#123;\n//    LOGD(&quot;MyGLRenderContext::GetInstance&quot;)\n    if (m_pContext == nullptr) &#123;\n        m_pContext = new MyGLRenderContext();\n    &#125;\n    return m_pContext;\n&#125;\n\nvoid MyGLRenderContext::DestroyInstance() &#123;\n    LOGD(&quot;MyGLRenderContext::DestroyInstance&quot;)\n    if (m_pContext) &#123;\n        delete m_pContext;\n        m_pContext = nullptr;\n    &#125;\n\n&#125;\n</code></pre>\n<p>这里具体实现了GetInstance和DestoryInstance方法。</p>\n<p>构造函数呢？</p>\n<pre><code class=\"line-numbers language-C++\">MyGLRenderContext::MyGLRenderContext() &#123;\n    LOGD(&quot;MyGLRenderContext::MyGLRenderContext&quot;)\n    m_pCurSample = nullptr;\n    m_pBeforeSample = nullptr;\n&#125;\n\nMyGLRenderContext::~MyGLRenderContext() &#123;\n    LOGD(&quot;MyGLRenderContext::~MyGLRenderContext&quot;)\n\n    if (m_pCurSample) &#123;\n        m_pCurSample-&gt;Shutdown();\n        delete m_pCurSample;\n        m_pCurSample = nullptr;\n    &#125;\n\n    if (m_pBeforeSample) &#123;\n        m_pBeforeSample-&gt;Shutdown();\n        delete m_pBeforeSample;\n        m_pBeforeSample = nullptr;\n    &#125;\n&#125;\n</code></pre>\n<p>需要关注一下这里面有个指针变量，GLBaseSample，是什么呢？<br>目测是一个记录demo如何绘制顶点着色器的一个类。</p>\n<pre><code class=\"line-numbers language-C++\">\n// 注意，这个目录在java层创建，参考 com.oyp.openglesdemo.activity.NativeRenderActivity.onResume方法\n#define DEFAULT_OGL_ASSETS_DIR &quot;/data/data/com.oyp.openglesdemo/cache&quot;\n\nclass GLBaseSample &#123;\n    \npublic:\n    GLBaseSample() &#123;\n        VERTEX_SHADER = GL_NONE;\n        FRAGMENT_SHADER = GL_NONE;\n        m_ProgramObj = 0;\n        m_Width = 0;\n        m_Height = 0;\n    &#125;\n\n    virtual ~GLBaseSample() &#123;&#125;\n\n    virtual void Create() = 0;\n\n    virtual void Change(int width, int height) &#123;\n        LOGD(&quot;Change() width = %d , height = %d\\n&quot;, width, height)\n        m_Width = width;\n        m_Height = height;\n        // Set the viewport\n        // 通知OpenGL ES 用于绘制的2D渲染表面的原点、宽度和高度。\n        // 在OpenGL ES 中，视口(Viewport) 定义所有OpenGL ES 渲染操作最终显示的2D矩形\n        // 视口(Viewport) 由原点坐标(x,y)和宽度(width) 、高度(height)定义。\n        glViewport(0, 0, m_Width, m_Height);\n    &#125;\n\n    virtual void Draw() = 0;\n\n    virtual void Shutdown()&#123;\n        if (m_ProgramObj) &#123;\n            glDeleteProgram(m_ProgramObj);\n            m_ProgramObj = GL_NONE;\n        &#125;\n        if(VERTEX_SHADER != nullptr)&#123;\n            delete[] VERTEX_SHADER;\n            VERTEX_SHADER = nullptr;\n        &#125;\n        if(FRAGMENT_SHADER!= nullptr)&#123;\n            delete[] FRAGMENT_SHADER;\n            FRAGMENT_SHADER = nullptr;\n        &#125;\n    &#125;\n\n    // 默认啥都不做，等待有需要的子类去重写\n    virtual void SwitchBlendingMode() &#123;&#125;\n\n    virtual void SetDelta(float x, float y) &#123;&#125;\n\n    virtual void SetMinFilter(int filter) &#123;&#125;\n\n    virtual void SetMagFilter(int filter) &#123;&#125;\n\n    virtual void LoadImage(NativeImage *pImage) &#123;&#125;;\n\n    virtual void LoadMultiImageWithIndex(int index, NativeImage *pImage) &#123;&#125;\n\n    virtual void UpdateTransformMatrix(float rotateX, float rotateY, float scaleX, float scaleY) &#123;&#125;\n\n    virtual void LoadAudioData(short *buffer, int len) &#123;&#125;\n\n    virtual void SetTouchLocation(float x, float y) &#123;&#125;\n\n    virtual void SetGravityXY(float x, float y) &#123;&#125;\n\nprotected:\n    /**\n     * 程序对象\n     */\n    GLuint m_ProgramObj;\n\n    /**\n     * 顶点着色器\n     */\n    const char *VERTEX_SHADER;\n    /**\n     * 片段着色器脚本\n     */\n    const char *FRAGMENT_SHADER;\n\n    /**\n     * 屏幕宽度\n     */\n    int m_Width;\n    /**\n     * 屏幕高度\n     */\n    int m_Height;\n&#125;;\n\n#endif //OPENGLESDEMO_GLBASESAMPLE_H\n</code></pre>\n<p>然后回到MyGLRenderContext中。<br>具体看下setRenderType如何实现的吧？</p>\n<pre><code class=\"line-numbers language-C++\">void MyGLRenderContext::SetRenderType(int sampleCategoryType, int renderSampleType) &#123;\n    LOGD(&quot;MyGLRenderContext::SetRenderType sampleCategoryType = %d, renderSampleType = %d&quot;,\n         sampleCategoryType, renderSampleType)\n\n    if (sampleCategoryType == SAMPLE_TYPE) &#123;\n        m_pBeforeSample = m_pCurSample;\n\n        LOGD(&quot;MyGLRenderContext::SetRenderType 0 m_pBeforeSample = %p&quot;, m_pBeforeSample)\n\n        switch (renderSampleType) &#123;\n            case SAMPLE_TYPE_KEY_TRIANGLE:\n                m_pCurSample = new NativeTriangle();\n                break;\n            case SAMPLE_TYPE_KEY_TRIANGLE2:\n                m_pCurSample = new NativeTriangle2();\n                break;\n            case SAMPLE_TYPE_KEY_TRIANGLE3:\n                m_pCurSample = new NativeTriangle3();\n                break;\n            case SAMPLE_TYPE_KEY_TRIANGLE_MAP_BUFFERS:\n                m_pCurSample = new NativeTriangleMapBuffers();\n                break;\n            case SAMPLE_TYPE_KEY_TRIANGLE_VERTEX_ARRAY_OBJECT:\n                m_pCurSample = new NativeTriangleVAO();\n                break;\n            case SAMPLE_TYPE_KEY_TRIANGLE_VERTEX_BUFFER_OBJECT:\n                m_pCurSample = new NativeTriangleVBO();\n                break;\n            case SAMPLE_TYPE_KEY_CUBE_SIMPLE_VERTEX_SHADER:\n                m_pCurSample = new NativeCubeSimpleVertexShader();\n                break;\n            case SAMPLE_TYPE_KEY_SIMPLE_TEXTURE_2D:\n                m_pCurSample = new SimpleTexture2D();\n                break;\n            case SAMPLE_TYPE_KEY_SIMPLE_TEXTURE_CUBE_MAP:\n                m_pCurSample = new SimpleTextureCubeMap();\n                break;\n            case SAMPLE_TYPE_KEY_MIPMAP_2D:\n                m_pCurSample = new MipMap2D();\n                break;\n            case SAMPLE_TYPE_KEY_TEXTURE_WRAP:\n                m_pCurSample = new TextureWrap();\n                break;\n            case SAMPLE_TYPE_KEY_MULTI_TEXTURE:\n                m_pCurSample = new MultiTexture();\n                break;\n            case SAMPLE_TYPE_KEY_PARTICLE_SYSTEM:\n                m_pCurSample = new ParticleSystem();\n                break;\n            case SAMPLE_TYPE_KEY_PARTICLE_SYSTEM_TRANSFORM_FEEDBACK:\n                m_pCurSample = new ParticleSystemTransformFeedBack();\n                break;\n            case SAMPLE_TYPE_KEY_NOISE3D:\n                m_pCurSample = new Noise3DRender();\n                break;\n            case SAMPLE_TYPE_KEY_MRT:\n                m_pCurSample = new MRT();\n                break;\n            case SAMPLE_TYPE_KEY_TERRAIN_RENDER:\n                m_pCurSample = new TerrainRender();\n                break;\n            case SAMPLE_TYPE_KEY_SHADOWS:\n                m_pCurSample = new Shadows();\n                break;\n            case SAMPLE_TYPE_KEY_LESSON_ONE:\n                m_pCurSample = new Native1Lesson();\n                break;\n            case SAMPLE_TYPE_KEY_LESSON_TWO:\n                m_pCurSample = new Native2Lesson();\n                break;\n            case SAMPLE_TYPE_KEY_LESSON_THREE:\n                m_pCurSample = new Native3Lesson();\n                break;\n            case SAMPLE_TYPE_KEY_LESSON_FOUR:\n                m_pCurSample = new Native4Lesson();\n                break;\n            case SAMPLE_TYPE_KEY_LESSON_FIVE:\n                m_pCurSample = new Native5Lesson();\n                break;\n            case SAMPLE_TYPE_KEY_LESSON_SIX:\n                m_pCurSample = new Native6Lesson();\n                break;\n            case SAMPLE_TYPE_KEY_TEXTURE_MAP:\n                m_pCurSample = new TextureMapSample();\n                break;\n            case SAMPLE_TYPE_KEY_YUV_RENDER:\n                m_pCurSample = new NV21TextureMapSample();\n                break;\n            case SAMPLE_TYPE_KEY_FBO:\n                m_pCurSample = new FBOSample();\n                break;\n            case SAMPLE_TYPE_KEY_FBO_LEG:\n                m_pCurSample = new FBOLegLengthenSample();\n                break;\n            case SAMPLE_TYPE_COORD_SYSTEM:\n                m_pCurSample = new CoordSystemSample();\n                break;\n            case SAMPLE_TYPE_KEY_BASE_LIGHT:\n                m_pCurSample = new BasicLightingSample();\n                break;\n            case SAMPLE_TYPE_KEY_MULTI_LIGHT:\n                m_pCurSample = new MultiLightingsSample();\n                break;\n            case SAMPLE_TYPE_KEY_INSTANCING:\n                m_pCurSample = new Instancing3DSample();\n                break;\n            case SAMPLE_TYPE_KEY_STENCIL_TESTING:\n                m_pCurSample = new StencilTestingSample();\n                break;\n            case SAMPLE_TYPE_KEY_BLENDING:\n                m_pCurSample = new BlendingSample();\n                break;\n            case SAMPLE_TYPE_KEY_PARTICLE_SYSTEM2:\n                m_pCurSample = new ParticlesSample2();\n                break;\n            case SAMPLE_TYPE_KEY_SKYBOX:\n                m_pCurSample = new SkyBoxSample();\n                break;\n            case SAMPLE_TYPE_KEY_PBO:\n                m_pCurSample = new PBOSample();\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_BEATING_HEART:\n                m_pCurSample = new BaseShaderToySimpleSample(\n                        SAMPLE_TYPE_KEY_SHADER_TOY_BEATING_HEART);\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_CLOUD:\n                m_pCurSample = new BaseShaderToySimpleSample(SAMPLE_TYPE_KEY_SHADER_TOY_CLOUD);\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_TIME_TUNNEL:\n                m_pCurSample = new TimeTunnelSample();\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_MAIN_SEQUENCE_STAR:\n                m_pCurSample = new BaseShaderToySimpleSample(\n                        SAMPLE_TYPE_KEY_SHADER_TOY_MAIN_SEQUENCE_STAR);\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_SKY_PATH:\n                m_pCurSample = new BaseShaderToySimpleSample(SAMPLE_TYPE_KEY_SHADER_TOY_SKY_PATH);\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_A_DAY:\n                m_pCurSample = new BaseShaderToySimpleSample(SAMPLE_TYPE_KEY_SHADER_TOY_A_DAY);\n                break;\n            case SAMPLE_TYPE_KEY_SHADER_TOY_ATMOSPHERE_SYSTEM_TEST:\n                m_pCurSample = new BaseShaderToySimpleSample(\n                        SAMPLE_TYPE_KEY_SHADER_TOY_ATMOSPHERE_SYSTEM_TEST);\n                break;\n            case SAMPLE_TYPE_KEY_BEZIER_CURVE:\n                m_pCurSample = new BezierCurveSample();\n                break;\n            case SAMPLE_TYPE_KEY_BIG_EYES:\n                m_pCurSample = new BigEyesSample();\n                break;\n            case SAMPLE_TYPE_KEY_FACE_SLENDER:\n                m_pCurSample = new FaceSlenderSample();\n                break;\n            case SAMPLE_TYPE_KEY_BIG_HEAD:\n                m_pCurSample = new BigHeadSample();\n                break;\n            case SAMPLE_TYPE_KEY_RATARY_HEAD:\n                m_pCurSample = new RotaryHeadSample();\n                break;\n            case SAMPLE_TYPE_KEY_VISUALIZE_AUDIO:\n                m_pCurSample = new VisualizeAudioSample();\n                break;\n            case SAMPLE_TYPE_KEY_SCRATCH_CARD:\n                m_pCurSample = new ScratchCardSample();\n                break;\n            case SAMPLE_TYPE_KEY_AVATAR:\n                m_pCurSample = new AvatarSample();\n                break;\n            case SAMPLE_TYPE_KEY_SHOCK_WAVE:\n                m_pCurSample = new ShockWaveSample();\n                break;\n            case SAMPLE_TYPE_KEY_MRT2:\n                m_pCurSample = new MRTSample();\n                break;\n            case SAMPLE_TYPE_KEY_FBO_BLIT:\n                m_pCurSample = new FBOBlitSample();\n                break;\n            case SAMPLE_TYPE_KEY_UBO:\n                m_pCurSample = new UniformBufferSample();\n                break;\n            case SAMPLE_TYPE_KEY_RGB2YUV:\n                m_pCurSample = new RGB2YUVSample();\n                break;\n            case SAMPLE_TYPE_KEY_MULTI_THREAD_RENDER:\n                m_pCurSample = new SharedEGLContextSample();\n                break;\n            case SAMPLE_TYPE_KEY_TEXT_RENDER:\n                m_pCurSample = new TextRenderSample();\n                break;\n            case SAMPLE_TYPE_KEY_STAY_COLOR:\n                m_pCurSample = new PortraitStayColorExample();\n                break;\n            case SAMPLE_TYPE_KEY_TRANSITIONS_1:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_2:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_3:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_4:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_5:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_6:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_7:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_8:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_9:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_10:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_11:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_12:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_13:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_14:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_15:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_16:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_17:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_18:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_19:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_20:\n            case SAMPLE_TYPE_KEY_TRANSITIONS_21:\n                m_pCurSample = new GLTransitionExample(renderSampleType);\n                break;\n            case SAMPLE_TYPE_KEY_3D_MODEL:\n                m_pCurSample = new Model3DSample();\n                break;\n            case SAMPLE_TYPE_KEY_3D_MODEL2:\n                m_pCurSample = new Model3DSample2();\n                break;\n            case SAMPLE_TYPE_KEY_AIR_HOCKEY:\n                m_pCurSample = new AirHockeySample();\n                break;\n\n            case SAMPLE_TYPE_KEY_RECTANGLE:\n                m_pCurSample = new NativeRectangle();\n                break;\n\n            case SAMPLE_TYPE_KEY_STICKER:\n                m_pCurSample = new StickerSample();\n                break;\n            case SAMPLE_TYPE_KEY_TIME_WATERMARK_STICKER:\n                m_pCurSample = new TimeWatermarkStickerSample();\n                break;\n\n            case SAMPLE_TYPE_KEY_GREEN_SCREEN_MATTING:\n                m_pCurSample = new GreenScreenMatting();\n                break;\n            case SAMPLE_TYPE_KEY_GREEN_SCREEN_MATTING_MIX:\n                m_pCurSample = new GreenScreenMattingMix();\n                break;\n            case SAMPLE_TYPE_KEY_ROTATE_TEXTURE:\n                m_pCurSample = new RotateTexture();\n                break;\n            default:\n                m_pCurSample = nullptr;\n                break;\n        &#125;\n        if (m_pCurSample == nullptr) &#123;\n            throw MyGLException(\n                    &quot;MyGLRenderContext::SetRenderType() 请注意：你应该忘记初始化你要展示的Sample类型 ，请补上初始化的代码，否则无法渲染&quot;);\n        &#125;\n        LOGD(&quot;MyGLRenderContext::SetRenderType m_pBeforeSample = %p, m_pCurSample=%p&quot;,\n             m_pBeforeSample, m_pCurSample)\n    &#125;\n&#125;\n</code></pre>\n<p>这里是所有类型，不过我们重点是看三角形。<br>三角形是这样赋值过去的。</p>\n<pre><code class=\"line-numbers language-C++\">switch (renderSampleType) &#123;\n    case SAMPLE_TYPE_KEY_TRIANGLE:\n        m_pCurSample = new NativeTriangle();\n        break;\n</code></pre>\n<p>这里new了一个NativeTriangle给到m_pCurSample指针变量。<br>这个m_pCurSample就是前面在MyGLRenderContext定义的两个指针变量的其中一个。<br>类型是GLBaseSample这个的指针类型。</p>\n<h3 id=\"1-7-三角形绘制方法\"><a href=\"#1-7-三角形绘制方法\" class=\"headerlink\" title=\"1.7 三角形绘制方法\"></a>1.7 三角形绘制方法</h3><p>这里先声明头文件：</p>\n<pre><code class=\"line-numbers language-C++\">#pragma once\n\n#include &lt;GLBaseSample.h&gt;\n\nclass NativeTriangle : public GLBaseSample &#123;\n\n#define VERTEX_POS_INDX       0\n\npublic:\n    NativeTriangle() = default;\n\n    virtual ~NativeTriangle() = default;\n\n    virtual void Create();\n\n    virtual void Draw();\n\n    virtual void Shutdown();\n&#125;;\n</code></pre>\n<p>这里看到了这个是必须继承我们的GLBaseSample，但不是绘制三角形必要，是我们为了统一管理demo，新建的一个Sample来，其它demo都继承这个，就比较好管理。</p>\n<p>然后再写cpp文件，去实现这个三角形：</p>\n<pre><code class=\"line-numbers language-C++\">#include &quot;NativeTriangle.h&quot;\n\n// 可以参考这篇讲解： https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/\n// 我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z）\n// 由于我们希望渲染一个三角形，我们一共要指定三个顶点，每个顶点都有一个3D位置。\n// 我们会将它们以标准化设备坐标的形式（OpenGL的可见区域）定义为一个float数组。\n// https://learnopengl-cn.github.io/img/01/04/ndc.png\n\n// https://developer.android.com/guide/topics/graphics/opengl#kotlin\n// 在 OpenGL 中，形状的面是由三维空间中的三个或更多点定义的表面。\n// 一个包含三个或更多三维点（在 OpenGL 中被称为顶点）的集合具有一个正面和一个背面。\n// 如何知道哪一面为正面，哪一面为背面呢？这个问题问得好！答案与环绕（即您定义形状的点的方向）有关。\n// 查看图片 ： https://developer.android.com/images/opengl/ccw-winding.png\n// 或者查看本地图片：Android_Java/Chapter_2/Hello_Triangle/ccw-winding.png\n// 在此示例中，三角形的点按照使它们沿逆时针方向绘制的顺序定义。\n// 这些坐标的绘制顺序定义了该形状的环绕方向。默认情况下，在 OpenGL 中，沿逆时针方向绘制的面为正面。\n// 因此您看到的是该形状的正面（根据 OpenGL 解释），而另一面是背面。\n//\n// 知道形状的哪一面为正面为何如此重要呢？\n// 答案与 OpenGL 的“面剔除”这一常用功能有关。\n// 面剔除是 OpenGL 环境的一个选项，它允许渲染管道忽略（不计算或不绘制）形状的背面，从而节省时间和内存并缩短处理周期：\nstatic GLfloat vVertices[] = &#123;\n        // 逆时针 三个顶点\n        0.0f, 0.5f, 0.0f,            // 上角\n        -0.5f, -0.5f, 0.0f,          // 左下角\n        0.5f, -0.5f, 0.0f            // 右下角\n&#125;;\n</code></pre>\n<p>这里先定义下3个坐标。这个坐标以屏幕中心为（0,0）,坐标跟常规的数学坐标一致。</p>\n<p>然后是一个Create方法，具体会在MyGLRenderContext的onSurfaceCreated中会执行</p>\n<pre><code class=\"line-numbers language-C++\">void MyGLRenderContext::OnSurfaceCreated(JNIEnv *env, jobject assetManager) &#123;\n    LOGD(&quot;MyGLRenderContext::OnSurfaceCreated&quot;)\n\n    // 初始化设置assetManager  一定要记得初始化，否则会报空指针异常\n    GLUtils::setEnvAndAssetManager(env, assetManager);\n\n    if (m_pBeforeSample) &#123;\n        m_pBeforeSample-&gt;Shutdown();\n        delete m_pBeforeSample;\n        m_pBeforeSample = nullptr;\n    &#125;\n\n    // 就是这里会走Create\n    if (m_pCurSample) &#123;\n        m_pCurSample-&gt;Create();\n    &#125;\n&#125;\n</code></pre>\n<p>三角形的Create方法怎么写呢？</p>\n<pre><code class=\"line-numbers language-C++\">void NativeTriangle::Create() &#123;\n    GLUtils::printGLInfo();\n\n    // Main Program\n    // 顶点着色器\n    VERTEX_SHADER = GLUtils::openTextFile(\n            &quot;vertex/vertex_shader_hello_triangle.glsl&quot;);\n    // 片段着色器\n    FRAGMENT_SHADER = GLUtils::openTextFile(\n            &quot;fragment/fragment_shader_hello_triangle.glsl&quot;);\n\n    m_ProgramObj = GLUtils::createProgram(&amp;VERTEX_SHADER, &amp;FRAGMENT_SHADER);\n    if (!m_ProgramObj) &#123;\n        LOGD(&quot;Could not Create program&quot;)\n        return;\n    &#125;\n    // 设置清除颜色\n    glClearColor(1.0f, 1.0f, 1.0f, 0.0f);\n&#125;\n</code></pre>\n<p>这里主要是初始化，并没有绘制相关信息。</p>\n<p>主要绘制发生于Draw方法：</p>\n<pre><code class=\"line-numbers language-C++\">void NativeTriangle::Draw() &#123;\n    // Clear the color buffer\n    // 清除屏幕\n    // 在OpenGL ES中，绘图中涉及多种缓冲区类型：颜色、深度、模板。\n    // 这个例子，绘制三角形，只向颜色缓冲区中绘制图形。在每个帧的开始，我们用glClear函数清除颜色缓冲区\n    // 缓冲区将用glClearColor指定的颜色清除。\n    // 这个例子，我们调用了GLES30.glClearColor(1.0f, 1.0f, 1.0f, 0.0f); 因此屏幕清为白色。\n    // 清除颜色应该由应用程序在调用颜色缓冲区的glClear之前设置。\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    // Use the program object\n    // 在glUseProgram函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象（也就是之前写的着色器)了。\n    // 当我们渲染一个物体时要使用着色器程序 , 将其设置为活动程序。这样就可以开始渲染了\n    glUseProgram(m_ProgramObj);\n\n    // Load the vertex data\n    //  顶点着色器允许我们指定任何以顶点属性为形式的输入。这使其具有很强的灵活性的同时，\n    //  它还的确意味着我们必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。\n    //  所以，我们必须在渲染前指定OpenGL该如何解释顶点数据。\n\n    //  我们的顶点缓冲数据会被解析为下面这样子：https://learnopengl-cn.github.io/img/01/04/vertex_attribute_pointer.png\n    //   . 位置数据被储存为32位（4字节）浮点值。\n    //   . 每个位置包含3个这样的值。\n    //   . 在这3个值之间没有空隙（或其他值）。这几个值在数组中紧密排列(Tightly Packed)。\n    //   . 数据中第一个值在缓冲开始的位置。\n\n    // 有了这些信息我们就可以使用glVertexAttribPointer函数告诉OpenGL该如何解析顶点数据（应用到逐个顶点属性上）了：\n    // Load the vertex data\n\n    // 第一个参数指定我们要配置的顶点属性。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入0。\n    // 第二个参数指定顶点属性的大小。顶点属性是一个vec3，它由3个值组成，所以大小是3。\n    // 第三个参数指定数据的类型，这里是GL_FLOAT(GLSL中vec*都是由浮点数值组成的)。\n    // 第四个参数定义我们是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。\n    // 第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。我们设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。\n    //      一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，\n    //      （译注: 这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节）。\n    // 最后一个参数的类型是void*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。\n    glVertexAttribPointer(VERTEX_POS_INDX, 3, GL_FLOAT, GL_FALSE, 0, vVertices);\n\n    // 现在我们已经定义了OpenGL该如何解释顶点数据，\n    // 我们现在应该使用glEnableVertexAttribArray，以顶点属性位置值作为参数，启用顶点属性；顶点属性默认是禁用的。\n    glEnableVertexAttribArray(VERTEX_POS_INDX);\n\n    // glDrawArrays函数第一个参数是我们打算绘制的OpenGL图元的类型。我们希望绘制的是一个三角形，这里传递GL_TRIANGLES给它。\n    // 第二个参数指定了顶点数组的起始索引，我们这里填0。\n    // 最后一个参数指定我们打算绘制多少个顶点，这里是3（我们只从我们的数据中渲染一个三角形，它只有3个顶点长）。\n    //        public static final int GL_POINTS                                  = 0x0000;\n    //        public static final int GL_LINES                                   = 0x0001;\n    //        public static final int GL_LINE_LOOP                               = 0x0002;\n    //        public static final int GL_LINE_STRIP                              = 0x0003;\n    //        public static final int GL_TRIANGLES                               = 0x0004;\n    //        public static final int GL_TRIANGLE_STRIP                          = 0x0005;\n    //        public static final int GL_TRIANGLE_FAN                            = 0x0006;\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n\n    // 禁用 通用顶点属性数组\n    glDisableVertexAttribArray(0);\n&#125;\n</code></pre>\n<p>主要是glVertexAttribPointer中传入了顶点坐标。<br>但这里还不能显示，需要解释一下顶点数据，怎么绘制顶点等。<br>这里传入了一个GL_TRIANGLES，系统就知道这三个点用来绘制三角形哦。</p>\n<h3 id=\"1-8-三角形颜色怎么设置\"><a href=\"#1-8-三角形颜色怎么设置\" class=\"headerlink\" title=\"1.8 三角形颜色怎么设置\"></a>1.8 三角形颜色怎么设置</h3><p>其实有多种方法。<br>方法1：可以在顶点后面直接加红绿蓝颜色值。<br>方法2：在片段着色器里面加。<br>方法3：可以通过特殊手段传值给着色器。</p>\n<p>这里我们看下第2种，直接在片段着色器中如何修改颜色。</p>\n<p>首先确认下在哪里加载片段主色器的。</p>\n<pre><code class=\"line-numbers language-C++\">void NativeRectangle::Create() &#123;\n    GLUtils::printGLInfo();\n\n    // Main Program\n    // 顶点着色器\n    VERTEX_SHADER = GLUtils::openTextFile(\n            &quot;vertex/vertex_shader_hello_triangle.glsl&quot;);\n    // 片段着色器\n    FRAGMENT_SHADER = GLUtils::openTextFile(\n            &quot;fragment/fragment_shader_hello_triangle.glsl&quot;);\n\n    m_ProgramObj = GLUtils::createProgram(&amp;VERTEX_SHADER, &amp;FRAGMENT_SHADER);\n    if (!m_ProgramObj) &#123;\n        LOGD(&quot;Could not Create program&quot;)\n        return;\n    &#125;\n</code></pre>\n<p>soga，原来在这里，create方法中，定义了片段着色器fragment&#x2F;fragment_shader_hello_triangle.glsl。<br>顶点主色器是同理，应该是顶点的颜色。</p>\n<p>目标位置在app&#x2F;src&#x2F;main&#x2F;assets&#x2F;fragment文件夹下，原来藏这里了。</p>\n<pre><code class=\"line-numbers language-glsl\">#version 300 es\n// 表示OpenGL ES着色器语言V3.00\n\n// 声明着色器中浮点变量的默认精度\nprecision mediump float;\n// 声明一个输出变量fragColor，这是一个4分量的向量，\n// 写入这个变量的值将被输出到颜色缓冲器\nout vec4 fragColor;\n\nvoid main()\n&#123;\n    //在计算机图形中颜色被表示为有4个元素的数组：红色、绿色、蓝色和alpha(透明度)分量，\n    //通常缩写为RGBA。当在OpenGL或GLSL中定义一个颜色的时候，\n    //我们把颜色每个分量的强度设置在0.0到1.0之间。\n\n    //比如说我们设置红为1.0f，绿为1.0f，我们会得到两个颜色的混合色，即黄色。\n    //这三种颜色分量的不同调配可以生成超过1600万种不同的颜色！\n\n    // 所有片段的着色器输出都是红色( 1.0, 0.0, 0.0, 1.0 )\n    fragColor = vec4 ( 1.0, 0.0, 0.0, 1.0 );\n\n    // 会输出橘黄色\n    // fragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&#125;\n</code></pre>\n<p>这个是着色器语言，决定怎么显示颜色。<br>这个着色器语言这么加载到程序的呢？<br>继续看上面的Create方法：</p>\n<pre><code class=\"line-numbers language-C++\">  m_ProgramObj = GLUtils::createProgram(&amp;VERTEX_SHADER, &amp;FRAGMENT_SHADER);\n    if (!m_ProgramObj) &#123;\n        LOGD(&quot;Could not Create program&quot;)\n        return;\n    &#125;\n</code></pre>\n<p>这里就加载到当前程序了。包括了顶点着色器和片段着色器。</p>\n<p>整个流程基本就是这样了，另外别忘了一个指针置空的问题。<br>我们这里每个demo会走一个Shutdown方法，这里就是关闭的时候进行一些数据回收操作。</p>\n<h2 id=\"2-总结\"><a href=\"#2-总结\" class=\"headerlink\" title=\"2 总结\"></a>2 总结</h2><ul>\n<li><p>首先Java层需要自定义一个View，继承GLSurfaceView，需要实现必须实现的方法。主要先在构造函数中进行必要的初始化，然后再设置Renderer，这个的Renderer是我们自己定义的一个封装好的类，这里面加载so库，方法c层的外观者类。</p>\n</li>\n<li><p>在外观者类定义好Surface初始化和DrawFrame的底层方法，定义好怎么初始化，怎么绘制的方法。再自定义View中调用，实现在底层实现。</p>\n</li>\n<li><p>可以通过alt+enter一键生成一个生成名字的方法，参数有JNIEnv的指针变量，可以访问jni的关键实例。然后这里面走我们自定义单例MyGLRenderContext的onDrawFrame或者其它方法。</p>\n</li>\n<li><p>然后我们在MyGLRenderContext声明了一个demo指针变量，可以让这个demo执行目标函数，比如onSurfaceCreated方法，就命令里面的m_pCurSample走Create方法。</p>\n</li>\n<li><p>因为外部先走setRenderType，所以我们在这里给m_pCurSample指针new对象。</p>\n</li>\n<li><p>比如绘制三角形，就创建一个NativeTriangle,当然继承demo类，然后定义一个坐标集合，三角形就按照数学坐标定义3个点。然后create方法里面加载我们的着色器，着色器代码可以放在项目的assets文件夹下。然后让GLUtils创建程序。</p>\n</li>\n<li><p>最后就是在自定义View的onDrawFrame绘制每一帧了。这里如果是三角形，我们就按照前面定义的坐标集合来绘制三角形即可。</p>\n</li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_posts/iOS-swift-如何实现扫码功能/scan1.png","slug":"scan1.png","post":"cldlhfhyo000bivv72lpy3cfc","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-如何实现扫码功能/scan2.png","slug":"scan2.png","post":"cldlhfhyo000bivv72lpy3cfc","modified":0,"renderable":0},{"_id":"source/_posts/Flutter-学习导航/FlutterDevs.jpeg","slug":"FlutterDevs.jpeg","post":"cldlhfhyo0009ivv79g398pik","modified":0,"renderable":0},{"_id":"source/_posts/Flutter-学习导航/Study_Knowledge.jpeg","slug":"Study_Knowledge.jpeg","post":"cldlhfhyo0009ivv79g398pik","modified":0,"renderable":0},{"_id":"source/_posts/Flutter-学习导航/blog_520lee_com.jpeg","slug":"blog_520lee_com.jpeg","post":"cldlhfhyo0009ivv79g398pik","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-实现简易地图功能/map.png","slug":"map.png","post":"cldlhfhyr000oivv7dxsn53r6","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-混编Flutter/fluttererror03.png","slug":"fluttererror03.png","post":"cldlhfhyq000mivv78rzb3wfk","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-混编Flutter/fluttererror1.png","slug":"fluttererror1.png","post":"cldlhfhyq000mivv78rzb3wfk","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-混编Flutter/fluttererror2.png","slug":"fluttererror2.png","post":"cldlhfhyq000mivv78rzb3wfk","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-数据库realm实践/realm1.png","slug":"realm1.png","post":"cldlhfhyq000iivv7dh55e7pk","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-数据库realm实践/realm2.png","slug":"realm2.png","post":"cldlhfhyq000iivv7dh55e7pk","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-打造TabLayout效果/page1.gif","slug":"page1.gif","post":"cldlhfhyp000givv77rdm1fur","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-打造TabLayout效果/segment1.png","slug":"segment1.png","post":"cldlhfhyp000givv77rdm1fur","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-网络请求二次封装moya/moya1.png","slug":"moya1.png","post":"cldlhfhyu001hivv7299c0bkj","modified":0,"renderable":0},{"_id":"source/_posts/Android-学习导航/bianchengjingxuan.jpeg","slug":"bianchengjingxuan.jpeg","post":"cldlhfhyu001givv7araa49aa","modified":0,"renderable":0},{"_id":"source/_posts/Android-学习导航/carson.jpeg","slug":"carson.jpeg","post":"cldlhfhyu001givv7araa49aa","modified":0,"renderable":0},{"_id":"source/_posts/Android-学习导航/guolin.jpeg","slug":"guolin.jpeg","post":"cldlhfhyu001givv7araa49aa","modified":0,"renderable":0},{"_id":"source/_posts/Android-学习导航/hongyang.jpeg","slug":"hongyang.jpeg","post":"cldlhfhyu001givv7araa49aa","modified":0,"renderable":0},{"_id":"source/_posts/Android-学习导航/jishuquan.jpeg","slug":"jishuquan.jpeg","post":"cldlhfhyu001givv7araa49aa","modified":0,"renderable":0},{"_id":"source/_posts/Android-学习导航/jishuzhuanjia.jpeg","slug":"jishuzhuanjia.jpeg","post":"cldlhfhyu001givv7araa49aa","modified":0,"renderable":0},{"_id":"source/_posts/Android-学习导航/jsonchao.jpeg","slug":"jsonchao.jpeg","post":"cldlhfhyu001givv7araa49aa","modified":0,"renderable":0},{"_id":"source/_posts/Android-学习导航/qunyingzhuan.jpeg","slug":"qunyingzhuan.jpeg","post":"cldlhfhyu001givv7araa49aa","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-自定义View之四级地址/四级地址.gif","slug":"四级地址.gif","post":"cldlhfhyv001jivv724f849t5","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-自定义View之步进器/stepper0.png","slug":"stepper0.png","post":"cldlhfhyv001livv7390secfa","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-自定义View之步进器/stepper5.png","slug":"stepper5.png","post":"cldlhfhyv001livv7390secfa","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-自定义View之时间选择器/预约日期.png","slug":"预约日期.png","post":"cldlhfhyv001nivv70woa9s3r","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-自定义View之时间选择器/预约时间.png","slug":"预约时间.png","post":"cldlhfhyv001nivv70woa9s3r","modified":0,"renderable":0},{"_id":"source/_posts/iOS-学习导航/iOSkaifa.jpeg","slug":"iOSkaifa.jpeg","post":"cldlhfhyw001pivv7acg9clnq","modified":0,"renderable":0},{"_id":"source/_posts/iOS-学习导航/mobile_tech_share.jpeg","slug":"mobile_tech_share.jpeg","post":"cldlhfhyw001pivv7acg9clnq","modified":0,"renderable":0},{"_id":"source/_posts/玩Android-Compose版本-项目分析/home_item.jpeg","slug":"home_item.jpeg","post":"cldlhfhyw001tivv741r7eu8e","modified":0,"renderable":0},{"_id":"source/_posts/玩Android-Compose版本-项目分析/mine.jpeg","slug":"mine.jpeg","post":"cldlhfhyw001tivv741r7eu8e","modified":0,"renderable":0},{"_id":"source/_posts/玩Android-Compose版本-项目分析/闪屏页.gif","slug":"闪屏页.gif","post":"cldlhfhyw001tivv741r7eu8e","modified":0,"renderable":0},{"_id":"source/_posts/玩Android-Compose版本-项目分析/首页.jpeg","slug":"首页.jpeg","post":"cldlhfhyw001tivv741r7eu8e","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/01.gif","slug":"01.gif","post":"cldofhihg0000crv73g4d6in5","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/02_1.png","slug":"02_1.png","post":"cldofhihg0000crv73g4d6in5","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/02_2.png","slug":"02_2.png","post":"cldofhihg0000crv73g4d6in5","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/03_1.png","slug":"03_1.png","post":"cldofhihg0000crv73g4d6in5","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/04_1.png","slug":"04_1.png","post":"cldofhihg0000crv73g4d6in5","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/04_2.png","slug":"04_2.png","post":"cldofhihg0000crv73g4d6in5","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/06_1.png","slug":"06_1.png","post":"cldofhihg0000crv73g4d6in5","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/07.gif","slug":"07.gif","post":"cldofhihg0000crv73g4d6in5","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/09.gif","slug":"09.gif","post":"cldofhihg0000crv73g4d6in5","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/1.2.png","slug":"1.2.png","post":"cldofhihg0000crv73g4d6in5","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/5_1.png","slug":"5_1.png","post":"cldofhihg0000crv73g4d6in5","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/Carousel.gif","slug":"Carousel.gif","post":"cldofhihg0000crv73g4d6in5","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/Customfont.gif","slug":"Customfont.gif","post":"cldofhihg0000crv73g4d6in5","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/mylocation.gif","slug":"mylocation.gif","post":"cldofhihg0000crv73g4d6in5","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/playvideo.gif","slug":"playvideo.gif","post":"cldofhihg0000crv73g4d6in5","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/randomMusicColor.gif","slug":"randomMusicColor.gif","post":"cldofhihg0000crv73g4d6in5","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/snapchatmenu.gif","slug":"snapchatmenu.gif","post":"cldofhihg0000crv73g4d6in5","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个Swift项目之第一天/videobg.gif","slug":"videobg.gif","post":"cldofhihg0000crv73g4d6in5","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/18_1.png","slug":"18_1.png","post":"cldpu0pmm0000a0v73we29j2z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/21_1.png","slug":"21_1.png","post":"cldpu0pmm0000a0v73we29j2z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/25_1.png","slug":"25_1.png","post":"cldpu0pmm0000a0v73we29j2z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/AnimateTabel.gif","slug":"AnimateTabel.gif","post":"cldpu0pmm0000a0v73we29j2z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/CollectionViewAnimation.gif","slug":"CollectionViewAnimation.gif","post":"cldpu0pmm0000a0v73we29j2z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/CustomPullToRefresh.gif","slug":"CustomPullToRefresh.gif","post":"cldpu0pmm0000a0v73we29j2z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/Limit.gif","slug":"Limit.gif","post":"cldpu0pmm0000a0v73we29j2z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/SlideMenu.gif","slug":"SlideMenu.gif","post":"cldpu0pmm0000a0v73we29j2z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/TumblrMenu.gif","slug":"TumblrMenu.gif","post":"cldpu0pmm0000a0v73we29j2z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/cleartableviewcell.gif","slug":"cleartableviewcell.gif","post":"cldpu0pmm0000a0v73we29j2z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/emoji spin.gif","slug":"emoji spin.gif","post":"cldpu0pmm0000a0v73we29j2z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/simple login animation.gif","slug":"simple login animation.gif","post":"cldpu0pmm0000a0v73we29j2z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第二天/splash.gif","slug":"splash.gif","post":"cldpu0pmm0000a0v73we29j2z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/22.png","slug":"22.png","post":"cldrc1wyj000055v718zbbipy","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/23_1.png","slug":"23_1.png","post":"cldrc1wyj000055v718zbbipy","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/24_1.png","slug":"24_1.png","post":"cldrc1wyj000055v718zbbipy","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/25_1.png","slug":"25_1.png","post":"cldrc1wyj000055v718zbbipy","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/25_2.png","slug":"25_2.png","post":"cldrc1wyj000055v718zbbipy","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/25_3.png","slug":"25_3.png","post":"cldrc1wyj000055v718zbbipy","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/25_4.png","slug":"25_4.png","post":"cldrc1wyj000055v718zbbipy","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/27_1.png","slug":"27_1.png","post":"cldrc1wyj000055v718zbbipy","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/28_1.png","slug":"28_1.png","post":"cldrc1wyj000055v718zbbipy","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/3DTouchQuickAction.gif","slug":"3DTouchQuickAction.gif","post":"cldrc1wyj000055v718zbbipy","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/AvatarPicker.gif","slug":"AvatarPicker.gif","post":"cldrc1wyj000055v718zbbipy","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/BasicAnimation.gif","slug":"BasicAnimation.gif","post":"cldrc1wyj000055v718zbbipy","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/CoreData.gif","slug":"CoreData.gif","post":"cldrc1wyj000055v718zbbipy","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/MosaicLayouts.gif","slug":"MosaicLayouts.gif","post":"cldrc1wyj000055v718zbbipy","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/SlideOutMenu.gif","slug":"SlideOutMenu.gif","post":"cldrc1wyj000055v718zbbipy","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/Spotlight Search.gif","slug":"Spotlight Search.gif","post":"cldrc1wyj000055v718zbbipy","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/Swipeable Cell.gif","slug":"Swipeable Cell.gif","post":"cldrc1wyj000055v718zbbipy","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/TapBarAnimation.gif","slug":"TapBarAnimation.gif","post":"cldrc1wyj000055v718zbbipy","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-3天30个swift项目之第三天/wikiFace.gif","slug":"wikiFace.gif","post":"cldrc1wyj000055v718zbbipy","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-Gitee客户端-完整项目分析之一/1.png","slug":"1.png","post":"cldsgpnnk0000egv78r9w1qr7","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-Gitee客户端-完整项目分析之一/2.png","slug":"2.png","post":"cldsgpnnk0000egv78r9w1qr7","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-Gitee客户端-完整项目分析之一/3.png","slug":"3.png","post":"cldsgpnnk0000egv78r9w1qr7","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-Gitee客户端-完整项目分析之一/4.png","slug":"4.png","post":"cldsgpnnk0000egv78r9w1qr7","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-Gitee客户端-完整项目分析之一/5.png","slug":"5.png","post":"cldsgpnnk0000egv78r9w1qr7","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-Gitee客户端-完整项目分析之一/6.png","slug":"6.png","post":"cldsgpnnk0000egv78r9w1qr7","modified":0,"renderable":0},{"_id":"source/_posts/iOS-swift-Gitee客户端-完整项目分析之一/tab1.png","slug":"tab1.png","post":"cldsgpnnk0000egv78r9w1qr7","modified":0,"renderable":0},{"_id":"source/_posts/Android-OpenGLES-demo-学习之一/01.png","post":"cldu4ej0500002av7hzff1jhe","slug":"01.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cldlhfhyk0001ivv74audan6c","category_id":"cldlhfhym0004ivv78gp53aj0","_id":"cldlhfhyq000jivv72b7g8ige"},{"post_id":"cldlhfhym0003ivv777j66hem","category_id":"cldlhfhyp000civv7cmx1fhzv","_id":"cldlhfhyr000qivv7f7xc1tog"},{"post_id":"cldlhfhyn0007ivv7b6m2ajhp","category_id":"cldlhfhyp000civv7cmx1fhzv","_id":"cldlhfhys000tivv7a9sc9aco"},{"post_id":"cldlhfhyo0009ivv79g398pik","category_id":"cldlhfhyr000pivv7d0n39ddm","_id":"cldlhfhys000xivv7h6fqgbvb"},{"post_id":"cldlhfhyo000bivv72lpy3cfc","category_id":"cldlhfhys000uivv76gfi5fxl","_id":"cldlhfhys0012ivv7evln6p3p"},{"post_id":"cldlhfhyp000givv77rdm1fur","category_id":"cldlhfhys000uivv76gfi5fxl","_id":"cldlhfhyt0016ivv78zumaeho"},{"post_id":"cldlhfhyq000iivv7dh55e7pk","category_id":"cldlhfhys000uivv76gfi5fxl","_id":"cldlhfhyt001aivv71mar83oh"},{"post_id":"cldlhfhyq000mivv78rzb3wfk","category_id":"cldlhfhys000uivv76gfi5fxl","_id":"cldlhfhyt001divv7c9lf833h"},{"post_id":"cldlhfhyr000oivv7dxsn53r6","category_id":"cldlhfhys000uivv76gfi5fxl","_id":"cldlhfhyt001fivv7hs4pc3hy"},{"post_id":"cldlhfhyu001givv7araa49aa","category_id":"cldlhfhyp000civv7cmx1fhzv","_id":"cldlhfhyv001mivv70qzu6503"},{"post_id":"cldlhfhyu001hivv7299c0bkj","category_id":"cldlhfhys000uivv76gfi5fxl","_id":"cldlhfhyv001oivv7ffhdfqux"},{"post_id":"cldlhfhyv001jivv724f849t5","category_id":"cldlhfhys000uivv76gfi5fxl","_id":"cldlhfhyw001rivv7azoihmc7"},{"post_id":"cldlhfhyv001livv7390secfa","category_id":"cldlhfhys000uivv76gfi5fxl","_id":"cldlhfhyw001uivv7hs8cd58w"},{"post_id":"cldlhfhyv001nivv70woa9s3r","category_id":"cldlhfhys000uivv76gfi5fxl","_id":"cldlhfhyw001vivv730gzf3ag"},{"post_id":"cldlhfhyw001pivv7acg9clnq","category_id":"cldlhfhys000uivv76gfi5fxl","_id":"cldlhfhyw001yivv7ggah38ga"},{"post_id":"cldlhfhyw001tivv741r7eu8e","category_id":"cldlhfhyp000civv7cmx1fhzv","_id":"cldlhfhyw0020ivv72xggd262"},{"post_id":"cldofhihg0000crv73g4d6in5","category_id":"cldlhfhys000uivv76gfi5fxl","_id":"cldofhihj0002crv7ejr59yy2"},{"post_id":"cldpu0pmm0000a0v73we29j2z","category_id":"cldlhfhys000uivv76gfi5fxl","_id":"cldpu0pmo0002a0v7f0v5942a"},{"post_id":"cldrc1wyj000055v718zbbipy","category_id":"cldlhfhys000uivv76gfi5fxl","_id":"cldrc1wyl000255v7e7xn91bj"},{"post_id":"cldsgpnnk0000egv78r9w1qr7","category_id":"cldlhfhys000uivv76gfi5fxl","_id":"cldsgpnnp0002egv7f7331h4l"},{"post_id":"cldu4ej0500002av7hzff1jhe","category_id":"cldlhfhyp000civv7cmx1fhzv","_id":"cldu4ej0a00022av7h3u7ctlp"}],"PostTag":[{"post_id":"cldlhfhyk0001ivv74audan6c","tag_id":"cldlhfhyn0005ivv7djne0weg","_id":"cldlhfhyp000eivv7egf47mem"},{"post_id":"cldlhfhym0003ivv777j66hem","tag_id":"cldlhfhyp000divv7erhz641s","_id":"cldlhfhyr000nivv7ctzk2gof"},{"post_id":"cldlhfhyn0007ivv7b6m2ajhp","tag_id":"cldlhfhyp000divv7erhz641s","_id":"cldlhfhys000sivv72xvweodb"},{"post_id":"cldlhfhyo0009ivv79g398pik","tag_id":"cldlhfhyr000rivv7dcku5znt","_id":"cldlhfhys000wivv75qgwg1av"},{"post_id":"cldlhfhyo000bivv72lpy3cfc","tag_id":"cldlhfhys000vivv78sgh160e","_id":"cldlhfhys0010ivv7dkgk6rwu"},{"post_id":"cldlhfhyp000givv77rdm1fur","tag_id":"cldlhfhys000zivv7akxm5vwg","_id":"cldlhfhyt0014ivv7ds0q2mq3"},{"post_id":"cldlhfhyq000iivv7dh55e7pk","tag_id":"cldlhfhys0013ivv75y89hqif","_id":"cldlhfhyt0018ivv7eq68b23n"},{"post_id":"cldlhfhyq000mivv78rzb3wfk","tag_id":"cldlhfhyt0017ivv7eo2y1hyq","_id":"cldlhfhyt001civv7e90we8fu"},{"post_id":"cldlhfhyr000oivv7dxsn53r6","tag_id":"cldlhfhyt001bivv7668q14g9","_id":"cldlhfhyt001eivv7bt6m4rg7"},{"post_id":"cldlhfhyu001givv7araa49aa","tag_id":"cldlhfhyp000divv7erhz641s","_id":"cldlhfhyv001iivv7gxv2eopm"},{"post_id":"cldlhfhyu001hivv7299c0bkj","tag_id":"cldlhfhyv001kivv718hbffzn","_id":"cldlhfhyw001sivv7ffr2bloc"},{"post_id":"cldlhfhyw001tivv741r7eu8e","tag_id":"cldlhfhyp000divv7erhz641s","_id":"cldlhfhyw001xivv7bzmt7zta"},{"post_id":"cldlhfhyv001jivv724f849t5","tag_id":"cldlhfhyw001qivv7bzms2iqa","_id":"cldlhfhyw001zivv7cum38wru"},{"post_id":"cldlhfhyv001livv7390secfa","tag_id":"cldlhfhyw001qivv7bzms2iqa","_id":"cldlhfhyw0022ivv7c20d674t"},{"post_id":"cldlhfhyv001nivv70woa9s3r","tag_id":"cldlhfhyw001qivv7bzms2iqa","_id":"cldlhfhyw0024ivv7c1hr9nhy"},{"post_id":"cldlhfhyw001pivv7acg9clnq","tag_id":"cldlhfhyw0023ivv70yxd2ey0","_id":"cldlhfhyw0025ivv7ciwi692q"},{"post_id":"cldofhihg0000crv73g4d6in5","tag_id":"cldofhihh0001crv78wsxeo35","_id":"cldofhihj0003crv70mnigjf1"},{"post_id":"cldpu0pmm0000a0v73we29j2z","tag_id":"cldofhihh0001crv78wsxeo35","_id":"cldpu0pmo0001a0v79fpa746d"},{"post_id":"cldrc1wyj000055v718zbbipy","tag_id":"cldofhihh0001crv78wsxeo35","_id":"cldrc1wyl000155v7ch28b3vk"},{"post_id":"cldsgpnnk0000egv78r9w1qr7","tag_id":"cldswbwx9000061v7bfe95mzi","_id":"cldswbwxc000161v7dkhq1wtt"},{"post_id":"cldu4ej0500002av7hzff1jhe","tag_id":"cldu4ej0700012av71rf25xvn","_id":"cldu4ej0a00032av7fpoa6jht"}],"Tag":[{"name":"博客","_id":"cldlhfhyn0005ivv7djne0weg"},{"name":"Android","_id":"cldlhfhyp000divv7erhz641s"},{"name":"Flutter","_id":"cldlhfhyr000rivv7dcku5znt"},{"name":"条形码识别 相机","_id":"cldlhfhys000vivv78sgh160e"},{"name":"TabLayout","_id":"cldlhfhys000zivv7akxm5vwg"},{"name":"数据库 iOS","_id":"cldlhfhys0013ivv75y89hqif"},{"name":"混编Flutter","_id":"cldlhfhyt0017ivv7eo2y1hyq"},{"name":"地图","_id":"cldlhfhyt001bivv7668q14g9"},{"name":"网络请求","_id":"cldlhfhyv001kivv718hbffzn"},{"name":"iOS 自定义View","_id":"cldlhfhyw001qivv7bzms2iqa"},{"name":"iOS","_id":"cldlhfhyw0023ivv70yxd2ey0"},{"name":"30个Swift项目","_id":"cldofhihh0001crv78wsxeo35"},{"name":"完整项目 Gitee","_id":"cldsgpnnn0001egv72f6nd6mw"},{"name":"完整项目 SwiftUI","_id":"cldswbwx9000061v7bfe95mzi"},{"name":"Android OpenGLES","_id":"cldu4ej0700012av71rf25xvn"}]}}