---
title: 面试 操作系统和网络 通关秘籍
date: 2023-01-08 21:26:12
top: false
cover: false
toc: true
mathjax: true
tags:
- 面试题 操作系统 网络
categories:
- 面试 
---

## 1 黑铁
> 网络相关常识。

### 1.1 简单介绍下Https的原理？
> HTTPS是HTTP协议的加密版本，它使用SSL/TLS协议来保护Web通信的安全性。HTTPS基于公开密钥加密和数字证书认证技术，它通过在通信过程中使用SSL/TLS协议来加密HTTP通信内容，从而保证通信数据的隐私性和完整性。<br>
HTTPS的工作原理可以简单描述如下：<br>
1.客户端向服务器发起HTTPS请求。<br>
2.服务器将自己的公钥发送给客户端。<br>
3.客户端使用服务器的公钥对随机生成的对称密钥进行加密。<br>
4.客户端将加密后的对称密钥发送给服务器。<br>
5.服务器使用私钥对接收到的密文进行解密，获得对称密钥。<br>
6.客户端和服务器使用对称密钥进行加密通信。<br>
7.通信过程中，客户端和服务器会互相验证数字证书的合法性，以保证通信的安全性。<br>
HTTPS的核心安全性建立在公开密钥加密和数字证书认证技术之上。其中，公开密钥加密使用两个密钥：公钥和私钥，公钥用来加密数据，私钥用来解密数据。数字证书认证则是指在数据传输过程中使用数字证书来认证通信双方的身份，确保通信的安全性和可靠性。同时，HTTPS还使用SSL/TLS协议来建立安全通信信道，通过加密、压缩、认证等多种技术，保护Web通信过程的安全性和隐私性。

### 1.2 谈谈对Socket的理解?
> Socket（套接字）是一种在计算机之间进行通信的API（应用程序编程接口）。Socket可以理解为一组程序接口，它们使得应用程序可以通过网络连接发送和接收数据。它是实现网络通信的基础。<br>
Socket通常被用于创建客户端和服务器之间的网络连接，它使用IP地址和端口号来唯一标识连接的两端。在客户端和服务器之间建立Socket连接后，它们可以通过Socket传输数据，包括文件、图像、视频和音频等。<br>
在Socket编程中，通常使用TCP（传输控制协议）和UDP（用户数据报协议）两种协议。TCP协议是一种可靠的、面向连接的协议，确保数据的传输和接收的完整性。UDP协议则是一种无连接的协议，它允许数据包在网络上传输时不进行确认，因此传输速度比TCP更快，但也不太可靠。<br>
Socket编程的基本流程是：创建Socket、绑定IP地址和端口号、监听连接请求、接受连接请求、建立连接、发送数据、接收数据、关闭连接。在实际编程中，Socket编程还需要考虑一些网络安全和性能优化的问题。<br>
总的来说，Socket是一种非常重要的网络编程技术，它使得计算机之间的通信变得更加简单、高效和可靠。在现代互联网应用中，Socket已经成为了必不可少的一部分，被广泛应用于各种网络通信场景。

### 1.3 TCP/UDP比较?
> TCP（传输控制协议）和UDP（用户数据报协议）是两种不同的网络传输协议。它们有不同的特点和适用场景，下面是它们的比较：<br>
1.连接方式：TCP是面向连接的协议，需要在传输前进行三次握手建立连接，建立后才能进行数据传输。UDP则是无连接的协议，数据包在发送前不需要建立连接，直接发送即可。<br>
2.数据可靠性：TCP是一种可靠的协议，它保证数据的传输和接收的完整性，确保数据的准确性和可靠性。UDP则是一种不可靠的协议，数据包在网络上传输时不进行确认，因此传输速度比TCP更快，但也不太可靠。<br>
3.数据量和速度：TCP适用于传输大量数据和对数据传输有严格要求的应用场景，如文件传输、电子邮件、网页浏览等。UDP则适用于传输数据量小、对实时性和传输速度有要求的应用场景，如音频、视频、游戏等。<br>
4.带宽控制：TCP采用流量控制和拥塞控制机制，可以根据网络拥塞情况自适应调整发送速度，以避免网络拥塞。UDP则没有拥塞控制机制，发送方会一直以最大速度发送数据，可能会导致网络拥塞。<br>
5.应用场景：TCP适用于对数据传输质量要求比较高的应用场景，如文件传输、远程登录等。UDP则适用于对传输速度和实时性要求比较高的应用场景，如音视频传输、实时游戏等。<br>
总的来说，TCP和UDP各有优缺点，应根据具体的应用场景来选择使用哪种协议。如果需要保证数据传输的可靠性和完整性，应选择TCP协议；如果需要传输速度快、实时性高的数据，应选择UDP协议。

### 1.4 OSI模型和TCP/IP模型？
> 1.OSI模型：
1.1 应用层
1.2 表示层
1.3 回话层
1.4 传输层
1.5 网络层
1.6 数据链路层：物理层负责0、1比特流与物理设备电压高低、光的闪灭之间的互换。
1.7 物理层<br>
2.TCP/IP模型
2.1 应用层
2.2 传输层 （TCP和UDP位于这个层数）
2.3 网络层 （IP协议位于这个层次）
2.4 网络接口层

### 1.5 TCP协议有哪些？
> SMTP: 电子邮件
telnet: 远程终端接入
http: 万维网
ftp: 文件传输 

### 1.6 UDP协议有哪些？
> dns: 域名转换
tftp: 文件传输
snmp: 网络管理
nfs: 远程文件服务器

### 1.7 常见的状态码？
> 1xx：指示信息——表示请求已接收，继续处理。
2xx：成功——表示请求已被成功接收、理解、接受。
3xx：重定向——要完成请求必须进行更进一步的操作。
4xx：客户端错误——请求有语法错误或请求无法实现。
5xx：服务器端错误——服务器未能实现合法的请求。

## 2 青铜
> 网络相关原理。

### 2.1 TCP连接的建立？
> 建立请务必回答是：三次握手。
1.第一次握手：客户端发送连接请求报文段SYN 给服务端。
2.第二次握手：服务端收到SYN报文段，发送给客户端ACK确认报文段和SYN报文段，相当于服务端确认了
3.第三次握手： 客户端收到服务端的SYN+ACK报文段，最后向服务端再次发生一个ACK确认报文段。

### 2.2 TCP连接的终止？
> 终止请务必回答是：四次挥手。
1.第一次：主动方（这里可以是客户端或服务端，谁主动都行）发送一个FIN和ACK报文段给被动方。
2.第二次：被动方发送一个ACK报文段。
3.第三次：被动方等了一下，再次发送一个FIN和ACK报文段。
4.第四次：主动方发送ACK报文段。<br>
为什么要等一下？
被动方数据没发完，等发完了，再关闭。

## 3 白银
> 操作系统相关常识。

### 3.1 什么时候会发生死锁?
> 死锁指的是多个进程或线程因为互相等待资源而陷入一种无法继续执行的状态，导致系统无法前进。以下是死锁发生的四个必要条件：<br>
1.互斥条件：资源只能被一个进程或线程占用，其他的进程或线程必须等待该资源释放。<br>
2.请求与保持条件：进程或线程持有一个资源并请求其他资源，但在等待其他资源的同时仍继续占有已有资源。<br>
3.不剥夺条件：资源不能被其他进程或线程强行抢占，只能由持有该资源的进程或线程主动释放。<br>
4.循环等待条件：存在一种进程或线程的等待链，每个进程或线程都在等待下一个进程或线程所持有的资源。<br>
当这四个条件同时满足时，就可能会发生死锁。

### 3.2 不同架构的机器有何不同（如x86等）
> 不同架构的机器指的是在计算机硬件和指令集设计上的不同。常见的计算机架构有x86、ARM、MIPS、PowerPC等。这些不同的架构在计算机硬件和指令集方面的设计不同，因此在使用和编程时会有一些差异。<br>
下面是一些不同架构的机器的主要特点和差异：<br>
x86架构：x86是目前PC和服务器领域最广泛使用的架构之一，其指令集包括x86-16、x86-32和x86-64。x86架构的主要特点是指令集复杂，支持大量的寄存器和广泛的指令集，具有高性能和灵活性，但也相对较复杂。<br>
ARM架构：ARM架构主要应用于嵌入式系统和移动设备领域，其指令集比x86简单，更加节能，具有低功耗、高效率的特点。ARM架构的处理器在功耗、成本和可靠性方面表现良好，因此广泛用于手机、平板电脑、智能家居和汽车等领域。<br>
MIPS架构：MIPS架构主要应用于嵌入式系统和网络设备领域，具有高性能、低功耗的特点。MIPS架构的处理器在网络处理、路由器、交换机等设备中应用广泛。<br>
PowerPC架构：PowerPC架构是IBM、苹果和摩托罗拉等公司共同开发的，主要应用于服务器和嵌入式系统领域，具有高性能、可靠性和可扩展性的特点。PowerPC架构的处理器在高性能计算、工业控制和航空航天等领域应用广泛。<br>
不同架构的机器在使用和编程时需要考虑其特点和差异，尤其是在跨平台开发和移植软件时更为重要。例如，跨平台开发需要考虑不同的编译器和库的兼容性，移植软件需要考虑不同架构的处理器和操作系统的支持情况。因此，在进行跨平台开发和移植软件时，需要对不同架构的机器有一定的了解。

### 4.3 操作系统的四个特性？
> 并发： 同一段时间内多个程序执行(注意区别并行和并发，前者是同一时刻的多个事件，后者是同一时间段内的多个事件)<br>
共享： 系统中的资源可以被内存中多个并发执行的进线程共同使用<br>
虚拟： 通过时分复用（如分时系统）以及空分复用（如虚拟内存）技术实现把一个物理实体虚拟为多个<br>
异步： 系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进

## 4 黄金
> 操作系统相关原理。

### 4.1 操作系统层面上，线程可以加哪些锁?
> 线程在操作系统层面上可以加如下几种锁：<br>
1.互斥锁（Mutex）：一种最常见的锁类型，用于确保在任何时候只有一个线程可以访问共享资源。当一个线程获得互斥锁时，其他线程就必须等待直到该线程释放锁。<br>
2.读写锁（Read-Write Lock）：允许多个线程同时访问同一个资源，但是对于写入操作，必须要保证只有一个线程在访问。读写锁可以提高并发性能，因为读操作通常比写操作更频繁，读写锁可以允许多个线程同时进行读操作。<br>
3.条件变量（Condition Variable）：用于在线程之间同步共享资源。当一个线程需要等待某个条件发生时，可以通过条件变量进行等待，而不是通过轮询来等待条件发生。<br>
4.信号量（Semaphore）：一种计数器，用于控制对共享资源的访问。当一个线程需要访问共享资源时，它必须先获得信号量。如果信号量的值为0，线程就必须等待直到其他线程释放资源并增加信号量的值。<br>
以上这些锁都可以用于线程之间同步和保证对共享资源的访问。不同类型的锁适用于不同的情况，选择合适的锁类型可以提高程序的性能和并发性能。

### 4.2 栈在系统中的方向是怎样的？为什么？
> 栈（stack）是一种后进先出（LIFO）的数据结构，它通常被用于存储和管理函数的调用和返回，以及存储局部变量和临时变量等。在计算机系统中，栈的方向通常是从高地址向低地址增长的，也就是说，栈顶的地址比栈底的地址低。<br>
这种栈向低地址增长的方向是由计算机体系结构的实现决定的。当一个函数被调用时，它的返回地址和一些参数需要被压入栈中，以便在函数执行完成后能够正确地返回到调用者。由于栈是从高地址向低地址增长的，所以每次压入栈中的数据都会被放置在已有数据的顶部，这样可以保证最新的数据总是在栈顶，而最老的数据总是在栈底。当函数返回时，栈顶的数据会被弹出，返回地址被取出并跳转到该地址，这样函数调用的堆栈就能够正确地管理。<br>
此外，由于栈的方向是固定的，所以在访问栈中的数据时，程序可以直接使用偏移地址和栈指针来访问，而不需要进行任何复杂的计算。这样可以提高访问速度和效率，并且使得栈在计算机体系结构中的实现变得更加简单和可靠。<br>
总之，栈在计算机系统中的方向通常是从高地址向低地址增长的，这是由计算机体系结构的实现决定的。这种方向使得栈能够有效地管理函数调用和返回，并且能够快速地访问栈中的数据。

### 4.3 操作系统进程间通信有哪些方法？
> 操作系统进程间通信的方法主要包括以下几种：<br>
1.管道（Pipe）：管道是一种半双工的通信方式，只能在具有公共祖先-子孙进程之间使用，只能用于相互通信的两个进程。通常将管道定义为文件描述符，一个进程写入数据到管道，另一个进程从管道中读取数据。<br>
2.消息队列（Message Queue）：消息队列是消息的链表，存在于内核中，通常由进程名和标识符来标识。不同进程可以通过向队列发送消息进行通信，可以实现任意进程之间的通信。<br>
3.共享内存（Shared Memory）：共享内存是最快的一种IPC方式，多个进程可以访问同一个物理内存，从而实现高速数据传输。但需要注意共享内存的访问必须同步，否则会产生竞争条件。<br>
4.信号量（Semaphore）：信号量是用来保证同步的一种方式。在访问共享资源时，必须先获得信号量，操作完成后再释放信号量。可以通过信号量来实现多个进程的互斥、同步和通信等。<br>
5.套接字（Socket）：套接字是一种网络通信协议，也可以用于进程间通信。通过套接字可以实现不同主机或同一主机上不同进程之间的通信。<br>
上述进程间通信方法各有优缺点，开发者可以根据自己的需求来选择合适的通信方式。

### 4.4 进程调度算法？
> 1.先来先服务调度算法FCFS： 既可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度；因此对于长作业比较有利；
2.短作业优先调度算法SJF： 作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱 ；
3.高响应比算法HRN： 响应比=(等待时间+要求服务时间)/要求服务时间；
4.时间片轮转调度RR： 按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ;
5.多级反馈队列调度算法： 目前公认较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按FCFS放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部……只有当前一个队列为空的时候才会去调度下一个队列的进程。

## 5 铂金

## 6 钻石

## 7 大师

## 8 宗师

## 9 王者
